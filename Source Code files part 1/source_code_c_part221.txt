ROR)
	{
		hr = LookupWdmClass(pCtx,
							Values[0].bstrVal,
							&WdmClass);
		
		
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// We need to pull out the properties from the instance
			// passed to us, do any mapping to WDM properties and then
			// set them in the WDM instance
			//
            hr = WdmClass->GetIndexByCimRelPath(Values[1].bstrVal,
												&RelPathIndex);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = WdmClass->PutInstance(pCtx,
										   RelPathIndex,
										   pInst);
			}
			
		}
		
		VariantClear(&Values[0]);
		VariantClear(&Values[1]);
	}
	
    pResultsSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL,NULL);
	
	return(hr);
}
SCODE CClassPro::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}

CWdmClass *CClassPro::FindExistingWdmClass(
	PWCHAR CimClassName
	)
{
	
	CWdmClass *WdmClass;

	//
	// This routine assumes any sync mechanism has been done outside of
	// this routine
	//
    WdmClass = WdmClassHead;
    while (WdmClass != NULL)
    {
        if (WdmClass->ClaimCimClassName(CimClassName))
        {
            //
            // We found an existing test services for this class.
            //
            return(WdmClass);
        }
        WdmClass = WdmClass->GetNext();
    }
	return(NULL);
}

HRESULT CClassPro::LookupWdmClass(
    IWbemContext *pCtx,
    const BSTR CimClassName,
    CWdmClass **WdmClassPtr
    )
{
    HRESULT hr;
    CWdmClass *WdmClass, *OtherWdmClass;
            
    WmipAssert(CimClassName != NULL);
    WmipAssert(WdmClassPtr != NULL);
    
    //
    // Look up the class name and find the Wdm Test Services
    // class that represents it. 
    //

	EnterCritSection();
	WdmClass = FindExistingWdmClass(CimClassName);
	LeaveCritSection();
	
	if (WdmClass != NULL)
	{
		//
		// CONSIDER: Refresh instances from WDM back into CIM
		//
		*WdmClassPtr = WdmClass;
		return(WBEM_S_NO_ERROR);
	}
	        
    //
    // If the WDM test services has not yet been initialized for this
    // CDM diagnostic classes then go ahead and do so
    //
    WdmClass = new CWdmClass();

	hr = WdmClass->InitializeSelf(pCtx, CimClassName);

	if (hr == WBEM_S_NO_ERROR)
	{

		//
		// Now check to see if another thread created and inserted the
		// test services for the class while we were trying to
		// initialize it. Since we want only one test services we throw
		// ours away and use the other
		//
		EnterCritSection();
		OtherWdmClass = FindExistingWdmClass(CimClassName);

		if (OtherWdmClass == NULL)
		{
			//
			// Horray, we win do insert our own test into list
			//
			WdmClass->InsertSelf(&WdmClassHead);
			LeaveCritSection();
			
			hr = WdmClass->RemapToCimClass(pCtx);

			//
			// Decrement the counter to indicate that instances are
			// available. This refcount was assigned in the constructor
			//
			WdmClass->DecrementMappingInProgress();
			
			if (hr != WBEM_S_NO_ERROR)
			{
				WmipDebugPrint(("CDMPROV: Inited failed %x for %p for %ws\n",
								hr, WdmClass, CimClassName));
			}
		} else {
			//
			// We lost, so use existing test services
			//
			WmipDebugPrint(("CDMPROV: WdmClass %p lost insertion race to %p\n",
							WdmClass, OtherWdmClass));
			LeaveCritSection();
			delete WdmClass;
			WdmClass = OtherWdmClass;
		}

		*WdmClassPtr = WdmClass;

	}
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\cimmap\text.h ===
//***************************************************************************
//
//  Text.h
//
//  Module: CDM Provider
//
//  Purpose: Define fixed class, property  and qualifier names
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#define WDM_SHADOW_CLASS     L"WdmShadowClass"
#define CIM_MAPPING_CLASS    L"CimMappingClass"
#define WDM_MAPPING_CLASS    L"WdmMappingClass"
#define WDM_MAPPING_PROPERTY L"WdmMappingProperty"
#define CIM_MAPPING_PROPERTY L"CimMappingProperty"

#define DERIVED_CLASS_TYPE L"DerivedClassType"
#define CONCRETE           L"Concrete"
#define NONCONCRETE        L"NonConcrete"

#define VALUES             L"Values"
#define VALUE_MAP          L"ValueMap"

#define PNP_DEVICE_ID     L"PnPDeviceId"
#define CAPTION           L"Caption"
#define DESCRIPTION       L"Description"
#define NAME              L"Name"
#define STATUS            L"Status"
#define OK                L"OK"

#define SUPERCLASS        L"__Superclass"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\mofapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    mofapi.c

Abstract:
    
    WMI MOF access apis

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "common.h"
#include "request.h"

ULONG 
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    )
/*++

Routine Description:

    ANSI thunk to WMIMofEnumerateResourcesA

--*/
{
    ULONG Status;
    PMOFRESOURCEINFOW MofResourceInfoUnicode;
    PMOFRESOURCEINFOA MofResourceInfoAnsi;
    PCHAR AnsiPtr;
    PCHAR Ansi;
    ULONG i, AnsiSize, AnsiStructureSize;
    ULONG MofResourceCountUnicode;
    ULONG AnsiLen;
    ULONG AnsiImagePathSize;
    ULONG AnsiResourceNameSize;
    
    EtwpInitProcessHeap();
    
    Status = WmiMofEnumerateResourcesW(MofResourceHandle,
                                       &MofResourceCountUnicode,
                                       &MofResourceInfoUnicode);
                                   
    if (Status == ERROR_SUCCESS)
    {
        //
        // Walk the unicode MOFRESOURCEINFOW to determine the ansi size needed
        // for all of the ansi MOFRESOURCEINFOA structures and strings. We 
        // determine the entire size and allocate a single block that holds
        // all of it since that is what WMIMofEnumerateResourceInfoW does.

        AnsiStructureSize = MofResourceCountUnicode * sizeof(MOFRESOURCEINFOA);
        AnsiSize = AnsiStructureSize;
        for (i = 0; i < MofResourceCountUnicode; i++)
        {
            Status = AnsiSizeForUnicodeString(MofResourceInfoUnicode[i].ImagePath,
                                              &AnsiImagePathSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }
                        
            Status = AnsiSizeForUnicodeString(MofResourceInfoUnicode[i].ResourceName,
                                              &AnsiResourceNameSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }
                        
            AnsiSize += AnsiImagePathSize + AnsiResourceNameSize;
        }
        
        MofResourceInfoAnsi = EtwpAlloc(AnsiSize);
        if (MofResourceInfoAnsi != NULL)
        {
            AnsiPtr = (PCHAR)((PUCHAR)MofResourceInfoAnsi + AnsiStructureSize);
            for (i = 0; i < MofResourceCountUnicode; i++)
               {
                MofResourceInfoAnsi[i].ResourceSize = MofResourceInfoUnicode[i].ResourceSize;
                MofResourceInfoAnsi[i].ResourceBuffer = MofResourceInfoUnicode[i].ResourceBuffer;

                MofResourceInfoAnsi[i].ImagePath = AnsiPtr;
                Status = UnicodeToAnsi(MofResourceInfoUnicode[i].ImagePath, 
                                       &MofResourceInfoAnsi[i].ImagePath,
                                       &AnsiLen);
                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;

                MofResourceInfoAnsi[i].ResourceName = AnsiPtr;
                Status = UnicodeToAnsi(MofResourceInfoUnicode[i].ResourceName, 
                                       &MofResourceInfoAnsi[i].ResourceName,
                                       &AnsiLen);
                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;

            }
            
            if (Status == ERROR_SUCCESS)
            {
                try
                {
                    *MofResourceInfo = MofResourceInfoAnsi;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                    EtwpFree(MofResourceInfoAnsi);
                }
            }
         } else {
            //
            // Not enough memory for ansi thunking so free unicode 
               // mof class info and return an error.
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

Done:        
        WmiFreeBuffer(MofResourceInfoUnicode);
    }    
    
    SetLastError(Status);
    return(Status);
}

ULONG 
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    )
/*++

Routine Description:

    This routine will enumerate one or all of the MOF resources that are 
    registered with WMI. 

Arguments:

    MofResourceHandle is reserved and must be 0
        
    *MofResourceCount returns with the count of MOFRESOURCEINFO structures
        returned in *MofResourceInfo.
            
    *MofResourceInfo returns with a pointer to an array of MOFRESOURCEINFO
        structures. The caller MUST call WMIFreeBuffer with *MofResourceInfo
        in order to ensure that there are no memory leaks.
        

Return Value:

    ERROR_SUCCESS or an error code

--*/        
{
    ULONG Status, SubStatus;
    PWMIMOFLIST MofList;
    ULONG MofListCount;
    ULONG MRInfoSize;
    ULONG MRCount;
    PWCHAR MRBuffer;
    PMOFRESOURCEINFOW MRInfo;
    PWCHAR RegPath, ResName, ImagePath;
    PWMIMOFENTRY MofEntry;
    ULONG i, j;
    PWCHAR *LanguageList;
    ULONG LanguageCount;
    BOOLEAN b;
    ULONG HeaderLen;
    ULONG MRBufferRemaining;
    PWCHAR ResourcePtr;
    ULONG BufferUsed;   
    PWCHAR ImagePathStatic;
    
    EtwpInitProcessHeap();

    if (MofResourceHandle != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    ImagePathStatic = EtwpAlloc(MAX_PATH * sizeof(WCHAR));
    if (ImagePathStatic != NULL)
    {   
        *MofResourceInfo = NULL;

        Status = EtwpGetMofResourceList(&MofList);

        if (Status == ERROR_SUCCESS) 
        {
            //
            // Ok, we have got a valid list of mofs. Now we need to 
            // loop over them all and convert the regpaths into image
            // paths
            //

            Status = EtwpGetLanguageList(&LanguageList,
                                         &LanguageCount);

            if (Status == ERROR_SUCCESS)
            {
                MofListCount = MofList->MofListCount;


                //
                // Take a guess as to the size of the buffer needed to
                // satisfy the complete list of mof resources
                //
                HeaderLen = (MofListCount * (LanguageCount+1)) *
                            sizeof(MOFRESOURCEINFOW);
    #if DBG
                MRInfoSize = HeaderLen + 2 * (MAX_PATH * sizeof(WCHAR));
    #else
                MRInfoSize = HeaderLen + (2*MofListCount * (MAX_PATH * sizeof(WCHAR)));
    #endif
                MRInfo = NULL;

                do
                {
    TryAgain:                   
                    if (MRInfo != NULL)
                    {
                        EtwpDebugPrint(("WMI: MofList was too small, retry 0x%x bytes\n",
                                        MRInfoSize));
                        EtwpFree(MRInfo);
                    }

                    MRInfo = EtwpAlloc(MRInfoSize);

                    if (MRInfo != NULL)
                    {
                        memset(MRInfo, 0, MRInfoSize);
                        MRBuffer = (PWCHAR)OffsetToPtr(MRInfo, HeaderLen);
                        MRBufferRemaining = (MRInfoSize - HeaderLen) / sizeof(WCHAR);

                        MRCount = 0;
                        for (i = 0; i < MofListCount; i++)
                        {
                            //
                            // Pull out thee image path and resource names
                            //
                            MofEntry = &MofList->MofEntry[i];
                            RegPath = (PWCHAR)OffsetToPtr(MofList, MofEntry->RegPathOffset);
                            ResName = (PWCHAR)OffsetToPtr(MofList, MofEntry->ResourceOffset);
                            if (*ResName != 0)
                            {
                                if ((MofEntry->Flags & WMIMOFENTRY_FLAG_USERMODE) == 0)
                                {
                                    ImagePath = EtwpRegistryToImagePath(ImagePathStatic,
                                        RegPath);

                                } else {
                                    ImagePath = RegPath;
                                }

                                if (ImagePath != NULL)
                                {
                                    //
                                    // If we've got a valid image path then
                                    // out it and the resource name into the
                                    // output buffer
                                    //
                                    MRInfo[MRCount].ImagePath = MRBuffer;
                                    b = EtwpCopyMRString(MRBuffer,
                                        MRBufferRemaining,
                                        &BufferUsed,
                                        ImagePath);
                                    if (! b)
                                    {
                                        //
                                        // The buffer was not big enough so we
                                        // double the size used and try again
                                        //
                                        MRInfoSize *= 2;
                                        goto TryAgain;
                                    }
                                    MRBuffer += BufferUsed;
                                    MRBufferRemaining -= BufferUsed;

                                    EtwpDebugPrint(("WMI: Add ImagePath %p (%ws) to MRList at position %d\n",
                                                    MRInfo[MRCount].ImagePath,
                                                    MRInfo[MRCount].ImagePath,
                                                    MRCount));

                                    MRInfo[MRCount].ResourceName = MRBuffer;
                                    ResourcePtr = MRBuffer;
                                    b = EtwpCopyMRString(MRBuffer,
                                        MRBufferRemaining,
                                        &BufferUsed,
                                        ResName);
                                    if (! b)
                                    {
                                        //
                                        // The buffer was not big enough so we
                                        // double the size used and try again
                                        //
                                        MRInfoSize *= 2;
                                        goto TryAgain;
                                    }
                                    MRBuffer += BufferUsed;
                                    MRBufferRemaining -= BufferUsed;

                                    EtwpDebugPrint(("WMI: Add Resource %p (%ws) to MRList at position %d\n",
                                                    MRInfo[MRCount].ResourceName,
                                                    MRInfo[MRCount].ResourceName,
                                                    MRCount));


                                    MRCount++;

                                    for (j = 0; j < LanguageCount; j++)
                                    {             
                                        MRInfo[MRCount].ImagePath = MRBuffer;
                                        SubStatus = EtwpBuildMUIPath(MRBuffer,
                                            MRBufferRemaining,
                                            &BufferUsed,
                                            ImagePath,
                                            LanguageList[j],
                                            &b);


                                        if (SubStatus == ERROR_SUCCESS) 
                                        {
                                            if (! b)
                                            {
                                                //
                                                // The buffer was not big enough so we
                                                // double the size used and try again
                                                //
                                                MRInfoSize *= 2;
                                                goto TryAgain;
                                            }
                                            MRBuffer += BufferUsed;
                                            MRBufferRemaining -= BufferUsed;

                                            EtwpDebugPrint(("WMI: Add ImagePath %p (%ws) to MRList at position %d\n",
                                                MRInfo[MRCount].ImagePath,
                                                MRInfo[MRCount].ImagePath,
                                                MRCount));

                                            //
                                            // We did find a MUI resource
                                            // so add it to the list
                                            //
                                            MRInfo[MRCount].ResourceName = ResourcePtr;
                                            EtwpDebugPrint(("WMI: Add Resource %p (%ws) to MRList at position %d\n",
                                                MRInfo[MRCount].ResourceName,
                                                MRInfo[MRCount].ResourceName,
                                                MRCount));
                                            MRCount++;
                                        }                                    
                                    }
                                }
                            }
                        }
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } while (FALSE);                

                //
                // Free up memory used to hold the language list
                //
                for (i = 0; i < LanguageCount; i++)
                {
                    EtwpFree(LanguageList[i]);
                }
                EtwpFree(LanguageList);

                *MofResourceCount = MRCount;
                *MofResourceInfo = MRInfo;
            }
            EtwpFree(MofList);      
        }
        EtwpFree(ImagePathStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
            
    SetLastError(Status);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\chunk.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    chunk.c

Abstract:
    
    This routine will manage allocations of chunks of structures

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include <stdio.h>

#define EtwpEnterCriticalSection() EtwpEnterPMCritSection()
#define EtwpLeaveCriticalSection() EtwpLeavePMCritSection()

//
// include implementation of chunk managment code
#include "chunkimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\intrnldp.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    intrnldp.c

Abstract:

    Implements WMI internal data provider

Author:

    21-Feb-1998 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "wmidata.h"
#include <cfgmgr32.h>

#define INSTANCE_INFO_GUID_INDEX 0
#define ENUMERATE_GUIDS_GUID_INDEX 1
#define DEFAULT_GUID_COUNT        100

GUID EtwpInternalGuidList[] = 
{
    INSTANCE_INFO_GUID,
    ENUMERATE_GUIDS_GUID
};

#define EtwpInternalGuidCount  (sizeof(EtwpInternalGuidList) / sizeof(GUID))

PWCHAR GuidToWString(
    PWCHAR s,
    LPGUID piid
    )
{
    swprintf(s, (L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}

ULONG EtwpFindGuid(
    LPGUID Guid
    )
{
    ULONG i;
    
    for (i = 0; i < EtwpInternalGuidCount; i++)
    {
        if (memcmp(Guid, &EtwpInternalGuidList[i], sizeof(GUID)) == 0)
        {
            break;
        }
    }
    return(i);
}

typedef
DWORD
(*PCMGETDEVNODEREGISTRYPROPERTYW)(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
typedef
DWORD
(*PCMLOCATEDEVNODEW)(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
     
typedef
DWORD
(*PCMLOCATEDEVNODEA)(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
#ifdef UNICODE
#define PCMLOCATEDEVNODE PCMLOCATEDEVNODEW
#else
#define PCMLOCATEDEVNODE PCMLOCATEDEVNODEA
#endif

     
void EtwpGetDevInstProperty(
    IN DEVINST DevInst,
    IN ULONG Property,
    IN OUT PBOOLEAN BufferFull,
    IN OUT PUCHAR *OutBuffer,
    IN OUT PULONG BufferLeft,
    IN OUT PULONG BufferNeeded,
    IN PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty
    )
{
    PWCHAR WCharPtr;
    PUCHAR PropertyBuffer;
    ULONG PropertyBufferLength;
    ULONG Type;
    ULONG Status;
    ULONG BufferUsed;
    ULONG Size;
#ifdef MEMPHIS
    ULONG PropertyBufferLengthAnsi;
    PCHAR PropertyBufferAnsi;
    CHAR AnsiBuffer[MAX_PATH];
#endif
    
#ifdef MEMPHIS
    PropertyBufferAnsi = AnsiBuffer;
    PropertyBufferLengthAnsi = sizeof(AnsiBuffer);
    Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                             Property,
                                             &Type,
                                             PropertyBufferAnsi,
                                             &PropertyBufferLengthAnsi,
                                             0);
    if (Status == CR_BUFFER_SMALL)
    {
        PropertyBufferAnsi = EtwpAlloc(PropertyBufferLengthAnsi);
        if (PropertyBufferAnsi != NULL)
        {
            Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                                   Property,
                                                   &Type,
                                                   PropertyBufferAnsi,
                                                   &PropertyBufferLengthAnsi,
                                                   0);            
        } else {
            Status = CR_OUT_OF_MEMORY;
        }
    }
    
    if (Status == CR_SUCCESS)
    {
        if (UnicodeSizeForAnsiString(PropertyBufferAnsi,
                                     &Size) != ERROR_SUCCESS)
        {   
            Status = CR_FAILURE;
        }
    }
#endif

    if ((*BufferFull) || (*BufferLeft == 0))
    {
        PropertyBufferLength = 0;
        PropertyBuffer = NULL;
    } else {
        PropertyBufferLength = *BufferLeft - sizeof(USHORT);
        PropertyBuffer = *OutBuffer + sizeof(USHORT);
    }
    
#ifdef MEMPHIS
    if (Status == CR_SUCCESS)
    {
        if (PropertyBufferLength >= Size)
        {
            if (AnsiToUnicode(PropertyBufferAnsi,
                              (PWCHAR *)&PropertyBuffer) != ERROR_SUCCESS)
            {
                Status = CR_FAILURE;
            }
        } else {
            Status = CR_BUFFER_SMALL;
        }
        PropertyBufferLength = Size;        
    }
    
    if (PropertyBufferAnsi != AnsiBuffer)
    {
        EtwpFree(PropertyBufferAnsi);
    }
#else
    Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                             Property,
                                             &Type,
                                             PropertyBuffer,
                                             &PropertyBufferLength,
                                             0);
#endif

    BufferUsed = PropertyBufferLength + sizeof(USHORT);
    if (Status == CR_SUCCESS) 
    {
        PropertyBuffer -= sizeof(USHORT);
        *((PUSHORT)PropertyBuffer) = (USHORT)PropertyBufferLength;
        *BufferLeft -= BufferUsed;
        *OutBuffer += BufferUsed;
        *BufferNeeded += BufferUsed;
    } else if (Status == CR_BUFFER_SMALL) {
        *BufferNeeded += BufferUsed;                
        *BufferFull = TRUE;
    } else {
        *BufferNeeded += 2;
        if ((! *BufferFull) && (*BufferLeft >= sizeof(USHORT)))
        {
            PropertyBuffer -= sizeof(USHORT);
            *((PUSHORT)PropertyBuffer) = 0;
            *BufferLeft -= sizeof(USHORT);
            *OutBuffer += sizeof(USHORT);
        } else {
            *BufferFull = TRUE;
        }
    }    
}


ULONG EtwpGetDevInstInfo(
    PWCHAR DevInstName,
    ULONG MaxSize,
    PUCHAR OutBuffer,
    ULONG *RetSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{
    PUCHAR Buffer;
    DEVINST DevInst;
    ULONG Status;
    ULONG BufferNeeded;
    ULONG BufferLeft;
    BOOLEAN BufferFull;
    PWCHAR WCharPtr;
#ifdef MEMPHIS
    PCHAR AnsiDevInstName;
#endif

    // TODO: Memphis string translations
    
#ifdef MEMPHIS
    AnsiDevInstName = NULL;
    Status = UnicodeToAnsi(DevInstName,
                           &AnsiDevInstName,
                           NULL);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = (*CMLocateDevNode)(&DevInst,
                                    AnsiDevInstName,
                                    CM_LOCATE_DEVNODE_NORMAL);
        EtwpFree(AnsiDevInstName);
    }
#else    
    Status = (*CMLocateDevNode)(&DevInst,
                               DevInstName,
                               CM_LOCATE_DEVNODE_NORMAL);
#endif
    if (Status == CR_SUCCESS)
    {
        BufferFull = (MaxSize == 0);
        BufferNeeded = 0;
        BufferLeft = MaxSize;
        
        WCharPtr = (PWCHAR)OutBuffer;

        EtwpGetDevInstProperty(DevInst,
                               CM_DRP_FRIENDLYNAME,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        EtwpGetDevInstProperty(DevInst,
                               CM_DRP_DEVICEDESC,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        EtwpGetDevInstProperty(DevInst,
                               CM_DRP_LOCATION_INFORMATION,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        EtwpGetDevInstProperty(DevInst,
                               CM_DRP_MFG,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        EtwpGetDevInstProperty(DevInst,
                               CM_DRP_SERVICE,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
               
        Status = BufferFull ? ERROR_INSUFFICIENT_BUFFER : ERROR_SUCCESS;
        *RetSize = BufferNeeded;
    } else {
        Status = ERROR_INVALID_DATA;
    }                               
    
    return(Status);
}

PWCHAR EtwpCountedToSzAndTrim(
    PWCHAR InNamePtr,
    PWCHAR OutNameBuffer,
    ULONG OutNameSizeInBytes,
    BOOLEAN Trim
    )
{
    PWCHAR WCharPtr, DevInstName;
    ULONG DevInstNameLength;
    ULONG i;
        
    WCharPtr = InNamePtr;
    DevInstNameLength = *WCharPtr++;
    
    if (DevInstNameLength >= OutNameSizeInBytes)
    {
        DevInstName = EtwpAlloc( DevInstNameLength + sizeof(USHORT));
    } else {
        DevInstName = OutNameBuffer;
    }

	if (DevInstName != NULL)
	{
		memcpy(DevInstName, WCharPtr, DevInstNameLength);
		DevInstNameLength /= sizeof(WCHAR);
		DevInstName[DevInstNameLength--] = UNICODE_NULL;
    
		if (Trim)
		{
			//
			// Trim off the final _xxx from the Instance name to convert it to
			// the Device Instance Name
			WCharPtr = DevInstName + DevInstNameLength;
			i = DevInstNameLength;
			while ((*WCharPtr != L'_') && (i-- != 0)) 
			{
				WCharPtr--;
			}
			*WCharPtr = UNICODE_NULL;
		}
    }
    
    return(DevInstName);
}

ULONG EtwpQuerySingleInstanceInfo(
    PWNODE_SINGLE_INSTANCE Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetWnodeSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{
    WCHAR DevInstBuffer[MAX_PATH];
    PWCHAR WCharPtr;
    PWCHAR DevInstName;
    ULONG DevInstNameLength;
    ULONG i;
    ULONG BufferSize;
    ULONG MaxBufferSize;
    ULONG WnodeNeeded;
    PUCHAR Buffer;
    ULONG Status;
    
    EtwpAssert(! (Wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES));
    EtwpAssert(Wnode->OffsetInstanceName < Wnode->WnodeHeader.BufferSize);
    EtwpAssert(Wnode->DataBlockOffset <= MaxWnodeSize);    
    
    WCharPtr = (PWCHAR)((PUCHAR)Wnode + Wnode->OffsetInstanceName);
    DevInstName =  EtwpCountedToSzAndTrim(WCharPtr,
                                          DevInstBuffer,
                                          MAX_PATH * sizeof(WCHAR),
                                          TRUE);

	if (DevInstName != NULL)
	{
		Buffer = (PUCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
		MaxBufferSize = MaxWnodeSize - Wnode->DataBlockOffset;

		BufferSize = 0;
		Status = EtwpGetDevInstInfo(DevInstName,
                                MaxBufferSize,
                                Buffer,
                                &BufferSize,
                                CMLocateDevNode,
                                CMGetDevNodeRegistryProperty);
    
		WnodeNeeded = Wnode->DataBlockOffset + BufferSize;
    
		if (Status == ERROR_SUCCESS)
		{
			WmiInsertTimestamp((PWNODE_HEADER)Wnode);
			Wnode->WnodeHeader.BufferSize = WnodeNeeded;
			Wnode->SizeDataBlock = BufferSize;
			*RetWnodeSize = WnodeNeeded;
		} else if (Status == ERROR_INSUFFICIENT_BUFFER) {
			EtwpAssert(MaxWnodeSize > sizeof(WNODE_TOO_SMALL));
           
			Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
			((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = WnodeNeeded;
			Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
			*RetWnodeSize = sizeof(WNODE_TOO_SMALL);
			Status = ERROR_SUCCESS;
		}
    
		if (DevInstName != DevInstBuffer)
		{
			EtwpFree(DevInstName);
		}
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}
    
    return(Status);    
}

GUID PnPDeviceIdGuid = DATA_PROVIDER_PNPID_GUID;

ULONG EtwpComputeInstanceCount(
    PWNODE_ALL_DATA WAD,
    ULONG WnodeSize,
    PULONG InstanceCount
    )
{
    ULONG Linkage;
    ULONG Count = 0;
    
    do
    {
        Linkage = WAD->WnodeHeader.Linkage;
        
        if (Linkage > WnodeSize)
        {
            EtwpDebugPrint(("WMI: Badly formed Wnode %x\n", WAD));
            EtwpAssert(FALSE);
            return(ERROR_INVALID_DATA);
        }

        Count += WAD->InstanceCount;
        
        WnodeSize -= Linkage;
        WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, WAD->WnodeHeader.Linkage);
    } while (Linkage != 0);            
    
    *InstanceCount = Count;
    return(ERROR_SUCCESS);
}


ULONG EtwpQueryAllInstanceInfo(
    PWNODE_ALL_DATA OutWAD,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{

    ULONG Status;
    PWNODE_ALL_DATA PnPIdWAD;
    WMIHANDLE PnPIdHandle;
    ULONG Size, Retries;
    ULONG InstanceCount;
    POFFSETINSTANCEDATAANDLENGTH OutOffsetNameLenPtr;
    ULONG OutOffsetInstanceNameOffsets;
    PULONG OutOffsetInstanceNameOffsetsPtr;
    ULONG OutSizeNeeded, OutInstanceCounter = 0;
    BOOLEAN OutIsFull = FALSE;
    ULONG OutNameOffset;
    ULONG OutNameSizeNeeded;
    ULONG OutSizeLeft;
    ULONG OutDataSize;
    PWCHAR OutNamePtr;
    PWNODE_ALL_DATA InWAD;
    BOOLEAN IsFixedSize;
    PWCHAR InNamePtr;
    PWCHAR InPnPIdPtr;
    ULONG FixedNameSize;
    ULONG i;
    PWCHAR DevInstName;
    WCHAR DevInstBuffer[MAX_PATH];    
    POFFSETINSTANCEDATAANDLENGTH InOffsetNameLenPtr;
    PUCHAR Buffer;    
    ULONG Linkage;
    PULONG InOffsetInstanceNamePtr;
    PWNODE_TOO_SMALL WTS;
    ULONG OutDataOffset;
    
    //
    // Obtain the complete list of device instance ids
    //
    Status = WmiOpenBlock(&PnPDeviceIdGuid, WMIGUID_QUERY, &PnPIdHandle);
    if (Status == ERROR_SUCCESS)
    {
        Size = 0x1000;
        Retries = 0;
        PnPIdWAD = NULL;
        do
        {
            if (PnPIdWAD != NULL)
            {
                EtwpFree(PnPIdWAD);
            }
            
            PnPIdWAD = (PWNODE_ALL_DATA)EtwpAlloc(Size);
            
            if (PnPIdWAD != NULL)
            {
                Status = WmiQueryAllDataW(PnPIdHandle,
                                          &Size,
                                          PnPIdWAD);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } while ((Status == ERROR_INSUFFICIENT_BUFFER) && 
                 (Retries++ < 5));
             
        if (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            EtwpAssert(FALSE);
            Status = ERROR_WMI_DP_NOT_FOUND;
        }
        
        WmiCloseBlock(PnPIdHandle);
    }
    
    if (Status == ERROR_SUCCESS)
    {
        Status = EtwpComputeInstanceCount(PnPIdWAD,
                                          Size,
                                          &InstanceCount);
                                      
        if (Status == ERROR_SUCCESS)
        {
            
            //
            // Prepare output WNODE
            OutOffsetNameLenPtr = OutWAD->OffsetInstanceDataAndLength;
    
            OutOffsetInstanceNameOffsets = sizeof(WNODE_ALL_DATA) + 
                    (InstanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH));
            OutOffsetInstanceNameOffsetsPtr = (PULONG)OffsetToPtr(OutWAD,
                                               OutOffsetInstanceNameOffsets);

            OutSizeNeeded = ((OutOffsetInstanceNameOffsets + 
                                   (InstanceCount * sizeof(ULONG))) + 7) & ~7;
        
                               
            EtwpDebugPrint(("WMI: Basic OutSizeNeeded = 0x%x\n", OutSizeNeeded));
                               
            //
            // Loop over all device instance ids returned and build
            // output wnode
            
            InWAD = PnPIdWAD;
            do
            {
                //
                // Get Instance and device instance id from input wnode
                InOffsetInstanceNamePtr = (PULONG)OffsetToPtr(InWAD,
                                           InWAD->OffsetInstanceNameOffsets);
                                       
                // TODO: Validate InOffsetInstanceNamePtr
                                       
                if (InWAD->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
                {
                    IsFixedSize = TRUE;
                    InPnPIdPtr = (PWCHAR)OffsetToPtr(InWAD, 
                                                InWAD->DataBlockOffset);
                    FixedNameSize = (InWAD->FixedInstanceSize + 7) & ~7;
                } else {
                    IsFixedSize = FALSE;
                    InOffsetNameLenPtr = InWAD->OffsetInstanceDataAndLength;
                }
            
                for (i = 0; i < InWAD->InstanceCount; i++)
                {
                    if (! IsFixedSize)
                    {
                        InPnPIdPtr = (PWCHAR)OffsetToPtr(InWAD, 
                                    InOffsetNameLenPtr[i].OffsetInstanceData);
                    }

                    InNamePtr = (PWCHAR)OffsetToPtr(InWAD, 
                                            InOffsetInstanceNamePtr[i]);
                                        
                    //
                    // TODO: Validate InNamePtr and InPnPIdPtr
                    if (FALSE)
                    {
                        //
                        // If we hit a bad instance name then we throw out the
                        // entire wnode
                        EtwpDebugPrint(("WMI: Badly formed instance name %x\n",
                                           InNamePtr));
                        EtwpAssert(FALSE);
                        break;
                    }
                    
                    DevInstName = EtwpCountedToSzAndTrim(InPnPIdPtr, 
                                                    DevInstBuffer, 
                                                    MAX_PATH * sizeof(WCHAR),
                                                    FALSE);

					if (DevInstName != NULL)
					{
						EtwpDebugPrint(("WMI: Processing %ws\n", DevInstName));
                                                
                                                
						//
						// Compute size and location of the output instance name
						// It needs to start on a word boundry and end on a 8 byte
						// boundry
						OutNameOffset = (OutSizeNeeded+1) & ~1;
						OutNameSizeNeeded = OutNameOffset - OutSizeNeeded;
						OutNameSizeNeeded += *InNamePtr + sizeof(USHORT);
						OutNameSizeNeeded =  ((OutNameOffset + OutNameSizeNeeded + 7) & ~7) - OutNameOffset;
                    
						EtwpDebugPrint(("WMI: OutNameSizeNeeded = 0x%x\n", OutNameSizeNeeded));
						OutDataOffset = OutSizeNeeded + OutNameSizeNeeded;
						if ((OutIsFull) || 
							(OutDataOffset > MaxWnodeSize))
						{
							EtwpDebugPrint(("    WMI: OutIsFull\n"));
							Buffer = NULL;
							OutSizeLeft = 0;
							OutIsFull = TRUE;
						} else {
							Buffer = (PUCHAR)OffsetToPtr(OutWAD, 
														 OutDataOffset);
							OutSizeLeft = MaxWnodeSize - OutDataOffset;
							EtwpDebugPrint(("    WMI: Out Not Full, OutSizeLeft = 0x%x at 0x%x\n", OutSizeLeft, OutDataOffset));
						}
                
						//
						// Now that we have the name, lets get the vital info
						Status = EtwpGetDevInstInfo(DevInstName,
                                             OutSizeLeft,
                                             Buffer,
                                             &OutDataSize,
                                             CMLocateDevNode,
                                             CMGetDevNodeRegistryProperty);
                                         
						EtwpDebugPrint(("    WMI: GetInfo -> %d, OutDataSize 0x%x\n", Status, OutDataSize));
						if (Status == ERROR_SUCCESS)
						{
							//
							// We were able to get all of the data so fill in the
							// instance name
							OutNamePtr = (PWCHAR)OffsetToPtr(OutWAD, 
                                                         OutNameOffset);
							*OutOffsetInstanceNameOffsetsPtr++ = OutNameOffset;
							*OutNamePtr++ = *InNamePtr;
							memcpy(OutNamePtr, InNamePtr+1, *InNamePtr);
                    
							//
							// Now fill in the output data
							OutOffsetNameLenPtr[OutInstanceCounter].OffsetInstanceData = OutDataOffset;
							OutOffsetNameLenPtr[OutInstanceCounter].LengthInstanceData = OutDataSize;
							OutInstanceCounter++;
						} else if (Status == ERROR_INSUFFICIENT_BUFFER) {
							OutIsFull = TRUE;
							OutInstanceCounter++;
						} else {
							OutNameSizeNeeded = 0;
							OutDataSize = 0;
						}
                
						OutSizeNeeded += (OutNameSizeNeeded + OutDataSize);
						EtwpDebugPrint(("    WMI: OutSizeNeeded = 0x%x\n", OutSizeNeeded));
                    
						if (DevInstName != DevInstBuffer)
						{
							EtwpFree(DevInstName);
						}
					} else {
						return(ERROR_NOT_ENOUGH_MEMORY);
					}
                  
                    if (IsFixedSize)
                    {
                        InPnPIdPtr = (PWCHAR)((PUCHAR)InPnPIdPtr + FixedNameSize);
                    }
                }
                        
                Linkage = InWAD->WnodeHeader.Linkage;
                InWAD = (PWNODE_ALL_DATA)OffsetToPtr(InWAD, 
                                                  InWAD->WnodeHeader.Linkage);
            } while (Linkage != 0);            
        }
    }
    
    //
    // Output wnode post processing. If not enough room then return a
    // WNODE_TOO_SMALL, otherwise fill in WNODE_ALL_DATA fields
    if ((OutInstanceCounter > 0) || (Status == ERROR_SUCCESS))
    {
        if (OutIsFull)
        {
            WTS = (PWNODE_TOO_SMALL)OutWAD;
            WTS->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WTS->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WTS->SizeNeeded = OutSizeNeeded;        
            *RetSize = sizeof(WNODE_TOO_SMALL);
        } else {
            OutWAD->WnodeHeader.BufferSize = OutSizeNeeded;
            OutWAD->InstanceCount = OutInstanceCounter;
            OutWAD->OffsetInstanceNameOffsets = OutOffsetInstanceNameOffsets;
            *RetSize = OutSizeNeeded;
        }
        Status = ERROR_SUCCESS;
    }
    
    return(Status);
}

#ifdef MEMPHIS
#define CFGMGRDLL TEXT("cfgmgr32.dll")
#else
#define CFGMGRDLL TEXT("setupapi.dll")
#endif

ULONG EtwpQueryInstanceInfo(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   )
{
    HMODULE CfgMgr32ModuleHandle;
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty;
    PCMLOCATEDEVNODE CMLocateDevNode;
    ULONG Status;
    
    //
    // Ensure this is a request we support
    if ((ActionCode != WmiGetSingleInstance) &&
        (ActionCode != WmiGetAllData))
    {
        return(ERROR_INVALID_FUNCTION);
    }
    
    //
    // First we try to demand load cfgmgr32.dll
    CfgMgr32ModuleHandle = LoadLibrary(CFGMGRDLL);
    if (CfgMgr32ModuleHandle != NULL)
    {
#ifdef MEMPHIS        
        CMLocateDevNode = (PCMLOCATEDEVNODEA)GetProcAddress(CfgMgr32ModuleHandle,
                                      "CM_Locate_DevNodeA");
#else
        CMLocateDevNode = (PCMLOCATEDEVNODEW)GetProcAddress(CfgMgr32ModuleHandle,
                                      "CM_Locate_DevNodeW");
#endif
        CMGetDevNodeRegistryProperty = (PCMGETDEVNODEREGISTRYPROPERTYW)
                                        GetProcAddress(CfgMgr32ModuleHandle,
#ifdef MEMPHIS
                                         "CM_Get_DevNode_Registry_PropertyA");
#else
                                         "CM_Get_DevNode_Registry_PropertyW");
#endif                 
        if ((CMLocateDevNode == NULL) ||
            (CMGetDevNodeRegistryProperty == NULL))
        {
            FreeLibrary(CfgMgr32ModuleHandle);
            EtwpDebugPrint(("WMI: Couldn't get CfgMgr32 prog addresses %d\n",
                            GetLastError()));
            return(GetLastError());
        }
    } else {
        EtwpDebugPrint(("WMI: Couldn't load CfgMgr32 %d\n",
                            GetLastError()));
        return(GetLastError());
    }
    
    if (ActionCode == WmiGetSingleInstance)
    {
        Status = EtwpQuerySingleInstanceInfo((PWNODE_SINGLE_INSTANCE)Wnode,
                                               MaxWnodeSize,
                                               OutBuffer,
                                               RetSize,
                                               CMLocateDevNode,
                                               CMGetDevNodeRegistryProperty);
    } else if (ActionCode == WmiGetAllData) {
        Status = EtwpQueryAllInstanceInfo((PWNODE_ALL_DATA)Wnode,
                                               MaxWnodeSize,
                                               OutBuffer,
                                               RetSize,
                                               CMLocateDevNode,
                                               CMGetDevNodeRegistryProperty);
    } else {
        EtwpAssert(FALSE);
    }
        
    FreeLibrary(CfgMgr32ModuleHandle);
    return(Status);
}

ULONG
EtwpEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG MaxGuidCount = 0;
    PWMIGUIDLISTINFO GuidInfo;
    ULONG RetSize;
    ULONG GuidInfoSize;

    MaxGuidCount = DEFAULT_GUID_COUNT;
retry:
    GuidInfoSize = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                     MaxGuidCount * sizeof(WMIGUIDPROPERTIES);
	     
    GuidInfo = (PWMIGUIDLISTINFO)EtwpAlloc(GuidInfoSize);

    if (GuidInfo == NULL)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    
    RtlZeroMemory(GuidInfo, GuidInfoSize);

    Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES,
                                  GuidInfo,
                                  GuidInfoSize,
                                  GuidInfo,
                                  GuidInfoSize,
                                  &RetSize,
                                  NULL);
    if (Status == ERROR_SUCCESS)
    {
        if ((RetSize < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) ||
            (RetSize < (FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                GuidInfo->ReturnedGuidCount * sizeof(WMIGUIDPROPERTIES))))
        {
            //
            // WMI KM returned to us a bad size which should not happen
            //
            Status = ERROR_WMI_DP_FAILED;
            EtwpAssert(FALSE);
	    EtwpFree(GuidInfo);
        } else {

            //
            // If RPC was successful, then build a WMI DataBlock with the data
            //
  
            if (GuidInfo->TotalGuidCount > GuidInfo->ReturnedGuidCount) {
                MaxGuidCount = GuidInfo->TotalGuidCount;
                EtwpFree(GuidInfo);
                goto retry;
            }
        }

        //
        // If the call was successful, return the pointers and the caller
        // must free the storage. 
        //

        *pGuidInfo = GuidInfo;
    }

    return Status;
}


ULONG
EtwpEnumerateGuids(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize)
{
    ULONG Status = ERROR_SUCCESS;
    PWMIGUIDLISTINFO GuidInfo = NULL;
    ULONG ReturnGuidCount = 0;

    Status = EtwpEnumRegGuids(&GuidInfo);

    if (Status == ERROR_SUCCESS) {

        PWMIGUIDPROPERTIES pGuidProperties = GuidInfo->GuidList;
        LPGUID  pGuid;
        WCHAR s[256];
        ULONG InstanceNameOffset;
        ULONG i;
        ULONG InstanceDataSize = sizeof(WMIGUIDPROPERTIES) - 
		                  FIELD_OFFSET(WMIGUIDPROPERTIES, GuidType);
        ULONG FixedInstanceSizeWithPadding = (InstanceDataSize+7) & ~7;    
        USHORT GuidStringSize = 76;
        ULONG SizeNeeded;
        PUCHAR BytePtr;
        PULONG UlongPtr;
        PUCHAR NamePtr;
        ULONG DataBlockOffset;

	EtwpAssert(GuidInfo->ReturnedGuidCount == GuidInfo->TotalGuidCount);
	ReturnGuidCount = GuidInfo->ReturnedGuidCount;
        SizeNeeded = sizeof(WNODE_ALL_DATA) + 
                     ReturnGuidCount * (FixedInstanceSizeWithPadding +
                                        GuidStringSize +
                                        sizeof(ULONG) + 
                                        sizeof(WCHAR));

        if (MaxWnodeSize < SizeNeeded) {
            // 
            // Build WNODE_TOO_SMALL
            //

            EtwpAssert(MaxWnodeSize > sizeof(WNODE_TOO_SMALL));

            Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
            Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            *RetSize = sizeof(WNODE_TOO_SMALL);
            EtwpFree(GuidInfo);
            return ERROR_SUCCESS;
        }

        Wnode->InstanceCount = ReturnGuidCount;
        Wnode->FixedInstanceSize = InstanceDataSize;
        Wnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;

        DataBlockOffset = sizeof(WNODE_ALL_DATA);

        //
        // pad out to an 8 byte boundary.
        //
        DataBlockOffset = (DataBlockOffset + 7) & ~7;

        Wnode->DataBlockOffset = DataBlockOffset;

        BytePtr = (PUCHAR)((PUCHAR)Wnode + DataBlockOffset);
        
        
        InstanceNameOffset = DataBlockOffset + 
                             (ReturnGuidCount * FixedInstanceSizeWithPadding);
        Wnode->OffsetInstanceNameOffsets = InstanceNameOffset;
                            
        UlongPtr = (PULONG)((PUCHAR)Wnode + InstanceNameOffset);

        NamePtr = (PUCHAR)UlongPtr;
        NamePtr = (PUCHAR)((PUCHAR)NamePtr + (ReturnGuidCount * sizeof(ULONG)));

        for (i=0; i < ReturnGuidCount; i++) {
            //
            // Copy the fixed instance datablock
            //
            RtlCopyMemory(BytePtr, 
                          &pGuidProperties->GuidType, 
                          Wnode->FixedInstanceSize);
            BytePtr += FixedInstanceSizeWithPadding;

            //
            // Set the Offset to InstanceName
            //
            *UlongPtr++ = (ULONG)((PCHAR)NamePtr - (PCHAR)Wnode); 
            //
            // Copy over the Instance Name
            //
            *((USHORT *)NamePtr) = GuidStringSize;
            NamePtr += sizeof(USHORT);
            GuidToWString(s, &pGuidProperties->Guid);
            RtlCopyMemory(NamePtr, s, GuidStringSize);
            NamePtr += GuidStringSize;

            pGuidProperties++; 
        }
        WmiInsertTimestamp((PWNODE_HEADER)Wnode);
        *RetSize = SizeNeeded;
        Wnode->WnodeHeader.BufferSize = SizeNeeded;

        EtwpFree(GuidInfo);
    }
    return Status;
}

ULONG EtwpInternalProvider(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   )
{
    ULONG GuidIndex;
    ULONG Status;
    
    EtwpAssert((PVOID)Wnode == OutBuffer);
    
    GuidIndex = EtwpFindGuid(&Wnode->Guid);
    
    switch(GuidIndex)
    {
        case INSTANCE_INFO_GUID_INDEX:
        {
            Status = EtwpQueryInstanceInfo(ActionCode,
                                           Wnode,
                                           MaxWnodeSize,
                                           OutBuffer,
                                           RetSize);
            break;
        }
	
        case ENUMERATE_GUIDS_GUID_INDEX:
        {
            //
            //
            // Need an RPC call to the server to get the desired data.
            //
            if (ActionCode == WmiGetAllData)
                Status = EtwpEnumerateGuids((PWNODE_ALL_DATA)Wnode,
                                            MaxWnodeSize,
                                            OutBuffer,
                                            RetSize);
            else
                Status = ERROR_INVALID_FUNCTION;

            break;
        }

        default:
        {
            Status = ERROR_WMI_GUID_NOT_FOUND;
        }
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\dcapi.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dcapi.c

Abstract:

    WMI data consumer api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

#ifndef MEMPHIS
#include <aclapi.h>
#endif

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *DataBlockGuid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
)
/*+++

Routine Description:

    This routine prepares for accessing data items contained within the data
    block represented by the guid passed. If successful it returns a handle
    that can be used to query and set data blocks maintained by data providers
    that have registered the guid. Any data providers that had registered the
    guid as expensive will receive a request to enable collection of data for
    the guid if collection was not previously enabled.

Arguments:

    DataBlockGuid - Pointer to guid that represents the data block

    DesiredAccess - Specifies the type of access to the object. Not used on
        Windows 98

    *DataBlockHandle - If successful returns a handle to the data block

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG Status;
    HANDLE KernelHandle;
    GUID Guid;
    ULONG Ioctl;
    
    EtwpInitProcessHeap();

    //
    // Validate the passed parameters
    //
    if ((DataBlockGuid == NULL) ||
        (DataBlockHandle == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }
    
    if ((DesiredAccess & WMIGUID_NOTIFICATION) &&
        ((DesiredAccess & (WMIGUID_QUERY | WMIGUID_SET | WMIGUID_EXECUTE))  != 0))
    {
        //
        // If you want to open the guid for notifications then it cannot
        // be opened for query and set operations
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        *DataBlockHandle = NULL;
        Guid = *DataBlockGuid;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (DesiredAccess == 0)
    {
        DesiredAccess =  ( WMIGUID_QUERY | WMIGUID_SET |  WMIGUID_EXECUTE );
    }

    //
    // Obtain a handle for the guid only if it is registered
    //
    if (DesiredAccess & WMIGUID_NOTIFICATION)
    {
        //
        // Opening a handle strictly for notifications
        //
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_EVENTS;
    } else {
        //
        // Otherwise we assume that opening for query/set
        //
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_QUERYSET;
    }
    Status = EtwpOpenKernelGuid(&Guid,
                                DesiredAccess,
                                &KernelHandle,
                                Ioctl);

    if (Status == ERROR_SUCCESS)
    {
        //
        // if we were able to open the guid then try to return the handle
        //
        try
        {
            *DataBlockHandle = KernelHandle;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CloseHandle(KernelHandle);
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
)
/*+++

Routine Description:

    This routine terminates all access to the data block managed by the
    data block handle passed and free any resources associated with it. Any
    data providers that were providing data blocks for this handle and were
    marked as expensive to collect will receive a collection disable request
    if this is the last handle to the data block to close.

Arguments:

    DataBlockHandle - Handle of data block to which access is closed

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG Status;
    BOOL Ok;
    
    EtwpInitProcessHeap();

    try
    {
        Ok = CloseHandle(DataBlockHandle);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // We may get an invalid handle exception and if so we catch it here
        // and just return an error
        //
        return(ERROR_INVALID_HANDLE);
    }
    
    if (Ok)
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }
    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT LPVOID Buffer
    )
/*++

Routine Description:

    ANSI thunk to WMIQueryAllDataW

    NOTE: This api will not translate any unicode strings in the data block
          from unicode to ANSI, but will translate the InstanceName string.
--*/
{
    ULONG Status;

    Status = WmiQueryAllDataW(DataBlockHandle,
                              BufferSize,
                              Buffer);

    if (Status == ERROR_SUCCESS)
    {
        Status = EtwpConvertWADToAnsi((PWNODE_ALL_DATA)Buffer);
    }

    return(Status);
}


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
    )
/*+++

Routine Description:

    This routine allows a data consumer to query for all data items of
    all instances of a data block. WMI will call all data providers that
    registered for the guid represented by DataBlockHandle with a query all
    data request. Each data provider will fill a WNODE_ALL_DATA with all
    of its instances of the data block. WMI will link each of the
    WNODE_ALL_DATA structures by placing the offset from the current
    WNODE_ALL_DATA struccture to the next WNODE_ALL_DATA in the Linkage
    field in the WNODE_HEADER. A value of 0 in the Linkage field indicates
    that the WNODE_ALL_DATA is the last in the chain.


Arguments:

    DataBlockHandle - Handle to data block being queried

    *InOutBufferSize - on entry has the maximum size available in Buffer.
                  If ERROR_BUFFER_TOO_SMALL is returned then returns the size
                  of buffer needed to return data. The minimum valid buffer
                  size that can be passed is sizeof(WNODE_TOO_SMALL).

    OutBuffer - If ERROR_SUCCESS is returned then the buffer contains a
             WNODE_ALL_DATA for the data block.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG SizeNeeded;
    PWNODE_HEADER Wnode;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG Status;
    LPVOID Buffer;
    ULONG RetSize;
    ULONG BufferSize;
    LPVOID BufferAllocated;
        
    EtwpInitProcessHeap();

    //
    // Validate passed Parameters
    //
    try
    {
        BufferSize = *InOutBufferSize;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if ((OutBuffer != NULL) && (BufferSize >= 0x80000000))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    WnodeTooSmall = (PWNODE_TOO_SMALL)WmipAlloc(sizeof(WNODE_ALL_DATA));

    if (WnodeTooSmall != NULL)
    {
        //
        // If Buffer is not specified or is too small then we can only return
        // the size needed.
        //
        if ((OutBuffer == NULL) || (BufferSize < sizeof(WNODE_ALL_DATA)))
        {
            Buffer = (LPVOID)WnodeTooSmall;
            BufferSize = sizeof(WNODE_ALL_DATA);
            BufferAllocated = NULL;
        } else {
            Buffer = EtwpAlloc(BufferSize);
            if (Buffer == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            BufferAllocated = Buffer;
        }

        //
        // Build the wnode and pass down to KM for execution
        //
        Wnode = (PWNODE_HEADER)Buffer;
        EtwpBuildWnodeHeader(Wnode,
                             sizeof(WNODE_HEADER),
                             WNODE_FLAG_ALL_DATA,
                             DataBlockHandle);

        Status = EtwpSendWmiRequest(
                                        WMI_GET_ALL_DATA,
                                        Wnode,
                                        sizeof(WNODE_HEADER),
                                        Wnode,
                                        BufferSize,
                                        &RetSize);

        if ((Status == ERROR_SUCCESS) &&
            ( (RetSize < sizeof(WNODE_HEADER))  ||
              (RetSize < Wnode->BufferSize)))
        {
            //
            // If we return success, but the output size is incorrect then we
            // flag an error. If this occurs then it indicates some problem
            // in the WMI KM code.
            //
            EtwpAssert(FALSE);
            Status = ERROR_WMI_DP_FAILED;
        }

        if (Status == ERROR_SUCCESS)
        {
            if (Wnode->Flags & WNODE_FLAG_INTERNAL)
            {
                //
                // If this is an internal guid, try the call internally
                //
                Wnode->Flags &= ~WNODE_FLAG_INTERNAL;
                Status = EtwpInternalProvider(WmiGetAllData,
                                              Wnode,
                                              BufferSize,
                                              Wnode,
                                              &RetSize);

                if (Status != ERROR_SUCCESS)
                {
                    goto done;
                }
            } 

            if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
            {
                //
                // There is not enough room to complete the query so we
                // remember how much the data provider needs and then add
                // in how much WMI needs for the instance names.

                SizeNeeded = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
                Status = ERROR_INSUFFICIENT_BUFFER;
            } else {
                //
                // We had enough room so report the size we used
                //
                SizeNeeded = RetSize;

                if (Wnode == (PWNODE_HEADER)WnodeTooSmall)
                {
                    Status = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // Copy back into the caller's buffer the BufferSize and the Buffer
            //
            try
            {
                *InOutBufferSize = SizeNeeded;
                if ((Status == ERROR_SUCCESS) &&
                    (Wnode != (PWNODE_HEADER)WnodeTooSmall))
                {
                    memcpy(OutBuffer, Buffer, SizeNeeded);
                    Status = ERROR_SUCCESS;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALID_PARAMETER;
            }
        }

done:
        if (BufferAllocated != NULL)
        {
            EtwpFree(BufferAllocated);
        }
        WmipFree(WnodeTooSmall);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;

    EtwpInitProcessHeap();
    
    Status = WmiQueryAllDataMultipleW(HandleList,
                                      HandleCount,
                                      InOutBufferSize,
                                      OutBuffer);

    if ((Status == ERROR_SUCCESS) && (*InOutBufferSize > 0))
    {
        Status = EtwpConvertWADToAnsi((PWNODE_ALL_DATA)OutBuffer);
    }

    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    PWMIQADMULTIPLE QadMultiple;
    ULONG RetSize;
    ULONG QadMultipleSize;
    ULONG i;
    ULONG OutBufferSize;
    ULONG Status;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    
    EtwpInitProcessHeap();

    WnodeTooSmall = (PWNODE_TOO_SMALL)WmipAlloc(sizeof(WNODE_TOO_SMALL));

    if (WnodeTooSmall != NULL)
    {
        if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
        {
            QadMultipleSize = sizeof(WMIQADMULTIPLE) + 
                                           ((HandleCount-1) * sizeof(HANDLE3264));

            QadMultiple = EtwpAlloc(QadMultipleSize);
            if (QadMultiple != NULL)
            {
                QadMultiple->HandleCount = HandleCount;
                try
                {
                    for (i = 0; i < HandleCount; i++)
                    {
                        WmipSetHandle3264(QadMultiple->Handles[i], HandleList[i]);
                    }
                    OutBufferSize = *InOutBufferSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    EtwpFree(QadMultiple);
                    SetLastError(ERROR_NOACCESS);
                    return(ERROR_NOACCESS);
                }

                if (OutBufferSize < sizeof(WNODE_ALL_DATA))
                {
                    Wnode = (PWNODE_HEADER)WnodeTooSmall;
                    OutBufferSize = sizeof(WNODE_TOO_SMALL);
                } else {
                    Wnode = (PWNODE_HEADER)OutBuffer;
                }

                Status = EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_QAD_MULTIPLE,
                                      QadMultiple,
                                      QadMultipleSize,
                                      Wnode,
                                      OutBufferSize,
                                      &RetSize,
                                      NULL);

                EtwpFree(QadMultiple);

                if (Status == ERROR_SUCCESS)
                {
                    if ((RetSize >= sizeof(WNODE_HEADER)) &&
						(Wnode->Flags & WNODE_FLAG_TOO_SMALL))
                    {       
                        RetSize = ((PWNODE_TOO_SMALL)(Wnode))->SizeNeeded;
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    } else if (Wnode == (PWNODE_HEADER)WnodeTooSmall) {
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }

                    try
                    {
                        *InOutBufferSize = RetSize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Status = ERROR_NOACCESS;
                    }
                }
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }
        
        WmipFree(WnodeTooSmall);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(Status);
    return(Status);     
}

ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT LPVOID Buffer
    )
/*++

Routine Description:

    ANSI thunk to WMIQuerySingleInstanceW

    NOTE: This api will not translate any unicode strings in the data block
          from unicode to ANSI, but will translate the InstanceName string.
--*/
{
    LPWSTR InstanceNameUnicode;
    ULONG Status;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Ptr;

    EtwpInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiQuerySingleInstanceW(DataBlockHandle,
                                         InstanceNameUnicode,
                                         BufferSize,
                                         Buffer);

        if (Status == ERROR_SUCCESS)
        {
            //
            // Convert Instance name from unicode back to ANSI. We assume
            // that the ansi size will never be larger than the unicode size
            // so we can convert in place.
            Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
            Ptr = (PWCHAR)(((PUCHAR)Buffer) + Wnode->OffsetInstanceName);
            Status = EtwpCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
            if (Status != ERROR_SUCCESS)
            {
                SetLastError(Status);
            } else {
                Wnode->WnodeHeader.Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;
            }
        }

        if (InstanceNameUnicode != NULL)
        {
            EtwpFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
    )
/*+++

Routine Description:

    This routine will query a single data provider for the values of a single
    instance of the data block represented by the DataBlockHandle. WMI will
    determine the appropriate data provider to which to send a query single
    instance request and if successful return a WNODE_SINGLE_INSTANCE to
    the caller.

Arguments:

    DataBlockHandle - Handle to data block to query

    InstanceName - name of the instance for which data is being queried

    *BufferSize - on entry has the maximum size available in pBuffer. If
                  ERROR_BUFFER_TOO_SMALL is returned then returns the size of
                  buffer needed to return data. The minimum valid buffer
                  size that can be passed is sizeof(WNODE_TOO_SMALL).

    Buffer - If ERROR_SUCCESS is returned then the buffer contains a
             WNODE_SINGLE_ITEM for the data block.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG Status, ReturnStatus;
    PWCHAR WnodePtr;
    ULONG BufferNeeded;
    ULONG BufferSize;
    LPVOID Buffer;
    ULONG RetSize;
    ULONG InstanceNameLen;

    EtwpInitProcessHeap();

    //
    // Validate input parameters
    //
    if ((InstanceName == NULL) ||
        (InOutBufferSize == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Calculate the size of the buffer needed to build the WNODE to send
    // to the driver. We add up the WNODE_SINGLE_INSTANCE header, the
    // instance name length and text and pad it out to an 8 byte boundry
    //
    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
        BufferSize = *InOutBufferSize;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Make sure we have a resonable buffer size
    //
    if ((OutBuffer != NULL) && (BufferSize >= 0x80000000))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    BufferNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                 VariableData) +
                   InstanceNameLen +
                   sizeof(USHORT) + 7) & ~7;

    //
    // if user passed a NULL buffer or one that is smaller than the
    // size needed to hold the WNODE then we allocate a small buffer on
    // its behalf and call to obtain the size needed.
    if ((OutBuffer == NULL) ||
        (BufferSize < BufferNeeded))
    {
        BufferSize = BufferNeeded;
    }

    Buffer = EtwpAlloc(BufferSize);
    if (Buffer == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    //
    Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                  VariableData));
    EtwpBuildWnodeHeader(&Wnode->WnodeHeader, 
                         BufferNeeded,
                         WNODE_FLAG_SINGLE_INSTANCE,
                         DataBlockHandle);

    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData);
    Wnode->DataBlockOffset = BufferNeeded;

    //
    // Copy InstanceName into the WnodeSingleInstance for the query.
    //
    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;
    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpFree(Buffer);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    Status = EtwpSendWmiRequest(
                                WMI_GET_SINGLE_INSTANCE,
                                (PWNODE_HEADER)Wnode,
                                BufferNeeded,
                                Wnode,
                                BufferSize,
                                &RetSize);

    if (Status == ERROR_SUCCESS)
    {
        //
        // Successful return, we either have success or a buffer too small
        //
        if ((RetSize < sizeof(WNODE_HEADER) ||
            ((RetSize >= sizeof(ULONG)) &&
             (RetSize < Wnode->WnodeHeader.BufferSize))))
        {
            //
            // if we get an incosistent WNODE back this may indicate a
            // problem with the WMI KM code
            //
            Status = ERROR_WMI_DP_FAILED;
            EtwpAssert(FALSE);
         } else {
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
            {
                //
                // If this is an internal guid, try the call internally
                //
                Wnode->WnodeHeader.Flags &= ~WNODE_FLAG_INTERNAL;
                Wnode->WnodeHeader.BufferSize = BufferNeeded;
                Status = EtwpInternalProvider( WmiGetSingleInstance,
                                          (PWNODE_HEADER)Wnode,
                                          BufferSize,
                                          Wnode,
                                          &RetSize);
                                          
                if (Status != ERROR_SUCCESS)
                {
                    goto done;
                }
            } 
    
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
            {
                //
                // Our buffer was too small so try to return the size needed
                //
                Status = ERROR_INSUFFICIENT_BUFFER;
                try
                {
                    *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            } else {
                //
                // We have a result from our query so we just copy back
                // the results.
                //
                try
                {
                    if (*InOutBufferSize >= RetSize)
                    {
                        memcpy(OutBuffer, Wnode, RetSize);
                    } else {
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }
                    *InOutBufferSize = RetSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    
done:
    EtwpFree(Buffer);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN LPCWSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG i;
    ULONG OutBufferSize;
    ULONG QsiMultipleSize;
    ULONG Len;
    PWMIQSIMULTIPLE QsiMultiple;
    PWNODE_HEADER Wnode;
    ULONG RetSize;
    HANDLE Handle;
    
    EtwpInitProcessHeap();

    WnodeTooSmall = (PWNODE_TOO_SMALL)WmipAlloc(sizeof(WNODE_TOO_SMALL));

    if (WnodeTooSmall != NULL)
    {       
        if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
        {
            QsiMultipleSize = sizeof(WMIQSIMULTIPLE) + 
                                         ((HandleCount-1)*sizeof(WMIQSIINFO));

            QsiMultiple = EtwpAlloc(QsiMultipleSize);
            if (QsiMultiple != NULL)
            {
                try
                {
                    OutBufferSize = *InOutBufferSize;

                    QsiMultiple->QueryCount = HandleCount;
                    for (i = 0; i < HandleCount; i++)
                    {
                        Handle = HandleList[i];

                        WmipSetHandle3264(QsiMultiple->QsiInfo[i].Handle, Handle);
    #if defined(_WIN64)             
                        QsiMultiple->QsiInfo[i].InstanceName.Buffer = (PWSTR)InstanceNames[i];
    #else
                        QsiMultiple->QsiInfo[i].InstanceName.Dummy = (ULONG64)(IntToPtr(PtrToInt(InstanceNames[i])));
    #endif

                        Len = wcslen(InstanceNames[i]) * sizeof(WCHAR);
                        QsiMultiple->QsiInfo[i].InstanceName.Length = (USHORT)Len;
                        QsiMultiple->QsiInfo[i].InstanceName.MaximumLength = (USHORT)Len;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    EtwpFree(QsiMultiple);
                    SetLastError(ERROR_NOACCESS);
                    return(ERROR_NOACCESS);
                }

                if (OutBufferSize < sizeof(WNODE_TOO_SMALL))
                {
                    Wnode = (PWNODE_HEADER)WnodeTooSmall;
                    OutBufferSize = sizeof(WNODE_TOO_SMALL);
                } else {
                    Wnode = (PWNODE_HEADER)OutBuffer;
                }

                Status = EtwpSendWmiKMRequest(NULL,
                                              IOCTL_WMI_QSI_MULTIPLE,
                                              QsiMultiple,
                                              QsiMultipleSize,
                                              Wnode,
                                              OutBufferSize,
                                              &RetSize,
                                              NULL);

                EtwpFree(QsiMultiple);

                if (Status == ERROR_SUCCESS)
                {
                    if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
                    {       
                        RetSize = ((PWNODE_TOO_SMALL)(Wnode))->SizeNeeded;
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }

                    try
                    {
                        *InOutBufferSize = RetSize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Status = ERROR_NOACCESS;
                    }
                }
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }
        WmipFree(WnodeTooSmall);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN LPCSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;
    ULONG Linkage;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Ptr;
    PWCHAR *UnicodeInstanceNames;
    ULONG UnicodeInstanceNamesSize;
    ULONG i;
    
    EtwpInitProcessHeap();
    
    if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
    {
        UnicodeInstanceNamesSize = HandleCount * sizeof(PWCHAR);
        UnicodeInstanceNames = EtwpAlloc(UnicodeInstanceNamesSize);
        if (UnicodeInstanceNames != NULL)
        {
            memset(UnicodeInstanceNames, 0, UnicodeInstanceNamesSize);
            for (i = 0; i < HandleCount; i++)
            {
                Status = AnsiToUnicode(InstanceNames[i], 
                                       &UnicodeInstanceNames[i]);
                if (Status != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
            
            Status = WmiQuerySingleInstanceMultipleW(HandleList,
                                             UnicodeInstanceNames,
                                             HandleCount,
                                             InOutBufferSize,
                                             OutBuffer);

            if ((Status == ERROR_SUCCESS) && (*InOutBufferSize > 0))
            {
                Linkage = 1;
                Wnode = (PWNODE_SINGLE_INSTANCE)OutBuffer;
                while ((Status == ERROR_SUCCESS) && (Linkage != 0))
                {
                    Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
                    Status = EtwpCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
                    Linkage = Wnode->WnodeHeader.Linkage;
                    Wnode = (PWNODE_SINGLE_INSTANCE)OffsetToPtr(Wnode, Linkage);
                }
            }

Cleanup:            
            for (i = 0; i < HandleCount; i++)
            {
                if (UnicodeInstanceNames[i] != NULL)
                {
                    EtwpFree(UnicodeInstanceNames[i]);
                }
            }
            EtwpFree(UnicodeInstanceNames);
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*++

Routine Description:

    ANSI thunk to WMISetSingleInstanceW

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR InstanceNameUnicode;

    EtwpInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiSetSingleInstanceW(DataBlockHandle,
                                    InstanceNameUnicode,
                                    Version,
                                    ValueBufferSize,
                                    ValueBuffer);
        if (InstanceNameUnicode != NULL)
        {
            EtwpFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*+++

Routine Description:

    This routine will send a set single instance request to the appropriate
    data provider to request changing all data items for a single instances
    of a data block. A data provider is free to silently ignore any change
    requests or only change some data items within an instance.

Arguments:

    DataBlockHandle - Handle to data block

    InstanceName - name of the instance for which data is being set

    Version - specifies the version of the data block being passed in
              ValueBuffer

    ValueBufferSize - on entry has the size of the data block containing the
                 new values for the instance of the data block passed in
                 ValueBuffer

    ValueBuffer - passes new values for instance

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG InstanceNameLen;
    ULONG Status;
    PWCHAR WnodePtr;
    ULONG BufferSize;
    ULONG RetSize;

    EtwpInitProcessHeap();

    //
    // Validate input parameters
    if ((InstanceName == NULL) ||
        (ValueBuffer == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // The WNODE_SINGLE_INSTANCE that we need to send to the data provider
    // must be large enough to hold the WNODE, the instance name of the
    // item being set, padding so that the data block is on a 8 byte
    // boundry and space for the new data block.
    BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                 InstanceNameLen + sizeof(USHORT) + ValueBufferSize + 7;

    Wnode = EtwpAlloc(BufferSize);
    if (Wnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    //
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData));
    EtwpBuildWnodeHeader(&Wnode->WnodeHeader,
                         BufferSize,
                         WNODE_FLAG_SINGLE_INSTANCE,
                         DataBlockHandle);
    Wnode->WnodeHeader.Version = Version;
    
    Wnode->SizeDataBlock = ValueBufferSize;
    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData);

    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;

    Wnode->DataBlockOffset = (Wnode->OffsetInstanceName +
                              InstanceNameLen + sizeof(USHORT) + 7) & ~7;

    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
        memcpy((PCHAR)Wnode + Wnode->DataBlockOffset,
                ValueBuffer,
                ValueBufferSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpFree(Wnode);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Send down the set request and reprot the results
    //
    Status = EtwpSendWmiRequest(
                                    WMI_SET_SINGLE_INSTANCE,
                                    (PWNODE_HEADER)Wnode,
                                    BufferSize,
                                    Wnode,
                                    ValueBufferSize,
                                    &RetSize);
    EtwpFree(Wnode);
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*++

Routine Description:

    ANSI thunk to WMISetSingleItemA

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR InstanceNameUnicode;

    EtwpInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiSetSingleItemW(DataBlockHandle,
                                    InstanceNameUnicode,
                                    DataItemId,
                                    Version,
                                    ValueBufferSize,
                                    ValueBuffer);
        if (InstanceNameUnicode != NULL)
        {
            EtwpFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*+++

Routine Description:

    This routine will send a set single item request to the appropriate data
    provider to request changing a specific data item within a specific
    instance of a data block. A data provider can silently ignore a change
    request.

Arguments:

    DataBlockHandle - Handle to data block

    InstanceName - name of the instance for which data is being set

    Version - specifies the version of the data block being passed in
              ValueBuffer

    DataItemId - Data item id of item to set

    ValueBufferSize - on entry has the size of the new value for the
                      data item which is passed in pBuffer.

    ValueBuffer - passes new value for data item

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_ITEM Wnode;
    ULONG InstanceNameLen;
    ULONG Status;
    PBYTE WnodeBuffer;
    PWCHAR WnodePtr;
    ULONG BufferSize;
    ULONG RetSize;

    EtwpInitProcessHeap();

    //
    // Validate passed parameters
    //
    if ((InstanceName == NULL) ||
        (ValueBuffer == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    BufferSize = FIELD_OFFSET(WNODE_SINGLE_ITEM, VariableData) +
                 InstanceNameLen + sizeof(USHORT) +
                 ValueBufferSize + 7;

    Wnode = EtwpAlloc(BufferSize);
    if (Wnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_ITEM, VariableData));
    EtwpBuildWnodeHeader(&Wnode->WnodeHeader,
                         BufferSize,
                         WNODE_FLAG_SINGLE_ITEM,
                         DataBlockHandle);
    Wnode->WnodeHeader.Version = Version;
    
    Wnode->ItemId = DataItemId;
    Wnode->SizeDataItem = ValueBufferSize;

    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_ITEM,VariableData);
    Wnode->DataBlockOffset = (Wnode->OffsetInstanceName +
                             InstanceNameLen + sizeof(USHORT) + 7) & ~7;

    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;
    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
        memcpy((PCHAR)Wnode + Wnode->DataBlockOffset, 
               ValueBuffer, 
               ValueBufferSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
        EtwpFree(Wnode);
        SetLastError(Status);
        return(Status);
    }

    //
    // Send down the request and report the result
    //
    Status = EtwpSendWmiRequest(
                                    WMI_SET_SINGLE_ITEM,
                                    (PWNODE_HEADER)Wnode,
                                    BufferSize,
                                    Wnode,
                                    ValueBufferSize,
                                    &RetSize);

    EtwpFree(Wnode);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN LPVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    )
/*++

Routine Description:

    ANSI thunk to WmiExecuteMethodW

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR MethodInstanceNameUnicode;
    LPWSTR InputInstanceNameUnicode;
    PWCHAR Ptr;

    EtwpInitProcessHeap();

    if (MethodInstanceName == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    MethodInstanceNameUnicode = NULL;
    Status = AnsiToUnicode(MethodInstanceName,
                           &MethodInstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiExecuteMethodW(MethodDataBlockHandle,
                                   MethodInstanceNameUnicode,
                                   MethodId,
                                   InputValueBufferSize,
                                   InputValueBuffer,
                                   OutputBufferSize,
                                   OutputBuffer);

        if (MethodInstanceNameUnicode != NULL)
        {
            EtwpFree(MethodInstanceNameUnicode);
        }
    }

    return(Status);
}

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN LPVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    )
/*+++

Routine Description:

    This routine will invoke a method on a WMI data provider. A method is a
    call to have the data provider do something rather than a query or a
    set. A WNODE_SINGLE_INSTANCE is built as the input parameters to a
    method and a WNODE_SINGLE_INSTANCE is returned as output from a method.

Arguments:

    MethodDataBlockHandle - Handle to data block that contains method

    MethodInstanceName - Name of instance of data block on which the method
                         should be executed.

    MethodId - Id value that specifies which method within the guid to
               execute.

    InputValueBufferSize - on entry has the size of the data block containing the
                 values for the instance of the data block passed in
                 ValueBuffer that serves as the input parameters

    InputValueBuffer - passes new values for instance that serves as the
                 input parameters. This can be NULL if there is no input

    *OutputBufferSize - on entry has the maxiumum size in bytes that can be
              written into Buffer and on return contains the actual
                  number of bytes written into Buffer. This can be NULL
                  if no output is expected to be returned, however if output
                  is returned the caller will not know how large a buffer
                  is needed to return it.

    OutputBuffer - buffer in which to return the output WNODE_SINGLE_INSTANCE.
                   This can be NULL if there is no output WNODE or the
                   caller wants to determine the size needed for the
                   output WNODE.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_METHOD_ITEM MethodWnode;
    PWNODE_HEADER WnodeHeader;
    ULONG MethodInstanceNameLen;
    ULONG MethodWnodeSize, MethodWnodeOffset;
    ULONG Status;
    ULONG BufferSize;
    PWCHAR InstanceNamePtr;
    ULONG OutSize;
    PUCHAR DataPtr;
    ULONG BaseMethodWnodeSize;
    ULONG RetSize;

    EtwpInitProcessHeap();

    //
    // Validate input parameters
    if ((MethodInstanceName == NULL) ||
        ((InputValueBuffer == NULL) &&
         (InputValueBufferSize != 0)))
    {
        //
        // All input parameters must be specifies or all input parameters
        // must NOT be specified.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Caller can pass a NULL output buffer when he only wants to get the
    // size needed for the output buffer or the method returns a void.
    //
    if (OutputBuffer == NULL)
    {
        BufferSize = 0;
    } else {
        if (OutputBufferSize != NULL)
        {
            try
            {
                BufferSize = *OutputBufferSize;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(ERROR_INVALID_PARAMETER);
            }

            if (BufferSize >= 0x80000000)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(ERROR_INVALID_PARAMETER);
            }
        } else {
            //
            // OutputBuffer is specified, but OutBufferSize is not specified
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return(ERROR_INVALID_PARAMETER);
        }
    }

    try
    {
        MethodInstanceNameLen = wcslen(MethodInstanceName) *
                                    sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // We need to allocate a buffer that is large enough for the
    // WNODE_METHOD_ITEM that contains the method call and any data passed
    // into the method

    //
    // Compute the size of the WNODE that can be returned from the provider
    BaseMethodWnodeSize = (FIELD_OFFSET(WNODE_METHOD_ITEM, VariableData) +
                       MethodInstanceNameLen + sizeof(USHORT) + 7) & ~7;

    OutSize = BaseMethodWnodeSize + BufferSize;

    //
    // Make sure we allocate enough room for the larger of the input or
    // output buffers.
    if (InputValueBufferSize > BufferSize)
    {
        BufferSize = InputValueBufferSize;
    }
    MethodWnodeSize = BaseMethodWnodeSize + BufferSize;

    MethodWnode = (PWNODE_METHOD_ITEM)EtwpAlloc(MethodWnodeSize);
    if (MethodWnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE_METHOD_ITEM containing method being called
    //
    memset(MethodWnode, 0, FIELD_OFFSET(WNODE_METHOD_ITEM, VariableData));
    MethodWnode->MethodId = MethodId;
    MethodWnode->OffsetInstanceName = FIELD_OFFSET(WNODE_METHOD_ITEM,
                                                   VariableData);
    MethodWnode->DataBlockOffset = BaseMethodWnodeSize;
    InstanceNamePtr = (PWCHAR)OffsetToPtr(MethodWnode,
                                          MethodWnode->OffsetInstanceName);
    *InstanceNamePtr++ = (USHORT)MethodInstanceNameLen;
    try
    {
        memcpy(InstanceNamePtr,
                   MethodInstanceName,
                   MethodInstanceNameLen);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpFree(MethodWnode);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (InputValueBuffer != NULL)
    {
        MethodWnode->SizeDataBlock = InputValueBufferSize;
        DataPtr = (PUCHAR)OffsetToPtr(MethodWnode,
                                      MethodWnode->DataBlockOffset);
        try
        {
            memcpy(DataPtr, InputValueBuffer, InputValueBufferSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            EtwpFree(MethodWnode);
            SetLastError(ERROR_INVALID_PARAMETER);
            return(ERROR_INVALID_PARAMETER);
        }
    }
    
    EtwpBuildWnodeHeader(&MethodWnode->WnodeHeader,
                         MethodWnode->DataBlockOffset + 
                             MethodWnode->SizeDataBlock,
                         WNODE_FLAG_METHOD_ITEM,
                         MethodDataBlockHandle);

    Status = EtwpSendWmiRequest(
                                    WMI_EXECUTE_METHOD,
                                    (PWNODE_HEADER)MethodWnode,
                                    MethodWnode->WnodeHeader.BufferSize,
                                    MethodWnode,
                                    OutSize,
                                    &RetSize);

    if ((Status == ERROR_SUCCESS) &&
        ((RetSize < sizeof(WNODE_TOO_SMALL) ||
         ((RetSize >= sizeof(ULONG)) &&
          (RetSize < MethodWnode->WnodeHeader.BufferSize)))))
    {
        Status = ERROR_WMI_DP_FAILED;
        EtwpAssert(FALSE);
    }  
    
    if (Status == ERROR_SUCCESS)
    {
        WnodeHeader = (PWNODE_HEADER)MethodWnode;
        if (WnodeHeader->Flags & WNODE_FLAG_TOO_SMALL)
        {
            Status = ERROR_INSUFFICIENT_BUFFER;
            if (OutputBufferSize != NULL)
            {
                try
                {
                    *OutputBufferSize = ((PWNODE_TOO_SMALL)WnodeHeader)->SizeNeeded -
                                     BaseMethodWnodeSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        } else {
            //
            // Success, return results to caller
            //
            try
            {
                if (OutputBufferSize != NULL)
                {
                    if (*OutputBufferSize >=  MethodWnode->SizeDataBlock)
                    {
                        if (OutputBuffer != NULL)
                        {
                            DataPtr = (PUCHAR)OffsetToPtr(MethodWnode,
                                               MethodWnode->DataBlockOffset);
                            memcpy(OutputBuffer,
                                   DataPtr,
                                   MethodWnode->SizeDataBlock);
                        }
                    } else {
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }

                    *OutputBufferSize = MethodWnode->SizeDataBlock;
                } else if (MethodWnode->SizeDataBlock != 0) {
                    Status = ERROR_INSUFFICIENT_BUFFER;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALID_PARAMETER;
            }
        }
    }

    EtwpFree(MethodWnode);

    SetLastError(Status);
    return(Status);
}

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    )
/*+++

Routine Description:

    This routine frees a buffer allocated by WMI. This routine is typically
    used by applications that receive events via the Window message
    notification mechanism.

Arguments:

    Buffer is a buffer returned by WMI that the app wishes to free

Return Value:

---*/
{
    EtwpInitProcessHeap();

    if (Buffer != NULL)
    {
        EtwpDebugPrint(("WMI: WMIFreeBuffer(%x)\n", Buffer));
        EtwpFree(Buffer);
    } else {
        EtwpDebugPrint(("WMI: NULL passed to WMIFreeBuffer\n"));
    }
}

// TODO: Make WmiFile

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT PCHAR InstanceNames
    )
/*++

Routine Description:

    ANSI thunk to WMIFileHandleToInstanceNameW

--*/
{
    ULONG Status;
    PWCHAR InstanceNamesUnicode;
    PWCHAR WCharPtr;
    PCHAR Ansi, AnsiPtr;
    ULONG AnsiLen, AnsiSize;
    ULONG CharAvailable, CharReturned;
    ULONG AnsiStringSize;

    EtwpInitProcessHeap();

    CharAvailable = *NumberCharacters;
    CharReturned = CharAvailable;

    do
    {
        //
        // We loop until we call with a buffer big enough to return
        // the entire list of instance names.
        InstanceNamesUnicode = EtwpAlloc(CharReturned * sizeof(WCHAR));

        if (InstanceNamesUnicode == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            SetLastError(Status);
            return(Status);
        }

        Status = WmiFileHandleToInstanceNameW(DataBlockHandle,
                                              FileHandle,
                                              &CharReturned,
                                              InstanceNamesUnicode);

        if (Status != ERROR_INSUFFICIENT_BUFFER)
        {
            break;
        }

        EtwpFree(InstanceNamesUnicode);
    } while (TRUE);

    //
    // CONSIDER: MB Strings
    if (Status == ERROR_SUCCESS)
    {
        //
        // Determine the size needed for the ansi buffer
        WCharPtr = InstanceNamesUnicode;
        AnsiSize = 1;
        while (*WCharPtr != UNICODE_NULL)
        {
            Status = AnsiSizeForUnicodeString(WCharPtr, &AnsiStringSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }

            AnsiSize += AnsiStringSize;
            WCharPtr += wcslen(WCharPtr)+1;
        }

        //
        // CONSIDER: MB String
        if (AnsiSize > CharAvailable)
        {
            Status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            //
            // Copy the list of unicode strings to ansi strings. End of list
            // is double NULL.
            AnsiPtr = InstanceNames;
            try
            {
                AnsiPtr[0] = 0;
                AnsiPtr[1] = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_NOACCESS;
                goto Done;
            }
            WCharPtr = InstanceNamesUnicode;
            while (*WCharPtr != UNICODE_NULL)
            {
                try
                {
                    Status = UnicodeToAnsi(WCharPtr, &AnsiPtr, &AnsiLen);
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }

                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;
                *AnsiPtr = 0;
                WCharPtr += wcslen(WCharPtr)+1;
            }
        }

Done:
        try
        {
            *NumberCharacters = AnsiSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = ERROR_NOACCESS;
        }
    }

    EtwpFree(InstanceNamesUnicode);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT PWCHAR InstanceNames
    )
/*+++

Routine Description:

    This routine will return all of the WMI instance names provided for a
    data block within the device stack targeted by a file handle. Note
    that not all data providers will support this functionality.

Arguments:

    DataBlockHandle - Handle to data block

    FileHandle - handle to a device whose stack is targeted

    *NumberCharacters - On entry has maximum size in characters of Buffer. If
        ERROR_BUFFER_TOO_SMALL is returned then it returns with the number
        of character needed.

    InstanceNames - if successful, returns with a list of single null
        terminated strings which are the WMI instance names. The last instance
        name is double null terminated

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    PWMIFHTOINSTANCENAME FhToInstanceName;
    ULONG RetSize;
    ULONG Status;
    WCHAR LocalInstanceNames[2];
    ULONG BufferSize;
    ULONG SizeNeeded;
    WCHAR Suffix[MAX_PATH];
    ULONG SuffixLen, CharsNeeded;
    HRESULT hr;

    EtwpInitProcessHeap();

    BufferSize = *NumberCharacters;

    //
    // Start off by assuming that there is only one instance name and so
    // only alloc space for that.
    //
    SizeNeeded = FIELD_OFFSET(WMIFHTOINSTANCENAME, InstanceNames) +
           (MAX_PATH * sizeof(WCHAR));
Again:
    FhToInstanceName = EtwpAlloc(SizeNeeded + sizeof(WCHAR));
    if (FhToInstanceName == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);

    }

    WmipSetHandle3264(FhToInstanceName->FileHandle, FileHandle);
    WmipSetHandle3264(FhToInstanceName->KernelHandle, DataBlockHandle);

    Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_TRANSLATE_FILE_HANDLE,
                                  FhToInstanceName,
                                  FIELD_OFFSET(WMIFHTOINSTANCENAME,
                                               InstanceNames),
                                  FhToInstanceName,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);
    if (Status == ERROR_SUCCESS)
    {
        if (RetSize == sizeof(ULONG))
        {
            //
            // If buffer passed was too small then try with a bigger buffer
            //
            SizeNeeded = FhToInstanceName->SizeNeeded + sizeof(WCHAR);
            EtwpFree(FhToInstanceName);
            goto Again;
        } else {
            if ((RetSize < sizeof(WMIFHTOINSTANCENAME)) ||
                (RetSize < (ULONG)(FhToInstanceName->InstanceNameLength +
                            FIELD_OFFSET(WMIFHTOINSTANCENAME, InstanceNames))))
            {
                //
                // WMI KM returned a bogus size which should not happen
                //
                Status = ERROR_WMI_DP_FAILED;
                EtwpAssert(FALSE);
            } else {
                
                //
                // Copy the results back to the users buffer if 
                // there is enough space
                //
                StringCbPrintf(Suffix,
                               sizeof(Suffix),
                               L"_%d",
                               FhToInstanceName->BaseIndex);
                
                SuffixLen = wcslen(Suffix);
                
                try
                {
                    CharsNeeded = (FhToInstanceName->InstanceNameLength /
                                         sizeof(WCHAR)) + SuffixLen + 1;
                    
                    *NumberCharacters = CharsNeeded;
                    if (BufferSize >= CharsNeeded)
                    {
                        hr = StringCchCopy(InstanceNames,
                                          BufferSize,
                                          &FhToInstanceName->InstanceNames[0]);
                        WmipAssert(hr == S_OK);
                        
                        hr = StringCchCat(InstanceNames,
                                    BufferSize,
                                    Suffix);
                        WmipAssert(hr == S_OK);
                        
                        InstanceNames[CharsNeeded-2] = UNICODE_NULL;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }

    EtwpFree(FhToInstanceName);
    SetLastError(Status);

    return(Status);

}

ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *InOutGuidCount
    )
/*++

Routine Description:

    This routine will enumerate all of the guids that are
    registered with WMI.

Arguments:

    GuidList is a pointer to an array of guids that is returned with the

    *GuidCount on entry is the number of guids that can be written to
        GuidList and if ERROR_SUCCESS is returned it has the actual number
        of guids written to GuidList. If ERROR_MORE_DATA is returned
        it has the total number of guids that are available to be returned.


Return Value:

    ERROR_SUCCESS if all guids returned, ERROR_MORE_DATA if not all guids
    were returned or another error code on error

--*/
{
    ULONG Status;
    PWMIGUIDLISTINFO GuidListInfo;
    ULONG GuidCount;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG i;

    EtwpInitProcessHeap();
    
    try
    {
        GuidCount = *InOutGuidCount;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if ((GuidList == NULL) && (GuidCount != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }
    
    //
    // Allocate space for returning guids
    //
    SizeNeeded = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                     GuidCount * sizeof(WMIGUIDPROPERTIES);
    
    GuidListInfo = EtwpAlloc(SizeNeeded);
    if (GuidListInfo != NULL)
    {
        Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_ENUMERATE_GUIDS,
                                  GuidListInfo,
                                  SizeNeeded,
                                  GuidListInfo,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);
                              
        if (Status == ERROR_SUCCESS)
        {
            if ((RetSize < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) ||
                (RetSize < (FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                            GuidListInfo->ReturnedGuidCount * sizeof(WMIGUIDPROPERTIES))))
            {
                //
                // WMI KM returned to us a bad size which should not happen
                //
                Status = ERROR_WMI_DP_FAILED;
                EtwpAssert(FALSE);
            } else {
                try
                {
                    for (i = 0; i < GuidListInfo->ReturnedGuidCount; i++)
                    {
                        GuidList[i] = GuidListInfo->GuidList[i].Guid;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }
                
                try
                {
                    //
                    // Return the total guid count which is also the actual
                    // guid count if we returned all guids correctly
                    //
                    *InOutGuidCount = GuidListInfo->TotalGuidCount;
                    if (GuidListInfo->ReturnedGuidCount != GuidListInfo->TotalGuidCount)
                    {
                        //
                        // If we did not return all of the guids, change 
                        // return status to something more appropriate
                        //
                        Status = ERROR_MORE_DATA;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }                    
            }
        }
                              
                              
        EtwpFree(GuidListInfo);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT PCHAR InstanceName,
    IN ULONG InstanceNameLength,
    IN PCHAR DevInst,
    IN ULONG InstanceIndex
    )
/*++

Routine Description:

    This routine will convert a device instance name and an instance index
    into a WMI instance name.

Arguments:

    InstanceName is a pointer to a buffer that returns with the WMI instance
        name if the buffer is large enough

    InstanceNameLength has the number of characters that can be written into
        InstanceName

    DevInst is the Device Instance Name

    InstanceIndex is the instance index

Return Value:

    number of characters that compose the WMI instance name

--*/
{
    CHAR Temp[MAX_PATH];
    ULONG SizeNeeded;
    HRESULT hr;

    EtwpInitProcessHeap();

    StringCbPrintfA(Temp, sizeof(Temp), "_%d", InstanceIndex);
    SizeNeeded = strlen(Temp) + strlen(DevInst) + 1;
    if (InstanceNameLength >= SizeNeeded)
    {
        hr = StringCchCopyA(InstanceName, InstanceNameLength, DevInst);
        WmipAssert(hr == S_OK);
        
        hr = StringCchCatA(InstanceName, InstanceNameLength, Temp);
        WmipAssert(hr == S_OK);     
    }
    return(SizeNeeded);
}

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT PWCHAR InstanceName,
    IN ULONG InstanceNameLength,
    IN PWCHAR DevInst,
    IN ULONG InstanceIndex
    )
{
    WCHAR Temp[MAX_PATH];
    ULONG SizeNeeded;
    HRESULT hr;

    EtwpInitProcessHeap();

    StringCbPrintf(Temp, sizeof(Temp), L"_%d", InstanceIndex);
    SizeNeeded = wcslen(Temp) + wcslen(DevInst) + 1;
    if (InstanceNameLength >= SizeNeeded)
    {
        hr = StringCchCopy(InstanceName, InstanceNameLength, DevInst);
        WmipAssert(hr == S_OK);
        
        hr = StringCchCat(InstanceName, InstanceNameLength, Temp);
        WmipAssert(hr == S_OK);
    }
    return(SizeNeeded);
}

ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE DataBlockHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    )
/*++

Routine Description:

    This routine will query information about a specific guid based upon
    the guid handle passed

Arguments:

    GuidHandle is the handle to the GUID whose information is being queried

    GuidInfo returns with the guid information

Return Value:

    ERROR_SUCCESS or error code

--*/
{
    WMIQUERYGUIDINFO QueryGuidInfo;
    ULONG Status;
    ULONG RetSize;

    EtwpInitProcessHeap();

    WmipSetHandle3264(QueryGuidInfo.KernelHandle, DataBlockHandle);
    Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_QUERY_GUID_INFO,
                                  &QueryGuidInfo,
                                  sizeof(QueryGuidInfo),
                                  &QueryGuidInfo,
                                  sizeof(QueryGuidInfo),
                                  &RetSize,
                                  NULL);

    if (Status == ERROR_SUCCESS)
    {
        if (RetSize == sizeof(QueryGuidInfo))
        {
            try
            {
                GuidInfo->IsExpensive = QueryGuidInfo.IsExpensive;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(ERROR_NOACCESS);
                return(ERROR_NOACCESS);
            }
        } else {
            //
            // WMI KM returned an invalid size which should not happen
            //
            Status = ERROR_WMI_DP_FAILED;
            EtwpAssert(FALSE);
        }
    }

    SetLastError(Status);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\srvmain.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    srvmain.c

Abstract:

    This routine is a service stub for WDM WMI service. This is for
    backward compatibility with Windows 2000 where other services
    were dependent on WDM WMI Service.  

Author:

    27-Mar-2001 Melur Raghuraman

Revision History:

--*/

#include "wmiump.h"

SERVICE_STATUS_HANDLE   WmiServiceStatusHandle;
SERVICE_STATUS          WmiServiceStatus;
HANDLE                  EtwpTerminationEvent;

VOID
EtwpUpdateServiceStatus (
    DWORD   dwState
    )
{
    EtwpAssert(WmiServiceStatusHandle);

    WmiServiceStatus.dwCurrentState = dwState;
    SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus);
}

VOID
WINAPI
WmiServiceCtrlHandler (
    DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        EtwpUpdateServiceStatus (SERVICE_STOP_PENDING);
        NtSetEvent( EtwpTerminationEvent, NULL );
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        EtwpAssert (WmiServiceStatusHandle);
        SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus);
        break;
    }
}

VOID
WINAPI
WdmWmiServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    NTSTATUS Status;

    RtlZeroMemory (&WmiServiceStatus, sizeof(WmiServiceStatus));
    WmiServiceStatus.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    WmiServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    WmiServiceStatusHandle = RegisterServiceCtrlHandler (L"Wmi", WmiServiceCtrlHandler);
    if (WmiServiceStatusHandle)
    {
        EtwpUpdateServiceStatus (SERVICE_RUNNING);

        Status =  NtCreateEvent( &EtwpTerminationEvent, 
                                  EVENT_ALL_ACCESS, 
                                  NULL, 
                                  SynchronizationEvent, 
                                  FALSE
                                 );
        if (!NT_SUCCESS(Status) ) {
            EtwpDebugPrint(("WMI: CreateEvent Failed %d\n", GetLastError() ));
        }
        else {
            Status = NtWaitForSingleObject( EtwpTerminationEvent, FALSE, NULL);
        }

        EtwpUpdateServiceStatus (SERVICE_STOPPED);
    }
    else 
    {
        EtwpDebugPrint( ( "WMI: RegisterServiceCtrlHandler failed %d\n", GetLastError() ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Alan Warwick

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=wmi
MINORCOMP=wmidll

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\rpcrt4.lib \
            $(SDK_LIB_PATH)\ntdll.lib

INCLUDES=$(INCLUDES);       \
         ..;                \
         ..\..\inc;         \
         ..\..\..\..\inc;   \
         $(BASE_INC_PATH);  \
         $(PROJECT_ROOT)\published\wmi\inc; \

C_DEFINES=$(C_DEFINES) -D__MIDL_USER_DEFINED

SOURCES_LIST= \
        ..\dcapi.c \
        ..\chunk.c \
        ..\tracedc.c \
        ..\tracert.c \
        ..\tracesup.c \
        ..\intrnldp.c \
        ..\srvmain.c\
        ..\mofapi.c\
        ..\tracehw.c

UMTYPE=windows

# USE_MSVCRT=1 for debug builds and USE_NTDLL=1 for retail
USE_MSVCRT=1
#USE_NTDLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\tracedc.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    tracedc.c

Abstract:

    Basic data consumer APIs to process trace data directly from buffers.


Author:

    15-Sep-1997 JeePang

Revision History:

    18-Apr-2001 insungp

        Added asynchronopus IO for reading log files.
        Also replaced WmiGetFirstTraceOffset() calls with sizeof(WMI_BUFFER_HEADER).

--*/


#ifndef MEMPHIS


#include "tracep.h"

PLIST_ENTRY  EventCallbackListHead = NULL;
ETW_QUERY_PROPERTIES QueryProperties;
PTRACE_GUID_MAP  EventMapList = NULL;
PLIST_ENTRY TraceHandleListHeadPtr = NULL;

VOID
EtwpInsertBuffer (
    PTRACE_BUFFER_LIST_ENTRY *Root,
    PTRACE_BUFFER_LIST_ENTRY NewEntry
    )
/*++

Routine Description:
    This routine inserts a buffer in a sorted list. The insertion 
    is done based on the timestamp of the BufferHeader. If two buffers
    have the same timestamp, then the BufferIndex is used to resolve the tie.

Arguments:
    Root - Pointer to the root of the LIST
    NewEntry - Entry being inserted

Returned Value:

    None

--*/
{
    PTRACE_BUFFER_LIST_ENTRY Current, Prev;
    //
    // If List is empty, make the new entry the Root and return.
    //

    if (NewEntry == NULL) {
        return;
    }

    if (*Root == NULL) {
        *Root = NewEntry;
        NewEntry->Next = NULL;
        return;
    }

    //
    // Traverse the list and insert the NewEntry in order
    //
    Prev = NULL;
    Current = *Root;

    while (Current != NULL) {
        if ((ULONGLONG)NewEntry->Event.Header.TimeStamp.QuadPart < 
            (ULONGLONG)Current->Event.Header.TimeStamp.QuadPart) {
            if (Prev != NULL) {
                Prev->Next = NewEntry;
            }
            else {
                *Root = NewEntry;
            }
            NewEntry->Next = Current;
            return;
        }
        else if ((ULONGLONG)NewEntry->Event.Header.TimeStamp.QuadPart == 
                 (ULONGLONG)Current->Event.Header.TimeStamp.QuadPart) {
            if (NewEntry->FileOffset < Current->FileOffset) {
                if (Prev != NULL) {
                    Prev->Next = NewEntry;
                }
                else {
                    *Root = NewEntry;
                }
                NewEntry->Next = Current;
                return;
            }
        }
        Prev = Current;
        Current = Current->Next;
    }


    if (Prev != NULL) {
        Prev->Next = NewEntry;
        NewEntry->Next = NULL;
    }
#if DBG
    else {
        EtwpAssert(Prev != NULL);
    }
#endif
    return;
}


PTRACE_BUFFER_LIST_ENTRY
EtwpRemoveBuffer(
    PTRACE_BUFFER_LIST_ENTRY *Root
    )
{
    PTRACE_BUFFER_LIST_ENTRY OldEntry = *Root;

    if (OldEntry == NULL)
        return NULL;
    *Root = OldEntry->Next;
    OldEntry->Next = NULL;
    return OldEntry;
}

PVOID
EtwpGetCurrentBuffer(
    PTRACELOG_CONTEXT pContext,
    PTRACE_BUFFER_LIST_ENTRY Current
    )
{
    NTSTATUS Status;

    LONG FileOffset = (ULONG)Current->FileOffset;
    ULONG nBytesRead;
    LONG TableIndex;

    HANDLE hFile = pContext->Handle;
    ULONG BufferSize = pContext->BufferSize;
    PVOID pBuffer;
    ULONGLONG Offset;

    DWORD BytesTransffered;

    //
    // Look for the buffer in cache.
    //
    TableIndex = FileOffset % MAX_TRACE_BUFFER_CACHE_SIZE;

    if (pContext->BufferCache[TableIndex].Index == FileOffset) {
        //
        // Check whether the buffer we want is still being read.
        // If so, we need to wait for it to finish.
        //
        if (pContext->BufferBeingRead == FileOffset) {
            if (GetOverlappedResult(hFile, &pContext->AsynchRead, &BytesTransffered, TRUE)) {
                pContext->BufferBeingRead = -1;
            }
            else { // getting the result failed
                return NULL;
            }
        }
        return pContext->BufferCache[TableIndex].Buffer;
    }

// 
// Do a synch read for the buffer we need. We still need to make sure the 
// previous read has completed.
//
    pBuffer = pContext->BufferCache[TableIndex].Buffer;
    Offset = FileOffset * BufferSize;
    if (pContext->BufferBeingRead != -1) {
        if (!GetOverlappedResult(hFile, &pContext->AsynchRead, &BytesTransffered, TRUE) &&
            GetLastError() != ERROR_HANDLE_EOF) {
            EtwpDebugPrint(("GetOverlappedResult failed with Status %d in GetCurrentBuffer\n", GetLastError()));
            // cannot determine the status of the previous read
            return NULL;
        }
    }
    // Not necessary, but PREFIX likes it.
    nBytesRead = 0;
    pContext->AsynchRead.Offset = (DWORD)(Offset & 0xFFFFFFFF);
    pContext->AsynchRead.OffsetHigh = (DWORD)(Offset >> 32);
    Status = EtwpSynchReadFile(hFile,
                    (LPVOID)pBuffer,
                    BufferSize,
                    &nBytesRead,
                    &pContext->AsynchRead);
    pContext->BufferBeingRead = -1;
    if (nBytesRead == 0) {
        return NULL;
    }
    //
    // Update the cache entry with the one just read in
    //

    pContext->BufferCache[TableIndex].Index = FileOffset;

    //
    // We need to account for event alignments when backtracking to get the MofPtr.
    // (BufferOffset - EventSize) backtracks to the start of the current event. 
    // Add EventHeaderSize and Subtract the MofLength gives the MofPtr. 
    //
    if (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT) {
        Current->Event.MofData = ((PUCHAR)pBuffer 
                                        + Current->BufferOffset 
                                        - Current->EventSize);
        if (pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {

            //
            // Need to override the timestamp with SystemTime
            //
            switch(Current->TraceType) {
                case TRACE_HEADER_TYPE_PERFINFO32:
                case TRACE_HEADER_TYPE_PERFINFO64:
                {
                    PPERFINFO_TRACE_HEADER   pPerf;
                    pPerf = (PPERFINFO_TRACE_HEADER)Current->Event.MofData;
                    pPerf->SystemTime = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM32:
                {
                    PSYSTEM_TRACE_HEADER pSystemHeader32;
                    pSystemHeader32 = (PSYSTEM_TRACE_HEADER) 
                                      Current->Event.MofData;
                    pSystemHeader32->SystemTime = 
                                      Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM64:
                {
                    PSYSTEM_TRACE_HEADER pSystemHeader64;
                    pSystemHeader64 = (PSYSTEM_TRACE_HEADER) 
                                      Current->Event.MofData;
                    pSystemHeader64->SystemTime =
                                     Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_FULL_HEADER:
                {
                    PEVENT_TRACE_HEADER pWnodeHeader = (PEVENT_TRACE_HEADER) Current->Event.MofData;
                    pWnodeHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_INSTANCE:
                {
                    if (((pContext->Logfile.LogfileHeader.VersionDetail.SubVersion >= 1) && 
                        (pContext->Logfile.LogfileHeader.VersionDetail.SubMinorVersion >= 1)) ||
                        pContext->Logfile.LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
                        // Use new header for event instances.
                        PEVENT_INSTANCE_GUID_HEADER pInstanceHeader = (PEVENT_INSTANCE_GUID_HEADER) Current->Event.MofData;
                        pInstanceHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    }
                    else {
                        PEVENT_INSTANCE_HEADER pInstanceHeader = (PEVENT_INSTANCE_HEADER) Current->Event.MofData;
                        pInstanceHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    }
                    break;
                }
                case TRACE_HEADER_TYPE_TIMED:
                {
                    PTIMED_TRACE_HEADER pTimedHeader = (PTIMED_TRACE_HEADER) Current->Event.MofData;
                    pTimedHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    break;
                }
            case TRACE_HEADER_TYPE_WNODE_HEADER:
                break;

                case TRACE_HEADER_TYPE_MESSAGE:
                {   PEVENT_TRACE_HEADER pWnodeHeader = (PEVENT_TRACE_HEADER) Current->Event.MofData ;
                    pWnodeHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    
                    break;
                }
            }
        }
    }
    else {

        //
        // When The FileOffset is 0 (First Buffer) and the EventType is 
        // LOGFILE_HEADER
        // 

        if ( (FileOffset == 0) && 
             ((Current->BufferOffset - Current->EventSize) == sizeof(WMI_BUFFER_HEADER)) ) 
        {
            PTRACE_LOGFILE_HEADER pLogHeader = (PTRACE_LOGFILE_HEADER)((PUCHAR)pBuffer 
                                                + Current->BufferOffset
                                                - Current->EventSize 
                                                + sizeof(SYSTEM_TRACE_HEADER));
            pLogHeader->LoggerName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER));
            pLogHeader->LogFileName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER) 
                                    + (wcslen(pLogHeader->LoggerName) + 1) * sizeof(WCHAR));

            Current->Event.MofData = (PUCHAR)pLogHeader;
        }
        else 
        {
            Current->Event.MofData = ((PUCHAR)pBuffer 
                                        + Current->BufferOffset 
                                        - Current->EventSize 
                                        + Current->Event.Header.Size 
                                        - Current->Event.MofLength );
        }
    }

    return pBuffer;
}

PTRACELOG_CONTEXT
EtwpAllocateTraceHandle()
{
    PLIST_ENTRY Next, Head;
    PTRACELOG_CONTEXT NewHandleEntry, pEntry;

    EtwpEnterPMCritSection();

    if (TraceHandleListHeadPtr == NULL) {
        TraceHandleListHeadPtr = EtwpAlloc(sizeof(LIST_ENTRY));
        if (TraceHandleListHeadPtr == NULL) {
            EtwpLeavePMCritSection();
            return NULL;
        }
        InitializeListHead(TraceHandleListHeadPtr);
    }

    NewHandleEntry = EtwpAlloc(sizeof(TRACELOG_CONTEXT));
    if (NewHandleEntry == NULL) {
        EtwpLeavePMCritSection();
        return NULL;
    }

    RtlZeroMemory(NewHandleEntry, sizeof(TRACELOG_CONTEXT));

    // AsynchRead initialization
    NewHandleEntry->BufferBeingRead = -1;
    NewHandleEntry->AsynchRead.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (NewHandleEntry->AsynchRead.hEvent == NULL) {
        EtwpFree(NewHandleEntry);
        EtwpLeavePMCritSection();
        return NULL;
    }

    InitializeListHead(&NewHandleEntry->StreamListHead);

    InitializeListHead(&NewHandleEntry->GuidMapListHead);
    Head = TraceHandleListHeadPtr;
    Next = Head->Flink;
    if (Next == Head) {
       NewHandleEntry->TraceHandle = 1;
       InsertTailList(Head, &NewHandleEntry->Entry);
       EtwpLeavePMCritSection();
       return NewHandleEntry;
    }

    while (Next != Head) {
        pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
        Next = Next->Flink;
        NewHandleEntry->TraceHandle++;
        if (NewHandleEntry->TraceHandle < pEntry->TraceHandle) {
            InsertTailList(&pEntry->Entry, &NewHandleEntry->Entry);
            EtwpLeavePMCritSection();
            return NewHandleEntry;
        }
    }

    //
    // TODO: Need to optimize this case out first before searching...
    //
    NewHandleEntry->TraceHandle++;
    InsertTailList(Head, &NewHandleEntry->Entry);
    EtwpLeavePMCritSection();
    return NewHandleEntry;

}

PTRACELOG_CONTEXT
EtwpLookupTraceHandle(
    TRACEHANDLE TraceHandle
    )
{
     PLIST_ENTRY Head, Next;
     PTRACELOG_CONTEXT pEntry;

     EtwpEnterPMCritSection();
     Head = TraceHandleListHeadPtr;

     if (Head == NULL) {
         EtwpLeavePMCritSection();
         return NULL;
     }
     Next = Head->Flink;
     while (Next != Head) {
        pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
        Next = Next->Flink;

        if (TraceHandle == pEntry->TraceHandle) {
            EtwpLeavePMCritSection();
            return pEntry;
        }
    }
    EtwpLeavePMCritSection();
    return NULL;
}

ULONG
EtwpFreeTraceHandle(
        TRACEHANDLE TraceHandle
        )
{
    PLIST_ENTRY Head, Next;
    PTRACELOG_CONTEXT pEntry;

    EtwpEnterPMCritSection();

    Head = TraceHandleListHeadPtr;
    if (Head == NULL) {
        EtwpLeavePMCritSection();
        return ERROR_INVALID_HANDLE;
    }
    Next = Head->Flink;

    while (Next != Head) {
       pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
       Next = Next->Flink;
       if (TraceHandle == pEntry->TraceHandle) {

           //
           // This test prevents someone calling CloseTrace on a Handle
           // while another thread is busy executing ProcessTrace on the 
           // same handle. 
           // TODO: We could implement a RefCount approach which would 
           // allow this to succeed but ProcessTrace will cleanup if
           // someone has already called CloseTrace?
           //
           //

           if (pEntry->fProcessed == TRUE)
           {
               EtwpLeavePMCritSection();
               return ERROR_BUSY;
           }

           RemoveEntryList(&pEntry->Entry);

           // Free pEntry memory
           //
           if (pEntry->Logfile.LogFileName != NULL)
           {
               EtwpFree(pEntry->Logfile.LogFileName);
           }
           if (pEntry->Logfile.LoggerName != NULL)
           {
               EtwpFree(pEntry->Logfile.LoggerName);
           }
           CloseHandle(pEntry->AsynchRead.hEvent);
           EtwpFree(pEntry);

           //
           // If the handle list is empty, then delete it.
           //
           if (Head == Head->Flink) {
                EtwpFree(TraceHandleListHeadPtr);
                TraceHandleListHeadPtr = NULL;
           }
           EtwpLeavePMCritSection();
           return ERROR_SUCCESS;
       }
   }
   EtwpLeavePMCritSection();
   return ERROR_INVALID_HANDLE;
}


ULONG
WMIAPI
EtwpCreateGuidMapping(void)
/*++

Routine Description:
    This routine is used to create the mapping array between GroupTypes and Guid
    for kernel events.

Arguments:
    None. 

Returned Value:

    None

--*/
{
    ULONG i = 0;
    ULONG listsize;

    EtwpEnterPMCritSection();

    if (EventMapList == NULL) { 
        listsize = sizeof(TRACE_GUID_MAP) * MAX_KERNEL_TRACE_EVENTS;
        EventMapList = (PTRACE_GUID_MAP) HeapAlloc(GetProcessHeap(), 
                                                   HEAP_ZERO_MEMORY, 
                                                   listsize);
        if (EventMapList == NULL) {
            EtwpLeavePMCritSection();
            return EtwpSetDosError(ERROR_OUTOFMEMORY);
        }

        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_IO;
        RtlCopyMemory(&EventMapList[i++].Guid,&DiskIoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_FILE;
        RtlCopyMemory(&EventMapList[i++].Guid, &FileIoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_TCPIP;
        RtlCopyMemory(&EventMapList[i++].Guid, &TcpIpGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_UDPIP;
        RtlCopyMemory(&EventMapList[i++].Guid, &UdpIpGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_THREAD;
        RtlCopyMemory(&EventMapList[i++].Guid, &ThreadGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PROCESS;
        RtlCopyMemory(&EventMapList[i++].Guid, &ProcessGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_MEMORY;
        RtlCopyMemory(&EventMapList[i++].Guid, &PageFaultGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_HEADER;
        RtlCopyMemory(&EventMapList[i++].Guid, &EventTraceGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PROCESS +
                                       EVENT_TRACE_TYPE_LOAD;
        RtlCopyMemory(&EventMapList[i++].Guid, &ImageLoadGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_REGISTRY;
        RtlCopyMemory(&EventMapList[i++].Guid, &RegistryGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_DBGPRINT;
        RtlCopyMemory(&EventMapList[i++].Guid, &DbgPrintGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_CONFIG;
        RtlCopyMemory(&EventMapList[i++].Guid, &EventTraceConfigGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_POOL;
        RtlCopyMemory(&EventMapList[i++].Guid, &PoolGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PERFINFO;
        RtlCopyMemory(&EventMapList[i++].Guid, &PerfinfoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_HEAP;
        RtlCopyMemory(&EventMapList[i++].Guid, &HeapGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_OBJECT;
        RtlCopyMemory(&EventMapList[i++].Guid, &ObjectGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_MODBOUND;
        RtlCopyMemory(&EventMapList[i++].Guid, &ModBoundGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_DPC;
        RtlCopyMemory(&EventMapList[i++].Guid, &DpcGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_POWER;
        RtlCopyMemory(&EventMapList[i++].Guid, &PowerGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_CRITSEC;
        RtlCopyMemory(&EventMapList[i++].Guid, &CritSecGuid, sizeof(GUID));
    }
    EtwpLeavePMCritSection();
    return EtwpSetDosError(ERROR_SUCCESS);
}

LPGUID
EtwpGuidMapHandleToGuid(
    PLIST_ENTRY GuidMapListHeadPtr,
    ULONGLONG    GuidHandle
    )
{
    PLIST_ENTRY Next, Head;
    PEVENT_GUID_MAP GuidMap;
    ULONG retry_count=0;

    EtwpEnterPMCritSection();
    
    Head = GuidMapListHeadPtr;
    Next = Head->Flink;
    while (Next != Head) {
        GuidMap = CONTAINING_RECORD( Next, EVENT_GUID_MAP, Entry );
        if (GuidMap->GuidHandle == GuidHandle) {
            EtwpLeavePMCritSection();
            return (&GuidMap->Guid);
        }
        Next = Next->Flink;
    }
    EtwpLeavePMCritSection();

    return NULL;
}

ULONG
EtwpAddGuidHandleToGuidMapList(
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONGLONG   GuidHandle,
    IN LPGUID      Guid
    )
{
    PEVENT_GUID_MAP GuidMap;

    if (GuidMapListHeadPtr != NULL)  {
        GuidMap = EtwpAlloc(sizeof(EVENT_GUID_MAP));
        if (GuidMap == NULL)
            return EtwpSetDosError(ERROR_OUTOFMEMORY);

        RtlZeroMemory(GuidMap, sizeof(EVENT_GUID_MAP));

        GuidMap->GuidHandle = GuidHandle;
        GuidMap->Guid = *Guid;
        EtwpEnterPMCritSection();
        InsertTailList(GuidMapListHeadPtr, &GuidMap->Entry);
        EtwpLeavePMCritSection();
    }
    return EtwpSetDosError(ERROR_SUCCESS);
}

void
EtwpCleanupGuidMapList(
        PLIST_ENTRY GuidMapListHeadPtr
    )
{
    EtwpEnterPMCritSection();
    if (GuidMapListHeadPtr != NULL) {
        PLIST_ENTRY Next, Head;
        PEVENT_GUID_MAP GuidMap;

        Head = GuidMapListHeadPtr;
        Next = Head->Flink;
        while (Next != Head) {
            GuidMap = CONTAINING_RECORD( Next, EVENT_GUID_MAP, Entry );
            Next = Next->Flink;
            RemoveEntryList(&GuidMap->Entry);
            EtwpFree(GuidMap);
        }
        GuidMapListHeadPtr = NULL;
    }
    EtwpLeavePMCritSection();

}


void
EtwpCleanupStreamList(
    PLIST_ENTRY StreamListHeadPtr
    )
{
    PLIST_ENTRY Next, Head;
    PTRACE_STREAM_CONTEXT pStream;

    if (StreamListHeadPtr != NULL) {
        Head = StreamListHeadPtr;
        Next = Head->Flink;
        while(Next != Head) {
            pStream = CONTAINING_RECORD(Next, TRACE_STREAM_CONTEXT, AllocEntry);
            Next = Next->Flink;
            RemoveEntryList(&pStream->AllocEntry);
            if (pStream->StreamBuffer != NULL) {
                EtwpFree(pStream->StreamBuffer);
            }
            if (ETW_LOG_BUFFER()) {
                DbgPrint("ETW: Stream %d  Proc %d Received %d Events\n", 
                     pStream->Type, pStream->ProcessorNumber, pStream->CbCount);
            }
            EtwpFree(pStream);
        }
    }
}


VOID
EtwpFreeCallbackList()
/*++

Routine Description:
    This routine removes all event callbacks and frees the storage. 

Arguments:
    None

Returned Value:

    None. 

--*/
{
    PLIST_ENTRY Next, Head;
    PEVENT_TRACE_CALLBACK EventCb;


    if (EventCallbackListHead == NULL) 
        return;
    
    EtwpEnterPMCritSection();

    Head = EventCallbackListHead;
    Next = Head->Flink;
    while (Next != Head) {
        EventCb = CONTAINING_RECORD( Next, EVENT_TRACE_CALLBACK, Entry );
        Next = Next->Flink;
        RemoveEntryList(&EventCb->Entry);
        EtwpFree(EventCb);
    }

    EtwpFree(EventCallbackListHead);
    EventCallbackListHead = NULL;

    EtwpLeavePMCritSection();
}


PEVENT_TRACE_CALLBACK
EtwpGetCallbackRoutine(
    LPGUID pGuid
    )
/*++

Routine Description:
    This routine returns the callback function for a given Guid. 
    If no callback was registered for the Guid, returns NULL. 

Arguments:
    pGuid           pointer to the Guid.

Returned Value:

    Event Trace Callback Function. 

--*/
{
    PLIST_ENTRY head, next;
    PEVENT_TRACE_CALLBACK pEventCb = NULL;

    if (pGuid == NULL)
        return NULL;

    EtwpEnterPMCritSection();

    if (EventCallbackListHead == NULL) {
        EtwpLeavePMCritSection();
        return NULL;
    }

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        pEventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        if (IsEqualGUID(pGuid, &pEventCb->Guid)) {
            EtwpLeavePMCritSection();
            return (pEventCb);
        }
        next = next->Flink;
    }

    EtwpLeavePMCritSection();
    return NULL;
    
}


ULONG 
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    )
/*++

Routine Description:

    This routine is used to wire a callback function for Guid. The 
    callback function is called when an Event with this Guid is found in
    the subsequent ProcessTraceLog Call. 

Arguments:

    pGuid           Pointer to the Guid.

    func            Callback Function Address. 


Return Value:
    ERROR_SUCCESS   Callback function is wired
    


--*/
{
    PEVENT_TRACE_CALLBACK pEventCb;
    PLIST_ENTRY head, next;
    GUID FilterGuid;
    ULONG Checksum;
    ULONG Status;

    EtwpInitProcessHeap();
    
    if ((pGuid == NULL) || (EventCallback == NULL) || 
        (EventCallback == (PEVENT_CALLBACK) -1 ) ) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    //
    // Capture the Guid first. We try to access the first ULONG of the 
    // function address to see if AV. 
    // TODO: Perhaps we should check to see if it's a valid user mode address.
    //
    try {
        FilterGuid = *pGuid;
        Checksum = *((PULONG)EventCallback);
        if (Checksum) {
            Status = Checksum;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return EtwpSetDosError(ERROR_NOACCESS);
    }

    EtwpEnterPMCritSection();

    if (EventCallbackListHead == NULL) {
        EventCallbackListHead = (PLIST_ENTRY) EtwpAlloc(sizeof(LIST_ENTRY));
        if (EventCallbackListHead == NULL) {
            EtwpLeavePMCritSection();
            return EtwpSetDosError(ERROR_OUTOFMEMORY);
        }
        InitializeListHead(EventCallbackListHead);
    }

    //
    // If there is a callback wired for this Guid, simply update the function.
    //

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        pEventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        if (IsEqualGUID(&FilterGuid, &pEventCb->Guid)) {
            pEventCb->CallbackRoutine = EventCallback;
            EtwpLeavePMCritSection();
            return EtwpSetDosError(ERROR_SUCCESS);
        }
        next = next->Flink;
    }

    //
    // Create a new entry in the EventCallbackList for this Guid.
    //
    pEventCb = (PEVENT_TRACE_CALLBACK) EtwpAlloc (sizeof(EVENT_TRACE_CALLBACK));
    if (pEventCb == NULL) {
        EtwpLeavePMCritSection();
        return EtwpSetDosError(ERROR_OUTOFMEMORY);
    }
    RtlZeroMemory(pEventCb, sizeof(EVENT_TRACE_CALLBACK));
    pEventCb->Guid = FilterGuid;
    pEventCb->CallbackRoutine = EventCallback;

    InsertTailList(EventCallbackListHead, &pEventCb->Entry);

    EtwpLeavePMCritSection();
    Status = ERROR_SUCCESS;
    return EtwpSetDosError(Status);
    
}

ULONG
WMIAPI
RemoveTraceCallback(
    IN LPCGUID pGuid
    )
/*++

Routine Description:

    This routine removes a callback function for a given Guid. 

Arguments:

    pGuid           Pointer to the Guid for which the callback routine needs
                    to be deleted. 

Return Value:

    ERROR_SUCCESS               Successfully deleted the callback routine. 
    ERROR_INVALID_PARAMETER     Could not find any callbacks for the Guid. 
--*/
{
    PLIST_ENTRY next, head;
    PEVENT_TRACE_CALLBACK EventCb;
    GUID RemoveGuid;
    ULONG errorCode;

    EtwpInitProcessHeap();
    
    if ((pGuid == NULL) || (EventCallbackListHead == NULL))
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);

    //
    // Capture the Guid into a local variable first
    //
    try {
        RemoveGuid = *pGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return EtwpSetDosError(ERROR_NOACCESS);
    }

    errorCode = ERROR_WMI_GUID_NOT_FOUND;

    EtwpEnterPMCritSection();

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        EventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        next = next->Flink;
        if (IsEqualGUID(&EventCb->Guid, &RemoveGuid)) {
            RemoveEntryList(&EventCb->Entry);
            EtwpFree(EventCb);
            errorCode = ERROR_SUCCESS;
        }
    }

    EtwpLeavePMCritSection();
    return EtwpSetDosError(errorCode);
}

#ifdef DBG
void
EtwpDumpEvent(
    PEVENT_TRACE pEvent
    )
{
    DbgPrint("\tSize              %d\n", pEvent->Header.Size);
    DbgPrint("\tThreadId          %X\n", pEvent->Header.ThreadId);
    DbgPrint("\tTime Stamp        %I64u\n", pEvent->Header.TimeStamp.QuadPart);
}

void
EtwpDumpGuid(
    LPGUID pGuid
    )
{
    DbgPrint("Guid=%x,%x,%x,\n\t{%x,%x,%x,%x,%x,%x,%x}\n",
        pGuid->Data1, pGuid->Data2, pGuid->Data3,
        pGuid->Data4[0], pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3],
        pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7], pGuid->Data4[8]);
}

void EtwpDumpCallbacks()
{
    PLIST_ENTRY next, head;
    PEVENT_TRACE_CALLBACK EventCb;

    if (EventCallbackListHead == NULL)
        return;
    EtwpEnterPMCritSection();
    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        EventCb = CONTAINING_RECORD(next, EVENT_TRACE_CALLBACK, Entry);
        EtwpDumpGuid(&EventCb->Guid);
        next = next->Flink;
    }
    EtwpLeavePMCritSection();
}

#endif




ULONG
EtwpReadGuidMapRecords(
    PEVENT_TRACE_LOGFILEW logfile,
    PVOID  pBuffer,
    BOOLEAN bLogFileHeader
    )
{
    PEVENT_TRACE pEvent;
    EVENT_TRACE EventTrace;
    ULONG BufferSize;
    ULONG Status;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    PTRACELOG_CONTEXT pContext = logfile->Context;

    Offset = sizeof(WMI_BUFFER_HEADER);

    while (TRUE) {
        pEvent = &EventTrace;
        RtlZeroMemory(pEvent, sizeof(EVENT_TRACE) );
        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) ||
             (HeaderType == WMIHT_WNODE) ||
             (Size == 0)
           ) {
                break;
        }
        Status = EtwpParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));
        Offset += Size;

        if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid)
            && (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP))
        {
            EtwpGuidMapCallback(&pContext->GuidMapListHead, pEvent);
            //
            // If we are processing the events in raw base pointer mode,
            // we fire callbacks for guid maps also. Note that only the
            // GuidMaps at the start of the file are triggered. The ones at the 
            // end are ignored. This is because the time order needs to be 
            // preserved when firing callbacks to the user.
            //
            if (bLogFileHeader && (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT)) {
                PTRACE_LOGFILE_HEADER pLogHeader = (PTRACE_LOGFILE_HEADER)(pEvent->MofData);
                pLogHeader->LoggerName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER));
                pLogHeader->LogFileName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER) 
                                        + (wcslen(pLogHeader->LoggerName) + 1) * sizeof(WCHAR));
                Status = EtwpDoEventCallbacks( logfile, pEvent);
                if (Status != ERROR_SUCCESS) {
                    break;
                }
            }

        }
        else {
            if (bLogFileHeader) {
                PTRACE_LOGFILE_HEADER pLogHeader = (PTRACE_LOGFILE_HEADER)(pEvent->MofData);
                pLogHeader->LoggerName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER));
                pLogHeader->LogFileName = (LPWSTR)((PUCHAR)pLogHeader + sizeof(TRACE_LOGFILE_HEADER) 
                                        + (wcslen(pLogHeader->LoggerName) + 1) * sizeof(WCHAR));
                Status = EtwpDoEventCallbacks( logfile, pEvent);
                if (Status != ERROR_SUCCESS) {
                    break;
                }
            }
            else {
                return ERROR_INVALID_DATA;
            }
        }
    }
    return ERROR_SUCCESS;
}




ULONG
EtwpProcessGuidMaps(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
    )
{
    long i;
    NTSTATUS Status;
    PTRACELOG_CONTEXT pContext;
    PEVENT_TRACE_LOGFILEW logfile;
    ULONG BuffersWritten;
    ULONG BufferSize;
    ULONG nBytesRead=0;
    ULONGLONG SizeWritten, ReadPosition;
    PVOID pBuffer;

    for (i=0; i<(long)LogfileCount; i++) {

        logfile = Logfiles[i];
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            continue;
        }
        if (logfile->IsKernelTrace) {
            continue;
        }
        pContext = (PTRACELOG_CONTEXT) logfile->Context;
        if (pContext == NULL) {
            continue;
        }

        // 
        // We now start reading the GuidMaps at the end of file. 
        // 
        if (!(Logfiles[i]->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))
        {
            pContext->fGuidMapRead = FALSE;
        }

        BuffersWritten = logfile->LogfileHeader.BuffersWritten; 
        BufferSize     = pContext->BufferSize;
        SizeWritten    = BuffersWritten * BufferSize;

        if (Logfiles[i]->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            ULONGLONG maxFileSize = (logfile->LogfileHeader.MaximumFileSize 
                                     * 1024 * 1024);
            if ( (maxFileSize > 0) && (SizeWritten > maxFileSize) ) {
                SizeWritten = maxFileSize;
            }
        }

        pBuffer = EtwpAlloc(BufferSize);
        if (pBuffer == NULL) {
            return EtwpSetDosError(ERROR_OUTOFMEMORY);
        }


        RtlZeroMemory(pBuffer, BufferSize);

        ReadPosition = SizeWritten;
        while (TRUE) {
            if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
                GetLastError() != ERROR_HANDLE_EOF) {
                EtwpDebugPrint(("GetOverlappedResult failed with Status %d in ProcessGuidMaps\n", GetLastError()));
                break;
            }
            pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
            pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);
            Status = EtwpSynchReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            BufferSize,
                            &nBytesRead,
                            &pContext->AsynchRead);
            if (nBytesRead == 0) {
                break;
            }
            Status = EtwpReadGuidMapRecords(Logfiles[i], pBuffer, FALSE);
            if (Status != ERROR_SUCCESS) {
                break;
            }
            ReadPosition += BufferSize;
        }

        //
        // End of File was reached. Now set the File Pointer back to 
        // the top of the file and process it. 

        pContext->StartBuffer = 0;
        ReadPosition = 0;
        while (TRUE) {
            BOOLEAN bLogFileHeader;
            if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
                GetLastError() != ERROR_HANDLE_EOF) {
                EtwpDebugPrint(("GetOverlappedResult failed with Status %d in ProcessGuidMaps\n", GetLastError()));
                break;
            }
            pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
            pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);
            Status = EtwpSynchReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            BufferSize,
                            &nBytesRead,
                            &pContext->AsynchRead);
            if (nBytesRead == 0) {
                break;
            }
            bLogFileHeader = (pContext->StartBuffer == 0);
            Status = EtwpReadGuidMapRecords(Logfiles[i], pBuffer, bLogFileHeader );
            if (Status != ERROR_SUCCESS){
                break;
            }
            pContext->StartBuffer++;
            ReadPosition += BufferSize;
        }

        EtwpFree(pBuffer);
    }
    return ERROR_SUCCESS;
}

ULONG
EtwpGetBuffersWrittenFromQuery(
    LPWSTR LoggerName
    )
/*++

Routine Description:
    This routine returns the number of buffers written by querying a logger.
    In case of an array of LogFiles, this routine should be called individually for
    each one.

Arguments:
    LogFile - pointer to EVENT_TRACE_LOGFILEW under consideration
    Unicode - whether the logger name is in unicode or not

Returned Value:

    The number of buffers written.

--*/
{
    TRACEHANDLE LoggerHandle = 0;
    ULONG Status;
    RtlZeroMemory(&QueryProperties, sizeof(QueryProperties));
    QueryProperties.TraceProp.Wnode.BufferSize = sizeof(QueryProperties);

    Status = EtwControlTraceW(LoggerHandle,
                      LoggerName,
                      &QueryProperties.TraceProp,
                      EVENT_TRACE_CONTROL_QUERY);

    if (Status == ERROR_SUCCESS) {
        return QueryProperties.TraceProp.BuffersWritten;
    }
    else {
        SetLastError(Status);
        return 0;
    }
}

VOID
EtwpCopyLogHeader (
    IN PTRACE_LOGFILE_HEADER pOutHeader,
    IN PVOID MofData,
    IN ULONG MofLength,
    IN PWCHAR *LoggerName,
    IN PWCHAR *LogFileName,
    IN ULONG  Unicode
    )
{
    PUCHAR Src, Dest;

    PTRACE_LOGFILE_HEADER pInHeader;
    ULONG PointerSize;
    ULONG SizeToCopy;
    ULONG Offset;

    pInHeader = (PTRACE_LOGFILE_HEADER) MofData; 
    PointerSize = pInHeader->PointerSize;   // This is the PointerSize in File

    if ( (PointerSize != 4) && (PointerSize != 8) ) {
#ifdef DBG
    EtwpDebugPrint(("WMI: Invalid PointerSize in File %d\n",PointerSize));
#endif
        return;
    }

    //
    // We have Two pointers (LPWSTR) in the middle of the LOGFILE_HEADER
    // structure. So We copy upto the Pointer Fields first, skip over
    // the pointers and copy the remaining stuff. We come back and fixup 
    // the pointers appropriately. 
    //

    SizeToCopy = FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName);

    RtlCopyMemory(pOutHeader, pInHeader, SizeToCopy);

    //
    // Skip over the Troublesome pointers in both Src and Dest
    //

    Dest = (PUCHAR)pOutHeader  + SizeToCopy + 2 * sizeof(LPWSTR);

    Src = (PUCHAR)pInHeader + SizeToCopy + 2 * PointerSize;

    //
    // Copy the Remaining fields at the tail end of the LOGFILE_HEADER 
    //

    SizeToCopy =  sizeof(TRACE_LOGFILE_HEADER)  -
                  FIELD_OFFSET(TRACE_LOGFILE_HEADER, TimeZone);

    RtlCopyMemory(Dest, Src, SizeToCopy); 

    //
    // Adjust the pointer fields now
    //
    Offset =  sizeof(TRACE_LOGFILE_HEADER) - 
              2 * sizeof(LPWSTR)           + 
              2 * PointerSize;

    *LoggerName  = (PWCHAR) ((PUCHAR)pInHeader + Offset);
    pOutHeader->LoggerName = *LoggerName;

}

ULONG
EtwpProcessLogHeader(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode,
    ULONG bFree
    )
/*++

Routine Description:
    This routine processes the header of an array of logfiles. 

Arguments:

    LogFile         Array of Logfiles being processed.
    LogFileCount    Number of Logfiles in the Array. 
    Unicode         Unicode Flag.

Returned Value:

    Status Code.

--*/
{
    HANDLE hFile;
    PTRACELOG_CONTEXT pContext = NULL;
    PVOID pBuffer;
    PEVENT_TRACE pEvent;
    long i;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    LPWSTR loggerName, logFileName;
    ULONG BufferSize, nBytesRead;
    PTRACE_LOGFILE_HEADER logfileHeader;
    ULONG Status = ERROR_SUCCESS;


    //
    // Open the Log File for shared Read
    //
    BufferSize = DEFAULT_LOG_BUFFER_SIZE;  // Log file header must be smaller than 1K

    pBuffer = EtwpAlloc(BufferSize);
    if (pBuffer == NULL) {
        return EtwpSetDosError(ERROR_OUTOFMEMORY);
    }


    for (i=0; i<(long)LogfileCount; i++) {
        EVENT_TRACE EventTrace;
        OVERLAPPED LogHeaderOverlapped;
        //
        // Caller can pass in Flags to fetch the timestamps in raw mode.
        // Since LogFileHeader gets overwritten from with data from the logfile
        // we need to save the passed in value here. 
        //

        if (Unicode) {
            hFile = CreateFileW(
                        (LPWSTR) Logfiles[i]->LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );
        }
        else {
            hFile = CreateFileA(
                        (LPSTR) Logfiles[i]->LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );
        }

        if (hFile == INVALID_HANDLE_VALUE) {
            Status = EtwpSetDosError(ERROR_BAD_PATHNAME);
            break;
        }

        BufferSize = DEFAULT_LOG_BUFFER_SIZE; 
        RtlZeroMemory(pBuffer, BufferSize);

        LogHeaderOverlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
        if (LogHeaderOverlapped.hEvent == NULL) {
            // cannot create event for file read
            break;
        }
        LogHeaderOverlapped.Offset = 0;
        LogHeaderOverlapped.OffsetHigh = 0;
        Status = EtwpSynchReadFile(hFile,
                        (LPVOID)pBuffer,
                        BufferSize,
                        &nBytesRead,
                        &LogHeaderOverlapped);
        if (nBytesRead == 0) {
            NtClose(hFile);
            Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
            break;
        }
        CloseHandle(LogHeaderOverlapped.hEvent);

        Offset = sizeof(WMI_BUFFER_HEADER);

        pEvent = &EventTrace;
        RtlZeroMemory(pEvent, sizeof(EVENT_TRACE) );
        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) ||
             (HeaderType == WMIHT_WNODE) ||
             (Size == 0) 
           ) {
                NtClose(hFile);
                Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
                break;
        }
        Status = EtwpParseTraceEvent(NULL, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

        Offset += Size;
        //
        // Set up the header structure properly
        //
        if ((Status == ERROR_SUCCESS) && (pEvent->MofLength > 0)) {
            ULONG PointerSize;

            logfileHeader = &Logfiles[i]->LogfileHeader;

            //
            // We are relying on the fact that the PointerSize field
            // will not shift between platforms. 
            //

            PointerSize = ((PTRACE_LOGFILE_HEADER)(pEvent->MofData))->PointerSize;

            if (PointerSize == sizeof(PUCHAR) ) {

                RtlCopyMemory(&Logfiles[i]->LogfileHeader, pEvent->MofData,
                              sizeof(TRACE_LOGFILE_HEADER));
    
                loggerName = (LPWSTR) ( (char*)pEvent->MofData +
                                        sizeof(TRACE_LOGFILE_HEADER) );

//              logFileName = (LPWSTR) ( (char*)pEvent->MofData +
//                                        sizeof(TRACE_LOGFILE_HEADER) +
//                                      sizeof(WCHAR)* wcslen(loggerName));
            }
            else {

                //
                // Ugly thunking going on here. Close your eyes...
                //

                EtwpCopyLogHeader(&Logfiles[i]->LogfileHeader, 
                                        pEvent->MofData, 
                                        pEvent->MofLength,
                                        &loggerName, 
                                        &logFileName, 
                                        Unicode);
                pEvent->MofData = (PVOID)&Logfiles[i]->LogfileHeader;
            }
        }
        else {
            NtClose(hFile);
            Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
            break;
        }

        Logfiles[i]->IsKernelTrace = !wcscmp(loggerName, KERNEL_LOGGER_NAME);

        Logfiles[i]->LogFileMode = (logfileHeader->LogFileMode &
                                ~(EVENT_TRACE_REAL_TIME_MODE));

        if (!bFree &&  (ETW_LOG_ERROR()) ) {
            DbgPrint("ETW: Dumping Logfile Header\n");
            DbgPrint("\tStart Time           %I64u\n",
                       pEvent->Header.TimeStamp);
            DbgPrint("\tLogger Thread Id     %X\n",
                            pEvent->Header.ThreadId);
            DbgPrint("\tHeader Size          %d\n",
                        pEvent->Header.Size);
            DbgPrint("\tBufferSize           %d\n",
                        logfileHeader->BufferSize);
            DbgPrint("\tVersion              %d\n",
                        logfileHeader->Version);
            DbgPrint("\t LogFile Format version %d.%d\n", 
                    logfileHeader->VersionDetail.SubVersion, 
                    logfileHeader->VersionDetail.SubMinorVersion);
            DbgPrint("\tProviderVersion      %d\n",
                            logfileHeader->ProviderVersion);
            DbgPrint("\tEndTime              %I64u\n",
                            logfileHeader->EndTime);
            DbgPrint("\tTimer Resolution     %d\n",
                        logfileHeader->TimerResolution);
            DbgPrint("\tMaximum File Size    %d\n",
                        logfileHeader->MaximumFileSize);
            DbgPrint("\tBuffers  Written     %d\n",
                        logfileHeader->BuffersWritten);
            DbgPrint("\tEvents  Lost     %d\n",
                        logfileHeader->EventsLost);
            DbgPrint("\tBuffers  Lost     %d\n",
                        logfileHeader->BuffersLost);
            DbgPrint("\tStart Buffers%d\n",
                        logfileHeader->StartBuffers);
            DbgPrint("\tReserved Flags   %x\n",
                        logfileHeader->ReservedFlags);
            DbgPrint("\tFrequency %I64u\n",
                        logfileHeader->PerfFreq.QuadPart);
            DbgPrint("\tLogger Name          %ls\n",
                        loggerName);
            DbgPrint("\tStartTime          %I64u\n",
                        logfileHeader->StartTime.QuadPart);
//            DbgPrint("\tLogfile Name         %ls\n",
//                        logFileName);

            DbgPrint("\tLogfile Mode         %X\n",
                        logfileHeader->LogFileMode);
            DbgPrint("\tProcessorCount          %d\n",
                        logfileHeader->NumberOfProcessors);

            DbgPrint("\tETW: IsKernelTrace = %d\n", Logfiles[i]->IsKernelTrace);
        }

        BufferSize = logfileHeader->BufferSize;

        EtwpAssert(BufferSize > 0);

        if ( (BufferSize/1024 == 0) ||
             (((BufferSize/1024)*1024) != BufferSize)  ) {
            NtClose(hFile);
            Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
            break;
        }


        if (Logfiles[i]->IsKernelTrace)
            EtwpDebugPrint(("\tLogfile contains kernel trace\n"));

        if  (bFree) {
            NtClose(hFile);
        }
        else {
            //
            // At this point, the logfile is opened successfully
            // Initialize the internal context now
            //
            pContext = EtwpLookupTraceHandle(HandleArray[i]);
            if (pContext == NULL) {
                NtClose(hFile); 
                Status = EtwpSetDosError(ERROR_OUTOFMEMORY);
                break;
            }

            Logfiles[i]->Context = pContext;
            pContext->Handle = hFile;

            //
            // If this is kernel file with Version 1.2 or above, look for 
            // extended logfileheader event. 
            //

            if ( (Logfiles[i]->IsKernelTrace) && 
                 (logfileHeader->VersionDetail.SubVersion >= 1) &&
                 (logfileHeader->VersionDetail.SubMinorVersion >= 2) ) {
                
                EVENT_TRACE TmpEvent;
                HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
                if ( (HeaderType == WMIHT_NONE) ||
                     (HeaderType == WMIHT_WNODE) ||
                     (Size == 0)
                   ) {
                        NtClose(hFile);
                        pContext->Handle = NULL;
                        Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
                        break;
                }

                RtlZeroMemory(&TmpEvent, sizeof(EVENT_TRACE));
                Status = EtwpParseTraceEvent(NULL, pBuffer, Offset, HeaderType,
                                             &TmpEvent, sizeof(EVENT_TRACE));

                if ((Status == ERROR_SUCCESS) && 
                    (TmpEvent.MofLength >= sizeof(PERFINFO_GROUPMASK))) {
                   RtlCopyMemory(&pContext->PerfGroupMask,  TmpEvent.MofData,
                                 sizeof(PERFINFO_GROUPMASK) );
                }

            }

            //
            // If the EndTime is 0, then we can not trust the BuffersWritten
            // field in the LogFileHeader. First we query the Logger to get 
            // the bufferswritten. However, if the file is being processed
            // from a different machine, then the QueryTrace call could fail. 
            // As a second option, we use the FileSize. Note that for loggers
            // with PREALLOCATE file, the filesize is bogus. 
            // 
            //

            if (logfileHeader->EndTime.QuadPart == 0) {

                logfileHeader->BuffersWritten = 
                                    EtwpGetBuffersWrittenFromQuery(loggerName);

                if (logfileHeader->BuffersWritten == 0) {

                    FILE_STANDARD_INFORMATION FileInfo;
                    NTSTATUS NtStatus;
                    IO_STATUS_BLOCK           IoStatus;

                    NtStatus = NtQueryInformationFile(
                                            hFile,
                                            &IoStatus,
                                            &FileInfo,
                                            sizeof(FILE_STANDARD_INFORMATION),
                                            FileStandardInformation
                                            );
                    if (NT_SUCCESS(NtStatus)) {
                        ULONG64 FileSize = FileInfo.AllocationSize.QuadPart; 
                        ULONG64 FileBuffers = FileSize / (ULONG64) BufferSize;
                        logfileHeader->BuffersWritten = (ULONG) FileBuffers;
                    }

                    if (logfileHeader->BuffersWritten == 0) {
                        NtClose(hFile);
                        pContext->Handle = NULL;
                        Status = EtwpSetDosError(ERROR_FILE_CORRUPT);
                        break;
                    }
                }
                if (!bFree && (ETW_LOG_ERROR())) {
                    DbgPrint("ETW: Set BuffersWritten to %d from QueryTrace\n",
                              logfileHeader->BuffersWritten);
                }
            }

            pContext->BufferCount = logfileHeader->BuffersWritten;
            pContext->BufferSize =  logfileHeader->BufferSize;

            if ((logfileHeader->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
                (logfileHeader->MaximumFileSize > 0) ) {
                
                ULONG maxFileSize = logfileHeader->MaximumFileSize; // in MB
                ULONG StartBuffer = logfileHeader->StartBuffers;
                ULONG maxBuffers = (maxFileSize * 1024 * 1024) / BufferSize;
                ULONG BuffersWritten = logfileHeader->BuffersWritten;
                ULONG FirstBuffer;

                if ((maxBuffers > StartBuffer) && (maxBuffers < BuffersWritten))
                    FirstBuffer = StartBuffer + ((BuffersWritten-StartBuffer)
                                                 % (maxBuffers-StartBuffer));
                else
                    FirstBuffer = StartBuffer;

                pContext->StartBuffer = StartBuffer;
                pContext->FirstBuffer = FirstBuffer;
                pContext->LastBuffer =  maxBuffers;

                if (!bFree && (ETW_LOG_ERROR())) {
                    DbgPrint("ETW: Buffers: Start %d First %d Last %d \n", 
                              StartBuffer, FirstBuffer, maxBuffers);
                }
            }

            //
            // Make the header the current Event   ...
            // and the callbacks for the header are handled by ProcessTraceLog. 

            pContext->UsePerfClock = logfileHeader->ReservedFlags;
            //
            // If the same structure is used to call OpenTrace again 
            // it will lead us to misuse the ReservedFlags as ConversionFlag. 
            // To be safe, we restore it here to caller's flags. 
            //
            pContext->StartTime = logfileHeader->StartTime;
            pContext->PerfFreq = logfileHeader->PerfFreq;
            pContext->CpuSpeedInMHz = logfileHeader->CpuSpeedInMHz;

            //
            // If the conversion flags are set, adjust UsePerfClock accordingly.
            //
            if (pContext->ConversionFlags & EVENT_TRACE_USE_RAWTIMESTAMP) {
                pContext->UsePerfClock = EVENT_TRACE_CLOCK_RAW;
            }

            if ((pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) || 
                (pContext->UsePerfClock == EVENT_TRACE_CLOCK_CPUCYCLE) ) {
                pContext->StartPerfClock = pEvent->Header.TimeStamp;
                Logfiles[i]->CurrentTime    = pContext->StartTime.QuadPart;
                pEvent->Header.TimeStamp.QuadPart = pContext->StartTime.QuadPart;
            }
            else {
                Logfiles[i]->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
            }
        }
    }

    EtwpFree(pBuffer);
    return Status;
}

ULONG
EtwpDoEventCallbacks( 
    PEVENT_TRACE_LOGFILEW logfile, 
    PEVENT_TRACE pEvent
    )
{
    NTSTATUS Status;
    PEVENT_TRACE_CALLBACK pCallback;

    //
    // First the Generic Event Callback is called.
    //
    if ( logfile->EventCallback ) {
        try {
            (*logfile->EventCallback)(pEvent);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
#ifdef DBG
            EtwpDebugPrint(("TRACE: EventCallback threw exception %X\n",
                                Status));
#endif
            return EtwpSetDosError(EtwpNtStatusToDosError(Status));
        }
    }

    //
    // Now Call the event specific callback.
    //
    pCallback = EtwpGetCallbackRoutine( &pEvent->Header.Guid );
    if ( pCallback != NULL ) {
        try {
            (*pCallback->CallbackRoutine)(pEvent);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
#ifdef DBG
            EtwpDebugPrint(("EventCallback %X threw exception %X\n",
                       pCallback->CallbackRoutine, Status));
#endif

            return EtwpSetDosError(EtwpNtStatusToDosError(Status));
        }
    }
    logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
    return ERROR_SUCCESS;
}


ULONG 
EtwpAdvanceToNewEvent(
    PEVENT_TRACE_LOGFILEW logfile,
    BOOL EventInRange
    )
{
    ULONG Status = ERROR_SUCCESS;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PVOID pBuffer;
    PTRACE_BUFFER_LIST_ENTRY Current;
    ULONG Size;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE; 

    pContext = logfile->Context;
    if (pContext == NULL) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }
 
    Current = EtwpRemoveBuffer(&pContext->Root);
    if (Current == NULL)  {
        pContext->EndOfFile = TRUE;
        return ERROR_SUCCESS;
    }

    //
    // Advance Event for current buffer
    //
    pEvent = &Current->Event;

    //
    // Before we make the callbacks, we need to restore the 
    // raw buffer, so that MofData will be pointing to the right data.
    //
    pBuffer = EtwpGetCurrentBuffer(pContext, Current);
    if (pBuffer == NULL) {
        //
        // This condition could happen when the file we are reading 
        // gets overwritten.
        //
        return ERROR_SHARING_VIOLATION;
    }
  
    if (EventInRange) {
        Status = EtwpDoEventCallbacks(logfile, pEvent);
        if (Status != ERROR_SUCCESS) {
            return Status;
        }
    }

    Size = 0;
    if ((HeaderType = WmiGetTraceHeader(pBuffer, Current->BufferOffset, &Size)) != WMIHT_NONE) {
        if (Size > 0) {
            Status = EtwpParseTraceEvent(pContext, pBuffer, Current->BufferOffset, HeaderType, pEvent, sizeof(EVENT_TRACE));
            Current->BufferOffset += Size;
            Current->TraceType = EtwpConvertEnumToTraceType(HeaderType);
        }
    }
    Current->EventSize = Size;

    if ( ( Size > 0) && (Status == ERROR_SUCCESS) ) {
        EtwpInsertBuffer(&pContext->Root, Current);
    }
    else {
        DWORD BytesTransffered;
        //
        // When the current buffer is exhausted, make the 
        // BufferCallback
        //
        if (logfile->BufferCallback) {
            ULONG bRetVal;
            PWMI_BUFFER_HEADER pHeader = (PWMI_BUFFER_HEADER)pBuffer;
            logfile->Filled     = (ULONG)pHeader->Offset;
            logfile->BuffersRead++;
            try {
                bRetVal = (*logfile->BufferCallback) (logfile);
                if (!bRetVal) {
                    return ERROR_CANCELLED;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                pContext->EndOfFile = TRUE;        
                Status = GetExceptionCode();
#ifdef DBG
                EtwpDebugPrint(("TRACE: BufferCallback threw exception %X\n",
                                        Status));
#endif
                EtwpSetDosError(EtwpNtStatusToDosError(Status));
                return ERROR_CANCELLED; // so that realtime also cleans up.
            }
        }
        //
        // Issue another asynch read on this buffer cache slot if there are no outstanding reads
        // at this point.
        // GetOverlappedResult() returns FALSE if IO is still pending.
        //
        if (pContext->BufferBeingRead == -1 || 
            GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &BytesTransffered, FALSE)) {

            LONG FileOffset = Current->FileOffset + MAX_TRACE_BUFFER_CACHE_SIZE;
            if ((ULONG)FileOffset < pContext->BufferCount) {
                ULONGLONG Offset = FileOffset * pContext->BufferSize;
                ResetEvent(pContext->AsynchRead.hEvent);
                pContext->AsynchRead.Offset = (DWORD)(Offset & 0xFFFFFFFF);
                pContext->AsynchRead.OffsetHigh = (DWORD)(Offset >> 32);

                Status = ReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            pContext->BufferSize,
                            NULL,
                            &pContext->AsynchRead);
                if (Status || GetLastError() == ERROR_IO_PENDING) {
                    ULONG TableIndex = FileOffset % MAX_TRACE_BUFFER_CACHE_SIZE;
                    pContext->BufferBeingRead = FileOffset;
                    pContext->BufferCache[TableIndex].Index = FileOffset;
                }
                else { // Issuing asynch IO failed. Not a fatal error. Just continue for now.
                    SetEvent(pContext->AsynchRead.hEvent);
                    pContext->BufferBeingRead = -1;
                }
            }
        }
    }
    //
    // The File reaches end of file when the Root is NULL
    //
    if (pContext->Root == NULL) {
        pContext->EndOfFile = TRUE;
    }
    else {
        logfile->CurrentTime = pContext->Root->Event.Header.TimeStamp.QuadPart;
    }

    return ERROR_SUCCESS;
}


ULONG 
EtwpBuildEventTable(
    PTRACELOG_CONTEXT pContext
    )
{
    ULONG i, nBytesRead;
    PVOID pBuffer;
    ULONG BufferSize = pContext->BufferSize;
    PEVENT_TRACE pEvent;
    ULONG TotalBuffersRead;
    NTSTATUS Status;
    ULONGLONG ReadPosition;


    //
    // File is already open.
    // Reset the file pointer and continue. 
    // TODO: If we start at bottom of file and insert
    // it might be more efficient. 
    //
    ReadPosition = pContext->StartBuffer * BufferSize;
    TotalBuffersRead = pContext->StartBuffer;

    //
    // If there are no other buffers except header and guidmaps, EOF is true
    //

    if (TotalBuffersRead == pContext->BufferCount) {
        pContext->EndOfFile = TRUE;
        pContext->Root = NULL;
        return ERROR_SUCCESS;
    }

    do {
        WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
        ULONG Size;
        ULONG Offset;
        ULONG TableIndex;

        TableIndex = TotalBuffersRead % MAX_TRACE_BUFFER_CACHE_SIZE ; 
        pBuffer = pContext->BufferCache[TableIndex].Buffer;

        if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
            GetLastError() != ERROR_HANDLE_EOF) {
            EtwpDebugPrint(("GetOverlappedResult failed with Status %d in BuildEventTable\n", GetLastError()));
            break;
        }
        pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
        pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);

        Status = EtwpSynchReadFile(pContext->Handle,
                  (LPVOID)pBuffer,
                  BufferSize,
                  &nBytesRead,
                  &pContext->AsynchRead);

        if (nBytesRead == 0)
            break;

        ReadPosition += BufferSize;
        Offset = sizeof(WMI_BUFFER_HEADER);

        pEvent = &pContext->BufferList[TotalBuffersRead].Event;

        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) || (HeaderType == WMIHT_WNODE) || (Size == 0) ) {
            TotalBuffersRead++;
            continue;
        }
        Status = EtwpParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

        //
        // Set up the header structure properly
        //
        if (Status != ERROR_SUCCESS) {
            TotalBuffersRead++;
            continue;
        }

        Offset += Size;
        pContext->BufferList[TotalBuffersRead].BufferOffset = Offset;
        pContext->BufferList[TotalBuffersRead].FileOffset = TotalBuffersRead;
        pContext->BufferList[TotalBuffersRead].EventSize = Size;
        pContext->BufferList[TotalBuffersRead].TraceType = EtwpConvertEnumToTraceType(HeaderType);
        EtwpInsertBuffer(&pContext->Root, &pContext->BufferList[TotalBuffersRead]);

        TotalBuffersRead++;
        if (TotalBuffersRead >= pContext->BufferCount)  {
            break;
        }
    } while (1); 

    return ERROR_SUCCESS;
}


ULONG
EtwpProcessTraceLog(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    )
/*++

Routine Description:
    This routine processes an array of traces (from file or realtime input 
    stream). If the trace is from a file, goes through each event till the 
    end of file, firing event callbacks (if any) along the way. If the trace
    is from realtime, it waits for event notification about buffer delivery 
    from the realtime callback and processes the buffer delivered in the 
    same way. It handles circular logfiles and windowing of data (with the 
    given start and end times) correctly. When more than one trace it
    provides the callback in chronological order. 

Arguments:

    Logfiles        Array of traces
    LogfileCount    Number of traces
    StartTime       Starting Time of the window of analysis
    EndTime         Ending Time of the window of analysis
    Unicode         Unicode Flag. 

Returned Value:

    Status Code.

--*/
{
    PEVENT_TRACE_LOGFILE logfile;
    ULONG Status;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    ULONG RealTimeDataFeed, LogFileDataFeed;
    USHORT LoggerId;
    TRACEHANDLE LoggerHandle = 0;
    ULONG i, j;
    BOOL Done = FALSE;
    ACCESS_MASK DesiredAccess = TRACELOG_ACCESS_REALTIME;
    LONGLONG CurrentTime = StartTime;
    UCHAR SubVersion;
    UCHAR SubMinorVersion;
    BOOLEAN bVersionMismatch;
    BOOLEAN bActiveCircular = FALSE;
    PTRACE_LOGFILE_HEADER logfileHeader;

    Status = EtwpCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    // 
    // After reading the First Buffer, determine the BufferSize, 
    // Number of Buffers written, filesize, kernel or non-kernel logger
    // Set a flag to strip out the GuidMap at the end. 
    //

    Status = EtwpProcessLogHeader( HandleArray, 
                                   Logfiles, 
                                   LogfileCount, 
                                   Unicode, 
                                   FALSE 
                                  );
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }


    bVersionMismatch = FALSE;

    SubVersion = Logfiles[0]->LogfileHeader.VersionDetail.SubVersion;
    SubMinorVersion = Logfiles[0]->LogfileHeader.VersionDetail.SubMinorVersion;

    for (i=0; i < LogfileCount; i++) {
        UCHAR tSV, tSMV;

        logfileHeader = &Logfiles[i]->LogfileHeader;

        tSV = Logfiles[i]->LogfileHeader.VersionDetail.SubVersion; 
        tSMV = Logfiles[i]->LogfileHeader.VersionDetail.SubMinorVersion; 

        if ( (SubVersion != tSV) || (SubMinorVersion != tSMV) ) {
            bVersionMismatch = TRUE;
        }
        if ((logfileHeader->EndTime.QuadPart == 0) && 
            ((logfileHeader->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))) {
            bActiveCircular = TRUE;
        }
    } 

    //
    // Is there is a version mismatch among the files, they need to be 
    // processed individually. 
    //
    if (bVersionMismatch) {
        return ERROR_INVALID_PARAMETER;
    } 
    else {

        if (((SubVersion >= 1) && (SubMinorVersion >= 2)) && 
            (!bActiveCircular)) {

            return EtwpProcessTraceLogEx(HandleArray, Logfiles,
                                     LogfileCount,
                                     StartTime,
                                     EndTime,
                                     Unicode);
    
        }
    }

    ASSERT (!bVersionMismatch);

    Status = EtwpProcessGuidMaps( Logfiles, LogfileCount, Unicode );
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    // 
    // Set up storage 
    //
    for (i=0; i < LogfileCount; i++) {
       ULONG BufferSize, BufferCount;
       ULONG SizeNeeded;
       PUCHAR Space;
       PTRACE_BUFFER_LIST_ENTRY Current;


       pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;

       BufferSize = pContext->BufferSize; 
       BufferCount = pContext->BufferCount;

       SizeNeeded = BufferCount * sizeof(TRACE_BUFFER_LIST_ENTRY);
       pContext->BufferList = EtwpMemCommit( NULL, SizeNeeded );

       if (pContext->BufferList == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(pContext->BufferList, SizeNeeded);

        //
        // Allocate Buffer Cache
        //
        SizeNeeded = MAX_TRACE_BUFFER_CACHE_SIZE * BufferSize;
        Space = EtwpMemCommit( NULL, SizeNeeded );
        if (Space == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        for (j=0; j<MAX_TRACE_BUFFER_CACHE_SIZE; j++) {
           pContext->BufferCache[j].Index = -1;
           pContext->BufferCache[j].Buffer = (PVOID)(Space + j * BufferSize); 
       }
       pContext->BufferCacheSpace = Space;
       Status = EtwpBuildEventTable(pContext);
       if (Status != ERROR_SUCCESS) {
            goto Cleanup;
       }


       Current = pContext->Root;
       if (Current != NULL) {
          Logfiles[i]->CurrentTime = Current->Event.Header.TimeStamp.QuadPart;
       }
       else {
          pContext->EndOfFile = TRUE;
       }
   }

   // 
   // Make the Second Pass and get the events. 
   //

#ifdef DBG
    EtwpDumpCallbacks();
#endif
   while (!Done) {
        LONGLONG nextTimeStamp;
        BOOL EventInRange;
        //
        // Check to see if end of file has been reached on all the 
        // files.
        //

        logfile = NULL;
        nextTimeStamp = 0;

        for (j=0; j < LogfileCount; j++) {
           pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;

           if (pContext->EndOfFile)
                continue;
           if (nextTimeStamp == 0) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
           else if (nextTimeStamp > Logfiles[j]->CurrentTime) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
        }

        if (logfile == NULL) {
            break;
        }
        //
        // if the Next event timestamp is not within the window of
        // analysis, we do not fire the event callbacks. 
        //

        EventInRange = TRUE;

        // Make sure we don't deliver events that go back in time.
        if ((CurrentTime != 0) && (CurrentTime > nextTimeStamp))
            EventInRange = FALSE;
        if ((EndTime != 0) && (EndTime < nextTimeStamp))
            EventInRange = FALSE;

        //
        // logfile->CurrentTime can only increase. On multiproc itanium machine,
        // time can go back.
        //

        if (CurrentTime < nextTimeStamp) {
            CurrentTime = nextTimeStamp;
        }

        if ( (ETW_LOG_ERROR() ) && (CurrentTime > nextTimeStamp) ) {
            DbgPrint("ETW: TimeStamp reversed. Prev %I64u Next %I64u\n", 
                      CurrentTime, nextTimeStamp);
        }

        //
        // Now advance to next event. 
        //

        Status = EtwpAdvanceToNewEvent(logfile, EventInRange);
        Done = (Status == ERROR_CANCELLED);
    }
Cleanup:
    for (i=0; i < LogfileCount; i++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;
        if (pContext != NULL) {
            EtwpCleanupTraceLog(pContext, FALSE);
        }
    }
    return Status;

}


ULONG
EtwpCopyLogfileInfo(
                    PTRACELOG_CONTEXT HandleEntry,
                    PEVENT_TRACE_LOGFILEW   Logfile,
                    ULONG Unicode
                    )
{
    ULONG bufSize;
    PWCHAR ws;
    //
    // Allocate LogfileName and LoggerName as well
    //
    RtlCopyMemory(&HandleEntry->Logfile,
                  Logfile,
                  sizeof(EVENT_TRACE_LOGFILEW));

    HandleEntry->Logfile.LogFileName = NULL;
    HandleEntry->Logfile.LoggerName = NULL;    
    HandleEntry->ConversionFlags = Logfile->LogfileHeader.ReservedFlags;

    if (ETW_LOG_API()) {
        DbgPrint("ETW: ConversionFlags for Processing %x\n", HandleEntry->ConversionFlags);
    }

    if (Logfile->LogFileName != NULL) {
        if (Unicode) 
            bufSize = (wcslen(Logfile->LogFileName) + 1) * sizeof(WCHAR);
        else 
            bufSize = (strlen((PUCHAR)(Logfile->LogFileName)) + 1)
                      * sizeof(WCHAR);
        
        ws = EtwpAlloc( bufSize );
        if (ws == NULL)
            return ERROR_OUTOFMEMORY;

        if (Unicode) {
            wcscpy(ws, Logfile->LogFileName);
        }
        else {
            MultiByteToWideChar(CP_ACP, 
                                0, 
                                (LPCSTR)Logfile->LogFileName, 
                                -1, 
                                (LPWSTR)ws, 
                                bufSize / sizeof(WCHAR));
        }
        HandleEntry->Logfile.LogFileName = ws;
    }
    if (Logfile->LoggerName != NULL) {
        if (Unicode)
            bufSize = (wcslen(Logfile->LoggerName) + 1) * sizeof(WCHAR);
        else
            bufSize = (strlen((PUCHAR)(Logfile->LoggerName)) + 1) 
                      * sizeof(WCHAR);

        ws = EtwpAlloc( bufSize );
        if (ws == NULL)
            return ERROR_OUTOFMEMORY;

        if (Unicode)
            wcscpy(ws, Logfile->LoggerName);
        else {
            MultiByteToWideChar(CP_ACP,
                                0,
                                (LPCSTR)Logfile->LoggerName,
                                -1,
                                (LPWSTR)ws,
                                bufSize / sizeof(WCHAR));
        }
        HandleEntry->Logfile.LoggerName = ws;
    }
    return ERROR_SUCCESS;
}



TRACEHANDLE
WMIAPI
OpenTraceA(
    IN PEVENT_TRACE_LOGFILEA Logfile
    )
/*++

Routine Description:
    This is the  Ansi version of the ProcessTracelogHeader routine.


Arguments:

    LogFile     Trace Input



Returned Value:

    TraceHandle

--*/
{
    ULONG status = ERROR_INVALID_PARAMETER;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

    EtwpInitProcessHeap();

    if (Logfile != NULL) {
        HandleEntry = EtwpAllocateTraceHandle();
        if (HandleEntry == NULL) {
            status = ERROR_OUTOFMEMORY;
        }
        else {
            //
            // Copy the LogFileStructure over. Converts strings to Unicode
            //
            TraceHandle = HandleEntry->TraceHandle;
            try {
                status = EtwpCopyLogfileInfo(
                                             HandleEntry,
                                             (PEVENT_TRACE_LOGFILEW)Logfile,
                                             FALSE
                                            );
                //
                // TODO: Once we copied the caller's memory we should use our 
                // private copy and also come out of the try-except block
                //
                if (status == ERROR_SUCCESS) {
                    //
                    // For RealTime, handle is a place holder until ProcessTrace
                    //
                    if ( (Logfile->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) 
                                               != EVENT_TRACE_REAL_TIME_MODE ) {
                        status = EtwpCreateGuidMapping();
                        if (status == ERROR_SUCCESS) {
                            status = EtwpProcessLogHeader(
                                          &HandleEntry->TraceHandle, 
                                          (PEVENT_TRACE_LOGFILEW*)&Logfile, 
                                          1, 
                                          FALSE, 
                                          TRUE
                                         );
                        }
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = EtwpNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if ( (status != ERROR_SUCCESS) && (HandleEntry != NULL) ) {
        EtwpFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    EtwpSetDosError(status);
    return TraceHandle;
}

TRACEHANDLE
WMIAPI
OpenTraceW(
    IN PEVENT_TRACE_LOGFILEW Logfile
    )
/*++

Routine Description:
    This routine processes a trace input and returns the tracelog header.
    Only for logfiles. For realtime traces, the header may not be available.

Arguments:

    Logfile     Trace input.



Returned Value:

    Pointer to Tracelog header.

--*/
{
    ULONG status = ERROR_INVALID_PARAMETER;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

    EtwpInitProcessHeap();
    if (Logfile != NULL) {
        HandleEntry = EtwpAllocateTraceHandle();
        if (HandleEntry == NULL) {
            status = ERROR_OUTOFMEMORY;
        }
        else {
            TraceHandle = HandleEntry->TraceHandle;
            try {
                status = EtwpCopyLogfileInfo(
                                             HandleEntry,
                                             (PEVENT_TRACE_LOGFILEW)Logfile,
                                             TRUE
                                            );
                if (status == ERROR_SUCCESS) {
                    if ( (Logfile->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) 
                                               != EVENT_TRACE_REAL_TIME_MODE ) {
                        status = EtwpCreateGuidMapping();
                        if (status == ERROR_SUCCESS) {
                            status = EtwpProcessLogHeader(
                                              &HandleEntry->TraceHandle,
                                              (PEVENT_TRACE_LOGFILEW*)&Logfile,
                                              1,
                                              TRUE,
                                              TRUE
                                             );
                        }
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = EtwpNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if ( (status != ERROR_SUCCESS) && (HandleEntry != NULL) ) {
        EtwpFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    EtwpSetDosError(status);
    return TraceHandle;
}

ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG   HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    )
/*++

Routine Description:
    This is the main ETW Consumer API. This processes one more Logfiles or
    realtime streams and returns events to the caller via event callbacks. 
    The processing can be windowed to an interval specified by the Start 
    and EndTime. 


Arguments:

    HandleArray     Array of Handles
    HandleCount     Count of the Handles
    StartTime       StartTime to window the data
    EndTime         EndTime to window the data



Returned Value:

    Status of the operation

--*/
{

    PEVENT_TRACE_LOGFILEW Logfiles[MAXLOGGERS];
    PLIST_ENTRY Head, Next;
    PTRACELOG_CONTEXT pHandleEntry, pEntry;
    ULONG i, Status;
    LONGLONG sTime, eTime;
    TRACEHANDLE SavedArray[MAXLOGGERS];

    PEVENT_TRACE_LOGFILE logfile;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PEVENT_TRACE_PROPERTIES Properties;
    ULONG  szProperties;
    ULONG RealTimeDataFeed = FALSE, LogFileDataFeed = FALSE;
    USHORT LoggerId;
    TRACEHANDLE LoggerHandle = 0;
    ULONG j;
    BOOL Done = FALSE;
    ACCESS_MASK DesiredAccess = TRACELOG_ACCESS_REALTIME;

    EtwpInitProcessHeap();

    if ((HandleCount == 0) || (HandleCount >= MAXLOGGERS)) {
        return ERROR_BAD_LENGTH;
    }
    if (HandleArray == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    // if TraceHandleListHeadPtr is NULL, 
    // OpenTrace wasn't called before ProcessTrace.
    if (TraceHandleListHeadPtr == NULL) {
        return ERROR_INVALID_FUNCTION;
    }
    //
    // TODO: Do we have to allocate this even for LogFile case? 
    //

    RtlZeroMemory(Logfiles, MAXLOGGERS*sizeof(PEVENT_TRACE_LOGFILEW) );
    szProperties = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);
    Properties = EtwpAlloc(szProperties);
    if (Properties == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    eTime = 0;
    sTime = 0;

    try {
        if (StartTime != NULL)
            sTime = *((PLONGLONG) StartTime);
        if (EndTime != NULL)
            eTime = *((PLONGLONG) EndTime);

        if ((eTime != 0) && (eTime < sTime) ) {
            Status = ERROR_INVALID_TIME;
            goto Cleanup;
        }

        for (i=0; i<HandleCount; i++) {
            SavedArray[i] = HandleArray[i];
            if (SavedArray[i] == (TRACEHANDLE) INVALID_HANDLE_VALUE) {
                Status = ERROR_INVALID_HANDLE;
                goto Cleanup;
            }
        }

        //
        // Need to use a termination handler to free the crit sect 
        // properly
        //

        EtwpEnterPMCritSection();

        for (i=0; i< HandleCount; i++) {
            pHandleEntry = NULL;
            Head = TraceHandleListHeadPtr;
            if (Head != NULL) {
                Next = Head->Flink;
                while (Next != Head) {
                    pEntry = CONTAINING_RECORD(Next, 
                                               TRACELOG_CONTEXT, 
                                               Entry);
                    Next = Next->Flink;
                    if (SavedArray[i] == pEntry->TraceHandle) {
                        if (pEntry->fProcessed == FALSE) {
                            pHandleEntry = pEntry;
                            pHandleEntry->fProcessed = TRUE;
                        }
                        break;
                    }
                }
            }
            if (pHandleEntry == NULL) {
                Status = ERROR_INVALID_HANDLE;
                EtwpLeavePMCritSection();
                goto Cleanup;
            }
            Logfiles[i] = &pHandleEntry->Logfile;
        }

        EtwpLeavePMCritSection();

        //
        // Scan the Logfiles list and decide it's realtime or 
        // Logfile Proceessing. 
        //
        for (i=0; i < HandleCount; i++) {
            //
            // Check to see if this is a RealTime Datafeed
            //
            if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
                if (Logfiles[i]->LoggerName == NULL) {
                    Status = EtwpSetDosError(ERROR_INVALID_NAME);
                    goto Cleanup;
                }
                //
                // Using the LoggerName, Query the Logger to determine
                // whether this is a Kernel or Usermode realtime logger.
                //
                RtlZeroMemory(Properties, szProperties);
                Properties->Wnode.BufferSize = szProperties;


                Status = EtwControlTraceW(LoggerHandle,
                                      (LPWSTR)Logfiles[i]->LoggerName,
                                      Properties,
                                      EVENT_TRACE_CONTROL_QUERY);

                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }

                if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                    Status = ERROR_WMI_INSTANCE_NOT_FOUND;
                    goto Cleanup;
                }

                Logfiles[i]->IsKernelTrace = IsEqualGUID(
                                                        &Properties->Wnode.Guid,
                                                        &SystemTraceControlGuid
                                                       );

                LoggerId = WmiGetLoggerId(Properties->Wnode.HistoricalContext);

                if (LoggerId == KERNEL_LOGGER_ID) {
                    LoggerId = 0;
                }
                Logfiles[i]->Filled = LoggerId; // Temporarily stash it away 
                Logfiles[i]->LogfileHeader.LogInstanceGuid = 
                                                         Properties->Wnode.Guid;

                //
                // If the Logger is using UsePerfClock for TimeStamps, make 
                // a reference timestamp now. 
                //

                Logfiles[i]->LogfileHeader.ReservedFlags = 
                                                Properties->Wnode.ClientContext;

                //
                // Save the BuffferSize for Realtime Buffer Pool Allocation
                //
                Logfiles[i]->BufferSize = Properties->BufferSize * 1024;

                //
                // This is the place to do security check on this Guid.
                //

                Status = EtwpCheckGuidAccess( &Properties->Wnode.Guid,
                                              DesiredAccess );

                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }
                RealTimeDataFeed = TRUE;
            }
            //
            // Check to see if this is a Logfile datafeed.
            //


            if (!(Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                if (Logfiles[i]->LogFileName == NULL) {
                    Status = EtwpSetDosError(ERROR_BAD_PATHNAME);
                    goto Cleanup;
                }

                if ( wcslen((LPWSTR)Logfiles[i]->LogFileName) <= 0 ) {
                        Status = EtwpSetDosError(ERROR_BAD_PATHNAME);
                        goto Cleanup;
                }

                LogFileDataFeed = TRUE;
            }

            //
            // We don't support both RealTimeFeed and LogFileDataFeed.
            //

            if (RealTimeDataFeed && LogFileDataFeed) {
                Status = EtwpSetDosError(ERROR_INVALID_PARAMETER);
                goto Cleanup;
            }
        }

        
        if (LogFileDataFeed) {
            Status = EtwpProcessTraceLog(&SavedArray[0], Logfiles, 
                                     HandleCount, 
                                     sTime, 
                                     eTime,
                                     TRUE);
        }
        else {
            Status = EtwpProcessRealTimeTraces(&SavedArray[0], Logfiles,
                                     HandleCount,
                                     sTime,
                                     eTime,
                                     TRUE);
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        EtwpDebugPrint(("TRACE: EtwpProcessTraceLog threw exception %X\n",
                            Status));
#endif
        Status = EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

    try {
        EtwpEnterPMCritSection();
        for (i=0; i< HandleCount; i++) {
            pHandleEntry = NULL;
            Head = TraceHandleListHeadPtr;
            EtwpAssert(Head);
            Next = Head->Flink;
            while (Next != Head) {
                pEntry = CONTAINING_RECORD(Next, TRACELOG_CONTEXT, Entry);
                Next = Next->Flink;

                if (SavedArray[i] == pEntry->TraceHandle) {
                    pEntry->fProcessed = FALSE;
                    break;
                }
            }
        }
        EtwpLeavePMCritSection();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        EtwpDebugPrint(("TRACE: EtwpProcessTraceLog threw exception %X\n",
                            Status));
#endif
        Status = EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

Cleanup:

    EtwpFree(Properties);
    return Status;
}

ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
       )
{
    EtwpInitProcessHeap();
    if ((TraceHandle == 0) || 
        (TraceHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE))
        return ERROR_INVALID_HANDLE;
    return EtwpFreeTraceHandle(TraceHandle);
}

VOID
EtwpGuidMapCallback(
        PLIST_ENTRY GuidMapListHeadPtr,
        PEVENT_TRACE pEvent
        )
{
    PTRACEGUIDMAP GuidMap;

    EtwpInitProcessHeap();
    
    if (pEvent == NULL)
        return;

    GuidMap = (PTRACEGUIDMAP) pEvent->MofData;
    if (GuidMap != NULL) {
        EtwpAddGuidHandleToGuidMapList(GuidMapListHeadPtr, GuidMap->GuidMapHandle, &GuidMap->Guid);
    }

}


void
EtwpCleanupTraceLog(
    PTRACELOG_CONTEXT pContext,
    BOOLEAN bSaveLastOffset
    )
{
    ULONG Size;

    //
    // Free up the realtime context arrays and buffers
    //

    EtwpEnterPMCritSection();

    if (pContext->IsRealTime) {
        if (pContext->Root != NULL) {
            EtwpFree(pContext->Root);
        }
        EtwpFreeRealTimeContext(pContext->RealTimeCxt);
    }
    else {
        if (pContext->Handle != NULL) {
            NtClose(pContext->Handle);
            pContext->Handle = NULL;
        }
    }

    if (pContext->BufferList != NULL) {
        EtwpMemFree(pContext->BufferList);
    }
    if (pContext->BufferCacheSpace != NULL) {
        EtwpMemFree(pContext->BufferCacheSpace);
    }

    EtwpCleanupGuidMapList(&pContext->GuidMapListHead);

    EtwpCleanupStreamList (&pContext->StreamListHead);

    if (bSaveLastOffset) {
        if (ETW_LOG_API()) {
            DbgPrint("ETW: Saving ReadPosition %I64u BuffersRead %d\n", 
                      pContext->MaxReadPosition, pContext->Logfile.BuffersRead);
        }
        pContext->OldMaxReadPosition = pContext->MaxReadPosition;
        pContext->Logfile.BuffersRead = 0;
    }

    //
    // The following fields need to be reset since the caller
    // may call ProcessTrace again with the same handle
    // 
    Size = sizeof(TRACELOG_CONTEXT) - FIELD_OFFSET(TRACELOG_CONTEXT, fProcessed);
    RtlZeroMemory(&pContext->fProcessed, Size);
    InitializeListHead (&pContext->GuidMapListHead);
    InitializeListHead (&pContext->StreamListHead);

    EtwpLeavePMCritSection();

}



ULONG
WMIAPI
WmiGetFirstTraceOffset(
    IN  PWMIBUFFERINFO BufferInfo
    )
/*++

Routine Description:
    This is the private API for buffer walking for cluster/
    debugger support.

    Returns the Offset to the first event.

Arguments: 


Returned Value:

    Status code

--*/
{
    PVOID pBuffer;
    PWMI_BUFFER_HEADER pHeader;
    PLONG LastByte;

    if (BufferInfo == NULL) {
        return 0;
    }
    pBuffer = BufferInfo->Buffer;

    if (pBuffer == NULL) {
        return 0;
    }
    pHeader = (PWMI_BUFFER_HEADER) pBuffer;

    switch(BufferInfo->BufferSource) {
        case WMIBS_CURRENT_LIST:
        {
            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            pHeader->ClientContext.Alignment = (UCHAR)BufferInfo->Alignment;
            pHeader->Offset = pHeader->CurrentOffset;
            break;
        }
        case WMIBS_FREE_LIST:
        {
            pHeader->Offset = pHeader->CurrentOffset;

            if (pHeader->SavedOffset > 0)
                pHeader->Offset = pHeader->SavedOffset;

            if (pHeader->Offset == 0) {
                pHeader->Offset = sizeof(WMI_BUFFER_HEADER);
            }

            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            break;
        }
        case WMIBS_TRANSITION_LIST:
        {
            if (pHeader->SavedOffset > 0) {
                pHeader->Offset = pHeader->SavedOffset;
            }
            break;
        }
        case WMIBS_FLUSH_LIST:
        {
            if (pHeader->SavedOffset > 0) {
                pHeader->Offset = pHeader->SavedOffset;
            }
            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            break;
        }
        case WMIBS_LOG_FILE: 
        {
            break;
        }
    }

    if (BufferInfo->BufferSource != WMIBS_LOG_FILE) {
        LastByte = (PLONG) ((PUCHAR)pHeader+ pHeader->Offset);
        if (pHeader->Offset <= (BufferInfo->BufferSize - sizeof(ULONG)) ) {

            *LastByte = -1;
        }
    }

    return  sizeof(WMI_BUFFER_HEADER);
}

ULONG 
EtwpConvertEnumToTraceType(
    WMI_HEADER_TYPE eTraceType
    )
{
    switch(eTraceType) {
        case WMIHT_SYSTEM32:
            return TRACE_HEADER_TYPE_SYSTEM32;
        case WMIHT_SYSTEM64:
            return TRACE_HEADER_TYPE_SYSTEM64;
        case WMIHT_EVENT_TRACE:
            return TRACE_HEADER_TYPE_FULL_HEADER;
        case WMIHT_EVENT_INSTANCE:
            return TRACE_HEADER_TYPE_INSTANCE;
        case WMIHT_TIMED:
            return TRACE_HEADER_TYPE_TIMED;
        case WMIHT_ULONG32:
            return TRACE_HEADER_TYPE_ULONG32;
        case WMIHT_WNODE:
            return TRACE_HEADER_TYPE_WNODE_HEADER;
        case WMIHT_MESSAGE:
            return TRACE_HEADER_TYPE_MESSAGE;
        case WMIHT_PERFINFO32:
            return TRACE_HEADER_TYPE_PERFINFO32;
        case WMIHT_PERFINFO64:
            return TRACE_HEADER_TYPE_PERFINFO64;
        default:
            return 0;
    }
}

WMI_HEADER_TYPE
EtwpConvertTraceTypeToEnum( 
                            ULONG TraceType 
                          )
{
    switch(TraceType) {
        case TRACE_HEADER_TYPE_SYSTEM32:
            return WMIHT_SYSTEM32;
        case TRACE_HEADER_TYPE_SYSTEM64:
            return WMIHT_SYSTEM64;
        case TRACE_HEADER_TYPE_FULL_HEADER:
            return WMIHT_EVENT_TRACE;
        case TRACE_HEADER_TYPE_INSTANCE:
            return WMIHT_EVENT_INSTANCE;
        case TRACE_HEADER_TYPE_TIMED:
            return WMIHT_TIMED;
        case TRACE_HEADER_TYPE_ULONG32:
            return WMIHT_ULONG32;
        case TRACE_HEADER_TYPE_WNODE_HEADER:
            return WMIHT_WNODE;
        case TRACE_HEADER_TYPE_MESSAGE:
            return WMIHT_MESSAGE;
        case TRACE_HEADER_TYPE_PERFINFO32:
            return WMIHT_PERFINFO32;
        case TRACE_HEADER_TYPE_PERFINFO64:
            return WMIHT_PERFINFO64;
        default: 
            return WMIHT_NONE;
    }
}
                    



ULONG
WMIAPI
WmiParseTraceEvent(
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    )
{

    return EtwpParseTraceEvent(NULL, LogBuffer, Offset, HeaderType, EventInfo, EventInfoSize);
}


PVOID
EtwpAllocTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    PTRACE_BUFFER_HEADER Header;
    PLIST_ENTRY Head, Next;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PTRACE_BUFFER_SPACE EtwpTraceBufferSpace;

    EtwpEnterPMCritSection();
    EtwpTraceBufferSpace = RTCxt->EtwpTraceBufferSpace;
    Head = &EtwpTraceBufferSpace->FreeListHead;
    Next = Head->Flink;
    while (Head != Next)  {
        ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
        Next = Next->Flink;
        if (ListEntry->Size == BufferSize) {
            goto foundList;
        }
    }
    //
    // No list for this bufferSize was  found. So go Ahead and allocate one.
    //
    ListEntry = EtwpAlloc(sizeof(TRACERT_BUFFER_LIST_ENTRY));
    if (ListEntry == NULL) {
        EtwpSetDosError(ERROR_OUTOFMEMORY);
        EtwpLeavePMCritSection();
        return NULL;
    }
    RtlZeroMemory(ListEntry, sizeof(TRACERT_BUFFER_LIST_ENTRY));
    ListEntry->Size = BufferSize;
    InitializeListHead(&ListEntry->BufferListHead);
    InsertHeadList(&EtwpTraceBufferSpace->FreeListHead, &ListEntry->Entry);

foundList:
    //
    // Now look for a free buffer in this list
    //
    Head = &ListEntry->BufferListHead;
    Next = Head->Flink;
    while (Head != Next) {
        Header = CONTAINING_RECORD( Next, TRACE_BUFFER_HEADER, Entry );
        if (((PWNODE_HEADER)Header)->BufferSize == BufferSize) {
            RemoveEntryList(&Header->Entry);
            Buffer = (PVOID)Header;
            break;
        }
        Next = Next->Flink;
    }
    EtwpLeavePMCritSection();
    //
    // If No Free Buffers are found we try to allocate one and return.
    //
    if (Buffer == NULL) {
        PVOID Space;
        ULONG SizeLeft = EtwpTraceBufferSpace->Reserved -
                         EtwpTraceBufferSpace->Committed;
        if (SizeLeft < BufferSize) {
            EtwpSetDosError(ERROR_OUTOFMEMORY);
            return NULL;
        }

        Space = (PVOID)( (PCHAR)EtwpTraceBufferSpace->Space +
                                EtwpTraceBufferSpace->Committed );

        Buffer =  EtwpMemCommit( Space, BufferSize );

        if (Buffer != NULL)  {
            EtwpTraceBufferSpace->Committed += BufferSize;
        }

    }
    return (Buffer);
}
VOID
EtwpFreeTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    PVOID Buffer
    )
{
    PTRACE_BUFFER_HEADER Header = (PTRACE_BUFFER_HEADER)Buffer;
    PLIST_ENTRY Head, Next;
    ULONG BufferSize = Header->Wnode.BufferSize;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PLIST_ENTRY BufferList = NULL;
    PTRACE_BUFFER_SPACE EtwpTraceBufferSpace;

    EtwpEnterPMCritSection();
    EtwpTraceBufferSpace = RTCxt->EtwpTraceBufferSpace;
    Head = &EtwpTraceBufferSpace->FreeListHead;
    Next = Head->Flink;
    while (Head != Next) {
        ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
        Next = Next->Flink;
        if (ListEntry->Size == BufferSize) {
            BufferList = &ListEntry->BufferListHead;
            break;
        }
    }
    if (BufferList != NULL) {

       InsertHeadList(BufferList, &Header->Entry);
    }
    else {

        //  We shoule not get here. If we do the buffer->Size is
        // Corrupted.
        EtwpAssert(BufferList == NULL);
    }
    EtwpLeavePMCritSection();
}



ULONG
WMIAPI
WmiOpenTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
/*++

Routine Description:
    Main entry point to process Merged ETL file.


Arguments:

    LogCursor           pointer to WMI_MERGE_ETL_CURSOR

Returned Value:

    Status

--*/
{
    ULONG DosStatus = ERROR_INVALID_PARAMETER;
    NTSTATUS Status;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    PEVENT_TRACE_LOGFILEW Logfile;
    PTRACELOG_CONTEXT pContext;
    ULONG BufferSize;
    PWMI_BUFFER_HEADER BufferHeader;
    ULONG CpuNum;
    BOOLEAN CpuBufferFound;
    
    EtwpInitProcessHeap();

    if (LogCursor != NULL) {
        LogCursor->Base = NULL;
        LogCursor->TraceMappingHandle = NULL;
        LogCursor->CursorVersion = WMI_MERGE_ETL_CURSOR_VERSION;

        Logfile = &LogCursor->Logfile;
        HandleEntry = EtwpAllocateTraceHandle();
        if (HandleEntry == NULL) {
            DosStatus = ERROR_OUTOFMEMORY;
        } else {
            TraceHandle = HandleEntry->TraceHandle;
            try {
                DosStatus = EtwpCopyLogfileInfo(HandleEntry,
                                                Logfile,
                                                TRUE
                    );
                if (DosStatus == ERROR_SUCCESS) {
                    DosStatus = EtwpCreateGuidMapping();
                    if (DosStatus == ERROR_SUCCESS) {
                        DosStatus = EtwpProcessLogHeader(&HandleEntry->TraceHandle,
                                                         &Logfile,
                                                         1,
                                                         TRUE,
                                                         FALSE
                            );
                    }
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                DosStatus = EtwpNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if (DosStatus == ERROR_SUCCESS) {
        //
        // Now Make sure the bit was set, indicating a MERGED ETL
        //

        if ((LogCursor->Logfile.LogFileMode & EVENT_TRACE_RELOG_MODE) == 0) {
            //
            // It is not Merged ETL.
            //
            DosStatus = ERROR_BAD_FORMAT;
        } else {
            //
            // Now find out the number of CPU's, Current event, etc.
            //
            pContext = LogCursor->Logfile.Context;
            //
            // Now Create a file Mapping
            //
            LogCursor->TraceMappingHandle = 
                CreateFileMapping(pContext->Handle,
                                  0,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                    );

            if (LogCursor->TraceMappingHandle == NULL) {
                DosStatus = GetLastError();
                return DosStatus;
            }

            //
            // MapView of the file
            //
            LogCursor->Base = MapViewOfFile(LogCursor->TraceMappingHandle, 
                                            FILE_MAP_READ, 
                                            0, 
                                            0, 
                                            0);
            if (LogCursor->Base == NULL) {
                DosStatus = GetLastError();
                return DosStatus;
            }
    
            //
            // Now find the first event of each CPU
            //
            pContext = LogCursor->Logfile.Context;
            BufferSize = pContext->BufferSize;
            LogCursor->CurrentCpu = 0;

            for (CpuNum = 0; CpuNum < LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CpuNum++) {
                CpuBufferFound = FALSE;
                while (CpuBufferFound == FALSE) {
                    BufferHeader = (PWMI_BUFFER_HEADER)
                                   ((UCHAR*) LogCursor->Base + 
                                    LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart);

                    if (BufferHeader->ClientContext.ProcessorNumber == CpuNum) {
                        CpuBufferFound = TRUE;
                        LogCursor->BufferCursor[CpuNum].BufferHeader = BufferHeader;
                    } else {
                        LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart += BufferSize;
                        if ((LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart/BufferSize) >=
                            LogCursor->Logfile.LogfileHeader.BuffersWritten) {
                            //
                            // Scanned the whole file;
                            //
                            LogCursor->BufferCursor[CpuNum].NoMoreEvents = TRUE;
                            break;
                        }
                    }
                }
                if (CpuBufferFound) {
                    //
                    // Found the buffer, set the offset
                    //
                    ULONG Size;
                    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
                    PVOID pBuffer;

                    LogCursor->BufferCursor[CpuNum].BufferHeader = BufferHeader;
                    LogCursor->BufferCursor[CpuNum].CurrentEventOffset = sizeof(WMI_BUFFER_HEADER);

                    //
                    // Initialize the first event in each CPU Stream.
                    //
                    pBuffer = LogCursor->BufferCursor[CpuNum].BufferHeader;

                    HeaderType = WmiGetTraceHeader(pBuffer, 
                                                   LogCursor->BufferCursor[CpuNum].CurrentEventOffset, 
                                                   &Size);

                    if (HeaderType != WMIHT_NONE) {
                        EtwpParseTraceEvent(pContext,
                                            pBuffer,
                                            LogCursor->BufferCursor[CpuNum].CurrentEventOffset,
                                            HeaderType,
                                            &LogCursor->BufferCursor[CpuNum].CurrentEvent,
                                            sizeof(EVENT_TRACE));

                        LogCursor->BufferCursor[CpuNum].CurrentEventOffset += Size;
                        LogCursor->CurrentCpu = CpuNum;

                    } else {
                        //
                        // There is no event in this buffer.
                        //
                        DosStatus = ERROR_FILE_CORRUPT;
                        return DosStatus;
                    }

                }
            }
            for (CpuNum = 0; CpuNum < LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CpuNum++) {
                //
                // Find the first event for whole trace.
                //
                if (LogCursor->BufferCursor[CpuNum].NoMoreEvents == FALSE) {
                    if (LogCursor->BufferCursor[LogCursor->CurrentCpu].CurrentEvent.Header.TimeStamp.QuadPart >
                        LogCursor->BufferCursor[CpuNum].CurrentEvent.Header.TimeStamp.QuadPart) {
                        LogCursor->CurrentCpu = CpuNum;
                    }
                }
            }
        }
    } else if ( HandleEntry != NULL) {
        EtwpFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    EtwpSetDosError(DosStatus);
    return DosStatus;
}


ULONG
WMIAPI
WmiCloseTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    ULONG     Status = ERROR_INVALID_PARAMETER;

    if (LogCursor != NULL) {
        if (LogCursor->Base != NULL) {
            if (UnmapViewOfFile(LogCursor->Base) == FALSE) {
                Status = GetLastError();
                return Status;
            } else {
                Status = ERROR_SUCCESS;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS) {
            return Status;
        }

        if (LogCursor->TraceMappingHandle != NULL) {
            if (CloseHandle(LogCursor->TraceMappingHandle) == FALSE) {
                Status = GetLastError();
                return Status;
            } else {
                Status = ERROR_SUCCESS;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    return Status;
}


VOID
WMIAPI
WmiConvertTimestamp(
    OUT PLARGE_INTEGER DestTime,
    IN PLARGE_INTEGER  SrcTime,
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    EtwpCalculateCurrentTime(DestTime, SrcTime, LogCursor->Logfile.Context);
}


ULONG
WMIAPI
WmiGetNextEvent(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    ULONG CurrentCpu = LogCursor->CurrentCpu;
    ULONG Size;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    PVOID pBuffer;
    PWMI_BUFFER_HEADER BufferHeader;
    ULONG BufferSize;
    PTRACELOG_CONTEXT pContext;
    ULONG CpuNum;
    NTSTATUS Status;
    ULONG i;
    BOOLEAN CpuBufferFound = FALSE;
    BOOLEAN MoreEvents = FALSE;

    if (LogCursor == NULL) {
        return MoreEvents;
    }

    //
    // Advance to the next event of this current CPU
    //
retry:

    pBuffer = LogCursor->BufferCursor[CurrentCpu].BufferHeader;

    HeaderType = WmiGetTraceHeader(
                        pBuffer, 
                        LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset, 
                        &Size
                                  );

    pContext = LogCursor->Logfile.Context;
    if (HeaderType == WMIHT_NONE) {
        //
        // End of current buffer, advance to the next buffer for this CPU
        //
        BufferSize = pContext->BufferSize;

        LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart
            = LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart 
              + BufferSize;

        if ((LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart /
             BufferSize) >= LogCursor->Logfile.LogfileHeader.BuffersWritten) {
            //
            // Scanned the whole file;
            //
            LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
        } else {
            while (CpuBufferFound == FALSE) {
                BufferHeader = (PWMI_BUFFER_HEADER)
                               ((UCHAR*) LogCursor->Base + 
                                LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart);

                if (BufferHeader->ClientContext.ProcessorNumber == CurrentCpu) {
                    CpuBufferFound = TRUE;
                } else {
                    LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart += BufferSize;
                    if ((LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart/BufferSize) >=
                        LogCursor->Logfile.LogfileHeader.BuffersWritten) {
                        //
                        // Scanned the whole file;
                        //
                        LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
                        break;
                    }
                }
            }
        }
        if (CpuBufferFound) {
            //
            // Found the buffer, set the offset
            //
            LogCursor->BufferCursor[CurrentCpu].BufferHeader = BufferHeader;
            LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset = sizeof(WMI_BUFFER_HEADER);
            goto retry;
        } else {
            //
            // No more buffer in this CPU stream.
            //
            LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
        }
    } else {
        EtwpParseTraceEvent(pContext, 
                            pBuffer,
                            LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset,
                            HeaderType,
                            &LogCursor->BufferCursor[CurrentCpu].CurrentEvent,
                            sizeof(EVENT_TRACE));

        LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset += Size;

        MoreEvents = TRUE;
    }

    //
    // No more events in current CPU.
    //
    if (MoreEvents == FALSE) {
        for (CurrentCpu=0; CurrentCpu<LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CurrentCpu++) {
            if (LogCursor->BufferCursor[CurrentCpu].NoMoreEvents == FALSE) {
                LogCursor->CurrentCpu = CurrentCpu;
                MoreEvents = TRUE;
                break;
            }
        }
    }

    //
    //  Now find the CPU that has the next event
    //
    if (MoreEvents == TRUE) {
        for (i=0; i<LogCursor->Logfile.LogfileHeader.NumberOfProcessors; i++) {
            if (LogCursor->BufferCursor[i].NoMoreEvents == FALSE) {
                if (LogCursor->BufferCursor[LogCursor->CurrentCpu].CurrentEvent.Header.TimeStamp.QuadPart >
                    LogCursor->BufferCursor[i].CurrentEvent.Header.TimeStamp.QuadPart) {
                    LogCursor->CurrentCpu = i;
                }
            }
        }
    }

    //
    // Finish finding the next event.
    //
    return MoreEvents;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\request.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    request.c

Abstract:

    Implements WMI requests to different data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "request.h"

ULONG EtwpSendWmiKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    OutBuffer is the output buffer for the call to the WMI device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer
    Overlapped is an option OVERLAPPED struct that is used to make the 
        call async

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED StaticOverlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    EtwpEnterPMCritSection();

    if (EtwpKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        EtwpKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (EtwpKMHandle == (HANDLE)-1)
        {
            EtwpKMHandle = NULL;
            EtwpLeavePMCritSection();
            return(GetLastError());
        }
    }
    EtwpLeavePMCritSection();

    if (Overlapped == NULL)
    {
        //
        // if caller didn't pass an overlapped structure then supply
        // our own and make the call synchronous
        //
        Overlapped = &StaticOverlapped;
    
        Overlapped->hEvent = EtwpAllocEvent();
        if (Overlapped->hEvent == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (DeviceHandle == NULL)
    {
        DeviceHandle = EtwpKMHandle;
    }

    do
    {
        IoctlSuccess = DeviceIoControl(DeviceHandle,
                              Ioctl,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              Overlapped);

        if (!IoctlSuccess)
        {
            if (Overlapped == &StaticOverlapped)
            {
                //
                // if the call was successful and we are synchronous then
                // block until the call completes
                //
                if (GetLastError() == ERROR_IO_PENDING)
                {
                    IoctlSuccess = GetOverlappedResult(DeviceHandle,
                                               Overlapped,
                                               ReturnSize,
                                               TRUE);
                }
    
                if (! IoctlSuccess)
                {
                    Status = GetLastError();
                } else {
                    Status = ERROR_SUCCESS;
                }
            } else {
                Status = GetLastError();
            }
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    if (Overlapped == &StaticOverlapped)
    {
        EtwpFreeEvent(Overlapped->hEvent);
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\tracert.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    tracert.c

Abstract:

   Trace RealTime Processing routines


Author:

    07-May-2002 Melur Raghuraman 

Revision History:


--*/


#include "tracep.h"


ULONG
EtwpProcessRealTimeTraces(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    )
/*++

Routine Description:
    Main entry point to process RealTime trace data streams.


Arguments:

    Logfiles            Array of logfile structures with LoggerNames of the RT stream
    LogfileCount        Number of RealTime trace streams to process
    StartTime           StartTime for windowing data
    EndTime             EndTime for windowing data


Returned Value:

    ERROR_SUCCESS       Successfully processed data from realtime trace stream

--*/
{
    ULONG Status;
    BOOL Done = FALSE;
    ULONG i, j;
    PTRACELOG_CONTEXT pContext;
    HANDLE  EventArray[MAXLOGGERS];
    NTSTATUS NtStatus;
    LONGLONG CurrentTime = StartTime;
    LARGE_INTEGER timeout = {(ULONG)(-1 * 10 * 1000 * 1000 * 10), -1};   // Wait for 10 seconds

    //
    // Register for RealTime Callbacks
    //

    Status = EtwpSetupRealTimeContext( HandleArray, Logfiles, LogfileCount);
    if (Status != ERROR_SUCCESS) {
        goto DoCleanup;
    }

    //
    // Build the Handle Array
    //

    for (j=0; j < LogfileCount; j++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;
        EventArray[j] = pContext->RealTimeCxt->MoreDataEvent;
    }


    //
    // Event Processing Loop
    //

    while (!Done) {

        LONGLONG nextTimeStamp;
        BOOL EventInRange;
        PEVENT_TRACE_LOGFILEW logfile;
        //
        // Check to see if end of file has been reached on all the
        // files.
        //

        logfile = NULL;
        nextTimeStamp = 0;

        for (j=0; j < LogfileCount; j++) {
           pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;

           if ((pContext->EndOfFile) &&
               (Logfiles[j]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                EtwpLookforRealTimeBuffers(Logfiles[j]);
            }

           if (pContext->EndOfFile)
                continue;
           if (nextTimeStamp == 0) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
           else if (nextTimeStamp > Logfiles[j]->CurrentTime) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
        }

        if (logfile == NULL) {
            //
            // If no logfile with events found, wait on the realtime event.
            // If no realtime datafeed, then we are done.
            //

            NtStatus = NtWaitForMultipleObjects(LogfileCount, 
                                                &EventArray[0], 
                                                WaitAny, 
                                                FALSE,  
                                                &timeout
                                               );

            if (NtStatus == STATUS_TIMEOUT) {
            //
            // If we timedout, then check to see if the loggers have gone away. 
            //
                if  ( !EtwpCheckForRealTimeLoggers(Logfiles, LogfileCount, Unicode) ) { 
                    break;
                }
            }
            continue;
            break;      // TODO: Is this necessary? 
        }

        //
        // if the Next event timestamp is not within the window of
        // analysis, we do not fire the event callbacks.
        //

        EventInRange = TRUE;

        if ((CurrentTime != 0) && (CurrentTime > nextTimeStamp))
            EventInRange = FALSE;
        if ((EndTime != 0) && (EndTime < nextTimeStamp))
            EventInRange = FALSE;

        // For real time logger, we have to allow events possibly 
        // going back in time. Thus no need to update CurrentTime.

        //
        // Make the Event Callbacks after reacquiring the correct context
        //

        pContext = (PTRACELOG_CONTEXT)logfile->Context;

        if (EventInRange) {
            PEVENT_TRACE pEvent = &pContext->Root->Event;
            Status = EtwpDoEventCallbacks( logfile, pEvent);
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
        }

        //
        // Now advance to next event.
        //

        Status = EtwpLookforRealTimeBuffers(logfile);
        Done = (Status == ERROR_CANCELLED);
    }

DoCleanup:
    for (i=0; i < LogfileCount; i++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;
        if (pContext != NULL) {
            EtwpCleanupTraceLog(pContext, FALSE);
        }
    }
    return Status;
}


ULONG
EtwpCheckForRealTimeLoggers(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode)
{
    ULONG Status = ERROR_SUCCESS;
    TRACEHANDLE LoggerHandle = 0;
    ULONG i;

    for (i=0; i < LogfileCount; i++) {
        //
        // Check to see if this is a RealTime Datafeed
        //
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            //
            // Using the LoggerName, Query the Logger to determine
            // whether this is a Kernel or Usermode realtime logger.
            //
            RtlZeroMemory(&QueryProperties, sizeof(QueryProperties));
            QueryProperties.TraceProp.Wnode.BufferSize = sizeof(QueryProperties);


            if (Unicode)
                Status = EtwControlTraceW(LoggerHandle,
                                  (LPWSTR)Logfiles[i]->LoggerName,
                                  &QueryProperties.TraceProp,
                                  EVENT_TRACE_CONTROL_QUERY);
            else
                Status = EtwControlTraceA(LoggerHandle,
                                  (LPSTR)Logfiles[i]->LoggerName,
                                  (PEVENT_TRACE_PROPERTIES)&QueryProperties,
                                  EVENT_TRACE_CONTROL_QUERY);
            //
            // If the Logger is still around  and the Real Time bit
            // is still set continue processing. Otherwise quit.
            //
            if ((Status == ERROR_SUCCESS) && (QueryProperties.TraceProp.LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ){
                return TRUE;
            }
        }
    }
#ifdef DBG
    //
    // We are expecting to see ERROR_WMI_INSTANCE_NOT_FOUND when the logger 
    // has gone away. Any other error is abnormal. 
    //
    if ( Status != ERROR_WMI_INSTANCE_NOT_FOUND ) {
        EtwpDebugPrint(("WET: EtwpCheckForRealTimeLoggers abnormal failure. Status %X\n", Status));
    }
#endif

    return FALSE;
}


void
EtwpFreeRealTimeContext(
    PTRACELOG_REALTIME_CONTEXT RTCxt
    )
{
    ULONG Status;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PLIST_ENTRY Head, Next;

    if (RTCxt == NULL) {
        return;
    }
    Status = EtwNotificationRegistrationW(
        (const LPGUID) &RTCxt->InstanceGuid,
        FALSE,
        EtwpRealTimeCallback,
        0,
        NOTIFICATION_CALLBACK_DIRECT
        );

    if (RTCxt->MoreDataEvent != NULL) {
        NtClose(RTCxt->MoreDataEvent);
    }

    if (RTCxt->EtwpTraceBufferSpace != NULL) {
        EtwpMemFree(RTCxt->EtwpTraceBufferSpace->Space);
        Head = &RTCxt->EtwpTraceBufferSpace->FreeListHead;
        Next = Head->Flink;
        while (Head != Next) {
            ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
            Next = Next->Flink;
            RemoveEntryList(&ListEntry->Entry);
            EtwpFree(ListEntry);
        }
        EtwpFree(RTCxt->EtwpTraceBufferSpace);
        RTCxt->EtwpTraceBufferSpace = NULL;
    }

    EtwpFree(RTCxt);
}

//
// TODO: If two threads called processtrace for the same RT stream, how can we 
// fire two callbacks 
//


ULONG
EtwpRealTimeCallback(
    IN PWNODE_HEADER Wnode,
    IN ULONG_PTR RTContext //LogFileIndex
    )
/*++

Routine Description:
    This routine is called when a real time buffer becomes available.
    The buffer delivered by WMI is copied to a local pool of ring buffers.
    Each realtime data feed maintains its own pool of ring buffers and the
    LogFileIndex passed back via the Wnode (ProviderId field)
    identifies the stream to which the buffer is destined.


Arguments:

    Wnode           Buffer
    LogFileIndex    Index of the Input stream from which this buffer came.

Returned Value:

    Status Code.

--*/
{
    ULONG index;
    PTRACELOG_REALTIME_CONTEXT Context = (PTRACELOG_REALTIME_CONTEXT) RTContext;
    PWNODE_HEADER pHeader;
    PWMI_CLIENT_CONTEXT ClientContext;
    ULONG CountLost;

    //
    // Assumes that the number of LogFiles is less than the MAXLOGGERS.
    //
    // Get the LogFileIndex to which this buffer is destined through the
    // Logger Historical Context.

    ClientContext = (PWMI_CLIENT_CONTEXT)&Wnode->ClientContext;
    //
    // If we can't use this buffer for  whatever reason, we return and
    // the return code is always ERROR_SUCCESS.
    //


    //
    // Circular FIFO  queue of MAXBUFFERS to hold the buffers.
    // Producer to Fill it and Consumer to Null it.
    //

    index =  (Context->BuffersProduced % MAXBUFFERS);
    if (Context->RealTimeBufferPool[index] == NULL) {  //Empty slot found.
        pHeader = (PWNODE_HEADER) EtwpAllocTraceBuffer(Context, Wnode->BufferSize);
        if (pHeader == NULL) {
            return ERROR_SUCCESS;
        }
        RtlCopyMemory(pHeader, Wnode, Wnode->BufferSize); // One more copy!?
        Context->RealTimeBufferPool[index] = pHeader;
        Context->BuffersProduced++;
        NtSetEvent(Context->MoreDataEvent, NULL);  //Signal the dc there's more data.
    }
    else {                              // No Empty Slots found.
        Context->BufferOverflow++;      // Simply let the buffer go.
    }

    //
    // wmi service maintains only the Delta buffersLost since the last time
    // it was reported. The Count is zeroed once it is reported in a delivered
    // buffer. This means I can add it directly.
    //
    CountLost = Wnode->Version >> 16;
    Context->BufferOverflow += CountLost;

    return ERROR_SUCCESS;
}



ULONG
EtwpSetupRealTimeContext(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount
    )
/*++

Routine Description:
    This routine sets up the context to process real time buffers.
    The real time buffers delivered will be copied and kept in a circular
    buffer pool until the ProcessTracelog routine can consume it.

Arguments:

    LogFile         Array of Logfiles being processed.
    LogFileCount    Number of Logfiles in the Array.

Returned Value:

    Status Code.

--*/
{
    ULONG i;
    ULONG Status;
    USHORT LoggerId;
    ULONG TotalBufferSize = 0;
    SYSTEM_BASIC_INFORMATION SystemInfo;

    Status = EtwpCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }


    for (i=0; i < LogfileCount; i++) {
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            TotalBufferSize += Logfiles[i]->BufferSize; // * SystemInfo.NumberOfProcessors;
         }
    }
    if (TotalBufferSize == 0)
        TotalBufferSize =  DEFAULT_REALTIME_BUFFER_SIZE;

    //
    // Initialize the real time data feed Structures.
    //

    for (i=0; i < LogfileCount; i++) {
        PTRACELOG_REALTIME_CONTEXT RTCxt;
        PTRACELOG_CONTEXT pContext;
        PTRACE_BUFFER_LIST_ENTRY pListEntry;
        LARGE_INTEGER Frequency;
        ULONGLONG Counter = 0;
        ULONG SizeReserved;
        PVOID BufferSpace;


        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {

            pContext = EtwpLookupTraceHandle(HandleArray[i]);
            if (pContext == NULL) {
                return EtwpSetDosError(ERROR_OUTOFMEMORY);
            }
            pContext->IsRealTime = TRUE;
            pContext->Handle = NULL;
            Logfiles[i]->Context = pContext;
            Logfiles[i]->BuffersRead = 0;

            pContext->EndOfFile = TRUE;


            //
            // Save the flags from OpenTrace at this time before the first
            // buffer callback which will erase it.
            //

            pContext->ConversionFlags = Logfiles[i]->LogfileHeader.ReservedFlags;

            pContext->UsePerfClock = Logfiles[i]->LogfileHeader.ReservedFlags;

            //
            // If the conversion flags are set, adjust UsePerfClock accordingly.
            //
            if (pContext->ConversionFlags & EVENT_TRACE_USE_RAWTIMESTAMP ) {
                pContext->UsePerfClock = EVENT_TRACE_CLOCK_RAW;
            }

            //
            // Fill in the StartTime, Frequency and StartPerfClock fields
            //

            Status = NtQueryPerformanceCounter((PLARGE_INTEGER)&Counter,
                                                &Frequency);
            pContext->StartPerfClock.QuadPart = Counter;
            pContext->PerfFreq.QuadPart = Frequency.QuadPart;
            pContext->StartTime.QuadPart = EtwpGetSystemTime();
            
            RTCxt = (PTRACELOG_REALTIME_CONTEXT)EtwpAlloc(
                                             sizeof(TRACELOG_REALTIME_CONTEXT));

            if (RTCxt == NULL) {
                return EtwpSetDosError(ERROR_OUTOFMEMORY);
            }

            RtlZeroMemory(RTCxt, sizeof(TRACELOG_REALTIME_CONTEXT));

            RTCxt->MoreDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (RTCxt->MoreDataEvent == NULL) {
                return EtwpSetDosError(ERROR_OBJECT_NOT_FOUND);
            }

            //
            // Save the RTCxt in a global pContext array so that the
            // notification callback from WMI can get at it through the
            // logfile index i.
            //
            LoggerId = (USHORT)Logfiles[i]->Filled; // get the stashed LoggerId.
            pContext->LoggerId = LoggerId;

            pContext->RealTimeCxt = RTCxt;

            RTCxt->InstanceGuid = Logfiles[i]->LogfileHeader.LogInstanceGuid;

            //
            // Allocate the buffer space to receive the ral time buffers
            //

            RTCxt->EtwpTraceBufferSpace = (PTRACE_BUFFER_SPACE)EtwpAlloc(
                                        sizeof(TRACE_BUFFER_SPACE));

            if (RTCxt->EtwpTraceBufferSpace == NULL) {
                return ERROR_OUTOFMEMORY;
            }
            RtlZeroMemory(RTCxt->EtwpTraceBufferSpace, sizeof(TRACE_BUFFER_SPACE));
            InitializeListHead(&RTCxt->EtwpTraceBufferSpace->FreeListHead);

            SizeReserved = MAXBUFFERS *
                           TotalBufferSize;


            BufferSpace = EtwpMemReserve( SizeReserved );
            if (BufferSpace == NULL) {
                return ERROR_OUTOFMEMORY;
            }

            RTCxt->EtwpTraceBufferSpace->Reserved = SizeReserved;
            RTCxt->EtwpTraceBufferSpace->Space = BufferSpace;

            //
            // For Every Logger Stream we need to register with WMI
            // for buffer notification with its Security Guid.
            //
            Status = EtwNotificationRegistrationW(
                            (const LPGUID) &RTCxt->InstanceGuid,
                            TRUE,
                            EtwpRealTimeCallback, 
                            (ULONG_PTR)RTCxt,
                            NOTIFICATION_CALLBACK_DIRECT
                            );
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
            //
            // Allocate Room to process one event
            //

            pListEntry = (PTRACE_BUFFER_LIST_ENTRY) EtwpAlloc( sizeof(TRACE_BUFFER_LIST_ENTRY) );
            if (pListEntry == NULL) {
                return ERROR_OUTOFMEMORY;
            }
            RtlZeroMemory(pListEntry, sizeof(TRACE_BUFFER_LIST_ENTRY) );

            pContext->Root = pListEntry;

        }
    }

    return ERROR_SUCCESS;
}

ULONG
EtwpLookforRealTimeBuffers(
    PEVENT_TRACE_LOGFILEW logfile
    )
/*++

Routine Description:
    This routine checks to see if there are any real time buffers
    ready for consumption.  If so, it sets up the CurrentBuffer and
    the CurrentEvent for this logfile stream. If no buffers are available
    simply sets the EndOfFile to be true.

Arguments:

    logfile         Current Logfile being processed.

Returned Value:

    ERROR_SUCCESS       Successfully moved to the next event.

--*/
{
    ULONG index;
    ULONG BuffersRead;
    PVOID pBuffer;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PTRACELOG_REALTIME_CONTEXT RTCxt;
    PWMI_BUFFER_HEADER pHeader;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    ULONG Status;


    if (logfile == NULL) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }
    pContext = logfile->Context;

    RTCxt = pContext->RealTimeCxt;

    if (RTCxt == NULL) {
        return EtwpSetDosError(ERROR_INVALID_DATA);
    }


    if (pContext->EndOfFile != TRUE) {

        pBuffer = pContext->BufferCache[0].Buffer;
        pEvent = &pContext->Root->Event;
        Status = ERROR_SUCCESS;
        Size = 0;
        if ((HeaderType = WmiGetTraceHeader(pBuffer, pContext->Root->BufferOffset, &Size)) != WMIHT_NONE) {
            if (Size > 0) {
                Status = EtwpParseTraceEvent(pContext, pBuffer, pContext->Root->BufferOffset, HeaderType, pEvent, sizeof(EVENT_TRACE));
                pContext->Root->BufferOffset += Size;
            }
        }
        pContext->Root->EventSize = Size;

        if ( ( Size > 0) && (Status == ERROR_SUCCESS) ) {
            logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
            return ERROR_SUCCESS;
        }
        else {
            //
            // When the current buffer is exhausted, make the
            // BufferCallback
            //
            if (logfile->BufferCallback) {
                ULONG bRetVal;
                try {
                    bRetVal = (*logfile->BufferCallback) (logfile);
                    if (!bRetVal) {
                        return ERROR_CANCELLED;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    pContext->EndOfFile = TRUE;
                    Status = GetExceptionCode();
#ifdef DBG
                    EtwpDebugPrint(("TRACE: BufferCallback threw exception %X\n",
                                            Status));
#endif
                    EtwpSetDosError(EtwpNtStatusToDosError(Status));
                    return ERROR_CANCELLED; // so that realtime also cleans up.
                }
            }
            EtwpFreeTraceBuffer(RTCxt, pBuffer);
        }
    }

    pContext->EndOfFile = TRUE;
    logfile->CurrentTime = 0;

    BuffersRead = logfile->BuffersRead;
    // Check to see if there are more  buffers to consume.
    if (BuffersRead < RTCxt->BuffersProduced) {
        index = (BuffersRead % MAXBUFFERS);
        if ( RTCxt->RealTimeBufferPool[index] != NULL) {
            PWMI_CLIENT_CONTEXT ClientContext;
            PWNODE_HEADER Wnode;

            pBuffer = (char*) (RTCxt->RealTimeBufferPool[index]);
            pContext->BufferCache[0].Buffer = pBuffer;
            RTCxt->RealTimeBufferPool[index] = NULL; 

            Wnode = (PWNODE_HEADER)pContext->BufferCache[0].Buffer;

            pHeader = (PWMI_BUFFER_HEADER)pContext->BufferCache[0].Buffer;

            Offset = sizeof(WMI_BUFFER_HEADER);

            pEvent = &pContext->Root->Event;

            logfile->BuffersRead++;

            if ((HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size)) != WMIHT_NONE) {
                if (Size == 0)
                    return ERROR_INVALID_DATA;
                Status = EtwpParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

                if (Status != ERROR_SUCCESS) {
                    return Status;
                } 
            }
            else {
                //
                // Empty Buffers are flushed when FlushTimer is used or when the
                // logger is stopped. We need to handle it properly here. 
                //
                return ERROR_SUCCESS;
            }

            Offset += Size;

            pContext->Root->BufferOffset = Offset;
            pContext->Root->EventSize = Size;

            logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;

            // Since the RealTime Logger may have started after
            // the consumer started, we have to get the buffersize
            // like this.
            logfile->BufferSize = Wnode->BufferSize;
            logfile->Filled     = (ULONG)pHeader->Offset;

            pContext->EndOfFile = FALSE;



        }
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\tracep.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    tracep.h

Abstract:

    Trace Consumer header file


Author:

    07-May-2002 Melur Raghuraman

Revision History:


--*/


#define INITGUID
#include "wmiump.h"
#include "traceump.h"
#include "evntrace.h"
#include "ntperf.h"

#define DEFAULT_LOG_BUFFER_SIZE         1024
#define DEFAULT_REALTIME_BUFFER_SIZE    32768

#define MAXBUFFERS                      1024

#define MAX_TRACE_BUFFER_CACHE_SIZE   29

extern ULONG WmipTraceDebugLevel;

#define  ETW_LEVEL_MIN      0 
#define  ETW_LEVEL_API      1 
#define  ETW_LEVEL_BUFFER   2 
#define  ETW_LEVEL_EVENT    3
#define  ETW_LEVEL_MAX      4

#define ETW_LOG_ERROR()           (WmipTraceDebugLevel >> ETW_LEVEL_MIN)
#define ETW_LOG_API()             (WmipTraceDebugLevel >> ETW_LEVEL_API)
#define ETW_LOG_BUFFER()          (WmipTraceDebugLevel >> ETW_LEVEL_BUFFER)
#define ETW_LOG_EVENT()           (WmipTraceDebugLevel >> ETW_LEVEL_EVENT)
#define ETW_LOG_MAX()             (WmipTraceDebugLevel >> ETW_LEVEL_MAX)


//
// Kernel Events are logged with SYSTEM_TRACE_HEADER or PERFINFO_TRACE_HEADER. 
// These headers have a GroupType and not a Guid in the header. In post-processing
// we map the Grouptype to Guid transparently to the consumer. 
// The mapping between GroupType and Guid is maintained by this structure. 
//

typedef struct _TRACE_GUID_MAP {        // used to map GroupType to Guid
    ULONG               GroupType;      // Group & Type
    GUID                Guid;           // Guid
} TRACE_GUID_MAP, *PTRACE_GUID_MAP;

//
// In W2K and WinXP, TraceEventInstance API replaced the Guids in the header
// with GuidHandle values. In postprocessing we need to replace the GuidHandle
// back to Guid transparently to the consumer. The mapping between GuidHandle
// and Guid is maintained by EVENT_GUID_MAP structure. This is obsolete in 
// .NET and above. 
//

typedef struct _EVENT_GUID_MAP {
    LIST_ENTRY          Entry;
    ULONGLONG           GuidHandle;
    GUID                Guid;
} EVENT_GUID_MAP, *PEVENT_GUID_MAP;

//
// Callback routines wired through SetTraceCallback API is maintained by 
// the EVENT_TRACE_CALLBACK structure. This is global for the process at the 
// moment mainly due to the way the API is designed. 
//

typedef struct _EVENT_TRACE_CALLBACK {
    LIST_ENTRY          Entry;
    GUID                Guid;
    PEVENT_CALLBACK     CallbackRoutine;
} EVENT_TRACE_CALLBACK, *PEVENT_TRACE_CALLBACK;



//
// If the tracelog instance is a realtime data feed instead of from a
// tracefile, TRACELOG_REALTIME_CONTEXT is used to maintain the real time
// buffers in a buffer pool.
//

typedef struct _TRACE_BUFFER_SPACE {
    ULONG               Reserved;   // amount of memory reserved
    ULONG               Committed;
    PVOID               Space;
    LIST_ENTRY          FreeListHead;
} TRACE_BUFFER_SPACE, *PTRACE_BUFFER_SPACE;

typedef struct _TRACELOG_REALTIME_CONTEXT {
    ULONG           BuffersProduced;    // Number of Buffers to read
    ULONG           BufferOverflow;     // Number of Buffers missed by the consumer
    GUID            InstanceGuid;       // Logger Instance Guid
    HANDLE          MoreDataEvent;      // Event to signal there is more data in this stream
    PTRACE_BUFFER_SPACE EtwpTraceBufferSpace;
    PWNODE_HEADER   RealTimeBufferPool[MAXBUFFERS];
} TRACELOG_REALTIME_CONTEXT, *PTRACELOG_REALTIME_CONTEXT;


//
// RealTime Free Buffer Pool is chained up as TRACE_BUFFER_HEADER
//

typedef struct _TRACE_BUFFER_HEADER {
    WNODE_HEADER Wnode;
    LIST_ENTRY   Entry;
} TRACE_BUFFER_HEADER, *PTRACE_BUFFER_HEADER;

typedef struct _TRACERT_BUFFER_LIST_ENTRY {
    ULONG Size;
    LIST_ENTRY Entry;
    LIST_ENTRY BufferListHead;
} TRACERT_BUFFER_LIST_ENTRY, *PTRACERT_BUFFER_LIST_ENTRY;


typedef struct _TRACE_BUFFER_CACHE_ENTRY {
    LONG Index;
    PVOID Buffer;
} TRACE_BUFFER_CACHE_ENTRY, *PTRACE_BUFFER_CACHE_ENTRY;


struct _TRACE_BUFFER_LIST_ENTRY;

typedef struct _TRACE_BUFFER_LIST_ENTRY {
    struct _TRACE_BUFFER_LIST_ENTRY *Next;
    LONG        FileOffset;     // Offset in File of this Buffer
    ULONG       BufferOffset;   // Offset in Buffer for the current event
    ULONG       Flags;          // Flags on status of this buffer
    ULONG       EventSize;
    ULONG       ClientContext;  // Alignment, ProcessorNumber
    ULONG       TraceType;      // Current Event Type
    EVENT_TRACE Event;          // CurrentEvent of this Buffer
} TRACE_BUFFER_LIST_ENTRY, *PTRACE_BUFFER_LIST_ENTRY;


typedef struct _TRACELOG_CONTEXT {
    LIST_ENTRY          Entry;          // Keeps track of storage allocations.

    //
    // This implements a caching scheme for Sequential files with repeated
    // call to ProcessTrace. 
    // 
    ULONGLONG  OldMaxReadPosition; // Maximum Read Position for the file. 
                                // Only valid for Sequential, used for 
                                // Read Behind. 
                                // Upon Exit From ProcessTrace, this 
                                // value can be cached to avoid rescanning. 

    LONGLONG   LastTimeStamp; 

    // Fields from HandleListEntry
    EVENT_TRACE_LOGFILEW Logfile;

    TRACEHANDLE     TraceHandle;
    ULONG           ConversionFlags;    // Indicates event processing options
    LONG            BufferBeingRead;
    OVERLAPPED      AsynchRead;

    //
    // Fields Below this will be reset upon ProcessTrace exit. 
    //

    BOOLEAN             fProcessed;
    USHORT              LoggerId;       // Logger Id of this DataFeed. 
    UCHAR               IsRealTime;     // Flag to tell if this feed is RT.
    UCHAR               fGuidMapRead;

    LIST_ENTRY   GuidMapListHead;   // This is LogFile specific property

    //
    // For using PerfClock, we need to save startTime, Freq 
    //

    ULONG   UsePerfClock; 
    ULONG   CpuSpeedInMHz;
    LARGE_INTEGER PerfFreq;             // Frequency from the LogFile
    LARGE_INTEGER StartTime;            // Start Wall clock time
    LARGE_INTEGER StartPerfClock;       // Start PerfClock value
    
    union 
       {
       HANDLE              Handle;         // NT handle to logfile
       PTRACELOG_REALTIME_CONTEXT RealTimeCxt; // Ptr to Real Time Context
       };

    ULONG EndOfFile;   // Flag to show whether this stream is still active.

    ULONG           BufferSize;
    ULONG           BufferCount;
    ULONG           StartBuffer; // Start of the Circular Buffers
    ULONG           FirstBuffer; // Jump off point to start reading
    ULONG           LastBuffer;  // last of the buffers in the boundary

    PTRACE_BUFFER_LIST_ENTRY Root;
    PTRACE_BUFFER_LIST_ENTRY BufferList;
    PVOID  BufferCacheSpace;
    TRACE_BUFFER_CACHE_ENTRY BufferCache[MAX_TRACE_BUFFER_CACHE_SIZE];

    LIST_ENTRY StreamListHead;  // Used to free the Stream datastructures
    ULONGLONG           MaxReadPosition;
    PERFINFO_GROUPMASK  PerfGroupMask;
    ULONG      CbCount;

} TRACELOG_CONTEXT, *PTRACELOG_CONTEXT;

//
// Each LogFile supplied to ProcessTrace consists of a number
// of streams. Each Stream has the following structure.
//

typedef struct _TRACE_STREAM_CONTEXT {
    LIST_ENTRY   Entry;     // SortList Entry 
    LIST_ENTRY   AllocEntry;// Used to free storage

    EVENT_TRACE  CurrentEvent;
    ULONG   EventCount;     // Number of Events detected in current buffer
    ULONG   CbCount;
    ULONG   ScanDone;       // For circular logfiles
    BOOLEAN bActive;        // Is this Stream still active?
    USHORT  Type;            // StreamType
    ULONG   ProcessorNumber; // Processor Number for this stream
    ULONG   CurrentOffset;   // Offset into the buffer
    ULONGLONG    ReadPosition;   // BufferCount starts with 0 for first buffer
    PTRACELOG_CONTEXT  pContext;  // back pointer to the LogFileContext
                                     // Need this only for GetNextBuffer?
    PVOID   StreamBuffer;            // CurrentBuffer for this stream

} TRACE_STREAM_CONTEXT, *PTRACE_STREAM_CONTEXT;



//
// this structure is used only by EtwpGetBuffersWrittenFromQuery() and
// EtwpCheckForRealTimeLoggers()
//
typedef struct _ETW_QUERY_PROPERTIES {
    EVENT_TRACE_PROPERTIES TraceProp;
    WCHAR  LoggerName[MAXSTR];
    WCHAR  LogFileName[MAXSTR];
} ETW_QUERY_PROPERTIES, *PETW_QUERY_PROPERTIES; 





extern ETW_QUERY_PROPERTIES QueryProperties;
extern PLIST_ENTRY  EventCallbackListHead;
extern ULONG WmiTraceAlignment;

//
// This TraceHandleListHeadPtr should be the only real global 
// for ProcessTrace to be multithreaded
//

extern PLIST_ENTRY TraceHandleListHeadPtr;
extern PTRACE_GUID_MAP  EventMapList;  // Array mapping the Grouptype to Guids

#define EtwpNtStatusToDosError(Status) ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

extern
ULONG
WMIAPI
EtwNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

extern
ULONG
WMIAPI
EtwControlTraceA(
    IN TRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    );

extern
ULONG
WMIAPI
EtwControlTraceW(
    IN TRACEHANDLE LoggerHandle,
    IN LPCWSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    );

__inline __int64 EtwpGetSystemTime()
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    return SystemTime.QuadPart;
}


extern
BOOL
EtwpSynchReadFile(
    HANDLE LogFile, 
    LPVOID Buffer, 
    DWORD NumberOfBytesToRead, 
    LPDWORD NumberOfBytesRead,
    LPOVERLAPPED Overlapped
    );

extern
__inline 
ULONG
EtwpSetDosError(
    IN ULONG DosError
    );

extern
PVOID
EtwpMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    );

extern
ULONG
EtwpMemFree(
    IN PVOID Buffer
    );

extern
PVOID
EtwpMemReserve(
    IN SIZE_T   Size
    );

__inline Move64(
    IN  PLARGE_INTEGER pSrc,
    OUT PLARGE_INTEGER pDest
    )
{
    pDest->LowPart = pSrc->LowPart;
    pDest->HighPart = pSrc->HighPart;
}

#ifdef DBG
void
EtwpDumpEvent(
    PEVENT_TRACE pEvent
    );
void
EtwpDumpGuid(
    LPGUID
    );

void
EtwpDumpCallbacks();
#endif


ULONG
EtwpConvertEnumToTraceType(
    WMI_HEADER_TYPE eTraceType
    );

WMI_HEADER_TYPE
EtwpConvertTraceTypeToEnum(
                            ULONG TraceType
                          );

ULONG
EtwpCheckForRealTimeLoggers(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
);

ULONG
EtwpLookforRealTimeBuffers(
    PEVENT_TRACE_LOGFILEW logfile
    );
ULONG
EtwpRealTimeCallback(
    IN PWNODE_HEADER Wnode,
    IN ULONG_PTR Context
    );
void
EtwpFreeRealTimeContext(
    PTRACELOG_REALTIME_CONTEXT RTCxt
    );

ULONG
EtwpSetupRealTimeContext(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount
    );

PVOID
EtwpAllocTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    ULONG BufferSize
    );

VOID
EtwpFreeTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    PVOID Buffer
    );

ULONG
EtwpProcessRealTimeTraces(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    );

//
// Routines used in this file only
//

ULONG
EtwpDoEventCallbacks(
    PEVENT_TRACE_LOGFILEW logfile,
    PEVENT_TRACE pEvent
    );

ULONG
EtwpCreateGuidMapping(void);

LPGUID
EtwpGuidMapHandleToGuid(
    PLIST_ENTRY GuidMapListHeadPtr,
    ULONGLONG    GuidHandle
    );

void
EtwpCleanupGuidMapList(
    PLIST_ENTRY GuidMapListHeadPtr
    );

PTRACELOG_CONTEXT
EtwpLookupTraceHandle(
    TRACEHANDLE TraceHandle
    );


void
EtwpCleanupTraceLog(
    PTRACELOG_CONTEXT pEntry,
    BOOLEAN bSaveLastOffset
    );

VOID
EtwpGuidMapCallback(
    PLIST_ENTRY GuidMapListHeadPtr,
    PEVENT_TRACE pEvent
    );

ULONG
EtwpProcessGuidMaps(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
    );

PEVENT_TRACE_CALLBACK
EtwpGetCallbackRoutine(
    LPGUID pGuid
    );

VOID 
EtwpFreeCallbackList();


ULONG
EtwpProcessLogHeader(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode,
    ULONG bFree
    );

ULONG
EtwpProcessTraceLog(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    );

ULONG
EtwpProcessTraceLogEx(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    );

ULONG
EtwpParseTraceEvent(
    IN PTRACELOG_CONTEXT pContext,
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    );

ULONG
EtwpGetBuffersWrittenFromQuery(
    LPWSTR LoggerName
    );

VOID
EtwpCopyLogHeader (
    IN PTRACE_LOGFILE_HEADER pLogFileHeader,
    IN PVOID MofData,
    IN ULONG MofLength,
    IN PWCHAR *LoggerName,
    IN PWCHAR *LogFileName,
    IN ULONG  Unicode
    );

ULONG
EtwpSetupLogFileStreams(
    PLIST_ENTRY pStreamListHead,
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,    
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG Unicode
    );

ULONG
EtwpGetLastBufferWithMarker(
    PTRACELOG_CONTEXT pContext
    );

ULONG
EtwpAddTraceStream(
    PLIST_ENTRY pStreamListHead,
    PTRACELOG_CONTEXT pContext,
    USHORT StreamType,
    LONGLONG StartTime,
    LONGLONG EndTime,     
    ULONG   ProcessorNumber
    );

ULONG 
EtwpGetNextBuffer(
    PTRACE_STREAM_CONTEXT pStream
    );

ULONG
EtwpAdvanceToNewEventEx(
    PLIST_ENTRY pStreamListHead, 
    PTRACE_STREAM_CONTEXT pStream
    );

ULONG
EtwpGetNextEventOffsetType(
    PUCHAR pBuffer,
    ULONG Offset,
    PULONG RetSize
    );

ULONG
EtwpCopyCurrentEvent(
    PTRACELOG_CONTEXT   pContext,
    PVOID               pHeader,
    PEVENT_TRACE        pEvent,
    ULONG               TraceType,
    PWMI_BUFFER_HEADER  LogBuffer
    );

LPGUID
EtwpGroupTypeToGuid(
    ULONG GroupType
    );

VOID
EtwpCalculateCurrentTime (
    OUT PLARGE_INTEGER    DestTime,
    IN  PLARGE_INTEGER    TimeValue,
    IN  PTRACELOG_CONTEXT pContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\wmicore_client.c ===
#include "wmicore_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\tracesup.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    tracesup.c

Abstract:

    Data Consumer Processing for version 1.2 and above


Author:

    07-May-2002 Melur Raghuraman

Revision History:


--*/


#include "tracep.h"

#define TIME_IN_RANGE(x, a, b) ((a == 0) || (x >= a)) && ((b == 0) || (x <= b))

ULONG WmipTraceDebugLevel=0;

// 0 No Debugging. Default
// 1 Errors only
// 2 API Level Messages
// 4 Buffer Level Messages
// 8 Event Level Messages
// 16 All messages. Maximum
// 

ULONG
EtwpProcessTraceLogEx(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    )
/*++

Routine Description:
    This routine processes an array of traces from file. It goes through each 
    event till the end of file, firing event callbacks (if any) along the way.
    It handles circular logfiles and windowing of data (with the given start 
    and end times) correctly. When more than one trace it provides the callback
    in chronological order. 

Arguments:

    Logfiles        Array of traces
    LogfileCount    Number of traces
    StartTime       Starting Time of the window of analysis
    EndTime         Ending Time of the window of analysis
    Unicode         Unicode Flag. 

Returned Value:

    Status Code.

--*/
{
    PTRACELOG_CONTEXT pContext;
    ULONG i;
    ULONG Status;
    LONGLONG CurrentTime = StartTime;
    LONGLONG PreviousTime = 0;
    LIST_ENTRY StreamListHead; 

    //
    // This temporary list is a sorted list of streams. They are in 
    // ascending order of TimeStamp. When each stream events are 
    // exhausted they are dropped from this list. When this list is
    // empty, we are done. 
    //
    InitializeListHead(&StreamListHead);

    Status = EtwpSetupLogFileStreams( &StreamListHead, 
                                      HandleArray, 
                                      Logfiles, 
                                      LogfileCount, 
                                      StartTime, 
                                      EndTime, 
                                      Unicode
                                     );
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }
    //
    // At this point, we have the local StreamList in sorted order for
    // the first event. 
    //

    while (!IsListEmpty(&StreamListHead) ) {
        PLIST_ENTRY Next;
        PTRACE_STREAM_CONTEXT pStream;
        BOOLEAN EventInRange;

        Next = RemoveHeadList( &StreamListHead );
        pStream = CONTAINING_RECORD(Next, TRACE_STREAM_CONTEXT, Entry);

        CurrentTime = pStream->CurrentEvent.Header.TimeStamp.QuadPart;

        //
        // Check to see if TimeStamp is forward moving...
        //

        if (ETW_LOG_MAX()) {
            if (CurrentTime < PreviousTime) {
                DbgPrint("ETW: TimeStamp error. Current %I64u Previous %I64u\n",
                          CurrentTime, PreviousTime);
            }
            PreviousTime = CurrentTime;
        }

        //
        // Make The Callback for the Current Event
        // 

        if ( TIME_IN_RANGE(CurrentTime, StartTime, EndTime) )  {

            pStream->CbCount++;
            Status = EtwpDoEventCallbacks( &pStream->pContext->Logfile, 
                                           &pStream->CurrentEvent
                                         );
            pStream->pContext->LastTimeStamp = CurrentTime;
        }
        else {
            if (ETW_LOG_MAX()) {
                DbgPrint("ETW: EventTime %I64u not in Range %I64u-%I64u\n", 
                          CurrentTime, StartTime, EndTime);
            }
        }

        //
        // Advance to next event for the stream
        //

        Status = EtwpAdvanceToNewEventEx(&StreamListHead, pStream);
        //
        // If the caller indicates to quit via the buffer callback, quit
        //
        if (Status == ERROR_CANCELLED)
        {
            if (ETW_LOG_API()) {
                DbgPrint("ETW: Processing Cancelled \n");
            }
            break;
        }
    }

Cleanup:
    for (i=0; i < LogfileCount; i++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;
        if (pContext != NULL) {

            if ((Status == ERROR_SUCCESS) && 
                (pContext->ConversionFlags & EVENT_TRACE_READ_BEHIND) ) {
                EtwpCleanupTraceLog(pContext, TRUE);
            }
            else {
                EtwpCleanupTraceLog(pContext, FALSE);
            }
        }
    }
    return Status;
}


//
// EtwpSetupLogFileStreams will set up the stream for each logfile.
//
ULONG
EtwpSetupLogFileStreams(
    PLIST_ENTRY pStreamListHead,
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,    
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG Unicode
    )
{
    ULONG Status = ERROR_SUCCESS;
    long NumProc;
    PTRACELOG_CONTEXT pContext;
    long i, j;

    //
    // Breakdown each logfile into streams
    //

    for (i=0; i<(long)LogfileCount; i++) {

        NumProc = Logfiles[i]->LogfileHeader.NumberOfProcessors;
        pContext = Logfiles[i]->Context;

        if (NumProc == 0) NumProc = 1;

        //
        // Before Setting up the streams find the last buffer range
        //
        EtwpGetLastBufferWithMarker( pContext );


        //
        // Set up the Generic Streams
        //

        for (j = 0; j < NumProc; j++) {

            Status = EtwpAddTraceStream( pStreamListHead,
                                         pContext,
                                         WMI_BUFFER_TYPE_GENERIC, 
                                         StartTime, 
                                         EndTime, 
                                         j
                                        );

        //
        // The LogFileHeader is logged as a RunDown buffer. 
        //


            Status = EtwpAddTraceStream( pStreamListHead,
                                        pContext,
                                        WMI_BUFFER_TYPE_RUNDOWN,
                                        StartTime, 
                                        EndTime, 
                                        j
                                       );

            if (Logfiles[i]->IsKernelTrace) {
                if ( PerfIsGroupOnInGroupMask(PERF_CONTEXT_SWITCH, &pContext->PerfGroupMask) ) {
                   Status = EtwpAddTraceStream( pStreamListHead,
                                               pContext,
                                               WMI_BUFFER_TYPE_CTX_SWAP,
                                               StartTime, EndTime,
                                               j
                                              );
                }
            }
        }
    }
    return Status;
}


//
// This routine will find the last buffer in the logfile with 
// WMI_BUFFER_FLAG_FLUSH_MARKER set. We can only process upto 
// this point. 
//



ULONG
EtwpGetLastBufferWithMarker(
    PTRACELOG_CONTEXT pContext
    )
{

    ULONGLONG ReadPosition;
    PVOID pTmpBuffer;
    ULONG BufferSize;
    ULONG nBytesRead=0;
    PWMI_BUFFER_HEADER pHeader;
    ULONG Status;

    EtwpAssert(pContext != NULL);

    pContext->MaxReadPosition = 0;
    BufferSize = pContext->BufferSize;

    if (ETW_LOG_MAX()) {

        ReadPosition = 0;

        pTmpBuffer = EtwpAlloc(BufferSize);
    
        if (pTmpBuffer == NULL) {
            return ERROR_OUTOFMEMORY;
        }

dumpmore:
        pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
        pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);

        Status = EtwpSynchReadFile(pContext->Handle,
                  pTmpBuffer,
                  BufferSize,
                  &nBytesRead,
                  &pContext->AsynchRead);

        if (nBytesRead == 0) {
            DbgPrint("End OF File reached\n");
            EtwpFree(pTmpBuffer);
        }
        else {

            PWMI_BUFFER_HEADER pHeader = (PWMI_BUFFER_HEADER) pTmpBuffer;
            PWMI_CLIENT_CONTEXT ClientContext = (PWMI_CLIENT_CONTEXT)&pHeader->Wnode.ClientContext;

            DbgPrint("ReadPos: %I64u  BufferType %d BufferFlag %d Proc %d \n",
            ReadPosition, pHeader->BufferType, pHeader->BufferFlag, ClientContext->ProcessorNumber);

            ReadPosition += BufferSize;
            goto dumpmore;

        }
    }

    if (pContext->Logfile.LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        pContext->MaxReadPosition = pContext->Logfile.LogfileHeader.MaximumFileSize * 1024 * 1024;

        return ERROR_SUCCESS;
    }

    ReadPosition =  pContext->BufferCount * pContext->BufferSize;

    if ( (pContext->ConversionFlags & EVENT_TRACE_READ_BEHIND) != 
                                      EVENT_TRACE_READ_BEHIND)  {
        pContext->MaxReadPosition = ReadPosition;
        return ERROR_SUCCESS;
    }

    if (ReadPosition < BufferSize) {
        if (ETW_LOG_ERROR()) {
            DbgPrint("ETW: ReadPosition %I64u is less than BufferSize %d \n", 
                      ReadPosition, BufferSize);
        }
        return ERROR_SUCCESS;
    }


    //
    // Set the ReadPosition to the start of last buffer
    //

    ReadPosition -= BufferSize;
    pTmpBuffer = EtwpAlloc(BufferSize);

    if (pTmpBuffer == NULL) {
        if (ETW_LOG_ERROR()) {
            DbgPrint("ETW: Allocation Failed %d Bytes, Line %d\n", 
                      BufferSize, __LINE__);
        }
        return ERROR_OUTOFMEMORY;
    }

Retry:

    pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
    pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);

    Status = EtwpSynchReadFile(pContext->Handle,
              pTmpBuffer,
              BufferSize,
              &nBytesRead,
              &pContext->AsynchRead);

    if (nBytesRead == 0) {
        EtwpDebugPrint(("ETW Error: No data in file. \n"));
        pContext->MaxReadPosition = 0;
        EtwpFree(pTmpBuffer);
        return ERROR_SUCCESS;
    }

    pHeader = (PWMI_BUFFER_HEADER) pTmpBuffer;

    if (pHeader->BufferFlag & WMI_BUFFER_FLAG_FLUSH_MARKER) {
        //
        // Found the Marker. It is safe to process events upto this point. 
        //
        if (ETW_LOG_BUFFER()) {
            DbgPrint("ETW: Found Flush Marker at %I64u\n", ReadPosition);
        }
        pContext->MaxReadPosition = ReadPosition;
        EtwpFree(pTmpBuffer);
        return ERROR_SUCCESS;
    }


    if (ReadPosition < BufferSize) {
        EtwpAssert(ReadPosition == 0);
        pContext->MaxReadPosition = 0;
        EtwpFree(pTmpBuffer);
        return ERROR_SUCCESS; 
    }
    else {
        ReadPosition -= BufferSize;
        goto Retry;
    }

    if (ETW_LOG_ERROR()) {
        DbgPrint("ETW: Could not find Last Marker. Corrupt File!\n");
    }

    EtwpAssert(FALSE);

    EtwpFree(pTmpBuffer);
    return ERROR_SUCCESS;
}


ULONG
EtwpAddTraceStream(
    PLIST_ENTRY pStreamListHead,
    PTRACELOG_CONTEXT pContext,
    USHORT StreamType,
    LONGLONG StartTime,
    LONGLONG EndTime,     
    ULONG   ProcessorNumber
    )
{
    ULONG Status = ERROR_SUCCESS;
    PTRACE_STREAM_CONTEXT pStream;


    pStream = (PTRACE_STREAM_CONTEXT) EtwpAlloc( sizeof(TRACE_STREAM_CONTEXT) );
    if (pStream == NULL) {
        if (ETW_LOG_ERROR()) {
            DbgPrint("ETW: Allocation Failed %d Bytes, Line %d\n", 
                       sizeof(TRACE_STREAM_CONTEXT), __LINE__);
        }
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(pStream, sizeof(TRACE_STREAM_CONTEXT) );

    pStream->Type = StreamType;
    pStream->ProcessorNumber = ProcessorNumber;

    pStream->pContext = pContext;


    EtwpAssert( pContext != NULL );
    EtwpAssert(pContext->BufferSize != 0);

    pStream->StreamBuffer = EtwpAlloc(pContext->BufferSize);

    if (pStream->StreamBuffer == NULL) {
        if (ETW_LOG_ERROR()) {
            DbgPrint("ETW: Allocation Failed %d Bytes, Line %d\n",
                       pContext->BufferSize, __LINE__);
        }
        EtwpFree(pStream);
        return ERROR_OUTOFMEMORY;
    }

    //
    // For Circular, Jump off to First Buffer
    // For Non-circular with StartTime specified, try to use the cached offset
    //

    if (pContext->Logfile.LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        if (StreamType != WMI_BUFFER_TYPE_RUNDOWN) {
            pStream->ReadPosition = pContext->FirstBuffer * 
                                    pContext->BufferSize;
        }
        else {
            pStream->ReadPosition = 0;
        }
    }
    else {
        if ( (StartTime > 0) && (StartTime >= pContext->LastTimeStamp) ) {
            pStream->ReadPosition = pContext->OldMaxReadPosition + 
                                    pContext->BufferSize;

            if (pStream->ReadPosition > pContext->MaxReadPosition) {
                EtwpFree(pStream->StreamBuffer);
                EtwpFree(pStream);
                return Status;
            }
        }
    }

    Status = EtwpGetNextBuffer(pStream);

    //
    // If Read failed, it is not fatal. There are no
    // events in this stream. Set the stream to not active and
    // continue.

    if (pStream->bActive) {
        if (ETW_LOG_BUFFER()) {
            DbgPrint("ETW: Added Stream %d Proc %d ReadPosition %I64u\n",
               pStream->Type, pStream->ProcessorNumber, pStream->ReadPosition);
        }
        EtwpAdvanceToNewEventEx(pStreamListHead, pStream);
        InsertTailList(&pContext->StreamListHead, &pStream->AllocEntry);
    }
    else {
        EtwpFree(pStream->StreamBuffer);
        EtwpFree(pStream);
    }

    return Status;
}



ULONG 
EtwpGetNextBuffer(
    PTRACE_STREAM_CONTEXT pStream
    )
{
    PEVENT_TRACE_LOGFILE LogFile;
    PTRACELOG_CONTEXT pContext;
    HANDLE hFile;
    NTSTATUS NtStatus;
    ULONG BufferSize; 
    ULONGLONG ReadPosition;
    PWMI_CLIENT_CONTEXT ClientContext;
    ULONG nBytesRead=0;
    PWMI_BUFFER_HEADER pHeader;
    ULONG Status;
    ULONGLONG FirstOffset, LastOffset, StartOffset;

    ULONG ProcessorNumber = pStream->ProcessorNumber;

    pContext =  pStream->pContext;
    LogFile = &pContext->Logfile;
    hFile = pContext->Handle;

    BufferSize = pContext->BufferSize;

    pStream->EventCount = 0;

    FirstOffset = pContext->FirstBuffer * BufferSize;
    LastOffset = pContext->LastBuffer * BufferSize;
    StartOffset = pContext->StartBuffer * BufferSize;

    //
    // Need to handle FileType properly here. 
    //
retry:

    ReadPosition = pStream->ReadPosition;

    if (ReadPosition > pContext->MaxReadPosition) {
        //
        // Only Valid for Sequential. For read behind mode, we do not 
        // process past the MaxReadPosition. 
        //

        if (pContext->ConversionFlags & EVENT_TRACE_READ_BEHIND) {
            if (ETW_LOG_BUFFER()) {
                DbgPrint("ETW: Reached MaxReadPosition for Stream %d Proc %d\n",                          pStream->Type, pStream->ProcessorNumber);
            }
            pStream->bActive = FALSE;
            return ERROR_SUCCESS;
        }
    }

    if (pContext->Logfile.LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {

        //
        // If we have scanned once and reached FirstBuffer, then we are done. 
        //

        if ( (ReadPosition >= FirstOffset) && pStream->ScanDone) {
            if (ETW_LOG_BUFFER()) {
                DbgPrint("ETW: Stream %d Proc %d Circular Mode Done.\n",
                          pStream->Type, pStream->ProcessorNumber);
            }
            pStream->bActive = FALSE;
            return ERROR_SUCCESS;
        }
    }

    pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
    pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);

    Status = EtwpSynchReadFile(pContext->Handle,
              (LPVOID)pStream->StreamBuffer,
              BufferSize,
              &nBytesRead,
              &pContext->AsynchRead);

    if (nBytesRead == 0) {

        if (pContext->Logfile.LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            if (ReadPosition >= LastOffset && !pStream->ScanDone) {

                //
                // Rundown  stream ends when we reach EOF
                //

                if (pStream->Type ==  WMI_BUFFER_TYPE_RUNDOWN) {
                    pStream->ScanDone = TRUE;
                    pStream->bActive = FALSE;
                    return ERROR_SUCCESS;
                }

                pStream->ReadPosition = StartOffset;
                pStream->ScanDone = TRUE;
                goto retry;
            }
            else  {
                pStream->bActive = FALSE;
            }
        }
        else {
            pStream->bActive = FALSE;
        }
        return ERROR_SUCCESS;
    }

    pStream->ReadPosition += BufferSize;

    pHeader = (PWMI_BUFFER_HEADER) pStream->StreamBuffer;

    ClientContext = (PWMI_CLIENT_CONTEXT)&pHeader->Wnode.ClientContext;    

    if ( ClientContext->ProcessorNumber
                    >= LogFile->LogfileHeader.NumberOfProcessors) {
        ClientContext->ProcessorNumber = (UCHAR) 0;
    }

    if ( (pStream->Type != pHeader->BufferType) || 
         (ClientContext->ProcessorNumber != ProcessorNumber) ) {
        goto retry;
    }

    //
    // If we got here, then we have the right buffer. Set the first 
    // offset so that events can parsed. 
    //

    pStream->CurrentOffset = sizeof(WMI_BUFFER_HEADER);

    pStream->bActive = TRUE;

    return ERROR_SUCCESS;
}



ULONG
EtwpAdvanceToNewEventEx(
    PLIST_ENTRY pStreamListHead, 
    PTRACE_STREAM_CONTEXT pStream
    )
{
    ULONG Size=0;
    WMI_HEADER_TYPE HdrType = WMIHT_NONE;
    PVOID pBuffer;
    ULONG Offset;
    PTRACELOG_CONTEXT pContext; 
    PEVENT_TRACE pEvent;
    ULONG Status;
    PEVENT_TRACE_LOGFILEW logfile;
    //
    // This routine advances to next event for this stream
    //
Retry:

    pBuffer = pStream->StreamBuffer;
    Offset  = pStream->CurrentOffset;
    pContext = pStream->pContext;

    EtwpAssert(pBuffer != NULL);
    EtwpAssert(pContext != NULL);

    pEvent = &pStream->CurrentEvent;

    if ((HdrType = WmiGetTraceHeader(pBuffer, Offset, &Size)) != WMIHT_NONE) {
        if (Size > 0) {
            LONGLONG TimeStamp, NextTimeStamp;
            PLIST_ENTRY Head, Next;
            PTRACE_STREAM_CONTEXT CurrentStream;
            
            EtwpParseTraceEvent( pContext, 
                                 pBuffer, 
                                 Offset,
                                 HdrType, 
                                 pEvent, 
                                 sizeof(EVENT_TRACE)
                                );
            pStream->CurrentOffset += Size;
            pStream->EventCount++;


            Head = pStreamListHead;
            Next = Head->Flink;
            TimeStamp = pStream->CurrentEvent.Header.TimeStamp.QuadPart;

            while (Head != Next) {
                CurrentStream = CONTAINING_RECORD(Next, TRACE_STREAM_CONTEXT, Entry);
                NextTimeStamp = CurrentStream->CurrentEvent.Header.TimeStamp.QuadPart;
                if (TimeStamp < NextTimeStamp) {

                    InsertHeadList(Next->Blink, &pStream->Entry);
                    break;

                }
                //
                // In case of a Tie in TimeStamps, we try to order the events
                // using Sequence numbers, if available. FieldTypeFlags in the 
                // header indicates if this event has a sequence number. 
                //
                else if (TimeStamp == NextTimeStamp) { 
                    USHORT pFlags = pStream->CurrentEvent.Header.FieldTypeFlags;
                    USHORT cFlags = CurrentStream->CurrentEvent.Header.FieldTypeFlags;

                    if (pFlags & EVENT_TRACE_USE_SEQUENCE) {
                        if ( (cFlags & EVENT_TRACE_USE_SEQUENCE) &&
                             (pStream->CurrentEvent.InstanceId <
                              CurrentStream->CurrentEvent.InstanceId)) {
                            InsertHeadList(Next->Blink, &pStream->Entry);
                            break;
                        }
                    }
                    else {
                        InsertHeadList(Next->Blink, &pStream->Entry);
                        break;
                    }
                }
                Next = Next->Flink;
            }

            if (Next == Head) {
                InsertTailList(Head, &pStream->Entry);
            }

        }
        return ERROR_SUCCESS;
    }

    //
    // No more events in this buffer. Advance to next buffer and retry. 
    //

    logfile = &pContext->Logfile;

        if (logfile->BufferCallback) {
            ULONG bRetVal;
            PWMI_BUFFER_HEADER pHeader = (PWMI_BUFFER_HEADER)pBuffer;
            logfile->Filled     = (ULONG)pHeader->Offset;
            logfile->BuffersRead++;
            try {
                bRetVal = (*logfile->BufferCallback) (logfile);
                if (!bRetVal) {
                    return ERROR_CANCELLED;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                EtwpDebugPrint(("TRACE: BufferCallback threw exception %X\n",
                                        Status));
                EtwpSetDosError(EtwpNtStatusToDosError(Status));
                return ERROR_CANCELLED; // so that realtime also cleans up.
            }
        }

    if (ETW_LOG_BUFFER()) {
        PWMI_BUFFER_HEADER pHeader = (PWMI_BUFFER_HEADER)pBuffer;
        DbgPrint("ETW: %d Type %d Flag %d Proc %d Events %d Filled %d Offset %d ReadPos %I64u TimeStamp %I64u\n", 
        logfile->BuffersRead, pStream->Type, pHeader->BufferFlag, pStream->ProcessorNumber,  pStream->EventCount, logfile->Filled, 
        pStream->CurrentOffset, pStream->ReadPosition, pContext->LastTimeStamp);
    }

    Status =  EtwpGetNextBuffer(pStream);

    if (pStream->bActive) {
        goto Retry;
    }

    return ERROR_SUCCESS;

}

WMI_HEADER_TYPE
WMIAPI
WmiGetTraceHeader(
    IN  PVOID  LogBuffer,
    IN  ULONG  Offset,
    OUT ULONG  *Size
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG TraceType;

    try {

        TraceType = EtwpGetNextEventOffsetType(
                                            (PUCHAR)LogBuffer,
                                            Offset,
                                            Size
                                          );

        return EtwpConvertTraceTypeToEnum(TraceType);


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        EtwpDebugPrint(("TRACE: WmiGetTraceHeader threw exception %X\n",
                            Status));
        Status = EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

    return 0;
}

ULONG 
EtwpGetNextEventOffsetType(
    PUCHAR pBuffer,
    ULONG Offset,    
    PULONG RetSize
    )
{
    ULONG   nSize;
    ULONG   TraceMarker;
    ULONG   TraceType = 0;
    PWMI_BUFFER_HEADER Header;
    ULONG Alignment;
    ULONG BufferSize;

    if (RetSize != NULL) {
        *RetSize = 0;
    }
    if (pBuffer == NULL) {
        return 0;
    }

    Header = (PWMI_BUFFER_HEADER)pBuffer;

    Alignment =  Header->ClientContext.Alignment;
    BufferSize = Header->Wnode.BufferSize;

    //
    // Check for end of buffer (w/o End of Buffer Marker case...)
    //
    if ( Offset >= (BufferSize - sizeof(long)) ){
        return 0;
    }

    TraceMarker =  *((PULONG)(pBuffer + Offset));

    if (TraceMarker == 0xFFFFFFFF) {
        return 0;
    }

    if (TraceMarker & TRACE_HEADER_FLAG) {
    //
    // If the first bit is set, then it is either TRACE or PERF record.
    //
        if (TraceMarker & TRACE_HEADER_EVENT_TRACE) {   // One of Ours.
            TraceType = (TraceMarker & TRACE_HEADER_ENUM_MASK) >> 16;
            switch(TraceType) {
                //
                // ISSUE: Need to split the two so we can process cross platform
                //        shsiao 03/22/2000
                //
                case TRACE_HEADER_TYPE_PERFINFO32:
                case TRACE_HEADER_TYPE_PERFINFO64:
                {
                    PUSHORT Size;
                    Size = (PUSHORT) (pBuffer + Offset + sizeof(ULONG));
                    nSize = *Size;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM32:
                case TRACE_HEADER_TYPE_SYSTEM64:
                {
                    PUSHORT Size;
                    Size = (PUSHORT) (pBuffer + Offset + sizeof(ULONG));
                    nSize = *Size;
                    break;
                }
                case TRACE_HEADER_TYPE_FULL_HEADER:
                case TRACE_HEADER_TYPE_INSTANCE:
                {
                   PUSHORT Size;
                   Size = (PUSHORT)(pBuffer + Offset);
                   nSize = *Size;
                   break;
                }
                default:
                {
                    return 0;
                }
            }

        } 

        else if ((TraceMarker & TRACE_HEADER_ULONG32_TIME) ==
                            TRACE_HEADER_ULONG32_TIME) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset);
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_TIMED;
        }
        else if ((TraceMarker & TRACE_HEADER_ULONG32) ==
                            TRACE_HEADER_ULONG32) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset);
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_ULONG32;
        }
        else if ((TraceMarker & TRACE_MESSAGE) ==
                                TRACE_MESSAGE) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset) ;
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_MESSAGE;
        }
        else {
            return 0;
        }
    }
    else {  // Must be WNODE_HEADER
        PUSHORT Size;
        Size = (PUSHORT) (pBuffer + Offset);
        nSize = *Size;
        TraceType = TRACE_HEADER_TYPE_WNODE_HEADER;
    }
    //
    // Check for End Of Buffer Marker
    //
    if (nSize == 0xFFFFFFFF) {
        return 0;
    }

    if (Alignment != 0) {
        nSize = (ULONG) ALIGN_TO_POWER2(nSize, Alignment);
    }

    //
    // Check for larger than BufferSize
    //

    if (nSize >= BufferSize) {
        return 0;
    }

    if (RetSize != NULL) {
        *RetSize = nSize;
    }

    return TraceType;
}



ULONG
EtwpParseTraceEvent(
    IN PTRACELOG_CONTEXT pContext,
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    )
{
    PWMI_BUFFER_HEADER Header = (PWMI_BUFFER_HEADER)LogBuffer;
    ULONG Status = ERROR_SUCCESS;
    PVOID pEvent;

    if ( (LogBuffer == NULL) ||
         (EventInfo == NULL) ||
         (EventInfoSize < sizeof(EVENT_TRACE_HEADER)) )
    {
        return (ERROR_INVALID_PARAMETER);
    } 

    Status = EtwpCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    try {

        RtlZeroMemory(EventInfo, sizeof(EVENT_TRACE));

        pEvent = (void*) ((PUCHAR)LogBuffer + Offset);

        EtwpCopyCurrentEvent(pContext,
                         pEvent,
                         EventInfo,
                         EtwpConvertEnumToTraceType(HeaderType),
                         (PWMI_BUFFER_HEADER)LogBuffer
                         );

        ( (PEVENT_TRACE)EventInfo)->ClientContext = Header->Wnode.ClientContext;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        EtwpDebugPrint(("TRACE: EtwpParseTraceEvent threw exception %X\n",
                            Status));
        Status = EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

    return Status;
}

ULONG
EtwpCopyCurrentEvent(
    PTRACELOG_CONTEXT   pContext,
    PVOID               pHeader,
    PEVENT_TRACE        pEvent,
    ULONG               TraceType,
    PWMI_BUFFER_HEADER  LogBuffer
    )
/*++

Routine Description:
    This routine copies the Current Event from the logfile buffer stream to 
    the CurrentEvent structure provided by the caller. The routine takes
    care of the differences between kernel event and user events by mapping
    all events uniformly to the EVENT_TRACE_HEADER structure. 

Arguments:
    pHeader           Pointer to the datablock in the input stream (logfile).
    pEvent            Current Event to which the data is copied.
    TraceType         Enum indicating the header type. 
    LogBuffer         The buffer 

Returned Value:

    Status indicating success or failure. 

--*/
{
    PEVENT_TRACE_HEADER pWnode;
    PEVENT_TRACE_HEADER pWnodeHeader;
    ULONG nGroupType;
    LPGUID pGuid;
    ULONG UsePerfClock = 0;
    ULONG UseBasePtr = 0;
    ULONG PrivateLogger=0;

    if (pHeader == NULL || pEvent == NULL)
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);

    if (pContext != NULL) {
        UsePerfClock = pContext->UsePerfClock;
        UseBasePtr = pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT;
        PrivateLogger = (pContext->Logfile.LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
    }

    switch(TraceType) {
        //
        // ISSUE: Need to split the two so we can process cross platform.
        //        shsiao 03/22/2000
        //
        case TRACE_HEADER_TYPE_PERFINFO32:
        case TRACE_HEADER_TYPE_PERFINFO64:
        {
            PPERFINFO_TRACE_HEADER pPerfHeader;
            pPerfHeader = (PPERFINFO_TRACE_HEADER) pHeader;
            nGroupType = pPerfHeader->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pPerfHeader->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pPerfHeader->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;

            pGuid = EtwpGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));

            pWnode->Size                = pPerfHeader->Packet.Size;
            pWnode->Class.Type          = pPerfHeader->Packet.Type;
            pWnode->Class.Version       = pPerfHeader->Version;

            EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pPerfHeader->SystemTime,
                                      pContext );

            //
            // PERFINFO headers does not have ThreadId or CPU Times
            //

            if( LogBuffer->Flags & WNODE_FLAG_THREAD_BUFFER ){

                pWnode->ThreadId = LogBuffer->CurrentOffset;

            } else {

                pWnode->ProcessId = -1;
                pWnode->ThreadId = -1;

            }
            

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                //
                // Override the Timestamp with SystemTime from PERFCounter. 
                // If rdtsc is used no conversion is done. 
                //
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pPerfHeader->SystemTime = pWnode->TimeStamp;
                }
            }
            else if (pWnode->Size > FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data)) {
                pEvent->MofData = (PVOID) ((char*) pHeader +
                                  FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data));
                pEvent->MofLength = pWnode->Size - 
                                    FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);
            }
            pEvent->Header.FieldTypeFlags = EVENT_TRACE_USE_NOCPUTIME;
            
            break;
        }
        case TRACE_HEADER_TYPE_SYSTEM32:
        {
            PSYSTEM_TRACE_HEADER pSystemHeader32;
            pSystemHeader32 = (PSYSTEM_TRACE_HEADER) pHeader;
            nGroupType = pSystemHeader32->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pSystemHeader32->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pSystemHeader32->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pGuid = EtwpGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));
            pWnode->Size            = pSystemHeader32->Packet.Size;
            pWnode->ThreadId        = pSystemHeader32->ThreadId;
            pWnode->ProcessId       = pSystemHeader32->ProcessId;
            pWnode->KernelTime      = pSystemHeader32->KernelTime;
            pWnode->UserTime        = pSystemHeader32->UserTime;
            pWnode->Class.Type      = pSystemHeader32->Packet.Type;
            pWnode->Class.Version   = pSystemHeader32->Version;

            EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pSystemHeader32->SystemTime,
                                      pContext );

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pSystemHeader32->SystemTime = pWnode->TimeStamp;
                }
            }
            else {
                pWnode->FieldTypeFlags = 0;
                if (pWnode->Size > sizeof(SYSTEM_TRACE_HEADER)) {
                    pEvent->MofData       = (PVOID) ((char*) pHeader +
                                                  sizeof(SYSTEM_TRACE_HEADER));
                    pEvent->MofLength = pWnode->Size - sizeof(SYSTEM_TRACE_HEADER); 
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_SYSTEM64:
        {
            PSYSTEM_TRACE_HEADER pSystemHeader64;
            pSystemHeader64 = (PSYSTEM_TRACE_HEADER) pHeader;

            nGroupType = pSystemHeader64->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pSystemHeader64->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pSystemHeader64->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pGuid = EtwpGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));
            pWnode->Size            = pSystemHeader64->Packet.Size;
            pWnode->ThreadId        = pSystemHeader64->ThreadId;
            pWnode->ProcessId       = pSystemHeader64->ProcessId;
            pWnode->KernelTime      = pSystemHeader64->KernelTime;
            pWnode->UserTime        = pSystemHeader64->UserTime;
            pWnode->Class.Type      = pSystemHeader64->Packet.Type;
            pWnode->Class.Version   = pSystemHeader64->Version;

            EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pSystemHeader64->SystemTime,
                                      pContext );

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pSystemHeader64->SystemTime = pWnode->TimeStamp;
                }
            }
            else {
                pWnode->FieldTypeFlags = 0;
                if (pWnode->Size > sizeof(SYSTEM_TRACE_HEADER)) {

                    pEvent->MofData       = (PVOID) ((char*) pHeader +
                                                  sizeof(SYSTEM_TRACE_HEADER));
                    pEvent->MofLength = pWnode->Size - sizeof(SYSTEM_TRACE_HEADER);
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_FULL_HEADER:
        {
            pWnodeHeader = (PEVENT_TRACE_HEADER) pHeader;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            RtlCopyMemory(pWnode,
                          pWnodeHeader, 
                          sizeof(EVENT_TRACE_HEADER)
                          );
            EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pWnodeHeader->TimeStamp, 
                                      pContext );

            if (UseBasePtr) {
                pEvent->Header.Size = pWnodeHeader->Size;
                pEvent->MofData =  (PVOID)pHeader;
                pEvent->MofLength = pWnodeHeader->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pWnodeHeader->TimeStamp = pWnode->TimeStamp;
                }
            }
            else {
            //
            // If the data came from Process Private Logger, then
            // mark the ProcessorTime field as valid
            //
                pEvent->Header.FieldTypeFlags = (PrivateLogger) ? EVENT_TRACE_USE_PROCTIME : 0;

                if (pWnodeHeader->Size > sizeof(EVENT_TRACE_HEADER)) {

                    pEvent->MofData = (PVOID) ((char*)pWnodeHeader +
                                                        sizeof(EVENT_TRACE_HEADER));
                    pEvent->MofLength = pWnodeHeader->Size - 
                                        sizeof(EVENT_TRACE_HEADER);
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_INSTANCE:
        {
            // new scheme using EVENT_INSTANCE_GUID_HEADER
            if (((pContext->Logfile.LogfileHeader.VersionDetail.SubVersion >= 1) && 
                (pContext->Logfile.LogfileHeader.VersionDetail.SubMinorVersion >= 1)) ||
                pContext->Logfile.LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
                PEVENT_INSTANCE_GUID_HEADER pInstanceHeader;
                pInstanceHeader = (PEVENT_INSTANCE_GUID_HEADER) pHeader;
                RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
                pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
                // EVENT_INSTANCE_GUID_HEADER is the same as the first part of the EVENT_TRACE.
                // No need to copy IIDs and parent GUID
                RtlCopyMemory(pWnode,
                              pInstanceHeader,
                              sizeof(EVENT_INSTANCE_GUID_HEADER)
                              );
                EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                          &pInstanceHeader->TimeStamp, 
                                          pContext );

                if (UseBasePtr) {
                    pEvent->Header.Size = pInstanceHeader->Size;
                    pEvent->MofData =  (PVOID)pHeader;
                    pEvent->MofLength = pInstanceHeader->Size;
                    if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                        pInstanceHeader->TimeStamp = pWnode->TimeStamp;
                    }
                }
                else {
                    pEvent->Header.FieldTypeFlags = (PrivateLogger) ? EVENT_TRACE_USE_PROCTIME : 0;
                    if (pInstanceHeader->Size > sizeof(EVENT_INSTANCE_GUID_HEADER)) {

                        pEvent->MofData = (PVOID) ((char*)pInstanceHeader +
                                                    sizeof(EVENT_INSTANCE_GUID_HEADER));
                        pEvent->MofLength = pInstanceHeader->Size -
                                            sizeof(EVENT_INSTANCE_GUID_HEADER);
                    }
                }
            }
            else {    
                PEVENT_INSTANCE_HEADER pInstanceHeader;
                pInstanceHeader = (PEVENT_INSTANCE_HEADER) pHeader;
                RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
                pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
                RtlCopyMemory(pWnode,
                              pInstanceHeader,
                              sizeof(EVENT_INSTANCE_HEADER)
                              );
                EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                          &pInstanceHeader->TimeStamp, 
                                          pContext );

                pEvent->InstanceId = pInstanceHeader->InstanceId;
                pEvent->ParentInstanceId = pInstanceHeader->ParentInstanceId;

                pGuid = EtwpGuidMapHandleToGuid(&pContext->GuidMapListHead, pInstanceHeader->RegHandle);
                if (pGuid != NULL) {
                  pEvent->Header.Guid = *pGuid;
                }
                else {
                    RtlZeroMemory(&pEvent->Header.Guid, sizeof(GUID));
                }

                if (pInstanceHeader->ParentRegHandle != (ULONGLONG)0) {
                    pGuid =  EtwpGuidMapHandleToGuid(
                                                &pContext->GuidMapListHead, 
                                                pInstanceHeader->ParentRegHandle);
                    if (pGuid != NULL) {
                        pEvent->ParentGuid = *pGuid;
                    }
#ifdef DBG
                    else {
                        EtwpAssert(pGuid != NULL);
                    }
#endif
                }


                if (UseBasePtr) {
                    pEvent->Header.Size = pInstanceHeader->Size;
                    pEvent->MofData =  (PVOID)pHeader;
                    pEvent->MofLength = pInstanceHeader->Size;
                    if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                        pInstanceHeader->TimeStamp = pWnode->TimeStamp;
                    }
                }
                else {
                    pEvent->Header.FieldTypeFlags = (PrivateLogger) ? EVENT_TRACE_USE_PROCTIME : 0;
                    if (pInstanceHeader->Size > sizeof(EVENT_INSTANCE_HEADER)) {

                        pEvent->MofData = (PVOID) ((char*)pInstanceHeader +
                                                    sizeof(EVENT_INSTANCE_HEADER));
                        pEvent->MofLength = pInstanceHeader->Size -
                                            sizeof(EVENT_INSTANCE_HEADER);
                    }
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_TIMED:
        {
            PTIMED_TRACE_HEADER pTimedHeader;
            pTimedHeader = (PTIMED_TRACE_HEADER) pHeader;

            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pWnode->Size                = pTimedHeader->Size;
            pWnode->Version             = pTimedHeader->EventId;
            EtwpCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pTimedHeader->TimeStamp,
                                      pContext );

            pWnode->ThreadId = -1;
            pWnode->ProcessId = -1;

            if (UseBasePtr) {
                pEvent->MofData =  (PVOID)pHeader;
                pEvent->MofLength = pTimedHeader->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pTimedHeader->TimeStamp = pWnode->TimeStamp;
                }
            }
            else if (pWnode->Size > sizeof(TIMED_TRACE_HEADER)) {

                pEvent->MofData       = (PVOID) ((char*) pHeader +
                                              sizeof(TIMED_TRACE_HEADER));
                pEvent->MofLength = pWnode->Size - sizeof(TIMED_TRACE_HEADER);
            }
            pEvent->Header.FieldTypeFlags = EVENT_TRACE_USE_NOCPUTIME;
            break;
        }
        case TRACE_HEADER_TYPE_WNODE_HEADER:
        {
            PWNODE_HEADER pTmpWnode = (PWNODE_HEADER) pHeader;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            RtlCopyMemory(&pEvent->Header,  pTmpWnode,  sizeof(WNODE_HEADER));
            pEvent->MofData   = (PVOID) pTmpWnode;
            pEvent->MofLength = pTmpWnode->BufferSize;
            break;
        }
        case TRACE_HEADER_TYPE_MESSAGE:
        {
            PMESSAGE_TRACE pMsg = (PMESSAGE_TRACE) pHeader;
            USHORT              MessageFlags = 0;
            UCHAR               * pMessageData;
            ULONG               MessageLength;

            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            RtlCopyMemory(&pEvent->Header, pMsg, sizeof(MESSAGE_TRACE_HEADER));
            //
            // Now Process the Trace Message header options
            //
            
            pMessageData = (char *)pMsg + sizeof(MESSAGE_TRACE_HEADER);
            MessageLength = pMsg->MessageHeader.Size;
            MessageFlags = ((PMESSAGE_TRACE_HEADER)pEvent)->Packet.OptionFlags;
            
            // Note that the order in which these are added is critical New 
            // entries must be added at the end!
            //
            // [First Entry] Sequence Number
            if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
                if (MessageLength >= sizeof(ULONG)) {
                    RtlCopyMemory(&pEvent->InstanceId, pMessageData, sizeof(ULONG));
                    pMessageData += sizeof(ULONG);
                    MessageLength -= sizeof(ULONG);
                    //
                    // Software tracing tools look at this (overlapped) field, so
                    // we should not overwrite it.
                    //
                    pEvent->Header.FieldTypeFlags |= EVENT_TRACE_USE_SEQUENCE;
                } else {
                    goto TraceMessageShort;
                }
            }
            
            // [Second Entry] GUID ? or CompnentID ?
            if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
                if (MessageLength >= sizeof(ULONG)) {
                    RtlCopyMemory(&pEvent->Header.Guid,pMessageData,sizeof(ULONG)) ;
                    pMessageData += sizeof(ULONG);
                    MessageLength -= sizeof(ULONG);
                } else {
                    goto TraceMessageShort;
                }
            } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
                if (MessageLength >= sizeof(GUID)) {
                    RtlCopyMemory(&pEvent->Header.Guid,pMessageData, sizeof(GUID));
                    pMessageData += sizeof(GUID);
                    MessageLength -= sizeof(GUID);
                } else {
                    goto TraceMessageShort;
                }
            }
            
            // [Third Entry] Timestamp?
            if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
                LARGE_INTEGER TimeStamp;
                if (MessageLength >= sizeof(LARGE_INTEGER)) {
                    RtlCopyMemory(&TimeStamp,pMessageData,sizeof(LARGE_INTEGER));
                    pMessageData += sizeof(LARGE_INTEGER);
                    MessageLength -= sizeof(LARGE_INTEGER);
                    EtwpCalculateCurrentTime( &pEvent->Header.TimeStamp, 
                                              &TimeStamp,
                                              pContext );
                } else {
                    goto TraceMessageShort;
                }
            }
            
            // [Fourth Entry] System Information?
            if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
                if (MessageLength >= 2 * sizeof(ULONG)) {
                    RtlCopyMemory(&pEvent->Header.ThreadId, pMessageData, sizeof(ULONG)) ;
                    pMessageData += sizeof(ULONG);
                    MessageLength -=sizeof(ULONG);
                    RtlCopyMemory(&pEvent->Header.ProcessId,pMessageData, sizeof(ULONG)) ;
                    pMessageData += sizeof(ULONG);
                    MessageLength -=sizeof(ULONG);
                } else {
                    goto TraceMessageShort;
                }
            }
            //
            // Add New Header Entries immediately before this comment!
            //
 
 TraceMessageShort:

            if (UseBasePtr) {
                pEvent->MofData = (PVOID)pHeader;
                pEvent->MofLength = pMsg->MessageHeader.Size;
            }
            else {
                pEvent->MofData = (PVOID)&(pMsg->Data) ;
                if (pMsg->MessageHeader.Size >= sizeof(MESSAGE_TRACE_HEADER) ) {
                    pEvent->MofLength = pMsg->MessageHeader.Size - sizeof(MESSAGE_TRACE_HEADER);
                } else {
                    pEvent->MofLength = 0;
                }
            }
            break;
        }
        default:                            // Assumed to be REAL WNODE
            break;
    }

    return EtwpSetDosError(ERROR_SUCCESS);
}



LPGUID
EtwpGroupTypeToGuid(
    ULONG GroupType
    )
/*++

Routine Description:
    This routine returns the GUID corresponding to a given GroupType.
    The mapping is static and is defined by the kernel provider.

    This routine assumes that the EventMapList is available for use. 
    It is allocated once via ProcessTrace and never deleted. 

Arguments:
    GroupType           The GroupType of the kernel event. 

Returned Value:

    Pointer to the GUID representing the given GroupType.  

--*/
{
    ULONG i;
    for (i = 0; i < MAX_KERNEL_TRACE_EVENTS; i++) {
        if (EventMapList[i].GroupType == GroupType) 
            return (&EventMapList[i].Guid);
    }
    return NULL;
}

VOID
EtwpCalculateCurrentTime (
    OUT PLARGE_INTEGER    DestTime,
    IN  PLARGE_INTEGER    TimeValue,
    IN  PTRACELOG_CONTEXT pContext
    )
{
    ULONG64 StartPerfClock;
    ULONG64 CurrentTime, TimeStamp;
    ULONG64 Delta;
    double dDelta;

    if (pContext == NULL) {
        Move64(TimeValue, DestTime);
        return;
    }

    if (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT) {
        Move64(TimeValue, DestTime);
        return;
    }

    Move64(TimeValue, (PLARGE_INTEGER) &TimeStamp);

    if ((pContext->UsePerfClock == EVENT_TRACE_CLOCK_SYSTEMTIME) ||
        (pContext->UsePerfClock == EVENT_TRACE_CLOCK_RAW)) {
        //
        // System time, just return the time stamp.
        //
        Move64(TimeValue, DestTime);
        return;
    } 
    else if (pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
        if (pContext->PerfFreq.QuadPart == 0) {
            Move64(TimeValue, DestTime);
            return;
        }
        StartPerfClock = pContext->StartPerfClock.QuadPart;
        if (TimeStamp > StartPerfClock) {
            Delta = (TimeStamp - StartPerfClock);
            dDelta =  ((double) Delta) *  (10000000.0 / (double)pContext->PerfFreq.QuadPart);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart + Delta;
        }
        else {
            Delta = StartPerfClock - TimeStamp;
            dDelta =  ((double) Delta) *  (10000000.0 / (double)pContext->PerfFreq.QuadPart);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart - Delta;
        }
        Move64((PLARGE_INTEGER) &CurrentTime, DestTime);
        return;
    } 
    else {
        if (pContext->CpuSpeedInMHz == 0) {
            Move64(TimeValue, DestTime);
            return;
        }
        StartPerfClock = pContext->StartPerfClock.QuadPart;
        if (TimeStamp > StartPerfClock) {
            Delta = (TimeStamp - StartPerfClock);
            dDelta =  ((double) Delta) *  (10.0 / (double)pContext->CpuSpeedInMHz);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart + Delta;
        }
        else {
            Delta = StartPerfClock - TimeStamp;
            dDelta =  ((double) Delta) *  (10.0 / (double)pContext->CpuSpeedInMHz);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart - Delta;
        }
        Move64((PLARGE_INTEGER) &CurrentTime, DestTime);
        return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\evntrace\sources.inc ===
USE_CRTDLL=1

MAJORCOMP=sdktools
MINORCOMP=evntrace

NTTARGETFILES=copyexe

TARGETNAME=evntrace
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES= evntrace.c 

UMTYPE=console
UMAPPL=evntrace

LINKLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib \
         $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

C_DEFINES=-DWIN32 -DNT -DSDK_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\evntrace\ansi\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\provider\unicode\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\provider\ansi\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\evntrace\evntrace.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, stop event tracing

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR                          1024
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Evm")
#define NT_LOGGER                       _T("NT Kernel Logger")
#define MAXIMUM_LOGGERS                 16
#define MAXGUIDS                        128

#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST			4
#define ACTION_ENABLE                   5

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

void
SplitCommandLine( 
    LPTSTR CommandLine, 
    LPTSTR* pArgv 
    );

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    );

LPTSTR
DecodeStatus(
    IN ULONG Status
    );

ULONG
GetGuids(LPTSTR GuidFile, LPGUID *GuidArray);

void   StringToGuid(TCHAR *str, LPGUID guid);

ULONG ahextoi(TCHAR *s);

TCHAR ErrorMsg[MAXSTR];

FILE  *fp;

int __cdecl _tmain(int argc, _TCHAR ** argv)
{
    ULONG GuidCount, i, j;
    USHORT Action = 0;
    ULONG Status = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR GuidFile[MAXSTR];
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    LPTSTR *commandLine;
    LPTSTR *targv;
    int targc;
    LPGUID *GuidArray;
    char *Space;
    char *save;
    BOOL bKill = FALSE;
    BOOL bEnable = TRUE;
    ULONG iLevel = 0;
    ULONG iFlags = 0;
    ULONG SizeNeeded = 0;



    // Very important!!!
    // Initialize structure first
    //
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        exit(ERROR_OUTOFMEMORY);
    }


    fp = _tfopen(_T("evntrace.log"), _T("a+"));
    if (fp == NULL) {
        _tprintf(_T("evntrace.log file open failed. quit!\n"));
        return (1);
    }

    _ftprintf(fp, _T("\n----------Start evntrace.exe--------\n\n"));
    _tprintf(_T("\n----------Start evntrace.exe--------\n\n"));
#ifdef DEBUG
    for(i=0; i<(ULONG)argc; i++) {
        _tprintf(_T("argv[%d]=%s\n"), i, argv[i]);
        _ftprintf(fp, _T("argv[%d]=%s\n"), i, argv[i]);
    }
    _tprintf(_T("\n"));
    _ftprintf(fp, _T("\n"));
#endif
    

    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset 
                                     + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, NT_LOGGER);

    Space = (char*) malloc( (MAXGUIDS * sizeof(GuidArray)) +
                            (MAXGUIDS * sizeof(GUID) ));
    if (Space == NULL) {
        free(pLoggerInfo);
        exit(ERROR_OUTOFMEMORY);
    }
    save = Space;
    GuidArray = (LPGUID *) Space;
    Space += MAXGUIDS * sizeof(GuidArray);

    for (GuidCount=0; GuidCount<MAXGUIDS; GuidCount++) {
        GuidArray[GuidCount] = (LPGUID) Space;
        Space += sizeof(GUID);
    }
    GuidCount = 0;

    targc = argc;
    commandLine = (LPTSTR*)malloc( argc * sizeof(LPTSTR) );
    if (commandLine == NULL) {
        free(Space);
        free(pLoggerInfo);
        exit(ERROR_OUTOFMEMORY);
    }
    for(i=0;i<(ULONG)argc;i++){
        commandLine[i] = (LPTSTR)malloc(MAXSTR * sizeof(TCHAR));
        if (commandLine[i] == NULL) {
            for (j=0; j < i; j++)
                free(commandLine[j]);
            free(commandLine);
            free(pLoggerInfo);
            free(Space);
        }
    }
    
    SplitCommandLine( GetCommandLine(), commandLine );
    targv = commandLine;

    //
    // Add default flags. Should consider options to control this independently
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-q"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    _tfullpath(LogFileName, targv[1], MAXSTR);
                    ++targv; --argc;

                    _ftprintf(fp, _T("Setting log file to:    '%s'\n"), 
                              LogFileName);
                    _tprintf(_T("Setting log file to: %s\n"), LogFileName);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {

                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        StringToGuid(targv[1], GuidArray[0]);
                        ++targv; --argc;
                        GuidCount=1;
                    }
                }

            }
            else if (!_tcsicmp(targv[0], _T("-seq"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Setting maximum sequential logfile size to: %d Mbytes\n"), pLoggerInfo->MaximumFileSize);
                    _tprintf(_T("Setting maximum sequential logfile size to: %d\n"),
                        pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cir"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Setting maximum circular logfile size to: %d Mbytes\n"), pLoggerInfo->MaximumFileSize);
                    _tprintf(_T("Setting maximum circular logfile size to: %d\n"),
                        pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-b"))) {
                if (argc > 1) {
                    pLoggerInfo->BufferSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing buffer size to %d\n"), pLoggerInfo->BufferSize);
                    _tprintf(_T("Changing buffer size to %d\n"),
                        pLoggerInfo->BufferSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flag"))) {
                if (argc > 1) {
                    pLoggerInfo->EnableFlags |= _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting logger flags to %d\n"),
                        pLoggerInfo->EnableFlags );
                }
            }
            else if (!_tcsicmp(targv[0], _T("-min"))) {
                if (argc > 1) {
                    pLoggerInfo->MinimumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing Minimum Number of Buffers to %d\n "), pLoggerInfo->MinimumBuffers);
                    _tprintf(_T("Changing Minimum Number of Buffers to %d\n"),
                        pLoggerInfo->MinimumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing Maximum Number of Buffers to %d\n "),pLoggerInfo->MaximumBuffers);
                    _tprintf(_T("Changing Maximum Number of Buffers to %d\n"),
                        pLoggerInfo->MaximumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-level"))) {
                if (argc > 1) {
                    iLevel = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting tracing level to %d\n"), iLevel);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flags"))) {
                if (argc > 1) {
                    iFlags = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting command to %d\n"), iFlags);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-ft"))) {
                if (argc > 1) {
                    pLoggerInfo->FlushTimer = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting buffer flush timer to %d seconds\n"),
                        pLoggerInfo->FlushTimer);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
                    _ftprintf(fp, _T("Setting Private Logger Flags\n"));
                    _tprintf(_T("Setting Private Logger Flags\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-rt"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
                _ftprintf(fp, _T("Setting real time mode\n"));
                _tprintf(_T("Setting real time mode\n"));
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       if (targv[1][0] == 'b')
                           pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                   }
               }
            }
            else if (!_tcsicmp(targv[0], _T("-age"))) {
                if (argc > 1) {
                    pLoggerInfo->AgeLimit = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Changing Aging Decay Time to %d\n"),
                        pLoggerInfo->AgeLimit);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-l"))) {
        		Action = ACTION_LIST;
            }
            else if (!_tcsicmp(targv[0], _T("-x"))) {
        		Action = ACTION_LIST;
        		bKill = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-fio"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
            }
            else if (!_tcsicmp(targv[0], _T("-pf"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
            }
            else if (!_tcsicmp(targv[0], _T("-hf"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
            }
            else if (!_tcsicmp(targv[0], _T("-img"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){

                _tprintf( 
                    _T("Usage: tracelog [options] | [-h | -help | -?]\n")
                    _T("\t-start     Starts up a trace session\n")
                    _T("\t-stop      Stops a trace session\n")
                    _T("\t-update    Updates a trace session\n")
                    _T("\t-b   <n>   Sets buffer size to <n> Kbytes\n")
                    _T("\t-min <n>   Sets minimum buffers\n")
                    _T("\t-max <n>   Sets maximum buffers\n")
                    _T("\t-x         Stops all active trace sessions\n")
                    _T("\t-q         Queries the status of trace session\n")
                    _T("\t-f name    Log to file <name>\n")
                    _T("\t-seq [n]   Sequential logfile of up to n Mbytes\n")
                    _T("\t-cir n     Circular logfile of n Mbytes\n")
                    _T("\t-nf  n     Sequentially to new file every n Mb\n")
                    _T("\t-ft n      Set flush timer to n seconds\n")
                    _T("\t-fio       Enable file I/O tracing\n")
                    _T("\t-pf        Enable page faults tracing\n")
                    _T("\t-hf        Enable hard faults tracing\n")
                    _T("\t-img       Enable image load tracing\n")
                    _T("\t-um        Enable Process Private tracing\n")
                    _T("\t-guid <file> Start tracing for providers in file\n")
                    _T("\t-rt [b]    Enable tracing in real time mode\n")
                    _T("\t-age n     Modify aging decay time\n")
                    _T("\t-level n\n")
                    _T("\t-flags n\n")
                    _T("\t-h\n")
                    _T("\t-help\n")
                    _T("\t-?         Prints this information\n")
                    _T("NOTE: The default with no options is -q\n") 
                    );

                return 0;
            }
            else Action = 0;
        }
        else { // get here if "-" or "/" given
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            return 0;
        }
    }
    if (!_tcscmp(LoggerName, NT_LOGGER)) {
        pLoggerInfo->EnableFlags |= (EVENT_TRACE_FLAG_PROCESS |
                                   EVENT_TRACE_FLAG_THREAD |
                                   EVENT_TRACE_FLAG_DISK_IO |
                                   EVENT_TRACE_FLAG_NETWORK_TCPIP);
        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid;   // default to OS tracing
    }

    if ( !(pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if ( _tcslen(LogFileName) <= 0   && 
             ((Action == ACTION_START) || (Action == ACTION_UPDATE))) {
            _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); // for now...
        }
    }

    switch (Action) {
        case  ACTION_START:
           if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
               if (GuidCount != 1) {
                    _ftprintf(fp, _T("Need exactly one GUID for PRIVATE loggers\n"));
                   _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                   return 0;
               }
               pLoggerInfo->Wnode.Guid = *GuidArray[0];
           }

            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _ftprintf(fp, _T("Could not start logger: %s\nOperation Status = %uL, %s"), LoggerName, Status, DecodeStatus(Status));
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n")
                         _T("%s\n"),
                         LoggerName,
                         Status,
                         DecodeStatus(Status));

                return Status;
            }
            _ftprintf(fp, _T("Logger %s Started...\n"), LoggerName);
            _tprintf(_T("Logger Started...\n"));


        case ACTION_ENABLE:

            if (Action == ACTION_ENABLE) {
                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                {
                    if (GuidCount != 1) {
                       _ftprintf(fp, _T("Need exactly one GUID for PRIVATE loggers\n"));
                        _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                        return 0;
                    }
                    pLoggerInfo->Wnode.Guid = *GuidArray[0];
                }
                Status = QueryTrace( (TRACEHANDLE)0, LoggerName, pLoggerInfo );
                if (Status != ERROR_SUCCESS) {
                    _ftprintf(fp,
                              _T("ERROR: Logger %s not started\nOperation Status= %d, %s"),
                              LoggerName,
                              Status,
                              DecodeStatus(Status));
                    _tprintf( _T("ERROR: Logger not started\n")
                              _T("Operation Status:    %uL\n")
                              _T("%s\n"),
                              Status,
                              DecodeStatus(Status));
                    exit(0);
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            if ((GuidCount > 0) && 
                (!IsEqualGUID(&pLoggerInfo->Wnode.Guid, &SystemTraceControlGuid)))
            {

                _ftprintf(fp, _T("Enabling trace to logger %d\n"), LoggerHandle);
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                for (i = 0; i < GuidCount; i ++) {
                    Status = EnableTrace (
                                    bEnable,
                                    iFlags,
                                    iLevel,
                                    GuidArray[i], 
                                    LoggerHandle);
                    if (Status != ERROR_SUCCESS && Status != 4317) {
                        _ftprintf(fp, _T("ERROR: Failed to enable Guid [%d]...\n Operation Status= %d, %s"), i, Status, DecodeStatus(Status));
                        _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                        _tprintf(_T("Operation Status:       %uL\n"), Status);
                        _tprintf(_T("%s\n"),DecodeStatus(Status));
                        return Status;
                    }
                }
            }
            else {
                if (GuidCount > 0)
                _ftprintf(fp, _T("ERROR: System Logger does not accept application guids...GuidCount=%d\n"), GuidCount);
                    _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
            }
            break;

        case ACTION_STOP :

            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    return 0;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }

            if (!IsEqualGUID(&pLoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
                if ((pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
                    Status = QueryTrace(
                            (TRACEHANDLE) 0, LoggerName, pLoggerInfo);
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
                    Status = EnableTrace( FALSE,
                                          EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                          0,
                                          GuidArray[0],
                                          LoggerHandle );
                }
                else {
                    Status = QueryTrace( (TRACEHANDLE)0, LoggerName, pLoggerInfo );
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;

                    for (i=0; i<GuidCount; i++) {
                        Status = EnableTrace( FALSE,
                                              0,
                                              0,
                                              GuidArray[i],
                                              LoggerHandle);
                    }

                }
            }

            Status = StopTrace((TRACEHANDLE)0, LoggerName, pLoggerInfo);
            break;

        case ACTION_UPDATE :
        case ACTION_QUERY:
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    return 0;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (Action == ACTION_UPDATE)
                Status = UpdateTrace(LoggerHandle, LoggerName, pLoggerInfo);
            else
                Status = QueryTrace(LoggerHandle, LoggerName, pLoggerInfo);

            break;
        case ACTION_LIST :
        {
            ULONG i, returnCount ;
            ULONG SizeNeeded;
            PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
            PEVENT_TRACE_PROPERTIES pStorage;
            PVOID Storage;

            SizeNeeded = MAXIMUM_LOGGERS * (sizeof(EVENT_TRACE_PROPERTIES)
                                          + 2 * MAXSTR * sizeof(TCHAR));

            Storage =  malloc(SizeNeeded);
            if (Storage == NULL)
                return ERROR_OUTOFMEMORY;
            RtlZeroMemory(Storage, SizeNeeded);

            pStorage = (PEVENT_TRACE_PROPERTIES)Storage;
            for (i=0; i<MAXIMUM_LOGGERS; i++) {
                pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                             + 2 * MAXSTR * sizeof(TCHAR);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                            + MAXSTR * sizeof(TCHAR);
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                     (char*)pStorage +
                                      pStorage->Wnode.BufferSize);
            }

            Status = QueryAllTraces(pLoggerInfo,
                                    MAXIMUM_LOGGERS,
                                    & returnCount);

            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    if (bKill)
                    {
                        LPTSTR LoggerName;
                        LoggerName = (LPTSTR) ((char*)pLoggerInfo[j] +
                                      pLoggerInfo[j]->LoggerNameOffset);

                        if (!IsEqualGUID(& pLoggerInfo[j]->Wnode.Guid,
                                         & SystemTraceControlGuid))
                        {
                            LoggerHandle = pLoggerInfo[j]->Wnode.HistoricalContext;
                            Status = EnableTrace(
                                          FALSE,
                                          (pLoggerInfo[j]->LogFileMode &
                                              EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                          ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                          : (0),
                                          0,
                                          & pLoggerInfo[j]->Wnode.Guid,
                                          LoggerHandle);
                        }
                        Status = StopTrace((TRACEHANDLE) 0,
                                            LoggerName,
                                            pLoggerInfo[j]);
                    }
                    PrintLoggerStatus(pLoggerInfo[j], Status);
                }
            }
            else
                printf("Error: Query failed with Status %d\n", Status);

            i = 0;
            free(Storage);

            return 0;
        }
        default :
            Status = QueryTrace(LoggerHandle, LoggerName, pLoggerInfo);
            break;
    }
    PrintLoggerStatus(pLoggerInfo, Status);


    for(i=0;i<(ULONG)targc;i++){
        free(commandLine[i]);
    }
    free(commandLine);
    free(pLoggerInfo);
    free(save);
    _ftprintf(fp, _T("\nEnd evntrace.exe, status = %d, %s\n"), Status, DecodeStatus(Status));
    fclose(fp);

    exit(Status);
}

void
SplitCommandLine( LPTSTR CommandLine, LPTSTR* pArgv )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg); 
        arg = _tcstok(NULL, _T(" \t"));
    }
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    )
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;


    //write to log file
    _ftprintf(fp, _T("Operation Status:       %uL, %s"), Status, DecodeStatus(Status));
    _ftprintf(fp, _T("Logger Name:            %s\n"),
        (LoggerName == NULL) ?
            _T(" ") : LoggerName);
    _ftprintf(fp, _T("Logger Id:              %d\n"), LoggerInfo->Wnode.Linkage);
    _ftprintf(fp, _T("Logger Thread Id:       %d\n"), LoggerInfo->Wnode.ProviderId);
    if (Status != 0)
    {
        _ftprintf(fp, _T("Logger status error: check messages above\n"));
        return;
    }

    _ftprintf(fp, _T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);
    _ftprintf(fp, _T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _ftprintf(fp, _T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _ftprintf(fp, _T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _ftprintf(fp, _T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _ftprintf(fp, _T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten );
    _ftprintf(fp, _T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _ftprintf(fp, _T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost );
    _ftprintf(fp, _T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);

    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _ftprintf(fp, _T("Log File Mode:          Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _ftprintf(fp, _T("Log File Mode:          Sequential\n"));
    }
    else {
        _ftprintf(fp, _T("Log File Mode:          \n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _ftprintf(fp, _T("Real Time mode enabled\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _ftprintf(fp, _T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _ftprintf(fp, _T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
        _ftprintf(fp, _T("Enabled tracing:        Process\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
        _ftprintf(fp, _T("Enabled tracing:        Thread\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
        _ftprintf(fp, _T("Enabled tracing:        ImageLoad\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
        _ftprintf(fp, _T("Enabled tracing:        Disk\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
        _ftprintf(fp, _T("Enabled tracing:        File\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
        _ftprintf(fp, _T("Enabled tracing:        SoftFaults\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
        _ftprintf(fp, _T("Enabled tracing:        HardFaults\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
        _ftprintf(fp, _T("Enabled tracing:        TcpIp\n"));

    _ftprintf(fp, _T("EnableFlags:            0x%08x\n"), LoggerInfo->EnableFlags);

    _ftprintf(fp, _T("Log Filename:           %s\n"),
          (LogFileName == NULL) ?
           _T(" ") : LogFileName);

    _tprintf(_T("Operation Status:       %uL\n"), Status);
    _tprintf(_T("%s\n"), DecodeStatus(Status));

    _tprintf(_T("Logger Name:            %s\n"),
        (LoggerName == NULL) ?
            _T(" ") : LoggerName);
    _tprintf(_T("Logger Id:         %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
    _tprintf(_T("Logger Thread Id:       %d\n"), HandleToUlong(LoggerInfo->LoggerThreadId));
    if (Status != 0)
        return;

    _tprintf(_T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);
    _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
    _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
    _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);

    _tprintf(_T("Log File Mode:          "));
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _tprintf(_T("Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _tprintf(_T("Sequential\n"));
    }
    else {
        _tprintf(_T("\n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _tprintf(_T("Real Time mode enabled\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

    if (LoggerInfo->EnableFlags != 0) {
        _tprintf(_T("Enabled tracing:        "));

        if ((LoggerName != NULL) && (!_tcscmp(LoggerName,NT_LOGGER))) {

            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                _tprintf(_T("Process "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                _tprintf(_T("Thread "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                _tprintf(_T("Disk "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                _tprintf(_T("File "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                _tprintf(_T("PageFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                _tprintf(_T("HardFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                _tprintf(_T("ImageLoad "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                _tprintf(_T("TcpIp "));
        }else{
            _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
        }
        _tprintf(_T("\n"));
    }
    _tprintf(_T("Log Filename:           %s\n"),
          (LogFileName == NULL) ?
              _T(" ") : LogFileName);

}

LPTSTR
DecodeStatus(
    IN ULONG Status
    )
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}

ULONG
GetGuids(LPTSTR GuidFile, LPGUID *GuidArray)
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return 0;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;

        _tcsncpy(arg, line, 8);
        arg[8] = 0;
        Guid->Data1 = ahextoi(arg);
        _tcsncpy(arg, &line[9], 4);
        arg[4] = 0;
        Guid->Data2 = (USHORT) ahextoi(arg);
        _tcsncpy(arg, &line[14], 4);
        arg[4] = 0;
        Guid->Data3 = (USHORT) ahextoi(arg);

        for (i=0; i<2; i++) {
            _tcsncpy(arg, &line[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) {
            _tcsncpy(arg, &line[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
    }
    return (ULONG)n;
}

ULONG ahextoi(TCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void StringToGuid(TCHAR *str, LPGUID guid)
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if directly used more than byte alloc
        guid->Data4[i]=(unsigned char)n;                  // causes overrun of memory
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\dll\tracehw.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracehw.c

Abstract:

    This routine dumps the hardware configuration of the machine to the
    logfile.

Author:

    04-Jul-2000 Melur Raghuraman
    09-Sep-2001 Nitin Choubey

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <mountmgr.h>
#include <winioctl.h>
#include <ntddvol.h>
#include <ntddscsi.h>
#include <regstr.h>
#include <iptypes.h>
#include <ntstatus.h>

#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"

#include <strsafe.h>

extern
PVOID
EtwpGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    );

extern EtwpSetHWConfigFunction(PVOID,ULONG);

__inline ULONG EtwpSetDosError(IN ULONG DosError);

#define EtwpNtStatusToDosError(Status) \
    ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define CPU_ROOT \
    L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor"

#define COMPUTERNAME_VALUE_NAME \
    L"ComputerName"

#define NETWORKCARDS_ROOT \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"

#define MHZ_VALUE_NAME \
    L"~MHz"

#define NIC_VALUE_NAME \
    L"Description"

#define REG_PATH_VIDEO_DEVICE_MAP \
    L"\\Registry\\Machine\\Hardware\\DeviceMap\\Video"

#define REG_PATH_VIDEO_HARDWARE_PROFILE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Control\\Video"

#define REG_PATH_SERVICES \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Video"

typedef BOOL WINAPI T_EnumDisplayDevicesW( LPWSTR lpDevice, 
                                           DWORD iDevNum, 
                                           PDISPLAY_DEVICEW lpDisplayDevice, 
                                           DWORD dwFlags );

typedef DWORD WINAPI T_GetNetworkParams( PFIXED_INFO pFixedInfo, 
                                         PULONG pOutBufLen );

typedef DWORD T_GetAdaptersInfo( PIP_ADAPTER_INFO pAdapterInfo, 
                                 PULONG pOutBufLen );

typedef DWORD T_GetPerAdapterInfo( ULONG IfIndex, 
                                   PIP_PER_ADAPTER_INFO pPerAdapterInfo, 
                                   PULONG pOutBufLen );

extern
NTSTATUS 
EtwpRegOpenKey(
    IN PCWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    );

extern
NTSTATUS
EtwpRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    );


NTSTATUS
EtwpGetCpuSpeed(
    IN DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    )
{
    PWCHAR Buffer = NULL;
    NTSTATUS Status;
    ULONG DataLength;
    DWORD Size;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    HRESULT hr;

    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(Buffer, DEFAULT_ALLOC_SIZE);

    hr = StringCchPrintf(Buffer, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), L"%ws\\%u", CPU_ROOT, *CpuNum);
    if(FAILED(hr)) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Status = EtwpRegOpenKey(Buffer, &Handle);
    if(!NT_SUCCESS(Status)) {
        Handle = INVALID_HANDLE_VALUE;
        goto Cleanup;
    }

    hr = StringCchPrintf(Buffer, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), MHZ_VALUE_NAME);
    if(FAILED(hr)) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Size = sizeof(DWORD);
    Status = EtwpRegQueryValueKey(Handle,
                                  (LPWSTR) Buffer,
                                  Size,
                                  CpuSpeed,
                                  &DataLength);
    
Cleanup:    
    if(!NT_SUCCESS(Status)) {
        *CpuSpeed = 0;
    }

    if(Handle != INVALID_HANDLE_VALUE) {
        NtClose(Handle);
    }
    
    if(Buffer) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }

    return Status;
}

ULONG
EtwpGetCpuConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWCHAR Buffer = NULL;
    PWCHAR ComputerName = NULL;
    ULONG CpuNum;
    ULONG CpuSpeed;
    DWORD Size;
    SYSTEM_INFO SysInfo;
    MEMORYSTATUS MemStatus;
    NTSTATUS Status;
    HANDLE Handle;
    ULONG DataLength;
    ULONG StringSize;
    ULONG SizeNeeded;
    PCPU_CONFIG_RECORD CpuConfig = NULL;
    PFIXED_INFO pFixedInfo = NULL;
    DWORD ErrorCode;
    ULONG NetworkParamsSize;
    T_GetNetworkParams *pfnGetNetworkParams = NULL;
    HINSTANCE hIphlpapiDll = NULL;
    DWORD dwError;
    HRESULT hr;

    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }
    RtlZeroMemory(Buffer, DEFAULT_ALLOC_SIZE);

    Size = StringSize = (MAX_DEVICE_ID_LENGTH) * sizeof (WCHAR);

    ComputerName = RtlAllocateHeap (RtlProcessHeap(),0,Size);
    if(ComputerName == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }
    RtlZeroMemory(ComputerName, Size);

    GlobalMemoryStatus(&MemStatus);


    hr = StringCchPrintf(Buffer, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), COMPUTERNAME_ROOT);
    if(FAILED(hr)) {
        Status = STATUS_UNSUCCESSFUL;
        goto CpuCleanup;
    }

    Status = EtwpRegOpenKey(Buffer, &Handle);

    if (!NT_SUCCESS(Status)) {
        goto CpuCleanup;
    }

    hr = StringCchPrintf(Buffer, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), COMPUTERNAME_VALUE_NAME);
    if(FAILED(hr)) {
        Status = STATUS_UNSUCCESSFUL;
        goto CpuCleanup;
    }

CpuQuery:
    Status = EtwpRegQueryValueKey(Handle,
                               (LPWSTR) Buffer,
                               Size,
                               ComputerName,
                               &StringSize
                               );

    if (!NT_SUCCESS(Status) ) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            RtlFreeHeap (RtlProcessHeap(),0,ComputerName);
            Size = StringSize;
            ComputerName = RtlAllocateHeap (RtlProcessHeap(),0,Size);
            if (ComputerName == NULL) {
                NtClose(Handle);
                Status = STATUS_NO_MEMORY;
                goto CpuCleanup;
            }
            RtlZeroMemory(ComputerName, Size);
            goto CpuQuery;
        }

        NtClose(Handle);
        goto CpuCleanup;
    }

    //
    // Get Architecture Type, Processor Type and Level Stepping...
    //
    CpuNum = 0;
    EtwpGetCpuSpeed(&CpuNum, &CpuSpeed);

    GetSystemInfo(&SysInfo);

    //
    // Get the Hostname and DomainName
    //

    // delay load iphlpapi.lib to Get network params
    hIphlpapiDll = LoadLibraryW(L"iphlpapi.dll");
    if (hIphlpapiDll == NULL) {
       Status = STATUS_DELAY_LOAD_FAILED;
       goto CpuCleanup;
    }
    pfnGetNetworkParams = (T_GetNetworkParams*) GetProcAddress(hIphlpapiDll, "GetNetworkParams");
    if(pfnGetNetworkParams == NULL) {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto CpuCleanup;
    }

    ErrorCode = pfnGetNetworkParams(NULL, &NetworkParamsSize);
    if(ErrorCode != ERROR_BUFFER_OVERFLOW) {
        Status = STATUS_UNSUCCESSFUL;
        goto CpuCleanup;
    }

    pFixedInfo = (PFIXED_INFO)RtlAllocateHeap (RtlProcessHeap(),0,NetworkParamsSize);
    if(pFixedInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }
    RtlZeroMemory(pFixedInfo, NetworkParamsSize);

    ErrorCode = pfnGetNetworkParams(pFixedInfo, &NetworkParamsSize);

    if(ErrorCode != ERROR_SUCCESS) {
        Status = STATUS_UNSUCCESSFUL;
        goto CpuCleanup;
    }

    //
    // Create EventTrace record for CPU configuration and write it
    //

    SizeNeeded = sizeof(CPU_CONFIG_RECORD) + StringSize + (CONFIG_MAX_DOMAIN_NAME_LEN * sizeof(WCHAR));

    CpuConfig = (PCPU_CONFIG_RECORD) EtwpGetTraceBuffer(LoggerContext,
                                                        NULL,
                                                        EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_CPU,
                                                        SizeNeeded);
    if (CpuConfig == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }

    CpuConfig->NumberOfProcessors = SysInfo.dwNumberOfProcessors;
    CpuConfig->ProcessorSpeed = CpuSpeed;
    CpuConfig->MemorySize = (ULONG)(((MemStatus.dwTotalPhys + 512) / 1024) + 512) / 1024;
    CpuConfig->PageSize = SysInfo.dwPageSize;
    CpuConfig->AllocationGranularity = SysInfo.dwAllocationGranularity;

    MultiByteToWideChar(CP_ACP,
                            0,
                            pFixedInfo->DomainName,
                            -1,
                            CpuConfig->DomainName,
                            CONFIG_MAX_DOMAIN_NAME_LEN);

    RtlCopyMemory(&CpuConfig->ComputerName, ComputerName, StringSize);
    CpuConfig->ComputerName[StringSize/2] = 0;

CpuCleanup:
    if (Buffer != NULL) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }
    if (ComputerName != NULL) {
        RtlFreeHeap (RtlProcessHeap(),0,ComputerName);
    }
    if(pFixedInfo) {
        RtlFreeHeap (RtlProcessHeap(),0,pFixedInfo);
    }
    if(hIphlpapiDll) {
        FreeLibrary(hIphlpapiDll);
    }

    return Status;
}


// Function to get logical disk
NTSTATUS
GetIoFixedDrive(
    OUT PLOGICAL_DISK_EXTENTS* ppFdi,
    IN WCHAR* DriveLetterString
    )
{
    DWORD i,dwLastError;
    WCHAR DeviceName[MAXSTR];
    BOOLEAN IsVolume = FALSE;
    PARTITION_INFORMATION_EX PartitionInfo;
    STORAGE_DEVICE_NUMBER StorageDeviceNum;
    HANDLE VolumeHandle;
    ULONG BytesTransferred;     
    WCHAR DriveRootName[CONFIG_DRIVE_LETTER_LEN];
    PLOGICAL_DISK_EXTENTS pFdi = NULL;
    INT FixedDiskInfoSize;
    BOOL bRet;
    DWORD bytes;
    ULONG BufSize;
    CHAR* pBuf = NULL;
    CHAR* pNew = NULL;
    PVOLUME_DISK_EXTENTS pVolExt = NULL;
    PDISK_EXTENT pDiskExt = NULL;
    ULARGE_INTEGER TotalBytes;
    ULARGE_INTEGER TotalFreeBytes;  
    ULARGE_INTEGER FreeBytesToCaller;
    ULONG TotalClusters;
    ULONG TotalFreeClusters;
    PUCHAR VolumeExtPtr = NULL;
    HRESULT hr;

    FixedDiskInfoSize = sizeof(LOGICAL_DISK_EXTENTS);
    //
    // First, we must calculate the size of FixedDiskInfo structure
    // non-partition logical drives have different size
    //
    hr = StringCchPrintf(DeviceName, MAXSTR, L"\\\\.\\%s",DriveLetterString);
    if(FAILED(hr)) {
        return STATUS_UNSUCCESSFUL;
    }

    VolumeHandle = CreateFileW(DeviceName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, // No child process should inherit the handle
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);

    if (VolumeHandle == INVALID_HANDLE_VALUE) {
        dwLastError = GetLastError();
        goto ErrorExit;
    }

    bRet = DeviceIoControl(VolumeHandle,
                           IOCTL_STORAGE_GET_DEVICE_NUMBER,
                           NULL,
                           0,
                           &StorageDeviceNum,
                           sizeof(StorageDeviceNum),
                           &bytes,
                           NULL);
    if (!bRet)
    {
        //
        // This is Volume
        // 
        BufSize = 2048;
        pBuf = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if (pBuf == NULL) {
            dwLastError = GetLastError();
            goto ErrorExit;
        }

        //
        // Well, the drive letter is for a volume.
        //
retry:
        RtlZeroMemory(pBuf, BufSize);
        bRet = DeviceIoControl(VolumeHandle,
                            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                            NULL,
                            0,
                            pBuf,
                            BufSize,
                            &bytes,
                            NULL);

        dwLastError = GetLastError();
        if (!bRet && dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            BufSize = bytes;
            if(pBuf) {
                RtlFreeHeap (RtlProcessHeap(),0,pBuf);
                pBuf = NULL;
            }
            pNew = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
            //
            // We can not reallocate memory, exit.
            //
            if (pNew == NULL){
                dwLastError = GetLastError();
                goto ErrorExit;
            }
            else {
                pBuf = pNew;
            }

            goto retry;
        }

        if (!bRet) {
            goto ErrorExit;
        }
        pVolExt = (PVOLUME_DISK_EXTENTS)pBuf;
        IsVolume=TRUE;
        FixedDiskInfoSize += sizeof(VOLUME_DISK_EXTENTS) + (pVolExt->NumberOfDiskExtents) * sizeof(DISK_EXTENT);
    }

    pFdi = (PLOGICAL_DISK_EXTENTS) RtlAllocateHeap (RtlProcessHeap(),0,FixedDiskInfoSize);
    if (pFdi == NULL) {
       goto ErrorExit;
    }
    RtlZeroMemory(pFdi, FixedDiskInfoSize);
    pFdi->VolumeExt = 0;
    pFdi->Size = FixedDiskInfoSize;

    if (IsVolume) {
        pFdi->DriveType = CONFIG_DRIVE_VOLUME;
        //
        // Volume can span multiple hard disks, so here we set the DriverNumber to -1
        //
        pFdi->DiskNumber = (ULONG)(-1);
        pFdi->PartitionNumber = 1;

        pFdi->VolumeExt= FIELD_OFFSET (LOGICAL_DISK_EXTENTS, VolumeExt);
        VolumeExtPtr = (PUCHAR) OffsetToPtr (pFdi, pFdi->VolumeExt);
        RtlCopyMemory(VolumeExtPtr, 
                      pVolExt,
                      sizeof(VOLUME_DISK_EXTENTS) + (pVolExt->NumberOfDiskExtents) * sizeof(DISK_EXTENT));
    }
    else {
        pFdi->DriveType = CONFIG_DRIVE_PARTITION;
        pFdi->DiskNumber = StorageDeviceNum.DeviceNumber;
        pFdi->PartitionNumber = StorageDeviceNum.PartitionNumber;
    }

    pFdi->DriveLetterString[0] = DriveLetterString[0];
    pFdi->DriveLetterString[1] = DriveLetterString[1];
    pFdi->DriveLetterString[2] = DriveLetterString[2];
    
    DriveRootName[0] = pFdi->DriveLetterString[0];
    DriveRootName[1] = pFdi->DriveLetterString[1];
    DriveRootName[2] = L'\\';
    DriveRootName[3] = UNICODE_NULL; 

    pFdi->SectorsPerCluster = 0;
    pFdi->BytesPerSector = 0;
    pFdi->NumberOfFreeClusters = 0;
    pFdi->TotalNumberOfClusters = 0;

    //
    // Get partition information.
    //
    if ( !DeviceIoControl(VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO_EX,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        dwLastError = GetLastError();
        goto ErrorExit;
    }
    CloseHandle(VolumeHandle);
    VolumeHandle = NULL;
    if (pBuf) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuf);
    }
    pBuf = NULL;

    //
    // Get the information of the logical drive
    //
    if (!GetDiskFreeSpaceW(DriveRootName,
                          &pFdi->SectorsPerCluster,
                          &pFdi->BytesPerSector,
                          &TotalFreeClusters,
                          &TotalClusters)) {

        dwLastError = GetLastError();
        if(dwLastError == ERROR_UNRECOGNIZED_VOLUME) {
            //
            // This could be a partition that has been assigned drive letter but not yet formatted
            //
            pFdi->SectorsPerCluster = 0;
            pFdi->BytesPerSector = 0;

            goto SkipFreeSpace;
        }
        goto ErrorExit;
    }

    if (!GetDiskFreeSpaceExW(DriveRootName,
                            &FreeBytesToCaller,
                            &TotalBytes,
                            &TotalFreeBytes)) {

        dwLastError = GetLastError();
        if(dwLastError == ERROR_UNRECOGNIZED_VOLUME) {
            //
            // This could be a partition that has been assigned drive letter but not yet formatted
            //
            goto SkipFreeSpace;
        }
        goto ErrorExit;
    }

    pFdi->NumberOfFreeClusters = TotalFreeBytes.QuadPart / (pFdi->BytesPerSector * pFdi->SectorsPerCluster);
    pFdi->TotalNumberOfClusters = TotalBytes.QuadPart / (pFdi->BytesPerSector * pFdi->SectorsPerCluster);

SkipFreeSpace:
    pFdi->StartingOffset = PartitionInfo.StartingOffset.QuadPart;
    pFdi->PartitionSize = (ULONGLONG)(((ULONGLONG)pFdi->TotalNumberOfClusters) *
                               ((ULONGLONG)pFdi->SectorsPerCluster) *
                               ((ULONGLONG)pFdi->BytesPerSector));

    //
    // Get the file system type of the logical drive
    //
    if (!GetVolumeInformationW(DriveRootName,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              pFdi->FileSystemType,
                              CONFIG_FS_NAME_LEN
                             ))
    {
        hr = StringCchCopy(pFdi->FileSystemType, CONFIG_FS_NAME_LEN, L"(unknown)");
        if(FAILED(hr)) {
            goto ErrorExit;
        }
    }

    *ppFdi = pFdi;

    if (VolumeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( VolumeHandle );
    }

    return STATUS_SUCCESS;

ErrorExit:

    if (VolumeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( VolumeHandle );
        VolumeHandle = INVALID_HANDLE_VALUE;
    }
    if (pFdi) {
        RtlFreeHeap (RtlProcessHeap(),0,pFdi);
    }
    if (pBuf) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuf);
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
EtwpGetDiskInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PUCHAR Buffer = NULL;
    STORAGE_DEVICE_NUMBER Number;
    PMOUNTMGR_MOUNT_POINTS mountPoints = NULL;
    MOUNTMGR_MOUNT_POINT mountPoint;
    ULONG returnSize, success;
    SYSTEM_DEVICE_INFORMATION DevInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfDisks;
    PWCHAR deviceNameBuffer;
    ULONG i;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatus;

    DISK_GEOMETRY_EX disk_geometryEx;
    PDISK_CACHE_INFORMATION disk_cache = NULL;
    PSCSI_ADDRESS scsi_address = NULL;
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    UNICODE_STRING      UnicodeName;

    PPHYSICAL_DISK_RECORD Disk = NULL;
    PLOGICAL_DISK_EXTENTS pLogicalDisk = NULL;
    PLOGICAL_DISK_EXTENTS pDiskExtents = NULL;
    ULONG SizeNeeded;
    PWCHAR  LogicalDrives = NULL;
    DWORD LogicalDrivesSize = 0;
    LPWSTR Drive = NULL;
    DWORD  Chars;
    ULONG BufferDataLength = 0;
    DWORD dwError;
    HRESULT hr;

    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(Buffer, DEFAULT_ALLOC_SIZE);

    //
    //  Get the Number of Physical Disks
    //

    RtlZeroMemory(&DevInfo, sizeof(DevInfo));

    Status = NtQuerySystemInformation(
                 SystemDeviceInformation,
                 &DevInfo, sizeof (DevInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        goto DiskCleanup;
    }

    NumberOfDisks = DevInfo.NumberOfDisks;

    //
    // Open Each Physical Disk and get Disk Layout information
    //
    for (i=0; i < NumberOfDisks; i++) {

        DISK_CACHE_INFORMATION cacheInfo;
        HANDLE PartitionHandle;
        HANDLE KeyHandle;
        ULONG DataLength;
        WCHAR BootDrive[MAX_PATH];
        WCHAR BootDriveLetter;
        WCHAR  DriveBuffer[MAXSTR];
        PDRIVE_LAYOUT_INFORMATION_EX pDriveLayout = NULL;
        ULONG PartitionCount;
        ULONG j;
        BOOL bSuccess = FALSE;
        DWORD BufSize;
        ULONG Size = DEFAULT_ALLOC_SIZE;
        BOOL bValidDiskCacheInfo = FALSE;

        RtlZeroMemory(&disk_geometryEx, sizeof(DISK_GEOMETRY_EX));        
        RtlZeroMemory(&cacheInfo, sizeof(DISK_CACHE_INFORMATION));
        PartitionCount = 0;
        BootDriveLetter = UNICODE_NULL;

        //
        // Get Boot Drive Letter
        //
        if(GetSystemDirectoryW(BootDrive, MAX_PATH)) {
            BootDriveLetter = BootDrive[0];
        }

        hr = StringCchPrintf(DriveBuffer, MAXSTR, L"\\\\.\\PhysicalDrive%d", i);
        if(FAILED(hr)) {
            Status = STATUS_UNSUCCESSFUL;
            goto DiskCleanup;
        }

        hDisk = CreateFileW(DriveBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, // No child process should inherit the handle
                       OPEN_EXISTING,
                       0,
                       NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            goto DiskCleanup;
        }

        //
        // Get Partition0 handle to get the Disk layout 
        //
        deviceNameBuffer = (PWCHAR) Buffer;
        hr = StringCchPrintf(deviceNameBuffer, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), L"\\Device\\Harddisk%d\\Partition0", i);
        if(FAILED(hr)) {
            Status = STATUS_UNSUCCESSFUL;
            goto DiskCleanup;
        }

        RtlInitUnicodeString(&UnicodeName, deviceNameBuffer);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        Status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );

        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        //
        // Get geomerty information
        //
        Status = NtDeviceIoControlFile(PartitionHandle,
                       0,
                       NULL,
                       NULL,
                       &IoStatus,
                       IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                       NULL,
                       0,
                       &disk_geometryEx,
                       sizeof (DISK_GEOMETRY_EX)
                       );
        
        if (!NT_SUCCESS(Status)) {
            RtlZeroMemory(&disk_geometryEx, sizeof(DISK_GEOMETRY_EX));
            NtClose(PartitionHandle);
            goto SkipPartition;
        }

        //
        // Get the scci information
        //
        scsi_address = (PSCSI_ADDRESS) Buffer;
        Status = NtDeviceIoControlFile(PartitionHandle,
                        0,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_SCSI_GET_ADDRESS,
                        NULL,
                        0,
                        scsi_address,
                        sizeof (SCSI_ADDRESS)
                        );
        NtClose(PartitionHandle);

        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        //
        // Get Manufacturer's name from Registry
        // We need to get the SCSI Address and then query the Registry with it.
        //
        hr = StringCchPrintf(DriveBuffer, MAXSTR,
                 L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                 scsi_address->PortNumber, scsi_address->PathId, scsi_address->TargetId, scsi_address->Lun
                );
        if(FAILED(hr)) {
            Status = STATUS_UNSUCCESSFUL;
            goto DiskCleanup;
        }

        Status = EtwpRegOpenKey(DriveBuffer, &KeyHandle);
        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        Size = DEFAULT_ALLOC_SIZE;
        RtlZeroMemory(Buffer, Size);
DiskQuery:
        Status = EtwpRegQueryValueKey(KeyHandle,
                                      L"Identifier",
                                      Size,
                                      Buffer,
                                      &BufferDataLength);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            RtlFreeHeap (RtlProcessHeap(),0,Buffer);
            Buffer = RtlAllocateHeap (RtlProcessHeap(),0,BufferDataLength);
            if (Buffer == NULL) {
                NtClose(KeyHandle);
                Status = STATUS_NO_MEMORY;
                goto DiskCleanup;
            }
            RtlZeroMemory(Buffer, BufferDataLength);
            goto DiskQuery;
        }

        NtClose(KeyHandle);
        if (!NT_SUCCESS(Status) ) {
            goto DiskCleanup;
        }

        //
        // Get the total partitions on the drive
        //
        BufSize = 2048;
        pDriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if(pDriveLayout == NULL) {
            goto DiskCleanup;
        }
        RtlZeroMemory(pDriveLayout, BufSize);
        bSuccess = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                            NULL,
                            0,
                            pDriveLayout,
                            BufSize,
                            &DataLength,
                            NULL
                            );
        if(bSuccess == FALSE && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        BufSize = DataLength;
        if(pDriveLayout) {
            RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
        }
        pDriveLayout = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if(pDriveLayout == NULL) {
            Status = STATUS_NO_MEMORY;
            goto DiskCleanup;
        }
        else {
            RtlZeroMemory(pDriveLayout, BufSize);
            bSuccess = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                            NULL,
                            0,
                            pDriveLayout,
                            BufSize,
                            &DataLength,
                            NULL
                            );
            }
        }

        if(bSuccess == FALSE) {
            //
            // If media type is not fixed media and device is not ready then dont query partition info.
            //
            if(disk_geometryEx.Geometry.MediaType != FixedMedia && GetLastError() == ERROR_NOT_READY) {
                goto SkipPartition;
            }

            if(pDriveLayout) {
                RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
                pDriveLayout = NULL;
            }
            continue;
        }

        //
        // Get Partition count for the current disk
        //
        PartitionCount = 0;
        j = 0;
        while (j < pDriveLayout->PartitionCount) {
            if (pDriveLayout->PartitionEntry[j].PartitionNumber != 0) {
                PartitionCount++;
            }
            j++;
        }

        //
        // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
        //
        bValidDiskCacheInfo = DeviceIoControl(hDisk,
                                              IOCTL_DISK_GET_CACHE_INFORMATION,
                                              NULL,
                                              0,
                                              &cacheInfo,
                                              sizeof(DISK_CACHE_INFORMATION),
                                              &DataLength,
                                              NULL);

        NtClose(hDisk);
        hDisk = INVALID_HANDLE_VALUE;

        //
        // Free drivelayout structure
        //
        if(pDriveLayout) {
            RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
            pDriveLayout = NULL;
        }

SkipPartition:

        //
        // Package all information about this disk and write an event record
        //

        SizeNeeded = sizeof(PHYSICAL_DISK_RECORD) + BufferDataLength;

        Disk = (PPHYSICAL_DISK_RECORD) EtwpGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK,
                                                           SizeNeeded);

        if (Disk == NULL) {
            Status = STATUS_NO_MEMORY;
            goto DiskCleanup;
        }

        Disk->DiskNumber =  i;

        Disk->BytesPerSector    = disk_geometryEx.Geometry.BytesPerSector;
        Disk->SectorsPerTrack   = disk_geometryEx.Geometry.SectorsPerTrack;
        Disk->TracksPerCylinder = disk_geometryEx.Geometry.TracksPerCylinder;
        Disk->Cylinders         = disk_geometryEx.Geometry.Cylinders.QuadPart;

        if(scsi_address) {
            Disk->SCSIPortNumber = scsi_address->PortNumber;
            Disk->SCSIPathId = scsi_address->PathId;
            Disk->SCSITargetId = scsi_address->TargetId;
            Disk->SCSILun = scsi_address->Lun;
        }
        else {
            Disk->SCSIPortNumber = 0;
            Disk->SCSIPathId = 0;
            Disk->SCSITargetId = 0;
            Disk->SCSILun = 0;
        }
        Disk->BootDriveLetter[0] = BootDriveLetter;
        if (bValidDiskCacheInfo && cacheInfo.WriteCacheEnabled) {
            Disk->WriteCacheEnabled = TRUE;
        }
        Disk->PartitionCount = PartitionCount;
        if(BufferDataLength > MAX_DEVICE_ID_LENGTH*sizeof(WCHAR)) BufferDataLength = MAX_DEVICE_ID_LENGTH * sizeof(WCHAR);
        RtlCopyMemory(Disk->Manufacturer, Buffer, BufferDataLength);
        Disk->Manufacturer[BufferDataLength/2] = 0;
    }

    //
    // Retrieve the logical drive strings from the system.
    //
    LogicalDrivesSize = MAX_PATH * sizeof(WCHAR);

DriveTry:
    LogicalDrives = RtlAllocateHeap (RtlProcessHeap(),0,LogicalDrivesSize);
    if(LogicalDrives == NULL) {
        Status = STATUS_NO_MEMORY;
        goto DiskCleanup;
    }
    RtlZeroMemory(LogicalDrives, LogicalDrivesSize);

    Chars = GetLogicalDriveStringsW(LogicalDrivesSize / sizeof(WCHAR), LogicalDrives);

    if(Chars > LogicalDrivesSize) {
        RtlFreeHeap (RtlProcessHeap(),0,LogicalDrives);
        LogicalDrivesSize = Chars;
        goto DriveTry;
    }
    else if(Chars == 0) {
        RtlFreeHeap (RtlProcessHeap(),0,LogicalDrives);
        Status = STATUS_UNSUCCESSFUL;
        goto DiskCleanup;
    }

    Drive = LogicalDrives;
   
    //
    // How many logical drives in physical disks exist?
    //
    while ( *Drive ) {
        WCHAR  DriveLetter[CONFIG_BOOT_DRIVE_LEN];
        size_t DriveTypeLength;

        DriveLetter[ 0 ] = Drive [ 0 ];
        DriveLetter[ 1 ] = Drive [ 1 ];
        DriveLetter[ 2 ] = UNICODE_NULL;

        if(GetDriveTypeW( Drive ) == DRIVE_FIXED) {
            //
            // If this is a logical drive which resides in a hard disk
            // we need to allocate a FixedDiskInfo structure for it.
            //
            if(GetIoFixedDrive(&pLogicalDisk, DriveLetter) == STATUS_SUCCESS) {
                SizeNeeded = pLogicalDisk->Size;

                //
                // Package all information about this disk and write an event record
                //
                pDiskExtents = (PLOGICAL_DISK_EXTENTS) EtwpGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_LOGICALDISK,
                                                           SizeNeeded);
                if(pDiskExtents == NULL) {
                    RtlFreeHeap (RtlProcessHeap(),0,pLogicalDisk);
                    pLogicalDisk = NULL;
                    Status = STATUS_NO_MEMORY;
                    goto DiskCleanup;
                }
                
                RtlCopyMemory(pDiskExtents, pLogicalDisk, SizeNeeded);
                RtlFreeHeap (RtlProcessHeap(),0,pLogicalDisk);
                pLogicalDisk = NULL;
            }
        }

        hr = StringCchLength(Drive, LogicalDrivesSize/sizeof(WCHAR), &DriveTypeLength);
        if(FAILED(hr)) {
            Status = STATUS_UNSUCCESSFUL;
            goto DiskCleanup;
        }
        Drive += (DriveTypeLength + 1);
        LogicalDrivesSize -= (DriveTypeLength+1) * sizeof(WCHAR);
    }

DiskCleanup:
    if (Buffer != NULL) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }
    if(hDisk != INVALID_HANDLE_VALUE) {
        NtClose(hDisk);
    }

    return Status;
}


NTSTATUS
EtwpGetVideoAdapters(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PVIDEO_RECORD Video = NULL;
    VIDEO_RECORD VideoRecord;
    HANDLE hVideoDeviceMap;
    HANDLE hVideoDriver;
    HANDLE hHardwareProfile;
    ULONG DeviceId = 0;
    PWCHAR Device = NULL;
    PWCHAR HardwareProfile = NULL;
    PWCHAR Driver = NULL;
    PWCHAR Buffer = NULL;
    PWCHAR DriverRegistryPath = NULL;

    ULONG ResultLength;
    PCHAR ValueBuffer = NULL;
    ULONG Length;
    BOOLEAN IsAdapter;
    ULONG SizeNeeded;
    NTSTATUS Status;
    INT i;

    DWORD iDevice = 0;
    DISPLAY_DEVICEW dd;
    HINSTANCE hUser32Dll  = NULL;
    T_EnumDisplayDevicesW *pfnEnumDisplayDevicesW = NULL;

    LPWSTR ChipsetInfo[6] = {
        L"HardwareInformation.MemorySize",
        L"HardwareInformation.ChipType",
        L"HardwareInformation.DacType",
        L"HardwareInformation.AdapterString",
        L"HardwareInformation.BiosString",
        L"Device Description"
    };

    LPWSTR SettingInfo[4] = {
        L"DefaultSettings.BitsPerPel",
        L"DefaultSettings.VRefresh",
        L"DefaultSettings.XResolution",
        L"DefaultSettings.YResolution",
    };

    HRESULT hr;

    //
    // delay load user32.lib to enum display devices function
    //
    hUser32Dll = LoadLibraryW(L"user32.dll");
    if (hUser32Dll == NULL) {
        return STATUS_DELAY_LOAD_FAILED; 
    }

    RtlZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);

    //
    // Enumerate all the video devices in the system
    //
    Status = EtwpRegOpenKey(REG_PATH_VIDEO_DEVICE_MAP, &hVideoDeviceMap);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Allocate memory for local variables on heap
    //
    Device = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    if(Device == NULL) {
        Status = STATUS_NO_MEMORY;
        goto VideoCleanup;
    }
    RtlZeroMemory(Device, DEFAULT_ALLOC_SIZE);

    HardwareProfile = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    if(HardwareProfile == NULL) {
        Status = STATUS_NO_MEMORY;
        goto VideoCleanup;
    }
    RtlZeroMemory(HardwareProfile, DEFAULT_ALLOC_SIZE);

    Driver = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    if(Driver == NULL) {
        Status = STATUS_NO_MEMORY;
        goto VideoCleanup;
    }
    RtlZeroMemory(Driver, DEFAULT_ALLOC_SIZE);

    Buffer = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    if(Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto VideoCleanup;
    }
    RtlZeroMemory(Buffer, DEFAULT_ALLOC_SIZE);

    while (TRUE) {
        RtlZeroMemory(&VideoRecord, sizeof(VideoRecord));

        //
        // Open video device
        //
        hr = StringCchPrintf(Device, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), L"\\Device\\Video%d", DeviceId++);
        if(FAILED(hr)) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Status = EtwpRegQueryValueKey(hVideoDeviceMap,
                    Device,
                    DEFAULT_ALLOC_SIZE,
                    Buffer,
                    &ResultLength
                    );

        if (!NT_SUCCESS(Status)) {
            Status = STATUS_SUCCESS;
            break;
        }

        //
        // Open the driver registry key
        //
        Status = EtwpRegOpenKey(Buffer, &hVideoDriver);
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        //
        // Get Video adapter information.
        //
        IsAdapter = TRUE;
        for (i = 0; i < 6; i++) {
            switch (i ) {
                case 0:
                    ValueBuffer = (PCHAR)&VideoRecord.MemorySize;
                    Length = sizeof(VideoRecord.MemorySize);
                    break;

                case 1:
                    ValueBuffer = (PCHAR)&VideoRecord.ChipType;
                    Length = sizeof(VideoRecord.ChipType);
                    break;

                case 2:
                    ValueBuffer = (PCHAR)&VideoRecord.DACType;
                    Length = sizeof(VideoRecord.DACType);
                    break;

                case 3:
                    ValueBuffer = (PCHAR)&VideoRecord.AdapterString;
                    Length = sizeof(VideoRecord.AdapterString);
                    break;

                case 4:
                    ValueBuffer = (PCHAR)&VideoRecord.BiosString;
                    Length = sizeof(VideoRecord.BiosString);
                    break;

                case 5:
                    ValueBuffer = (PCHAR)&VideoRecord.DeviceId;
                    Length = sizeof(VideoRecord.DeviceId);
                    break;
            }

            //
            // Query the size of the data
            //
            Status = EtwpRegQueryValueKey(hVideoDriver,
                                    ChipsetInfo[i],
                                    Length,
                                    ValueBuffer,
                                    &ResultLength);
            //
            // If we can not get the hardware information, this
            // is  not adapter
            //
            if (!NT_SUCCESS(Status)) {
                IsAdapter = FALSE;
                break;
            }
        }
        
        NtClose(hVideoDriver);
        if (IsAdapter == FALSE) {
            continue;
        }

        DriverRegistryPath = wcsstr(Buffer, L"{");
        if(DriverRegistryPath == NULL) {
            continue;
        }

        hr = StringCchPrintf(HardwareProfile, DEFAULT_ALLOC_SIZE/sizeof(WCHAR), L"%s\\%s", REG_PATH_VIDEO_HARDWARE_PROFILE, DriverRegistryPath);
        if(FAILED(hr)) {
            continue;
        }

        Status = EtwpRegOpenKey(HardwareProfile, &hHardwareProfile);
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        for (i = 0; i < 4; i++) {
            switch (i ) {
                case 0:
                    ValueBuffer = (PCHAR)&VideoRecord.BitsPerPixel;
                    Length = sizeof(VideoRecord.BitsPerPixel);
                    break;

                case 1:
                    ValueBuffer = (PCHAR)&VideoRecord.VRefresh;
                    Length = sizeof(VideoRecord.VRefresh);
                    break;

                case 2:
                    ValueBuffer = (PCHAR)&VideoRecord.XResolution;
                    Length = sizeof(VideoRecord.XResolution);
                    break;

                case 3:
                    ValueBuffer = (PCHAR)&VideoRecord.YResolution;
                    Length = sizeof(VideoRecord.YResolution);
                    break;
            }

            //
            // Query the size of the data
            //
            Status = EtwpRegQueryValueKey(hHardwareProfile,
                                    SettingInfo[i],
                                    Length,
                                    ValueBuffer,
                                    &ResultLength);
        }

        NtClose(hHardwareProfile);

        //
        // Enum display devices
        //
        pfnEnumDisplayDevicesW = (T_EnumDisplayDevicesW *) GetProcAddress(hUser32Dll, "EnumDisplayDevicesW");
        if(pfnEnumDisplayDevicesW == NULL) {
            Status = STATUS_PROCEDURE_NOT_FOUND;
            break;
        }

        while (pfnEnumDisplayDevicesW(NULL, iDevice++, &dd, 0)) {    
            if (_wcsicmp(VideoRecord.DeviceId, dd.DeviceString) == 0) {
                if (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {
                    VideoRecord.StateFlags = (ULONG)dd.StateFlags;
                }
                break;
                iDevice = 0;
            }
       }

        //
        // Package all information about this disk and write an event record
        //

        SizeNeeded = sizeof(VIDEO_RECORD);

        Video = (PVIDEO_RECORD) EtwpGetTraceBuffer( LoggerContext,
                                                   NULL,
                                                   EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_VIDEO,
                                                   SizeNeeded);

        if (Video == NULL) {
            Status = STATUS_NO_MEMORY;
            break;
        }
        RtlCopyMemory(Video, &VideoRecord, sizeof(VIDEO_RECORD));
    }

VideoCleanup:
    NtClose(hVideoDeviceMap);
    if (hUser32Dll) {
        FreeLibrary(hUser32Dll);
    }

    //
    // Free local variables allocated on heap
    //
    if(Device) {
        RtlFreeHeap (RtlProcessHeap(), 0, Device);
    }

    if(HardwareProfile) {
        RtlFreeHeap (RtlProcessHeap(), 0, HardwareProfile);
    }
    
    if(Driver) {
        RtlFreeHeap (RtlProcessHeap(), 0, Driver);
    }

    if(Buffer) {
        RtlFreeHeap (RtlProcessHeap(), 0, Buffer);
    }

    return Status;
}



NTSTATUS 
EtwpGetNetworkAdapters(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    DWORD  IfNum;
    DWORD  Ret;
    PIP_ADAPTER_INFO pAdapterList = NULL, pAdapterListHead = NULL;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    PFIXED_INFO pFixedInfo = NULL;
    PIP_ADDR_STRING pIpAddressList = NULL;
    ULONG OutBufLen = 0;
    INT i;
    NIC_RECORD AdapterInfo;
    PNIC_RECORD pAdapterInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    INT IpAddrLen = 0;
    T_GetAdaptersInfo *pfnGetAdaptersInfo = NULL;
    T_GetPerAdapterInfo *pfnGetPerAdapterInfo = NULL;
    HINSTANCE hIphlpapiDll = NULL;
    PUCHAR IpDataPtr = NULL;

    // delay load iphlpapi.lib to Get network params
    hIphlpapiDll = LoadLibraryW(L"iphlpapi.dll");
    if (hIphlpapiDll == NULL) {
        Status = STATUS_DELAY_LOAD_FAILED;
        goto IpCleanup;
    }
    pfnGetAdaptersInfo = (T_GetAdaptersInfo*) GetProcAddress(hIphlpapiDll, "GetAdaptersInfo");
    if(pfnGetAdaptersInfo == NULL) {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto IpCleanup;
    }
    
    pfnGetPerAdapterInfo = (T_GetPerAdapterInfo*) GetProcAddress(hIphlpapiDll, "GetPerAdapterInfo");
    if(pfnGetPerAdapterInfo == NULL) {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto IpCleanup;
    }

    //
    // Get number of adapters
    //
    Ret = pfnGetAdaptersInfo(NULL, &OutBufLen);
    if(Ret != ERROR_BUFFER_OVERFLOW) {
        Status = STATUS_UNSUCCESSFUL;
        goto IpCleanup;
    }

TryAgain:
    pAdapterList = (PIP_ADAPTER_INFO)RtlAllocateHeap (RtlProcessHeap(),0,OutBufLen);
    if (pAdapterList == NULL) {
        Status = STATUS_NO_MEMORY;
        goto IpCleanup;
    }
    RtlZeroMemory(pAdapterList, OutBufLen);

    Ret = pfnGetAdaptersInfo(pAdapterList, &OutBufLen);
    if(Ret != ERROR_SUCCESS) {
        if (Ret == ERROR_BUFFER_OVERFLOW) {
            RtlFreeHeap (RtlProcessHeap(),0,pAdapterList);
            goto TryAgain;
        }
        if (pAdapterList != NULL) {
            RtlFreeHeap (RtlProcessHeap(),0,pAdapterList);
        }
        Status = STATUS_UNSUCCESSFUL;
        goto IpCleanup;
    }

    //
    // Calculate the total length for all the IP Addresses
    //
    IpAddrLen = sizeof(IP_ADDRESS_STRING) * CONFIG_MAX_DNS_SERVER; // Length of 4 DNS Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of IP Mask
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of DHCP Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Gateway IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Primary Wins Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Secondary Wins Server IP Address

    //
    // Allocate memory for NIC_RECORD
    //
    RtlZeroMemory(&AdapterInfo, sizeof(AdapterInfo));

    //
    // Fill out the information per adapter
    //
    pAdapterListHead = pAdapterList;
    while (pAdapterList ) {
        MultiByteToWideChar(CP_ACP,
                            0,
                            (LPCSTR)pAdapterList->Description,
                            -1,
                            (LPWSTR)AdapterInfo.NICName,
                            MAX_DEVICE_ID_LENGTH);

        AdapterInfo.Index = (ULONG)pAdapterList->Index;

        //
        // Copy the Physical address of NIC
        //
        AdapterInfo.PhysicalAddrLen = pAdapterList->AddressLength;
        RtlCopyMemory(AdapterInfo.PhysicalAddr, pAdapterList->Address, pAdapterList->AddressLength);

        //
        // Set the size of the Data
        //
        AdapterInfo.Size = IpAddrLen;

        //
        // Get DNS server list for this adapter
        // 
        Ret = pfnGetPerAdapterInfo(pAdapterList->Index, NULL, &OutBufLen);
        if(Ret != ERROR_BUFFER_OVERFLOW) {
            Status = STATUS_UNSUCCESSFUL;
            goto IpCleanup;
        }

        pPerAdapterInfo = (PIP_PER_ADAPTER_INFO)RtlAllocateHeap (RtlProcessHeap(),0,OutBufLen);
        if (!pPerAdapterInfo) {
            Status = STATUS_NO_MEMORY;
            goto IpCleanup;
        }
        RtlZeroMemory(pPerAdapterInfo, OutBufLen);

        Ret = pfnGetPerAdapterInfo(pAdapterList->Index, pPerAdapterInfo, &OutBufLen);
        if(Ret != ERROR_SUCCESS) {
            Status = STATUS_UNSUCCESSFUL;
            goto IpCleanup;
        }

        //
        // Package all information about this NIC and write an event record
        //
        pAdapterInfo = (PNIC_RECORD) EtwpGetTraceBuffer( LoggerContext,
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_NIC,
                                                           sizeof(NIC_RECORD) + IpAddrLen);

        
        if(!pAdapterInfo) {
            Status = STATUS_NO_MEMORY;
            goto IpCleanup;
        }

        RtlCopyMemory(pAdapterInfo, 
                      &AdapterInfo, 
                      sizeof(NIC_RECORD));

        //
        // Copy the IP Address and Subnet mask
        //
        if (pAdapterList->CurrentIpAddress) {
            pAdapterInfo->IpAddress = FIELD_OFFSET(NIC_RECORD, Data);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->IpAddress), 
                          &(pAdapterList->CurrentIpAddress->IpAddress), 
                          sizeof(IP_ADDRESS_STRING));

            pAdapterInfo->SubnetMask = pAdapterInfo->IpAddress + sizeof(IP_ADDRESS_STRING);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SubnetMask), 
                          &(pAdapterList->CurrentIpAddress->IpMask), 
                          sizeof(IP_ADDRESS_STRING));
        }
        else {
            pAdapterInfo->IpAddress = FIELD_OFFSET(NIC_RECORD, Data);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->IpAddress), 
                          &(pAdapterList->IpAddressList.IpAddress), 
                          sizeof(IP_ADDRESS_STRING));

            pAdapterInfo->SubnetMask = pAdapterInfo->IpAddress + sizeof(IP_ADDRESS_STRING);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SubnetMask), 
                          &(pAdapterList->IpAddressList.IpMask), 
                          sizeof(IP_ADDRESS_STRING));
        }

        //
        // Copy the Dhcp Server IP Address
        //
        pAdapterInfo->DhcpServer = pAdapterInfo->SubnetMask + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->DhcpServer), 
                      &(pAdapterList->DhcpServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Gateway IP Address
        //
        pAdapterInfo->Gateway = pAdapterInfo->DhcpServer + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->Gateway), 
                      &(pAdapterList->GatewayList.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Primary Wins Server IP Address
        //
        pAdapterInfo->PrimaryWinsServer = pAdapterInfo->Gateway + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->PrimaryWinsServer), 
                      &(pAdapterList->PrimaryWinsServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Secondary Wins Server IP Address
        //
        pAdapterInfo->SecondaryWinsServer = pAdapterInfo->PrimaryWinsServer + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SecondaryWinsServer),
                      &(pAdapterList->SecondaryWinsServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));
        
        //
        // Hardcoded entries for DNS server(limited upto 4);
        //
        pIpAddressList = &pPerAdapterInfo->DnsServerList;
        pAdapterInfo->DnsServer[0] = pAdapterInfo->SecondaryWinsServer + sizeof(IP_ADDRESS_STRING);
        for (i = 0; pIpAddressList && i < CONFIG_MAX_DNS_SERVER; i++) {

            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->DnsServer[i]), 
                          &(pIpAddressList->IpAddress), 
                          sizeof(IP_ADDRESS_STRING));
            
            if(i < CONFIG_MAX_DNS_SERVER - 1) {
                pAdapterInfo->DnsServer[i + 1] = pAdapterInfo->DnsServer[i] + sizeof(IP_ADDRESS_STRING);
            }

            pIpAddressList = pIpAddressList->Next;
        }

        //
        // Free the DNS server list
        //
        RtlFreeHeap (RtlProcessHeap(),0,pPerAdapterInfo);
        pPerAdapterInfo = NULL;

        //
        // increment the AdapterInfo buffer position for next record
        //
        pAdapterList = pAdapterList->Next;
    }

IpCleanup:
    if (pAdapterListHead) {
        RtlFreeHeap (RtlProcessHeap(),0,pAdapterListHead);
    }

    if(pPerAdapterInfo) {
        RtlFreeHeap(RtlProcessHeap(),0,pPerAdapterInfo);
    }

    if(hIphlpapiDll) {
        FreeLibrary(hIphlpapiDll);
    }

    return Status;
}


NTSTATUS 
EtwpGetServiceInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    DWORD dwServicesNum = 0;
    SC_HANDLE hScm = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSYSTEM_PROCESS_INFORMATION pProcInfo = NULL;
    PSYSTEM_PROCESS_INFORMATION ppProcInfo = NULL;
    PUCHAR pBuffer = NULL;
    ULONG ulBufferSize = 16 * DEFAULT_ALLOC_SIZE;
    ULONG TotalOffset;
    ULONG TotalTasks = 0;
    ULONG j;
    ULONG ulReturnedLength = 0;
    HRESULT hr;

    //
    // Allocate memory for process Info
    //
retry:

    pBuffer = RtlAllocateHeap (RtlProcessHeap(),0,ulBufferSize);
    if(pBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(pBuffer, ulBufferSize);

    //
    // Query process Info
    //
    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                pBuffer,
                ulBufferSize,
                &ulReturnedLength
                );

    if(!NT_SUCCESS(Status)) {
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ulBufferSize = ulReturnedLength;
            RtlFreeHeap (RtlProcessHeap(),0,pBuffer);
            pBuffer = NULL;
            goto retry;
        }

        goto ServiceCleanup;
    }
    
    pProcInfo = (PSYSTEM_PROCESS_INFORMATION) pBuffer;

    //
    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE
                );

    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESSW pInfo    = NULL;
        LPENUM_SERVICE_STATUS_PROCESSW ppInfo   = NULL;
        DWORD                         cbInfo   = DEFAULT_ALLOC_SIZE;
        DWORD                         dwErr    = ERROR_SUCCESS;
        DWORD                         dwResume = 0;
        DWORD                         cLoop    = 0;
        const DWORD                   cLoopMax = 2;
        WMI_SERVICE_INFO              ServiceInfo;
        PWMI_SERVICE_INFO             pServiceInfo = NULL;
        SERVICE_STATUS_PROCESS        ServiceProcess;
        PWCHAR p = NULL;
        DWORD dwRemainBytes;

        //
        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {
            if (pInfo) {
                RtlFreeHeap (RtlProcessHeap(),0,pInfo);
            }
            pInfo = (LPENUM_SERVICE_STATUS_PROCESSW)RtlAllocateHeap (RtlProcessHeap(),0,cbInfo);
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(pInfo, cbInfo);

            dwErr = ERROR_SUCCESS;
            if (!EnumServicesStatusExW(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (PBYTE)pInfo,
                    cbInfo,
                    &dwRemainBytes,
                    &dwServicesNum,
                    &dwResume,
                    NULL)) 
            {
                dwErr = GetLastError();
                cbInfo += dwRemainBytes;
                dwResume = 0;
            }
        } while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwServicesNum) {
            //
            // Process each service and send an event
            //
            ppInfo = pInfo;
            Status = STATUS_SUCCESS;
            while(dwServicesNum) {

                RtlZeroMemory(&ServiceInfo, sizeof(WMI_SERVICE_INFO));

                hr = StringCchCopy(ServiceInfo.ServiceName, CONFIG_MAX_NAME_LENGTH, ppInfo->lpServiceName);
                if(FAILED(hr)) {
                    Status = STATUS_UNSUCCESSFUL;
                    goto ServiceCleanup;
                }
                hr = StringCchCopy(ServiceInfo.DisplayName, CONFIG_MAX_DISPLAY_NAME, ppInfo->lpDisplayName);
                if(FAILED(hr)) {
                    Status = STATUS_UNSUCCESSFUL;
                    goto ServiceCleanup;
                }

                ServiceInfo.ProcessId = ppInfo->ServiceStatusProcess.dwProcessId;

                //
                // Get the process name
                //
                ppProcInfo = pProcInfo;
                TotalOffset = 0;
                while(TRUE) {
                    if((DWORD)(DWORD_PTR)ppProcInfo->UniqueProcessId == ServiceInfo.ProcessId) {
                        if(ppProcInfo->ImageName.Buffer) {
                            p = wcschr(ppProcInfo->ImageName.Buffer, L'\\');
                            if ( p ) {
                                p++;
                            } else {
                                p = ppProcInfo->ImageName.Buffer;
                            }
                        }
                        else {
                            p = L"System Process";
                        }
                        hr = StringCchCopy(ServiceInfo.ProcessName, CONFIG_MAX_NAME_LENGTH, p);
                        if(FAILED(hr)) {
                            Status = STATUS_UNSUCCESSFUL;
                            goto ServiceCleanup;
                        }
                    }
                    if (ppProcInfo->NextEntryOffset == 0) {
                        break;
                    }
                    TotalOffset += ppProcInfo->NextEntryOffset;
                    ppProcInfo   = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)pProcInfo+TotalOffset);
                }

                //
                // Package all information about this NIC and write an event record
                //
                pServiceInfo = NULL;
                pServiceInfo = (PWMI_SERVICE_INFO) EtwpGetTraceBuffer( LoggerContext,
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_SERVICES,
                                                           sizeof(WMI_SERVICE_INFO));
                if(pServiceInfo == NULL) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                RtlCopyMemory(pServiceInfo, &ServiceInfo, sizeof(WMI_SERVICE_INFO));

                dwServicesNum--;
                ppInfo++;
            }
        }

        if (pInfo) {
            RtlFreeHeap (RtlProcessHeap(),0,pInfo);
        }

        CloseServiceHandle(hScm);
    }

ServiceCleanup:
    if(pBuffer) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuffer);
    }

    return Status;
}

NTSTATUS
EtwpGetPowerInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status;
    SYSTEM_POWER_CAPABILITIES Cap;
    WMI_POWER_RECORD Power;
    PWMI_POWER_RECORD pPower = NULL;

    RtlZeroMemory(&Power, sizeof(WMI_POWER_RECORD));

    Status = NtPowerInformation (SystemPowerCapabilities,
                                 NULL,
                                 0,
                                 &Cap,
                                 sizeof (Cap));
    if(!NT_SUCCESS(Status)) {
        Status = STATUS_UNSUCCESSFUL;
        goto PowerCleanup;
    }

    Power.SystemS1 = Cap.SystemS1;
    Power.SystemS2 = Cap.SystemS2;
    Power.SystemS3 = Cap.SystemS3;
    Power.SystemS4 = Cap.SystemS4;
    Power.SystemS5 = Cap.SystemS5;

    //
    // Package all Power information and write an event record
    //
    pPower = (PWMI_POWER_RECORD) EtwpGetTraceBuffer(LoggerContext,
                                                    NULL,
                                                    EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_POWER,
                                                    sizeof(WMI_POWER_RECORD));


    if(!pPower) {
        Status = STATUS_NO_MEMORY;
        goto PowerCleanup;
    }

    RtlCopyMemory(pPower,
                  &Power,
                  sizeof(WMI_POWER_RECORD));

PowerCleanup:
    return Status;
}

//
// This routine records the hardware configuration in the
// logfile during RunDown
//

ULONG
EtwpDumpHardwareConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    Status = EtwpGetCpuConfig(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    Status = EtwpGetVideoAdapters(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    Status = EtwpGetDiskInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    Status = EtwpGetNetworkAdapters(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    Status = EtwpGetServiceInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    Status = EtwpGetPowerInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));

    return ERROR_SUCCESS;
}

void EtwpCallHWConfig(ULONG Reason) {

    EtwpSetHWConfigFunction(EtwpDumpHardwareConfig, Reason);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\evntrace\unicode\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\provider\sources.inc ===
USE_CRTDLL=1

MAJORCOMP=sdktools
MINORCOMP=provider

#NTTARGETFILES=copyexe

TARGETNAME=provider
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES=provider.c provider.rc provider.mof

UMTYPE=console
UMAPPL=provider

LINKLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib \
         $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib  \
         $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

C_DEFINES=-DWIN32 -DNT -DSDK_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\drt\tracelog\provider\provider.c ===
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <ole2.h>
#include <wmistr.h>
#include <evntrace.h>
#include <time.h>
#include <tchar.h>

#define DEBUG

#define MAXEVENTS                       5000
#define MAXSTR                          1024

TRACEHANDLE LoggerHandle;
#define ResourceName _T("MofResource")
TCHAR ImagePath[MAXSTR];

GUID TransactionGuid[2] =
{ 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10},
	{0xf684e86f, 0xba1d, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};
GUID   ControlGuid[2]  =
{
	{0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc},
	{0x7c6a708a, 0xba1e, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};

TRACE_GUID_REGISTRATION TraceGuidReg[2] =
{
    { (LPGUID)&TransactionGuid[0],
      NULL
    },
    { (LPGUID)&TransactionGuid[1],
      NULL
    }
};

typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_EVENT, *PUSER_EVENT;

typedef struct _USER_INSTANCE_EVENT {
    EVENT_INSTANCE_HEADER    Header;
    MOF_FIELD                mofData;
} USER_INSTANCE_EVENT, *PUSER_INSTANCE_EVENT;

TRACEHANDLE RegistrationHandle[2];
BOOLEAN RegistrationSuccess;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;

ULONG InitializeTrace(
    IN LPTSTR ExePath, FILE* fp
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

GUID StringToGuid(TCHAR *str);

LPTSTR Decodestatus(IN ULONG Status);

HANDLE ghTraceOnEvent;
ULONG  TraceOnFlag;
UINT   nSleepTime = 0;
TCHAR  ErrorMsg[MAXSTR];
ULONG  gnMultiReg=1;

int __cdecl _tmain(int argc, _TCHAR **argv)
{
	ULONG    status;
    USER_EVENT UserEvent;
    USER_INSTANCE_EVENT UserInstanceEvent;
    EVENT_INSTANCE_INFO InstInfo;
    ULONG    i;
    ULONG    MaxEvents;
    //ULONG    InstanceId;
    PWNODE_HEADER Wnode;
    TCHAR    *str;
    int      err;
    BOOL     bInstanceTrace=0, bUseGuidPtr=0, bUseMofPtr=0;
    BOOL     bIncorrect  = FALSE;
    BOOL     bUseNullPtr = FALSE;

    PMOF_FIELD mofField;
    TCHAR      strMofData[MAXSTR];

    FILE *fp; 
    fp = _tfopen(_T("provider.log"), _T("a+")); if(fp==NULL) {_tprintf(_T("pf=NULL\n"));};

    MaxEvents = MAXEVENTS;
    TraceOnFlag = 0;

    if (argc > 1)
        MaxEvents = _ttoi(argv[1]);

    if(argc > 2)
        ControlGuid[0] = StringToGuid(argv[2]);

    if(argc > 3)
        nSleepTime = _ttoi(argv[3]);

    err = UuidToString(&ControlGuid[0], &str);

    if(RPC_S_OK == err)
        _tprintf(_T("The ControlGuid is : %s\n"), str);
    else
        _tprintf(_T("Error(%d) converting uuid\n"), err);

    _ftprintf(fp, _T("The ControlGuid is : %s\n"), str);

    if(argc > 4) {
        if(!_tcscmp(_T("TraceInstance"), argv[4]))
            bInstanceTrace = TRUE;        
    }

    if(argc > 5) {
        if(!_tcscmp(_T("GuidPtr"), argv[5]))
            bUseGuidPtr = TRUE;
        else if(!_tcscmp(_T("MofPtr"), argv[5]))
            bUseMofPtr = TRUE;
        else if(!_tcscmp(_T("GuidPtrMofPtr"), argv[5])) {
            bUseGuidPtr = TRUE;
            bUseMofPtr  = TRUE;
        }
        else if (!_tcscmp(_T("InCorrectMofPtr"), argv[5])) {
            bUseMofPtr  = TRUE;
            bIncorrect  = TRUE;
        }
        else if (!_tcscmp(_T("NullMofPtr"), argv[5])) {
            bUseMofPtr  = TRUE;
            bUseNullPtr = TRUE;
            bIncorrect  = TRUE;
        }
    }

    if(argc > 6) {
        if(!_tcscmp(_T("MultiReg"), argv[6]))
	        gnMultiReg=2;   //use 2 registrations for now
    }

    status = InitializeTrace(_T("tracedp.exe"), fp);
    if (status != ERROR_SUCCESS) {
        _ftprintf(fp, _T("InitializeTrace failed, status=%d, %s\n"), status, Decodestatus(status));
       return 0;
    }

    _tprintf(_T("Testing Logger with %d events\n"), MaxEvents);

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    Wnode = (PWNODE_HEADER) &UserEvent;
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
	if(bUseGuidPtr) {
        _tprintf(_T("\n********Use Guid Pointer**********\n"));
        UserEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid[0];
    }
    else
        UserEvent.Header.Guid  =  TransactionGuid[0];

    RtlZeroMemory(&UserInstanceEvent, sizeof(UserInstanceEvent));
    UserInstanceEvent.Header.Size  = sizeof(USER_INSTANCE_EVENT);
    UserInstanceEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;

	if(bUseMofPtr) {
        _tprintf(_T("\n=======Use Mof Pointer========\n"));
        _tcscpy(strMofData, str);

        UserEvent.Header.Flags         |= WNODE_FLAG_USE_MOF_PTR;
        mofField = (PMOF_FIELD) & UserEvent.mofData;
        if (bUseNullPtr)
            mofField->DataPtr = (ULONGLONG) (NULL);
        else
            mofField->DataPtr = (ULONGLONG) (strMofData);
        if (bIncorrect)
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1000);
        else
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1);

        UserInstanceEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
        mofField = (PMOF_FIELD) & UserInstanceEvent.mofData;
        if (bUseNullPtr)
            mofField->DataPtr = (ULONGLONG) (NULL);
        else
            mofField->DataPtr = (ULONGLONG) (strMofData);
        if (bIncorrect)
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 10000);
        else
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1);
    }

    if(bInstanceTrace) {
        status = CreateTraceInstanceId((PVOID)TraceGuidReg[0].RegHandle, &InstInfo);
        _tprintf(_T("\n-------TraceEventInstance-----\n"));
        if (status != ERROR_SUCCESS) {
            _ftprintf(fp, _T("CreatTraceInstanceId() failed. status=%d,  %s\n"), status, Decodestatus(status));
        }
    }

    _ftprintf(fp, _T("%d Events, %s, %s, %s, %s, sleep time=%d\n"), MaxEvents, 
              bInstanceTrace? _T("TraceEventInstance"): _T("TraceEvent"), 
              bUseGuidPtr? _T("Use GuidPtr"): _T("Use Guid"), 
              bUseMofPtr? _T("Use MofPtr"): _T("Not use MofPtr"), 
              gnMultiReg==1 ? _T("Single Registration"): _T("Multiple Registrations"), 
              nSleepTime);

    i = 0;

    while (1) {
        if(WAIT_FAILED == WaitForSingleObject(ghTraceOnEvent, INFINITE))
        {
            _tprintf(_T("Error(%d) waiting for ghTraceOnEvent object\n"), GetLastError());
        }
        if (TraceOnFlag == 1 && i < MaxEvents) {
            i++;
            if (i == ((i/2) * 2) ) {
                UserEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
                UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            }
            else {
                UserEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
                UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            }

            if(bInstanceTrace) {
                status = TraceEventInstance(LoggerHandle, (PEVENT_INSTANCE_HEADER)&UserInstanceEvent, &InstInfo, NULL);
                if (status != ERROR_SUCCESS) {
                    _tprintf(_T("%d TraceEventInstance() failed, status=%d  %s\n"), i, status, Decodestatus(status));
                    _ftprintf(fp, _T("\ni=%d TraceEventInstance() failed, break! status=%d  %s\n"), i, status, Decodestatus(status));
                    return 0;
                }
            }
            else {
                status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) &UserEvent);
                if (status != ERROR_SUCCESS) {
                    fprintf(stderr, "Error(%d) while writing event.\n", status);
                    _ftprintf(fp, _T("\ni=%d TraceEvent() failed, break!\nstatus=%d  %s\n"), i, status, Decodestatus(status));
                    return 0;
                }
            }

            if (i >= MaxEvents) {
                _ftprintf(fp, _T("\ni=%d  MaxEvents=%d break!\n\n"), i, MaxEvents);
			}
            else if (!(i % 100)) {
                _ftprintf(fp, _T("."));
                _tprintf(_T("."));

                if(nSleepTime)
                    _sleep(nSleepTime);
            }
        }
        if (TraceOnFlag == 2) {
            _ftprintf(fp, _T("\ni=%d TraceOnFlag == 2 break!\n\n"), i);
            break;
		}
    }

    fclose(fp);
    CloseHandle(ghTraceOnEvent);
    for(i=0; i<	gnMultiReg; i++)
        UnregisterTraceGuids(RegistrationHandle[i]);
	return (0);
}


ULONG InitializeTrace(
    IN LPTSTR ExePath, FILE* fp
    )
{
    ULONG Status;
    ULONG i, j;

    Status = GetModuleFileName(NULL, &ImagePath[0], MAXSTR*sizeof(TCHAR));
    if (Status == 0) {
        return (ERROR_FILE_NOT_FOUND);
    }

    ghTraceOnEvent = CreateEvent(
                        NULL,           // security attributes
                        TRUE,           // manual reset
                        FALSE,          // initial state
                        NULL            // pointer to event-object
                    );        

    if(NULL == ghTraceOnEvent)
    {
        Status=GetLastError();
        _tprintf(_T("Error(%d) creating TraceOnEvent\n"), Status);
        return Status;
    }

    for (i=0; i<gnMultiReg; i++) {
		Status = RegisterTraceGuids(
					(WMIDPREQUEST)ControlCallback,   //use same callback function
					(PVOID)(INT_PTR)(0x12345678+i),  // RequestContext
					(LPCGUID)&ControlGuid[i],
					1,
					&TraceGuidReg[i],
					(LPCTSTR)&ImagePath[0],
					(LPCTSTR)ResourceName,
					&RegistrationHandle[i]);

		if (Status != ERROR_SUCCESS) {
			_tprintf(_T("Trace registration failed\n"));
			RegistrationSuccess = FALSE;
            if(i>0)
                for (j=0; j<i; j++)
                    UnregisterTraceGuids(RegistrationHandle[i]);
       _ftprintf(fp, _T("InitializeTrace failed. i=%d, status=%d, %s\n"), i, Status, Decodestatus(Status));
            return(Status);
		}
		else {
			_tprintf(_T("Trace registered successfully\n"));
			RegistrationSuccess = TRUE;
		}
	}
    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to %I64u\n"), LoggerHandle);
            TraceOnFlag = 1;
            SetEvent(ghTraceOnEvent);
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = 2;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            SetEvent(ghTraceOnEvent);
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}


GUID StringToGuid(TCHAR *str)
{
    GUID  guid;
    TCHAR temp[10];
    int   i, n;

    _tprintf(_T("sizeof GUID = %d  GUID=%s\n"), sizeof(guid), str);

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid.Data1));
    
    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid.Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid.Data3));

    temp[2]=_T('\0');
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if directly used more than byte alloc
        guid.Data4[i]=(unsigned char)n;                   // causes overrun of memory
    }
    
    return guid;
}

LPTSTR
Decodestatus(
    IN ULONG Status
    )
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\bmfmisc.h ===
//
// Header describing a compressed binary mof blob
//
typedef struct
{
    DWORD Signature;
    DWORD CompressionType;
    DWORD CompressedSize;
    DWORD UncompressedSize;
    BYTE Buffer[1];
} BMOFCOMPRESSEDHEADER, *PBMOFCOMPRESSEDHEADER;



typedef struct
{
	HANDLE MofHandle;
	HANDLE EnglishMofHandle;
	BOOLEAN WriteToEnglish;
	PUCHAR UncompressedBlob;
} MOFFILETARGET, *PMOFFILETARGET;


#define MofObjectTypeClass 0
#define MofObjectTypeInstance 1

#ifdef __cplusplus
extern "C" {
#endif
	
BOOLEAN __stdcall ConvertMofToBmf(
    TCHAR *MofFile,
    TCHAR *EnglishMofFile,
    TCHAR *BmfFile
    );

BOOLEAN __stdcall ConvertBmfToMof(
    PUCHAR BinaryMofData,
    TCHAR *MofFile,
    TCHAR *EnglishMofFile
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\chunkimp.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    chunkimpl.h

Abstract:

    This routine will manage allocations of chunks of structures. It also
    contains a handy unicode to ansi conversion function

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

PENTRYHEADER EtwpAllocEntry(
    PCHUNKINFO ChunkInfo
    )
/*++

Routine Description:

    This routine will allocate a single structure within a list of chunks
    of structures.

Arguments:

    ChunkInfo describes the chunks of structures

Return Value:

    Pointer to structure or NULL if one cannot be allocated. Entry returns
    with its refcount set to 1

--*/
{
    PLIST_ENTRY ChunkList, EntryList, FreeEntryHead;
    PCHUNKHEADER Chunk;
    PBYTE EntryPtr;
    ULONG EntryCount, ChunkSize;
    PENTRYHEADER Entry;
    ULONG i;

#ifdef HEAPVALIDATION
    EtwpAssert(RtlValidateProcessHeaps());
#endif
    EtwpEnterCriticalSection();
    ChunkList = ChunkInfo->ChunkHead.Flink;

    //
    // Loop over all chunks to see if any chunk has a free entry for us
    while(ChunkList != &ChunkInfo->ChunkHead)
    {
        Chunk = CONTAINING_RECORD(ChunkList, CHUNKHEADER, ChunkList);
        if (! IsListEmpty(&Chunk->FreeEntryHead))
        {
            EntryList = RemoveHeadList(&Chunk->FreeEntryHead);
            Chunk->EntriesInUse++;
            EtwpLeaveCriticalSection();
            Entry = (CONTAINING_RECORD(EntryList,
                                       ENTRYHEADER,
                                       FreeEntryList));
            EtwpAssert(Entry->Flags & FLAG_ENTRY_ON_FREE_LIST);
            memset(Entry, 0, ChunkInfo->EntrySize);
            Entry->Chunk = Chunk;
            Entry->RefCount = 1;
            Entry->Flags = ChunkInfo->InitialFlags;
            Entry->Signature = ChunkInfo->Signature;
#if DBG
            InterlockedIncrement(&ChunkInfo->AllocCount);
#endif
            return(Entry);
        }
        ChunkList = ChunkList->Flink;
    }
    EtwpLeaveCriticalSection();

    //
    // There are no more free entries in any of the chunks. Allocate a new
    // chunk if we can
    ChunkSize = (ChunkInfo->EntrySize * ChunkInfo->EntriesPerChunk) +
                  sizeof(CHUNKHEADER);
    Chunk = (PCHUNKHEADER)EtwpAlloc(ChunkSize);
    if (Chunk != NULL)
    {
        //
        // Initialize the chunk by building the free list of entries within
        // it while also initializing each entry.
        memset(Chunk, 0, ChunkSize);

        FreeEntryHead = &Chunk->FreeEntryHead;
        InitializeListHead(FreeEntryHead);

        EntryPtr = (PBYTE)Chunk + sizeof(CHUNKHEADER);
        EntryCount = ChunkInfo->EntriesPerChunk - 1;

        for (i = 0; i < EntryCount; i++)
        {
            Entry = (PENTRYHEADER)EntryPtr;
            Entry->Chunk = Chunk;
            Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
            InsertHeadList(FreeEntryHead,
                           &((PENTRYHEADER)EntryPtr)->FreeEntryList);
            EntryPtr = EntryPtr + ChunkInfo->EntrySize;
        }
        //
        // EntryPtr now points to the last entry in the chunk which has not
        // been placed on the free list. This will be the entry returned
        // to the caller.
        Entry = (PENTRYHEADER)EntryPtr;
        Entry->Chunk = Chunk;
        Entry->RefCount = 1;
        Entry->Flags = ChunkInfo->InitialFlags;
        Entry->Signature = ChunkInfo->Signature;

        Chunk->EntriesInUse = 1;

        //
        // Now place the newly allocated chunk onto the list of chunks
        EtwpEnterCriticalSection();
        InsertHeadList(&ChunkInfo->ChunkHead, &Chunk->ChunkList);
        EtwpLeaveCriticalSection();

    } else {
        EtwpDebugPrint(("WMI: Could not allocate memory for new chunk %x\n",
                        ChunkInfo));
        Entry = NULL;
    }
    return(Entry);
}

void EtwpFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    This routine will free an entry within a chunk and if the chunk has no
    more allocated entries then the chunk will be returned to the pool.

Arguments:

    ChunkInfo describes the chunks of structures

    Entry is the chunk entry to free

Return Value:


--*/
{
    PCHUNKHEADER Chunk;

    EtwpAssert(Entry != NULL);
    EtwpAssert(! (Entry->Flags & FLAG_ENTRY_ON_FREE_LIST))
    EtwpAssert((Entry->Flags & FLAG_ENTRY_INVALID))
    EtwpAssert(Entry->RefCount == 0);
    EtwpAssert(Entry->Signature == ChunkInfo->Signature);

    Chunk = Entry->Chunk;
    EtwpAssert(Chunk->EntriesInUse > 0);

    EtwpEnterCriticalSection();
    if ((--Chunk->EntriesInUse == 0) &&
        (ChunkInfo->ChunkHead.Blink != &Chunk->ChunkList))
    {
        //
        // We return the chunks memory back to the heap if there are no
        // more entries within the chunk in use and the chunk was not the
        // first chunk to be allocated.
        RemoveEntryList(&Chunk->ChunkList);
        EtwpLeaveCriticalSection();
        EtwpFree(Chunk);
    } else {
        //
        // Otherwise just mark the entry as free and put it back on the
        // chunks free list.
#if DBG
        memset(Entry, 0xCCCCCCCC, ChunkInfo->EntrySize);
#endif
        Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
        Entry->Signature = 0;
        InsertTailList(&Chunk->FreeEntryHead, &Entry->FreeEntryList);
        EtwpLeaveCriticalSection();
    }
}


ULONG EtwpUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*+++

Routine Description:

    This routine will remove a reference count from the entry and if the
    reference count reaches zero then the entry is removed from its active
    list and then cleaned up and finally freed.

Arguments:

    ChunkInfo points at structure that describes the entry

    Entry is the entry to unreference

Return Value:

    New refcount of the entry

---*/
{
    ULONG RefCount;

    EtwpAssert(Entry != NULL);
    EtwpAssert(Entry->RefCount > 0);
    EtwpAssert(Entry->Signature == ChunkInfo->Signature);

    EtwpEnterCriticalSection();
    InterlockedDecrement(&Entry->RefCount);
    RefCount = Entry->RefCount;

    if (RefCount == 0)
    {
        //
        // Entry has reached a ref count of 0 so mark it as invalid and remove
        // it from its active list.
        Entry->Flags |= FLAG_ENTRY_INVALID;

        if ((Entry->InUseEntryList.Flink != NULL) &&
            (Entry->Flags & FLAG_ENTRY_REMOVE_LIST))
        {
            RemoveEntryList(&Entry->InUseEntryList);
        }

        EtwpLeaveCriticalSection();

        if (ChunkInfo->EntryCleanup != NULL)
        {
            //
            // Call cleanup routine to free anything contained by the entry
            (*ChunkInfo->EntryCleanup)(ChunkInfo, Entry);
        }

        //
        // Place the entry back on its free list
        EtwpFreeEntry(ChunkInfo, Entry);
    } else {
        EtwpLeaveCriticalSection();
    }
    return(RefCount);
}

ULONG AnsiSizeForUnicodeString(
    PWCHAR UnicodeString,
    ULONG *AnsiSizeInBytes
    )
/*++

Routine Description:

    This routine will return the length needed to represent the unicode
    string as ANSI

Arguments:

    UnicodeString is the unicode string whose ansi length is returned

Return Value:

    Number of bytes needed to represent unicode string as ANSI

--*/
{
    EtwpAssert(UnicodeString != NULL);

    try
    {
        *AnsiSizeInBytes = WideCharToMultiByte(CP_ACP,
                                        0,
                        UnicodeString,
                        -1,
                        NULL,
                                            0, NULL, NULL) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ERROR_NOACCESS);
    }
    return((*AnsiSizeInBytes == 0) ? GetLastError() : ERROR_SUCCESS);
}


ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    )
/*++

Routine Description:

    Convert Unicode string into its ansi equivalent

Arguments:

    pszW is unicode string to convert

    *ppszA on entry has a pointer to a ansi string into which the answer
        is written. If NULL on entry then a buffer is allocated and  returned
    in it.

Return Value:

    Error code

--*/
{
    ULONG cbAnsi, cCharacters;
    ULONG Status;
    ULONG cbAnsiUsed;
    BOOLEAN CallerReturnBuffer = (*ppszA != NULL);

    //
    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return(ERROR_SUCCESS);
    }

    try
    {
        cCharacters = wcslen(pszW)+1;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpDebugPrint(("WMI: Bad pointer %x passed to UnicodeToAnsi\n", pszW));
        return(ERROR_NOACCESS);
    }

    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    if (*ppszA == NULL)
    {
        *ppszA = (LPSTR) EtwpAlloc(cbAnsi);
        if (NULL == *ppszA)
    {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    // Convert to ANSI.
    try
    {
        cbAnsiUsed = WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                      cbAnsi, NULL, NULL);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (! CallerReturnBuffer)
        {
            EtwpFree(*ppszA);
            *ppszA = NULL;
        }
        return(ERROR_NOACCESS);
    }

    if (AnsiSizeInBytes != NULL)
    {
        *AnsiSizeInBytes = cbAnsiUsed;
    }
    if (0 == cbAnsiUsed)
    {
        Status = GetLastError();
        if (! CallerReturnBuffer)
        {
            EtwpFree(*ppszA);
            *ppszA = NULL;
        }
        return(Status);
    }

    return(ERROR_SUCCESS);

}

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    )
/*++

Routine Description:

    Convert Ansi string into its Unicode equivalent

Arguments:

    pszA is ansi string to convert

    *ppszW on entry has a pointer to a unicode string into which the answer
        is written. If NULL on entry then a buffer is allocated and  returned
    in it.

Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG Status;
    ULONG cbUnicodeUsed;
    BOOLEAN CallerReturnBuffer = (*ppszW != NULL);

    //
    // If input is null then just return the same.
    if (pszA == NULL)
    {
        *ppszW = NULL;
        return(ERROR_SUCCESS);
    }

    //
    // Determine the count of characters needed for Unicode string
    try
    {
        cCharacters = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpDebugPrint(("WMI: Bad pointer %x passed to AnsiToUnicode\n", pszA));
        return(ERROR_NOACCESS);
    }

    if (cCharacters == 0)
    {
        *ppszW = NULL;
        return(GetLastError());
    }

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.

    if (*ppszW == NULL)
    {
        *ppszW = (LPWSTR) EtwpAlloc(cCharacters * sizeof(WCHAR));
    }
    if (NULL == *ppszW)
        return(ERROR_NOT_ENOUGH_MEMORY);

    // Convert to Unicode
    try
    {
        cbUnicodeUsed = MultiByteToWideChar(CP_ACP, 0, pszA, -1, *ppszW, cCharacters);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (! CallerReturnBuffer)
        {
            EtwpFree(*ppszW);
            *ppszW = NULL;
        }
        return(ERROR_NOACCESS);
    }
    if (0 == cbUnicodeUsed)
    {
        Status = GetLastError();
        if (! CallerReturnBuffer)
        {
            EtwpFree(*ppszW);
            *ppszW = NULL;
        }
        return(Status);
    }

    return(ERROR_SUCCESS);

}

ULONG UnicodeSizeForAnsiString(
    LPCSTR pszA,
    ULONG *UnicodeSizeInBytes
    )
/*++

Routine Description:

    This routine will return the length needed to represent the ansi
    string as UNICODE

Arguments:

    pszA is ansi string to convert


Return Value:

    Error code

--*/
{

    EtwpAssert(pszA != NULL);


    //
    // Determine the count of characters needed for Unicode string
    try
    {
        *UnicodeSizeInBytes = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ERROR_NOACCESS);
    }

    return((*UnicodeSizeInBytes == 0) ? GetLastError() : ERROR_SUCCESS);

}

#if 0     // TODO: Delete me
ULONG EtwpStaticInstanceNameSize(
    PWMIINSTANCEINFO WmiInstanceInfo
    )
/*+++

Routine Description:

    This routine will calculate the size needed to place instance names in
    a WNODE_ALL_DATA

Arguments:

    WmiInstanceInfo describes to instance set whose instance name size
        is to be calculated

Return Value:

    Size needed to place instance names in a WNODE_ALL_DATA plus 3. The
    extra 3 bytes are added in case the OffsetInstanceNameOffsets need to be
    padded since they must be on a 4 byte boundry.
        
---*/
{
    ULONG NameSize;
    ULONG i;
    ULONG SuffixLen;

    //
    // If we already computed this then just return the results
    if (WmiInstanceInfo->InstanceNameSize != 0)
    {
        return(WmiInstanceInfo->InstanceNameSize);
    }

    //
    // Start with a name size of 3 in case the OffsetInstanceNameOffset will
    // need to be padded so that it starts on a 4 byte boundry.
    NameSize = 3;

    if (WmiInstanceInfo->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // For static base names we assume that there will never be more than
        // 999999 instances of a guid.
        SuffixLen = MAXBASENAMESUFFIXSIZE * sizeof(WCHAR);
        EtwpAssert((WmiInstanceInfo->BaseIndex + WmiInstanceInfo->InstanceCount) < 999999);
        NameSize += ((wcslen(WmiInstanceInfo->BaseName) * sizeof(WCHAR)) + 2 + SuffixLen + sizeof(ULONG)) * WmiInstanceInfo->InstanceCount;
    } else if (WmiInstanceInfo->Flags & IS_INSTANCE_STATICNAMES)
    {
        //
        // Count up each size of the static instance names in the list
        for (i = 0; i < WmiInstanceInfo->InstanceCount; i++)
        {
            NameSize += (wcslen(WmiInstanceInfo->StaticNamePtr[i]) + 2) * sizeof(WCHAR) + sizeof(ULONG);
        }
    }

    WmiInstanceInfo->InstanceNameSize = NameSize;

    return(NameSize);
}

void EtwpInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PWMIINSTANCEINFO WmiInstanceInfo
    )
/*+++

Routine Description:

    This routine will copy into the WNODE_ALL_DATA instance names for a
    static instance name set. If the Wnode_All_data is too small then it
    is converted to a WNODE_TOO_SMALL

Arguments:

    Wnode points at the WNODE_ALL_DATA
    MaxWnodeSize is the maximum size of the Wnode
    WmiInstanceInfo is the Instance Info

Return Value:

---*/
{
    PWCHAR NamePtr;
    PULONG NameOffsetPtr;
    ULONG InstanceCount;
    ULONG i;
    WCHAR Index[7];
    PWCHAR StaticName;
    ULONG SizeNeeded;
    ULONG NameLen;
    USHORT Len;
    ULONG PaddedBufferSize;

    if ((WmiInstanceInfo->Flags &
                (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) == 0)
    {
        EtwpDebugPrint(("WMI: Try to setup static names for dynamic guid\n"));
        return;
    }
    InstanceCount = WmiInstanceInfo->InstanceCount;

    //
    // Pad out the size of the buffer to a 4 byte boundry since the
    // OffsetInstanceNameOffsets must be on a 4 byte boundry
    PaddedBufferSize = (Wnode->WnodeHeader.BufferSize + 3) & ~3;
    
    //
    // Compute size needed to write instance names.
    SizeNeeded = (InstanceCount * sizeof(ULONG)) +
                 EtwpStaticInstanceNameSize(WmiInstanceInfo) +
                 Wnode->WnodeHeader.BufferSize;

    if (SizeNeeded > MaxWnodeSize)
    {
        //
        // If not enough space left then change into a WNODE_TOO_SMALL
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
        return;
    }

    //
    // Build the array of offsets to instance names
    NameOffsetPtr = (PULONG)((PBYTE)Wnode + PaddedBufferSize);
    Wnode->OffsetInstanceNameOffsets = (ULONG)((PBYTE)NameOffsetPtr - (PBYTE)Wnode);
    NamePtr = (PWCHAR)(NameOffsetPtr + InstanceCount);


    if (WmiInstanceInfo->Flags & IS_INSTANCE_BASENAME)
    {
        if (WmiInstanceInfo->Flags & IS_PDO_INSTANCENAME)
        {
            Wnode->WnodeHeader.Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
        }

        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PBYTE)NamePtr - (PBYTE)Wnode);
            wcscpy(NamePtr+1,
                   WmiInstanceInfo->BaseName);
            swprintf(Index, L"%d", WmiInstanceInfo->BaseIndex+i);
            wcscat(NamePtr+1, Index);
            NameLen = wcslen(NamePtr+1) + 1;
            *NamePtr = (USHORT)NameLen * sizeof(WCHAR);
            NamePtr += NameLen + 1;
        }
    } else if (WmiInstanceInfo->Flags & IS_INSTANCE_STATICNAMES) {
        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PBYTE)NamePtr - (PBYTE)Wnode);
            StaticName = WmiInstanceInfo->StaticNamePtr[i];
            Len = (wcslen(StaticName)+1) * sizeof(WCHAR);
            *NamePtr++ = Len;
            wcscpy(NamePtr, StaticName);
            NamePtr += Len / sizeof(WCHAR);
        }
    }
    Wnode->WnodeHeader.BufferSize = SizeNeeded;
}
#endif


#ifdef HEAPVALIDATION
PVOID EtwpAlloc(
    ULONG Size
    )
{
    PVOID p;

    EtwpAssert(RtlValidateProcessHeaps());
    p = RtlAllocateHeap(EtwpProcessHeap, 0, Size);

    EtwpDebugPrint(("WMI: EtwpAlloc %x (%x)\n", p, Size));

    return(p);
}

void EtwpFree(
    PVOID p
    )
{

    EtwpDebugPrint(("WMI: EtwpFree %x\n", p));
    EtwpAssert(p != NULL);

    EtwpAssert(RtlValidateProcessHeaps());
    RtlFreeHeap(EtwpProcessHeap, 0, p);
}
#endif

#ifdef MEMPHIS
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}
#else
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    i = sprintf(Buffer, "[%d] - ", GetTickCount());
    va_start(pArg, Format);
    i = _vsnprintf(&Buffer[i], sizeof(Buffer), Format, pArg);
    DbgPrint(Buffer);
}
#endif

#ifndef MEMPHIS
ULONG EtwpCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    )
{
    HANDLE Handle;
    ULONG Status;

    Status = EtwpOpenKernelGuid(Guid,
                                DesiredAccess,
                                &Handle,
                                IOCTL_WMI_OPEN_GUID
                );

    if (Status == ERROR_SUCCESS)
    {
        CloseHandle(Handle);
    }

    return(Status);
}

ULONG EtwpBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    )
{
    WCHAR GuidChar[37];

	EtwpAssert(Guid != NULL);
    
    //
    // Build up guid name into the ObjectAttributes
    //
    swprintf(GuidChar, L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               Guid->Data1, Guid->Data2, 
               Guid->Data3,
               Guid->Data4[0], Guid->Data4[1],
               Guid->Data4[2], Guid->Data4[3],
               Guid->Data4[4], Guid->Data4[5],
               Guid->Data4[6], Guid->Data4[7]);

	EtwpAssert(wcslen(GuidChar) == 36);
	
	wcscpy(GuidObjectName, WmiGuidObjectDirectory);
	wcscat(GuidObjectName, GuidChar);    
	RtlInitUnicodeString(GuidString, GuidObjectName);
    
	memset(ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
	ObjectAttributes->Length = sizeof(OBJECT_ATTRIBUTES);
	ObjectAttributes->ObjectName = GuidString;
	
    return(ERROR_SUCCESS);    
}

ULONG EtwpOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    UNICODE_STRING GuidString;
    ULONG ReturnSize;
    ULONG Status;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;

    Status = EtwpBuildGuidObjectAttributes(Guid,
                                           &ObjectAttributes,
                                           &GuidString,
                                           GuidObjectName);
                                       
    if (Status == ERROR_SUCCESS)
    {
        WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;
        WmiOpenGuidBlock.DesiredAccess = DesiredAccess;

        Status = EtwpSendWmiKMRequest(NULL, 
                                      Ioctl,
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      &ReturnSize,
                      NULL);

        if (Status == ERROR_SUCCESS)
        {
            *Handle = WmiOpenGuidBlock.Handle.Handle;
        } else {
            *Handle = NULL;
        }
    }
    return(Status);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#ifdef BIT16
#define     FAR     _far
#else
#ifndef FAR
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned _stdcall Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned _stdcall Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned _stdcall Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned _stdcall Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\fchba\testapp\hbatest.c ===
//***************************************************************************
//
//  hbatest.c
// 
//  Module: Windows HBA API implmentation test application
//
//  Purpose: Contains routines for getting and setting data
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  This is provided for informational purposes only. Do not
//  redistribute.
//
//***************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "hbaapi.h"

#define MAX_ADAPTERS 64



void CallMiscFunctions()
{
	HBA_STATUS Status;
	HBA_UINT32 Version;
	
    Status = HBA_RegisterLibrary(NULL);
	if (Status != HBA_STATUS_ERROR_NOT_SUPPORTED)
	{
		printf("HBA_RegisterLibrary -> %d\n", Status);
	}
	
	Version = HBA_GetVersion();
	if (Version != HBA_VERSION)
	{
		printf("HBA_GetVersion -> %d\n", Version);
	}
	
	Status = HBA_LoadLibrary();
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_LoadLibrary -> %d\n", Status);
	}
	
	Status = HBA_FreeLibrary();
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_FreeLibrary -> %d\n", Status);
	}
	
// TODO: These functions
#if 0

HBA_API HBA_STATUS HBA_SendScsiInquiry (
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 EVPD,
	HBA_UINT32 PageCode,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize);

HBA_API HBA_STATUS HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

HBA_API HBA_STATUS HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);
#endif

	
}

HBA_STATUS BuildAdapterList(
    PULONG AdapterCount,
    TCHAR **Adapters
)
{
	HBA_UINT32 Count, i;
	PTCHAR Name;
	HBA_STATUS Status;

	Count = HBA_GetNumberOfAdapters();
	if (Count > MAX_ADAPTERS)
	{
		printf("%d is above limit of %d adapters\n", Count, MAX_ADAPTERS);
		Count = MAX_ADAPTERS;
	}

	*AdapterCount = Count;
	Status = HBA_STATUS_OK;
	for (i = 0; i < Count; i++)
	{
		Name = malloc(256 * sizeof(TCHAR));
		Status = HBA_GetAdapterName(i, Name);
		if (Status == HBA_STATUS_OK)
		{
			Adapters[i] = Name;
		} else {
			printf("HBA_GetAdapterName(%d) -> %d\n", i, Status);
			break;
		}
	}
	
	return(Status);
}

void PrintHBA_WWN(
    PCHAR s,
	HBA_WWN wwn
    )
{
	printf(s);
	printf(" %02x %02x %02x %02x %02x %02x %02x %02x \n",
		   wwn.wwn[0], wwn.wwn[1], wwn.wwn[2], wwn.wwn[3],
		   wwn.wwn[4], wwn.wwn[5], wwn.wwn[6], wwn.wwn[7]);
		   
}

void PrintHBA_UINT32(
    PCHAR s,
    HBA_UINT32 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

#ifdef UNICODE
void Printchar(
    PCHAR s,
    PWCHAR w
    )
{
	printf(s);
	printf(": %ws\n", w);
}
#else
void Printchar(
    PCHAR s,
    PCHAR w
    )
{
	printf(s);
	printf(": %s\n", w);
}
#endif

HBA_STATUS GetAdapterAttributes(
    HBA_HANDLE Handle,
    HBA_UINT32 *PortCount
    )
{
	HBA_STATUS Status;
	HBA_ADAPTERATTRIBUTES Attributes;
	
	Status = HBA_GetAdapterAttributes(Handle,
									  &Attributes);

	if (Status == HBA_STATUS_OK)
	{
		printf("\nAdapter Attributes:\n");
		PrintHBA_WWN("NodeWWN", Attributes.NodeWWN);
		PrintHBA_UINT32("VendorSpecificID", Attributes.VendorSpecificID);
		PrintHBA_UINT32("NumberOfPorts", Attributes.NumberOfPorts);
		*PortCount = Attributes.NumberOfPorts;
	
		Printchar("Manufacturer", Attributes.Manufacturer);
		Printchar("SerialNumber", Attributes.SerialNumber);
		Printchar("Model", Attributes.Model);
		Printchar("ModelDescription", Attributes.ModelDescription);
		Printchar("NodeSymbolicName", Attributes.NodeSymbolicName);
		Printchar("HardwareVersion", Attributes.HardwareVersion);
		Printchar("DriverVersion", Attributes.DriverVersion);
		Printchar("OptionROMVersion", Attributes.OptionROMVersion);
		Printchar("FirmwareVersion", Attributes.FirmwareVersion);
		Printchar("DriverName", Attributes.DriverName);		
	} else {
		printf("HBA_GetAdapterAttributes -> %d\n", Status);
	}
	return(Status);
}

void PrintHBA_PORTTYPE(
    PCHAR s,
    HBA_PORTTYPE u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_PORTSPEED(
    PCHAR s,
    HBA_PORTSPEED u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_PORTSTATE(
    PCHAR s,
    HBA_PORTSTATE u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_COS(
    PCHAR s,
    HBA_COS u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_FC4TYPES(
    PCHAR s,
    HBA_FC4TYPES Fc4
    )
{
	ULONG i;
	
	// TODO: symbolic constants
	printf(s);
	printf(":");
	for (i = 0; i < 32; i++)
	{
		printf(" %02x", Fc4.bits[i]);
	}
	printf("\n");
}

void PrintHBA_UINT64(
    PCHAR s,
    HBA_UINT64 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_INT64(
    PCHAR s,
    HBA_INT64 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_UINT16(
    PCHAR s,
    HBA_UINT16 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_UINT8A(
    PCHAR s,
    HBA_UINT8 *u,
    ULONG Len
    )
{
	ULONG i;
	
	printf(s);
	printf(":");
	for (i = 0; i < Len; i++)
	{
		printf(" 0x%x\n", u[i]);
	}
	printf("\n");
}

void PrintHBA_PORTATTRIBUTES(
    PHBA_PORTATTRIBUTES Attributes
	)
{
	PrintHBA_WWN("NodeWWN", Attributes->NodeWWN);
	PrintHBA_WWN("PortWWN", Attributes->PortWWN);
	PrintHBA_UINT32("PortFcId", Attributes->PortFcId);
	PrintHBA_PORTTYPE("PortType", Attributes->PortType);
	PrintHBA_PORTSTATE("PortState", Attributes->PortState);
	PrintHBA_COS("PortSupportedClassofService", Attributes->PortSupportedClassofService);
	PrintHBA_FC4TYPES("PortSupportedFc4Types", Attributes->PortSupportedFc4Types);
	PrintHBA_FC4TYPES("PortActiveFc4Types", Attributes->PortActiveFc4Types);
	Printchar("PortSymbolicName", Attributes->PortSymbolicName);
	Printchar("OSDeviceName", Attributes->OSDeviceName);
	PrintHBA_PORTSPEED("PortSupportedSpeed", Attributes->PortSupportedSpeed);
	PrintHBA_PORTSPEED("PortSpeed", Attributes->PortSpeed);
	PrintHBA_UINT32("PortMaxFrameSize", Attributes->PortMaxFrameSize);
	PrintHBA_WWN("FabricName", Attributes->FabricName);
	PrintHBA_UINT32("NumberofDiscoveredPorts", Attributes->NumberofDiscoveredPorts);
}

HBA_STATUS GetPortInformation(
    HBA_HANDLE Handle,
    HBA_UINT32 PortIndex
    )
{
	HBA_STATUS Status;
	HBA_PORTATTRIBUTES Attributes;
	HBA_PORTSTATISTICS Statistics;
	UINT i;

    HBA_ResetStatistics(Handle, PortIndex);
	Status = HBA_GetAdapterPortAttributes(Handle,
								   PortIndex,
								   &Attributes);

	if (Status == HBA_STATUS_OK)
	{
		PrintHBA_PORTATTRIBUTES(&Attributes);
		Status = HBA_GetPortStatistics(Handle,
									   PortIndex,
									   &Statistics);
		if (Status == HBA_STATUS_OK)
		{
			PrintHBA_INT64("SecondsSinceLastReset", Statistics.SecondsSinceLastReset);
			PrintHBA_INT64("TxFrames", Statistics.TxFrames);
			PrintHBA_INT64("TxWords", Statistics.TxWords);
			PrintHBA_INT64("RxFrames", Statistics.RxFrames);
			PrintHBA_INT64("RxWords", Statistics.RxWords);
			PrintHBA_INT64("LIPCount", Statistics.LIPCount);
			PrintHBA_INT64("NOSCount", Statistics.NOSCount);
			PrintHBA_INT64("ErrorFrames", Statistics.ErrorFrames);
			PrintHBA_INT64("DumpedFrames", Statistics.DumpedFrames);
			PrintHBA_INT64("LinkFailureCount", Statistics.LinkFailureCount);
			PrintHBA_INT64("LossOfSyncCount", Statistics.LossOfSyncCount);
			PrintHBA_INT64("LossOfSignalCount", Statistics.LossOfSignalCount);
			PrintHBA_INT64("PrimitiveSeqProtocolErrCount", Statistics.PrimitiveSeqProtocolErrCount);
			PrintHBA_INT64("InvalidTxWordCount", Statistics.InvalidTxWordCount);
			PrintHBA_INT64("InvalidCRCCount", Statistics.InvalidCRCCount);

			for (i = 0; i < 4; i++)
			{
				printf("\nDiscovered port %d\n", i);
				Status = HBA_GetDiscoveredPortAttributes(Handle,
					                                     PortIndex,
                                                         i,
                                    					 &Attributes);
				if (Status == HBA_STATUS_OK)
				{
					HBA_WWN wwn = {0};    // TODO: make wwn meaningful
					
					PrintHBA_PORTATTRIBUTES(&Attributes);
					
					Status = HBA_GetPortAttributesByWWN(Handle,
						                                wwn,
						                                &Attributes);

					if (Status == HBA_STATUS_OK)
					{
						PrintHBA_PORTATTRIBUTES(&Attributes);
					} else {
						printf("HBA_GetPortAttributesByWWN -> %d\n", Status);
					}
				} else {
					printf("HBA_GetDiscoveredPortAttributes -> %d\n", Status);
				}
			}
		} else {
			printf("HBA_GetPortStatistics -> %d\n", Status);
		}
	} else {
		printf("HBA_GetPortAttributes -> %d\n", Status);
	}
	return(Status);
}

HBA_STATUS GetSetMgmtInfo(
    HBA_HANDLE Handle
    )
{
	HBA_MGMTINFO MgmtInfo;
	HBA_STATUS Status;

	Status = HBA_GetRNIDMgmtInfo(Handle,
								 &MgmtInfo);
	if (Status == HBA_STATUS_OK)
	{
		PrintHBA_WWN("wwn", MgmtInfo.wwn);
		PrintHBA_UINT32("unittype", MgmtInfo.unittype);
		PrintHBA_UINT32("PortId", MgmtInfo.PortId);
		PrintHBA_UINT32("NumberOfAttachedNodes", MgmtInfo.NumberOfAttachedNodes);
		PrintHBA_UINT16("IPVersion", MgmtInfo.IPVersion);
		PrintHBA_UINT16("UDPPort", MgmtInfo.UDPPort);
		PrintHBA_UINT8A("IPAddress", MgmtInfo.IPAddress, 16);
		PrintHBA_UINT16("reserved", MgmtInfo.reserved);
		PrintHBA_UINT16("TopologyDiscoveryFlags", MgmtInfo.TopologyDiscoveryFlags);

		Status = HBA_SetRNIDMgmtInfo(Handle,
									 &MgmtInfo);
		if (Status != HBA_STATUS_OK)
		{
			printf("HBA_SetRNIDMgmtInfo -> %d\n", Status);
		}
	} else {
		printf("HBA_GetRNIDMgmtInfo -> %d\n", Status);
	}
	
	return(Status);
}

UCHAR RspBuffer[0x1000];
UCHAR ReqBuffer[0x800];

HBA_STATUS SendPassThroughs(
    HBA_HANDLE Handle
    )
{
	HBA_STATUS Status;
	HBA_UINT32 RspBufferSize;
	HBA_WWN wwn = {0};
	HBA_WWNTYPE wwnType = 0;

	memset(ReqBuffer, 0x80, sizeof(ReqBuffer));
	Status = HBA_SendCTPassThru(Handle,
								ReqBuffer,
								sizeof(ReqBuffer),
								RspBuffer,
								sizeof(RspBuffer)/2);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendCTPassThru too small -> %d\n", Status);
	}
								
	memset(ReqBuffer, 0x81, sizeof(ReqBuffer));
	Status = HBA_SendCTPassThru(Handle,
								ReqBuffer,
								sizeof(ReqBuffer),
								RspBuffer,
								sizeof(RspBuffer));
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendCTPassThru -> %d\n", Status);
	}

	//
	// Now do RNID
	//
	
	RspBufferSize = 0;
	memset(ReqBuffer, 0x80, sizeof(ReqBuffer));
	Status = HBA_SendRNID(Handle,
						  wwn,
						  wwnType,
						  RspBuffer,
						  &RspBufferSize);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendRNID too small -> %d\n", Status);
	} else {
		printf("HBA_SENDRNID too small RspBufferSize = %d\n", RspBufferSize);
	}
								

	memset(ReqBuffer, 0x81, sizeof(ReqBuffer));
	RspBufferSize = 100;
	Status = HBA_SendRNID(Handle,
						  wwn,
						  wwnType,
						  RspBuffer,
						  &RspBufferSize);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendRNID -> %d\n", Status);
	} else {
		printf("HBA_SENDRNID RspBufferSize = %d\n", RspBufferSize);
	}
	return(Status);
}

void PrintHBA_SCSIID(
    PHBA_SCSIID ScsiId
    )
{
	Printchar("OSDeviceName", ScsiId->OSDeviceName);
	PrintHBA_UINT32("ScsiBusNumber", ScsiId->ScsiBusNumber);
	PrintHBA_UINT32("ScsiTargetNumber", ScsiId->ScsiTargetNumber);
	PrintHBA_UINT32("ScsiOSLun", ScsiId->ScsiOSLun);	
}

void PrintHBA_FCPID(
    PHBA_FCPID FcpId
    )
{
	PrintHBA_UINT32("FcId", FcpId->FcId);
	PrintHBA_WWN("NodeWWN", FcpId->NodeWWN);
	PrintHBA_WWN("PortWWN", FcpId->PortWWN);
	PrintHBA_UINT64("FcpLun", FcpId->FcpLun);
}

void PrintHBA_FCPSCSIENTRY(
    PHBA_FCPSCSIENTRY entry
    )
{
	PrintHBA_SCSIID(&entry->ScsiId);
	PrintHBA_FCPID(&entry->FcpId);	
}

void PrintHBA_FCPBINDINGTYPE(
    PCHAR s,
    HBA_FCPBINDINGTYPE type
    )
{
	printf(s);
	if (type == TO_D_ID)
	{
		printf(": TO_D_ID\n");
	} else if (type == TO_WWN) {
		printf(": TO_WWN\n");
	} else {
		printf(": ?? UNKNOWN ??\n");
	}
}

void PrintHBA_FCPBINDINGENTRY(
    PHBA_FCPBINDINGENTRY entry
    )
{
	PrintHBA_FCPBINDINGTYPE("type", entry->type);
	PrintHBA_SCSIID(&entry->ScsiId);
	PrintHBA_FCPID(&entry->FcpId);	
}

HBA_STATUS GetMappings(
    HBA_HANDLE Handle
    )
{
	HBA_FCPTARGETMAPPING FcpMappingStatic;
	PHBA_FCPTARGETMAPPING FcpMapping;
	HBA_FCPBINDING FcpBindingStatic;
	PHBA_FCPBINDING FcpBinding;
	ULONG i, SizeNeeded;
	HBA_STATUS Status;

	printf("FcpTargetMapping\n");
	FcpMappingStatic.NumberOfEntries = 0;
	Status = HBA_GetFcpTargetMapping(Handle,
									 &FcpMappingStatic);
	if (Status == HBA_STATUS_ERROR_MORE_DATA)
	{
		SizeNeeded = (sizeof(HBA_FCPTARGETMAPPING) +
					  (FcpMappingStatic.NumberOfEntries * sizeof(HBA_FCPSCSIENTRY)));

		FcpMapping = (PHBA_FCPTARGETMAPPING)malloc(SizeNeeded);
		if (FcpMapping != NULL)
		{
			FcpMapping->NumberOfEntries = FcpMappingStatic.NumberOfEntries;
			Status = HBA_GetFcpTargetMapping(Handle,
											 FcpMapping);
			if (Status == HBA_STATUS_OK)
			{
				printf("Entries = %d\n", FcpMapping->NumberOfEntries);
				for (i = 0; i <  FcpMapping->NumberOfEntries; i++)
				{
					PrintHBA_FCPSCSIENTRY(&FcpMapping->entry[i]);
				}
			} else {
				printf("HBA_GetFcpTargetMapping full -> %d\n", Status);
			}
		} else {
			printf("Alloc for %d FCPMapping failed\n", SizeNeeded);
		}
	} else {
		printf("HBA_GetFcpTargetMapping -> %d\n", Status);
	}

	printf("FcpBinding\n");
	FcpBindingStatic.NumberOfEntries = 0;
	Status = HBA_GetFcpPersistentBinding(Handle,
									 &FcpBindingStatic);
	if (Status == HBA_STATUS_ERROR_MORE_DATA)
	{
		SizeNeeded = (sizeof(HBA_FCPBINDING) +
					  (FcpBindingStatic.NumberOfEntries * sizeof(HBA_FCPBINDINGENTRY)));

		FcpBinding = (PHBA_FCPBINDING)malloc(SizeNeeded);
		if (FcpBinding != NULL)
		{
			FcpBinding->NumberOfEntries = FcpBindingStatic.NumberOfEntries;
			Status = HBA_GetFcpPersistentBinding(Handle,
											 FcpBinding);
			if (Status == HBA_STATUS_OK)
			{
				printf("NumberOfEntries = %d\n", FcpBinding->NumberOfEntries);
				for (i = 0; i <  FcpBinding->NumberOfEntries; i++)
				{
					PrintHBA_FCPBINDINGENTRY(&FcpBinding->entry[i]);
				}
			} else {
				printf("HBA_GetPersistentBinding full -> %d\n", Status);
			}
		} else {
			printf("Alloc for %d FcpBinding failed\n", SizeNeeded);
		}
	} else {
		printf("HBA_GetFcpPersistenBinding -> %d\n", Status);
	}
	return(Status);
}

HBA_STATUS GetAdapterInformation(
    PTCHAR AdapterName
    )
{
	HBA_STATUS Status;
	HBA_HANDLE Handle;
	HBA_UINT32 i, PortCount;
	
	Handle = HBA_OpenAdapter(AdapterName);
	if (Handle != 0)
	{
		HBA_RefreshInformation(Handle);
		
		Status = GetAdapterAttributes(Handle, &PortCount);
		if (Status == HBA_STATUS_OK)
		{
			for (i = 0; i < PortCount; i++)
			{
				printf("Port %d\n", i);
				Status = GetPortInformation(Handle, i);
				if (Status != HBA_STATUS_OK)
				{
					printf("GetPortAttributes(%d) -> %d\n", i, Status);
				}
			}

			Status = GetSetMgmtInfo(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("GetSetMgmtInfo -> %d\n", Status);
			}

			Status = SendPassThroughs(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("DoPassthroughs -> %d\n", Status);
			}

			Status = GetMappings(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("GetMappings -> %d\n", Status);
			}
		}
		
		HBA_CloseAdapter(Handle);
	} else {
#ifdef UNICODE		
		printf("HBA_OpenAdapter(%ws) Error\n", AdapterName);
#else
		printf("HBA_OpenAdapter(%s) Error\n", AdapterName);
#endif
	}
	return(Status);
}


int _cdecl main(int argc, char *argv[])
{
	TCHAR *Adapters[MAX_ADAPTERS];
	ULONG AdapterCount;
	HBA_STATUS Status;
	ULONG i;

	CallMiscFunctions();
	
	Status = BuildAdapterList(&AdapterCount, Adapters);
	if (Status == HBA_STATUS_OK)
	{
		printf("%d adapters discovered\n", AdapterCount);
		
		for (i = 0; i < AdapterCount; i++)
		{
#ifdef UNICODE
			printf("Adapter: %ws\n", Adapters[i]);
#else
			printf("Adapter: %s\n", Adapters[i]);
#endif
			Status = GetAdapterInformation(Adapters[i]);
			if (Status != HBA_STATUS_OK)
			{
#ifdef UNICODE				
				printf("GetAdapterInformation(%ws) -> %d\n",
					   Adapters[i], Status);
#else
				printf("GetAdapterInformation(%s) -> %d\n",
					   Adapters[i], Status);
#endif
			}
		}
	}
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\bmof.h ===
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  bmof.h
//
//  a-davj  14-April-97   Created.
//
//  Describes the format of binary MOF files.  In addition, it defines some
//  structures which specify the details of the format and also defines some
//  addtional structures and helper functions for navigating a BMOF file.
//
//***************************************************************************

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

//  The extension  for supporting qualifier flavors is to add the following data after the current blob.
//  
//  typedef struct 
//  {
//      WCHAR wcSignature;          // the string BMOFQUALFLAVOR11
//      DWORD dwNumPair;
//      // BYTE FlavorInfo[];             // Blob containing array of WBEM_Object structs
//  }WBEM_Binary_FLAVOR;
//  
//  The FlavorInfo blob will be a series of DWORD pairs of the form
//  
//  Typedef struct
//  {
//  	DWORD dwOffsetInOriginalBlob;
//  	DWORD dwFlavor;
//  }

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    WBEM_QualifierList * m_pql;
    WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    WBEM_Object * m_pob;
    BYTE * m_pInfo;
    WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    WBEM_Property * m_pCurrProp;

    WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    WBEM_Object * m_pInfo;
    WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;


//
// Qualifier flavor definitions
#define FlavorAmended           0x80
#define FlavorDisableOverride   0x10
#define FlavorToSubclass        0x02
#define FlavorToInstance        0x01



// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

//
// redefine the BMOF allocation routines to be the same as the WMI allocation
// routines.
#define BMOFFree(p) WmipFree(p)
#define BMOFAlloc(s) WmipAlloc(s)


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * _stdcall CreateObjList(BYTE * pBuff);
void _stdcall ResetObjList(CBMOFObjList * pol);
CBMOFObj * _stdcall NextObj(CBMOFObjList *pol);
CBMOFObj * _stdcall FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void _stdcall ResetObj(CBMOFObj * pol);
CBMOFQualList * _stdcall GetQualList(CBMOFObj * pol);
CBMOFQualList * _stdcall GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * _stdcall GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL _stdcall NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD _stdcall GetType(CBMOFObj * pob);
WBEM_Property * _stdcall FindPropPtr(CBMOFObj * pob, WCHAR * pName);
WBEM_Property * _stdcall FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void _stdcall ResetQualList(CBMOFQualList * pql);
BOOL _stdcall NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff);
BOOL _stdcall FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int _stdcall GetNumDimensions(CBMOFDataItem *);
int _stdcall GetNumElements(CBMOFDataItem *, long lDim);
int _stdcall GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int _stdcall iTypeSize(DWORD vtTest);
BOOL _stdcall SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL _stdcall SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * _stdcall CreateQualList(WBEM_QualifierList *pql);
CBMOFObj * _stdcall CreateObj(WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\dllcalls.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    DLLCALLS.H

Abstract:

	This file defines the entry points for calling this as a dll rather than a com object.

History:

	3/20/00     a-davj      Created

--*/

#ifndef __DLLCALLS__H_
#define __DLLCALLS__H_

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\common.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    common.h

Abstract:

	This file contains structures and functions used in Ntdll.dll and advapi32.dll

--*/

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define EtwpNtStatusToDosError(Status) ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))
#define DEFAULT_ALLOC_SIZE     4096
#define MAXSTR                 1024

#if !defined (_NTDLLBUILD_)
    extern void EtwpCallHWConfig(ULONG Reason);
#endif

HANDLE EtwpWin32Event;

__inline 
ULONG
EtwpSetDosError(
    IN ULONG DosError
    )
{
#if defined (_NTDLLBUILD_)
    EtwpSetLastError(DosError);
#else
    SetLastError(DosError);
#endif
    return DosError;
}

#if defined (_NTDLLBUILD_)

    extern
    RTL_CRITICAL_SECTION UMLogCritSect;
    BOOLEAN EtwLocksInitialized = FALSE;

#endif

HINSTANCE DllInstanceHandle;
extern HANDLE EtwpKMHandle;

#if DBG 

    #define MOFLISTSIZEGUESS  1
    BOOLEAN EtwpLoggingEnabled = FALSE;

#else       
    #define MOFLISTSIZEGUESS  10
#endif

#ifndef MEMPHIS
RTL_CRITICAL_SECTION PMCritSect;
HANDLE EtwpCBInProgressEvent = NULL;
PVOID EtwpProcessHeap = NULL;
HANDLE EtwpDeviceHandle;
#else
HANDLE PMMutex;
#endif

NTSTATUS EtwpInitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{

#ifdef MEMPHIS
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;

    Status = NtCreateMutant(&PMMutex,
                            MUTANT_ALL_ACCESS,
                            BaseFormatObjectAttributes(&Obja, NULL, NULL)
                            FALSE);
    if (! NT_SUCCESS(Status))
    {
        return(Status);
    }
#else
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(&PMCritSect);
    
    if (! NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = NtCreateEvent(&EtwpCBInProgressEvent, 
                                          EVENT_ALL_ACCESS,
                                          NULL, 
                                          NotificationEvent,
                                          TRUE);
    if (! NT_SUCCESS(Status)) 
    {
        RtlDeleteCriticalSection(&PMCritSect); // Delete PMCritSec.
        return (Status);
    }

#if defined (_NTDLLBUILD_)

    Status = RtlInitializeCriticalSection(&UMLogCritSect);

    if (! NT_SUCCESS(Status))
    {
        RtlDeleteCriticalSection(&PMCritSect); // Delete PMCritSec.
        NtClose(EtwpCBInProgressEvent);
        EtwpCBInProgressEvent = NULL;
        return(Status);
    }

    EtwLocksInitialized = TRUE;

#endif

#endif

    return(STATUS_SUCCESS);
}

void EtwpDeinitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{
#ifdef MEMPHIS
    CloseHandle(PMMutex);
#else

#if defined (_NTDLLBUILD_)
    if(EtwLocksInitialized){
        EtwLocksInitialized = FALSE;
#endif
        RtlDeleteCriticalSection(&PMCritSect);   
        NtClose(EtwpCBInProgressEvent);
        EtwpCBInProgressEvent = NULL;

#if defined (_NTDLLBUILD_)
        RtlDeleteCriticalSection(&UMLogCritSect);
    }
#endif

    if ((EtwpProcessHeap != NULL) &&
        (EtwpProcessHeap != RtlProcessHeap()))

    {
        RtlDestroyHeap(EtwpProcessHeap);
        EtwpProcessHeap = NULL;
    }
    if (EtwpDeviceHandle != NULL) 
    {
#if defined (_NTDLLBUILD_)
        EtwpCloseHandle(EtwpDeviceHandle);
#else
        CloseHandle(EtwpDeviceHandle);
#endif
        EtwpDeviceHandle = NULL;
    }
#endif

    if (EtwpWin32Event != NULL)
    {
#if defined (_NTDLLBUILD_)
        EtwpCloseHandle(EtwpWin32Event);
#else 
        CloseHandle(EtwpWin32Event);
#endif
        EtwpWin32Event = NULL;
    } 
}

NTSTATUS 
EtwpRegOpenKey(
    IN PCWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    RtlInitUnicodeString( &KeyName, lpKeyName );
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

    return NtOpenKey( KeyHandle, KEY_READ, &ObjectAttributes );
}

NTSTATUS
EtwpRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + Length;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) 
                          RtlAllocateHeap (RtlProcessHeap(),0,BufferLength);
    if (KeyValueInformation == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey(
                KeyHandle,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                ResultLength
                );
    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(KeyValue, 
                      KeyValueInformation->Data, 
                      KeyValueInformation->DataLength
                     );

        *ResultLength = KeyValueInformation->DataLength;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > Length) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength++] = 0;
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength] = 0;
            *ResultLength = KeyValueInformation->DataLength + sizeof(WCHAR);
        }
    }
    RtlFreeHeap(RtlProcessHeap(),0,KeyValueInformation);
    return Status;
}

#if DBG

NTSTATUS EtwpGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG DataLength;
    HANDLE Handle = INVALID_HANDLE_VALUE;

    Status = EtwpRegOpenKey(WmiRegKeyText, &Handle);

    if (NT_SUCCESS(Status)) {

        Status = EtwpRegQueryValueKey(Handle,
                                      ValueName,
                                      sizeof(DWORD),
                                      (PVOID)Value,
                                      &DataLength
                                      );
        NtClose(Handle);
    }

    return Status;
}

#endif

BOOLEAN
WmiDllInitialize(
    IN PVOID DllBase,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.

Arguments:

    DllHandle - 

    Reason  - attach\detach

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/
{
    //
    // NOTE : Do not use WMI heap in this function
    // or in any of the routines called subsequently
    // as WMI Heap is not initialized until any ETW API
    // is called.
    //

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Foo;

    DllInstanceHandle = (HINSTANCE)DllBase;
    
    if (Reason == DLL_PROCESS_ATTACH)       
    {

#if DBG
        Foo = EtwpLoggingEnabled ? 1 : 0;
        EtwpGetRegistryValue(LoggingEnableValueText,
                             &Foo);
        EtwpLoggingEnabled = (Foo == 0) ? FALSE : TRUE;
#endif
        Status = EtwpInitializeDll();
    
    } else if (Reason == DLL_PROCESS_DETACH) {

        //
        // Don't need to clean up if process is exiting
        //
        if (Context == NULL)
        {            
            EtwpDeinitializeDll();
        }

        if (EtwpKMHandle != (HANDLE)NULL)
        {
#if defined (_NTDLLBUILD_)
            EtwpCloseHandle(EtwpKMHandle);
#else 
            CloseHandle(EtwpKMHandle);
#endif
        }

    }

#if !defined (_NTDLLBUILD_)
        EtwpCallHWConfig(Reason);
#endif

    return(NT_SUCCESS(Status));
}

#ifndef MEMPHIS
VOID
EtwpCreateHeap(
    void
    )
{
    EtwpEnterPMCritSection();
    
    if (EtwpProcessHeap == NULL)
    {
        EtwpProcessHeap = RtlCreateHeap(HEAP_GROWABLE,
                                        NULL,
                                        DLLRESERVEDHEAPSIZE,
                                        DLLCOMMITHEAPSIZE,
                                        NULL,
                                        NULL);
                
        if (EtwpProcessHeap == NULL)
        {
            EtwpDebugPrint(("WMI: Cannot create EtwpProcessHeap, using process default\n"));
            EtwpProcessHeap = RtlProcessHeap();
        }
    }
    
    EtwpLeavePMCritSection();   
    
    //
    // This has been copied to this function as in ntdll
    // we cannot execute WmiInitializeDll codepath. And
    // EtwpLoggingEnabled has to be checked only  once. 
    // So this place should be  okay  to initialze 
    // EtwpLoggingEnabled
    //

#if DBG && defined(_NTDLLBUILD_)
    {
        ULONG Foo;
        Foo = EtwpLoggingEnabled ? 1 : 0;
        EtwpGetRegistryValue(&LoggingEnableValueText, &Foo);
        EtwpLoggingEnabled = (Foo == 0) ? FALSE : TRUE;
    }
#endif

}
#endif


ULONG
EtwpGetMofResourceList(
    PWMIMOFLIST *MofListPtr
    )
{
    ULONG MofListSize;
    PWMIMOFLIST MofList;
    ULONG RetSize=0;
    ULONG Status;
    
    //
    // Make an intelligent guess as to the size needed to get all of 
    // the MOF resources
    //
    *MofListPtr = NULL;
    MofListSize = MOFLISTSIZEGUESS * (sizeof(WMIMOFLIST) + 
                                          (MAX_PATH + 
                                           MAX_PATH) * sizeof(WCHAR));
                                       
    MofList = EtwpAlloc(MofListSize);
    if (MofList != NULL)
    {    
        Status = EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENUMERATE_MOF_RESOURCES,
                                      NULL,
                                      0,
                                      MofList,
                                      MofListSize,
                                      &RetSize,
                                      NULL);
              
        if ((Status == ERROR_SUCCESS) && (RetSize == sizeof(ULONG)))
        {
            //
            // The buffer was too small, but we now know how much we'll 
            // need.
            //
            MofListSize = MofList->MofListCount;
            EtwpFree(MofList);
            MofList = EtwpAlloc(MofListSize);
            if (MofList != NULL)
            {
                //
                // Now lets retry the query
                //
                Status = EtwpSendWmiKMRequest(NULL,
                                          IOCTL_WMI_ENUMERATE_MOF_RESOURCES,
                                          NULL,
                                          0,
                                          MofList,
                                          MofListSize,
                                          &RetSize,
                                          NULL);

            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS) 
    {
        if (RetSize >= sizeof(WMIMOFLIST))
        {
            *MofListPtr = MofList;
        } else {
            Status = ERROR_INVALID_PARAMETER;
            EtwpFree(MofList);
        }
    } else if (MofList != NULL) {
        EtwpFree(MofList);
    }
    return(Status);
}

PWCHAR EtwpRegistryToImagePath(
    PWCHAR ImagePath,
    PWCHAR RegistryPath
    )
/*++

Routine Description:

    This routine will determine the location of the device driver's image file
    from its registry path

Arguments:

    RegistryPath is a pointer to the driver's registry path

    ImagePath is buffer of length MAX_PATH and returns the image path

Return Value:

    pointer to Image path of driver or NULL if image path is unavailable

--*/
{
#define SystemRoot TEXT("\\SystemRoot\\")
#ifdef MEMPHIS
#define SystemRootDirectory TEXT("%WinDir%\\")
#else
#define SystemRootDirectory TEXT("%SystemRoot%\\")
#endif
#define SystemRootCharSize (( sizeof(SystemRoot) / sizeof(WCHAR) ) - 1)

#define DriversDirectory TEXT("\\System32\\Drivers\\")
#define NdisDriversDirectory TEXT("\\System\\")

#define QuestionPrefix TEXT("\\??\\")
#define QuestionPrefixSize (( sizeof(QuestionPrefix) / sizeof(WCHAR) ) - 1)

#define RegistryPrefix TEXT("\\Registry")
    HKEY RegKey;
    PWCHAR ImagePathPtr = NULL;
    ULONG ValueType;
    ULONG Size;
    PWCHAR DriverName;
    ULONG Len;
    BOOLEAN DefaultImageName;
    PWCHAR DriversDirectoryPath;
    WCHAR *Buffer;
    WCHAR *FullRegistryPath;
    WCHAR RegBuffer[DEFAULT_ALLOC_SIZE];
    
    Buffer = (PTCHAR)EtwpAlloc(2 * MAX_PATH * sizeof(WCHAR));
    if (Buffer != NULL)
    {
        FullRegistryPath = Buffer + MAX_PATH;

        //
        // Get the driver file name or the MOF image path from the KM
        // registry path. Here are the rules:
        //
        // 1. First check the MofImagePath value in the registry in case the
        //    mof resource is in a different file from the driver.
        // 2. Next check the ImagePath value since the mof resource is assumed
        //    to be part of the driver image.
        // 3. If no MofImagePath or ImagePath values then assume the mof resource
        //    is in the driver file and compose the driver file name as
        //    %SystemRoot%\System32\driver.sys.
        // 4. If MofImagePath or ImagePath was specified then
        //    - Check first char for % or second character for :, or prefix
        //      of \??\ and if so use EtwpExpandEnvironmentStringsW
        //    - Check first part of path for \SystemRoot\, if so rebuild string
        //      as %SystemRoot%\ and use ExpandEnvironementStrings
        //    - Assume format D below and prepend %SystemRoot%\ and use
        //      EtwpExpandEnvironmentStringsW

        // If MofImagePath or ImagePath value is present and it is a REG_EXPAND_SZ
        // then it is used to locate the file that holds the mof resource. It
        // can be in one of the following formats:
        //    Format A - %SystemRoot%\System32\Foo.Dll
        //    Format B -C:\WINNT\SYSTEM32\Drivers\Foo.SYS
        //    Format C - \SystemRoot\System32\Drivers\Foo.SYS
        //    Format D - System32\Drivers\Foo.Sys
        //    Format E - \??\c:\foo.sys


        Len = wcslen(RegistryPath);

        if (Len > 0)
        {
            DriverName = RegistryPath + Len;
            while ((*(--DriverName) != '\\') && (--Len > 0)) ;
        }

        if (Len == 0)
        {
            EtwpDebugPrint(("WMI: Badly formed registry path %ws\n", RegistryPath));
            EtwpFree(Buffer);
            return(NULL);
        }

        DriverName++;

        StringCchCopyW(FullRegistryPath,
					  MAX_PATH,
					  TEXT("System\\CurrentControlSet\\Services\\"));
        StringCchCatW(FullRegistryPath,
					 MAX_PATH,
					 DriverName);
        DefaultImageName = TRUE;

#if defined(_NTDLLBUILD_)

		StringCbPrintfW(RegBuffer,
					   DEFAULT_ALLOC_SIZE,
					   L"%ws\\%ws",
					   L"\\REGISTRY\\MACHINE",
					   FullRegistryPath);
        if (EtwpRegOpenKey(RegBuffer, &RegKey) == ERROR_SUCCESS)
        {
            
            ULONG cbSize;
            PKEY_VALUE_PARTIAL_INFORMATION Buf; 
            Size = MAX_PATH * sizeof(WCHAR);
            cbSize = Size + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

            Buf = EtwpAlloc(cbSize);

            if( Buf ) {

                UNICODE_STRING UnicodeString;
                RtlInitUnicodeString(&UnicodeString, L"MofImagePath");

                if( NtQueryValueKey(RegKey,
					    &UnicodeString,
					    KeyValuePartialInformation,
					    Buf,
					    Size,
					    &Size) == ERROR_SUCCESS)
                {
                    RtlCopyMemory(ImagePath, &Buf->Data[0], Buf->DataLength);
                    ValueType = Buf->Type;
                    DefaultImageName = FALSE;

                } else {

                    RtlInitUnicodeString(&UnicodeString, L"ImagePath");

                    if( NtQueryValueKey(RegKey,
					        &UnicodeString,
					        KeyValuePartialInformation,
					        Buf,
					        Size,
					        &Size) == ERROR_SUCCESS)
                    {
                        RtlCopyMemory(ImagePath, &Buf->Data[0], Buf->DataLength);
                        ValueType = Buf->Type;
                        DefaultImageName = FALSE;
                    }
                }
            }

            EtwpFree(Buf);
        }
#else
        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                                  FullRegistryPath,
                                 &RegKey) == ERROR_SUCCESS)
        {
            Size = MAX_PATH * sizeof(WCHAR);
            if (RegQueryValueEx(RegKey,
                                TEXT("MofImagePath"),
                                NULL,
                                &ValueType,
                                (PBYTE)ImagePath,
                                &Size) == ERROR_SUCCESS)
            {
                  DefaultImageName = FALSE;
            } else {
                Size = MAX_PATH * sizeof(WCHAR);
                if (RegQueryValueEx(RegKey,
                                    TEXT("ImagePath"),
                                    NULL,
                                    &ValueType,
                                    (PBYTE)ImagePath,
                                    &Size) == ERROR_SUCCESS)
                {
                    DefaultImageName = FALSE;
                }
            }
            NtClose(RegKey);
        }
#endif
        if ((DefaultImageName) ||
            ((ValueType != REG_EXPAND_SZ) && (ValueType != REG_SZ)) ||
            (Size < (2 * sizeof(WCHAR))))
        {
            //
            // No special ImagePath or MofImagePath so assume image file is
            // %SystemRoot%\System32\Drivers\Driver.Sys
            StringCchCopyW(Buffer,
						  MAX_PATH,
						  TEXT("%SystemRoot%\\System32\\Drivers\\"));
            StringCchCatW(Buffer, MAX_PATH, DriverName);
            StringCchCatW(Buffer, MAX_PATH, TEXT(".SYS"));
        } else {
            if (_wcsnicmp(ImagePath,
                          SystemRoot,
                          SystemRootCharSize) == 0)
            {
                //
                // Looks like format C
                StringCchCopyW(Buffer, MAX_PATH, SystemRootDirectory);
                StringCchCatW(Buffer, MAX_PATH, &ImagePath[SystemRootCharSize]);
            } else if ((*ImagePath == '%') ||
                       ( (Size > 3*sizeof(WCHAR)) && ImagePath[1] == TEXT(':')) )
            {
                //
                // Looks like format B or format A
                StringCchCopyW(Buffer, MAX_PATH, ImagePath);
            } else if (_wcsnicmp(ImagePath,
                                 QuestionPrefix,
                                 QuestionPrefixSize) == 0)
            {
                //
                // Looks like format E
                StringCchCopyW(Buffer, MAX_PATH, ImagePath+QuestionPrefixSize);
            } else {
                //
                // Assume format D
                StringCchCopyW(Buffer, MAX_PATH, SystemRootDirectory);
                StringCchCatW(Buffer, MAX_PATH, ImagePath);
            }
        }

#if defined(_NTDLLBUILD_)
        Size = EtwpExpandEnvironmentStringsW(Buffer,
                                        ImagePath,
                                        MAX_PATH);
#else
        Size = ExpandEnvironmentStrings(Buffer,
                                        ImagePath,
                                        MAX_PATH);
#endif

#ifdef MEMPHIS
        EtwpDebugPrint(("WMI: %s has mof in %s\n",
                         DriverName, ImagePath));
#else
        EtwpDebugPrint(("WMI: %ws has mof in %ws\n",
                         DriverName, ImagePath));
#endif
        EtwpFree(Buffer);
    } else {
        ImagePath = NULL;
    }

    return(ImagePath);
}

BOOLEAN
EtwpCopyMRString(
    PWCHAR Buffer,
    ULONG BufferRemaining,
    PULONG BufferUsed,
    PWCHAR SourceString
    )
{
    BOOLEAN BufferNotFull;
    ULONG len;
    
    len = wcslen(SourceString) + 1;
    if (len <= BufferRemaining)
    {
        wcscpy(Buffer, SourceString);
        *BufferUsed = len;
        BufferNotFull = TRUE;
    } else {
        BufferNotFull = FALSE;
    }
    return(BufferNotFull);
}

BOOLEAN
EtwpFileExists(
    PWCHAR FileName
    )
{
    HANDLE FindHandle;
    BOOLEAN Found;
    PWIN32_FIND_DATA FindData;

    FindData = (PWIN32_FIND_DATA)EtwpAlloc(sizeof(WIN32_FIND_DATA));

    if (FindData != NULL)
    {
        //
        // Now we need to make sure that the file a ctually exists
        //
#if defined(_NTDLLBUILD_)
        FindHandle = EtwpFindFirstFileW(FileName, FindData);
#else
        FindHandle = FindFirstFile(FileName, FindData);
#endif

        if (FindHandle == INVALID_HANDLE_VALUE)
        {
            Found = FALSE;
        } else {
#if defined(_NTDLLBUILD_)
            EtwpFindClose(FindHandle);
#else
            FindClose(FindHandle);
#endif
            Found = TRUE;
        }
        EtwpFree(FindData);
    } else {
        Found = FALSE;
    }
    return(Found);
}

ULONG EtwpGetWindowsDirectory(
    PWCHAR *s,
    PWCHAR Static,
    ULONG StaticSize
    )
{
    ULONG Size;
    ULONG Status = ERROR_SUCCESS;

#if defined(_NTDLLBUILD_)
    Size = EtwpGetSystemWindowsDirectoryW(Static, StaticSize);
#else
    Size = GetWindowsDirectory(Static, StaticSize);
#endif
    if (Size > StaticSize)
    {
        Size += sizeof(UNICODE_NULL);
        *s = EtwpAlloc(Size * sizeof(WCHAR));
        if (*s != NULL)
        {
#if defined(_NTDLLBUILD_)
    Size = EtwpGetSystemWindowsDirectoryW(*s, Size);
#else
    Size = GetWindowsDirectory(*s, Size);
#endif
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else if (Size == 0) {
#if defined(_NTDLLBUILD_)
        Status = EtwpGetLastError();
#else
        Status = GetLastError();
#endif
    } else {
        *s = Static;
    }

    if (Status == ERROR_SUCCESS)
    {
        if ( (*s)[Size-1] == L'\\')
        {
            (*s)[Size-1] = 0;
        }
    }
    return(Status);
}


ULONG
EtwpBuildMUIPath(
    PWCHAR Buffer,
    ULONG BufferRemaining,
    PULONG BufferUsed,
    PWCHAR EnglishPath,
    PWCHAR Language,
    PBOOLEAN BufferNotFull  
    )
{
    #define FallbackDir L"\\MUI\\Fallback\\"
    #define MUIPath L"\\MUI\\"
    #define MUITail L".mui"
    
    ULONG EnglishLen;
    PWCHAR WinDir;
    PWCHAR s, p;
    ULONG len;
    ULONG Status, SizeNeeded;
    PWCHAR LanguagePath;
    PWCHAR WinDirStatic;
    ULONG WinDirStaticSize;

    WinDirStaticSize = MAX_PATH+1;
    WinDirStatic = EtwpAlloc(WinDirStaticSize * sizeof(WCHAR));

    if (WinDirStatic != NULL)
    {
        Status = ERROR_FILE_NOT_FOUND;

        LanguagePath = Buffer;  

        EtwpDebugPrint(("WMI: Building MUI path for %ws in language %ws\n",
                             EnglishPath, Language));

        EnglishLen = wcslen(EnglishPath);
        p = EnglishPath + EnglishLen;
        len = EnglishLen;

        //
        // Work from the end of the string to try to find the last \ so
        // we can then slip in the language name
        //
        while ( (len != 0) && (*p != L'\\'))
        {
            len--;
            p--;
        }

        if (len != 0)
        {
            p++;
        }
        EtwpDebugPrint(("WMI: Tail of %ws is %ws\n", EnglishPath, p));

        //
        // First try looking in <path>\\MUI\\<lang id> which is where 3rd
        // parties will install their resource only drivers. We look for
        // foo.sys and then foo.sys.mui.
        //
        SizeNeeded = len + wcslen(Language) + wcslen(MUIPath) + 1 + wcslen(p) + 1 + wcslen(MUITail);

        if (SizeNeeded <= BufferRemaining)
        {
            if (len != 0)
            {
                wcsncpy(LanguagePath, EnglishPath, len);
                LanguagePath[len] = 0;
                wcscat(LanguagePath, MUIPath);
            } else {
                LanguagePath[len] = 0;
            }

            wcscat(LanguagePath, Language);
            wcscat(LanguagePath, L"\\");
            wcscat(LanguagePath, p);
            if (EtwpFileExists(LanguagePath))
            {
                *BufferUsed = wcslen(LanguagePath) + 1;
                *BufferNotFull = TRUE;
                Status = ERROR_SUCCESS;
                EtwpDebugPrint(("WMI: #1 - Found %ws\n", LanguagePath));
            } else {
                wcscat(LanguagePath, MUITail);
                if (EtwpFileExists(LanguagePath))
                {
                    *BufferUsed = wcslen(LanguagePath) + 1;
                    *BufferNotFull = TRUE;
                    Status = ERROR_SUCCESS;
                    EtwpDebugPrint(("WMI: #2 - Found %ws\n", LanguagePath));
                }           
            }
        } else {
            *BufferNotFull = FALSE;
            Status = ERROR_SUCCESS;
        }



        if (Status != ERROR_SUCCESS)
        {
            //
            // Next lets check the fallback directory,
            // %windir%\MUI\Fallback\<lang id>. This is where system components
            // are installed by default.
            //
            Status = EtwpGetWindowsDirectory(&WinDir,
                                        WinDirStatic,
                                        WinDirStaticSize);
            if (Status == ERROR_SUCCESS)
            {
                SizeNeeded = wcslen(WinDir) +
                             wcslen(FallbackDir) +
                             wcslen(Language) +
                             1 +
                             wcslen(p) + 1 +
                             wcslen(MUITail);

                if (SizeNeeded <= BufferRemaining)
                {
                    wcscpy(LanguagePath, WinDir);
                    wcscat(LanguagePath, FallbackDir);
                    wcscat(LanguagePath, Language);
                    wcscat(LanguagePath, L"\\");
                    wcscat(LanguagePath, p);
                    wcscat(LanguagePath, MUITail);

                    if ( EtwpFileExists(LanguagePath))
                    {
                        *BufferUsed = wcslen(LanguagePath) + 1;
                        *BufferNotFull = TRUE;
                        Status = ERROR_SUCCESS;
                        EtwpDebugPrint(("WMI: #3 - Found %ws\n", LanguagePath));
                    } else {
                        Status = ERROR_FILE_NOT_FOUND;
                    }
                } else {
                    *BufferNotFull = FALSE;
                    Status = ERROR_SUCCESS;
                }

                if (WinDir != WinDirStatic)
                {
                    EtwpFree(WinDir);
                }
            }
        }
        EtwpFree(WinDirStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return(Status);
}

typedef struct
{
    ULONG Count;
    ULONG MaxCount;
    PWCHAR *List;
} ENUMLANGCTX, *PENUMLANGCTX;


BOOL EnumUILanguageCallback(
    LPWSTR Language,
    LONG_PTR Context
)
{
    PENUMLANGCTX EnumLangCtx = (PENUMLANGCTX)Context;
    PWCHAR *p;
    PWCHAR w;
    ULONG NewMaxCount;

    if (EnumLangCtx->Count == EnumLangCtx->MaxCount)
    {
        NewMaxCount = EnumLangCtx->MaxCount * 2;
        p = EtwpAlloc( sizeof(PWCHAR) * NewMaxCount);
        if (p != NULL)
        {
            memset(p, 0, sizeof(PWCHAR) * NewMaxCount);
            memcpy(p, EnumLangCtx->List, EnumLangCtx->Count * sizeof(PWCHAR));
            EtwpFree(EnumLangCtx->List);
            EnumLangCtx->List = p;
            EnumLangCtx->MaxCount = NewMaxCount;
        } else {
            return(FALSE);
        }
    }

    w = EtwpAlloc( (wcslen(Language)+1) * sizeof(WCHAR) );
    if (w != NULL)
    {
        EnumLangCtx->List[EnumLangCtx->Count++] = w;
        wcscpy(w, Language);
    } else {
        return(FALSE);
    }
    
    return(TRUE);
}

ULONG
EtwpGetLanguageList(
    PWCHAR **List,
    PULONG Count
    )
{
    ENUMLANGCTX EnumLangCtx;
    BOOL b;
    ULONG Status;

    *List = NULL;
    *Count = 0;
    
    EnumLangCtx.Count = 0;
    EnumLangCtx.MaxCount = 8;
    EnumLangCtx.List = EtwpAlloc( 8 * sizeof(PWCHAR) );

    if (EnumLangCtx.List != NULL)
    {

#if defined(_NTDLLBUILD_)

        b = EtwpEnumUILanguages(EnumUILanguageCallback,
                            0,
                            (LONG_PTR)&EnumLangCtx);

#else

        b = EnumUILanguages(EnumUILanguageCallback,
                            0,
                            (LONG_PTR)&EnumLangCtx);
#endif

        if (b)
        {
            *Count = EnumLangCtx.Count;
            *List = EnumLangCtx.List;
            Status = ERROR_SUCCESS;
        } else {
            if (EnumLangCtx.List != NULL)
            {
                EtwpFree(EnumLangCtx.List);
            }
#if defined(_NTDLLBUILD_)
            Status = EtwpGetLastError();
#else
            Status = GetLastError();
#endif
        }
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}


BOOL
EtwpSynchReadFile(
    HANDLE LogFile, 
    LPVOID Buffer, 
    DWORD NumberOfBytesToRead, 
    LPDWORD NumberOfBytesRead,
    LPOVERLAPPED Overlapped
    ) 
/*++

Routine Description:
    This routine performs synchronous read on a given file. Since logfile is opened for
    asychronous IO, current file position is not available. Thus, for synch read, we need 
    to use this.

Arguments:
    LogFile - handle to file
    Buffer - data buffer
    NumberOfBytesToRead - number of bytes to read
    NumberOfBytesRead - number of bytes read
    Overlapped - overlapped structure

Returned Value:

    TRUE if succeeded.

--*/
{
    BOOL ReadSuccess;
    if (Overlapped == NULL || Overlapped->hEvent == NULL || Overlapped->hEvent == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
#if defined (_NTDLLBUILD_)
    if (!EtwpResetEvent(Overlapped->hEvent)) {
        return FALSE;
    }

    ReadSuccess = EtwpReadFile(LogFile,
                        Buffer,
                        NumberOfBytesToRead,
                        NULL,
                        Overlapped);
    if (ReadSuccess || EtwpGetLastError() == ERROR_IO_PENDING) {
        ReadSuccess = EtwpGetOverlappedResult(LogFile, Overlapped, NumberOfBytesRead, TRUE);
        if (!ReadSuccess && EtwpGetLastError() == ERROR_HANDLE_EOF) {
            *NumberOfBytesRead = 0;
            EtwpSetEvent(Overlapped->hEvent);
        }
        return ReadSuccess;
    }
    else {
        *NumberOfBytesRead = 0;
        EtwpSetEvent(Overlapped->hEvent);
        return FALSE;
    }
#else
    if (!ResetEvent(Overlapped->hEvent)) {
        return FALSE;
    }

    ReadSuccess = ReadFile(LogFile,
                        Buffer,
                        NumberOfBytesToRead,
                        NULL,
                        Overlapped);
    if (ReadSuccess || GetLastError() == ERROR_IO_PENDING) {
        ReadSuccess = GetOverlappedResult(LogFile, Overlapped, NumberOfBytesRead, TRUE);
        if (!ReadSuccess && GetLastError() == ERROR_HANDLE_EOF) {
            *NumberOfBytesRead = 0;
            SetEvent(Overlapped->hEvent);
        }
        return ReadSuccess;
    }
    else {
        *NumberOfBytesRead = 0;
        SetEvent(Overlapped->hEvent);
        return FALSE;
    }

#endif
}


PVOID
EtwpMemReserve(
    IN SIZE_T   Size
    )
{
    NTSTATUS Status;
    PVOID    lpAddress = NULL;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &lpAddress,
                    0,
                    &Size,
                    MEM_RESERVE,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return lpAddress;
    }
    else {
        EtwpSetDosError(EtwpNtStatusToDosError(Status));
        return NULL;
    }
}

PVOID
EtwpMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    )
{
    NTSTATUS Status;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &Buffer,
                    0,
                    &Size,
                    MEM_COMMIT,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return Buffer;
    }
    else {
        EtwpSetDosError(EtwpNtStatusToDosError(Status));
        return NULL;
    }
}

ULONG
EtwpMemFree(
    IN PVOID Buffer
    )
{
    NTSTATUS Status;
    SIZE_T Size = 0;
    HANDLE hProcess = NtCurrentProcess();

    if (Buffer == NULL) {
        EtwpSetDosError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    try {
        Status = NtFreeVirtualMemory( hProcess, &Buffer, &Size, MEM_RELEASE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return TRUE;
    }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (RtlFlushSecureMemoryCache(Buffer, Size)) {
                Status = NtFreeVirtualMemory(
                            hProcess, Buffer, &Size, MEM_RELEASE);
                if (NT_SUCCESS(Status)) {
                    return TRUE;
                }
            }
        }
        EtwpSetDosError(EtwpNtStatusToDosError(Status));
        return FALSE;
    }
}


ULONG EtwpConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    )
/*+++

Routine Description:

    This routine will convert the instance names in a WNODE_ALL_DATA to
    ansi. The conversion is done in place since we can assume that ansi
    strings are no longer than unicode strings.

Arguments:

    Wnode is the WNODE_ALL_DATA whose instance names are to be converted to
        ANSI

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG i;
    ULONG Linkage;
    ULONG InstanceCount;
    PULONG InstanceNameOffsets;
    PWCHAR Ptr;
    ULONG Status = ERROR_SUCCESS;

    EtwpAssert(!(Wnode->WnodeHeader.Flags & WNODE_FLAG_ANSI_INSTANCENAMES));

    do
    {
        Wnode->WnodeHeader.Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

        InstanceCount = Wnode->InstanceCount;
        InstanceNameOffsets = (PULONG)(((PUCHAR)Wnode) +
                                            Wnode->OffsetInstanceNameOffsets);
        for (i = 0; i < InstanceCount; i++)
        {
            Ptr = (PWCHAR)(((PUCHAR)Wnode) + InstanceNameOffsets[i]);
            try
            {
                Status = EtwpCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
            } except(EXCEPTION_EXECUTE_HANDLER) {
//                Wnode->WnodeHeader.Flags |= WNODE_FLAG_INVALID;
                return(ERROR_SUCCESS);
            }
            if (Status != ERROR_SUCCESS)
            {
#if defined (_NTDLLBUILD_)
                EtwpSetLastError(Status);
#else
                SetLastError(Status);
#endif
                goto Done;
            }
        }

        Linkage = Wnode->WnodeHeader.Linkage;
        Wnode = (PWNODE_ALL_DATA)(((PUCHAR)Wnode) + Linkage);
    } while (Linkage != 0);


Done:
    return(Status);
}

ULONG EtwpUnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    ){

    ANSI_STRING DestinationString;
    UNICODE_STRING SourceString;
    NTSTATUS Status;
    BOOLEAN AllocateString;
    ULONG AnsiLength;

    //
    // If output is null then return error as we don't have 
    // any place to put output string
    //

    if( ppszA==NULL ){

        return(STATUS_INVALID_PARAMETER_2);
    }

    //
    // If input is null then just return the same.
    //

    if (pszW == NULL)
    {
        *ppszA = NULL;
        return(ERROR_SUCCESS);
    }

    //
    // We ASSUME that if *ppszA!=NULL then we have sufficient
    // amount of memory to copy
    //

    AllocateString = ((*ppszA) == NULL );

    RtlInitUnicodeString(&SourceString,(LPWSTR)pszW);

    AnsiLength = RtlUnicodeStringToAnsiSize(&SourceString);

    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_1;
    }

    DestinationString.Length = (USHORT)(AnsiLength - 1);
    DestinationString.MaximumLength = (USHORT)AnsiLength;
    DestinationString.Buffer = EtwpAlloc(AnsiLength);

    if ( DestinationString.Buffer == NULL ) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlUnicodeStringToAnsiString( &DestinationString, &SourceString, FALSE);

    if( NT_SUCCESS(Status) ) {

        if( AllocateString ) {

            *ppszA = DestinationString.Buffer;

        } else {

            memcpy((*ppszA),DestinationString.Buffer,AnsiLength);
            EtwpFree(DestinationString.Buffer);
        }

        if (AnsiSizeInBytes != NULL){
            *AnsiSizeInBytes = DestinationString.Length;
        }
    } else {
        EtwpFree(DestinationString.Buffer);
    }

	return Status;
}

ULONG EtwpCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    )
/*++

Routine Description:

    Translate a counted ansi string into a counted unicode string.
    Conversion may be done inplace, that is Ansi == Unicode.

Arguments:

    Unicode is the counted unicode string to convert to ansi

    Ansi is the buffer to place the converted string into
        
Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCHAR APtr;
    PWCHAR WPtr;
    ULONG AnsiSize, UnicodeSize;
    ULONG Status;
    
    UnicodeSize = *Unicode;
    WPtr = EtwpAlloc(UnicodeSize + sizeof(WCHAR));
    if (WPtr != NULL)
    {
        memcpy(WPtr, Unicode + 1, UnicodeSize);
        WPtr[UnicodeSize/sizeof(WCHAR)] = UNICODE_NULL;

        APtr = NULL;

        Status = EtwpUnicodeToAnsi(WPtr, &APtr, &AnsiSize);

        if (Status == ERROR_SUCCESS)
        {
            *((PUSHORT)Ansi) = (USHORT)AnsiSize; 
            memcpy(Ansi+sizeof(USHORT), APtr, AnsiSize);
            Status = ERROR_SUCCESS;
            EtwpFree(APtr);
        } 
        EtwpFree(WPtr);        
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\dpapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dpapi.c

Abstract:
    
    WMI data provider api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include "wmiump.h"
#include "trcapi.h"


ULONG EtwpCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi        
    )
/*++

Routine Description:

    This routine will copy an ansi ro unicode C string to a counted unicode
    string.
        
Arguments:

    String is the ansi or unicode incoming string
        
    Counted string is a pointer to where to write counted unicode string
        
    *BytesUsed returns number of bytes used to build counted unicode string
        
    ConvertFromAnsi is TRUE if String is an ANSI string 

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    USHORT StringSize;
    PWCHAR StringPtr = CountedString+1;
    ULONG Status;
    
    if (ConvertFromAnsi)
    {
        StringSize = (strlen((PCHAR)String) +1) * sizeof(WCHAR);
        Status = EtwpAnsiToUnicode((PCHAR)String,
                               &StringPtr);
    } else {
        StringSize = (wcslen(String) +1) * sizeof(WCHAR);
        wcscpy(StringPtr, String);
        Status = ERROR_SUCCESS;
    }
    
    *CountedString = StringSize;
     *BytesUsed = StringSize + sizeof(USHORT);                

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\mofcheck\mofcheck.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mofcheck.c

Abstract:

    TODO: Enable localization

    Tool to validate that a binary MOF is valid for use with WMI

    Usage:

        wmimofck <binary mof file>


    Rules that are enforced by this program:

    * Any classes that do not have the WMI qualifier are ignored. Any class
      with the qualifier is a WMI class.
    * All WMI classes must have guids, including embedded classes.
    * All WMI classes that do not have special HMOM qualifiers [Dynamic,
      Provider("WMIProv")] are embedded only classes.
    * All non embedded WMI classes must have a property with the [key]
      qualifier named InstanceName, be of type string and NOT have a
      WmiDataId qualifier.
    * Embedded only classes should not have InstanceName or Active properties
    * All other properties in a WMI class must have a WmiDataId qualifier
      that specifies the position of the data item represented by the property
      within the data block represented by the class.
    * The property for the first data item in the data block must have
      WmiDataId(1). WmiDataId(0) is reserved.
    * WmiDataId qualifier values must be contiguous, ie, 1,2,3,4,5... There may
      not be any duplicate or missing WmiDataId values in a class.
    * The order of the properties as specified in the mof does not need to
      follow that of the WmiDataId
    * A property with a greater WmiDataId can not be marked with a WmiVersion
      qualifier whose value is lower than any properties with a lower WmiDataId
    * All embedded classes must be defined in the same mof
    * Only the following types are valid for properties:
        string, sint32, uint32, sint64, uint64, bool, sint16, uint16, char16
        sint8, uint8, datetime
    * Any variable length array must have a WmiSizeIs qualifier that specifies
      the property that holds the number of elements in the array. This
      property must be part of the same class as the variable length array,
      and this property must be an unsigned integer type (uint8, uint16,
      uint32, uint64)
    * Fixed length arrays must have the max qualifier.
    * An array may not be both fixed and variable length
    * Methods must have WmiMethodId qualifier with a unique value
    * Methods must have the Implemented qualifier
    * Methods must have a void return
    * Classes derrived from WmiEvent may not be abstract

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define STRSAFE_NO_DEPRECATE

#define WMI_USER_MODE

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <ctype.h>

#include "wmiump.h"
#include "bmof.h"
#include "mrcicode.h"

#ifdef WmipUnreferenceMC
#undef WmipUnreferenceMC
#endif
#define WmipUnreferenceMC(MofClass)

#ifdef WmipUnreferenceMR
#undef WmipUnreferenceMR
#endif
#define WmipUnreferenceMR(MofClass)

#ifdef WmipAllocMofResource
#undef WmipAllocMofResource
#endif
#define WmipAllocMofResource() WmipAlloc(sizeof(MOFRESOURCE))

#ifdef WmipAllocMofClass
#undef WmipAllocMofClass
#endif
#define WmipAllocMofClass() WmipAlloc(sizeof(MOFCLASS))


BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid);


#if DBG
BOOLEAN EtwpLoggingEnabled = FALSE;
#endif

#ifdef MEMPHIS
#if DBG
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}
#endif
#endif

TCHAR *MessageText[ERROR_WMIMOF_COUNT + 5] =
{
    TEXT("This file is not a valid binary mof file"),
    TEXT("There was not enough memory to complete an operation"),
    TEXT("Binary Mof file %s could not be opened"),

    TEXT("Unknown error code %d\n"),

//
// ERROR_WMIMOF_ messages start here
    TEXT("ERROR_WMIMOF_INCORRECT_DATA_TYPE"),
    TEXT("ERROR_WMIMOF_NO_DATA"),
    TEXT("ERROR_WMIMOF_NOT_FOUND"),
    TEXT("ERROR_WMIMOF_UNUSED"),
    TEXT("Property %ws in class %ws has no embedded class name"),
    TEXT("Property %ws in class %ws has an unknown data type"),
    TEXT("Property %ws in class %ws has no syntax qualifier"),
    TEXT("ERROR_WMIMOF_NO_SYNTAX_QUALIFIER"),
    TEXT("ERROR_WMIMOF_NO_CLASS_NAME"),
    TEXT("ERROR_WMIMOF_BAD_DATA_FORMAT"),
    TEXT("Property %ws in class %ws has the same WmiDataId %d as property %ws"),
    TEXT("Property %ws in class %ws has a WmiDataId of %d which is out of range"),
    TEXT("ERROR_WMIMOF_MISSING_DATAITEM"),
    TEXT("Property for WmiDataId %d is not defined in class %ws"),
    TEXT("Embedded class %ws not defined for Property %ws in Class %ws"),
    TEXT("Property %ws in class %ws has an incorrect [WmiVersion] qualifier"),
    TEXT("ERROR_WMIMOF_NO_PROPERTY_QUALIFERS"),
    TEXT("Class %ws has a badly formed or missing [guid] qualifier"),
    TEXT("Could not find property %ws which is the array size for property %ws in class %ws"),
    TEXT("A class could not be parsed properly"),
    TEXT("Wmi class %ws requires the qualifiers [Dynamic, Provider(\"WmiProv\")]"),
    TEXT("Error accessing binary mof file %s, code %d"),
    TEXT("Property InstanceName in class %ws must be type string and not %ws"),
    TEXT("Property Active in class %ws must be type bool and not %ws"),
    TEXT("Property %ws in class %ws does not have [WmiDataId()] qualifier"),
    TEXT("Property InstanceName in class %ws must have [key] qualifier"),
    TEXT("Class %ws and all its base classes do not have an InstanceName property"),
    TEXT("Class %ws and all its base classes do not have an Active qualifier"),
    TEXT("Property %ws in class %ws is an array, but doesn't specify a dimension"),
    TEXT("The element count property %ws for the variable length array %ws in class %ws is not an integral type"),
    TEXT("Property %ws in class %ws is both a fixed and variable length array"),
    TEXT("Embedded class %ws should be abstract or not have InstaneName or Active properties"),
    TEXT("Implemented qualifier required on method %ws in class %ws"),

    TEXT("WmiMethodId for method %ws in class %ws must be unique"),
    TEXT("WmiMethodId for method %ws in class %ws must be specified"),
    TEXT("WmiMethodId for method %ws in class %ws must not be 0"),
    TEXT("Class %ws is derived from WmiEvent and may not be [abstract]"),
    TEXT("The element count property for the variable length array %ws in class %ws is not a property of the class"),
    TEXT("An error occured resolving the variable length array property %ws in class %ws to element count property"),
    TEXT("Method %ws in class %ws must have return type void\n"),
    TEXT("Embedded class %ws should not have any methods\n")            
};


HANDLE FileHandle, MappingHandle;
TCHAR *BMofFileName;

BOOLEAN DoMethodHeaderGeneration;
BOOLEAN ForceHeaderGeneration;

//
// These global variables hold the compressed buffer and size
PVOID CompressedFileBuffer;
ULONG CompressedSize;

//
// These global variables hold the uncompressed buffer and size
PVOID FileBuffer;
ULONG UncompressedSize;

BOOLEAN SkipEmbedClassCheck;

void __cdecl ErrorMessage(
    BOOLEAN ExitProgram,
    ULONG ErrorCode,
    ...
    )
{
    va_list pArg;
    LONG Index;
    TCHAR *ErrorText;
    TCHAR Buffer[1024];

    UnmapViewOfFile(CompressedFileBuffer);
    CloseHandle(MappingHandle);
    CloseHandle(FileHandle);
    DeleteFile(BMofFileName);


    if (ErrorCode == ERROR_WMI_INVALID_MOF)
    {
        Index = 0;
    } else if (ErrorCode == ERROR_NOT_ENOUGH_MEMORY) {
        Index = 1;
    } else if (ErrorCode == ERROR_FILE_NOT_FOUND) {
        Index = 2;
    } else {
        Index = (-1 * ((LONG)ErrorCode)) + 4;
    }

    fprintf(stderr, "%s (0) : error RC2135 : ", BMofFileName);
    if ( (Index < 0) || (Index > (ERROR_WMIMOF_COUNT+4)))
    {
        ErrorText = MessageText[3];
        fprintf(stderr, ErrorText, ErrorCode);
    } else {
        ErrorText = MessageText[Index];
        va_start(pArg, ErrorCode);
        _vsnprintf(Buffer, sizeof(Buffer), ErrorText, pArg);
        Buffer[1023] = 0;
        fprintf(stderr, Buffer);
        fprintf(stderr, "\n");
    }

    if (ExitProgram)
    {
        ExitProcess(ErrorCode);
    }
}

typedef struct
{
    DWORD Signature;
    DWORD CompressionType;
    DWORD CompressedSize;
    DWORD UncompressedSize;
    BYTE Buffer[];
} COMPRESSEDHEADER, *PCOMPRESSEDHEADER;

ULONG WmipDecompressBuffer(
    IN PVOID CompressedBuffer,
    OUT PVOID *UncompressedBuffer,
    OUT ULONG *UncompressedSize
    )
/*++

Routine Description:

    This routine will decompress a compressed MOF blob into a buffer
    that can be used to interpert the blob.

Arguments:

    CompressedBuffer points at the compressed MOF blob

    *UncompressedBuffer returns with a pointer to the uncompressed
        MOF blob

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCOMPRESSEDHEADER CompressedHeader = (PCOMPRESSEDHEADER)CompressedBuffer;
    BYTE *Buffer;
    ULONG Status;

    if ((CompressedHeader->Signature != BMOF_SIG) ||
        (CompressedHeader->CompressionType != 1))
    {
        WmipDebugPrint(("WMI: Invalid compressed mof header\n"));
        Status = ERROR_WMI_INVALID_MOF;
    } else {
        Buffer = WmipAlloc(CompressedHeader->UncompressedSize);
        if (Buffer == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *UncompressedSize = Mrci1Decompress(&CompressedHeader->Buffer[0],
                                               CompressedHeader->CompressedSize,
                                               Buffer,
                                               CompressedHeader->UncompressedSize);

            if (*UncompressedSize != CompressedHeader->UncompressedSize)
            {
                WmipDebugPrint(("WMI: Invalid compressed mof buffer\n"));
                WmipFree(Buffer);
                Status = ERROR_WMI_INVALID_MOF;
            } else {
                *UncompressedBuffer = Buffer;
                Status = ERROR_SUCCESS;
            }
        }
    }
    return(Status);
}

ULONG WmipGetDataItemIdInMofClass(
    PMOFCLASSINFOW MofClassInfo,
    PWCHAR PropertyName,
    ULONG *DataItemIndex
    )
{
    PMOFDATAITEMW MofDataItem;
    ULONG i;

    for (i = 0; i < MofClassInfo->DataItemCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i];
        WmipAssert(MofDataItem->Name != NULL);
        if (_wcsicmp(PropertyName, MofDataItem->Name) == 0)
        {
            //
            // data item ids are 0 or 1 based depending if they are parameters
            // for a method or part of a data class. They match the
            // value in the MOF file while data item indexes within
            // the MofClassInfo structure are 0 based.
            *DataItemIndex = i;
            return(ERROR_SUCCESS);
        }
    }
    return(ERROR_WMIMOF_DATAITEM_NOT_FOUND);
}

PMOFCLASS WmipFindClassInMofResourceByGuid(
    PMOFRESOURCE MofResource,
    LPGUID Guid
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                     MOFCLASS,
                                     MCMRList);
        if (IsEqualGUID(&MofClass->MofClassInfo->Guid, Guid))
        {
            return(MofClass);
        }
        MofClassList = MofClassList->Flink;
    }
    return(NULL);
}


PMOFCLASS WmipFindClassInMofResourceByName(
    PMOFRESOURCE MofResource,
    PWCHAR ClassName
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                     MOFCLASS,
                                     MCMRList);
        if (_wcsicmp(MofClass->MofClassInfo->Name, ClassName) == 0)
        {
            return(MofClass);
        }
        MofClassList = MofClassList->Flink;
    }
    return(NULL);
}

ULONG WmipFillEmbeddedClasses(
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW MofClassInfo,
    BOOLEAN CleanupOnly
    )
{
    PWCHAR ClassName;
    PMOFDATAITEMW MofDataItem;
    ULONG i;
    PMOFCLASS EmbeddedMofClass;
    ULONG Status = ERROR_SUCCESS;
    WCHAR *EmbeddedClassName;

    for (i = 0; i < MofClassInfo->DataItemCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i];
        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            ClassName = (PWCHAR)MofDataItem->EcTempPtr;
#if DBG
            printf("Look for embdedded class %ws (%x) for %ws in class %ws\n",
                   ClassName, (ULONG_PTR)ClassName, MofDataItem->Name, MofClassInfo->Name);
#endif
            if (! CleanupOnly)
            {
                EmbeddedClassName = ClassName+(sizeof(L"object") / sizeof(WCHAR));
                EmbeddedMofClass = WmipFindClassInMofResourceByName(
                           MofResource,
                           EmbeddedClassName);
                if (EmbeddedMofClass != NULL)
                {
                    memcpy(&MofDataItem->EmbeddedClassGuid,
                           &EmbeddedMofClass->MofClassInfo->Guid,
                           sizeof(GUID));
                } else if (SkipEmbedClassCheck) {
                    MofDataItem->Flags |= MOFDI_FLAG_EC_GUID_NOT_SET;
                } else {
                    Status = ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND;
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND,
                                 EmbeddedClassName,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                }
            }

        // Don't free ClassName since we may use MofDataItem->EcTempPtr later

        }
    }

    //
    // Resolve guids for embedded classes in any method parameter classinfo
    //
    for (i = 0; i < MofClassInfo->MethodCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i+MofClassInfo->DataItemCount];
        WmipFillEmbeddedClasses(MofResource,
                                MofDataItem->MethodClassInfo,
                                CleanupOnly);
    }
    return(Status);
}


void WmipFreeMofClassInfo(
    PMOFCLASSINFOW MofClassInfo
    )
/*++

Routine Description:

    This routine frees any memory allocated for the MofClassInfo and then
    the MofClassInfo itself

Arguments:

    MofClassInfo is a pointer to a MofClassInfo structure

Return Value:


--*/
{
    ULONG i;
    PMOFDATAITEMW MofDataItem;

    WmipAssert(MofClassInfo != NULL);

    if (MofClassInfo != NULL)
    {
        if (MofClassInfo->Name != NULL)
        {
            WmipFree(MofClassInfo->Name);
        }

        if (MofClassInfo->Description != NULL)
        {
            WmipFree(MofClassInfo->Description);
        }

        for (i = 0; i < MofClassInfo->DataItemCount + MofClassInfo->MethodCount; i++)
        {
            MofDataItem = &MofClassInfo->DataItems[i];
            if (MofDataItem->Name != NULL)
            {
                WmipFree(MofDataItem->Name);
            }

            if (MofDataItem->Description != NULL)
            {
                WmipFree(MofDataItem->Description);
            }
        }
    }
}

ULONG WmipFindProperty(
    CBMOFObj * ClassObject,
    WCHAR * PropertyName,
    CBMOFDataItem *MofPropertyData,
    DWORD *ValueType,
    PVOID ValueBuffer
    )
/*++

Routine Description:

    This routine will find a named property within a class object

Arguments:

    ClassObject is the class object in which to search

    PropertyName is the name of the property to search for

    MofPropertyData returns with the property data

    *ValueType on entry has the property data type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *ValueType is 0xffffffff then any data type is acceptable

    ValueBuffer points to a buffer that returns the value of the
        property. If the property is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status;
    LONG i;

    if (FindProp(ClassObject, PropertyName, MofPropertyData))
    {
        if ((*ValueType != 0xffffffff) &&
            (MofPropertyData->m_dwType != *ValueType))
        {
            Status = ERROR_WMIMOF_INCORRECT_DATA_TYPE;
        }

        i = 0;
        if (GetData(MofPropertyData, (BYTE *)ValueBuffer, &i) == 0)
        {
            Status = ERROR_WMIMOF_NO_DATA;
        } else {
            *ValueType = MofPropertyData->m_dwType;
            Status = ERROR_SUCCESS;
        }
    } else {
        Status = ERROR_WMIMOF_NOT_FOUND;
    }
    return(Status);
}

ULONG WmipFindMofQualifier(
    CBMOFQualList *QualifierList,
    LPCWSTR QualifierName,
    DWORD *QualifierType,
    DWORD *NumberElements,
    PVOID QualifierValueBuffer
    )
/*++

Routine Description:

    This routine will find a MOF qualifier within the qualifier list passed,
    ensure that its type matches the type requested and return the qualifier's
    value

Arguments:

    QualifierList is the MOF qualifier list

    QualifierName is the name of the qualifier to search for

    *QualifierType on entry has the qualifier type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *QualifierType is 0xffffffff then any qualifier type is acceptable

    *NumberElements returns the number of elements in the array if the result
        of the qualifier is an array

    QualifierValueBuffer points to a buffer that returns the value of the
        qualifier. If the qualifier is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    CBMOFDataItem MofDataItem;
    ULONG Status;
    PUCHAR List, ListPtr;
    ULONG BaseTypeSize;
    ULONG ElementCount;
    ULONG i;

    if (FindQual(QualifierList, (PWCHAR)QualifierName, &MofDataItem))
    {
        if ((*QualifierType != 0xffffffff) &&
            (MofDataItem.m_dwType != *QualifierType))
        {
            Status = ERROR_WMIMOF_INCORRECT_DATA_TYPE;
        }

        if (MofDataItem.m_dwType & VT_ARRAY)
        {
            if (MofDataItem.m_dwType == (VT_BSTR | VT_ARRAY))
            {
                BaseTypeSize = sizeof(PWCHAR);
            } else {
                BaseTypeSize = iTypeSize(MofDataItem.m_dwType);
            }

            ElementCount = GetNumElements(&MofDataItem, 0);
            if (NumberElements != NULL)
            {
                *NumberElements = ElementCount;
            }

            if (ElementCount != -1)
            {
               List = WmipAlloc(ElementCount * BaseTypeSize);
               if (List != NULL)
               {
                   ListPtr = List;
                   for (i = 0; i < ElementCount; i++)
                   {
                       if ((GetData(&MofDataItem,
                                   (BYTE *)ListPtr,
                                   &i)) == 0)
                       {
                           WmipFree(List);
                           Status = ERROR_WMIMOF_NO_DATA;
                           return(Status);
                       }
                       ListPtr += BaseTypeSize;
                   }
                   Status = ERROR_SUCCESS;
                   *QualifierType = MofDataItem.m_dwType;
                   *((PVOID *)QualifierValueBuffer) = List;
               } else {
                   Status = ERROR_NOT_ENOUGH_MEMORY;
               }
            } else {
                Status = ERROR_WMIMOF_NOT_FOUND;
            }
        } else {
            if (GetData(&MofDataItem, (BYTE *)QualifierValueBuffer, 0) == 0)
            {
                Status = ERROR_WMIMOF_NO_DATA;
            } else {
                *QualifierType = MofDataItem.m_dwType;
                Status = ERROR_SUCCESS;
            }
        }
    } else {
        Status = ERROR_WMIMOF_NOT_FOUND;
    }
    return(Status);
}


MOFDATATYPE VTToMofDataTypeMap[] =
{
    MOFUnknown,                /* VT_EMPTY= 0, */
    MOFUnknown,                /* VT_NULL    = 1, */
    MOFInt16,                  /* VT_I2    = 2, */
    MOFInt32,                  /* VT_I4    = 3, */
    MOFUnknown,                /* VT_R4    = 4, */
    MOFUnknown,                /* VT_R8    = 5, */
    MOFUnknown,                /* VT_CY    = 6, */
    MOFUnknown,                /* VT_DATE    = 7, */
    MOFString,                 /* VT_BSTR    = 8, */
    MOFUnknown,                /* VT_DISPATCH    = 9, */
    MOFUnknown,                /* VT_ERROR    = 10, */
    MOFBoolean,                /* VT_BOOL    = 11, */
    MOFUnknown,                /* VT_VARIANT    = 12, */
    MOFUnknown,                /* VT_UNKNOWN    = 13, */
    MOFUnknown,                /* VT_DECIMAL    = 14, */
    MOFChar,                   /* VT_I1    = 16, */
    MOFByte,                   /* VT_UI1    = 17, */
    MOFUInt16,                 /* VT_UI2    = 18, */
    MOFUInt32,                 /* VT_UI4    = 19, */
    MOFInt64,                  /* VT_I8    = 20, */
    MOFUInt64,                 /* VT_UI8    = 21, */
};

MOFDATATYPE WmipVTToMofDataType(
    DWORD VariantType
    )
{
    MOFDATATYPE MofDataType;

    if (VariantType < (sizeof(VTToMofDataTypeMap) / sizeof(MOFDATATYPE)))
    {
        MofDataType = VTToMofDataTypeMap[VariantType];
    } else {
        MofDataType = MOFUnknown;
    }
    return(MofDataType);
}


ULONG WmipGetClassDataItemCount(
    CBMOFObj * ClassObject,
    PWCHAR QualifierToFind
    )
/*++

Routine Description:

    This routine will count the number of WMI data items in the class and
    the total number of properties in the class.

Arguments:

    ClassObject is class for which we count the number of data items

    *TotalCount returns the total number of properties

Return Value:

    Count of methods

--*/
{
    CBMOFQualList *PropQualifierList;
    CBMOFDataItem MofPropertyData;
    DWORD QualifierType;
    ULONG Counter = 0;
    WCHAR *PropertyName;
    ULONG Status;
    ULONG Index;

    ResetObj(ClassObject);
    while ((NextProp(ClassObject, &PropertyName, &MofPropertyData)) &&
           PropertyName != NULL)
    {
        PropQualifierList = GetPropQualList(ClassObject, PropertyName);
        if (PropQualifierList != NULL)
        {
            //
            // Get the id of the property so we know it order in class
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(PropQualifierList,
                                          QualifierToFind,
                                          &QualifierType,
                                          NULL,
                                          (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                Counter++;
            }
            BMOFFree(PropQualifierList);
        }
        BMOFFree(PropertyName);
    }

    return(Counter);
}

ULONG WmipGetClassMethodCount(
    CBMOFObj * ClassObject
)
/*++

Routine Description:

    This routine will count the number of WMI data items in the class

Arguments:

    ClassObject is class for which we count the number of data items

Return Value:

    Count of methods

--*/
{
    ULONG MethodCount;
    WCHAR *MethodName;
    CBMOFDataItem MofMethodData;

    ResetObj(ClassObject);
    MethodCount = 0;
    while(NextMeth(ClassObject, &MethodName, &MofMethodData))
    {
        MethodCount++;
        if (MethodName != NULL)
        {
            BMOFFree(MethodName);
        }
    }
    return(MethodCount);
}


ULONG WmipParsePropertyObject(
    OUT PMOFDATAITEMW MofDataItem,
    IN CBMOFDataItem *MofPropertyData,
    IN CBMOFQualList *PropQualifierList
    )
/*++

Routine Description:

    This routine will parse a BMOF object that is known to be an object that
    contains a property and fill int the MofDataItem that holds its
    information. If the routine detects an error then parsing will stop as
    the whole class will need to be rejected.


    No error messages are generated from this routine. The return error
    code is checked and an appropriate message generated.

Arguments:

    MofDataItem is the mof data item information structure to fill in

    MofPropertyData has the property information for the data item

    PropQualifierList has the qualifier list for the property

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    short BooleanValue;
    DWORD QualifierType;
    ULONG Status;
    WCHAR *StringPtr;
    ULONG FixedArraySize;
    DWORD VTDataType;
    DWORD VersionValue;
    BOOLEAN FreeString = TRUE;
    PMOFCLASSINFOW MethodClassInfo;
    ULONG MaxLen;
    
    //
    // Keep track of property and property qualifier objects
    MofDataItem->PropertyQualifierHandle = (ULONG_PTR)PropQualifierList;

    //
    // Get the description string which is not required
    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"description",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&MofDataItem->Description);

    //
    // Get the version value which is not required
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiVersion",
                                  &QualifierType,
                                  NULL,
                                  (PVOID)&VersionValue);
    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->Version = VersionValue;
    }

    //
    // Get read qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"read",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_READABLE;
    }

    //
    // Get write qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"write",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_WRITEABLE;
    }

    //
    // Get WmiEvent qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiEvent",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_EVENT;
    }

    //
    // See if this is a fixed length array
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"max",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&FixedArraySize);

    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->Flags |= MOFDI_FLAG_FIXED_ARRAY;
        MofDataItem->FixedArrayElements = FixedArraySize;
#if DBG
        printf(" Fixed Array");
#endif
    }

    //
    // See if this is a fixed length array
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"MaxLen",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&MaxLen);

    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->MaxLen = MaxLen;
    }

    //
    // See if maxmium length 
    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiSizeIs",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&StringPtr);

    if (Status == ERROR_SUCCESS)
    {
        if (MofDataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
        {
            BMOFFree(StringPtr);
            return(ERROR_WMIMOF_BOTH_FIXED_AND_VARIABLE_ARRAY);
        }
        MofDataItem->Flags |= MOFDI_FLAG_VARIABLE_ARRAY;

        //
        // When all properties are parsed we will come back and compute the
        // data item id for the data item that holds the number of elements
        // in the array. For now we'll hang onto the string pointer
        MofDataItem->VarArrayTempPtr = StringPtr;
#if DBG
        printf(" Variable Array of %ws", StringPtr);
#endif
    }

    if ((MofPropertyData->m_dwType & VT_ARRAY) &&
        ((MofDataItem->Flags & (MOFDI_FLAG_VARIABLE_ARRAY | MOFDI_FLAG_FIXED_ARRAY)) == 0))
    {
        return(ERROR_WMIMOF_MUST_DIM_ARRAY);
    }

    //
    // Now figure out the data type and size of the data item
    VTDataType = MofPropertyData->m_dwType & ~(VT_ARRAY | VT_BYREF);

    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                      L"CIMTYPE",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&StringPtr);

    if (VTDataType == VT_DISPATCH)
    {
        //
        // This is an embedded class
        MofDataItem->DataType = MOFEmbedded;

        if (Status == ERROR_SUCCESS)
        {
            //
            // We will resolve the class name to its guid later so we
            // just hang onto the embedded class name here.
            MofDataItem->EcTempPtr = StringPtr;
            MofDataItem->Flags |= MOFDI_FLAG_EMBEDDED_CLASS;
#if DBG
            printf(" Embedded Class of %ws (%x)", StringPtr, (ULONG_PTR)StringPtr);
#endif
        } else {
            return(ERROR_WMIMOF_NO_EMBEDDED_CLASS_NAME);
        }
    } else {
        if (Status == ERROR_SUCCESS)
        {
            if (_wcsnicmp(StringPtr, L"object:", 7) == 0) {
                MofDataItem->DataType = MOFEmbedded;
                MofDataItem->EcTempPtr = StringPtr;
                MofDataItem->Flags |= MOFDI_FLAG_EMBEDDED_CLASS;
                FreeString = FALSE;
#if DBG
                printf(" Embedded Class of %ws (%x)", StringPtr, (ULONG_PTR)StringPtr);
#endif
            } else if (_wcsicmp(StringPtr, L"string") == 0) {
                MofDataItem->DataType = MOFString;
            } else if (_wcsicmp(StringPtr, L"sint32") == 0) {
                MofDataItem->DataType = MOFInt32;
                MofDataItem->SizeInBytes = 4;
            } else if (_wcsicmp(StringPtr, L"uint32") == 0) {
                MofDataItem->DataType = MOFUInt32;
                MofDataItem->SizeInBytes = 4;
            } else if (_wcsicmp(StringPtr, L"boolean") == 0) {
                MofDataItem->DataType = MOFBoolean;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"sint64") == 0) {
                MofDataItem->DataType = MOFInt64;
                MofDataItem->SizeInBytes = 8;
            } else if (_wcsicmp(StringPtr, L"uint64") == 0) {
                MofDataItem->DataType = MOFUInt64;
                MofDataItem->SizeInBytes = 8;
            } else if ((_wcsicmp(StringPtr, L"sint16") == 0) ||
                       (_wcsicmp(StringPtr, L"char16") == 0)) {
                MofDataItem->DataType = MOFInt16;
                MofDataItem->SizeInBytes = 2;
            } else if (_wcsicmp(StringPtr, L"uint16") == 0) {
                MofDataItem->DataType = MOFUInt16;
                MofDataItem->SizeInBytes = 2;
            } else if (_wcsicmp(StringPtr, L"sint8") == 0) {
                MofDataItem->DataType = MOFChar;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"uint8") == 0) {
                MofDataItem->DataType = MOFByte;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"datetime") == 0) {
                MofDataItem->DataType = MOFDate;
                MofDataItem->SizeInBytes = 25;
            } else {
                WmipDebugPrint(("WMI: Unknown data item syntax %ws\n",
                                  StringPtr));
                BMOFFree(StringPtr);
                return(ERROR_WMIMOF_UNKNOWN_DATA_TYPE);
            }

            if (FreeString)
            {
                BMOFFree(StringPtr);
            }

            //
            // If fixed array then multiply number elements by element size
            if ((MofDataItem->SizeInBytes != 0) &&
                (MofDataItem->Flags & MOFDI_FLAG_FIXED_ARRAY))
            {
                MofDataItem->SizeInBytes *= MofDataItem->FixedArrayElements;
            }
        } else {
            WmipDebugPrint(("WMI: No Syntax qualifier for %ws\n",
            MofDataItem->Name));
            return(ERROR_WMIMOF_NO_SYNTAX_QUALIFIER);
        }
    }
    return(ERROR_SUCCESS);
}

ULONG WmipParseMethodObject(
    CBMOFDataItem *MofMethodData,
    CBMOFQualList *PropQualifierList,
    PULONG MethodId
    )
{
    ULONG UlongValue;
    ULONG Status;
    DWORD QualifierType;
    short BooleanValue;
    
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"Implemented",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status != ERROR_SUCCESS) || (! BooleanValue))
    {
        return(ERROR_WMIMOF_IMPLEMENTED_REQUIRED);
    }

    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiMethodId",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&UlongValue);

    if (Status != ERROR_SUCCESS)
    {
        return(ERROR_WMIMOF_IMPLEMENTED_REQUIRED);
    }

    if (UlongValue == 0)
    {
        return(ERROR_WMIMOF_METHODID_ZERO);
    }

    *MethodId = UlongValue;


    return(ERROR_SUCCESS);
}

ULONG WmipResolveVLArray(
    IN PMOFCLASSINFOW MofClassInfo,
    IN OUT PMOFDATAITEMW MofDataItem,
    IN ULONG FinalStatus
)
/*++

Routine Description:

    This routine will resolve the array index for a variable length array

Arguments:

    MofCLassInfo is the class info for the class

    MofDataItem is the mof data item that is a variable length array and
        whole index needs to be resolved.

    FinalStatus is the status of the mof parsing previously done for the
        class

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    MOFDATATYPE ArraySizeDataType;
    PWCHAR PropertyName;
    ULONG Status;
    ULONG Index;

    PropertyName = (PWCHAR)MofDataItem->VarArrayTempPtr;
    if (FinalStatus == ERROR_SUCCESS)
    {
        //
        // Only resolve this in the case where the class parsing
        // has not failed. We kept the name of the property containing the
        // number of elements in the array handy, so we need to
        // resolve it to its data item id and free the name.
        //
        Status = WmipGetDataItemIdInMofClass(MofClassInfo,
                                       PropertyName,
                                       &Index);
            

            
            
        if (Status != ERROR_SUCCESS)
        {
            FinalStatus = Status;
        } else {
            if ((MofClassInfo->Flags & MOFCI_FLAG_METHOD_PARAMS) ==
                              MOFCI_FLAG_METHOD_PARAMS)
            {
                MofDataItem->VariableArraySizeId = Index;
            } else {
                MofDataItem->VariableArraySizeId = Index + 1;
        }
        
            ArraySizeDataType = MofClassInfo->DataItems[Index].DataType;
            if ((ArraySizeDataType != MOFInt32) &&
                (ArraySizeDataType != MOFUInt32) &&
                (ArraySizeDataType != MOFInt64) &&
                (ArraySizeDataType != MOFUInt64) &&
                (ArraySizeDataType != MOFInt16) &&
                (ArraySizeDataType != MOFUInt16))
            {
                FinalStatus = ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE;
            }
        }
    }
    BMOFFree(PropertyName);
    PropertyName = NULL;

    return(FinalStatus);
}


ULONG WmipParseMethodInOutObject(
    CBMOFObj *ClassObject,
    PMOFCLASSINFOW ClassInfo,
    ULONG DataItemCount
)
/*++

Routine Description:

    This routine will parse a class object that is either the in or out
    parameters for a method.

Arguments:

    ClassObject is the in or out parameter class object to parse

    ClassInfo returns updated with information from ClassObject

    DataItemCount is the number of data items in the ClassInfo

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status = ERROR_WMIMOF_NO_DATA;
    CBMOFDataItem MofPropertyData;
    PWCHAR PropertyName = NULL;
    ULONG Index;
    PMOFDATAITEMW MofDataItem;
    CBMOFQualList *PropQualifierList = NULL;
    DWORD QualifierType;
    short BooleanValue;

    ResetObj(ClassObject);

    ClassInfo->ClassQualifierHandle = (ULONG_PTR)GetQualList(ClassObject);
    
    while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
    {
        PropQualifierList = GetPropQualList(ClassObject, PropertyName);
        if (PropQualifierList != NULL)
        {

            //
            // Get the id of the property so we know its order in class
            //
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(PropQualifierList,
                                              L"Id",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                //
                // Method ids are 0 based
                //
                if (Index < DataItemCount)
                {
                    //
                    // Valid data item id, make sure it already isn't
                    // in use. Note that we could have the same property
                    // be in both the in and the out class objects
                    //
                    MofDataItem = &ClassInfo->DataItems[Index];


                    //
                    // See if this is an input, output or both
                     //
                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                              L"in",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MofDataItem->Flags |= MOFDI_FLAG_INPUT_METHOD;
                    }

                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                              L"out",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MofDataItem->Flags |= MOFDI_FLAG_OUTPUT_METHOD;
                    }


                    if ((MofDataItem->Name != NULL) &&
                        (wcscmp(MofDataItem->Name, PropertyName) != 0))
                    {
                        //
                        // id already in use
                        //
                        Status = ERROR_WMIMOF_DUPLICATE_ID;
                        goto done;
                    }

                    if (MofDataItem->Name == NULL)
                    {
                        MofDataItem->Name = PropertyName;
                    } else {
                        BMOFFree(PropertyName);
                    }
                    PropertyName = NULL;

                    Status = WmipParsePropertyObject(
                                              MofDataItem,
                                              &MofPropertyData,
                                              PropQualifierList);

                    if (Status != ERROR_SUCCESS)
                    {
                        if (Status == ERROR_WMIMOF_MUST_DIM_ARRAY)
                        {
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_MUST_DIM_ARRAY,
                                    MofDataItem->Name,
                                    L"<Method>");                                        
                        }
                        goto done;
                    }
                } else {
                    //
                    // Method ID qualifier is out of range
                    //
                    Status = ERROR_WMIMOF_BAD_DATAITEM_ID;
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_BAD_DATAITEM_ID,
                                    MofDataItem->Name,
                                    L"<Method>",
                                 Index+1);
                    
                    goto done;
                }
            } else {
                //
                // property is supposed to have a method id !!
                //
                Status = ERROR_WMIMOF_METHOD_RETURN_NOT_VOID;
                goto done;
            }
        }
    }

done:
    if (PropertyName != NULL)
    {
        BMOFFree(PropertyName);
        PropertyName = NULL;
    }

    if (PropQualifierList != NULL)
    {
        BMOFFree(PropQualifierList);
    }

    return(Status);
}


ULONG WmipParseMethodParameterObjects(
    IN CBMOFObj *InObject,
    IN CBMOFObj *OutObject,
    OUT PMOFCLASSINFOW *ClassInfo
    )
/*++

Routine Description:

    This routine will parse the in and out method parameter obejcts to create
    a MOFCLASSINFO that describes the method call.

Arguments:

    InObject is the object with the input parameters

    OutObject is the object with the output parameters

    *ClassInfo returns with the class info for the method call

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    PMOFCLASSINFOW MofClassInfo;
    ULONG Status, FinalStatus;
    DWORD QualifierType;
    ULONG DataItemCount;
    ULONG MofClassInfoSize;
    WCHAR *StringPtr;
    ULONG i, Index;
    ULONG InItemCount, OutItemCount;
    ULONG Size;
    PMOFDATAITEMW MofDataItem;
    ULONG Count;

    FinalStatus = ERROR_SUCCESS;
    
    if (InObject != NULL)
    {
        ResetObj(InObject);
        InItemCount = WmipGetClassDataItemCount(InObject, L"Id");
    } else {
        InItemCount = 0;
    }

    if (OutObject != NULL)
    {
        ResetObj(OutObject);
        OutItemCount = WmipGetClassDataItemCount(OutObject, L"Id");
    } else {
        OutItemCount = 0;
    }

    DataItemCount = InItemCount + OutItemCount;

    Size = sizeof(MOFCLASSINFOW) + DataItemCount * sizeof(MOFDATAITEMW);
    MofClassInfo = WmipAlloc(Size);
    if (MofClassInfo == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get the essential information to fill in the MOF class info
    memset(MofClassInfo, 0, Size);
    MofClassInfo->Flags |= MOFCI_FLAG_METHOD_PARAMS;

    MofClassInfo->DataItems = (PMOFDATAITEMW) ((PUCHAR)MofClassInfo +
                                                   sizeof(MOFCLASSINFOW));

    //
    // number of properties/data items in class
    MofClassInfo->DataItemCount = DataItemCount;
    MofClassInfo->MethodCount = 0;

    //
    // Parse the input parameter class object
    //
    if (InObject != NULL)
    {
        Status = WmipParseMethodInOutObject(InObject,
                                            MofClassInfo,
                                            DataItemCount);
        if (Status == ERROR_SUCCESS)
        {
            if (OutObject != NULL)
            {
                //
                // Parse the output parameter class object
                //
                Status = WmipParseMethodInOutObject(OutObject,
                                                    MofClassInfo,
                                                    DataItemCount);
            }

            //
            // Now do any post parsing validation and fixup any variable
            // length array properties
            //
            FinalStatus = Status;
            Count = MofClassInfo->DataItemCount;
            for (Index = 0; Index < Count; Index++)
            {
                MofDataItem = &MofClassInfo->DataItems[Index];

                if (MofDataItem->Name == NULL)
                {
                    MofClassInfo->DataItemCount--;
                }

                if (MofDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY)
                {
                    FinalStatus = WmipResolveVLArray(MofClassInfo,
                                                     MofDataItem,
                                                     FinalStatus);
                    if (FinalStatus != ERROR_SUCCESS)
                    {
                        ErrorMessage(TRUE,
                                     ERROR_WMIMOF_VL_ARRAY_NOT_FOUND,
                                     MofDataItem->Name,
                                     L"<Method>");                                
                    }
                }
            }
        } else {
            FinalStatus = Status;
        }
    }

    *ClassInfo = MofClassInfo;

    return(FinalStatus);
}


ULONG WmipParseMethodParameters(
    CBMOFDataItem *MofMethodData,
    PMOFCLASSINFOW *MethodClassInfo
)
{
    ULONG Status = ERROR_SUCCESS;
    CBMOFObj *InObject;
    CBMOFObj *OutObject;
    ULONG i;
    ULONG NumberDimensions;
    ULONG NumberElements;
    VARIANT InVar, OutVar;
    DWORD SimpleType;

    SimpleType = MofMethodData->m_dwType & ~VT_ARRAY & ~VT_BYREF;

    NumberDimensions = GetNumDimensions(MofMethodData);
    if (NumberDimensions > 0)
    {
        NumberElements = GetNumElements(MofMethodData, 0);
        WmipAssert(NumberDimensions == 1);
        WmipAssert((NumberElements == 1) || (NumberElements == 2));

        i = 0;
        memset((void *)&InVar.lVal, 0, 8);

        if (GetData(MofMethodData, (BYTE *)&(InVar.lVal), &i))
        {
            InObject = (CBMOFObj *)InVar.bstrVal;
            InVar.vt = (VARTYPE)SimpleType;
            WmipAssert(InVar.vt ==  VT_UNKNOWN);

            if (NumberElements == 2)
            {
                i = 1;
                memset((void *)&OutVar.lVal, 0, 8);
                if (GetData(MofMethodData, (BYTE *)&(OutVar.lVal), &i))
                {
                    OutVar.vt = (VARTYPE)SimpleType;
                    WmipAssert(OutVar.vt ==  VT_UNKNOWN);
                    OutObject = (CBMOFObj *)OutVar.bstrVal;
                } else {
                    Status = ERROR_WMIMOF_NOT_FOUND;
                }
            } else {
                OutObject = NULL;
            }
        } else {
            Status = ERROR_WMIMOF_NOT_FOUND;
        }
    } else {
        InObject = NULL;
        OutObject = NULL;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipParseMethodParameterObjects(InObject,
                                                 OutObject,
                                                 MethodClassInfo);      
    }

    return(Status);
}

ULONG WmipParseClassObject(
    PMOFRESOURCE MofResource,
    CBMOFObj * ClassObject
    )
/*++

Routine Description:

    This routine will parse a BMOF object that is known to be an object that
    contains a class. If we run into a parsing error then we immediate
    quit parsing the class and return an error.

Arguments:

    MofResource is the Mof Resource structure

    ClassObject is BMOF object to parse

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    PMOFCLASSINFOW MofClassInfo;
    CBMOFQualList *ClassQualifierList = NULL;
    CBMOFQualList *PropQualifierList = NULL;
    CBMOFQualList *MethQualifierList = NULL;
    CBMOFDataItem MofPropertyData, MofMethodData;
    ULONG Status;
    DWORD QualifierType;
    ULONG DataItemCount;
    ULONG MofClassInfoSize;
    WCHAR *PropertyName = NULL;
    WCHAR *MethodName = NULL;
    ULONG Index;
    PMOFDATAITEMW MofDataItem;
    WCHAR *StringPtr;
    PMOFCLASS MofClass;
    ULONG FailedStatus;
    ULONG Version;
    short BooleanValue;
    WCHAR *ClassName;
    BOOLEAN DynamicQualifier, ProviderQualifier;
    PULONG MethodList = 0;
    ULONG MethodCount, MethodId;
    ULONG i, Size;
    BOOLEAN IsEvent;
    PMOFCLASSINFOW MethodClassInfo;
    BOOLEAN AbstractClass = FALSE;

    //
    // Get the class name which is required
    if (! GetName(ClassObject, &ClassName))
    {
        WmipDebugPrint(("WMI: MofClass does not have a name\n"));
        Status = ERROR_WMIMOF_NO_CLASS_NAME;
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(Status);
    }

#if DBG
    printf("Parsing class %ws\n", ClassName);
#endif

    ResetObj(ClassObject);
    ClassQualifierList = GetQualList(ClassObject);
    if (ClassQualifierList == NULL)
    {
        WmipDebugPrint(("WMI: MofClass %ws does not have a qualifier list\n",
                        ClassName));
        Status = ERROR_WMIMOF_NO_CLASS_NAME;
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(Status);
    }

    //
    // Classes derived from WmiEvent may not be [abstract]

    QualifierType = VT_BSTR;
    Status = WmipFindProperty(ClassObject,
                                  L"__SUPERCLASS",
                                  &MofPropertyData,
                                  &QualifierType,
                                  (PVOID)&StringPtr);
    if (Status == ERROR_SUCCESS)
    {
        IsEvent = (_wcsicmp(StringPtr, L"WmiEvent") == 0);
    } else {
        IsEvent = FALSE;
    }
    
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Abstract",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        //
        // This is an abstract class - make sure it is not derived from
        // WmiEvent
        AbstractClass = TRUE;
        QualifierType = VT_BSTR;
        Status = WmipFindProperty(ClassObject,
                                  L"__SUPERCLASS",
                                  &MofPropertyData,
                                  &QualifierType,
                                  (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            if (_wcsicmp(StringPtr, L"WmiEvent") == 0)
            {
                ErrorMessage(TRUE,
                     ERROR_WMIMOF_WMIEVENT_ABSTRACT,
                     ClassName);
                 return(ERROR_WMIMOF_WMIEVENT_ABSTRACT);
            }
            BMOFFree(StringPtr);
        }
    }

    //
    // See if this is a WMI class. Wmi classes have the [WMI] qualifier
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"WMI",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    if (! ((Status == ERROR_SUCCESS) && BooleanValue))
    {
        //
        // Skip this non-wmi class
        return(ERROR_SUCCESS);
    }

    //
    // Now check for WBEM required qualifiers
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Dynamic",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    DynamicQualifier = ((Status == ERROR_SUCCESS) && BooleanValue);


    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Provider",
                                      &QualifierType,
                                      NULL,
                                      (PVOID)&StringPtr);

    if (Status == ERROR_SUCCESS)
    {
        if (_wcsicmp(StringPtr, L"WmiProv") != 0)
        {
            Status = ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS;
        }
        BMOFFree(StringPtr);
        ProviderQualifier = TRUE;
    } else {
        ProviderQualifier = FALSE;
    }


    if ((ProviderQualifier && ! DynamicQualifier) ||
        (! ProviderQualifier && DynamicQualifier))
    {
        //
        // Both or neither [Dynamic, Provider(WmiProv)] qualifiers are required
        ErrorMessage(TRUE,
                     ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS,
                     ClassName);
        return(ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS);
    }


    MofClass = WmipAllocMofClass();
    if (MofClass == NULL)
    {
        //
        // No memory for MofClass so give up
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Reference the MofResource so it stays around while the MofClass
    // stays around
    MofClass->MofResource = MofResource;
    WmipReferenceMR(MofResource);

    DataItemCount = WmipGetClassDataItemCount(ClassObject, L"WmiDataId");
    MethodCount = WmipGetClassMethodCount(ClassObject);
    ResetObj(ClassObject);

    Size = sizeof(MOFCLASSINFO);

    MofClassInfoSize = Size +
                        (DataItemCount+MethodCount) * sizeof(MOFDATAITEMW);
    MofClassInfo = WmipAlloc(MofClassInfoSize);
    if (MofClassInfo == NULL)
    {
        // WmipMCCleanup will unreference the MofResource
        WmipUnreferenceMC(MofClass);
        return(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        MofClass->MofClassInfo = MofClassInfo;
        MofClass->ClassObjectHandle = (ULONG_PTR)ClassObject;

        //
        // Get the essential information to fill in the MOF class info
        memset(MofClassInfo, 0, MofClassInfoSize);

        MofClass->MofClassInfo->ClassQualifierHandle = (ULONG_PTR)GetQualList(ClassObject);
        WmipAssert(MofClass->MofClassInfo->ClassQualifierHandle != 0);
        
        MofClassInfo->Flags = MOFCI_FLAG_READONLY;
        MofClassInfo->Flags |= IsEvent ? MOFCI_FLAG_EVENT : 0;
        MofClassInfo->Flags |= ProviderQualifier ? MOFCI_RESERVED0 : 0;

        if (!ProviderQualifier && !DynamicQualifier)
        {
             //
            // If neither the provider qualifier and Dynamic qualifier are
            // specified then this is an embedded class
            //
            MofClassInfo->Flags |= MOFCI_FLAG_EMBEDDED_CLASS;
        }

        MofClassInfo->DataItems = (PMOFDATAITEMW) ((PUCHAR)MofClassInfo +
                                                   Size);

        //
        // number of properties/data items in class
        MofClassInfo->DataItemCount = DataItemCount;
        MofClassInfo->MethodCount = MethodCount;

        MofClassInfo->Name = ClassName;

        ClassQualifierList = GetQualList(ClassObject);
        if (ClassQualifierList == NULL)
        {
            WmipDebugPrint(("WMI: MofClass %ws does not have a qualifier list\n",
                            MofClassInfo->Name));
            Status = ERROR_WMIMOF_NO_CLASS_NAME;
            ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
            goto done;
        }

        //
        // Get the class guid which is required. Then convert it into
        // binary form.
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"guid",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            Status = wGUIDFromString(StringPtr , &MofClassInfo->Guid) ?
                                        ERROR_SUCCESS :
                                        ERROR_WMIMOF_BAD_DATA_FORMAT;
            BMOFFree((PVOID)StringPtr);

        }
        if (Status != ERROR_SUCCESS)
        {
            WmipDebugPrint(("WMI: MofClass %ws guid not found or in incorrect format\n",
                           MofClassInfo->Name));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_BAD_OR_MISSING_GUID,
                         MofClassInfo->Name);
            goto done;
        }


        //
        // Get the description string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"description",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->Description);


        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"HeaderName",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->HeaderName);

        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"GuidName1",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->GuidName1);


        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"GuidName2",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->GuidName2);

        //
        // Now gather all of the information about the data items/properties
        ResetObj(ClassObject);
        Status = ERROR_SUCCESS;
        while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
        {
#if DBG
            printf("    %ws - ", PropertyName);
#endif
            PropQualifierList = GetPropQualList(ClassObject, PropertyName);
            if (PropQualifierList != NULL)
            {
                //
                // Get the id of the property so we know its order in class
                // If it doesn't have an id then we ignore it
                QualifierType = VT_I4;
                Status = WmipFindMofQualifier(PropQualifierList,
                                              L"WmiDataId",
                                              &QualifierType,
                                          NULL,
                                              (PVOID)&Index);
                if (Status == ERROR_SUCCESS)
                {
                    //
                    // Wmi Data Item ids are 1 based in the MOF
                    Index--;
                    if (Index < DataItemCount)
                    {
                        //
                        // Valid data item id, make sure it already isn't
                        // in use.
                        MofDataItem = &MofClassInfo->DataItems[Index];
                        if (MofDataItem->Name != NULL)
                        {
                            WmipDebugPrint(("WMI: Mof Class %ws has duplicate data item id %d for %ws and %ws\n",
                                 MofClassInfo->Name, Index,
                                 MofDataItem->Name, PropertyName));
                            Status = ERROR_WMIMOF_DUPLICATE_ID;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_DUPLICATE_ID,
                                         MofDataItem->Name,
                                          MofClassInfo->Name,
                                         Index+1,
                                         PropertyName);
                            goto done;
                        }
                        MofDataItem->Name = PropertyName;
                        PropertyName = NULL;
                        Status = WmipParsePropertyObject(
                                              MofDataItem,
                                              &MofPropertyData,
                                              PropQualifierList);
                        if (Status != ERROR_SUCCESS)
                        {
                            WmipDebugPrint(("WMI: MofClass %ws Property %ws not parsed properly %x\n",
                                        MofClassInfo->Name, MofDataItem->Name, Status));
                            ErrorMessage(TRUE,
                                         Status,
                                          MofDataItem->Name,
                                          MofClassInfo->Name);
                            goto done;
                        }

                        if (MofDataItem->Flags & MOFDI_FLAG_WRITEABLE)
                        {
                            MofClassInfo->Flags &= ~MOFCI_FLAG_READONLY;
                        }
                    } else {
                        WmipDebugPrint(("WMI: MofClass %ws has DataItem Id for %ws out of range %d\n",
                            MofClassInfo->Name, PropertyName, Index));
                        Status = ERROR_WMIMOF_BAD_DATAITEM_ID;
                        ErrorMessage(TRUE,
                                     ERROR_WMIMOF_BAD_DATAITEM_ID,
                                        PropertyName,
                                        MofClassInfo->Name,
                                     Index+1);
                        goto done;
                    }
                } else {
                    //
                    // This property does not have a WmiDataId qualifier
                    // so see if it is Active or InstanceName
                    QualifierType = VT_BSTR;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                                  L"CIMTYPE",
                                                  &QualifierType,
                                          NULL,
                                                  (PVOID)&StringPtr);

                    if (_wcsicmp(PropertyName, L"InstanceName") == 0)
                    {
                        if ((Status != ERROR_SUCCESS) ||
                            (_wcsicmp(StringPtr, L"string") != 0))
                        {
                            Status = ERROR_WMIMOF_INSTANCENAME_BAD_TYPE;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_INSTANCENAME_BAD_TYPE,
                                         MofClassInfo->Name,
                                         StringPtr);
                            BMOFFree(StringPtr);
                            goto done;
                        } else {
                            BMOFFree(StringPtr);
                            if ((! ProviderQualifier) && (! AbstractClass))
                            {
                                //
                                // If InstanceName specified, but this is an
                                // embedded class then an error
                                Status = ERROR_WMIMOF_EMBEDDED_CLASS;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_EMBEDDED_CLASS,
                                         MofClassInfo->Name);
                                goto done;
                            }
                            QualifierType = VT_BOOL;
                            Status = WmipFindMofQualifier(PropQualifierList,
                                                  L"key",
                                                  &QualifierType,
                                          NULL,
                                                  (PVOID)&BooleanValue);
                            if ((Status == ERROR_SUCCESS) && BooleanValue)
                            {
                                MofClassInfo->Flags |= MOFCI_RESERVED1;
                            } else {
                                Status = ERROR_WMIMOF_INSTANCENAME_NOT_KEY;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_INSTANCENAME_NOT_KEY,
                                         MofClassInfo->Name);
                                goto done;
                            }
                        }
                    } else if (_wcsicmp(PropertyName, L"Active") == 0)
                    {
                        if ((Status != ERROR_SUCCESS) ||
                            (_wcsicmp(StringPtr, L"boolean") != 0))
                        {
                            Status = ERROR_WMIMOF_ACTIVE_BAD_TYPE;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_ACTIVE_BAD_TYPE,
                                         MofClassInfo->Name,
                                         StringPtr);
                            BMOFFree(StringPtr);
                            goto done;
                        } else {
                            BMOFFree(StringPtr);
                            if ((! ProviderQualifier) && (! AbstractClass))
                            {
                                //
                                // If Boolean specified, but this is an
                                // embedded class then an error
                                Status = ERROR_WMIMOF_EMBEDDED_CLASS;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_EMBEDDED_CLASS,
                                         MofClassInfo->Name);
                                goto done;
                            }
                            MofClassInfo->Flags |= MOFCI_RESERVED2;
                        }
                    } else {
                        Status = ERROR_WMIMOF_NO_WMIDATAID;
                        ErrorMessage(TRUE,
                                     ERROR_WMIMOF_NO_WMIDATAID,
                                        PropertyName,
                                        MofClassInfo->Name);
                        BMOFFree(StringPtr);
                        goto done;
                    }
                }

                // Do not free PropQualifierList since it is needed for
                // generating header files
                PropQualifierList= NULL;
            }

#if DBG
                printf("\n");
#endif
            if (PropertyName != NULL)
            {
                BMOFFree(PropertyName);
                PropertyName = NULL;
            }
        }
        //
        // Now parse the methods
#if DBG
        printf("Parsing methods\n");
#endif

        if (MethodCount > 0)
        {
//
// Don't enable this yet as 1394wmi.mof has methods within an embedded
// class.
//
#if 0           
            if (! ProviderQualifier)
            {
                // methods don't belong in embedded classes
                Status = ERROR_WMIMOF_EMBEDDED_CLASS_HAS_METHODS;
                ErrorMessage(TRUE,
                             ERROR_WMIMOF_EMBEDDED_CLASS_HAS_METHODS,
                             MofClassInfo->Name);
                
            }
#endif
            
            MethodList = (PULONG)BMOFAlloc(MethodCount * sizeof(ULONG));
            if (MethodList == NULL)
            {
                WmipDebugPrint(("WMI: Not enough memory for Method List\n"));
                return(ERROR_NOT_ENOUGH_MEMORY);

            }
        }

        MethodCount = 0;
        ResetObj(ClassObject);
        while(NextMeth(ClassObject, &MethodName, &MofMethodData))
        {
#if DBG
            printf("    %ws - ", MethodName);
#endif
            MethQualifierList = GetMethQualList(ClassObject, MethodName);
            if (MethQualifierList != NULL)
            {
                Status = WmipParseMethodObject(&MofMethodData,
                                               MethQualifierList,
                                               &MethodId);
                if (Status != ERROR_SUCCESS)
                {
                    WmipDebugPrint(("WMI: MofClass %ws Method %ws not parsed properly %x\n",
                                    MofClassInfo->Name, MethodName, Status));
                    ErrorMessage(TRUE,
                                         Status,
                                          MethodName,
                                     MofClassInfo->Name);
                    goto done;
                }

                for (i = 0; i < MethodCount; i++)
                {
                    if (MethodId == MethodList[i])
                    {
                        ErrorMessage(TRUE,
                                 ERROR_WMIMOF_DUPLICATE_METHODID,
                                 MethodName,
                                 MofClassInfo->Name);
                        goto done;
                    }
                }

                MofDataItem = &MofClassInfo->DataItems[DataItemCount+MethodCount];
                MethodList[MethodCount++] = MethodId;

                MofDataItem->Flags = MOFDI_FLAG_METHOD;
                MofDataItem->Name = MethodName;
                MofDataItem->MethodId = MethodId;

                //
                // Keep track of property and property qualifier objects
                MofDataItem->PropertyQualifierHandle = (ULONG_PTR)MethQualifierList;


                //
                // Get the header name string which is not required
                QualifierType = VT_BSTR;
                Status = WmipFindMofQualifier(MethQualifierList,
                                      L"HeaderName",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofDataItem->HeaderName);

                MethQualifierList = NULL;

                //
                // parse the parameters for the method call
                //
                Status = WmipParseMethodParameters(&MofMethodData,
                                                   &MethodClassInfo);

                if (Status == ERROR_SUCCESS)
                {
                    MofDataItem->MethodClassInfo = MethodClassInfo;
                } else if (Status == ERROR_WMIMOF_METHOD_RETURN_NOT_VOID) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_METHOD_RETURN_NOT_VOID,
                                 MethodName,
                                 MofClassInfo->Name);                                
                }

            }
#if DBG
            printf("\n");
#endif
            // DOn't free method name, kept in MofDataItem
            MethodName = NULL;
        }
    }

done:
    //
    // Cleanup any loose pointers

    if (MethodList != NULL)
    {
        BMOFFree(MethodList);
        MethodList = NULL;
    }


    if (PropertyName != NULL)
    {
        BMOFFree(PropertyName);
        PropertyName = NULL;
    }

    if (MethodName != NULL)
    {
        BMOFFree(MethodName);
        MethodName = NULL;
    }

    if (PropQualifierList != NULL)
    {
        BMOFFree(PropQualifierList);
    }

    if (MethQualifierList != NULL)
    {
        BMOFFree(MethQualifierList);
    }

    if (ClassQualifierList != NULL)
    {
        BMOFFree(ClassQualifierList);
    }

    //
    // Validate that we have all data item ids filled in, fixup any
    // property references for variable length arrays and setup
    // the appropriate version number in the data items.
    FailedStatus = Status;
    Version = 1;
    for (Index = 0; Index < MofClassInfo->DataItemCount; Index++)
    {
        MofDataItem = &MofClassInfo->DataItems[Index];

        if (MofDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY)
        {
            //
            // Resolve the variable length array
            //
            Status = WmipResolveVLArray(MofClassInfo,
                                        MofDataItem,
                                        FailedStatus);
            if (Status != ERROR_SUCCESS)
            {
                if (Status == ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND)
                {
                    WmipDebugPrint(("WMI: Could not resolve vl array size property %ws in class %ws\n",
                            PropertyName, MofClassInfo->Name));
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND,
                                 PropertyName,
                                    MofDataItem->Name,
                                    MofClassInfo->Name);
                } else if (Status == ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE,
                                 MofClassInfo->DataItems[MofDataItem->VariableArraySizeId-1].Name,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);

                } else if (Status == ERROR_WMIMOF_DATAITEM_NOT_FOUND) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_NOT_FOUND,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                } else {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_NOT_RESOLVED,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                }
                FailedStatus = Status;
            }
        }

        //
        // Ensure that this data item has got a name, that is the mof
        // writer didn't skip a data item id
        if (MofDataItem->Name == NULL)
        {
            //
            // This data item was not filled in
            Status = ERROR_WMIMOF_MISSING_DATAITEM;
            WmipDebugPrint(("WMI: Missing data item %d in class %ws\n",
                         Index, MofClassInfo->Name));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_MISSING_DATAITEM,
                         Index+1,
                         MofClassInfo->Name);
            FailedStatus = Status;
        }

        if (FailedStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // Establish version for data item
        if (MofDataItem->Version == 0)
        {
            MofDataItem->Version = Version;
        } else if ((MofDataItem->Version == Version) ||
                   (MofDataItem->Version == Version+1)) {
            Version = MofDataItem->Version;
        } else {
            Status = ERROR_WMIMOF_INCONSISTENT_VERSIONING;
            WmipDebugPrint(("WMI: Inconsistent versioning in class %ws at data item id %d\n",
                          MofClassInfo->Name, Index));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_INCONSISTENT_VERSIONING,
                         MofDataItem->Name,
                         MofClassInfo->Name);
            FailedStatus = Status;
            // fall thru......
            // continue;
        }
    }


    if (FailedStatus == ERROR_SUCCESS)
    {
        //
        // Mof class parsed OK so we set its version number and link it
        // into the list of classes for the MOF resource
        MofClassInfo->Version = Version;

        //
        // Link this into the list of MofClasses for this mof resource
        InsertTailList(&MofResource->MRMCHead, &MofClass->MCMRList);

    } else {
        WmipUnreferenceMC(MofClass);
        Status = FailedStatus;
    }

    return(Status);
}


//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

ULONG GetRootObjectList(
    char *BMofFile,
    CBMOFObjList **ObjectList
    )
{
    ULONG Status;
    ULONG CompressedSizeHigh;

    BMofFileName = BMofFile;
    FileHandle = CreateFile(BMofFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    CompressedSize = GetFileSize(FileHandle, &CompressedSizeHigh);

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0, 0,
                                      NULL);
    if (MappingHandle == NULL)
    {
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    CompressedFileBuffer = MapViewOfFile(MappingHandle,
                               FILE_MAP_READ,
                               0, 0,
                               0);

    if (CompressedFileBuffer == NULL)
    {
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    Status = WmipDecompressBuffer(CompressedFileBuffer,
                                  &FileBuffer,
                                  &UncompressedSize);

    if (Status != ERROR_SUCCESS)
    {
        UnmapViewOfFile(CompressedFileBuffer);
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    fprintf(stderr, "Binary mof file %s expanded to %d bytes\n", BMofFile,
                                                       UncompressedSize);

    //
    //  Create an object list structure of all the objects in the MOF
    *ObjectList = CreateObjList(FileBuffer);
    if(*ObjectList == NULL)
    {
        UnmapViewOfFile(CompressedFileBuffer);
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(ERROR_WMI_INVALID_MOF);
    }
    return(ERROR_SUCCESS);
}

ULONG VerifyClassProperties(
    PMOFRESOURCE MofResource,
    PWCHAR ClassName,
    PWCHAR BaseClassName,
    PMOFCLASS MofClass

)
{
    CBMOFObj *ClassObject;
    PMOFCLASSINFOW MofClassInfo;
    CBMOFDataItem MofPropertyData;
    DWORD QualifierType;
    WCHAR *StringPtr;
    ULONG Status = ERROR_SUCCESS;
    PMOFCLASS MofSuperClass;
    
    ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;
    MofClassInfo = MofClass->MofClassInfo;
        
    if ( ((MofClassInfo->Flags & MOFCI_RESERVED1) == 0) &&
         ((MofClassInfo->Flags & MOFCI_RESERVED2) == 0) )       
    {
        //
        // This class does not have the instanceName and Active properties
        // so we expect that a superclass should. Look for the superclass
        // and check that
        //
        QualifierType = VT_BSTR;
        Status = WmipFindProperty(ClassObject,
                                      L"__SUPERCLASS",
                                      &MofPropertyData,
                                      &QualifierType,
                                      (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            //
            // Find the MofClass for the superclass and see if it has
            // the required properties
            //
            MofSuperClass = WmipFindClassInMofResourceByName(MofResource,
                                                StringPtr);
                                            
            if (MofSuperClass != NULL)
            {
                Status = VerifyClassProperties(MofResource,
                                               MofSuperClass->MofClassInfo->Name,
                                               BaseClassName,
                                               MofSuperClass);
            } else {
                //
                // We could not find the superclass, but we will assume
                // that this is ok
                //
                fprintf(stderr, "%s (0): warning RC2135 : Class %ws and all of its base classes do not have InstanceName and Active properties\n",
                    BMofFileName, BaseClassName);
                Status = ERROR_SUCCESS;
            }
            BMOFFree(StringPtr);
            
        } else {
            Status = ERROR_WMIMOF_NO_INSTANCENAME;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_INSTANCENAME,
                         BaseClassName);
        }
    } else {
        //
        // If its got one of the properties make sure that it has
        // both of them.
    
        if ((MofClassInfo->Flags & MOFCI_RESERVED1) == 0)
        {
            Status = ERROR_WMIMOF_NO_INSTANCENAME;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_INSTANCENAME,
                         BaseClassName);
        }

        if ((MofClassInfo->Flags & MOFCI_RESERVED2) == 0)
        {
            Status = ERROR_WMIMOF_NO_ACTIVE;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_ACTIVE,
                         BaseClassName);
        }
    }
    return(Status);
}

ULONG ParseBinaryMofFile(
    char *BMofFile,
    PMOFRESOURCE *ReturnMofResource
    )
{
    ULONG Status;
    CBMOFObjList *MofObjList;
    CBMOFObj *ClassObject;
    PMOFRESOURCE MofResource;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    BOOLEAN CleanupOnly;
    PMOFCLASSINFOW MofClassInfo;

    MofResource = WmipAllocMofResource();
    if (MofResource == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *ReturnMofResource = MofResource;
    InitializeListHead(&MofResource->MRMCHead);
    Status = GetRootObjectList(BMofFile, &MofObjList);
    if (Status == ERROR_SUCCESS)
    {
        ResetObjList (MofObjList);

        while((Status == ERROR_SUCCESS) &&
              (ClassObject = NextObj(MofObjList)) )
        {
            Status = WmipParseClassObject(MofResource, ClassObject);
            if (Status != ERROR_SUCCESS)
            {
                ErrorMessage(TRUE, ERROR_WMIMOF_CLASS_NOT_PARSED);
            }
        }

        //
        // Now that all classes are parsed we need to go back and find
        // the guids for any embedded classes, or if a class failed
        // to parse then we need to free any embedded class names
        CleanupOnly = (Status != ERROR_SUCCESS);
        MofClassList = MofResource->MRMCHead.Flink;
        while (MofClassList != &MofResource->MRMCHead)
        {
            MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);
            MofClassInfo = MofClass->MofClassInfo;
                                    
            if ((! CleanupOnly) &&
                (MofClassInfo->Flags & MOFCI_RESERVED0))
            {
                //
                // if the class has Provider qualifier, it better have
                // an instancename and Active properties in itself or in a
                // superclass
                //
                Status = VerifyClassProperties(MofResource,
                                               MofClassInfo->Name,
                                               MofClassInfo->Name,
                                               MofClass);
                                        
                CleanupOnly = (Status != ERROR_SUCCESS);
            }
                                    
            Status = WmipFillEmbeddedClasses(MofResource,
                                             MofClassInfo,
                                             CleanupOnly);
            if (Status != ERROR_SUCCESS)
            {
                CleanupOnly = TRUE;
            }
            MofClassList = MofClassList->Flink;
        }

        if (CleanupOnly)
        {
            Status = ERROR_WMI_INVALID_MOF;
        }

        BMOFFree(MofObjList);

        if (Status != ERROR_SUCCESS)
        {
            //
            // Make sure we have a useful Win32 error code and not
            // an internal WMIMOF error code
            Status = ERROR_WMI_INVALID_MOF;
        }
    }
    return(Status);
}

ULONG FilePrintVaList(
    HANDLE FileHandle,
    CHAR *Format,
    va_list pArg
    )
{
    PCHAR Buffer;
    ULONG Size, Written;
    ULONG Status;

    Buffer = WmipAlloc(8192);
    if (Buffer != NULL)
    {
        Size = _vsnprintf(Buffer, 8192, Format, pArg);
        Buffer[8191] = 0;
        if (WriteFile(FileHandle,
                           Buffer,
                           Size,
                           &Written,
                           NULL))
        {
            Status = ERROR_SUCCESS;
        } else {
            Status = GetLastError();
        }
        WmipFree(Buffer);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(Status);
}

ULONG FilePrint(
    HANDLE FileHandle,
    char *Format,
    ...
    )
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(FileHandle, Format, pArg);
    return(Status);
}

ULONG GenerateASLTemplate(
    PCHAR TemplateFile
    )
{
    return(ERROR_SUCCESS);
}

ULONG GenerateBinaryMofData(
    HANDLE FileHandle
    )
{
    ULONG Lines;
    ULONG LastLine;
    ULONG i;
    ULONG Index;
    PUCHAR BMofBuffer = (PUCHAR)CompressedFileBuffer;
    PCHAR IndentString = "    ";
    ULONG Status;

    Lines = CompressedSize / 16;
    LastLine = CompressedSize % 16;
    if (LastLine == 0)
    {
        LastLine = 16;
        Lines--;
    }

    for (i = 0; i < Lines; i++)
    {
        Index = i * 16;
        Status = FilePrint(FileHandle, "%s0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\r\n",
              IndentString,
              BMofBuffer[Index],
              BMofBuffer[Index+1],
              BMofBuffer[Index+2],
              BMofBuffer[Index+3],
              BMofBuffer[Index+4],
              BMofBuffer[Index+5],
              BMofBuffer[Index+6],
              BMofBuffer[Index+7],
              BMofBuffer[Index+8],
              BMofBuffer[Index+9],
              BMofBuffer[Index+10],
              BMofBuffer[Index+11],
              BMofBuffer[Index+12],
              BMofBuffer[Index+13],
              BMofBuffer[Index+14],
              BMofBuffer[Index+15]);

        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }

    LastLine--;
    FilePrint(FileHandle, "%s",               IndentString);
    Index = Lines * 16;
    for (i = 0; i < LastLine; i++)
    {
        Status = FilePrint(FileHandle, "0x%02x, ",
                  BMofBuffer[Index+i]);
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }

    Status = FilePrint(FileHandle, "0x%02x\r\n",
                  BMofBuffer[Index+i]);

    return(Status);
}

//
// This will loop over the mof class list and print out once for each class
// in the list.
//
// Handle is the file handle to which to write
// MR is the MofResource whose classes are being enumerated
// NamePtr is the variable to place the name of the class
// Counter is the variable to use as a counter
// Format is the format template to use to write out
//

HANDLE GlobalFilePrintHandle;
ULONG FilePrintGlobal(CHAR *Format, ...)
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(GlobalFilePrintHandle, Format, pArg);
    return(Status);
}

#define FilePrintMofClassLoop( \
    Handle, \
    MR, \
    NamePtr, \
    Counter, \
    DiscardEmbedded, \
    Format   \
    ) \
{    \
    PLIST_ENTRY MofClassList; \
    PMOFCLASSINFOW ClassInfo; \
    PMOFCLASS MofClass; \
    GlobalFilePrintHandle = TemplateHandle; \
    (Counter) = 0; \
    MofClassList = (MR)->MRMCHead.Flink; \
    while (MofClassList != &(MR)->MRMCHead) \
    { \
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList); \
        ClassInfo = MofClass->MofClassInfo; \
        if (! ((DiscardEmbedded) && \
               (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS)) ) \
        { \
            (NamePtr) = ClassInfo->Name; \
            FilePrintGlobal Format; \
            (Counter)++; \
        } \
        MofClassList = MofClassList->Flink; \
    } \
}

typedef void (*ENUMMOFCLASSCALLBACK)(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    );

void EnumerateMofClasses(
    HANDLE TemplateHandle,
    PMOFRESOURCE MR,
    ENUMMOFCLASSCALLBACK Callback,
    PVOID Context
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    ULONG Counter;

    Counter = 0;
    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        (*Callback)(TemplateHandle,
                    MofClass,
                    Counter,
                    Context);

        MofClassList = MofClassList->Flink;
        Counter++;
    }
}

void GenerateGuidListTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;
    PWCHAR GuidName1, GuidSuffix1;

    ClassInfo = MofClass->MofClassInfo;

    if ( ! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS))
    {
        //
        // Only generate code for non embedded classes
        //
        if (ClassInfo->GuidName1 != NULL)
        {
            GuidName1 = ClassInfo->GuidName1;
            GuidSuffix1 = L"";
        } else {
            GuidName1 = ClassInfo->Name;
            GuidSuffix1 = L"Guid";
        }

        FilePrint(TemplateHandle,
              "GUID %wsGUID = %ws%ws;\r\n",
              ClassInfo->Name,
              GuidName1, GuidSuffix1);
      }
}


void GenerateFunctionControlListTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;

    ClassInfo = MofClass->MofClassInfo;

    if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS) )
    {
        FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {\r\n",
        ClassInfo->Name);

        if (ClassInfo->Flags & MOFCI_FLAG_EVENT)
        {
            FilePrint(TemplateHandle,
"            if (Enable)\r\n"
"            {\r\n"
"                //\r\n"
"                // TODO: Event is being enabled, do anything required to\r\n"
"                //       allow the event to be fired\r\n"
"                //\r\n"
"            } else {\r\n"
"                //\r\n"
"                // TODO: Event is being disabled, do anything required to\r\n"
"                //       keep the event from being fired\r\n"
"                //\r\n"
"            }\r\n");

        } else {
            FilePrint(TemplateHandle,
"            //\r\n"
"            // TODO: Delete this entire case if data block does not have the\r\n"
"            //       WMIREG_FLAG_EXPENSIVE flag set\r\n"
"            //\r\n"
"            if (Enable)\r\n"
"            {\r\n"
"                //\r\n"
"                // TODO: Datablock collection is being enabled. If this\r\n"
"                //       data block has been marked as expensive in the\r\n"
"                //       guid list then this code will be called when the\r\n"
"                //       first data consumer opens this data block. If\r\n"
"                //       anything needs to be done to allow data to be \r\n"
"                //       collected for this data block then it should be\r\n"
"                //       done here\r\n"
"                //\r\n"
"            } else {\r\n"
"                //\r\n"
"                // TODO: Datablock collection is being disabled. If this\r\n"
"                //       data block has been marked as expensive in the\r\n"
"                //       guid list then this code will be called when the\r\n"
"                //       last data consumer closes this data block. If\r\n"
"                //       anything needs to be done to cleanup after data has \r\n"
"                //       been collected for this data block then it should be\r\n"
"                //       done here\r\n"
"                //\r\n"
"            }\r\n");
        }

        FilePrint(TemplateHandle,
"            break;\r\n"
"        }\r\n\r\n");
    }
}

void GenerateSetList(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PCHAR Format = (PCHAR)Context;

    PMOFCLASSINFOW ClassInfo;

    ClassInfo = MofClass->MofClassInfo;
    if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS) )
    {
        if (! (ClassInfo->Flags & MOFCI_FLAG_READONLY))
        {
            FilePrint(TemplateHandle, Format, ClassInfo->Name);
        } else {
            FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            status = STATUS_WMI_READ_ONLY;\r\n"
"            break;\r\n"
"        }\r\n\r\n",
             ClassInfo->Name);
        }
    }
}

void GenerateMethodCTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;
    ULONG i;
    PMOFDATAITEMW DataItem;

    ClassInfo = MofClass->MofClassInfo;

    if (ClassInfo->MethodCount > 0)
    {

        FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {\r\n"
"            switch(MethodId)\r\n"
"            {\r\n",
          ClassInfo->Name);

        for (i = 0; i < ClassInfo->MethodCount; i++)
        {
            DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];
            FilePrint(TemplateHandle,
"                case %ws:\r\n"
"                {            \r\n"
"                    //\r\n"
"                    // TODO: Validate InstanceIndex, InBufferSize \r\n"
"                    //       and Buffer contents to ensure that the \r\n"
"                    //       input buffer is valid and OutBufferSize is\r\n"
"                    //       large enough to return the output data.\r\n"
"                    //\r\n"
"                    break;\r\n"
"                }\r\n\r\n",
                               DataItem->Name);
        }

        FilePrint(TemplateHandle,
"                default:\r\n"
"                {\r\n"
"                    status = STATUS_WMI_ITEMID_NOT_FOUND;\r\n"
"                    break;\r\n"
"                }\r\n"
"            }\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
                );
    }
}

BOOLEAN DoesSupportMethods(
    PMOFRESOURCE MR
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        if (MofClass->MofClassInfo->MethodCount > 0)
        {
            return(TRUE);
        }
        MofClassList = MofClassList->Flink;
    }
    return(FALSE);
}

BOOLEAN DoesReadOnly(
    PMOFRESOURCE MR
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PMOFCLASSINFOW ClassInfo;
    ULONG i;

    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        ClassInfo = MofClass->MofClassInfo;

        for (i = 0; i < ClassInfo->DataItemCount; i++)
        {
            if (ClassInfo->DataItems[i].Flags & MOFDI_FLAG_WRITEABLE)
            {
                return(FALSE);
            }
        }

        MofClassList = MofClassList->Flink;
    }
    return(TRUE);
}

PCHAR GetBaseNameFromFileName(
    PCHAR FileName,
    PCHAR BaseName
    )
{
    PCHAR p, p1;
    ULONG Len;

    p = FileName;
    p1 = FileName;
    while ((*p != '.') && (*p != 0))
    {
        if (*p == '\\')
        {
            p1 = p+1;
        }
        p++;
    }

    Len = (ULONG)(p - p1);
    memcpy(BaseName, p1, Len);
    BaseName[Len] = 0;
    return(BaseName);
}


ULONG GenerateCTemplate(
    PCHAR TemplateFile,
    PCHAR HFileName,
    PCHAR XFileName,
    PMOFRESOURCE MofResource
    )
{
    BOOLEAN SupportsMethods, SupportsFunctionControl, IsReadOnly;
    HANDLE TemplateHandle;
    CHAR BaseName[MAX_PATH], BaseXFileName[MAX_PATH], BaseHFileName[MAX_PATH];
    ULONG i;
    PWCHAR ClassName;

    GetBaseNameFromFileName(TemplateFile, BaseName);
    GetBaseNameFromFileName(XFileName, BaseXFileName);
    GetBaseNameFromFileName(XFileName, BaseHFileName);
    BaseName[0] = (CHAR)toupper(BaseName[0]);

    SupportsMethods = DoesSupportMethods(MofResource);
    SupportsFunctionControl = TRUE;
    IsReadOnly = DoesReadOnly(MofResource);

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    FilePrint(TemplateHandle,
"//\r\n"
"// %s.c - Code generated by wmimofck tool\r\n"
"//\r\n"
"// Finish code by doing all TODO: sections\r\n"
"//\r\n"
"\r\n"
"#include <wdm.h>\r\n"
"#include <wmistr.h>\r\n"
"#include <wmiguid.h>\r\n"
"#include <wmilib.h>\r\n"
"\r\n"
"//\r\n"
"// Include data header for classes\r\n"
"#include \"%s.h\"\r\n"
"\r\n"
"\r\n",
        BaseName,
        BaseHFileName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// TODO: Place the contents in this device extension into the driver's\r\n"
"//       actual device extension. It is only defined here to supply\r\n"
"//       a device extension so that this file can be compiled on its own\r\n"
"//\r\n"
"#ifdef MAKE_THIS_COMPILE\r\n"
"typedef struct DEVICE_EXTENSION\r\n"
"{\r\n"
"    WMILIB_CONTEXT WmiLib;\r\n"
"    PDEVICE_OBJECT physicalDevObj;\r\n"
"} DEVICE_EXTENSION, *PDEVICE_EXTENSION;\r\n"
"#endif\r\n\r\n"
         );

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sInitializeWmilibContext(\r\n"
"    IN PWMILIB_CONTEXT WmilibContext\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sFunctionControl(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN WMIENABLEDISABLECONTROL Function,\r\n"
"    IN BOOLEAN Enable\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sExecuteWmiMethod(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG MethodId,\r\n"
"    IN ULONG InBufferSize,\r\n"
"    IN ULONG OutBufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataItem(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG DataItemId,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sQueryWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG InstanceCount,\r\n"
"    IN OUT PULONG InstanceLengthArray,\r\n"
"    IN ULONG BufferAvail,\r\n"
"    OUT PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sQueryWmiRegInfo(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    OUT ULONG *RegFlags,\r\n"
"    OUT PUNICODE_STRING InstanceName,\r\n"
"    OUT PUNICODE_STRING *RegistryPath,\r\n"
"    OUT PUNICODE_STRING MofResourceName,\r\n"
"    OUT PDEVICE_OBJECT *Pdo\r\n"
"    );\r\n"
"\r\n"
"#ifdef ALLOC_PRAGMA\r\n"
"#pragma alloc_text(PAGE,%sQueryWmiRegInfo)\r\n"
"#pragma alloc_text(PAGE,%sQueryWmiDataBlock)\r\n"
"#pragma alloc_text(PAGE,%sSetWmiDataBlock)\r\n"
"#pragma alloc_text(PAGE,%sSetWmiDataItem)\r\n"
"#pragma alloc_text(PAGE,%sExecuteWmiMethod)\r\n"
"#pragma alloc_text(PAGE,%sFunctionControl)\r\n"
"#pragma alloc_text(PAGE,%sInitializeWmilibContext)\r\n"
"#endif\r\n"
"\r\n",
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// TODO: Decide if your MOF is going to be part of your driver as a resource\r\n"
"//       attached to it. If this is done then all MOF in the resource will be\r\n"
"//       added to the schema. If this is the case be sure that \r\n"
"//       USE_BINARY_MOF_RESOURCE is defined. MOF can also be reported at \r\n"
"//       runtime via a query to the driver. This can be useful if you want\r\n"
"//       the MOF reported to the schema to be dynamic. If MOF is reported via\r\n"
"//       a query then USE_BINARY_MOF_QUERY should be defined.\r\n"
"\r\n"
"#define USE_BINARY_MOF_QUERY\r\n"
"#define USE_BINARY_MOF_RESOURCE\r\n"
"\r\n"
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"//\r\n"
"// MOF data can be reported by a device driver via a resource attached to\r\n"
"// the device drivers image file or in response to a query on the binary\r\n"
"// mof data guid. Here we define global variables containing the binary mof\r\n"
"// data to return in response to a binary mof guid query. Note that this\r\n"
"// data is defined to be in a PAGED data segment since it does not need to\r\n"
"// be in nonpaged memory. Note that instead of a single large mof file\r\n"
"// we could have broken it into multiple individual files. Each file would\r\n"
"// have its own binary mof data buffer and get reported via a different\r\n"
"// instance of the binary mof guid. By mixing and matching the different\r\n"
"// sets of binary mof data buffers a \"dynamic\" composite mof would be created.\r\n"
"\r\n"
"#ifdef ALLOC_DATA_PRAGMA\r\n"
"   #pragma data_seg(\"PAGED\")\r\n"
"#endif\r\n"
"\r\n"
"UCHAR %sBinaryMofData[] =\r\n"
"{\r\n"
"    #include \"%s.x\"\r\n"
"};\r\n"
"#ifdef ALLOC_DATA_PRAGMA\r\n"
"   #pragma data_seg()\r\n"
"#endif\r\n"
"#endif\r\n"
"\r\n",
    BaseName,
    BaseXFileName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// Define symbolic names for the guid indexes\r\n"
    );

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE,
                          ("#define %wsGuidIndex    %d\r\n",
               ClassName, i));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"#define BinaryMofGuidIndex   %d\r\n"
"#endif\r\n",
    i
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// List of guids supported\r\n\r\n"
    );

    EnumerateMofClasses(TemplateHandle,
                        MofResource,
                        GenerateGuidListTemplate,
                        NULL);

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"GUID %sBinaryMofGUID =         BINARY_MOF_GUID;\r\n"
"#endif\r\n"
"\r\n"
"//\r\n"
"// TODO: Make sure the instance count and flags are set properly for each\r\n"
"//       guid\r\n"
"WMIGUIDREGINFO %sGuidList[] =\r\n"
"{\r\n",
               BaseName, BaseName);

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE,
("    {\r\n"
"        &%wsGUID,                        // Guid\r\n"
"        1,                               // # of instances in each device\r\n"
"        0                                // Flags\r\n"
"    },\r\n",
         ClassName));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"    {\r\n"
"        &%sBinaryMofGUID,\r\n"
"        1,\r\n"
"        0\r\n"
"    }\r\n"
"#endif\r\n"
"};\r\n\r\n"
"#define %sGuidCount (sizeof(%sGuidList) / sizeof(WMIGUIDREGINFO))\r\n"
"\r\n",
       BaseName, BaseName, BaseName);

    FilePrint(TemplateHandle,
"//\r\n"
"// We need to hang onto the registry path passed to our driver entry so that\r\n"
"// we can return it in the QueryWmiRegInfo callback. Be sure to store a copy\r\n"
"// of it into %sRegistryPath in the DriverEntry routine\r\n"
"//\r\n"
"extern UNICODE_STRING %sRegistryPath;\r\n\r\n",
              BaseName, BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS %sSystemControl(\r\n"
"    PDEVICE_OBJECT DeviceObject,\r\n"
"    PIRP Irp\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject \r\n"
"    Irp\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    NT status code\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    PWMILIB_CONTEXT wmilibContext;\r\n"
"    NTSTATUS status;\r\n"
"    SYSCTL_IRP_DISPOSITION disposition;\r\n"
"    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"    //\r\n"
"    // TODO: Point at the WMILIB context within the device extension\r\n"
"    wmilibContext = &devExt->WmiLib;\r\n"
"\r\n"
"    //\r\n"
"    // Call Wmilib helper function to crack the irp. If this is a wmi irp\r\n"
"    // that is targetted for this device then WmiSystemControl will callback\r\n"
"    // at the appropriate callback routine.\r\n"
"    //\r\n"
"    status = WmiSystemControl(wmilibContext,\r\n"
"                              DeviceObject,\r\n"
"                              Irp,\r\n"
"                              &disposition);\r\n"
"\r\n"
"    switch(disposition)\r\n"
"    {\r\n"
"        case IrpProcessed:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp has been processed and may be completed or pending.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"        case IrpNotCompleted:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp has not been completed, but has been fully processed.\r\n"
"            // we will complete it now.\r\n"
"            IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"        case IrpForward:\r\n"
"        case IrpNotWmi:\r\n"
"        default:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp is either not a WMI irp or is a WMI irp targetted\r\n"
"            // at a device lower in the stack.\r\n"
"\r\n"
"            // TODO: Forward IRP down the device stack to the next device\r\n"
"            //       Or if this is a PDO then just complete the irp without\r\n"
"            //       touching it.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n",
         BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sQueryWmiRegInfo(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    OUT ULONG *RegFlags,\r\n"
"    OUT PUNICODE_STRING InstanceName,\r\n"
"    OUT PUNICODE_STRING *RegistryPath,\r\n"
"    OUT PUNICODE_STRING MofResourceName,\r\n"
"    OUT PDEVICE_OBJECT *Pdo\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to retrieve the list of\r\n"
"    guids or data blocks that the driver wants to register with WMI. This\r\n"
"    routine may not pend or block. Driver should NOT call\r\n"
"    WmiCompleteRequest.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose registration info is being queried\r\n"
"\r\n"
"    *RegFlags returns with a set of flags that describe the guids being\r\n"
"        registered for this device. If the device wants enable and disable\r\n"
"        collection callbacks before receiving queries for the registered\r\n"
"        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the\r\n"
"        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case\r\n"
"        the instance name is determined from the PDO associated with the\r\n"
"        device object. Note that the PDO must have an associated devnode. If\r\n"
"        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique\r\n"
"        name for the device.\r\n"
"\r\n"
"    InstanceName returns with the instance name for the guids if\r\n"
"        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The\r\n"
"        caller will call ExFreePool with the buffer returned.\r\n"
"\r\n"
"    *RegistryPath returns with the registry path of the driver. The caller\r\n"
"         does NOT free this buffer.\r\n"
"\r\n"
"    *MofResourceName returns with the name of the MOF resource attached to\r\n"
"        the binary file. If the driver does not have a mof resource attached\r\n"
"        then this can be returned as NULL. The caller does NOT free this\r\n"
"        buffer.\r\n"
"\r\n"
"    *Pdo returns with the device object for the PDO associated with this\r\n"
"        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in\r\n"
"        *RegFlags.\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"    //\r\n"
"    // Return the registry path for this driver. This is required so WMI\r\n"
"    // can find your driver image and can attribute any eventlog messages to\r\n"
"    // your driver.\r\n"
"    *RegistryPath = &%sRegistryPath;\r\n"
"        \r\n"
"#ifndef USE_BINARY_MOF_RESOURCE\r\n"
"    //\r\n"
"    // Return the name specified in the .rc file of the resource which\r\n"
"    // contains the bianry mof data. By default WMI will look for this\r\n"
"    // resource in the driver image (.sys) file, however if the value\r\n"
"    // MofImagePath is specified in the driver's registry key\r\n"
"    // then WMI will look for the resource in the file specified there.\r\n"
"    RtlInitUnicodeString(MofResourceName, L\"MofResourceName\");\r\n"
"#endif\r\n"
"\r\n"
"    //\r\n"
"    // Specify that the driver wants WMI to automatically generate instance\r\n"
"    // names for all of the data blocks based upon the device stack's\r\n"
"    // device instance id. Doing this is STRONGLY recommended since additional\r\n"
"    // information about the device would then be available to callers.\r\n"
"    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;\r\n"
"\r\n"
"    //\r\n"
"    // TODO: Assign the physical device object for the device stack to *Pdo\r\n"
"    *Pdo = devExt->physicalDevObj;\r\n"
"\r\n"
"    return(STATUS_SUCCESS);\r\n"
"}\r\n"
"\r\n",
      BaseName, BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sQueryWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG InstanceCount,\r\n"
"    IN OUT PULONG InstanceLengthArray,\r\n"
"    IN ULONG BufferAvail,\r\n"
"    OUT PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to query for the contents of\r\n"
"    all instances of a data block. If the driver can satisfy the query within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the query is satisfied.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being queried\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    InstanceCount is the number of instnaces expected to be returned for\r\n"
"        the data block.\r\n"
"\r\n"
"    InstanceLengthArray is a pointer to an array of ULONG that returns the\r\n"
"        lengths of each instance of the data block. If this is NULL then\r\n"
"        there was not enough space in the output buffer to fufill the request\r\n"
"        so the irp should be completed with the buffer needed.\r\n"
"\r\n"
"    BufferAvail on entry has the maximum size available to write the data\r\n"
"        blocks.\r\n"
"\r\n"
"    Buffer on return is filled with the returned data blocks. Note that each\r\n"
"        instance of the data block must be aligned on a 8 byte boundry.\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status = STATUS_UNSUCCESSFUL;\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"    ULONG sizeNeeded;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
       ,BaseName        );

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE, (
"        case %wsGuidIndex:\r\n"
"        {\r\n"
"            //\r\n"
"            // TODO: Check that the size of the buffer passed is large enough\r\n"
"            //       for all of the instances requested and if so fill Buffer\r\n"
"            //       with the data. Make sure that each instance begins on an\r\n"
"            //       8 byte boundry.\r\n"
"            //\r\n"
"            break;\r\n"
"        }\r\n\r\n",
                          ClassName));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"        case BinaryMofGuidIndex:\r\n"
"        {\r\n"
"            //\r\n"
"            // TODO: If the driver supports reporting MOF dynamically, \r\n"
"            //       change this code to handle multiple instances of the\r\n"
"            //       binary mof guid and return only those instances that\r\n"
"            //       should be reported to the schema\r\n"
"            //\r\n"
"            sizeNeeded = sizeof(%sBinaryMofData);\r\n"
"\r\n"
"            if (BufferAvail < sizeNeeded)\r\n"
"            {\r\n"
"                status = STATUS_BUFFER_TOO_SMALL;\r\n"
"            } else {\r\n"
"                RtlCopyMemory(Buffer, %sBinaryMofData, sizeNeeded);\r\n"
"                *InstanceLengthArray = sizeNeeded;\r\n"
"                status = STATUS_SUCCESS;\r\n"
"            }\r\n"
"            break;\r\n"
"        }\r\n"
"#endif\r\n"
"\r\n"
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    //\r\n"
"    // Complete the irp. If there was not enough room in the output buffer\r\n"
"    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size\r\n"
"    // needed to return all of the data. If there was enough room then\r\n"
"    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes\r\n"
"    // being returned.\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     sizeNeeded,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
           , BaseName, BaseName);

    if (! IsReadOnly)
    {
        FilePrint(TemplateHandle,
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to change the contents of\r\n"
"    a data block. If the driver can change the data block within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being queried\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    BufferSize has the size of the data block passed\r\n"
"\r\n"
"    Buffer has the new values for the data block\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
    , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateSetList,
"\r\n"
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            //\r\n"
"            // TODO: Validate InstanceIndex, BufferSize and Buffer contents\r\n"
"            //       and if valid then set the underlying data block, write\r\n"
"            //       to the hardware, etc.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
           );

        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"\r\n"
"\r\n"
"}\r\n"
           );
        FilePrint(TemplateHandle,
"       \r\n"
"NTSTATUS\r\n"
"%sSetWmiDataItem(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG DataItemId,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to change the contents of\r\n"
"    a data block. If the driver can change the data block within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being changed\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    DataItemId has the id of the data item being set\r\n"
"\r\n"
"    BufferSize has the size of the data item passed\r\n"
"\r\n"
"    Buffer has the new values for the data item\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
        , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateSetList,
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            //\r\n"
"            // TODO: Validate InstanceIndex, DataItemId, BufferSize \r\n"
"            //       and Buffer contents\r\n"
"            //       and if valid then set the underlying data item, write\r\n"
"            //       to the hardware, etc.\r\n"
"            break;\r\n"
"        }\r\n");


        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
        );

    }

    if (SupportsMethods)
    {

        FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sExecuteWmiMethod(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG MethodId,\r\n"
"    IN ULONG InBufferSize,\r\n"
"    IN ULONG OutBufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to execute a method. If\r\n"
"    the driver can complete the method within the callback it should\r\n"
"    call WmiCompleteRequest to complete the irp before returning to the\r\n"
"    caller. Or the driver can return STATUS_PENDING if the irp cannot be\r\n"
"    completed immediately and must then call WmiCompleteRequest once the\r\n"
"    data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose method is being executed\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    MethodId has the id of the method being called\r\n"
"\r\n"
"    InBufferSize has the size of the data block passed in as the input to\r\n"
"        the method.\r\n"
"\r\n"
"    OutBufferSize on entry has the maximum size available to write the\r\n"
"        returned data block.\r\n"
"\r\n"
"    Buffer is filled with the input buffer on entry and returns with\r\n"
"         the output data block\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    ULONG sizeNeeded = 0;\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
"            \r\n"
        , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateMethodCTemplate,
                            NULL);


        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     sizeNeeded,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
            );
    }

    if (SupportsFunctionControl)
    {
        FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sFunctionControl(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN WMIENABLEDISABLECONTROL Function,\r\n"
"    IN BOOLEAN Enable\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to enabled or disable event\r\n"
"    generation or data block collection. A device should only expect a\r\n"
"    single enable when the first event or data consumer enables events or\r\n"
"    data collection and a single disable when the last event or data\r\n"
"    consumer disables events or data collection. Data blocks will only\r\n"
"    receive collection enable/disable if they were registered as requiring\r\n"
"    it. If the driver can complete enabling/disabling within the callback it\r\n"
"    should call WmiCompleteRequest to complete the irp before returning to\r\n"
"    the caller. Or the driver can return STATUS_PENDING if the irp cannot be\r\n"
"    completed immediately and must then call WmiCompleteRequest once the\r\n"
"    data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device object\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    Function specifies which functionality is being enabled or disabled\r\n"
"\r\n"
"    Enable is TRUE then the function is being enabled else disabled\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n",
        BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateFunctionControlListTemplate,
                            NULL);

        FilePrint(TemplateHandle,
"        \r\n"
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"    \r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     STATUS_SUCCESS,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"    return(status);\r\n"
"}\r\n"
             );

    }


    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sInitializeWmilibContext(\r\n"
"    IN PWMILIB_CONTEXT WmilibContext\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine will initialize the wmilib context structure with the\r\n"
"    guid list and the pointers to the wmilib callback functions. This routine\r\n"
"    should be called before calling IoWmiRegistrationControl to register\r\n"
"    your device object.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    WmilibContext is pointer to the wmilib context.\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));\r\n"
"    \r\n"
"    WmilibContext->GuidCount = %sGuidCount;\r\n"
"    WmilibContext->GuidList = %sGuidList;    \r\n"
"    \r\n"
"    WmilibContext->QueryWmiRegInfo = %sQueryWmiRegInfo;\r\n"
"    WmilibContext->QueryWmiDataBlock = %sQueryWmiDataBlock;\r\n",
        BaseName,
        BaseName,
        BaseName,
        BaseName,
        BaseName);

    if (! IsReadOnly)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->SetWmiDataBlock = %sSetWmiDataBlock;\r\n"
"    WmilibContext->SetWmiDataItem = %sSetWmiDataItem;\r\n",
                   BaseName, BaseName);
    }

    if (SupportsMethods)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->ExecuteWmiMethod = %sExecuteWmiMethod;\r\n",
                   BaseName);
    }

    if (SupportsFunctionControl)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->WmiFunctionControl = %sFunctionControl;\r\n",
                   BaseName);
    }

    FilePrint(TemplateHandle,
"\r\n"
"    return(STATUS_SUCCESS);\r\n"
"}"
                  );

    CloseHandle(TemplateHandle);
    return(ERROR_SUCCESS);
}

//
// A data item is variable length if it is a variable length array or a
// string that does not have a maxiumum length specified
//
#define WmipIsDataitemVariableLen(DataItem) \
     ( (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) || \
       ((DataItem->DataType == MOFString) && \
        (DataItem->MaxLen == 0)) ||  \
       (DataItem->DataType == MOFZTString) || \
       (DataItem->DataType == MOFAnsiString) )
                                            

BOOLEAN ClassCanCreateHeader(
    PMOFCLASSINFOW ClassInfo,
    ULONG RequiredFlags,
    PULONG ItemCount
    )
{
    ULONG i;
    BOOLEAN HasVariableLength = FALSE;
    PMOFDATAITEMW DataItem;
    ULONG Count;

    Count = 0;
    for (i = 0; i < ClassInfo->DataItemCount; i++)
    {
        DataItem = &ClassInfo->DataItems[i];
            
        if ((RequiredFlags == 0xffffffff) ||
            (DataItem->Flags & RequiredFlags))
            
        {
            if (HasVariableLength)
            {
                *ItemCount = Count;
                return(FALSE);
            }

            Count++;

            HasVariableLength = (! ForceHeaderGeneration) &&
                                WmipIsDataitemVariableLen(DataItem);
        }
    }

    *ItemCount = Count;
    return(TRUE);
}

ULONG DumpCppQuote(
    HANDLE TemplateHandle,
    CBMOFQualList *QualifierList
    )
{
    DWORD QualifierType;
    ULONG Status;
    WCHAR *StringPtr;

    if (QualifierList != NULL)
    {
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(QualifierList,
                                 L"cpp_quote",
                                 &QualifierType,
                                 NULL,
                                 &StringPtr);

        if (Status == ERROR_SUCCESS)
        {
            Status = FilePrint(TemplateHandle,
                               "\n%ws\n",
                               StringPtr);
            BMOFFree(StringPtr);
        }
    } else {
        Status = ERROR_SUCCESS;
    }
    return(Status);
}

PWCHAR MofDataTypeText[15] =
{
    L"LONG",           // 32bit integer
    L"ULONG",          // 32bit unsigned integer
    L"LONGLONG",         // 64bit integer
    L"ULONGLONG",         // 32bit unsigned integer
    L"SHORT",         // 16bit integer
    L"USHORT",         // 16bit unsigned integer
    L"CHAR",         // 8bit integer
    L"UCHAR",         // 8bit unsigned integer
    L"WCHAR",         // Wide (16bit) character
    L"DATETIME",      // Date field
    L"BOOLEAN",         // 8bit Boolean value
    L"MOFEmbedded",         // Embedded class
    L"MOFString",         // Counted String type
    L"MOFZTString",         // NULL terminated unicode string
    L"MOFAnsiString"         // NULL terminated ansi string
};


ULONG GenerateClassHeader(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    PWCHAR ClassName,
    PMOFCLASSINFOW ClassInfo,
    ULONG RequiredFlags
    )
{
    ULONG Status;
    CBMOFDataItem *PropertyObject;
    CBMOFQualList *PropertyQualifier;
    ULONG Status2, QualifierType;
    PVOID ptr;
    ULONG ValueMapCount, DefineValuesCount, ValuesCount;
    PWCHAR *ValueMapPtr, *DefineValuesPtr, *ValuesPtr;
    ULONG BitMapCount, DefineBitMapCount, BitValuesCount, BitMapValue;
    PWCHAR *BitMapPtr, *DefineBitMapPtr, *BitValuesPtr;
    PWCHAR DefineDataId;
    WCHAR DefineDataIdText[MAX_PATH];
    PMOFDATAITEMW DataItem, LastDataItem = NULL;
    PWCHAR Description;
    PMOFCLASS EmbeddedClass;
    ULONG i, j;
    PWCHAR DataTypeText;
    ULONG ItemCount;
    PWCHAR VLCommentText = L"  ";
    WCHAR *StringPtr;

    WmipDebugPrint(("Generate class header for %ws\n", ClassName));

    if ((ClassCanCreateHeader(ClassInfo, RequiredFlags, &ItemCount)) &&
        (ItemCount != 0))
    {       
        Status = FilePrint(TemplateHandle,
                           "typedef struct _%ws\r\n{\r\n",
                           ClassName);
        for (i = 0; i < ClassInfo->DataItemCount; i++)
        {
            DataItem = &ClassInfo->DataItems[i];
            if ((RequiredFlags == 0xffffffff) ||
                (DataItem->Flags & RequiredFlags))
            {
                LastDataItem = DataItem;
                PropertyQualifier = (CBMOFQualList *)DataItem->PropertyQualifierHandle;

                DumpCppQuote(TemplateHandle,
                             PropertyQualifier);
                
                //
                // Handle any bit maps via the DefineBitMap qualifier
                //
                DefineBitMapCount = 0;
                DefineBitMapPtr = NULL;
                BitValuesCount = 0;
                BitValuesPtr = NULL;
                BitMapCount = 0;
                BitMapPtr = NULL;
                QualifierType = VT_ARRAY | VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineBitMap",
                                         &QualifierType,
                                         &DefineBitMapCount,
                                         &DefineBitMapPtr) == ERROR_SUCCESS)
                {
                    QualifierType = VT_ARRAY | VT_BSTR;
                    if (WmipFindMofQualifier(PropertyQualifier,
                                             L"BitValues",
                                             &QualifierType,
                                             &BitValuesCount,
                                             &BitValuesPtr) == ERROR_SUCCESS)
                    {
                        if (DefineBitMapCount == BitValuesCount)
                        {
                            QualifierType = VT_ARRAY | VT_BSTR;
                            if (WmipFindMofQualifier(PropertyQualifier,
                                L"BitMap",
                                &QualifierType,
                                &BitMapCount,
                                &BitMapPtr) != ERROR_SUCCESS)
                            {
                                BitMapPtr = NULL;
                            }
                            
                            FilePrint(TemplateHandle,
                                      "\r\n");
                            for (j = 0; j < DefineBitMapCount; j++)
                            {
                                if ((BitMapPtr != NULL) &&
                                      (j < BitMapCount) &&
                                      (BitMapPtr[j] != NULL))
                                {
                                    FilePrint(TemplateHandle,
                                              "// %ws\r\n",
                                              BitMapPtr[j]);
                                }
                                BitMapValue = 1 << _wtoi(BitValuesPtr[j]);
                                FilePrint(TemplateHandle,
                                          "#define %ws 0x%x\r\n",
                                          DefineBitMapPtr[j],
                                          BitMapValue);
                            }
                            FilePrint(TemplateHandle,
                                      "\r\n");
                        } else {
                            FilePrint(TemplateHandle, "// Warning: Cannot create Bitmap definitions\r\n//          Requires DefineBitMap and BitValues qualifier with same number of elements\r\n\r\n");
                        }
                        
                        for (j = 0; j < BitValuesCount; j++)
                        {
                            BMOFFree(BitValuesPtr[j]);
                        }
                        BMOFFree(BitValuesPtr);
                        
                        if (BitMapPtr != NULL)
                        {
                            for (j = 0; j < BitMapCount; j++)
                            {
                                BMOFFree(BitMapPtr[j]);
                            }
                            BMOFFree(BitMapPtr);
                        }
                    } else {
                        FilePrint(TemplateHandle, "// Warning: Cannot create Bitmap definitions\r\n//          Requires DefineBitMap and BitValues qualifier with same number of elements\r\n\r\n");
                    }
                    
                    for (j = 0; j < DefineBitMapCount; j++)
                    {
                        BMOFFree(DefineBitMapPtr[j]);
                    }
                    BMOFFree(DefineBitMapPtr);
                }
                
                //
                // Handle any enumerations via the DefineValueMap qualifier
                //
                DefineValuesCount = 0;
                DefineValuesPtr = NULL;
                ValuesCount = 0;
                ValuesPtr = NULL;
                ValueMapCount = 0;
                ValueMapPtr = NULL;
                
                QualifierType = VT_ARRAY | VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineValues",
                                         &QualifierType,
                                         &DefineValuesCount,
                                         &DefineValuesPtr) == ERROR_SUCCESS)
                {
                    QualifierType = VT_ARRAY | VT_BSTR;
                    if (WmipFindMofQualifier(PropertyQualifier,
                                             L"ValueMap",
                                             &QualifierType,
                                             &ValueMapCount,
                                             &ValueMapPtr) == ERROR_SUCCESS)
                    {
                        if (DefineValuesCount == ValueMapCount)
                        {
                            QualifierType = VT_ARRAY | VT_BSTR;
                            if (WmipFindMofQualifier(PropertyQualifier,
                                L"Values",
                                &QualifierType,
                                &ValuesCount,
                                &ValuesPtr) != ERROR_SUCCESS)
                            {
                                ValuesPtr = NULL;
                            }
                            
                            FilePrint(TemplateHandle,
                                      "\r\n");
                            for (j = 0; j < DefineValuesCount; j++)
                            {
                                if ((ValuesPtr != NULL) &&
                                      (j < ValuesCount) &&
                                      (ValuesPtr[j] != NULL))
                                {
                                    FilePrint(TemplateHandle,
                                              "// %ws\r\n",
                                              ValuesPtr[j]);
                                }
                                FilePrint(TemplateHandle,
                                          "#define %ws %ws\r\n",
                                          DefineValuesPtr[j],
                                          ValueMapPtr[j]);
                            }
                            FilePrint(TemplateHandle,
                                      "\r\n");
                        } else {
                            FilePrint(TemplateHandle, "// Warning: Cannot create ValueMap enumeration definitions\r\n//          Requires DefineValues and ValueMap qualifier with same number of elements\r\n\r\n");
                        }
                        
                        for (j = 0; j < ValueMapCount; j++)
                        {
                            BMOFFree(ValueMapPtr[j]);
                        }
                        BMOFFree(ValueMapPtr);
                        
                        if (ValuesPtr != NULL)
                        {
                            for (j = 0; j < ValuesCount; j++)
                            {
                                BMOFFree(ValuesPtr[j]);
                            }
                            BMOFFree(ValuesPtr);
                        }
                    } else {
                        FilePrint(TemplateHandle, "// Warning: Cannot create ValueMap enumeration definitions\r\n//          Requires DefineValues and ValueMap qualifier with same number of elements\r\n\r\n");
                    }
                    
                    for (j = 0; j < DefineValuesCount; j++)
                    {
                        BMOFFree(DefineValuesPtr[j]);
                    }
                    BMOFFree(DefineValuesPtr);
                }
                
                //
                // Generate structure element from property information
                //
                if (DataItem->Description != NULL)
                {
                    Description = DataItem->Description;
                } else {
                    Description = L"";
                }
                
                //
                // Produce a #define for the data id of the property
                //
                QualifierType = VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineDataId",
                                         &QualifierType,
                                         NULL,
                                         &DefineDataId) != ERROR_SUCCESS)
                {
                    swprintf(DefineDataIdText,
                             L"%ws_%ws",
                             ClassName,
                             DataItem->Name);
                    DefineDataId = DefineDataIdText;
                }
                
                if (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
                {
                    // Get Embedded Class name
                    EmbeddedClass = WmipFindClassInMofResourceByGuid(
                        MofResource,
                        &DataItem->EmbeddedClassGuid);
                    
                    if (EmbeddedClass != NULL)
                    {
                        if (EmbeddedClass->MofClassInfo->HeaderName != NULL)
                        {
                            DataTypeText = EmbeddedClass->MofClassInfo->HeaderName;
                        } else {
                            DataTypeText = EmbeddedClass->MofClassInfo->Name;
                        }
                    } else {
                        DataTypeText = L"UNKNOWN";
                    }
                    
                } else {
                    // Standard data type
                    if ((DataItem->DataType == MOFString) ||
                          (DataItem->DataType == MOFZTString) ||
                          (DataItem->DataType == MOFAnsiString) ||
                          (DataItem->DataType == MOFDate))
                    {
                        DataTypeText = L"WCHAR";
                    } else {                        
                        DataTypeText = MofDataTypeText[DataItem->DataType];
                    }
                }
                
                if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
                {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws[%d];\r\n"
                                       "    #define %ws_SIZE sizeof(%ws[%d])\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name,
                                       DataItem->FixedArrayElements,
                                       DefineDataId,
                                       DataTypeText,
                                       DataItem->FixedArrayElements);
                } else if (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws[1];\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name);
                } else if (DataItem->DataType == MOFDate) {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  WCHAR %ws[25];\r\n"
                                       "    #define %ws_SIZE sizeof(WCHAR[25])\r\n",
                                       Description,
                                       VLCommentText,
                                       DataItem->Name,
                                       DefineDataId);
                } else if ((DataItem->DataType == MOFString) ||
                           (DataItem->DataType == MOFZTString) ||
                           (DataItem->DataType == MOFAnsiString)) {
                    if (DataItem->MaxLen == 0)
                    {
                        Status = FilePrint(TemplateHandle,
                                           "    // %ws\r\n%ws  CHAR VariableData[1];\r\n",
                                           Description,
                                           VLCommentText);
                    } else {
                        Status = FilePrint(TemplateHandle,
                                           "    // %ws\r\n%ws  WCHAR %ws[%d + 1];\r\n",
                                           Description,
                                           VLCommentText,
                                           DataItem->Name,
                                           DataItem->MaxLen
                                          );
                    }
                } else {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws;\r\n"
                                       "    #define %ws_SIZE sizeof(%ws)\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name,
                                       DefineDataId,
                                       DataTypeText);
                }
                
                if (WmipIsDataitemVariableLen(DataItem))
                {
                    VLCommentText = L"//";
                }
                
                Status = FilePrint(TemplateHandle,
                                   "    #define %ws_ID %d\r\n\r\n",
                                   DefineDataId,
                                   i+1
                                  );
                
                if (DefineDataId != DefineDataIdText)
                {
                    BMOFFree(DefineDataId);
                }
            }
        }
        
        Status = FilePrint(TemplateHandle,
                       "} %ws, *P%ws;\r\n\r\n",
                       ClassName,
                       ClassName);

        if ((LastDataItem != NULL) &&
            ! ( (LastDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) ||
                (LastDataItem->DataType == MOFString) ||
                (LastDataItem->DataType == MOFZTString) ||
                (LastDataItem->DataType == MOFAnsiString) ) )
        {
            FilePrint(TemplateHandle,
    "#define %ws_SIZE (FIELD_OFFSET(%ws, %ws) + %ws_%ws_SIZE)\r\n\r\n",
                      ClassName,
                      ClassName,
                      LastDataItem->Name,
                      ClassName,
                      LastDataItem->Name);
        }
                  
    } else {
        
#if DBG
        printf("Warning: Header for class %ws cannot be created\n",
               ClassName);
#endif

        if (ItemCount != 0)
        {
            Status = FilePrint(TemplateHandle,
                           "// Warning: Header for class %ws cannot be created\r\n"
                           "typedef struct _%ws\r\n{\r\n    char VariableData[1];\r\n\r\n",
                           ClassName,
                           ClassName);
            
            Status = FilePrint(TemplateHandle,
                       "} %ws, *P%ws;\r\n\r\n",
                       ClassName,
                       ClassName);

        } else {
            Status = ERROR_SUCCESS;
        }
    }
    return(Status);
}


ULONG GenerateHTemplate(
    PCHAR TemplateFile,
    PMOFRESOURCE MofResource
    )
{
    HANDLE TemplateHandle;
    ULONG Status;
    ULONG i,j;
    PWCHAR DataTypeText, ClassName;
    WCHAR MethodClassName[MAX_PATH];
    PWCHAR GuidName1, GuidName2;
    PWCHAR GuidSuffix1, GuidSuffix2;
    PMOFDATAITEMW DataItem;
    PMOFCLASSINFOW ClassInfo, MethodClassInfo;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PCHAR p;
    ULONG Len;
    CBMOFObj *ClassObject;
    PWCHAR MethodBaseClassName;
    DWORD QualifierType;
    short BooleanValue; 

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    //
    // move back to only get the last part of the path and convert any
    // . into _
    //
    Len = strlen(TemplateFile);
    p = TemplateFile + Len;
    while ((p >= TemplateFile) && (*p != '\\'))
    {
        if (*p == '.')
        {
            *p = '_';
        }
        p--;
    }
    
    p++;

    Status = FilePrint(TemplateHandle,
                       "#ifndef _%s_\r\n#define _%s_\r\n\r\n",
                        p, p);


    //
    // Loop over all mof classes
    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);

        ClassInfo = MofClass->MofClassInfo;
        ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;

        QualifierType = VT_BOOL;
        Status = WmipFindMofQualifier((CBMOFQualList *)ClassInfo->ClassQualifierHandle,
                                      L"WmiGenerateHeader",
                                      &QualifierType,
                                              NULL,
                                      (PVOID)&BooleanValue);

        if ((Status != ERROR_SUCCESS) ||
            ((Status == ERROR_SUCCESS) && BooleanValue))
        {

            if (ClassInfo->HeaderName != NULL)
            {
                ClassName = ClassInfo->HeaderName;
            } else {
                ClassName = ClassInfo->Name;
            }

            if (ClassInfo->GuidName1 != NULL)
            {
                GuidName1 = ClassInfo->GuidName1;
                GuidSuffix1 = L"";
            } else {
                GuidName1 = ClassInfo->Name;
                GuidSuffix1 = L"Guid";
            }

            if (ClassInfo->GuidName2 != NULL)
            {
                GuidName2 = ClassInfo->GuidName2;
                GuidSuffix2 = L"";
            } else {
                GuidName2 = ClassInfo->Name;
                GuidSuffix2 = L"_GUID";
            }

            Status = FilePrint(TemplateHandle,
                                "// %ws - %ws\r\n",
                                ClassInfo->Name,
                                ClassName);
            if (ClassInfo->Description != NULL)
            {
                Status = FilePrint(TemplateHandle,
                               "// %ws\r\n",
                               ClassInfo->Description);
            }

            Status = DumpCppQuote(TemplateHandle,
                                (CBMOFQualList *)ClassInfo->ClassQualifierHandle);

            Status = FilePrint(TemplateHandle,
                               "#define %ws%ws \\\r\n"
                               "    { 0x%08x,0x%04x,0x%04x, { 0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x } }\r\n\r\n",
                               GuidName1, GuidSuffix1,
                               ClassInfo->Guid.Data1, ClassInfo->Guid.Data2,
                               ClassInfo->Guid.Data3,
                               ClassInfo->Guid.Data4[0], ClassInfo->Guid.Data4[1],
                               ClassInfo->Guid.Data4[2], ClassInfo->Guid.Data4[3],
                               ClassInfo->Guid.Data4[4], ClassInfo->Guid.Data4[5],
                               ClassInfo->Guid.Data4[6], ClassInfo->Guid.Data4[7]);

            Status = FilePrint(TemplateHandle,
                               "#if ! (defined(MIDL_PASS))\r\n"
                               "DEFINE_GUID(%ws%ws, \\\r\n"
                               "            0x%08x,0x%04x,0x%04x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x);\r\n"
                               "#endif\r\n\r\n",
                               GuidName2, GuidSuffix2,
                               ClassInfo->Guid.Data1, ClassInfo->Guid.Data2,
                               ClassInfo->Guid.Data3,
                               ClassInfo->Guid.Data4[0], ClassInfo->Guid.Data4[1],
                               ClassInfo->Guid.Data4[2], ClassInfo->Guid.Data4[3],
                               ClassInfo->Guid.Data4[4], ClassInfo->Guid.Data4[5],
                               ClassInfo->Guid.Data4[6], ClassInfo->Guid.Data4[7]);


            if (ClassInfo->MethodCount > 0)
            {
                Status = FilePrint(TemplateHandle,
                                   "//\r\n// Method id definitions for %ws\r\n",
                                   ClassInfo->Name);
            }

            for (i = 0; i < ClassInfo->MethodCount; i++)
            {
                DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];

                Status = DumpCppQuote(TemplateHandle,
                                    (CBMOFQualList *)DataItem->PropertyQualifierHandle);

                Status = FilePrint(TemplateHandle,
                                   "#define %ws     %d\r\n",
                                   DataItem->Name,
                                   DataItem->MethodId);


                MethodClassInfo = DataItem->MethodClassInfo;

                if (DataItem->HeaderName != NULL)
                {
                    MethodBaseClassName = DataItem->HeaderName;
                } else {
                    MethodBaseClassName = DataItem->Name;               
                }

                if (DoMethodHeaderGeneration)
                {
                    swprintf(MethodClassName, L"%ws_IN", MethodBaseClassName);
                    Status = GenerateClassHeader(TemplateHandle,
                                                 MofResource,
                                                 MethodClassName,
                                                 MethodClassInfo,
                                                 MOFDI_FLAG_INPUT_METHOD);

                    swprintf(MethodClassName, L"%ws_OUT", MethodBaseClassName);
                    Status = GenerateClassHeader(TemplateHandle,
                                                 MofResource,
                                                 MethodClassName,
                                                 MethodClassInfo,
                                                 MOFDI_FLAG_OUTPUT_METHOD);
                }

            }

            Status = FilePrint(TemplateHandle,
                               "\r\n");

            Status = GenerateClassHeader(TemplateHandle,
                                         MofResource,
                                         ClassName,
                                         ClassInfo,
                                         0xffffffff);

        }
        MofClassList = MofClassList->Flink;
    }

    Status = FilePrint(TemplateHandle,
                       "#endif\r\n");

    CloseHandle(TemplateHandle);
    if (Status != ERROR_SUCCESS)
    {
        DeleteFile(TemplateFile);
    }

    return(Status);
}

ULONG FilePrintDataItem(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    ULONG Level,
    PCHAR Prefix,
    PCHAR DisplayPrefix,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem
)
{
    ULONG Status = ERROR_SUCCESS;
    CHAR NewPrefix[MAX_PATH];
    CHAR NewDisplayPrefix[MAX_PATH];
    CHAR ArrayLenBuffer[MAX_PATH];
    PCHAR ArrayLen;
    PMOFCLASSINFOW EmbeddedClassInfo;
    PMOFCLASS EmbeddedClass;
    PMOFDATAITEMW NewDataItem;
    ULONG j;

    if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
    {
        sprintf(ArrayLenBuffer, "%d",
                                DataItem->FixedArrayElements);
        ArrayLen = ArrayLenBuffer;
    } else if (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) {
        sprintf(ArrayLenBuffer, "%s%ws",
                    Prefix,
                      ClassInfo->DataItems[DataItem->VariableArraySizeId-1].Name);
        ArrayLen = ArrayLenBuffer;
    } else {
        ArrayLen = NULL;
    }

    if (ArrayLen != NULL)
    {
        Status = FilePrint(TemplateHandle,
                                       "    for i%d = 0 to (%s-1)\r\n",
                                       Level,
                                       ArrayLen);
        sprintf(NewPrefix, "%s%ws(i%d)",
                  Prefix,
                  DataItem->Name,
                  Level);
        sprintf(NewDisplayPrefix, "%s%ws(\"&i%d&\")",
                  DisplayPrefix,
                  DataItem->Name,
                  Level);
    } else {
        sprintf(NewPrefix, "%s%ws",
                  Prefix,
                  DataItem->Name);

        sprintf(NewDisplayPrefix, "%s%ws",
                  DisplayPrefix,
                  DataItem->Name);

    }

    if (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &DataItem->EmbeddedClassGuid);

        if (EmbeddedClass != NULL)
          {
            strcat(NewPrefix, ".");
            strcat(NewDisplayPrefix, ".");

            EmbeddedClassInfo = EmbeddedClass->MofClassInfo;
            for (j = 0; j < EmbeddedClassInfo->DataItemCount; j++)
            {
                NewDataItem = &EmbeddedClassInfo->DataItems[j];
                   Status = FilePrintDataItem(TemplateHandle,
                                           MofResource,
                                           Level+1,
                                           NewPrefix,
                                           NewDisplayPrefix,
                                           EmbeddedClassInfo,
                                           NewDataItem);
            }
        } else {
#if DBG
            printf("WARNING - Cannot create test for %s, cannot find embedded class\n",
                         NewPrefix);
#endif
                FilePrint(TemplateHandle, "REM WARNING - Cannot create test for %s, cannot find embedded class\r\n",
                         NewPrefix);
        }
    } else {
        Status = FilePrint(TemplateHandle,
                  "    a.WriteLine(\"        %s=\" & %s)\r\n",
                  NewDisplayPrefix,
                  NewPrefix);
    }

    if (ArrayLen != NULL)
    {
        Status = FilePrint(TemplateHandle,
                           "    next 'i%d\r\n",
                           Level);
    }

    return(Status);
}

BOOLEAN CanCreateTest(
    PMOFCLASSINFOW ClassInfo
            )
{
    //
    // Cannot create tests for embedded classes or events
    if (((ClassInfo->Flags & MOFCI_RESERVED1) == 0) ||
        (ClassInfo->Flags & MOFCI_FLAG_EVENT))

    {
        return(FALSE);
    }

    return(TRUE);
}

ULONG GenerateTTemplate(
    PCHAR TemplateFile,
    PMOFRESOURCE MofResource
    )
{
    HANDLE TemplateHandle;
    ULONG Status;
    ULONG i;
    PMOFDATAITEMW DataItem;
    PMOFCLASSINFOW ClassInfo;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PCHAR p, p1;

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle != NULL) && (TemplateHandle != INVALID_HANDLE_VALUE))
    {
        p = TemplateFile;
        p1 = TemplateFile;
        while ((*p != '.') && (*p != 0))
        {
            if (*p == '\\')
            {
                p1 = p+1;
            }
            p++;
        }

        if (*p == '.')
        {
            *p = 0;
        }

        Status = FilePrint(TemplateHandle,
                           "REM Note that missing classes in log file mean tthe hat WMI cannot access them.\r\n"
                           "REM Most likely this indicates a problem with the driver.\r\n"
                           "REM See %%windir%%\\system32\\wbem\\wmiprov.log and nt eventlog for more details.\r\n"
                           "REM You could also delete the line On Error Resume Next and examine the\r\n"
                           "REM specific VBScript error\r\n\r\n\r\n");
        Status = FilePrint(TemplateHandle,
                     "On Error Resume Next\r\n\r\n");

        Status = FilePrint(TemplateHandle,
                     "Set fso = CreateObject(\"Scripting.FileSystemObject\")\r\n");
        Status = FilePrint(TemplateHandle,
                     "Set a = fso.CreateTextFile(\"%s.log\", True)\r\n",
                     p1);

        Status = FilePrint(TemplateHandle,
                        "Set Service = GetObject(\"winmgmts:{impersonationLevel=impersonate}!root/wmi\")\r\n");

        //
        // Loop over all mof classes
        MofClassList = MofResource->MRMCHead.Flink;
        while (MofClassList != &MofResource->MRMCHead)
        {
            MofClass = CONTAINING_RECORD(MofClassList,
                                             MOFCLASS,
                                             MCMRList);

            ClassInfo = MofClass->MofClassInfo;

            if (CanCreateTest(ClassInfo))
            {
                Status = FilePrint(TemplateHandle,
                                "Rem %ws - %ws\r\n",
                                ClassInfo->Name,
                          ClassInfo->Description ? ClassInfo->Description : L"");

                Status = FilePrint(TemplateHandle,
                          "Set enumSet = Service.InstancesOf (\"%ws\")\r\n"
                          "a.WriteLine(\"%ws\")\r\n",
                          ClassInfo->Name,
                          ClassInfo->Name);

                Status = FilePrint(TemplateHandle,
                        "for each instance in enumSet\r\n");

                Status = FilePrint(TemplateHandle,
                  "    a.WriteLine(\"    InstanceName=\" & instance.InstanceName)\r\n");

                for (i = 0; i < ClassInfo->DataItemCount; i++)
                {
                    DataItem = &ClassInfo->DataItems[i];
                    FilePrintDataItem(TemplateHandle,
                                      MofResource,
                                      1,
                                      "instance.",
                                      "instance.",
                                      ClassInfo,
                                      DataItem);

                }
            Status = FilePrint(TemplateHandle,
                                   "next 'instance\r\n\r\n");

            }

            MofClassList = MofClassList->Flink;
        }

        Status = FilePrint(TemplateHandle,
                           "a.Close\r\n"
                           "Wscript.Echo \"%s Test Completed, see %s.log for details\"\r\n",
                           p1, p1);

        CloseHandle(TemplateHandle);
        if (Status != ERROR_SUCCESS)
        {
            DeleteFile(TemplateFile);
        }
    } else {
        Status = GetLastError();
    }
    return(Status);
}

ULONG GenerateXTemplate(
    PCHAR TemplateFile
    )
{
    HANDLE TemplateHandle;
    ULONG Status;

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    Status = GenerateBinaryMofData(TemplateHandle);

    CloseHandle(TemplateHandle);
    if (Status != ERROR_SUCCESS)
    {
        DeleteFile(TemplateFile);
    }

    return(Status);

}
typedef void (*PROPERTYCALLBACK)(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                                 
    );


void EnumerateClassProperties(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PROPERTYCALLBACK Callback,
    BOOLEAN Recurse,
    PVOID Context,
    ULONG RecursionLevel
    )
{
    ULONG i;
    WCHAR I[1];
    WCHAR F[1];

    if (InstanceName == NULL)
    {
        I[0] = UNICODE_NULL;
        InstanceName = I;
    }

    if (FormName == NULL)
    {
        F[0] = UNICODE_NULL;
        FormName = F;
    }

    for (i = 0; i < ClassInfo->DataItemCount; i++)
    {
        WCHAR FName[MAX_PATH];
        WCHAR IName[MAX_PATH];
        PMOFCLASS EmbeddedClass;
        PMOFDATAITEMW DataItem;

        DataItem = &ClassInfo->DataItems[i];
          wcscpy(IName, InstanceName);
           wcscat(IName, L".");
           wcscat(IName, DataItem->Name);

        wcscpy(FName, FormName);
        wcscat(FName, DataItem->Name);

        if (DataItem->Flags & (MOFDI_FLAG_FIXED_ARRAY |
                               MOFDI_FLAG_VARIABLE_ARRAY))
        {
            wcscat(IName, L"(");
            wcscat(IName, FName);
            wcscat(IName, L"Index)");
        }

        (*Callback)(TemplateHandle,
                    FName,
                    IName,
                    InstanceName,
                    MofResource,
                    ClassInfo,
                    DataItem,
                    i,
                    Context,
                    RecursionLevel);


        if (Recurse && (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
        {
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &DataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                EnumerateClassProperties(TemplateHandle,
                                     FName,
                                     IName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     Callback,
                                     Recurse,
                                     Context,
                                     RecursionLevel+1);
            }
        }
    }
}


void GenerateChangeText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    //
    // Generate code to change the contents of a property
    //
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
        FilePrint(TemplateHandle,
"      Instance%ws = TheForm.%wsText.Value\r\n",
             InstanceName,
             FormName);
    }
}

void GenerateReloadText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    //
    // Generate code to redisplay the contents of the property
    //
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
        FilePrint(TemplateHandle,
"        TheForm.%wsText.Value = Instance%ws\r\n",
             FormName,
             InstanceName);
    }

    if (DataItem->Flags & (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"        TheForm.%wsIndexText.Value = %wsIndex\r\n",
           FormName, FormName);

        if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
        {
            FilePrint(TemplateHandle,
"        %wsMaxIndex = %d\r\n",
                      FormName, DataItem->FixedArrayElements);
        } else {
            FilePrint(TemplateHandle,
"        %wsMaxIndex = Instance%ws.%ws\r\n",
                  FormName, InstancePrefix,
                  ClassInfo->DataItems[DataItem->VariableArraySizeId-1].Name);
        }
    }

}

void GenerateTextFormText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)) {
        FilePrint(TemplateHandle,
"<p class=MsoNormal>%ws: <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><INPUT TYPE=\"TEXT\" SIZE=\"96\" NAME=\"%wsText\"></p>\r\n"
"\r\n",
             FormName, FormName);
     }

    if (DataItem->Flags &
        (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=Next%wsButton type=BUTTON value=Next OnClick=\"NextIndexButton_OnClick %wsIndex, %wsMaxIndex\">\r\n"
"\r\n"
"<input name=Prev%wsButton type=BUTTON value=Previous OnClick=\"PrevIndexButton_OnClick %wsIndex, %wsMaxIndex\">\r\n"
"\r\n"
"%wsArrayIndex: <INPUT TYPE=\"TEXT\" SIZE=\"5\" NAME=\"%wsIndexText\">\r\n"
"\r\n"
"<input name=GoTo%wsButton type=BUTTON value=GoTo OnClick=\"GoToIndexButton_OnClick %wsIndex, %wsMaxIndex, Document.ClassForm.%wsIndexText.Value\">\r\n"
"\r\n",
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName);
    }

}

void GenerateArrayDimsText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    //
    // Declare an index variable that tracks the current index of an array
    //
    if (MofDataItem->Flags &
            (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"Dim %wsIndex\r\n"
"%wsIndex = 0\r\n"
"Dim %wsMaxIndex\r\n"
"%wsMaxIndex = 1\r\n",
                  FormName,
                  FormName,
                  FormName,
                  FormName);
    }
}

void GenerateMethodInL2Text(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                            
)
{
    if (! (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
            FilePrint(TemplateHandle,
"      %ws = TheForm.%ws%wsText.Value\r\n",
                  InstanceName,
                  Context,
                  FormName);        
    } else {
        FilePrint(TemplateHandle,
"      %ws = Service.Get(\"%ws\")\r\n",
                          InstanceName,
                          (PWCHAR)MofDataItem->EcTempPtr +
                                         (sizeof(L"object") / sizeof(WCHAR)));
    }
}

void GenerateMethodInText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel
)
{
    //
    // Declare classes for all IN and OUT embedded classes
    //
    if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        PWCHAR EmbeddedClassName = (PWCHAR)MofDataItem->EcTempPtr +
                                         (sizeof(L"object") / sizeof(WCHAR));

        if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
        {                                   
            FilePrint(TemplateHandle,
"      Set %ws = Service.Get(\"%ws\").SpawnInstance_\r\n",
                      FormName,
                      EmbeddedClassName);
        } else {
            FilePrint(TemplateHandle,
"      Dim %ws\r\n",
                      FormName);
        }
    }

    if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
    {

        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            PMOFCLASS EmbeddedClass;
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &MofDataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                          
                EnumerateClassProperties(TemplateHandle,
                                     FormName,
                                     FormName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     GenerateMethodInL2Text,
                                     TRUE,
                                     Context,
                                     RecursionLevel+1);
            }



        } else {
            FilePrint(TemplateHandle,
"      %ws = TheForm.%ws%wsText.Value\r\n",
                  FormName,
                  Context,
                  FormName);
        }
    }
}


void GenerateMethodOutL2Text(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    if (! (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
            FilePrint(TemplateHandle,
"        TheForm.%ws%wsText.Value = %ws\r\n",

                  Context,
                  FormName,
                  InstanceName);
    }
}

void GenerateMethodOutText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                           
)
{
    if (MofDataItem->Flags & (MOFDI_FLAG_OUTPUT_METHOD))
    {
        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            PMOFCLASS EmbeddedClass;
            PWCHAR EmbeddedClassName = (PWCHAR)MofDataItem->EcTempPtr +
                                         (sizeof(L"object") / sizeof(WCHAR));
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &MofDataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                EnumerateClassProperties(TemplateHandle,
                                     FormName,
                                     FormName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     GenerateMethodOutL2Text,
                                     TRUE,
                                     Context,
                                     RecursionLevel+1);
            }



        } else {
            FilePrint(TemplateHandle,
"        TheForm.%ws%wsText.Value = %ws\r\n",

                  Context,
                  FormName,
                  FormName);
        }
    }
}

void GenerateMethodCallText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel
)
{
    //
    // Declare an index variable that tracks the current index of an array
    //
    FilePrint(TemplateHandle,
" %ws",
                  FormName);

    if (Counter != PtrToUlong(Context))
    {
        FilePrint(TemplateHandle, ", ");
    }
}

void GenerateMethodControlText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context,
    ULONG RecursionLevel                             
)
{
    PWCHAR MethodName = (PWCHAR)Context;

    FilePrint(TemplateHandle,
"<p>  "
             );

    if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
    {
        FilePrint(TemplateHandle,
                   " [in] ");
    }

    if (MofDataItem->Flags & (MOFDI_FLAG_OUTPUT_METHOD))
    {
        FilePrint(TemplateHandle,
                   " [out] ");
    }


    if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        FilePrint(TemplateHandle, "%ws </p>\r\n", FormName);
    } else {
        FilePrint(TemplateHandle,
" %ws <INPUT TYPE=\"TEXT\" SIZE=\"70\" NAME=\"%ws%wsText\"></p>\r\n",
                  FormName,
                  MethodName,
                  FormName);
    }

    if (MofDataItem->Flags &
        (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=Next%wsButton type=BUTTON value=Next OnClick=\"NextIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex\">\r\n"
"\r\n"
"<input name=Prev%wsButton type=BUTTON value=Previous OnClick=\"PrevIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex\">\r\n"
"\r\n"
"%ws%wsArrayIndex: <INPUT TYPE=\"TEXT\" SIZE=\"5\" NAME=\"%ws%wsIndexText\">\r\n"
"\r\n"
"<input name=GoTo%ws%wsButton type=BUTTON value=GoTo OnClick=\"GoToIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex, Document.ClassForm.%ws%wsIndexText.Value\">\r\n"
"\r\n",
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName);
    }

}


typedef void (*METHODCALLBACK)(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
    );


void EnumerateClassMethods(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    METHODCALLBACK Callback,
    PVOID Context
    )
{
    PMOFDATAITEMW DataItem;
    ULONG i;

    for (i = 0; i < ClassInfo->MethodCount; i++)
    {
        DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];

        WmipAssert(DataItem->Flags & MOFDI_FLAG_METHOD);

        (*Callback)(TemplateHandle,
                    DataItem->Name,
                    MofResource,
                    ClassInfo,
                    DataItem,
                    i,
                    Context);
    }
}

void GenerateMethodButtonsText(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
)
{
    PMOFCLASSINFOW MethodClassInfo;

    FilePrint(TemplateHandle,
"<p class=MsoNormal>Method %ws: <input name=%wsButton type=BUTTON value=Execute> </p>\r\n",
        MethodName, MethodName);

    MethodClassInfo = MethodDataItem->MethodClassInfo;
    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodControlText,
                             TRUE,
                             MethodName,
                             0);


}

void GenerateMethodSubsText(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
)
{
    PMOFCLASSINFOW MethodClassInfo;

    FilePrint(TemplateHandle,
"Sub %wsButton_OnClick\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
"      Set TheForm = Document.ClassForm\r\n"
"      Err.Clear\r\n",
               MethodName);

    MethodClassInfo = MethodDataItem->MethodClassInfo;
    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodInText,
                             FALSE,
                             MethodName,
                            0);

    FilePrint(TemplateHandle,
"      Instance.%ws ",
            MethodName);

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodCallText,
                             FALSE,
                             UlongToPtr(MethodClassInfo->DataItemCount-1),
                             0);

    FilePrint(TemplateHandle,
"\r\n      if Err.Number = 0 Then\r\n"
             );

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodOutText,
                             FALSE,
                             MethodName,
                             0);


    FilePrint(TemplateHandle,
"        MsgBox \"Method Execution Succeeded\"\r\n"
"      Else\r\n"
"        MsgBox Err.Description,, \"Method Execution Failed\"\r\n"
"      End if\r\n"
"    End if\r\n"
"  End if\r\n"
"End Sub\r\n\r\n"
        );

}



ULONG GenerateClassWebPage(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    PMOFRESOURCE MofResource
    )
{
    PMOFCLASSINFOW ClassInfo = MofClass->MofClassInfo;
    BOOLEAN IsEvent=(ClassInfo->Flags & MOFCI_FLAG_EVENT) == MOFCI_FLAG_EVENT;


    FilePrint(TemplateHandle,
"<html xmlns:v=\"urn:schemas-microsoft-com:vml\"\r\n"
"xmlns:o=\"urn:schemas-microsoft-com:office:office\"\r\n"
"xmlns:w=\"urn:schemas-microsoft-com:office:word\"\r\n"
"xmlns=\"http://www.w3.org/TR/REC-html40\">\r\n"
"\r\n"
"<head>\r\n"
"<meta http-equiv=Content-Type content=\"text/html; charset=us-ascii\">\r\n"
"<meta name=ProgId content=Word.Document>\r\n"
"<meta name=Generator content=\"Microsoft Word 9\">\r\n"
"<meta name=Originator content=\"Microsoft Word 9\">\r\n"
"<link rel=File-List href=\"./valid_files/filelist.xml\">\r\n"
"<link rel=Edit-Time-Data href=\"./valid_files/editdata.mso\">\r\n"
"<!--[if !mso]>\r\n"
"<style>\r\n"
"v\\:* {behavior:url(#default#VML);}\r\n"
"o\\:* {behavior:url(#default#VML);}\r\n"
"w\\:* {behavior:url(#default#VML);}\r\n"
".shape {behavior:url(#default#VML);}\r\n"
"</style>\r\n"
"<![endif]-->\r\n"
"<title>Class %ws</title>\r\n"
"<!--[if gte mso 9]><xml>\r\n"
" <o:DocumentProperties>\r\n"
"  <o:Author>Wmi Mof Checking Tool</o:Author>\r\n"
"  <o:Template>Normal</o:Template>\r\n"
"  <o:LastAuthor>Wmi Mof Checking Tool</o:LastAuthor>\r\n"
"  <o:Revision>2</o:Revision>\r\n"
"  <o:TotalTime>3</o:TotalTime>\r\n"
"  <o:Created>1999-09-10T01:09:00Z</o:Created>\r\n"
"  <o:LastSaved>1999-09-10T01:12:00Z</o:LastSaved>\r\n"
"  <o:Pages>1</o:Pages>\r\n"
"  <o:Words>51</o:Words>\r\n"
"  <o:Characters>292</o:Characters>\r\n"
"  <o:Company>Microsoft</o:Company>\r\n"
"  <o:Lines>2</o:Lines>\r\n"
"  <o:Paragraphs>1</o:Paragraphs>\r\n"
"  <o:CharactersWithSpaces>358</o:CharactersWithSpaces>\r\n"
"  <o:Version>9.2720</o:Version>\r\n"
" </o:DocumentProperties>\r\n"
"</xml><![endif]--><!--[if gte mso 9]><xml>\r\n"
" <w:WordDocument>\r\n"
"  <w:Compatibility>\r\n"
"   <w:UseFELayout/>\r\n"
"  </w:Compatibility>\r\n"
" </w:WordDocument>\r\n"
"</xml><![endif]-->\r\n"
"<style>\r\n"
"<!--\r\n"
" /* Font Definitions */\r\n"
"@font-face\r\n"
"    {font-family:\"MS Mincho\";\r\n"
"    panose-1:2 2 6 9 4 2 5 8 3 4;\r\n"
"    mso-font-alt:\"\\FF2D\\FF33 \\660E\\671D\";\r\n"
"    mso-font-charset:128;\r\n"
"    mso-generic-font-family:roman;\r\n"
"    mso-font-format:other;\r\n"
"    mso-font-pitch:fixed;\r\n"
"    mso-font-signature:1 134676480 16 0 131072 0;}\r\n"
"@font-face\r\n"
"    {font-family:\"\\@MS Mincho\";\r\n"
"    panose-1:2 2 6 9 4 2 5 8 3 4;\r\n"
"    mso-font-charset:128;\r\n"
"    mso-generic-font-family:modern;\r\n"
"    mso-font-pitch:fixed;\r\n"
"    mso-font-signature:-1610612033 1757936891 16 0 131231 0;}\r\n"
" /* Style Definitions */\r\n"
"p.MsoNormal, li.MsoNormal, div.MsoNormal\r\n"
"    {mso-style-parent:\"\";\r\n"
"    margin:0in;\r\n"
"    margin-bottom:.0001pt;\r\n"
"    mso-pagination:widow-orphan;\r\n"
"    font-size:12.0pt;\r\n"
"    font-family:\"Times New Roman\";\r\n"
"    mso-fareast-font-family:\"MS Mincho\";}\r\n"
"@page Section1\r\n"
"    {size:8.5in 11.0in;\r\n"
"    margin:1.0in 1.25in 1.0in 1.25in;\r\n"
"    mso-header-margin:.5in;\r\n"
"    mso-footer-margin:.5in;\r\n"
"    mso-paper-source:0;}\r\n"
"div.Section1\r\n"
"    {page:Section1;}\r\n"
"-->\r\n"
"</style>\r\n"
"<!--[if gte mso 9]><xml>\r\n"
" <o:shapedefaults v:ext=\"edit\" spidmax=\"1026\"/>\r\n"
"</xml><![endif]--><!--[if gte mso 9]><xml>\r\n"
" <o:shapelayout v:ext=\"edit\">\r\n"
"  <o:idmap v:ext=\"edit\" data=\"1\"/>\r\n"
" </o:shapelayout></xml><![endif]-->\r\n"
"</head>\r\n"
"\r\n"
"<body lang=EN-US style='tab-interval:.5in'>\r\n"
"\r\n"
"<div class=Section1>\r\n"
"\r\n"
"<h3>Class %ws</h3>\r\n"
"\r\n"
"\r\n"
"<div class=MsoNormal align=center style='text-align:center'>\r\n"
"\r\n"
"<hr size=2 width=\"100%\" align=center>\r\n"
"\r\n"
"</div>\r\n"
"\r\n"
"\r\n"
"<form NAME=ClassForm>\r\n"
"\r\n"
"<p class=MsoNormal><span style='display:none;mso-hide:all'><script language=\"VBScript\">\r\n"
"<!--\r\n"
"On Error Resume Next\r\n"
"Dim Locator\r\n"
"Dim Service\r\n"
"Dim Collection\r\n"
"Dim InstancePaths()\r\n"
"Dim InstanceCount\r\n"
"Dim CurrentInstanceIndex\r\n"
"\r\n",
        ClassInfo->Name, ClassInfo->Name, ClassInfo->Name);


    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateArrayDimsText,
                             TRUE,
                             NULL,
                             0);

    FilePrint(TemplateHandle, "\r\n");

    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"Dim LastEventObject\r\n"
"Dim ReceivedEvent\r\n"
"ReceivedEvent = FALSE\r\n"
"InstanceCount = 1\r\n"
"\r\n"
"Sub window_onLoad \r\n"
"  Set Locator = CreateObject(\"WbemScripting.SWbemLocator\")\r\n"
"  Locator.Security_.Privileges.AddAsString \"SeSecurityPrivilege\"\r\n"
"  Set Service = Locator.ConnectServer(, \"root\\wmi\")\r\n"
"  Service.Security_.ImpersonationLevel=3\r\n"
"  On Error Resume Next\r\n"
"  Err.Clear\r\n"
"  Service.ExecNotificationQueryAsync mysink, _\r\n"
"           \"select * from %ws\"\r\n"
"\r\n"
"  if Err.Number <> 0 Then\r\n"
"    MsgBox Err.Description,, \"Error Registering for event\"\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n",
                 ClassInfo->Name);

    FilePrint(TemplateHandle,
"Sub ReloadInstance\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if ReceivedEvent Then\r\n"
"      Set Instance = LastEventObject\r\n"
"      TheForm.InstanceNameText.Value = Instance.InstanceName\r\n"
             );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateReloadText,
                             TRUE,
                             NULL,
                             0);

        FilePrint(TemplateHandle,
"  End If\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
                    );
    } else {
        FilePrint(TemplateHandle,
"Set Locator = CreateObject(\"WbemScripting.SWbemLocator\")\r\n"
"' Note that Locator.ConnectServer can be used to connect to remote computers\r\n"
"Set Service = Locator.ConnectServer(, \"root\\wmi\")\r\n"
"Service.Security_.ImpersonationLevel=3\r\n"
             );
        
        FilePrint(TemplateHandle,
"Set Collection = Service.InstancesOf (\"%ws\")\r\n"
"\r\n"
"InstanceCount = 0\r\n"
"Err.Clear\r\n"
"for each Instance in Collection\r\n"
"    if Err.Number = 0 Then\r\n"
"      InstanceCount = InstanceCount + 1\r\n"
"\r\n"
"      ReDim Preserve InstancePaths(InstanceCount)\r\n"
"\r\n"
"      Set ObjectPath = Instance.Path_\r\n"
"      InstancePaths(InstanceCount) = ObjectPath.Path\r\n"
"    End If\r\n"
"next 'Instance\r\n"
"\r\n"
"if InstanceCount = 0 Then\r\n"
"  MsgBox \"No instances available for this class\"\r\n"
"Else\r\n"
"  CurrentInstanceIndex = 1\r\n"
"End if\r\n"
"\r\n",
    ClassInfo->Name
    );

        FilePrint(TemplateHandle,
"Sub ChangeButton_OnClick\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
    );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateChangeText,
                             TRUE,
                             NULL,
                             0);

        FilePrint(TemplateHandle,
"\r\n"
"      Err.Clear\r\n"
"      Instance.Put_()\r\n"
"      if Err.Number <> 0 Then\r\n"
"        MsgBox Err.Description, ,CurrentObjectPath\r\n"
"      End If\r\n"
"    Else\r\n"
"        MsgBox Err.Description, ,CurrentObjectPath\r\n"
"    End If\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub ReloadInstance\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if InstanceCount = 0 Then\r\n"
"    TheForm.InstanceNameText.Value = \"No Instances Available\"\r\n"
"  Else\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
"\r\n"
"      TheForm.InstanceNameText.Value = InstancePaths(CurrentInstanceIndex)\r\n"
             );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateReloadText,
                             TRUE,
                             NULL,
                             0);

        FilePrint(TemplateHandle,
"    Else\r\n"
"      MsgBox Err.Description, ,CurrentObjectPath\r\n"
"    End If\r\n"
"  End If\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
"Sub RefreshButton_OnClick\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub NextButton_OnClick\r\n"
"\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    if CurrentInstanceIndex = InstanceCount Then\r\n"
"      CurrentInstanceIndex = 1\r\n"
"    Else \r\n"
"      CurrentInstanceIndex = CurrentInstanceIndex + 1\r\n"
"    End If\r\n"
"    call ReloadInstance\r\n"
"  End if\r\n"
"\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
"Sub PrevButton_OnClick\r\n"
"\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    if CurrentInstanceIndex = 1 Then\r\n"
"      CurrentInstanceIndex = InstanceCount\r\n"
"    Else\r\n"
"      CurrentInstanceIndex = CurrentInstanceIndex - 1\r\n"
"    End if\r\n"
"    call ReloadInstance\r\n"
"  End if\r\n"
"\r\n"
"\r\n"
"End Sub\r\n"
"\r\n");
    }
    
    FilePrint(TemplateHandle,
"Sub NextIndexButton_OnClick(ByRef Index, MaxIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    Index = Index + 1\r\n"
"    if Index = MaxIndex Then\r\n"
"      Index = 0\r\n"
"    End If\r\n"
"      Call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub PrevIndexButton_OnClick(ByRef Index, MaxIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    if Index = 0 Then\r\n"
"      Index = MaxIndex - 1\r\n"
"    Else\r\n"
"      Index = Index - 1\r\n"
"    End If\r\n"
"      Call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub GotoIndexButton_OnClick(ByRef Index, MaxIndex, NewIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    DestIndex = NewIndex + 0\r\n"
"    if DestIndex >= 0 And DestIndex < MaxIndex Then\r\n"
"      Index = DestIndex\r\n"
"      Call ReloadInstance\r\n"
"    Else\r\n"
"      MsgBox \"Enter an index between 0 and \" & MaxIndex-1, ,\"Index out of range\"\r\n"
"    End If\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n");

    EnumerateClassMethods(TemplateHandle,
                             MofResource,
                             ClassInfo,
                             GenerateMethodSubsText,
                             NULL);

    FilePrint(TemplateHandle,
"-->\r\n"
"</script></span>"
"<INPUT TYPE=\"TEXT\" SIZE=\"128\" NAME=\"InstanceNameText\" VALUE=\"\"></p>\r\n"
        );

    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"<SCRIPT FOR=\"mysink\" EVENT=\"OnObjectReady(Instance, objAsyncContext)\" LANGUAGE=\"VBScript\">\r\n"
                 );         
            
        FilePrint(TemplateHandle,
"        Set LastEventObject = Instance\r\n"
"        ReceivedEvent = TRUE\r\n"
"        Call ReloadInstance\r\n"
                 );
            
        FilePrint(TemplateHandle,
"</SCRIPT>\r\n"
            );
    } else {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=NextButton type=BUTTON value=Next>\r\n"
"\r\n"
"<input name=PrevButton type=BUTTON value=Previous>\r\n"
"\r\n"
"<input name=ChangeButton type=BUTTON value=Change>\r\n"
"\r\n"
"<input name=RefreshButton type=BUTTON value=Refresh>\r\n"
"\r\n"
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
                  );
    }

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateTextFormText,
                             TRUE,
                             NULL,
                             0);


    EnumerateClassMethods(TemplateHandle,
                          MofResource,
                          ClassInfo,
                          GenerateMethodButtonsText,
                          NULL);

    FilePrint(TemplateHandle,
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
"<p class=MsoNormal><a href=\"index.htm\"\r\n"
"title=\"Goes back to list of classes in this MOF\">Back to List</a></p>\r\n"
"\r\n"
"</form>\r\n"
"\r\n"
          );
    if (! IsEvent)
    {
        FilePrint(TemplateHandle,
"<p class=MsoNormal><span style='display:none;mso-hide:all'><script language=\"VBScript\">\r\n"
"<!--\r\n"
"  call ReloadInstance\r\n"
"-->\r\n"
"</script></span></p>\r\n"
"\r\n"
           );
   }

   FilePrint(TemplateHandle,
"</div>\r\n"
"\r\n"
            );
        
    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"<OBJECT ID=\"mysink\" CLASSID=\"CLSID:75718C9A-F029-11d1-A1AC-00C04FB6C223\"></OBJECT>\r\n"
                );
    }

    FilePrint(TemplateHandle,
"</body>\r\n"
"\r\n"
"</html>\r\n"
              );

    return(ERROR_SUCCESS);
}

ULONG GenerateWebFiles(
    PCHAR WebDir,
    PMOFRESOURCE MofResource
    )
{
    ULONG Status;
    HANDLE IndexHandle, TemplateHandle;
    CHAR PathName[MAX_PATH];
    PCHAR FileName;
    ULONG Len, Index;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PMOFCLASSINFOW ClassInfo;
    CBMOFObj *ClassObject;

    if (! CreateDirectory(WebDir, NULL))
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS)
        {
            return(Status);
        }
    }

    strcpy(PathName, WebDir);
    Len = strlen(PathName)-1;
    if (PathName[Len] != '\\')
    {
        PathName[++Len] = '\\';
        PathName[++Len] = 0;
    } else {
        Len++;
    }
    FileName = &PathName[Len];

    strcpy(FileName, "index.htm");
    IndexHandle = CreateFile(PathName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    if ((IndexHandle == NULL) || (IndexHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    FilePrint(IndexHandle,
              "<HTML>\r\n<HEAD><TITLE>Class List</TITLE></HEAD><BODY>\r\n");


    //
    // Loop over all mof classes
    Index = 0;
    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);

        ClassInfo = MofClass->MofClassInfo;
        ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;

        if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS))
        {
            //
            // don't create pages for embedded classes or events
            sprintf(FileName, "%ws.htm", ClassInfo->Name);
            TemplateHandle = CreateFile(PathName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
            {
                CloseHandle(IndexHandle);
                return(GetLastError());
            }

            FilePrint(IndexHandle,
                      "<H3><A href=\"%ws.htm\">%ws</A></H3><HR>",
                      ClassInfo->Name,
                      ClassInfo->Name);

            Status = GenerateClassWebPage(TemplateHandle,
                                          MofClass,
                                          MofResource);

            CloseHandle(TemplateHandle);
        }
        MofClassList = MofClassList->Flink;
    }

    FilePrint(IndexHandle, "</BODY>\r\n</HTML>\r\n");
    CloseHandle(IndexHandle);
    return(ERROR_SUCCESS);
}

ULONG AppendUnicodeTextFiles(
    char *DestFile,
    char *SrcFile1,
    char *SrcFile2                           
    )
{
    #define READ_BLOCK_SIZE 0x8000
    
    HANDLE DestHandle, SrcHandle;
    ULONG BytesRead, BytesWritten;
    PUCHAR Buffer, p;
    BOOL b;
    ULONG Status = ERROR_SUCCESS;
    BOOLEAN FirstTime;
    ULONG TotalBytesRead = 0;
    ULONG TotalBytesWritten = 0;
    ULONG ReadSize;
    CHAR c;

    //
    // This is a very simple procedure. We append the second file onto
    // the end of the first file, however we always skip the first 2
    // bytes of the second file if they are a 0xFEFF. This signature
    // denotes that the file is a unicode text file, but if it gets
    // appended in the middle of the file then mofcomp will get really
    // pissed off and barf.
    //
    Buffer = (PUCHAR)WmipAlloc(READ_BLOCK_SIZE);
    if (Buffer != NULL)
    {
        DestHandle = CreateFile(DestFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (DestHandle != INVALID_HANDLE_VALUE)
        {
            SrcHandle = CreateFile(SrcFile1,
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
            if (SrcHandle != INVALID_HANDLE_VALUE)
            {
                //
                // Just copy over all data from first file into
                // destination
                //
                do
                {
                    b = ReadFile(SrcHandle,
                                 Buffer,
                                 READ_BLOCK_SIZE,
                                 &BytesRead,
                                 NULL);
                    if (b)
                    {
                        TotalBytesRead += BytesRead;
                        WmipDebugPrint(("Read 0x%x/0x%x from Source 1\n",
                                        BytesRead, TotalBytesRead));
                        b = WriteFile(DestHandle,
                                      Buffer,
                                      BytesRead,
                                      &BytesWritten,
                                      NULL);
                        if (!b)
                        {                           
                            Status = GetLastError();
                            break;
                        } else if (BytesWritten != BytesRead) {
                            Status = ERROR_BAD_LENGTH;
                            break;
                        }
                        TotalBytesWritten += BytesWritten;
                        WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                    } else { 
                        Status = GetLastError();
                        break;
                    }
                } while (BytesRead == READ_BLOCK_SIZE);
                
                CloseHandle(SrcHandle);

                //
                // Now copy the data from the second file, but make
                // sure we skip any 0xFFFE at the beginning of the
                // second file
                //
                TotalBytesRead = 0;
                SrcHandle = CreateFile(SrcFile2,
                                       GENERIC_READ,
                                       0,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL);
                if (SrcHandle != INVALID_HANDLE_VALUE)
                {
                    FirstTime = TRUE;
                    do
                    {
                        b = ReadFile(SrcHandle,
                                 Buffer,
                                 READ_BLOCK_SIZE,
                                 &BytesRead,
                                 NULL);
                        
                        if (b)
                        {
                            ReadSize = READ_BLOCK_SIZE;
                            
                            TotalBytesRead += BytesRead;
                            WmipDebugPrint(("Read 0x%x/0x%x from Source 2\n",
                                        BytesRead, TotalBytesRead));
                            if (FirstTime)
                            {
                                FirstTime = FALSE;
                                if (BytesRead >= 2)
                                {
                                    if ( *((PWCHAR)Buffer) == 0xFEFF )
                                    {
                                        WmipDebugPrint(("First Time and need to skip 2 bytes\n"));
                                        p = Buffer + 2;
                                        BytesRead -= 2;
                                        ReadSize -= 2;
                                    }
                                }
                            } else {
                                p = Buffer;
                            }
                                
                            b = WriteFile(DestHandle,
                                      p,
                                      BytesRead,
                                      &BytesWritten,
                                      NULL);
                            if (!b)
                            {                           
                                Status = GetLastError();
                                break;
                            } else if (BytesWritten != BytesRead) {
                                Status = ERROR_BAD_LENGTH;
                                break;
                            }
                            TotalBytesWritten += BytesWritten;
                            WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                        } else { 
                            Status = GetLastError();
                            break;
                        }
                    } while (BytesRead == ReadSize);

                    if (Status == ERROR_SUCCESS)
                    {
                        //
                        // Copy put a ^Z at the end so well do that too
                        //
                        c = 0x1a;
                        b = WriteFile(DestHandle,
                                      &c,
                                      1,
                                      &BytesWritten,
                                      NULL);

                        if (!b)
                        {                           
                            Status = GetLastError();
                        } else if (BytesWritten != 1) {
                            Status = ERROR_BAD_LENGTH;
                        }
                        TotalBytesWritten += BytesWritten;
                        WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                    }
                    
                    CloseHandle(SrcHandle);
                }
                
            } else {
                Status = GetLastError();
            }
            CloseHandle(DestHandle);
        } else {
            Status = GetLastError();
        }
        WmipFree(Buffer);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status); 
}


void Usage(
    void
    )
{
    printf("WMI Mof Check Tool - Revision 25\n");
    printf("\n");
    printf("WmiMofCk validates that the classes, properties, methods and events specified \n");
    printf("in a binary mof file (.bmf) are valid for use with WMI. It also generates \n");
    printf("useful output files needed to build and test the WMI data provider.\n");
    printf("\n");
    printf("If the -h parameter is specified then a C language header file is created\n");
    printf("that defines the guids, data structures and method indicies specified in the\n");
    printf("MOF file.\n");
    printf("\n");
    printf("If the -t parameter is specified then a VBScript applet is created that will\n");
    printf("query all data blocks and properties specified in the MOF file. This can be\n");
    printf("useful for testing WMI data providers.\n");
    printf("\n");
    printf("If the -x parameter is specified then a text file is created that contains\n");
    printf("the text representation of the binary mof data. This can be included in \n");
    printf("the source of the driver if the driver supports reporting the binary mof \n");
    printf("via a WMI query rather than a resource on the driver image file.\n\n");
    printf("If the -c parameter is specified then a C language source file is\n");
    printf("generated that contains a template for implementing WMI code in\n");
    printf("a device driver\n\n");
    printf("if the -w parameter is specified then a set of HTML files are\n");
    printf("generated that create a rudimentary UI that can be used to access\n");
    printf("the wmi data blocks\n\n");
    printf("if the -m parameter is specified then structure definitions for\n");
    printf("method parameter lists are generated in the generated header file.\n\n");
    printf("if the -u parameter is specified then structure definitions for all\n");
    printf("data blocks are generated unconditionally\n\n");
    printf("\n");
    printf("Usage:\n");
    printf("    wmimofck -h<C Source Language Header output file>\n");
    printf("             -c<C Source Language Code output file>\n");
    printf("             -x<Hexdump output file>\n");
    printf("             -t<Command line VBScript test output file>\n");
    printf("             -w<HTML UI output file directory>\n");
    printf("             -y<MofFile> -z<MflFile>\n");
    printf("             -m\n");
    printf("             -u\n");
    printf("             <binary mof input file>\n\n");
}

#define IsWhiteSpace(c) ( (c == ' ') || (c == '\t') )
ULONG GetParameter(
    char *Parameter,
    ULONG ParameterSize,
    char *CommandLine
    )
{
    ULONG i;

    i = 0;
    ParameterSize--;

    while ( (! IsWhiteSpace(*CommandLine)) &&
            ( *CommandLine != 0) &&
            (i < ParameterSize) )
    {
        *Parameter++ = *CommandLine++;
        i++;
    }
    *Parameter = 0;
    return(i);
}

int _cdecl main(int argc, char *argv[])
{
    char BMofFile[MAX_PATH];
    char *Parameter;
    int i;
    ULONG Status;
    char ASLFile[MAX_PATH];
    char CFile[MAX_PATH];
    char HFile[MAX_PATH];
    char XFile[MAX_PATH];
    char TFile[MAX_PATH];
    char WebDir[MAX_PATH];
    char MofFile[MAX_PATH];
    char MflFile[MAX_PATH];
    char c;
    PMOFRESOURCE MofResource;

    *ASLFile = 0;
    *CFile = 0;
    *HFile = 0;
    *XFile = 0;
    *TFile = 0;
    *WebDir = 0;
    *MofFile = 0;
    *MflFile = 0;
    *BMofFile = 0;

    printf("Microsoft (R) WDM Extensions To WMI MOF Checking Utility  Version 1.50.0000\n");
    printf("Copyright (c) Microsoft Corp. 1997-2000. All rights reserved.\n\n");

    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);   // BUGBUG: Remove when MOF format maintains alignment correctly

    if (argc == 1)
    {
        Usage();
        return(1);
    }

    i = 1;
    while (i < argc)
    {
        Parameter = argv[i++];
        if (IsWhiteSpace(*Parameter))
        {
            Parameter++;
            continue;
        }

        if (*Parameter != '-')
        {
            //
            // Parameter does not start with -, must be bmof filename
            if (*BMofFile != 0)
            {
                //
                // Only one filename allowed
                Usage();
            }
            GetParameter(BMofFile, sizeof(BMofFile), Parameter);
        } else {
            Parameter++;
            // Check for - parameters here
            c = (CHAR)toupper(*Parameter);
            Parameter++;
            switch (c)
            {
                case 'A' :
                {
                    GetParameter(ASLFile, sizeof(ASLFile), Parameter);
                    break;
                }

                case 'C':
                {
                    GetParameter(CFile, sizeof(CFile), Parameter);
                    break;
                }

                case 'H':
                {
                    GetParameter(HFile, sizeof(HFile), Parameter);
                    break;
                }

                case 'U':
                {
                    ForceHeaderGeneration = TRUE;
                }

                case 'M':
                {
                    DoMethodHeaderGeneration = TRUE;
                    break;
                }

                case 'X':
                {
                    GetParameter(XFile, sizeof(XFile), Parameter);
                    break;
                }

                case 'T':
                {
                    GetParameter(TFile, sizeof(TFile), Parameter);
                    break;
                }

                case 'W':
                {
                    GetParameter(WebDir, sizeof(WebDir), Parameter);
                    break;
                }

                case 'Y':
                {
                    GetParameter(MofFile, sizeof(MofFile), Parameter);
                    break;
                }

                case 'Z':
                {
                    GetParameter(MflFile, sizeof(MflFile), Parameter);
                    break;
                }

                default: {
                    Usage();
                    return(1);
                }
            }

        }
    }

    if (*BMofFile == 0)
    {
        //
        // We must have a filename
        Usage();
        return(1);
    }

    if (*MofFile != 0)
    {
        if (*MflFile != 0)
        {
            Status = AppendUnicodeTextFiles(BMofFile, MofFile, MflFile);
        } else {
            Usage();
            return(1);
        }
        return(Status);
    }

    
    Status = ParseBinaryMofFile(BMofFile, &MofResource);

    if (Status == ERROR_SUCCESS)
    {
        if (*HFile != 0)
        {
            //
            // Generate C Header file
            Status = GenerateHTemplate(HFile, MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Header Template file \n", Status);
            }
        }

        if (*XFile != 0)
        {
            //
            // Generate X Header file
            Status = GenerateXTemplate(XFile);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating X Header Template file \n", Status);
            }
        }

        if (*TFile != 0)
        {
            //
            // Generate C output template
            Status = GenerateTTemplate(TFile, MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Template file \n", Status);
            }
        }

        if (*CFile != 0)
        {
            //
            // Generate C output template
            Status = GenerateCTemplate(CFile,
                                       HFile,
                                       *XFile == 0 ? CFile : XFile,
                                       MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Template file \n", Status);
            }
        }

        if (*WebDir != 0)
        {
            //
            // Generate HTML UI for classes
            //
            Status = GenerateWebFiles(WebDir,
                                      MofResource);
        }

        if (*ASLFile != 0)
        {
            //
            // Generate ASL output template
            Status = GenerateASLTemplate(ASLFile);
        }
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\request.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    request.h

Abstract:

	This file contains structures and functions definitions used in Ntdll.dll
	and advapi32.dll.


--*/

HANDLE EtwpKMHandle;

extern
HANDLE EtwpWin32Event;

__inline HANDLE EtwpAllocEvent(
    void
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer((PVOID *)(&EtwpWin32Event),
                                                     NULL);
    if (EventHandle == NULL)
    {
        //
        // If event in queue is in use then create a new one
#if defined (_NTDLLBUILD_)
        EventHandle = EtwpCreateEventW(NULL, FALSE, FALSE, NULL);
#else
        EventHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
#endif
    }
    return(EventHandle);
}

__inline void EtwpFreeEvent(
    HANDLE EventHandle
    )
{
    if (InterlockedCompareExchangePointer(&EtwpWin32Event,
                                          EventHandle,
                                          NULL) != NULL)
    {
        //
        // If there is already a handle in the event queue then free this
        // handle
#if defined (_NTDLLBUILD_)
        EtwpCloseHandle(EventHandle);
#else
        CloseHandle(EventHandle);
#endif

    }
}


ULONG IoctlActionCode[WmiExecuteMethodCall+1] =
{
    IOCTL_WMI_QUERY_ALL_DATA,
    IOCTL_WMI_QUERY_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_ITEM,
    IOCTL_WMI_ENABLE_EVENT,
    IOCTL_WMI_DISABLE_EVENT,
    IOCTL_WMI_ENABLE_COLLECTION,
    IOCTL_WMI_DISABLE_COLLECTION,
    IOCTL_WMI_GET_REGINFO,
    IOCTL_WMI_EXECUTE_METHOD
};

ULONG EtwpSendWmiKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    OutBuffer is the output buffer for the call to the WMI device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer
    Overlapped is an option OVERLAPPED struct that is used to make the 
        call async

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED StaticOverlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    EtwpEnterPMCritSection();

#if defined (_NTDLLBUILD_)
    if (EtwpKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        EtwpKMHandle = EtwpCreateFileW(WMIDataDeviceName_W,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (EtwpKMHandle == INVALID_HANDLE_VALUE)
        {
            EtwpKMHandle = NULL;
            EtwpLeavePMCritSection();
            return(EtwpGetLastError());
        }
    }
    EtwpLeavePMCritSection();

    if (Overlapped == NULL)
    {
        //
        // if caller didn't pass an overlapped structure then supply
        // our own and make the call synchronous
        //
        Overlapped = &StaticOverlapped;
    
        Overlapped->hEvent = EtwpAllocEvent();
        if (Overlapped->hEvent == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (DeviceHandle == NULL)
    {
        DeviceHandle = EtwpKMHandle;
    }

    do
    {
        IoctlSuccess = EtwpDeviceIoControl(DeviceHandle,
                              Ioctl,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              Overlapped);

        if (!IoctlSuccess)
        {
            if (Overlapped == &StaticOverlapped)
            {
                //
                // if the call was successful and we are synchronous then
                // block until the call completes
                //
                if (EtwpGetLastError() == ERROR_IO_PENDING)
                {
                    IoctlSuccess = EtwpGetOverlappedResult(DeviceHandle,
                                               Overlapped,
                                               ReturnSize,
                                               TRUE);
                }
    
                if (! IoctlSuccess)
                {
                    Status = EtwpGetLastError();
                } else {
                    Status = ERROR_SUCCESS;
                }
            } else {
                Status = EtwpGetLastError();
            }
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    if (Overlapped == &StaticOverlapped)
    {
        EtwpFreeEvent(Overlapped->hEvent);
    }

#else // _NTDLLBUILD_

    if (EtwpKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        EtwpKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (EtwpKMHandle == INVALID_HANDLE_VALUE)
        {
            EtwpKMHandle = NULL;
            EtwpLeavePMCritSection();
            return(GetLastError());
        }
    }
    EtwpLeavePMCritSection();

    if (Overlapped == NULL)
    {
        //
        // if caller didn't pass an overlapped structure then supply
        // our own and make the call synchronous
        //
        Overlapped = &StaticOverlapped;
    
        Overlapped->hEvent = EtwpAllocEvent();
        if (Overlapped->hEvent == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (DeviceHandle == NULL)
    {
        DeviceHandle = EtwpKMHandle;
    }

    do
    {
        IoctlSuccess = DeviceIoControl(DeviceHandle,
                              Ioctl,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              Overlapped);

        if (!IoctlSuccess)
        {
            if (Overlapped == &StaticOverlapped)
            {
                //
                // if the call was successful and we are synchronous then
                // block until the call completes
                //
                if (GetLastError() == ERROR_IO_PENDING)
                {
                    IoctlSuccess = GetOverlappedResult(DeviceHandle,
                                               Overlapped,
                                               ReturnSize,
                                               TRUE);
                }
    
                if (! IoctlSuccess)
                {
                    Status = GetLastError();
                } else {
                    Status = ERROR_SUCCESS;
                }
            } else {
                Status = GetLastError();
            }
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    if (Overlapped == &StaticOverlapped)
    {
        EtwpFreeEvent(Overlapped->hEvent);
    }
#endif
    
    return(Status);
}

ULONG EtwpSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxWnodeSize,
    ULONG *RetSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the appropriate
    data provider. Note that this routine is called while the GuidHandle's
    critical section is held.

Arguments:


Return Value:

---*/
{
    ULONG Status = ERROR_SUCCESS;
    ULONG Ioctl;
    ULONG BusyRetries;

    //
    // Send the query down to kernel mode for execution
    //
    EtwpAssert(ActionCode <= WmiExecuteMethodCall);
    Ioctl = IoctlActionCode[ActionCode];
    Status = EtwpSendWmiKMRequest(NULL,
                                      Ioctl,
                                      Wnode,
                                      WnodeSize,
                                      OutBuffer,
                                      MaxWnodeSize,
                                      RetSize,
                                      NULL);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\traceump.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    traceump.h

Abstract:

    Private headers for Event Tracing user mode

Author:

    19-Jul-2000   Melur Raghuraman

Revision History:

--*/ 

#ifndef MEMPHIS


#define MAXSTR                         1024
#define BUFFER_SIZE                    64*1024
#define MAX_BUFFER_SIZE                10*1024*1024
#define NOTIFY_RETRY_COUNT             10

#define SYSTEM_TRACE_VERSION1           1

#ifdef _WIN64
#define SYSTEM_TRACE_MARKER1    TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_SYSTEM64 << 16) | SYSTEM_TRACE_VERSION1
#else
#define SYSTEM_TRACE_MARKER1    TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                            | (TRACE_HEADER_TYPE_SYSTEM32 << 16) | SYSTEM_TRACE_VERSION1
#endif

#define LOGFILE_FIELD_OFFSET(field) \
        sizeof(WMI_BUFFER_HEADER) + \
        sizeof(SYSTEM_TRACE_HEADER) +\
        FIELD_OFFSET(TRACE_LOGFILE_HEADER, field)

typedef struct _WMI_LOGGER_CONTEXT {
    LARGE_INTEGER               StartTime;
    HANDLE                      LogFileHandle;
    HANDLE                      NewFileHandle;
    ULONG                       LoggerId;
    ULONG                       LocalSequence;
    HANDLE                      Semaphore;
    HANDLE                      LoggerThreadId;
    HANDLE                      hThread;
    HANDLE                      LoggerEvent;
    NTSTATUS                    LoggerStatus;

    ULONG                       BuffersAvailable;
    ULONG                       NumberOfProcessors;
    ULONG                       BufferPageSize; // BufferSize rounded to page
    LIST_ENTRY                  FreeList;
    LIST_ENTRY                  FlushList;
    PLIST_ENTRY                 TransitionBuffer;
    PWMI_BUFFER_HEADER*         ProcessorBuffers;   // Per Processor Buffer
    UNICODE_STRING              LoggerName;
    UNICODE_STRING              LogFileName;

    ULONG                       CollectionOn;
    ULONG                       NewFileFlag;
    ULONG                       EnableFlags;
    ULONG                       MaximumFileSize;
    ULONG                       LogFileMode;
    ULONG                       LastFlushedBuffer;
    LARGE_INTEGER               FlushTimer;
    LARGE_INTEGER               FirstBufferOffset;
    LARGE_INTEGER               ByteOffset;
    LARGE_INTEGER               BufferAgeLimit;

    ULONG                       TimerResolution; // Used for backtracking in Rundown code
    ULONG                       UsePerfClock;    // Logger Specific PerfClock flags

// the following are attributes available for query
    ULONG                       BufferSize;
    ULONG                       NumberOfBuffers;
    ULONG                       MaximumBuffers;
    ULONG                       MinimumBuffers;
    ULONG                       EventsLost;
    ULONG                       BuffersWritten;
    ULONG                       LogBuffersLost;
    ULONG                       RealTimeBuffersLost;

    PULONG                      SequencePtr;
    GUID                        InstanceGuid;

// logger specific extension to context
    PVOID                       BufferSpace;    // Reserved Buffer Space
} WMI_LOGGER_CONTEXT, *PWMI_LOGGER_CONTEXT;


//
// logsup.c
//

PVOID
EtwpGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    );

//
// tracehw.c
//

ULONG
WmipDumpHardwareConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipDumpGuidMaps(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONG StartFlag
    );

ULONG
WmipAddGuidHandleToGuidMapList(
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONGLONG   GuidHandle,
    IN LPGUID      Guid
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\dcapi.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dcapi.c

Abstract:

    WMI data consumer api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

#ifndef MEMPHIS
#include <aclapi.h>
#endif

ULONG
WMIAPI
EtwNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
/*+++

Routine Description:

    ANSI thunk to NotificationRegistration

Return Value:

    Returns ERROR_SUCCESS or an error code

---*/
{
    return(EtwpNotificationRegistration(Guid,
                                        Enable,
                                        DeliveryInfo,
                                        DeliveryContext,
                                        0,
                                        Flags,
                                        TRUE));

}

ULONG
WMIAPI
EtwNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
/*+++

Routine Description:

    This routine allows a data consumer to register or unregister for
    notification of events fired by WMI data providers. Notifications are
    delivered via callbackor via a posted meesage to a window.

Arguments:

    Guid is pointer to the guid whose events are being registered for

    Enable is TRUE if enabling notifications else FALSE. If FALSE the
        Destination and DestinationInformation parameters are ignored.

    DeliveryInfo has the callback function pointer or window handle to which
        to deliver the notifications for the guid.

    DeliveryContext has a context value or additional information to use
        when delivering the notification.

    Flags are a set of flags that define how the notification is delivered.
        DeliveryInfo and DeliveryContext have different meanings depending
        upon the value in Flags:

        NOTIFICATION_WINDOW_HANDLE is set when notifications for the guid
            are to be delivered by posting a message to the window handle
            passed in DeliveryInfo. The message posted is the value that
            is returned from the call to
            RegisterWindowMessage(WMINOTIFICATIONWINDOWMESSAGE) with the
            wParam set to the pointer to the Wnode containing the notification
            and lParam set to the context value passed in DeliveryContext.
            The caller MUST free the Wnode passed in wParam by calling
            WMIFreeBuffer.

        NOTIFICATION_CALLBACK_DIRECT is set when notifications for the
            guid are to be delivered by direct callback. Whenever a
            notification arrives WMI creates a new thread dedicated to
            calling the callback function with the notification. This
            mechanism provides the shortest latency from notification firing
            to notification delivery, although it is the most expensive
            mechanism. The callback function pointer is passed in DeliveryInfo
            and must conform to the prototype described by the type
            NOTIFICATIONCALLBACK. The context value passed in the callback
            is specified by the DeliveryContext parameter. WMI does not
            serialize calling the callback function so it must be reentrant.

        NOTIFICATION_CALLBACK_QUEUED is set when notifications for the
            guid are to be delivered by a queued callback. Whenever a
            notification arrives WMI places it at the end of an internal
            queue. A single thread monitors this queue and calls the callback
            function serially for each notification in the queue. This
            mechanism provides low overhead for event delivery, however
            notification delivery can be delayed if the callback function
            for an earlier notification does not complete quickly.
            The callback function pointer is passed in DeliveryInfo
            and must conform to the prototype described by the type
            NOTIFICATIONCALLBACK. The context value passed in the callback
            is specified by the DeliveryContext parameter. WMI does
            serialize calling the callback function so it need not be
            reentrant provided it is not also used for
            NOTIFICATION_CALLBACK_DIRECT notififications. NOTE THAT THIS
            IS NOT YET IMPLEMENTED.

        NOTIFICATION_TRACE_FLAG is set when the caller wishes to enable
            trace logging in the data provider for the guid. DeliveryInfo
            specifies the trace logger handle to be passed to the data
            provider. DeliveryContext is not used. No notifications are
            generated to the caller when this flag is set.


        Note that all of the above flags are mutually exclusive.

Return Value:

    Returns ERROR_SUCCESS or an error code

---*/
{
    return(EtwpNotificationRegistration(Guid,
                                        Enable,
                                        DeliveryInfo,
                                        DeliveryContext,
                                        0,
                                        Flags,
                                        FALSE));

}

ULONG
WMIAPI
EtwReceiveNotificationsW(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
)
{
    return(EtwpReceiveNotifications(HandleCount,
                                    HandleList,
                                    Callback,
                                    DeliveryContext,
                                    FALSE,
                                    RECEIVE_ACTION_NONE,
                                    NULL,
                                    NULL));
}

ULONG
WMIAPI
EtwReceiveNotificationsA(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
)
{
    return(EtwpReceiveNotifications(HandleCount,
                                    HandleList,
                                    Callback,
                                    DeliveryContext,
                                    TRUE,
                                    RECEIVE_ACTION_NONE,
                                    NULL,
                                    NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\inc\wmiump.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiump.h

Abstract:

    Private headers for WMI user mode

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define _WMI_SOURCE_

//
// Define this to track reference counts
//#define TRACK_REFERNECES

//
// Define this to get extra checks on heap validation
//#define HEAPVALIDATION

//
// Define this to get a trace of critical section
//#define CRITSECTTRACE

//
// Define this to compile WMI to run as a service under NT
#define RUN_AS_SERVICE

//
// Define this to include WMI user mode functionality. Note that if you enable
// this then you also need to fix the files: wmi\dll\sources and wmi\makefil0.
//#define WMI_USER_MODE

//
// Define this to track memory leaks
//#define TRACK_MEMORY_LEAKS

#ifndef MEMPHIS
#define UNICODE
#define _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>

#ifndef MEMPHIS
#include "svcs.h"
#endif

#include <netevent.h>

#ifdef MEMPHIS
//
// CONSIDER: Is there a better place to get this stuff on MEMPHIS
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

typedef LONG NTSTATUS;
typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );


#include <stdio.h>
#endif

#include "wmium.h"
#include "wmiumkm.h"
#include "ntwmi.h"
#include "wmiguid.h"

#if DBG
#if defined(_NTDLLBUILD_)
#define EtwpAssert(x) if (! (x) ) { \
    BOOLEAN OldLoggingEnabled = EtwpLoggingEnabled; \
    EtwpLoggingEnabled = TRUE; \
    EtwpDbgPrint(("WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    EtwpLoggingEnabled = OldLoggingEnabled; \
    DbgBreakPoint(); }
#else
#define EtwpAssert(x) if (! (x) ) { \
    BOOLEAN OldLoggingEnabled = EtwpLoggingEnabled; \
    EtwpLoggingEnabled = TRUE; \
    EtwpDbgPrint(("WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    EtwpLoggingEnabled = OldLoggingEnabled; \
    DebugBreak(); }
#endif
#else
#define EtwpAssert(x)
#endif

#if DBG
extern BOOLEAN EtwpLoggingEnabled;
#ifdef MEMPHIS
void __cdecl DebugOut(char *Format, ...);
#define EtwpDebugPrint(_x_) { if (EtwpLoggingEnabled) DebugOut _x_; }
#define EtwpDbgPrint(_x_) { if (EtwpLoggingEnabled) DebugOut _x_; }
#else
#define EtwpDebugPrint(_x_) { if (EtwpLoggingEnabled) DbgPrint _x_; }
#define EtwpDbgPrint(_x_) { if (EtwpLoggingEnabled) DbgPrint _x_; }
#endif
#else
#define EtwpDebugPrint(_x_)
#define EtwpDbgPrint(_x_)
#endif

#define NULL_GUID  {0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

//
// Registry based config options. Only available on checked builds
//
#define WmiRegKeyText TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Control\\WMI")
#define PumpTimeoutRegValueText TEXT("NotificationPumpTimeout")
#define LoggingEnableValueText TEXT("LoggingEnabled")

#define DEFAULT_ALLOC_SIZE     4096




//
// WMI RPC related definitions
typedef struct
{
    WNODE_HEADER WnodeHeader;
    BYTE Data[1];
} WNODE_INTERNAL, *PWNODE_INTERNAL;

#define INTERNAL_PROVIDER_ID 1

//
// Size of initial buffer used to read notifications from kernel mode
#define STARTNOTIFICATIONBUFFERSIZE 4096

#ifdef MEMPHIS
#define WmiRpcProtocolSequence TEXT("ncalrpc")

#define WmiServiceRpcProtocolSequence TEXT("ncalrpc")
#define WmiServiceRpcEndpoint TEXT("WmiRpcEndpoint")
#else
//#define WmiRpcProtocolSequence TEXT("ncalrpc")
//#define WmiRpcEndpointPrefix TEXT("NT")

#define WmiRpcProtocolSequence TEXT("ncacn_np")
#define WmiRpcEndpointPrefix TEXT("\\pipe\\")

#define WmiServiceRpcProtocolSequence TEXT("ncacn_np")
#define WmiServiceRpcEndpoint SVCS_RPC_PIPE
#endif

#define MinRpcCalls 1
#define MaxRpcCalls RPC_C_PROTSEQ_MAX_REQS_DEFAULT

//
// Time to wait between retrying an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_TIMER   500

//
// Number of times to retry an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_RETRIES 5

//
// WMI RPC interface principle name
#define WMI_RPC_PRINC_NAME TEXT("WMI_RPC_PRINC_NAME")

//
// This macro will break CountedString into a pointer to the actual string
// and the actual length of the string excluding any trailing nul characters
#define EtwpBreakCountedString(CountedString, CountedStringLen) { \
    CountedStringLen = *CountedString++; \
    if (CountedString[(CountedStringLen-sizeof(WCHAR))/sizeof(WCHAR)] == UNICODE_NULL) \
    { \
        CountedStringLen -= sizeof(WCHAR); \
    } \
}


typedef struct
{
    HANDLE GuidHandle;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG Flags;
} NOTIFYEE, *PNOTIFYEE;

#define STATIC_NOTIFYEE_COUNT 2

typedef struct
{
    LIST_ENTRY GNList;
    GUID Guid;
    ULONG RefCount; 
    ULONG NotifyeeCount;
    PNOTIFYEE Notifyee;
    NOTIFYEE StaticNotifyee[STATIC_NOTIFYEE_COUNT];
    BOOLEAN bInProgress; 
} GUIDNOTIFICATION, *PGUIDNOTIFICATION;

#define EtwpAllocGNEntry() (PGUIDNOTIFICATION)EtwpAlloc(sizeof(GUIDNOTIFICATION))
#define EtwpFreeGNEntry(GNEntry) EtwpFree(GNEntry)
#define EtwpReferenceGNEntry(GNEntry) InterlockedIncrement(&GNEntry->RefCount);


//
// Notification Cookie data structures
//#if DBG
//#define NOTIFYCOOKIESPERCHUNK 2
//#else
//#define NOTIFYCOOKIESPERCHUNK 128
//#endif
/*
typedef struct
{
    PVOID DeliveryContext;
    PVOID DeliveryInfo;
    GUID Guid;
    BOOLEAN InUse;
} NOTIFYCOOKIE, *PNOTIFYCOOKIE;

typedef struct
{
    LIST_ENTRY Next;                         // Next cookie chunk
    ULONG BaseSlot;                          // Index of first slot number
    USHORT FreeSlot;                         // Index to a free cookie
    BOOLEAN Full;                            // TRUE if this chunk is full
    NOTIFYCOOKIE Cookies[NOTIFYCOOKIESPERCHUNK];
} NOTIFYCOOKIECHUNK, *PNOTIFYCOOKIECHUNK;
*/

//
// Useful macro to establish a WNODE_HEADER quickly
#ifdef _WIN64

#define EtwpBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    (Wnode)->KernelHandle = Handle;                \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#else

#define EtwpBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    *((PULONG64)(&((Wnode)->TimeStamp))) = (ULONG64)(IntToPtr(PtrToInt(Handle))); \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#endif

#ifdef MEMPHIS
extern HANDLE PMMutex;
#define EtwpEnterPMCritSection() WaitForSingleObject(PMMutex, INFINITE)

#define EtwpLeavePMCritSection() ReleaseMutex(PMMutex)

#else
extern RTL_CRITICAL_SECTION PMCritSect;
extern HANDLE EtwpCBInProgressEvent;
#if DBG
#define EtwpEnterPMCritSection() \
                EtwpAssert(NT_SUCCESS(RtlEnterCriticalSection(&PMCritSect)));

#define EtwpLeavePMCritSection() { \
     EtwpAssert(PMCritSect.LockCount >= 0); \
     EtwpAssert(NT_SUCCESS(RtlLeaveCriticalSection(&PMCritSect))); }

//
// Assumptions about EtwpLockCB and EtwpUnlockCB:
// 1. Called only by the Pump Thread 
// 2. There can be only one callback in progress at any time with the 
//    Global event EtwpCBInProgressEvent unset and the corresponding GNEntry
//    marked as InProgress. 
// 3. Once the callback completes (successfully or not), the event is set 
//    and the GNEntry unlocked. 
// 4. Unregistering threads remove the GNEntry first and then check to see
//    whether to block for the PumpThread based on InProgressFlag. 
// 5. No callbacks are permitted if the GNEntry is not found in the GNList. 
// 


#define EtwpLockCB(GNEntry) { \
    EtwpDebugPrint(("WMI: Locking GNEntry 0x%x %s %d\n", GNEntry, __FILE__, __LINE__)); \
    EtwpAssert( GNEntry->bInProgress == FALSE); \
    GNEntry->bInProgress = TRUE; \
    NtClearEvent (EtwpCBInProgressEvent); }

#define EtwpUnlockCB(GNEntry) { \
    EtwpDebugPrint(("WMI: Unlocking GNEntry 0x%x %s %d\n", GNEntry, __FILE__, __LINE__)); \
    EtwpAssert( GNEntry->bInProgress == TRUE); \
    NtSetEvent(EtwpCBInProgressEvent, NULL); \
    GNEntry->bInProgress = FALSE;}

#else
#define EtwpEnterPMCritSection() RtlEnterCriticalSection(&PMCritSect)
#define EtwpLeavePMCritSection() RtlLeaveCriticalSection(&PMCritSect)

#define EtwpLockCB(GNEntry) {\
    GNEntry->bInProgress = TRUE; \
    NtClearEvent (EtwpCBInProgressEvent);}
#define EtwpUnlockCB(GNEntry) { \
    NtSetEvent(EtwpCBInProgressEvent, NULL); \
    GNEntry->bInProgress = FALSE; }

#endif // DBG

#endif // MEMPHIS


typedef struct
{
    NOTIFICATIONCALLBACK Callback;
    ULONG_PTR Context;
    PWNODE_HEADER Wnode;
    BYTE WnodeBuffer[1];
} NOTIFDELIVERYCTX, *PNOTIFDELIVERYCTX;


// from handle.c

#define EtwpVerifyToken() \
{ \
    ULONG VerifyStatus; \
    VerifyStatus = EtwpCheckImpersonationTokenType(); \
    if (VerifyStatus != ERROR_SUCCESS) \
    { \
        SetLastError(VerifyStatus); \
        return(VerifyStatus); \
    } \
}

ULONG EtwpCheckImpersonationTokenType(
    void
    );

ULONG EtwpCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi
    );

ULONG EtwpCountedAnsiToCountedUnicode(
    PCHAR Ansi,
    PWCHAR Unicode
    );

ULONG EtwpCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    );

#ifndef MEMPHIS
ULONG EtwpCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    );

ULONG EtwpOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    );
#endif
/*
ULONG EtwpAllocateCookie(
    PVOID DeliveryInfo,
    PVOID DeliveryContext,
    LPGUID Guid
    );

BOOLEAN EtwpLookupCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PVOID *DeliveryInfo,
    PVOID *DeliveryContext
    );

void EtwpGetGuidInCookie(
    ULONG CookieSlot,
    LPGUID Guid
    );

void EtwpFreeCookie(
    ULONG CookieSlot
    );
*/

PGUIDNOTIFICATION
EtwpFindAndLockGuidNotification(
    LPGUID Guid,
    BOOLEAN bLock
    );

ULONG
EtwpAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    );

ULONG
EtwpRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo
    );

BOOLEAN
EtwpDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    );

//PTCHAR GuidToString(
//    PTCHAR s,
//    LPGUID piid
//    );

PCHAR GuidToStringA(
    PCHAR s,
    ULONG szBuf,
    LPGUID piid
    );


// from request.c
ULONG EtwpSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *RetSize
    );

ULONG EtwpSendWmiKMRequest(
    HANDLE Handle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    );

ULONG EtwpSendRegisterKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    );

ULONG EtwpConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    );

ULONG EtwpConvertWADToUnicode(
    PWNODE_ALL_DATA WnodeAllData,
    ULONG *BufferSize
    );

ULONG EtwpRegisterGuids(
    IN LPGUID MasterGuid,
    IN LPGUID ControlGuid, 
    IN LPCWSTR MofImagePath,
    IN LPCWSTR MofResourceName,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
    );

//
// from intrnldp.c
ULONG EtwpInternalProvider(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   );

ULONG
EtwpEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    );

//
// from dcapi.c
ULONG
EtwpNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    );


//
// from mofapi.c
//
void EtwpProcessLanguageAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );

void EtwpProcessMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


//
// from notify.c
extern ULONG EtwpNotificationSinkIndex;
#ifndef MEMPHIS

ULONG EtwpProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    );

#endif

ULONG EtwpAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    );

void EtwpMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


ULONG
EtwpReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    );

ULONG EtwpEventPump(
    PVOID Param
    );

void
EtwpEnableDisableGuid(
    PWNODE_HEADER Wnode,
    ULONG RequestCode,
    BOOLEAN bDelayEnable
    );

//
// from main.c
VOID
EtwpCreateHeap(
    VOID
    );

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// These define the dll and mof resource name for all of the builtin mof
// resources
#define WMICOREDLLNAME L"wmicore.dll"
#define WMICOREMOFRESOURCENAME L"MofResource"


//
// This defines the registry key under which security descriptors associated
// with the guids are stored.
#ifndef MEMPHIS
#define WMISECURITYREGISTRYKEY TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#endif


//
// This defines the initial value of the buffer passed to each data provider
// to retrieve the registration information
#if DBG
#define INITIALREGINFOSIZE sizeof(WNODE_TOO_SMALL)
#else
#define INITIALREGINFOSIZE 8192
#endif


//
// Chunk Management definitions
// All structures that rely upon the chunk allocator must be defined so that
// their members match that of ENTRYHEADER. These include DATASOURCE,
// GUIDENTRY, INSTANCESET, DCENTRY, NOTIFICATIONENTRY, MOFCLASS, MOFRESOURCE
// Also ENTRYHEADER reserves 0x80000000 for its own flag.

struct _CHUNKINFO;
struct _ENTRYHEADER;

typedef void (*ENTRYCLEANUP)(
    struct _CHUNKINFO *,
    struct _ENTRYHEADER *
    );

typedef struct _CHUNKINFO
{
    LIST_ENTRY ChunkHead;        // Head of list of chunks
    ULONG EntrySize;            // Size of a single entry
    ULONG EntriesPerChunk;        // Number of entries per chunk allocation
    ENTRYCLEANUP EntryCleanup;   // Entry cleanup routine
    ULONG InitialFlags;         // Initial flags for all entries
    ULONG Signature;
#if DBG
    ULONG AllocCount;
    ULONG FreeCount;
#endif
} CHUNKINFO, *PCHUNKINFO;

typedef struct
{
    LIST_ENTRY ChunkList;        // Node in list of chunks
    LIST_ENTRY FreeEntryHead;    // Head of list of free entries in chunk
    ULONG EntriesInUse;            // Count of entries being used
} CHUNKHEADER, *PCHUNKHEADER;

typedef struct _ENTRYHEADER
{
    union
    {
        LIST_ENTRY FreeEntryList;    // Node in list of free entries
        LIST_ENTRY InUseEntryList;   // Node in list ofin use entries
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;                // Flags
    ULONG RefCount;                 // Reference Count
    ULONG Signature;
} ENTRYHEADER, *PENTRYHEADER;

                                // Set if the entry is free
#define FLAG_ENTRY_ON_FREE_LIST       0x80000000
#define FLAG_ENTRY_ON_INUSE_LIST      0x40000000
#define FLAG_ENTRY_INVALID            0x20000000
#define FLAG_ENTRY_REMOVE_LIST        0x10000000


#define EtwpReferenceEntry(Entry) \
    InterlockedIncrement(&((PENTRYHEADER)(Entry))->RefCount)

// chunk.c
#ifndef MEMPHIS
ULONG EtwpBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    );
#endif

ULONG EtwpUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry);

PENTRYHEADER EtwpAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void EtwpFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

//
// This is the guid that denotes non event notifications. WMICore
// automatically registers anyone opening a guid to
extern GUID RegChangeNotificationGuid;

extern CHUNKINFO DSChunkInfo;
extern CHUNKINFO GEChunkInfo;
extern CHUNKINFO ISChunkInfo;
extern CHUNKINFO DCChunkInfo;
extern CHUNKINFO NEChunkInfo;
extern CHUNKINFO MRChunkInfo;

struct tagGUIDENTRY;
typedef struct tagGUIDENTRY GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

struct tagDATASOURCE;


//
// An INSTANCESET contains the information a set of instances that is provided
// by a single data source. An instance set is part of two lists. One list is
// the set of instance sets for a particular guid. The other list is the list
// of instance sets supported by a data source.
//

//
// Instance names for an instance set registered with a base name and count
// are stored in a ISBASENAME structure. This structure is tracked by
// PDFISBASENAME in wmicore.idl.
typedef struct
{
    ULONG BaseIndex;            // First index to append to base name
    WCHAR BaseName[1];            // Actual base name
} ISBASENAME, *PISBASENAME, *PBISBASENAME;

//
// This defines the maximum number of characters that can be part of a suffix
// to a basename. The current value of 6 will allow up to 999999 instances
// of a guid with a static base name
#define MAXBASENAMESUFFIXSIZE    6

//
// Instance names for an instance set registerd with a set of static names
// are kept in a ISSTATICNAMES structure. This structure is tracked by
// PDFISSTATICNAMES defined in wmicore.idl
typedef struct
{
    PWCHAR StaticNamePtr[1];     // pointers to static names
//    WCHAR StaticNames[1];
} ISSTATICENAMES, *PISSTATICNAMES, *PBISSTATICNAMES;

typedef struct tagInstanceSet
{
    union
    {
        // Entry in list of instances within a guid
        LIST_ENTRY GuidISList;

        // Entry in main list of free instances
        LIST_ENTRY FreeISList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Reference count of number of guids using this instance set
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Entry in list of instances within a data source
    LIST_ENTRY DSISList;

    // Back link to guid that this instance set is a member
    PBGUIDENTRY GuidEntry;

    // Back link to data source that this instance set is a member
    struct tagDATASOURCE *DataSource;

    // Count of instances in instance set
    ULONG Count;

    //
    // If IS_INSTANCE_BASENAME is set then IsBaseName pointe at instance base
    // name structure. Else if IS_INSTANCE_STATICNAME is set then
    // IsStaticNames points to static instance name list. If
    union
    {
        PBISBASENAME IsBaseName;
        PBISSTATICNAMES IsStaticNames;
    };

} INSTANCESET, *PINSTANCESET, *PBINSTANCESET;

#define IS_SIGNATURE 'nalA'

//
// Guid Map Entry List maintains the list of Guid and their maps.
// Only those Guids that are Unregistered while a logger session is in
// progress is kept in this list.
// It is also used as a placeholder for InstanceIds. Trace Guid Registration
// calls return a handle to a GUIDMAPENTRY which maintains the map and the
// Instance Ids.
//

typedef struct tagTRACE_REG_INFO
{
    BOOLEAN     EnabledState;    // Indicates if this GUID is Enabled or not.
    PVOID       NotifyRoutine;
    PVOID       TraceCtxHandle;
    PVOID       NotifyContext;
    ULONG64     LoggerContext;
} TRACE_REG_INFO, *PTRACE_REG_INFO;

typedef struct
{
    ULONG           InstanceId;
    ULONG           Reserved;
    GUID            Guid;
} GUIDMAPENTRY, *PGUIDMAPENTRY;


#define IS_INSTANCE_BASENAME        0x00000001
#define IS_INSTANCE_STATICNAMES     0x00000002
#define IS_EXPENSIVE                0x00000004    // set if collection must be enabled
#define IS_COLLECTING               0x00000008    // set when collecting

#define IS_KM_PROVIDER              0x00000080    // KM data provider
#define IS_SM_PROVIDER              0x00000100    // Shared memory provider
#define IS_UM_PROVIDER              0x00000200    // User mode provider
#define IS_NEWLY_REGISTERED         0x00000800    // set if IS is registering

//
// Any traced guids are used for trace logging and not querying
#define IS_TRACED                   0x00001000

// Set when events are enabled for instance set
#define IS_ENABLE_EVENT             0x00002000

// Set when events are enabled for instance set
#define IS_ENABLE_COLLECTION        0x00004000

// Set if guid is used only for firing events and not querying
#define IS_EVENT_ONLY               0x00008000

// Set if data provider for instance set is expecting ansi instsance names
#define IS_ANSI_INSTANCENAMES       0x00010000

// Set if instance names are originated from a PDO
#define IS_PDO_INSTANCENAME         0x00020000

// If set the data provider for the InstanceSet is internal to wmi.dll
#define IS_INTERNAL_PROVIDER        0x00040000

// Set if a Traced Guid is also a Trace Control Guid
#define IS_CONTROL_GUID             0x00080000

#define IS_ON_FREE_LIST             0x80000000

typedef struct tagGUIDENTRY
{
    union
    {
        // Entry in list of all guids registered with WMI
        LIST_ENTRY MainGEList;

        // Entry in list of free guid entry blocks
        LIST_ENTRY FreeGEList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Count of number of data sources using this guid
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Count of InstanceSets headed by this guid
    ULONG ISCount;

    // Head of list of all instances for guid
    LIST_ENTRY ISHead;

    // Guid that represents data block
    GUID Guid;

} GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

#define GE_SIGNATURE 'diuG'

#define GE_ON_FREE_LIST        0x80000000

//
// When set this guid is an internally defined guid that has no data source
// attached to it.
#define GE_FLAG_INTERNAL    0x00000001



typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMRList;

        // Entry in list of free DS
        LIST_ENTRY FreeMRList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    PWCHAR MofImagePath;           // Path to image file with resource
    PWCHAR MofResourceName;        // Name of resource containing mof data
#ifdef WMI_USER_MODE
    LIST_ENTRY MRMCHead;
#endif

} MOFRESOURCE, *PMOFRESOURCE;

#define MR_SIGNATURE 'yhsA'


#if DBG
#define AVGMOFRESOURCECOUNT 1
#else
#define AVGMOFRESOURCECOUNT 4
#endif

typedef struct tagDATASOURCE
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainDSList;

        // Entry in list of free DS
        LIST_ENTRY FreeDSList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    ULONG Signature;

    // Head of list of instances for this DS
    LIST_ENTRY ISHead;

    // Binding string and callback address for DS rpc server
    PTCHAR BindingString;
    RPC_BINDING_HANDLE RpcBindingHandle;
    ULONG RequestAddress;
    ULONG RequestContext;

    // Provider id of kernel mode driver
    ULONG_PTR ProviderId;

    // Path to registry holding ACLs
    PTCHAR RegistryPath;

    // Head of list of MofResources attached to data source
    ULONG MofResourceCount;
    PMOFRESOURCE *MofResources;
    PMOFRESOURCE StaticMofResources[AVGMOFRESOURCECOUNT];
};

#define DS_SIGNATURE ' naD'

#define VERIFY_DPCTXHANDLE(DsCtxHandle) \
    ( ((DsCtxHandle) == NULL) || \
      (((PBDATASOURCE)(DsCtxHandle))->Signature == DS_SIGNATURE) )
    
typedef struct tagDATASOURCE DATASOURCE, *PDATASOURCE, *PBDATASOURCE;

#define DS_ALLOW_ALL_ACCESS    0x00000001
#define DS_KERNEL_MODE         0x00000002

//
// Set in the Internal WMI data source
#define DS_INTERNAL            0x00000004

#define DS_ON_FREE_LIST        0x80000000


//
// A list of enabled notifications is maintained by the wmi service to mange
// delivering events and to know when to send enable and disable event
// wmi requests to the data providers. Each NOTIFICATIONENTRY has an array of
// DCREF which is a reference to the data consumer who is interested in the
// event.

#define RPCOUTSTANDINGCALLLIMIT 128

typedef struct
{
    LIST_ENTRY MainDCList;        // Node on global data consumer list
    PCHUNKHEADER Chunk;           // Chunk in which entry is located
    ULONG Flags;
    ULONG RefCount;

    ULONG Signature;
                                  // Actual RPC binding handle
    RPC_BINDING_HANDLE RpcBindingHandle;

    PUCHAR EventData;             // Buffer to hold events to be sent
    ULONG LastEventOffset;        // Offset in EventData to previous event
    ULONG NextEventOffset;        // Offset in EventData to write next event
    ULONG EventDataSizeLeft;      // Number of bytes left to use in EventData

    ULONG RpcCallsOutstanding;    // Number of rpc calls outstanding
#if DBG
    PTCHAR BindingString;         // Binding string for consumer
#endif
} DCENTRY, *PDCENTRY;

#define DC_SIGNATURE 'cirE'

// If the data consumer has had its context rundown routine then this flag
// is set. This indicates that the data consumer has gone away and no more
// events should be sent to him.
#define DC_FLAG_RUNDOWN        0x00000001

#define VERIFY_DCCTXHANDLE(DcCtxHandle) \
    ( ((DcCtxHandle) == NULL) || \
      (((PDCENTRY)(DcCtxHandle))->Signature == DC_SIGNATURE) )


typedef struct
{
    PDCENTRY DcEntry;     // points at data consumer interested in notification
                          // Number of times collect has been enabled by
                          // this DC.
    ULONG CollectRefCount;

                          // Number of times collect has been enabled by
                          // this DC.
    ULONG EventRefCount;

    ULONG Flags;         // Flags
    ULONG LostEventCount;
} DCREF, *PDCREF;

//
// _ENABLED flag set if DP already called to enable notification or collection
#define DCREF_FLAG_NOTIFICATION_ENABLED    0x00000001
#define DCREF_FLAG_COLLECTION_ENABLED      0x00000002

// if DCREF_FLAG_NO_EXTRA_THREAD set then WMI will not create a special thread
// to do the direct notification callback.
#define DCREF_FLAG_NO_EXTRA_THREAD        0x00000008

// If this flag is set then the notification callback is expecting an ANSI
// instance names.
#define DCREF_FLAG_ANSI                   0x00000010

// NOTE: Other notification flags in wmium.h are:
// NOTIFICATION_TRACE_FLAG 0x00010000
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
#define NOTIFICATION_FLAG_CALLBACK_DIRECT    0x00020000
#define NOTIFICATION_FLAG_CALLBACK_QUEUED    0x00040000
#define NOTIFICATION_FLAG_WINDOW             0x00080000
#define NOTIFICATION_FLAG_BATCHED            0x00100000

//
// This flag is set for those guid handles that may be duplicated in
// the list. All Notifyee slots that have this flag are considered in a
// group and only one handle needs to be put on the list
//
#define NOTIFICATION_FLAG_GROUPED_EVENT      0x00200000

//
// This flag is set for those guid handles that are pending closure.
// Only the pump thread is allowed to close a handle; the main threads
// will set this flag to indicate that the handle should no longer be
// used. When the pump thread builds the list of handles and notices
// the flag it will close the handle.
//
#define NOTIFICATION_FLAG_PENDING_CLOSE      0x00400000

#define EtwpIsNotifyeePendingClose(Notifyee) \
    (((Notifyee)->Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == NOTIFICATION_FLAG_PENDING_CLOSE)


//
// These are the flags contained in DcRef->Flags that pertain to Notifications
#define NOTIFICATION_MASK_EVENT_FLAGS  \
                                    (NOTIFICATION_FLAG_CALLBACK_DIRECT | \
                                     NOTIFICATION_FLAG_CALLBACK_QUEUED | \
                                     NOTIFICATION_FLAG_WINDOW | \
                                     DCREF_FLAG_NO_EXTRA_THREAD | \
                                     DCREF_FLAG_ANSI)


//
// This defines the number of DC references a NOTIFICATIONENTRY can have
// in a single entry

// CONSIDER: Merging NOTIFICATIONENTRY with GUIDENTRY
#define DCREFPERNOTIFICATION    16

typedef struct _notificationentry
{
    LIST_ENTRY MainNotificationList;    // Node in main notifications list
    PCHUNKHEADER Chunk;                 // Chunk in which entry is located
    ULONG Flags;                        // flags
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    GUID Guid;                          // guid representing notification
                                        // If > DCREFPERNOTIFICATION DC have
                                        // enabled this event then this points
                                        // to another NOTIFICATIONENTRY which
                                        // has another DCREF array
    struct _notificationentry *Continuation;
    ULONG EventRefCount;                // Global count of event enables
    ULONG CollectRefCount;              // Global count of collection enables
    ULONG64 LoggerContext;              // Logger context handle
        
    HANDLE CollectInProgress;           // Event set when all collect complete

    DCREF DcRef[DCREFPERNOTIFICATION];    // DC that have enabled this event
} NOTIFICATIONENTRY, *PNOTIFICATIONENTRY;

#define NE_SIGNATURE 'eluJ'

// Set when a notification request is being processed by the data providers
#define NE_FLAG_NOTIFICATION_IN_PROGRESS 0x00000001

// Set when a collection request is being processed by the data providers
#define NE_FLAG_COLLECTION_IN_PROGRESS 0x00000002

// Set when a trace disable is being processed by a worker thread
#define NE_FLAG_TRACEDISABLE_IN_PROGRESS 0x00000004

#ifdef WMI_USER_MODE
//
// Valid MOF data types for qualifiers and properties (data items)
typedef enum
{
    MOFInt32 = 0,                // 32bit integer
    MOFUInt32 = 1,               // 32bit unsigned integer
    MOFInt64 = 2,                // 64bit integer
    MOFUInt64 = 3,               // 32bit unsigned integer
    MOFInt16 = 4,                // 16bit integer
    MOFUInt16 = 5,               // 16bit unsigned integer
    MOFChar = 6,                 // 8bit integer
    MOFByte = 7,                 // 8bit unsigned integer
    MOFWChar = 8,                // Wide (16bit) character
    MOFDate = 9,                 // Date field
    MOFBoolean = 10,             // 8bit Boolean value
    MOFEmbedded = 11,            // Embedded class
    MOFString = 12,              // Counted String type
    MOFZTString = 13,            // NULL terminated unicode string
    MOFAnsiString = 14,          // NULL terminated ansi string
    MOFUnknown = 0xffffffff      // Data type is not known
} MOFDATATYPE, *PMOFDATATYPE;

// Data items that are of type MOFString are stored in the data block as a
// counted unicode string. The text of the string is always preceeded by
// a USHORT which contains the count of bytes following that composes the
// string. The string may be NULL terminated and in that case the count must
// include the null termination bytes.


// Data items that are of type MOFDate are fixed length Unicode strings and
// not preceeded by a count value. It is in the following fixed format:
//
//      yyyymmddhhmmss.mmmmmmsutc
//
// Where  yyyy is a 4 digit year, mm is the month, dd is the day,  hh  is
// the  hour  (24-hour clock), mm is the minute, ss is  the  second,  the
// mmmmmm is the number of microseconds (typically all zeros) and s is  a
//  "+"  or  "-" indicating the sign of the UTC (correction field, and  utc
// is  the  offset from UTC in minutes (using the sign indicated  by  s).
// For  example,  Wednesday, May 25, 1994, at 1:30:15  PM  EDT  would  be
// represented as:
//
//      19940525133015.0000000-300
//
// Values  MUST  be zero-padded so that the entire string is  always  the
// same 25-character length.  Fields which are not significant  MUST  be
// replaced  with asterisk characters.  Similarly,  intervals   use  the
// same  format, except   that   the  interpretation of the fields is based
// on elapsed time. For  example,  an  elapsed time of 1 day, 13 hours,
// 23 minutes, and 12 seconds  would  be:
//
//      00000001132312.000000+000
//
// A UTC offset of zero is always used for interval properties.

struct _MOFCLASSINFOW;
struct _MOFCLASSINFOA;

//
// Each class has one or more data items that are described by a MOFDATAITEM
// structure.
typedef struct
{
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Name;                    // Text name of data item
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array

    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPWSTR HeaderName;// Name of structure in generated header
    struct _MOFCLASSINFOW *MethodClassInfo;
    ULONG MaxLen;
} MOFDATAITEMW, *PMOFDATAITEMW;

typedef struct
{
    LPSTR
           Name;                    // Text name of data item
    LPSTR
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array
    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPSTR HeaderName;               // Name of structure in generated header
    struct _MOFCLASSINFOA *MethodClassInfo;
    ULONG MaxLen;
} MOFDATAITEMA, *PMOFDATAITEMA;

#ifdef UNICODE
typedef MOFDATAITEMW MOFDATAITEM;
typedef PMOFDATAITEMW PMOFDATAITEM;
#else
typedef MOFDATAITEMA MOFDATAITEM;
typedef PMOFDATAITEMA PMOFDATAITEM;
#endif


// Data item is actually a fixed sized array
#define MOFDI_FLAG_FIXED_ARRAY        0x00000001

// Data item is actually a variable length array
#define MOFDI_FLAG_VARIABLE_ARRAY     0x00000002

// Data item is actually an embedded class
#define MOFDI_FLAG_EMBEDDED_CLASS     0x00000004

// Data item is readable
#define MOFDI_FLAG_READABLE           0x00000008

// Data item is writable
#define MOFDI_FLAG_WRITEABLE          0x00000010

// Data item is an event
#define MOFDI_FLAG_EVENT              0x00000020

// Embedded class Guid is not set
#define MOFDI_FLAG_EC_GUID_NOT_SET    0x00000040

// Data item is really a method
#define MOFDI_FLAG_METHOD             0x00000080

// Data item is an input method parameter
#define MOFDI_FLAG_INPUT_METHOD       0x00000100

// Data item is an output method parameter
#define MOFDI_FLAG_OUTPUT_METHOD      0x00000200

//
// The MOFCLASSINFO structure describes the format of a data block
typedef struct _MOFCLASSINFOW
{
    GUID Guid;                    // Guid that represents class

#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Name;       // Text name of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Description;// Text description of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      HeaderName;// Name of structure in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName1;// Name of Guid in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG_PTR ClassQualifierHandle;      // CBMOFObj, BMOF class qualifier  ptr
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
#ifdef MIDL_PASS
    [size_is(DataItemCount)]
#endif
      MOFDATAITEMW *DataItems;
#ifndef MIDL_PASS
    UCHAR Tail[1];
#endif
} MOFCLASSINFOW, *PMOFCLASSINFOW;

typedef struct _MOFCLASSINFOA
{
    GUID Guid;                    // Guid that represents class

    LPSTR
                      Name;       // Text name of class
    LPSTR
                      Description;// Text description of class
    LPSTR
                      HeaderName;// Name of structure in generated header
    LPSTR
                      GuidName1;// Name of Guid in generated header
    LPSTR
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG_PTR ClassQualifierHandle;      // CBMOFObj, BMOF class qualifier  ptr
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
    MOFDATAITEMA *DataItems;
    UCHAR Tail[1];
} MOFCLASSINFOA, *PMOFCLASSINFOA;

#ifdef UNICODE
typedef MOFCLASSINFOW MOFCLASSINFO;
typedef PMOFCLASSINFOW PMOFCLASSINFO;
#else
typedef MOFCLASSINFOA MOFCLASSINFO;
typedef PMOFCLASSINFOA PMOFCLASSINFO;
#endif

// 0x00000001 to 0x00000004 are not available
#define MOFCI_FLAG_EVENT          0x10000000
#define MOFCI_FLAG_EMBEDDED_CLASS 0x20000000
#define MOFCI_FLAG_READONLY       0x40000000
#define MOFCI_FLAG_METHOD_PARAMS  0x80000000

typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMCList;

        // Entry in list of free DS
        LIST_ENTRY FreeMCList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    PMOFCLASSINFOW MofClassInfo;   // Actual class info data

    LIST_ENTRY MCMRList;          // Entry in list of MCs in a MR

    LIST_ENTRY MCVersionList;     // Head or entry in list of MCs with
                                  // same guid, but possibly different versions

    ULONG_PTR ClassObjectHandle;      // CBMOFObj, BMOF class object ptr
    PMOFRESOURCE MofResource;     // Resource holding class info

} MOFCLASS, *PMOFCLASS;

// If this is set then the MOF class can never be replaced with a later version
#define MC_FLAG_NEVER_REPLACE 0x00000001

#endif

//
// AVGGUIDSPERDS defines a guess as to the number of guids that get registered
// by any data provider. It is used to allocate the buffer used to deliver
// registration change notifications.
#if DBG
#define AVGGUIDSPERDS    2
#else
#define AVGGUIDSPERDS    256
#endif


#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)(Base) + (Offset)))



//
// Guid and InstanceSet cache
#if DBG
#define PTRCACHEGROWSIZE 2
#else
#define PTRCACHEGROWSIZE 64
#endif

typedef struct
{
    LPGUID Guid;
    PBINSTANCESET InstanceSet;
} PTRCACHE;


//
// Registration data structures
//

#ifdef MEMPHIS

extern HANDLE SMMutex;
#define EtwpEnterSMCritSection() WaitForSingleObject(SMMutex, INFINITE)

#define EtwpLeaveSMCritSection() ReleaseMutex(SMMutex)

#else
extern RTL_CRITICAL_SECTION SMCritSect;
#if DBG
#ifdef CRITSECTTRACE
#define EtwpEnterSMCritSection() { \
    EtwpDebugPrint(("WMI: Enter SM Crit %s %d\n", __FILE__, __LINE__)); \
    RtlEnterCriticalSection(&SMCritSect); }

#define EtwpLeaveSMCritSection() { \
    EtwpDebugPrint(("WMI: Leave SM Crit %s %d\n", __FILE__, __LINE__)); \
    RtlLeaveCriticalSection(&SMCritSect); }
#else
#define EtwpEnterSMCritSection() \
                EtwpAssert(NT_SUCCESS(RtlEnterCriticalSection(&SMCritSect)));
#define EtwpLeaveSMCritSection() { \
     EtwpAssert(SMCritSect.LockCount >= 0); \
     EtwpAssert(NT_SUCCESS(RtlLeaveCriticalSection(&SMCritSect))); }
#endif // CRITSECTTRACE

#else
#define EtwpEnterSMCritSection() RtlEnterCriticalSection(&SMCritSect)
#define EtwpLeaveSMCritSection() RtlLeaveCriticalSection(&SMCritSect)
#endif // DBG
#endif // MEMPHIS

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// WMI MOF result codes. Since they are never given to the caller they are
// defined in here
#define ERROR_WMIMOF_INCORRECT_DATA_TYPE -1               /* 0xffffffff */
#define ERROR_WMIMOF_NO_DATA -2                           /* 0xfffffffe */
#define ERROR_WMIMOF_NOT_FOUND -3                         /* 0xfffffffd */
#define ERROR_WMIMOF_UNUSED -4                            /* 0xfffffffc */
// Property %ws in class %ws has no embedded class name
#define ERROR_WMIMOF_NO_EMBEDDED_CLASS_NAME -5            /* 0xfffffffb */
// Property %ws in class %ws has an unknown data type
#define ERROR_WMIMOF_UNKNOWN_DATA_TYPE -6                 /* 0xfffffffa */
// Property %ws in class %ws has no syntax qualifier
#define ERROR_WMIMOF_NO_SYNTAX_QUALIFIER -7               /* 0xfffffff9 */
#define ERROR_WMIMOF_NO_CLASS_NAME -8                     /* 0xfffffff8 */
#define ERROR_WMIMOF_BAD_DATA_FORMAT -9                   /* 0xfffffff7 */
// Property %ws in class %ws has the same WmiDataId %d as property %ws
#define ERROR_WMIMOF_DUPLICATE_ID -10                     /* 0xfffffff6 */
// Property %ws in class %ws has a WmiDataId of %d which is out of range
#define ERROR_WMIMOF_BAD_DATAITEM_ID -11                  /* 0xfffffff5 */
#define ERROR_WMIMOF_MISSING_DATAITEM -12                 /* 0xfffffff4 */
// Property for WmiDataId %d is not defined in class %ws
#define ERROR_WMIMOF_DATAITEM_NOT_FOUND -13               /* 0xfffffff3 */
// Embedded class %ws not defined for Property %ws in Class %ws
#define ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND -14         /* 0xfffffff2 */
// Property %ws in class %ws has an incorrect [WmiVersion] qualifier
#define ERROR_WMIMOF_INCONSISTENT_VERSIONING -15          /* 0xfffffff1 */
#define ERROR_WMIMOF_NO_PROPERTY_QUALIFERS -16            /* 0xfffffff0 */
// Class %ws has a badly formed or missing [guid] qualifier
#define ERROR_WMIMOF_BAD_OR_MISSING_GUID -17              /* 0xffffffef */
// Could not find property %ws which is the array size for property %ws in class %ws
#define ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND -18          /* 0xffffffee */
// A class could not be parsed properly
#define ERROR_WMIMOF_CLASS_NOT_PARSED -19                 /* 0xffffffed */
// Wmi class %ws requires the qualifiers [Dynamic, Provider("WmiProv")]
#define ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS -20          /* 0xffffffec */
// Error accessing binary mof file %s
#define ERROR_WMIMOF_CANT_ACCESS_FILE -21                 /* 0xffffffeb */
// Property InstanceName in class %ws must be type string and not %ws
#define ERROR_WMIMOF_INSTANCENAME_BAD_TYPE -22            /* 0xffffffea */
// Property Active in class %ws must be type bool and not %ws
#define ERROR_WMIMOF_ACTIVE_BAD_TYPE -23                  /* 0xffffffe9 */
// Property %ws in class %ws does not have [WmiDataId()] qualifier
#define ERROR_WMIMOF_NO_WMIDATAID -24                     /* 0xffffffe8 */
// Property InstanceName in class %ws must have [key] qualifier
#define ERROR_WMIMOF_INSTANCENAME_NOT_KEY -25             /* 0xffffffe7 */
// Class %ws does not have an InstanceName qualifier
#define ERROR_WMIMOF_NO_INSTANCENAME -26                  /* 0xffffffe6 */
// Class %ws does not have an Active qualifier
#define ERROR_WMIMOF_NO_ACTIVE -27                        /* 0xffffffe5 */
// Property %ws in class %ws is an array, but doesn't specify a dimension
#define ERROR_WMIMOF_MUST_DIM_ARRAY -28                   /* 0xffffffe4 */
// The element count property %ws for the variable length array %ws in class %ws is not an integral type
#define ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE -29           /* 0xdddddde4 */
// Property %ws in class %ws is both a fixed and variable length array
#define ERROR_WMIMOF_BOTH_FIXED_AND_VARIABLE_ARRAY -30    /* 0xffffffe3 */
// Embedded class %ws should not have InstaneName or Active properties
#define ERROR_WMIMOF_EMBEDDED_CLASS -31                   /* 0xffffffe2 */
#define ERROR_WMIMOF_IMPLEMENTED_REQUIRED -32             /* 0xffffffe1 */
//    TEXT("WmiMethodId for method %ws in class %ws must be unique")
#define ERROR_WMIMOF_DUPLICATE_METHODID -33             /* 0xffffffe0 */
//    TEXT("WmiMethodId for method %ws in class %ws must be specified")
#define ERROR_WMIMOF_MISSING_METHODID -34             /* 0xffffffdf */
//    TEXT("WmiMethodId for method %ws in class %ws must not be 0")
#define ERROR_WMIMOF_METHODID_ZERO -35             /* 0xffffffde */
//    TEXT("Class %ws is derived from WmiEvent and may not be [abstract]")
#define ERROR_WMIMOF_WMIEVENT_ABSTRACT -36             /* 0xffffffdd */
//    TEXT("The element count property for the variable length array
//    %ws in class %ws is not a property of the class"),
#define ERROR_WMIMOF_VL_ARRAY_NOT_FOUND -37           /* 0xffffffdc */
//    TEXT("An error occured resolving the variable length array
//    property %ws in class %ws to element count property")
#define ERROR_WMIMOF_VL_ARRAY_NOT_RESOLVED -38       /* 0xffffffdb */
//    TEXT("Method %ws in class %ws must return void\n")
#define ERROR_WMIMOF_METHOD_RETURN_NOT_VOID -39     /* 0xffffffda */
//     TEXT("Embedded class %ws should not have any methods\n")			
#define ERROR_WMIMOF_EMBEDDED_CLASS_HAS_METHODS -40 /* 0xffffffd9 */

#define ERROR_WMIMOF_COUNT 40

// This file is not a valid binary mof file
// ERROR_WMI_INVALID_MOF

// There was not enough memory to complete an operation
// ERROR_NOT_ENOUGH_MEMORY

//
// Function prototypes for private functions

//
// sharemem.c
ULONG EtwpEstablishSharedMemory(
    PBDATASOURCE DataSource,
    LPCTSTR SectionName,
    ULONG SectionSize
    );

//
// validate.c
BOOLEAN EtwpValidateCountedString(
    WCHAR *String
    );

BOOLEAN EtwpValidateGuid(
    LPGUID Guid
    );

BOOLEAN EtwpProbeForRead(
    PUCHAR Buffer,
    ULONG BufferSize
    );

//
// alloc.c

extern LIST_ENTRY GEHead;
extern PLIST_ENTRY GEHeadPtr;
extern CHUNKINFO GEChunkInfo;

extern LIST_ENTRY NEHead;
extern PLIST_ENTRY NEHeadPtr;
extern CHUNKINFO NEChunkInfo;

extern LIST_ENTRY DSHead;
extern PLIST_ENTRY DSHeadPtr;
extern CHUNKINFO DSChunkInfo;

extern LIST_ENTRY DCHead;
extern PLIST_ENTRY DCHeadPtr;
extern CHUNKINFO DCChunkInfo;

extern LIST_ENTRY MRHead;
extern PLIST_ENTRY MRHeadPtr;
extern CHUNKINFO MRChunkInfo;

extern CHUNKINFO ISChunkInfo;

extern LIST_ENTRY GMHead;
extern PLIST_ENTRY GMHeadPtr;

#ifdef WMI_USER_MODE
extern LIST_ENTRY MCHead;
extern PLIST_ENTRY MCHeadPtr;
extern CHUNKINFO MCChunkInfo;
#endif

#ifdef TRACK_REFERNECES
#define EtwpUnreferenceDS(DataSource) \
{ \
    EtwpDebugPrint(("WMI: Unref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource); \
}

#define EtwpReferenceDS(DataSource) \
{ \
    EtwpDebugPrint(("WMI: Ref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)DataSource); \
}

#define EtwpUnreferenceGE(GuidEntry) \
{ \
    EtwpDebugPrint(("WMI: Unref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry); \
}

#define EtwpReferenceGE(GuidEntry) \
{ \
    EtwpDebugPrint(("WMI: Ref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)GuidEntry); \
}

#define EtwpUnreferenceIS(InstanceSet) \
{ \
    EtwpDebugPrint(("WMI: Unref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet); \
}

#define EtwpReferenceIS(InstanceSet) \
{ \
    EtwpDebugPrint(("WMI: Ref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)InstanceSet); \
}

#define EtwpUnreferenceDC(DataConsumer) \
{ \
    EtwpDebugPrint(("WMI: Unref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer); \
}

#define EtwpReferenceDC(DataConsumer) \
{ \
    EtwpDebugPrint(("WMI: Ref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)DataConsumer); \
}

#define EtwpUnreferenceNE(NotificationEntry) \
{ \
    EtwpDebugPrint(("WMI: Unref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry); \
}

#define EtwpReferenceNE(NotificationEntry) \
{ \
    EtwpDebugPrint(("WMI: Ref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)NotificationEntry); \
}

#define WmippUnreferenceMR(MofResource) \
{ \
    EtwpDebugPrint(("WMI: Unref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource); \
}

#define WmipReferenceMR(MofResource) \
{ \
    EtwpDebugPrint(("WMI: Ref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)MofResource); \
}

#ifdef WMI_USER_MODE
#define EtwpUnreferenceMC(MofClass) \
{ \
    EtwpDebugPrint(("WMI: Unref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    EtwpUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass); \
}

#define EtwpReferenceMC(MofClass) \
{ \
    EtwpDebugPrint(("WMI: Ref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    EtwpReferenceEntry((PENTRYHEADER)MofClass); \
}
#endif
#else
#define EtwpUnreferenceDS(DataSource) \
    EtwpUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource)

#define EtwpReferenceDS(DataSource) \
    EtwpReferenceEntry((PENTRYHEADER)DataSource)

#define EtwpUnreferenceGE(GuidEntry) \
    EtwpUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry)

#define EtwpReferenceGE(GuidEntry) \
    EtwpReferenceEntry((PENTRYHEADER)GuidEntry)

#define EtwpUnreferenceIS(InstanceSet) \
    EtwpUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet)

#define EtwpReferenceIS(InstanceSet) \
    EtwpReferenceEntry((PENTRYHEADER)InstanceSet)

#define EtwpUnreferenceDC(DataConsumer) \
    EtwpUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer)

#define EtwpReferenceDC(DataConsumer) \
    EtwpReferenceEntry((PENTRYHEADER)DataConsumer)

#define EtwpUnreferenceNE(NotificationEntry) \
    EtwpUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry)

#define EtwpReferenceNE(NotificationEntry) \
    EtwpReferenceEntry((PENTRYHEADER)NotificationEntry)

#define WmipUnreferenceMR(MofResource) \
    EtwpUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource)

#define WmipReferenceMR(MofResource) \
    EtwpReferenceEntry((PENTRYHEADER)MofResource)

#ifdef WMI_USER_MODE
#define EtwpUnreferenceMC(MofClass) \
    EtwpUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass)

#define EtwpReferenceMC(MofClass) \
    EtwpReferenceEntry((PENTRYHEADER)MofClass)
#endif
#endif

PBDATASOURCE EtwpAllocDataSource(
    void
    );

PBGUIDENTRY EtwpAllocGuidEntry(
    void
    );

#define EtwpAllocInstanceSet() ((PBINSTANCESET)EtwpAllocEntry(&ISChunkInfo))
#define EtwpAllocDataConsumer() ((PDCENTRY)EtwpAllocEntry(&DCChunkInfo))

#define EtwpAllocNotificationEntry() ((PNOTIFICATIONENTRY)EtwpAllocEntry(&NEChunkInfo))

#define EtwpAllocMofResource() ((PMOFRESOURCE)EtwpAllocEntry(&MRChunkInfo))

#define WmipDebugPrint EtwpDebugPrint
#define WmipAlloc EtwpAlloc
#define WmipAssert EtwpAssert
#define WmipFree EtwpFree

#ifdef WMI_USER_MODE
#define EtwpAllocMofClass() ((PMOFCLASS)EtwpAllocEntry(&MCChunkInfo))
#endif

#define EtwpAllocString(Size) \
    EtwpAlloc((Size)*sizeof(WCHAR))

#define EtwpFreeString(Ptr) \
    EtwpFree(Ptr)

#ifdef MEMPHIS
#define EtwpAlloc(Size) \
    malloc(Size)

#define EtwpFree(Ptr) \
    free(Ptr)
    
#define EtwpInitProcessHeap()
#else

//
// Reserve 1MB for WMI.DLL, but only commit 16K initially
#define DLLRESERVEDHEAPSIZE 1024 * 1024
#define DLLCOMMITHEAPSIZE     0 * 1024

//
// Reserve 1MB for WMI service, but only commit 16K initially
#define CORERESERVEDHEAPSIZE 1024 * 1024
#define CORECOMMITHEAPSIZE     16 * 1024


extern PVOID EtwpProcessHeap;

#define EtwpInitProcessHeap() \
{ \
    if (EtwpProcessHeap == NULL) \
    { \
        EtwpCreateHeap(); \
    } \
}


#ifdef HEAPVALIDATION
PVOID EtwpAlloc(
    ULONG Size
    );

void EtwpFree(
    PVOID p
    );

#else
#if DBG
_inline PVOID EtwpAlloc(ULONG Size)
{
    EtwpAssert(EtwpProcessHeap != NULL);
    return(RtlAllocateHeap(EtwpProcessHeap, 0, Size));
}

_inline void EtwpFree(PVOID Ptr)
{
    RtlFreeHeap(EtwpProcessHeap, 0, Ptr);
}

#else
#define EtwpAlloc(Size) \
    RtlAllocateHeap(EtwpProcessHeap, 0, Size)

#define EtwpFree(Ptr) \
    RtlFreeHeap(EtwpProcessHeap, 0, Ptr)
#endif
#endif
#endif

BOOLEAN EtwpRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    );


//
// datastr.c
extern GUID EtwpBinaryMofGuid;

void EtwpGenerateBinaryMofNotification(
    PBINSTANCESET BianryMofInstanceSet,
    LPCGUID Guid    
    );

BOOLEAN EtwpEstablishInstanceSetRef(
    PBDATASOURCE DataSourceRef,
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG EtwpAddDataSource(
    PTCHAR QueryBinding,
    ULONG RequestAddress,
    ULONG RequestContext,
    LPCTSTR ImagePath,
    PWMIREGINFOW RegistrationInfo,
    ULONG RegistrationInfoSize,
    ULONG_PTR *ProviderId,
    BOOLEAN IsAnsi
    );

ULONG EtwpUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

ULONG EtwpUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

BOOLEAN  EtwpUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    );

void EtwpUpdateDataSource(
    ULONG_PTR ProviderId,
    PWMIREGINFOW RegistrationInfo,
    ULONG RetSize
    );

void EtwpRemoveDataSource(
    ULONG_PTR ProviderId
    );

void EtwpRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    );

ULONG EtwpRegisterInternalDataSource(
    void
    );

PBGUIDENTRY EtwpFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    );

PBINSTANCESET EtwpFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    );

PNOTIFICATIONENTRY EtwpFindNEByGuid(
    GUID UNALIGNED *Guid,
    BOOLEAN MakeTopOfList
    );

PDCREF EtwpFindExistingAndFreeDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer,
    PDCREF *FreeDcRef
    );

PDCREF EtwpFindDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer
    );

PBDATASOURCE EtwpFindDSByProviderId(
    ULONG_PTR ProviderId
    );

PBINSTANCESET EtwpFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    );

PMOFRESOURCE EtwpFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    );

#ifdef WMI_USER_MODE
PMOFCLASS EtwpFindMCByGuid(
    LPGUID Guid
    );

PMOFCLASS EtwpFindMCByGuidAndBestLanguage(
    LPGUID Guid,
    WORD Language
    );

PMOFCLASS EtwpFindMCByGuidAndLanguage(
    LPGUID Guid,
    WORD Language
    );
#endif

PBINSTANCESET EtwpFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    );

PWNODE_HEADER EtwpGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG GuidMax,
    ULONG NotificationCode
    );

BOOLEAN
EtwpIsControlGuid(
    PBGUIDENTRY GuidEntry
    );

void EtwpGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid
    );

//
// wbem.c
ULONG EtwpBuildMofClassInfo(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    );

ULONG EtwpReadBuiltinMof(
    void
    );


//
// from krnlmode.c
ULONG EtwpInitializeKM(
    HANDLE *WmiKMHandle
    );

void EtwpKMNonEventNotification(
    HANDLE WmiKMHandle,
    PWNODE_HEADER Wnode
    );

//
// main.c

extern HANDLE EtwpRestrictedToken;


NTSTATUS EtwpGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    );

ULONG WmiRunService(
    ULONG Context
#ifdef MEMPHIS
    , HINSTANCE InstanceHandle
#endif
    );

ULONG EtwpInitializeAccess(
    PTCHAR *RpcStringBinding
    );

void WmiTerminateService(
    void
    );

ULONG WmiInitializeService(
    void
);

void WmiDeinitializeService(
    void
);

void EtwpEventNotification(
    PWNODE_HEADER Wnode,
    BOOLEAN SingleEvent,
    ULONG EventSizeGuess
    );

#define EtwpBuildRegistrationNotification(Wnode, WnodeSize, NotificationCode, GuidCount) { \
    memset(Wnode, 0, sizeof(WNODE_HEADER)); \
    memcpy(&Wnode->Guid, &RegChangeNotificationGuid, sizeof(GUID)); \
    Wnode->BufferSize = WnodeSize; \
    Wnode->Linkage = NotificationCode; \
    Wnode->Version = GuidCount; \
    Wnode->Flags = WNODE_FLAG_INTERNAL; \
}

void EtwpSendQueuedEvents(
    void
    );

ULONG EtwpCleanupDataConsumer(
    PDCENTRY DataConsumer
#if DBG
    ,BOOLEAN *NotificationsEnabled,
    BOOLEAN *CollectionsEnabled
#endif
    );
//
// This defines the maximum number of replacement strings over all of the
// event messages.
#define MAX_MESSAGE_STRINGS 2
void __cdecl EtwpReportEventLog(
    ULONG MessageCode,
    WORD MessageType,
    WORD MessageCategory,
    DWORD RawDataSize,
    PVOID RawData,
    WORD StringCount,
    ...
    );

#ifdef MEMPHIS
long WINAPI
DeviceNotificationWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

void EtwpDestroyDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND WindowHandle
    );

ULONG EtwpCreateDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND *DeviceNotificationWindow
    );

#endif


//
// server.c
void EtwpRpcServerDeinitialize(
    void
    );

ULONG EtwpRpcServerInitialize(
    void
    );

ULONG EtwpDeliverWnodeToDS(
    ULONG ActionCode,
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode
);

ULONG EtwpDoDisableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

ULONG CollectOrEventWorker(
    PDCENTRY DataConsumer,
    LPGUID Guid,
    BOOLEAN Enable,
    BOOLEAN IsEvent,
    ULONG *NotificationCookie,
    ULONG64 LoggerContext,
    ULONG NotificationFlags
    );

ULONG EtwpCreateRestrictedToken(
    HANDLE *RestrictedToken
    );

void EtwpShowPrivs(
    HANDLE TokenHandle
    );

#ifdef MEMPHIS
#define EtwpRestrictToken(Token) (ERROR_SUCCESS)
#define EtwpUnrestrictToken() (ERROR_SUCCESS)
#else
ULONG EtwpRestrictToken(
    HANDLE RestrictedToken
    );

ULONG EtwpUnrestrictToken(
    void
    );

ULONG EtwpServiceDisableTraceProviders(
    PWNODE_HEADER Wnode
    );

#endif

void EtwpReleaseCollectionEnabled(
    PNOTIFICATIONENTRY NotificationEntry
    );

//
// chunk.c
ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    );

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    );

ULONG AnsiSizeForUnicodeString(
    PWCHAR UnicodeString,
    ULONG *AnsiSizeInBytes
    );

ULONG UnicodeSizeForAnsiString(
    LPCSTR AnsiString,
    ULONG *UnicodeSizeInBytes
    );

//
// debug.c
#if DBG
void EtwpDumpIS(
    PBINSTANCESET IS,
    BOOLEAN RecurseGE,
    BOOLEAN RecurseDS
    );

void EtwpDumpGE(
    PBGUIDENTRY GE,
    BOOLEAN RecurseIS
    );

void EtwpDumpDS(
    PBDATASOURCE DS,
    BOOLEAN RecurseIS
    );

void EtwpDumpAllDS(
    void
    );

#endif

#ifndef MEMPHIS

typedef enum
{
    TRACELOG_START        = 0,
    TRACELOG_STOP         = 1,
    TRACELOG_QUERY        = 2,
    TRACELOG_QUERYALL     = 3,
    TRACELOG_QUERYENABLED = 4,
    TRACELOG_UPDATE       = 5,
    TRACELOG_FLUSH        = 6
} TRACEREQUESTCODE;

typedef struct _WMI_REF_CLOCK {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   StartPerfClock;
} WMI_REF_CLOCK, *PWMI_REF_CLOCK;

//
// logsup.c

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
);

ULONG
EtwpAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK RefClock,
    IN ULONG Update
    );

ULONG
EtwpStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    );
ULONG
EtwpFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

VOID
EtwpInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    );

ULONG
EtwpGetTraceRegKeys(
    );

ULONG
EtwpFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpRelogHeaderToLogFile( 
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo ,
    IN PSYSTEM_TRACE_HEADER RelogProp
    );

//
// umlog.c
BOOLEAN
FASTCALL
EtwpIsPrivateLoggerOn();

ULONG
EtwpSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
FASTCALL
EtwpTraceUmEvent(
    IN PWNODE_HEADER Wnode
    );

NTSTATUS
EtwpTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\guidapi.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    wmiguidapi.c

Abstract:

   Data structures and functions that generate GUID. 


--*/



#include <ntos.h>

#define MAX_CACHED_UUID_TIME 10000  // 10 seconds
#define WMI_UUID_TIME_HIGH_MASK    0x0FFF
#define WMI_UUID_VERSION           0x1000
typedef long WMI_STATUS;
#define WMI_ENTRY __stdcall
#define WMI_S_OUT_OF_MEMORY               14
#define WMI_S_OK                          0
#define WMI_S_UUID_LOCAL_ONLY            1824L
//#define RPC_RAND_UUID_VERSION      0x4000
#define WMI_UUID_RESERVED          0x80
#define WMI_UUID_CLOCK_SEQ_HI_MASK 0x3F

extern EtwpSleep(unsigned long dwMilliseconds);

typedef struct _WMI_UUID_GENERATE
{
    unsigned long  TimeLow;
    unsigned short TimeMid;
    unsigned short TimeHiAndVersion;
    unsigned char  ClockSeqHiAndReserved;
    unsigned char  ClockSeqLow;
    unsigned char  NodeId[6];
} WMI_UUID_GENERATE;

typedef struct _UUID_CACHED_VALUES_STRUCT
{

    ULARGE_INTEGER      Time;  // Time of last uuid allocation
    long                AllocatedCount; // Number of UUIDs allocated
    unsigned char       ClockSeqHiAndReserved;
    unsigned char       ClockSeqLow;

    unsigned char       NodeId[6];
} UUID_CACHED_VALUES_STRUCT;


UUID_CACHED_VALUES_STRUCT  UuidCachedValues;

WMI_STATUS 
EtwpUuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT *Values
    )
/*++

Routine Description:

    This routine allocates a block of uuids for UuidCreate to handout.

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.
             The following fields will be updated here:

    NextTimeLow -   Together with LastTimeLow, this denotes the boundaries
                    of a block of Uuids. The values between NextTimeLow
                    and LastTimeLow are used in a sequence of Uuids returned
                    by UuidCreate().

    LastTimeLow -   See NextTimeLow.

    ClockSequence - Clock sequence field in the uuid.  This is changed
                    when the clock is set backward.

Return Value:

    WMI_S_OK - We successfully allocated a block of uuids.

    WMI_S_OUT_OF_MEMORY - As needed.
--*/
{
    NTSTATUS NtStatus;
    ULARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;
    int Tries = 0;

    do {
        NtStatus = NtAllocateUuids(&Time, &Range, &Sequence, (char *) &Values->NodeId[0]);

        if (NtStatus == STATUS_RETRY)
            {
            EtwpSleep(1);
            }

        Tries++;

        if (Tries == 20)
            {
#ifdef DEBUGRPC
            PrintToDebugger("Rpc: NtAllocateUuids retried 20 times!\n");
            ASSERT(Tries < 20);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            }

        } while(NtStatus == STATUS_RETRY);

    if (!NT_SUCCESS(NtStatus))
        {
        return(WMI_S_OUT_OF_MEMORY);
        }

    // NtAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (unsigned __int64) (1000*1000*10)       // seconds
                     * (unsigned __int64) (60 * 60 * 24)       // days
                     * (unsigned __int64) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        WMI_UUID_RESERVED | (((unsigned char) (Sequence >> 8))
        & (unsigned char) WMI_UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (unsigned char) (Sequence & 0x00FF);

    // The order of these assignments is important

    Values->Time.QuadPart = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    /*if ((Values->NodeId[0] & 0x80) == 0)
        {*/
        return(WMI_S_OK);
        /*}
    
    return (WMI_S_UUID_LOCAL_ONLY);*/
}



WMI_STATUS WMI_ENTRY
EtwpUuidCreateSequential (
    OUT UUID * Uuid
    )
/*++

Routine Description:

    This routine will create a new UUID (or GUID) which is unique in
    time and space.  We will try to guarantee that the UUID (or GUID)
    we generate is unique in time and space.  This means that this
    routine may fail if we can not generate one which we can guarantee
    is unique in time and space.

Arguments:

    Uuid - Returns the generated UUID (or GUID).

Return Value:

    WMI_S_OK - The operation completed successfully.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.

    WMI_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
        network address.  This is a warning to the user, the
        UUID is still valid, it just may not be unique on other machines.

    WMI_S_OUT_OF_MEMORY - Returned as needed.
--*/
{
    WMI_UUID_GENERATE * WmiUuid = (WMI_UUID_GENERATE *) Uuid;
    WMI_STATUS Status = WMI_S_OK;
	ULARGE_INTEGER Time;
    long Delta;
    static unsigned long LastTickCount = 0;

    if (NtGetTickCount()-LastTickCount > MAX_CACHED_UUID_TIME)
        {
        UuidCachedValues.AllocatedCount = 0;
        LastTickCount = NtGetTickCount();
        }

    for(;;)
        {
        Time.QuadPart = UuidCachedValues.Time.QuadPart;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(unsigned long *)&WmiUuid->ClockSeqHiAndReserved =
            *(unsigned long *)&UuidCachedValues.ClockSeqHiAndReserved;
        *(unsigned long *)&WmiUuid->NodeId[2] =
            *(unsigned long *)&UuidCachedValues.NodeId[2];

        Delta = InterlockedDecrement(&UuidCachedValues.AllocatedCount);

        if (Time.QuadPart != UuidCachedValues.Time.QuadPart)
            {
            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
            }

        if (Delta >= 0)
            {
            break;
            }

        //
        // Allocate block of Uuids.
        //

        Status = EtwpUuidGetValues( &UuidCachedValues );
     /*   if (Status == WMI_S_OK)
            {
            UuidCacheValid = CACHE_VALID;
            }
        else
            {
            UuidCacheValid = CACHE_LOCAL_ONLY;
            }*/

        if (Status != WMI_S_OK)
            {
#ifdef DEBUGRPC
            if (Status != WMI_S_OUT_OF_MEMORY)
                PrintToDebugger("RPC: UuidGetValues returned or raised: %x\n", Status);
#endif
            ASSERT( (Status == WMI_S_OUT_OF_MEMORY) );


            return Status;
            }

        // Loop
        }


    Time.QuadPart -= Delta;

    WmiUuid->TimeLow = (unsigned long) Time.LowPart;
    WmiUuid->TimeMid = (unsigned short) (Time.HighPart & 0x0000FFFF);
    WmiUuid->TimeHiAndVersion = (unsigned short)
        (( (unsigned short)(Time.HighPart >> 16)
        & WMI_UUID_TIME_HIGH_MASK ) | WMI_UUID_VERSION);

   // ASSERT(   Status == WMI_S_OK
   //        || Status == WMI_S_UUID_LOCAL_ONLY);

 /*   if (UuidCacheValid == CACHE_LOCAL_ONLY)
        {
        return WMI_S_UUID_LOCAL_ONLY;
        }*/

    return(Status);
}


NTSTATUS
EtwpUuidCreate(
    OUT UUID *Uuid
    )
{

	return (NTSTATUS)EtwpUuidCreateSequential (Uuid );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\logapi.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    logapi.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:


--*/

#ifndef MEMPHIS
#ifdef DBG
#include <stdio.h> // only for fprintf
#endif
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <ntverp.h>
#include <limits.h>
#include "wmiump.h"
#include "evntrace.h"
#include "tracelib.h"
#include "trcapi.h"
#include <strsafe.h>

#define MAXSTR                          1024

#define MAXINST                         0XFFFFFFFF
#define TRACE_RETRY_COUNT               5

#define TRACE_HEADER_FULL   (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_FULL_HEADER << 16))

#define TRACE_HEADER_INSTANCE (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_INSTANCE << 16))

ULONG   EtwpIsBBTOn = 0;


//
// This guid is used by RegisterTraceGuids when register a tracelog
// provider. Any ACLs for controlling registration should be placed on
// this guid. Note that since the kernel will created unnamed guid
// objects, multiple tracelog providers can register without issue.
//
// {DF8480A1-7492-4f45-AB78-1084642581FB}
GUID RegisterReservedGuid = { 0xdf8480a1, 0x7492, 0x4f45, 0xab, 0x78, 0x10, 0x84, 0x64, 0x25, 0x81, 0xfb };

HANDLE EtwpDeviceHandle = NULL;

VOID
EtwpCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    );

VOID
EtwpCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    );

VOID
EtwpFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpCheckForEnoughFreeSpace(
    PWCHAR FullLogFileName,
    ULONG  FullLogFileNameLen,
    ULONG  MaxFileSizeSpecified,
    ULONG  AppendMode,
    ULONG  UseKBytes
    );

ULONG
WMIAPI
EtwUnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );


VOID
EtwpFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This function resets the LoggerName.Buffer and LogFileName.Buffer 
    pointers based on the Overall size of the structure and the individual 
    lengths of the two strings. 

    Assumptions: WMI_LOGGER_INFORMATION structure is laid out as follows. 


         WMI_LOGGER_INFORMATION
        +----------------------+
        | Wnode.BufferSize ----|--------> size of the entire block including 
        |                      |          the two strings. 
        |                      |
        |                      |
        |                      |
        |       ...            |
        |                      |    
        |                      |
        +----------------------+
        | LoggerName.Length    |
        | LoggerName.MaxLength |
        | LoggerName.Buffer----|----+
        |                      |    |
        +----------------------+    |
        | LogFileName.Length   |    |
        | LogFileName.MaxLength|    |
  +-----|-LogFileName.Buffer   |    |
  |     +----------------------+    |
  |     |        ...           |    |
  |     |                      |    |
  |     +----------------------+<---+ Offset = sizeof(WMI_LOGGER_INFORMATION)
  |     |                      |
  |     | LoggerName String    |
  |     |                      |
  +---->+----------------------+<---- Offset += LoggerName.MaximumLength
        |                      |
        | LogFileName String   |
        |                      |
        +----------------------+

Arguments:

    LoggerInfo      Logger Information Structure

Return Value:

    No return value. 

--*/
{
    ULONG Offset = sizeof(WMI_LOGGER_INFORMATION);
    ULONG LoggerInfoSize;

    if (LoggerInfo == NULL)
        return;

    LoggerInfoSize = LoggerInfo->Wnode.BufferSize;

    if (LoggerInfoSize <= Offset)
        return;

    //
    // Fixup LoggerName first
    //

    if (LoggerInfo->LoggerName.Length > 0) {
        LoggerInfo->LoggerName.Buffer = (PWCHAR) ((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LoggerName.MaximumLength;
    }

    if (LoggerInfoSize <= Offset) 
        return;

    if (LoggerInfo->LogFileName.Length > 0) {
        LoggerInfo->LogFileName.Buffer = (PWCHAR)((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LogFileName.MaximumLength;
    }

#ifdef DBG
    EtwpAssert(LoggerInfoSize >= Offset);
#endif
}

ULONG
EtwpCheckForEnoughFreeSpace(
    PWCHAR FullLogFileName,
    ULONG  FullLogFileNameLen,
    ULONG  MaxFileSizeSpecified,
    ULONG  AppendMode,
    ULONG  UseKBytes
    )
{
    ULONG NeededSpace = MaxFileSizeSpecified;
    ULONG SizeNeeded;
    UINT ReturnedSizeNeeded;
    PWCHAR strLogFileDir = NULL;
    WCHAR strSystemDir[MAX_PATH];

    if (NeededSpace && AppendMode) {
        ULONG Status;
        WIN32_FILE_ATTRIBUTE_DATA FileAttributes;
        ULONGLONG ExistingFileSize;
        ULONG ExistingFileSizeInMBytes, ExistingFileSizeInKBytes;
        if (EtwpGetFileAttributesExW(FullLogFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)(&FileAttributes))) {

            ExistingFileSize = (((ULONGLONG)FileAttributes.nFileSizeHigh) << 32)
                             + FileAttributes.nFileSizeLow;
            ExistingFileSizeInMBytes = (ULONG)(ExistingFileSize / (1024 * 1024));
            ExistingFileSizeInKBytes = (ULONG)(ExistingFileSize / 1024);
            if (!UseKBytes) {
                if (ExistingFileSizeInMBytes >= NeededSpace) {
                    return ERROR_DISK_FULL;
                }
                else {
                    NeededSpace -= ExistingFileSizeInMBytes;
                }
            }
            else {
                if (ExistingFileSizeInKBytes >= NeededSpace) {
                    return ERROR_DISK_FULL;
                }
                else {
                    NeededSpace -= ExistingFileSizeInKBytes;
                }
            }
        } 
        else { // GetFileAttributesExW() failed
            Status = EtwpGetLastError();
            // If the file is not found, advapi32.dll treats 
            // the case as EVENT_TRACE_FILE_MODE_NEWFILE
            // So, we will let it go here.
            if (ERROR_FILE_NOT_FOUND != Status) { 
                return Status;
            }
        }                       
    }

    RtlZeroMemory(&strSystemDir[0], sizeof(WCHAR) * MAX_PATH);

    ReturnedSizeNeeded = EtwpGetSystemDirectoryW(strSystemDir, MAX_PATH);
    if (ReturnedSizeNeeded == 0) {
        return EtwpGetLastError();
    }

    if (ReturnedSizeNeeded < 2 || FullLogFileNameLen < 2) {
        // This really cannot happen. 
        return ERROR_INVALID_PARAMETER;
    }
    if (FullLogFileName[1] == L':' && strSystemDir[1] == L':') {
        if (!_wcsnicmp(FullLogFileName, strSystemDir, 1)) {
            if (!UseKBytes) {
                if (ULONG_MAX - 200 < NeededSpace) {
                    // Addition may incur overflow
                    return ERROR_DISK_FULL;
                }
                NeededSpace += 200;
            }
            else { // Using KBytes
                if (ULONG_MAX - (200 * 1024) < NeededSpace) {
                    // Addition may incur overflow
                    return ERROR_DISK_FULL;
                }
                else {
                    NeededSpace += 200 * 1024;
                }
            }
        }
    }

    // Check for space only when we have to
    if (NeededSpace) {
        int i;
        ULARGE_INTEGER FreeBytesAvailable, TotalNumberOfBytes;
        ULONG FreeMegaBytes, FreeKiloBytes;

        strLogFileDir = EtwpAlloc((FullLogFileNameLen + 1) * sizeof(WCHAR));
        if (strLogFileDir == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcsncpy(strLogFileDir, FullLogFileName, FullLogFileNameLen);
        for (i = FullLogFileNameLen - 1; i >= 0; i--) {
            if (strLogFileDir[i] == L'\\' || strLogFileDir[i] == L'/') {
                strLogFileDir[i] = '\0';
                break;
            }
        }
        if (i < 0) {
            // This really cannot happen. 
            EtwpFree(strLogFileDir);
            strLogFileDir = NULL;
        }
        // it also works with network paths
        if (EtwpGetDiskFreeSpaceExW(strLogFileDir,
                               &FreeBytesAvailable,
                               &TotalNumberOfBytes,
                               NULL)) {
            FreeMegaBytes = (ULONG)(FreeBytesAvailable.QuadPart / (1024 *1024));
            FreeKiloBytes = (ULONG)(FreeBytesAvailable.QuadPart / 1024);
            EtwpFree(strLogFileDir);
            if (!UseKBytes && FreeMegaBytes < NeededSpace) {
                return ERROR_DISK_FULL;
            }
            else if (UseKBytes && FreeKiloBytes < NeededSpace) {
                return ERROR_DISK_FULL;
            }
        }
        else {
            EtwpFree(strLogFileDir);
            return EtwpGetLastError();
        }
    }

    return ERROR_SUCCESS;
}


ULONG
EtwpValidateLogFileMode(
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG IsLogFile
    )

/*++

Routine Description:

    This routine validates the LogFileMode field. Several combinations
    of mode are not allowed and this routine will trap all the invalid
    combinations. A similar check is made in the kernel in case anyone 
    tries to call the IOCTL_WMI* directly. 

Arguments:

    Properties      Logger properties. 

Return Value:

    The status of performing the action requested.

--*/

{
    //
    // 1. You need to specifiy either a LogFile or RealTimeMode
    // 
    if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        if (!IsLogFile) {
            return ERROR_BAD_PATHNAME;
        }
    }

    //
    // 2, RealTimeMode from a Process Private logger is not allowed
    //

    if ((Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
        (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // 3. We can not append to a circular or RealTimeMode
    //
    if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
        if (   (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
            || (Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // 4. For Preallocation, you must provide a LogFile and maximumSize. 
    //    Preallocation is not allowed with NEWFILE or ProcessPrivate. 
    //
    if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
        if (   (Properties->MaximumFileSize == 0)
            || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
            || (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
            || (!IsLogFile)) {
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // 5. For USE_KBYTES, we need a logfile and a non-zero maximum size
    //
    if (Properties->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
        if ((Properties->MaximumFileSize == 0) 
            || (!IsLogFile)) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // 6. Relogger is supported only with Private Logger
    //
    if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
        if (!(Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) 
            || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
            || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
            || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // 7. NewFile mode is not supported for CIRCULAR or ProcessPrivate. 
    //    It is not supported for Kernel Logger. You must specify a logfile
    //    and a maximum file size. 
    //

    if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
        if ((Properties->MaximumFileSize == 0) ||
            (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
            (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ||
            (IsLogFile != TRUE) ||
            (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) 
            // Kernel Logger cannot be in newfile mode
           ){
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // 8. Circular mode must specify a MaximumFileSize
    //

    if ( (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&  
         (Properties->MaximumFileSize == 0) ) {
         return ERROR_INVALID_PARAMETER;
    }

    return ERROR_SUCCESS;

}


ULONG
WMIAPI
EtwStartTraceA(
    OUT PTRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the ANSI version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ANSI_STRING AnsiString;
    ULONG IsLogFile;
    LPSTR CapturedName;
    ULONG SizeNeeded;
    ULONG LogFileNameLen, LoggerNameLen;
    PCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PCHAR FullPathName=NULL;
    ULONG FullPathNameSize = MAXSTR;
    ULONG RelogPropSize = 0;


    EtwpInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return EtwpSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        //
        // LoggerName is a Mandatory Parameter. Must provide space for it. 
        //
        LoggerNameLen = strlen(LoggerName);
        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + LoggerNameLen + 1;

        //
        // Rules for Kernel Logger Identification
        // 1. If the logger name is "NT Kernel Logger", it is the kernel logger,
        //    and the System GUID is copied as well.
        // 2. If the GUID is equal to the System GUID, but not the name, reject
        //    the session.
        //

        if (!strcmp(LoggerName, KERNEL_LOGGER_NAMEA)) {
            Properties->Wnode.Guid = SystemTraceControlGuid;
        }
        else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)){ 
            // LoggerName is not "NT Kernel Logger", but Guid is
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }

        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range. 
        //
        if (Properties->LoggerNameOffset > 0) 
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            ULONG RetValue;

            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = ((PCHAR)Properties + Properties->LogFileNameOffset );
            SizeNeeded += (strlen(LogFileName) + 1) * sizeof(CHAR);

Retry:
            FullPathName = EtwpAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }
            RetValue = EtwpGetFullPathNameA(LogFileName, 
                                            FullPathNameSize, 
                                            FullPathName, 
                                            NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    EtwpFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = strlen(LogFileName);
            if (LogFileNameLen == 0) 
                IsLogFile = FALSE;

        }
        else 
            IsLogFile = FALSE;

        //
        //  Check to see if there is room in the Properties structure
        //  to return both the InstanceName (LoggerName) and the LogFileName
        //
        // Note that we are only checking to see if there is room to return 
        // relative path name for logfiles. 
        //
            

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        CapturedName = (LPSTR) LoggerName;
        LoggerNameLen = strlen(CapturedName);

        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        ErrorCode = EtwpValidateLogFileMode(Properties, IsLogFile);
        if (ErrorCode  != ERROR_SUCCESS) {
            goto Cleanup;
        }

        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            PCHAR cptr = strchr(LogFileName, '%');
            if (NULL == cptr || cptr != strrchr(LogFileName, '%')) {
                ErrorCode = ERROR_INVALID_NAME;
                goto Cleanup;
            }

            else if (NULL == strstr(LogFileName, "%d")) {
                ErrorCode = ERROR_INVALID_NAME;
                goto Cleanup;
            }
        }

    // For UserMode logger the LoggerName and LogFileName must be
    // passed in as offsets. 

        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) +
                     (LoggerNameLen  + 1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

    //
    // If the EXTENSION bit is set on the EnableFlags, then we are passing
    // the extended flags. The size of the flags are given as Number of ULONGs
    // in the Length field of TRACE_ENABLE_FLAG_EXTENSION structure. 
    //
    // Check to see if the Properties structure has the right size for 
    // extended flags. 
    //

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0) ||
                (FlagExt->Offset < sizeof(EVENT_TRACE_PROPERTIES)) ||
                (FlagExt->Offset > Properties->Wnode.BufferSize) ||
                (FlagExt->Length * sizeof(ULONG) > Properties->Wnode.BufferSize
                                           - sizeof(EVENT_TRACE_PROPERTIES))) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            SizeNeeded += FlagExt->Length * sizeof(ULONG);
        }

        //
        // If RELOG mode, then pass on the LOGFILE_HEADER from old logfile
        // appended to the LOGGER_INFORMATION
        //

        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            PSYSTEM_TRACE_HEADER pSysHeader;
            pSysHeader = (PSYSTEM_TRACE_HEADER) 
                         ((PUCHAR)Properties + sizeof(EVENT_TRACE_PROPERTIES) );
            RelogPropSize = pSysHeader->Packet.Size;
            //
            // Before tagging on a structure at the end of user supplied strings
            // align it.  
            //
            
            SizeNeeded = ALIGN_TO_POWER2(SizeNeeded, 8);

            SizeNeeded += RelogPropSize;
        }

        SizeNeeded = ALIGN_TO_POWER2(SizeNeeded, 8);

        LoggerInfo = EtwpAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires Ansi strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        EtwpCopyPropertiesToInfo(
            (PEVENT_TRACE_PROPERTIES) Properties,
            LoggerInfo);

        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;


        RtlInitAnsiString(&AnsiString, CapturedName);

        LoggerInfo->LoggerName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LoggerNameLen + 1));
        LoggerInfo->LoggerName.Buffer =
                (LPWSTR) (  ((PUCHAR) LoggerInfo)
                          + sizeof(WMI_LOGGER_INFORMATION));
        Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName,
                    &AnsiString, FALSE);
        if (!NT_SUCCESS(Status)) {
            ErrorCode = EtwpNtStatusToDosError(Status);
            goto Cleanup;
        }

        if (IsLogFile) {
            LoggerInfo->LogFileName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LogFileNameLen + 1));
            LoggerInfo->LogFileName.Buffer =
                    (LPWSTR) (  ((PUCHAR) LoggerInfo)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + LoggerInfo->LoggerName.MaximumLength);

            RtlInitAnsiString(&AnsiString, LogFileName);
            Status = RtlAnsiStringToUnicodeString(
                        &LoggerInfo->LogFileName,
                        &AnsiString, FALSE);

            if (!NT_SUCCESS(Status)) {
                ErrorCode = EtwpNtStatusToDosError(Status);
                goto Cleanup;
            }

            Status = EtwpCheckForEnoughFreeSpace(
                             LoggerInfo->LogFileName.Buffer,
                             LogFileNameLen, 
                             Properties->MaximumFileSize,
                             (Properties->LogFileMode & 
                              EVENT_TRACE_FILE_MODE_APPEND),
                             (Properties->LogFileMode & 
                              EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                            );
            if (Status != ERROR_SUCCESS) {
                ErrorCode = Status;
                goto Cleanup;
            }
        }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }

        if ( (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) &&
             (RelogPropSize > 0) )  {
            PSYSTEM_TRACE_HEADER pRelog, pSysHeader;
            PTRACE_LOGFILE_HEADER Relog;
            ULONG Offset;

            Offset = sizeof(WMI_LOGGER_INFORMATION) +
                     LoggerInfo->LoggerName.MaximumLength +
                     LoggerInfo->LogFileName.MaximumLength;

            Offset = ALIGN_TO_POWER2( Offset, 8 );

            pRelog = (PSYSTEM_TRACE_HEADER) ( ((PUCHAR) LoggerInfo) + Offset);

            pSysHeader =  (PSYSTEM_TRACE_HEADER) ( (PUCHAR)Properties + 
                          sizeof(EVENT_TRACE_PROPERTIES) );

            RtlCopyMemory(pRelog, pSysHeader, RelogPropSize);
        }


        ErrorCode = EtwpStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PCHAR pLoggerName, pLogFileName;

            EtwpCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            if (Properties->LoggerNameOffset == 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            
            pLoggerName = (PCHAR)((PCHAR)Properties + 
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            RequiredLength = strlen(CapturedName) + 1;
            if (RequiredLength <= AvailableLength) {
                StringCchCopyA(pLoggerName, AvailableLength, CapturedName);
            }
            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            // 
            // If there is room copy fullpath name
            //
            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            if ( (LogFileNameLen > 0) && (AvailableLength >= LogFileNameLen) ) {

                pLogFileName = (PCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

                StringCchCopyA(pLogFileName, AvailableLength, LogFileName);

            }
        }
    }


    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = EtwpNtStatusToDosError( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)     
        EtwpFree(LoggerInfo);
    if (FullPathName != NULL)   
        EtwpFree(FullPathName);

    return EtwpSetDosError(ErrorCode);
}

ULONG
WMIAPI
EtwStartTraceW(
    OUT    PTRACEHANDLE            LoggerHandle,
    IN     LPCWSTR                 LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the Unicode version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ULONG  IsLogFile;
    LPWSTR CapturedName;
    ULONG  SizeNeeded;
    USHORT LogFileNameLen, LoggerNameLen;
    PWCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PWCHAR FullPathName = NULL;
    ULONG FullPathNameSize = MAXSTR;
    ULONG RetValue;
    ULONG RelogPropSize = 0;


    EtwpInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return EtwpSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        // LoggerName is a Mandatory Parameter. Must provide space for it.
        //
        CapturedName = (LPWSTR) LoggerName;
        LoggerNameLen =  (USHORT) wcslen(CapturedName);

        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + 
                     (LoggerNameLen + 1) * sizeof(WCHAR);
        //
        // Rules for Kernel Logger Identification
        // 1. If the logger name is "NT Kernel Logger", it is the kernel logger,
        //    and the System GUID is copied as well.
        // 2. If the GUID is equal to the System GUID, but not the name, reject
        //    the session.
        //

        if (!wcscmp(LoggerName, KERNEL_LOGGER_NAMEW)) {
            Properties->Wnode.Guid = SystemTraceControlGuid;
        }
        else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)){ 
            // LoggerName is not "NT Kernel Logger", but Guid is
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }

        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0)
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = (PWCHAR)((char*)Properties + 
                              Properties->LogFileNameOffset);
            SizeNeeded += (wcslen(LogFileName) +1) * sizeof(WCHAR);

Retry:
            FullPathName = EtwpAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }

            RetValue = EtwpGetFullPathNameW(LogFileName, 
                                            FullPathNameSize, 
                                            FullPathName,
                                            NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    EtwpFree(FullPathName);
                    FullPathNameSize =  RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = (USHORT) wcslen(LogFileName);
            if (LogFileNameLen <= 0)
                IsLogFile = FALSE;
        }
        else 
            IsLogFile = FALSE;

        //
        // Check to see if there is room for both LogFileName and
        // LoggerName (InstanceName) to be returned
        //

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        LoggerNameLen = (USHORT) wcslen(CapturedName);
        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        ErrorCode = EtwpValidateLogFileMode(Properties, IsLogFile);
        if (ErrorCode != ERROR_SUCCESS) {
            goto Cleanup;
        }

        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            PWCHAR wcptr = wcschr(LogFileName, L'%');
            if (NULL == wcptr || wcptr != wcsrchr(LogFileName, L'%')) {
                ErrorCode = ERROR_INVALID_NAME;
                goto Cleanup;
            }
            
            else if (NULL == wcsstr(LogFileName, L"%d")) {
                ErrorCode = ERROR_INVALID_NAME;
                goto Cleanup;
            }
        }

        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 
                     (LoggerNameLen +1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0) ||
                (FlagExt->Offset < sizeof(EVENT_TRACE_PROPERTIES)) ||
                (FlagExt->Offset > Properties->Wnode.BufferSize) ||
                (FlagExt->Length * sizeof(ULONG) > Properties->Wnode.BufferSize
                - sizeof(EVENT_TRACE_PROPERTIES))) 
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            SizeNeeded += FlagExt->Length * sizeof(ULONG);            
        }

        //
        // If RELOG mode, then pass on the LOGFILE_HEADER from old logfile 
        // appended to the LOGGER_INFORMATION
        //

        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            PSYSTEM_TRACE_HEADER pSysHeader;
            pSysHeader = (PSYSTEM_TRACE_HEADER)((PUCHAR)Properties + 
                                               sizeof(EVENT_TRACE_PROPERTIES) );
            RelogPropSize = pSysHeader->Packet.Size;
            //
            // Need to align due to strings
            //
            SizeNeeded = ALIGN_TO_POWER2(SizeNeeded, 8);

            SizeNeeded += RelogPropSize;
        }

        SizeNeeded = ALIGN_TO_POWER2(SizeNeeded, 8);
        LoggerInfo = EtwpAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires wide char strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        EtwpCopyPropertiesToInfo(Properties, LoggerInfo);
        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;

        LoggerInfo->LoggerName.MaximumLength =
                sizeof(WCHAR) * (LoggerNameLen + 1);
        LoggerInfo->LoggerName.Length =
                sizeof(WCHAR) * LoggerNameLen;
        LoggerInfo->LoggerName.Buffer = (PWCHAR)
                (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
        wcsncpy(LoggerInfo->LoggerName.Buffer, LoggerName, LoggerNameLen);

        if (IsLogFile) {
            ULONG Status;

            LoggerInfo->LogFileName.MaximumLength =
                    sizeof(WCHAR) * (LogFileNameLen + 1);
            LoggerInfo->LogFileName.Length =
                    sizeof(WCHAR) * LogFileNameLen;
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                    (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                   + LoggerInfo->LoggerName.MaximumLength);
            wcsncpy(LoggerInfo->LogFileName.Buffer,
                    LogFileName,
                    LogFileNameLen);

            Status = EtwpCheckForEnoughFreeSpace(
                                LoggerInfo->LogFileName.Buffer, 
                                LogFileNameLen, 
                                Properties->MaximumFileSize,
                                (Properties->LogFileMode & 
                                 EVENT_TRACE_FILE_MODE_APPEND),
                                (Properties->LogFileMode & 
                                 EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                                );
            if (Status != ERROR_SUCCESS) {
                ErrorCode = Status;
                goto Cleanup;
            }
       }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }
        if ( (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) &&
             (RelogPropSize > 0) )  {
            PSYSTEM_TRACE_HEADER pRelog, pSysHeader;
            PTRACE_LOGFILE_HEADER Relog;
            ULONG Offset;

            Offset = sizeof(WMI_LOGGER_INFORMATION) +
                     LoggerInfo->LoggerName.MaximumLength +
                     LoggerInfo->LogFileName.MaximumLength;

            Offset = ALIGN_TO_POWER2(Offset, 8);

            pRelog = (PSYSTEM_TRACE_HEADER) ( ((PUCHAR) LoggerInfo) +  Offset);

            pSysHeader =  (PSYSTEM_TRACE_HEADER) ( 
                                                  (PUCHAR)Properties + 
                                                  sizeof(EVENT_TRACE_PROPERTIES)
                                                 );

            RtlCopyMemory(pRelog, pSysHeader, RelogPropSize);

        }

        ErrorCode = EtwpStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PWCHAR pLoggerName;
            PWCHAR pLogFileName;

            EtwpCopyInfoToProperties(LoggerInfo, Properties);
            if (Properties->LoggerNameOffset > 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            pLoggerName = (PWCHAR)((PCHAR)Properties +
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;


            RequiredLength = (wcslen(CapturedName) + 1) * sizeof(WCHAR);
            if (RequiredLength <= AvailableLength) {
               StringCbCopyW(pLoggerName,  AvailableLength, CapturedName);
            }

            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;


            RequiredLength = LoggerInfo->LogFileName.Length;

            pLogFileName = (PWCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

            if ( (RequiredLength > 0) &&  (RequiredLength <= AvailableLength) ) {
                wcsncpy(pLogFileName, 
                        LoggerInfo->LogFileName.Buffer, 
                        LogFileNameLen
                       );
                pLogFileName[LogFileNameLen] = L'\0';
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = EtwpNtStatusToDosError( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)
        EtwpFree(LoggerInfo);
    if (FullPathName != NULL)
        EtwpFree(FullPathName);
    return EtwpSetDosError(ErrorCode);
}

ULONG
WMIAPI
EtwControlTraceA(
    IN TRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH   - to flush the logger

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    ULONG ErrorCode;

    BOOLEAN IsKernelTrace = FALSE;
    BOOLEAN bFreeString = FALSE;
    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PCHAR                   FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   FullPathNameSize = MAXSTR;
    ULONG                   RetValue;
    PTRACE_ENABLE_CONTEXT   pContext;
    ANSI_STRING String;
     

    EtwpInitProcessHeap();

    RtlZeroMemory(&String, sizeof(ANSI_STRING));

    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    try {
        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //
        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (LoggerName != NULL) {
            LoggerNameLen = strlen(LoggerName) + 1;
            //
            // Rules for Kernel Logger Identification when a string is given 
            // instead of handle
            // 1. If the logger name is "NT Kernel Logger", it is the 
            //    kernel logger, and the System GUID is copied as well.
            // 2. If the GUID is equal to the System GUID, but not the name, 
            //    reject the session.
            // 3. If the logger name is null or of size 0, and the GUID is 
            //    equal to the System GUID, let it proceed as the kernel logger.
            //
            if (!strcmp(LoggerName, KERNEL_LOGGER_NAMEA)) {
                Properties->Wnode.Guid = SystemTraceControlGuid;
            }
            else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) { 
                // LoggerName is not "NT Kernel Logger", but Guid is
                if (strlen(LoggerName) > 0) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }
        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            IsKernelTrace = TRUE;
        }
        if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            if ((LoggerName == NULL) || (strlen(LoggerName) <= 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        //
        // We do not support UpdateTrace to a new file with APPEND mode
        //

        if ( (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) &&
             (Control == EVENT_TRACE_CONTROL_UPDATE) &&
             (Properties->LogFileNameOffset > 0) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        
/*
        if (LoggerHandle != 0) {
            pContext = (PTRACE_ENABLE_CONTEXT) &LoggerHandle;
            if (   (pContext->InternalFlag != 0) &&
               (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
            // Currently only one possible InternalFlag value. This will filter
            // out some bogus LoggerHandle
            //
                return EtwpSetDosError(ERROR_INVALID_HANDLE);
            }
        }
*/
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:
    // Extra 32 bytes for UMlogger to append instance name to logfilename. 
    LogFileNameLen += 16;
    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 
                 (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);
    sizeNeeded = ALIGN_TO_POWER2(sizeNeeded, 8);
    LoggerInfo = (PWMI_LOGGER_INFORMATION) EtwpAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    EtwpInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    EtwpInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));

    // Look for logger name first
    //
    try {
        if (LoggerName != NULL) {
            if (strlen(LoggerName) > 0) {
                ANSI_STRING AnsiString;

                RtlInitAnsiString(&AnsiString, LoggerName);
                Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName, &AnsiString, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = EtwpNtStatusToDosError(Status);
                    goto Cleanup;
                }
            }
        }

//        InitString up above already does this. 
//        LoggerInfo->LogFileName.Buffer = (PWCHAR)
//                (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
//                        + LoggerInfo->LoggerName.MaximumLength);
//
        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            PCHAR  strLogFileNameA;

            strLogFileNameA = (PCHAR) (  ((PCHAR) Properties)
                                      + Properties->LogFileNameOffset);
Retry:
            FullPathName = EtwpAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            RetValue = EtwpGetFullPathNameA(strLogFileNameA, 
                                            FullPathNameSize, 
                                            FullPathName, 
                                            NULL); 
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    EtwpFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileNameA = FullPathName;
                }
            }

            lenLogFileName = strlen(strLogFileNameA);
            if (lenLogFileName > 0) {
                ANSI_STRING ansiLogFileName;

                RtlInitAnsiString(& ansiLogFileName, strLogFileNameA);
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));

                Status = RtlAnsiStringToUnicodeString(
                        & LoggerInfo->LogFileName, & ansiLogFileName, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = EtwpNtStatusToDosError(Status);
                    goto Cleanup;
                }
            }
        }
        // stuff the loggerhandle in Wnode
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers the Guid is required to  determine the provider
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;
        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = EtwpQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = EtwpStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            EtwpCopyPropertiesToInfo((PEVENT_TRACE_PROPERTIES) Properties,
                                     LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
            ErrorCode = EtwpQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = EtwpFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry 
    // with sufficient buffer space for the two strings. The size required 
    // is returned in the MaximuumLength field. 
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / 
                             sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / 
                             sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                EtwpFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                EtwpFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }


        //
        // The Kernel call succeeded. Now we need to get the output and 
        // pass it back to the caller. This is complicated by the fact that 
        // WMI_LOGGER_INFORMATION structure uses pointers instead of offsets. 
        //

        if (ErrorCode == ERROR_SUCCESS) {
            PCHAR pLoggerName, pLogFileName;
            ULONG BytesAvailable;
            ULONG Length = 0;

            EtwpCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            //
            // need to convert the strings back
            //
            EtwpFixupLoggerStrings(LoggerInfo);

            //
            // Now we need to copy the strings into Properties structure after
            // converting them to ANSI strings
            //

            if (Properties->LoggerNameOffset == 0) 
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset > Properties->LogFileNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                BytesAvailable =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            Status = RtlUnicodeStringToAnsiString(
                                &String, &LoggerInfo->LoggerName, TRUE);

            if (NT_SUCCESS(Status)) {
                bFreeString = TRUE;
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                                             Length  +
                                             LoggerInfo->LogFileName.Length + 
                                             2 * sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PCHAR) ((PCHAR)Properties +
                                Properties->LoggerNameOffset);
                    RtlZeroMemory(pLoggerName, BytesAvailable);
                    if (Length > 0) {
                        strncpy(pLoggerName, String.Buffer, Length);
                    }
                    // 
                    // Though the RtlZeroMemory above and the BytesAvailable
                    // takes care of this, we want to be explicit about 
                    // null terminating this string
                    //
                    pLoggerName[Length] = '\0';

                }
                ErrorCode = RtlNtStatusToDosError(Status);
            }

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset + 
                                                Length + sizeof(CHAR);
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            RtlFreeAnsiString(&String);
            bFreeString = FALSE;
            Status = RtlUnicodeStringToAnsiString(
                                    &String, &LoggerInfo->LogFileName, TRUE);

            if (NT_SUCCESS(Status)) {
                bFreeString = TRUE;
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = (Properties->Wnode.BufferSize - 
                                              BytesAvailable) + 
                                              Length + 
                                              sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {
                    pLogFileName = (PCHAR) ((PCHAR)Properties +
                                            Properties->LogFileNameOffset  
                                           );
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    strncpy(pLogFileName, String.Buffer, Length );
                }
                ErrorCode = RtlNtStatusToDosError(Status);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = EtwpNtStatusToDosError(GetExceptionCode());
    }

Cleanup:
    if (bFreeString) 
        RtlFreeAnsiString(&String);
    if (LoggerInfo != NULL)
        EtwpFree(LoggerInfo);
    if (FullPathName != NULL) 
        EtwpFree(FullPathName);
    return EtwpSetDosError(ErrorCode);
}

ULONG
WMIAPI
EtwControlTraceW(
    IN TRACEHANDLE LoggerHandle,
    IN LPCWSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH     - to flush the logger

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode;
    BOOLEAN IsKernelTrace = FALSE;

    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PWCHAR                  FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   RetValue;
    PTRACE_ENABLE_CONTEXT   pContext;

    EtwpInitProcessHeap();
    
    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    try {
        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (LoggerName != NULL) {
            LoggerNameLen = wcslen(LoggerName) + 1;
            //
            // Rules for Kernel Logger Identification when a string is given 
            // instead of handle
            // 1. If the logger name is "NT Kernel Logger", it is the 
            //    kernel logger, and the System GUID is copied as well.
            // 2. If the GUID is equal to the System GUID, but not the name, 
            //    reject the session.
            // 3. If the logger name is null or of size 0, and the GUID is 
            //    equal to the System GUID, let it proceed as the kernel logger.
            //
            if (!wcscmp(LoggerName, KERNEL_LOGGER_NAMEW)) {
                Properties->Wnode.Guid = SystemTraceControlGuid;
            }
            else if (IsEqualGUID(&Properties->Wnode.Guid, 
                                 &SystemTraceControlGuid)) { 
                // LoggerName is not "NT Kernel Logger", but Guid is
                if (wcslen(LoggerName) > 0) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }
        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            IsKernelTrace = TRUE;
        }
        if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            if ((LoggerName == NULL) || (wcslen(LoggerName) <= 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        //
        // We do not support UpdateTrace to a new file with APPEND mode
        //

        if ( (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) &&
             (Control == EVENT_TRACE_CONTROL_UPDATE) &&
             (Properties->LogFileNameOffset > 0) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // If LoggerHandle is supplied, check to see if it valid
        //
/*
        if (LoggerHandle != 0) {
            pContext = (PTRACE_ENABLE_CONTEXT) &LoggerHandle;

            if ((pContext->InternalFlag != 0) &&
               (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
            // Currently only one possible InternalFlag value. This will filter
            // out some bogus LoggerHandle
            //
                return EtwpSetDosError(ERROR_INVALID_HANDLE);
            }
        }
*/
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:
    //
    // Add an extra 16 characters to the LogFileName since the UMLogger 
    // could munge the name to add the PIDs at the end. 
    //
    LogFileNameLen += 16;
    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 
                 (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);

    sizeNeeded = ALIGN_TO_POWER2(sizeNeeded, 8);
    LoggerInfo = (PWMI_LOGGER_INFORMATION) EtwpAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    EtwpInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    EtwpInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));
    try {
        if (LoggerName != NULL) {
            if (wcslen(LoggerName) > 0) {
                StringCchCopyW(strLoggerName, LoggerNameLen, LoggerName);
                RtlInitUnicodeString(&LoggerInfo->LoggerName, strLoggerName);
            }
        }
        
        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            ULONG FullPathNameSize = MAXSTR;

            strLogFileName = (PWCHAR) (  ((PCHAR) Properties)
                                       + Properties->LogFileNameOffset);

Retry:
            FullPathName = EtwpAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            RetValue = EtwpGetFullPathNameW(strLogFileName, 
                                            FullPathNameSize, 
                                            FullPathName, 
                                            NULL
                                            );
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    EtwpFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileName = FullPathName;
                }
            }

            lenLogFileName = wcslen(strLogFileName);
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                        (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                + LoggerInfo->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));
                LoggerInfo->LogFileName.Length =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName));
                wcsncpy(LoggerInfo->LogFileName.Buffer,
                        strLogFileName,
                        lenLogFileName);
            }
            else {
                LoggerInfo->LogFileName.Length = 0;
                LoggerInfo->LogFileName.MaximumLength = MAXSTR * sizeof(WCHAR);
            }
        }

        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers, the Guid must be supplied
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;

        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = EtwpQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = EtwpStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            EtwpCopyPropertiesToInfo(Properties, LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            ErrorCode = EtwpQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = EtwpFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry
    // with sufficient buffer space for the two strings. The size required
    // is returned in the MaximuumLength field.
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / 
                             sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / 
                             sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                EtwpFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                EtwpFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }
    
        if (ErrorCode == ERROR_SUCCESS) {
            ULONG Length = 0;
            ULONG BytesAvailable = 0;
            PWCHAR pLoggerName, pLogFileName;

            EtwpCopyInfoToProperties(LoggerInfo, Properties);

            EtwpFixupLoggerStrings(LoggerInfo);

            if (Properties->LoggerNameOffset == 0)
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset ) 
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else 
                BytesAvailable =  Properties->LogFileNameOffset - 
                                  Properties->LoggerNameOffset;
            Length = LoggerInfo->LoggerName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR) )) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                                             Length + 
                                             LoggerInfo->LogFileName.Length + 
                                             2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PWCHAR) ((PCHAR)Properties + 
                                                Properties->LoggerNameOffset);
                    RtlZeroMemory(pLoggerName, BytesAvailable);
                    wcsncpy(pLoggerName, 
                            LoggerInfo->LoggerName.Buffer, 
                            Length/2 );
                    pLoggerName[Length/2] = L'\0';
                }
            }

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                                Length + sizeof(WCHAR);
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            //
            // Check for space to return LogFileName. 
            //
            Length = LoggerInfo->LogFileName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) +
                                             Length + 
                                             LoggerInfo->LogFileName.Length + 
                                             2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {

                    pLogFileName = (PWCHAR) ((PCHAR)Properties +
                                             Properties->LogFileNameOffset);
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    wcsncpy(pLogFileName, 
                            LoggerInfo->LogFileName.Buffer, Length/2 );
                    pLogFileName[Length/2] = L'\0';
               }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = EtwpNtStatusToDosError(GetExceptionCode());
    }

Cleanup:
    if (LoggerInfo != NULL)
        EtwpFree(LoggerInfo);
    if (FullPathName != NULL)
        EtwpFree(FullPathName);

    return EtwpSetDosError(ErrorCode);
}



ULONG 
EtwpEnableDisableKernelTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag
    )
{
    ULONG status;
    PWMI_LOGGER_INFORMATION pLoggerInfo;
    ULONG Flags;
    GUID Guid;
    ULONG SizeNeeded = 0;
    ULONG RetryCount = 1;
    WMITRACEENABLEDISABLEINFO TraceEnableInfo;
    ULONG ReturnSize;


    //
    // We need to query the kernel logger to find the current flags 
    // and construct the new flags to update with. 
    //


    SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 2 * MAXSTR * sizeof(WCHAR);

    SizeNeeded = ALIGN_TO_POWER2(SizeNeeded, 8);

    pLoggerInfo = EtwpAlloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    RtlZeroMemory(pLoggerInfo, SizeNeeded);
    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Guid   = SystemTraceControlGuid;
    pLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
    WmiSetLoggerId(KERNEL_LOGGER_ID, &pLoggerInfo->Wnode.HistoricalContext);

    status = EtwpQueryLogger(pLoggerInfo, FALSE);
    if (status != ERROR_SUCCESS) {
        EtwpFree(pLoggerInfo);
        return EtwpSetDosError(status);
    }

    Flags = pLoggerInfo->EnableFlags;
    //
    // If Enabling, we need to pass down the final state of the flags
    // ie., the old flags plus the new flags.
    // If disabling, we need to pass down the only the flags that
    // are already turned on and being turned off now.
    //
    if (Enable) {
        Flags |= EnableFlag;
    }
    else {
        Flags &= EnableFlag;
    }

    //
    // At this point if the Flags are 0, then no change is being
    // requested.
    //

    if (Flags) {
        pLoggerInfo->EnableFlags = Flags;
        status = EtwpQueryLogger(pLoggerInfo, TRUE);
    }
    EtwpFree(pLoggerInfo);
    return EtwpSetDosError(status);

}


ULONG
WMIAPI
EtwEnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    )
{
    ULONG status;
    PTRACE_ENABLE_CONTEXT pTraceHandle = (PTRACE_ENABLE_CONTEXT)&TraceHandle;
    GUID Guid;
    WMITRACEENABLEDISABLEINFO TraceEnableInfo;
    ULONG ReturnSize;

    EtwpInitProcessHeap();

    // We only accept T/F for Enable code. In future, we really should take
    // enumerated request codes. Declaring the Enable as ULONG instead
    // of BOOLEAN should give us room for expansion.

    if ( (ControlGuid == NULL) 
         || (EnableLevel > 255) 
         || ((Enable != TRUE) && (Enable != FALSE)) 
         || (TraceHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE) 
         || (TraceHandle == (TRACEHANDLE)0 ) ) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }
    try {
        Guid = *ControlGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return EtwpSetDosError(ERROR_NOACCESS);
    }

    //
    // If this is for the Kernel Logger, we need to actually make 
    // an UpdateTrace call 
    //

    if ( IsEqualGUID(&SystemTraceControlGuid, &Guid) ) {
        status = EtwpEnableDisableKernelTrace(Enable, EnableFlag);
    }
    else {

        pTraceHandle->Level = (UCHAR)EnableLevel;
        pTraceHandle->EnableFlags = EnableFlag;

        //
        // For Non-Kernel Providers, simply call the  WMI IOCTL
        //

        RtlZeroMemory(&TraceEnableInfo, sizeof(WMITRACEENABLEDISABLEINFO) );

        TraceEnableInfo.Guid = Guid;
        TraceEnableInfo.Enable = (BOOLEAN)Enable;
        TraceEnableInfo.LoggerContext = TraceHandle;

        status =  EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENABLE_DISABLE_TRACELOG,
                                      &TraceEnableInfo,
                                      sizeof(WMITRACEENABLEDISABLEINFO),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);
    }

    return EtwpSetDosError(status);

}



ULONG
EtwpTraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PWNODE_HEADER Wnode
    )
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    PEVENT_TRACE_HEADER EventTrace = (PEVENT_TRACE_HEADER)Wnode;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;
    ULONG Status;

    Wnode->HistoricalContext = LoggerHandle;
    if ( (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) && 
         (EtwpIsBBTOn == 0) ) {
        Status = EtwpTraceUmEvent(Wnode);
        return EtwpSetDosError(Status);
    }

    //
    // Not a process private logger event. It is going to the kernel.
    //

    Size = EventTrace->Size;
    //
    // Now the LoggerHandle is expected to be filled in by the caller.
    // But check to see if it has a valid value.
    //

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
         return ERROR_INVALID_HANDLE;
    }
    //
    // When BBT buffers are active, we override all user mode logging
    // to log to this one stream (Global Logger). 
    //

    if (EtwpIsBBTOn) {
        WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &Wnode->HistoricalContext);
    }

	NtStatus = NtTraceEvent(NULL,
                            ETW_NT_FLAGS_TRACE_HEADER,
                            sizeof(WNODE_HEADER),
                            Wnode);

	return EtwpNtStatusToDosError( NtStatus );

}


ULONG 
WMIAPI
EtwTraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    )
/*++

Routine Description:

    This is the main entry point for logging events from user mode. The caller
    must supply the LoggerHandle and a pointer to the evnet being logged. 

    This routine needs to make sure that the contents of the EventTrace 
    record are restored back to the way caller sent it. (Internally, they 
    are modified but restored before return). 


Arguments:

    LoggerHandle    The handle to the logger instance.

    EventTrace      Pointer to the Event being logged. 


Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status, SavedMarker;
    PULONG TraceMarker;
    ULONG Size;
    ULONGLONG SavedGuidPtr;
    BOOLEAN RestoreSavedGuidPtr = FALSE;
    ULONG Flags;

    EtwpInitProcessHeap();
    
    if (EventTrace == NULL ) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        TraceMarker = (PULONG) EventTrace;
        SavedMarker = *TraceMarker;

        Flags = EventTrace->Flags;

        EventTrace->Flags |= WNODE_FLAG_TRACED_GUID; 
        
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_TRACE_HEADER)) {
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        *TraceMarker = 0;
        EventTrace->Size = (USHORT)Size;
        
        *TraceMarker |= TRACE_HEADER_FULL;

        if (EventTrace->Flags & WNODE_FLAG_USE_GUID_PTR) {
            RestoreSavedGuidPtr = TRUE;
            SavedGuidPtr = EventTrace->GuidPtr;
        }
        Status = EtwpTraceEvent(LoggerHandle, (PWNODE_HEADER) EventTrace);
        *TraceMarker = SavedMarker;
        EventTrace->Flags = Flags;
        if (RestoreSavedGuidPtr) {
            EventTrace->GuidPtr = SavedGuidPtr;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError( GetExceptionCode() );
    }

    return EtwpSetDosError(Status);
}



ULONG
WMIAPI
EtwTraceEventInstance(
    IN TRACEHANDLE  LoggerHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    )
/*++

Routine Description:

    This routine logs an event with its instance information. The caller
    must supply the LoggerHandle, the Event to log and the Instance info. 
    Optionally, the cally may specify the Parent Instance info. 

    This routine needs to make sure that the contents of the EventTrace
    record are restored back to the way caller sent it. (Internally, they
    are modified but restored before return).


    EVENT_INSTANCE_HEADER contains pointer for Guid and ParentGuid. In W2K,
    this record is logged with the pointers and later decoded to Guids during
    post processing using the GuidMaps dumped in the logfile. 
    
    For WinXP and above, we no longer use the GuidMaps. We convert the 
    EVENT_INSTANCE_HEADER to larger sized EVENT_INSTANCE_GUID_HEADER with the
    Guids already translated. There is no decoding needed during postprocessing
    as a result. 


Arguments:

    LoggerHandle    The handle to the logger instance.

    EventTrace      Pointer to the Event being logged.

    pInstInfo       Pointer to Instance Information
   
    pParentInfo     Pointer to Parent's Instance Information


Return Value:

    The status of performing the action requested.

--*/
{
    PULONG TraceMarker;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG Size, MofSize;
    ULONG Flags;
    PEVENT_INSTANCE_HEADER InstanceHeader= (PEVENT_INSTANCE_HEADER) EventTrace;
    PEVENT_INSTANCE_GUID_HEADER InstanceGuidHeader;
    ULONG Status;

    struct { // This is the same structure as _EVENT_TRACE defined in evntrace.h
        EVENT_INSTANCE_GUID_HEADER  NewInstanceHeader;
        MOF_FIELD                   MofField[MAX_MOF_FIELDS];
    } InstanceEventTrace;

    EtwpInitProcessHeap();
    
    if ((EventTrace == NULL ) || (pInstInfo == NULL)) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        InstanceGuidHeader = &(InstanceEventTrace.NewInstanceHeader);
        Flags = EventTrace->Flags;
        TraceMarker = (PULONG)(InstanceGuidHeader);
        Flags |= WNODE_FLAG_TRACED_GUID; 
        
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_INSTANCE_HEADER)) {
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        // Copy the contents of the instance header to the new structure.
        RtlCopyMemory(InstanceGuidHeader, 
                      InstanceHeader, 
                      FIELD_OFFSET(EVENT_INSTANCE_HEADER, ParentRegHandle)
                     );
        
        *TraceMarker = 0;     
        *TraceMarker |= TRACE_HEADER_INSTANCE;

        //
        // With EVENT_INSTANCE_HEADER we don't want the logger
        // to try to dereference the GuidPtr since it is
        // just a hash value for the Guid and not really a LPGUID.
        //

        if (InstanceGuidHeader->Flags & WNODE_FLAG_USE_GUID_PTR) {
            InstanceGuidHeader->Flags  &= ~WNODE_FLAG_USE_GUID_PTR;
        }

        GuidMapEntry =  (PGUIDMAPENTRY) pInstInfo->RegHandle;
        if (GuidMapEntry == NULL) {
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        
        InstanceGuidHeader->InstanceId = pInstInfo->InstanceId;


        // Newly added line for copying GUID
        InstanceGuidHeader->Guid = GuidMapEntry->Guid;

        if (pParentInstInfo != NULL) {
            GuidMapEntry =  (PGUIDMAPENTRY) pParentInstInfo->RegHandle;
            if (GuidMapEntry == NULL) {
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);
            }
            InstanceGuidHeader->ParentInstanceId =
                                   pParentInstInfo->InstanceId;
            // Newly added line for copying parent GUID
            InstanceGuidHeader->ParentGuid = GuidMapEntry->Guid;
        }
        else {
            InstanceGuidHeader->ParentInstanceId = 0;
            RtlZeroMemory(&(InstanceGuidHeader->ParentGuid), sizeof(GUID));
        }

        if (InstanceGuidHeader->Flags & WNODE_FLAG_USE_MOF_PTR) {
            PUCHAR Src, Dest;
            MofSize = Size - sizeof(EVENT_INSTANCE_HEADER);
            // Let's make sure we have a valid size
            if ((MofSize % sizeof(MOF_FIELD)) != 0) {
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);
            }
            Src = (PUCHAR)EventTrace + sizeof(EVENT_INSTANCE_HEADER);
            Dest = (PUCHAR)InstanceGuidHeader + 
                   sizeof(EVENT_INSTANCE_GUID_HEADER);
            RtlCopyMemory(Dest, Src, MofSize);
            // Correct the Size of the event. 
            // We already know Size >= sizeof(EVENT_INSTANCE_HEADER).
            InstanceGuidHeader->Size = (USHORT)(Size - 
                                            sizeof(EVENT_INSTANCE_HEADER) +
                                            sizeof(EVENT_INSTANCE_GUID_HEADER)
                                           );
        }
        else {
            MofSize = Size - sizeof(EVENT_INSTANCE_HEADER);
            InstanceGuidHeader->Flags |= WNODE_FLAG_USE_MOF_PTR;
            InstanceEventTrace.MofField[0].DataPtr = 
                (ULONG64) ((PUCHAR)EventTrace + sizeof(EVENT_INSTANCE_HEADER));
            InstanceEventTrace.MofField[0].Length = MofSize;
            // Correct the Size of the event. We are forcing the use of Mof Ptr. 
            InstanceGuidHeader->Size = 
               (USHORT)(sizeof(EVENT_INSTANCE_GUID_HEADER) + sizeof(MOF_FIELD));
        }

        Status = EtwpTraceEvent(
                                LoggerHandle, 
                                (PWNODE_HEADER) InstanceGuidHeader
                               );

        EventTrace->Flags = Flags;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError( GetExceptionCode() );
#if DBG
        EtwpDebugPrint(("ETW: Exception in TraceEventInstance Status = %d\n", 
                       Status));
#endif

    }

    return EtwpSetDosError(Status);
}

PTRACE_REG_INFO
EtwpAllocateGuidMaps(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID      ControlGuid,
    IN ULONG        GuidCount, 
    IN PTRACE_GUID_REGISTRATION GuidReg
    )
/*++

Routine Description:

    The purpose of this routine is to allocate in calling process's address
    space a hash of all the Guids being registered. Also to stash away 
    callback address and context. 

Arguments:

    RequestAddress    Pointer of the Enable callback function

    RequestContext    Pointer to the Context to be passed back during callback

    ControlGuid       Pointer to control guid being registered. 

    GuidCount         Count of Transaction Guids (0 to WMIMAXREGGUIDCOUNT)

    GuidReg           Pointer to transaction guid reg 


Return Value:

    Pointer to the address of the TRACE_REG_INFO block

--*/
{

    ULONG i;
    ULONG SizeNeeded;
    PUCHAR Buffer;
    PTRACE_REG_INFO pTraceRegInfo;
    PTRACE_GUID_REGISTRATION GuidRegPtr;
    PGUIDMAPENTRY pTransGuidMapEntry, pControlGMEntry;

    SizeNeeded = sizeof(TRACE_REG_INFO) +  
                 sizeof(GUIDMAPENTRY) +             // Control Guid
                 sizeof(GUIDMAPENTRY) * GuidCount;  // Transaction Guids

    Buffer = EtwpAlloc(SizeNeeded);
    if (Buffer == NULL) {
        return NULL;
    }
    RtlZeroMemory(Buffer, SizeNeeded);

    pTraceRegInfo = (PTRACE_REG_INFO) Buffer;
    pTraceRegInfo->NotifyRoutine = (PVOID)RequestAddress;
    pTraceRegInfo->NotifyContext = RequestContext;

    pControlGMEntry = (PGUIDMAPENTRY) ( Buffer + sizeof(TRACE_REG_INFO) );

    pControlGMEntry->Guid = *ControlGuid;

    // 
    // Initialize the list of Guid Map Entries.
    //
    pTransGuidMapEntry = (PGUIDMAPENTRY) ( Buffer + 
                                           sizeof(TRACE_REG_INFO) +
                                           sizeof(GUIDMAPENTRY) );
    for (i=1; i <= GuidCount; i++) {
        GuidRegPtr = &GuidReg[i-1];
        GuidRegPtr->RegHandle = pTransGuidMapEntry;
        pTransGuidMapEntry->Guid = *GuidRegPtr->Guid;
        //
        // Uses PID as signature. 
        //
        pTransGuidMapEntry->Reserved = EtwpGetCurrentProcessId();
        pTransGuidMapEntry++;
    }
    return pTraceRegInfo;
}

ULONG 
EtwpMakeCallbacks(
    IN LPCGUID      ControlGuid,
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN TRACEHANDLE  LoggerContext,
    IN PTRACE_REG_INFO pTraceRegInfo
    )
{
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerContext;
    BOOLEAN DeliverNotification = FALSE;
    ULONG Status=ERROR_SUCCESS;


    if (LoggerContext) {
        DeliverNotification = TRUE;

        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
            // Before Delivering this Notification
            // make sure that the Process Private logger
            // is running.
            pTraceRegInfo->EnabledState = TRUE;
            pTraceRegInfo->LoggerContext = LoggerContext;
            DeliverNotification = EtwpIsPrivateLoggerOn();
        }
    }

    if(IsEqualGUID(&NtdllTraceGuid, ControlGuid))
    {
        DeliverNotification = TRUE;
    }

    if (DeliverNotification) {
        try {
            WNODE_HEADER Wnode;
            ULONG InOutSize;
            //
            // Need to use a Local Wnode and a local InOutSize because 
            // the Callback function might alter it. 
            //

            RtlZeroMemory(&Wnode, sizeof(Wnode));
            Wnode.BufferSize = sizeof(Wnode);
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Guid = *ControlGuid;
            InOutSize = Wnode.BufferSize;
            Status = (RequestAddress)(WMI_ENABLE_EVENTS,
                         RequestContext,
                         &InOutSize,
                         &Wnode);
        } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
            Status = GetExceptionCode();
            EtwpDebugPrint(("WMI: Enable Call caused exception%d\n",
                Status));
#endif
            Status = ERROR_WMI_DP_FAILED;
        }
    }
    return Status;
}


ULONG 
WMIAPI
EtwRegisterTraceGuidsW(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID      ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCWSTR      MofImagePath,
    IN LPCWSTR      MofResourceName,
    IN PTRACEHANDLE RegistrationHandle
    )
/*++

Routine Description:

    This routine performs the ETW provider registration. It takes one control 
    Guid and optionally several transaction Guids. It registers the ControlGuid
    with the kernel and maintains the transaction Guids in a cache in the 
    process (GuidMaps).  The GuidMaps are necessary if one uses the 
    TraceEventInstance API which requires us to decode the GuidReg pointer
    back to the transaction Guid. 

Arguments:

    RequestAddress    Pointer of the Enable callback function

    RequestContext    Pointer to the Context to be passed back during callback

    ControlGuid       Pointer to control guid being registered.

    GuidCount         Count of Transaction Guids (0 to WMIMAXREGGUIDCOUNT)

    GuidReg           Pointer to transaction guid reg

    MofImagePath      Mof Image Path

    MofResourceName   Mof Resource Name

    RegistrationHandle  Handle returned from this registration. Caller must
                        use it to call UnregisterTraceGuids to free up memory.


Return Value:

    Return status from the call. 

--*/
{

    GUID Guid;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    TRACEHANDLE LoggerContext = 0;
    HANDLE TraceCtxHandle;
    ULONG Status;

    EtwpInitProcessHeap();

    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (ControlGuid == NULL) ||
        (GuidCount > WMIMAXREGGUIDCOUNT) )
    {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        Guid = *ControlGuid;
        *RegistrationHandle = (TRACEHANDLE) 0;
        //
        // Allocate GuidMaps, Registration Cookie
        //

        pTraceRegInfo = EtwpAllocateGuidMaps(RequestAddress,
                                      RequestContext, 
                                      &Guid,
                                      GuidCount,
                                      GuidReg
                                      );
        if (pTraceRegInfo == NULL) {
            return EtwpGetLastError();
        }

        Status = EtwpRegisterGuids(&RegisterReservedGuid,
                                   &Guid,
                                   MofImagePath,
                                   MofResourceName,
                                   &LoggerContext,
                                   &TraceCtxHandle);

        if (Status != ERROR_SUCCESS) {
            EtwpFree(pTraceRegInfo);
            return Status;
        }

        pTraceRegInfo->TraceCtxHandle = TraceCtxHandle;

        *RegistrationHandle =  (TRACEHANDLE)pTraceRegInfo;

        //
        // Make the Callback if we have to
        //

        Status = EtwpMakeCallbacks(&Guid,
                                   RequestAddress,
                                   RequestContext, 
                                   LoggerContext, 
                                   pTraceRegInfo);
        if (Status != ERROR_SUCCESS) {
            goto Cleanup;
        }
        //
        // We are Done. Add the handle to the EventPump and return
        //
        Status = EtwpAddHandleToEventPump(&Guid,
                                 (PVOID)TraceCtxHandle,
                                 (ULONG_PTR)pTraceRegInfo,
                                 0,
                                 TraceCtxHandle);

        if (Status != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError(GetExceptionCode());
#if DBG
            EtwpDebugPrint(("ETW: Registration call caused exception%d\n",
                Status));
#endif
    }

    return EtwpSetDosError(Status);
Cleanup:

    EtwUnregisterTraceGuids(*RegistrationHandle);
    *RegistrationHandle = 0;
    return (EtwpSetDosError(Status));

}


ULONG
WMIAPI
EtwRegisterTraceGuidsA(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCSTR       MofImagePath,
    IN LPCSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    )
/*++

Routine Description:

    ANSI thunk to RegisterTraceGuidsW

--*/
{
    LPWSTR MofImagePathUnicode = NULL;
    LPWSTR MofResourceNameUnicode = NULL;
    ULONG Status;

    EtwpInitProcessHeap();
    
    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (GuidCount <= 0) ||
        (GuidReg == NULL)  ||
        (ControlGuid == NULL) || 
        (GuidCount > WMIMAXREGGUIDCOUNT) )
    {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    Status = EtwpAnsiToUnicode(MofImagePath, &MofImagePathUnicode);
    if (Status == ERROR_SUCCESS) {
        if (MofResourceName) {
            Status = EtwpAnsiToUnicode(MofResourceName,&MofResourceNameUnicode);
        }
        if (Status == ERROR_SUCCESS) {

            Status = EtwRegisterTraceGuidsW(RequestAddress,
                                        RequestContext,
                                        ControlGuid,
                                        GuidCount,
                                        GuidReg,
                                        MofImagePathUnicode,
                                        MofResourceNameUnicode,
                                        RegistrationHandle
                                        );
            if (MofResourceNameUnicode) {
                EtwpFree(MofResourceNameUnicode);
            }
        }
        if (MofImagePathUnicode) {
            EtwpFree(MofImagePathUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
EtwUnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    )
{
    // First check if the handle belongs to a Trace Control Guid. 
    // Then UnRegister all the regular trace guids controlled by 
    // this control guid and free up the storage allocated to maintain 
    // the TRACEGUIDMAPENTRY structures.

    // Get to the real Registration Handle, stashed away in 
    // in the internal structures and pass it onto the call.  

    PGUIDMAPENTRY pControlGMEntry;
    WMIHANDLE WmiRegistrationHandle;
    ULONG Status;
    PVOID RequestContext;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    ULONG64 LoggerContext = 0;
    WMIDPREQUEST RequestAddress;

    EtwpInitProcessHeap();
    
    if (RegistrationHandle == 0) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        pTraceRegInfo = (PTRACE_REG_INFO) RegistrationHandle;

        pControlGMEntry = (PGUIDMAPENTRY)((PUCHAR)pTraceRegInfo + 
                                          sizeof(TRACE_REG_INFO) );

        WmiRegistrationHandle = (WMIHANDLE)pTraceRegInfo->TraceCtxHandle;
        if (WmiRegistrationHandle == NULL) {
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }

        Status =  WmiUnregisterGuids(WmiRegistrationHandle, 
                                     &pControlGMEntry->Guid, 
                                     &LoggerContext);

        if ((Status == ERROR_SUCCESS) && LoggerContext) {
            WNODE_HEADER Wnode;
            ULONG InOutSize = sizeof(Wnode);

            RtlZeroMemory(&Wnode, InOutSize);
            Wnode.BufferSize = sizeof(Wnode);
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Guid = pControlGMEntry->Guid;
            RequestAddress = pTraceRegInfo->NotifyRoutine;
            RequestContext = pTraceRegInfo->NotifyContext;

            Status = (RequestAddress)(WMI_DISABLE_EVENTS,
                            RequestContext,
                            &InOutSize,
                            &Wnode);
        }
        // 
        // At this point, it should be safe to delete the TraceRegInfo.
        //
        EtwpFree(pTraceRegInfo);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        Status = EtwpNtStatusToDosError(GetExceptionCode());
#if DBG
        EtwpDebugPrint(("ETW: UnregisterTraceGuids exception%d\n", Status));

#endif 
    }

    return EtwpSetDosError(Status);
}

ULONG
EtwpQueryAllUmTraceW(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    PWCHAR                     strSrcW;
    PWCHAR                     strDestW;

    if (PropertyArrayCount <= i) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = ALIGN_TO_POWER2(LoggerInfoSize, 8);
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) EtwpAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    EtwpInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    EtwpInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    status = EtwpSendUmLogRequest( (fEnabledOnly) ? (TRACELOG_QUERYENABLED) 
                                                  : (TRACELOG_QUERYALL),
                                    pLoggerInfo
                                 );

    if (status != ERROR_SUCCESS)
        goto Cleanup;

    while (i < PropertyArrayCount && Offset < SizeUsed) {

        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);

        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(WCHAR) * (lenLoggerName + 1)
               + sizeof(WCHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {

            EtwpCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            strSrcW = (PWCHAR) (  ((PUCHAR) pLoggerInfoCurrent)
                                  + sizeof(WMI_LOGGER_INFORMATION));
            if (lenLoggerName > 0) {
                if (PropertyArray[i]->LoggerNameOffset == 0) {
                    PropertyArray[i]->LoggerNameOffset =
                                    sizeof(EVENT_TRACE_PROPERTIES);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LoggerNameOffset);
                wcsncpy(strDestW, strSrcW, lenLoggerName);
                strDestW[lenLoggerName] = 0;
            }

            strSrcW = (PWCHAR) (((PUCHAR) pLoggerInfoCurrent)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + pLoggerInfoCurrent->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                if (PropertyArray[i]->LogFileNameOffset == 0) {
                    PropertyArray[i]->LogFileNameOffset =
                            PropertyArray[i]->LoggerNameOffset
                            + sizeof(WCHAR) * (lenLoggerName + 1);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LogFileNameOffset);
                wcsncpy(strDestW, strSrcW, lenLogFileName);
                strDestW[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        EtwpFree(pLoggerInfo);

    return EtwpSetDosError(status);
}

ULONG
EtwpQueryAllTraces(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount,
    IN ULONG IsUnicode
    )
{
    ULONG i, status;
    ULONG returnCount = 0;
    EVENT_TRACE_PROPERTIES LoggerInfo;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;

    EtwpInitProcessHeap();

    if ((LoggerCount == NULL)
        || (PropertyArrayCount > MAXLOGGERS)
        || (PropertyArray == NULL)
        || (PropertyArrayCount == 0))
        return ERROR_INVALID_PARAMETER;
    if (*PropertyArray == NULL)
        return ERROR_INVALID_PARAMETER;

    try {
        *LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            if (returnCount < PropertyArrayCount) {
                pLoggerInfo = PropertyArray[returnCount];
            }
            else {
                pLoggerInfo = &LoggerInfo;
                RtlZeroMemory(pLoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                pLoggerInfo->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);
            }
            WmiSetLoggerId(i, &pLoggerInfo->Wnode.HistoricalContext);

            if (IsUnicode) {
                status = EtwControlTraceW(
                            (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                            NULL,
                            pLoggerInfo,
                            EVENT_TRACE_CONTROL_QUERY);
            }
            else {
                status = EtwControlTraceA(
                            (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                            NULL,
                            pLoggerInfo,
                            EVENT_TRACE_CONTROL_QUERY);
            }

            if (status == ERROR_SUCCESS)
                returnCount++;
        }
        *LoggerCount = returnCount;
        status = EtwpQueryAllUmTraceW(PropertyArray,
                                      FALSE,
                                      PropertyArrayCount,
                                      LoggerCount);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return EtwpSetDosError(ERROR_NOACCESS);
    }

    if (returnCount > PropertyArrayCount)
        return ERROR_MORE_DATA;
    else
        return ERROR_SUCCESS;

}

ULONG
WMIAPI
EtwQueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{
    return EtwpQueryAllTraces(PropertyArray, 
                              PropertyArrayCount,
                              LoggerCount, TRUE);

}
    

ULONG
EtwpQueryAllUmTraceA(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    ANSI_STRING                strBufferA;
    PUCHAR                     strDestA;


    if (PropertyArrayCount <= i) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = ALIGN_TO_POWER2(LoggerInfoSize, 8);
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) EtwpAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    EtwpInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    EtwpInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    status = EtwpSendUmLogRequest(
                        (fEnabledOnly) ? (TRACELOG_QUERYENABLED)
                                       : (TRACELOG_QUERYALL),
                        pLoggerInfo
                    );

    if (status != ERROR_SUCCESS)
        goto Cleanup;


    while (i < PropertyArrayCount && Offset < SizeUsed) {
        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);
        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(CHAR) * (lenLoggerName + 1)
               + sizeof(CHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {
            EtwpCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            if (lenLoggerName > 0) {
                pLoggerInfoCurrent->LoggerName.Buffer = (PWCHAR)
                                        (  ((PUCHAR) pLoggerInfoCurrent)
                                         + sizeof(WMI_LOGGER_INFORMATION));
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LoggerName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LoggerNameOffset == 0) {
                        PropertyArray[i]->LoggerNameOffset =
                                        sizeof(EVENT_TRACE_PROPERTIES);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LoggerNameOffset);
                    StringCchCopyA(strDestA, lenLoggerName+1, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLoggerName] = 0;
            }

            if (lenLogFileName > 0) {
                pLoggerInfoCurrent->LogFileName.Buffer = (PWCHAR)
                              (  ((PUCHAR) pLoggerInfoCurrent)
                               + sizeof(WMI_LOGGER_INFORMATION)
                               + pLoggerInfoCurrent->LoggerName.MaximumLength);
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LogFileName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LogFileNameOffset == 0) {
                        PropertyArray[i]->LogFileNameOffset =
                                         sizeof(EVENT_TRACE_PROPERTIES)
                                       + sizeof(CHAR) * (lenLoggerName + 1);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LogFileNameOffset);
                    StringCchCopyA(strDestA, lenLogFileName+1, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        EtwpFree(pLoggerInfo);

    return EtwpSetDosError(status);
}

ULONG
WMIAPI
EtwQueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{

    return EtwpQueryAllTraces(PropertyArray,
                              PropertyArrayCount,
                              LoggerCount, FALSE);
}


TRACEHANDLE
WMIAPI
EtwGetTraceLoggerHandle(
    IN PVOID Buffer
    )
{
    TRACEHANDLE LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    USHORT LoggerId;

    EtwpInitProcessHeap();
    
    if (Buffer == NULL) {
        EtwpSetDosError(ERROR_INVALID_PARAMETER);
        return LoggerHandle;
    }

    try {
        if (((PWNODE_HEADER)Buffer)->BufferSize < sizeof(WNODE_HEADER)) {
            EtwpSetDosError(ERROR_BAD_LENGTH);
            return LoggerHandle;
        }
        LoggerHandle = (TRACEHANDLE)((PWNODE_HEADER)Buffer)->HistoricalContext;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        EtwpSetDosError(ERROR_NOACCESS);
        return (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID)) 
    {
        EtwpSetDosError(ERROR_INVALID_HANDLE);
        LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    return LoggerHandle;
}

UCHAR
WMIAPI
EtwGetTraceEnableLevel(
    IN TRACEHANDLE LoggerHandle
    )
{
    UCHAR Level;
    USHORT LoggerId;

    EtwpInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);

    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        EtwpSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Level = WmiGetLoggerEnableLevel(LoggerHandle);
    return Level;
}

ULONG
WMIAPI
EtwGetTraceEnableFlags(
    IN TRACEHANDLE LoggerHandle
    )
{
    ULONG Flags;
    USHORT LoggerId;

    EtwpInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        EtwpSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Flags = WmiGetLoggerEnableFlags(LoggerHandle);
    return Flags;
}

ULONG
WMIAPI
EtwCreateTraceInstanceId(
    IN PVOID RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInst
    )
/*++

Routine Description:

    This call takes the Registration Handle for a traced GUID and fills in the 
    instanceId in the EVENT_INSTANCE_INFO structure provided by the caller. 

Arguments:

    RegHandle       Registration Handle for the Guid. 

    pInst           Pointer to the Instance information

Return Value:

    The status of performing the action requested.

--*/
{
    PGUIDMAPENTRY GuidMapEntry;

    EtwpInitProcessHeap();
    
    if ((RegHandle == NULL) || (pInst == NULL)) {
        return EtwpSetDosError(ERROR_INVALID_PARAMETER);
    } 
    try {

        pInst->RegHandle = RegHandle;
        GuidMapEntry =  (PGUIDMAPENTRY) RegHandle;
        //
        // Use the PID as a signature 
        // 
        if (GuidMapEntry->Reserved != EtwpGetCurrentProcessId() ) {
#if DBG
            EtwpDebugPrint(("ETW: Bad RegHandle %x in CreateTraceInstanceId!\n", RegHandle));
            
#endif
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        if (GuidMapEntry->InstanceId >= MAXINST) {
            InterlockedCompareExchange(&GuidMapEntry->InstanceId, MAXINST, 0);
        }
        pInst->InstanceId = InterlockedIncrement(&GuidMapEntry->InstanceId);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return EtwpSetDosError(EtwpNtStatusToDosError(GetExceptionCode()));
    }

    return ERROR_SUCCESS;
}


ULONG
WMIAPI
EtwEnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    )
/*++

Routine Description:

    This call returns all the registered trace control guids
    with their current status.

Arguments:

    GuidPropertiesArray Points to buffers to write trace control guid properties

    PropertyArrayCount  Size of the array provided

    GuidCount           Number of GUIDs written in the Array. If the
                        Array was smaller than the required size, GuidCount
                        returns the size needed.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    PWMIGUIDLISTINFO pGuidListInfo;
    ULONG i, j;

    EtwpInitProcessHeap();

    try {
        if ( (GuidPropertiesArray == NULL)  || (*GuidPropertiesArray == NULL) ){
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        for (i=0; i < PropertyArrayCount; i++) {
            if (GuidPropertiesArray[i] == NULL) {
                return EtwpSetDosError(ERROR_INVALID_PARAMETER);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError( GetExceptionCode() );
        return EtwpSetDosError(Status);
    }




    Status = EtwpEnumRegGuids(&pGuidListInfo);

    if (Status == ERROR_SUCCESS) {
        try {

            PWMIGUIDPROPERTIES pGuidProperties = pGuidListInfo->GuidList;
            j = 0;

            for (i=0; i < pGuidListInfo->ReturnedGuidCount; i++) {

                if (pGuidProperties->GuidType == 0) { // Trace Control Guid

                    if (j >=  PropertyArrayCount) {
                        Status = ERROR_MORE_DATA;
                    }
                    else {
                        RtlCopyMemory(GuidPropertiesArray[j],
                                      pGuidProperties,
                                      sizeof(WMIGUIDPROPERTIES)
                                     );
                    }
                    j++;
                }
                pGuidProperties++;
            }
            *GuidCount = j;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = EtwpNtStatusToDosError( GetExceptionCode() );
        }

        EtwpFree(pGuidListInfo);
    }

    return EtwpSetDosError(Status);

}


// Stub APIs
ULONG
WMIAPI
EtwQueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}

ULONG
WMIAPI
EtwQueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}

ULONG
WMIAPI
EtwStopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}

ULONG
WMIAPI
EtwStopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}


ULONG
WMIAPI
EtwUpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        EtwControlTraceA(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}

ULONG
WMIAPI
EtwUpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        EtwControlTraceW(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}

ULONG
WMIAPI
EtwFlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}

ULONG
WMIAPI
EtwFlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return EtwControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}


ULONG 
EtwpTraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     ArgList
)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    ULONG Flags;
    ULONG dataBytes, argCount ;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;
    va_list ap ;
    PMESSAGE_TRACE_USER pMessage = NULL ;
    try {
        //
        // Determine the number bytes to follow header
        //
        dataBytes = 0 ;             // For Count of Bytes
        argCount = 0 ;              // For Count of Arguments
        { // Allocation Block
            
            PCHAR source;
            ap = ArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                    size_t elemBytes;
                    elemBytes = va_arg (ap, size_t);

                    if ( elemBytes > (TRACE_MESSAGE_MAXIMUM_SIZE - sizeof(MESSAGE_TRACE_USER))) {
                        EtwpSetLastError(ERROR_BUFFER_OVERFLOW);
                        return(ERROR_BUFFER_OVERFLOW);            
                    }

                    dataBytes += elemBytes;
                    argCount++ ;
            }
         } // end of allocation block

        if (dataBytes > (TRACE_MESSAGE_MAXIMUM_SIZE - sizeof(MESSAGE_TRACE_USER))) {
            EtwpSetLastError(ERROR_BUFFER_OVERFLOW);
            return(ERROR_BUFFER_OVERFLOW);
        }

        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE){
            NtStatus = EtwpTraceUmMessage(dataBytes,
                                         (ULONG64)LoggerHandle,
                                         MessageFlags,
                                         MessageGuid,
                                         MessageNumber,
                                         ArgList);
            return EtwpNtStatusToDosError( NtStatus );
        }
        //
        // Now the LoggerHandle is expected to be filled in by the caller.
        //  But check to see if it has a valid value.
        //

        LoggerId = WmiGetLoggerId(LoggerHandle);
        if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
             return ERROR_INVALID_HANDLE;
        }

        Size = dataBytes + sizeof(MESSAGE_TRACE_USER) ;

        pMessage = (PMESSAGE_TRACE_USER)EtwpAlloc(Size);
        if (pMessage == NULL)
        {
            EtwpSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pMessage->MessageHeader.Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        pMessage->MessageFlags = MessageFlags ;
        pMessage->MessageHeader.Packet.MessageNumber = MessageNumber ;
        pMessage->LoggerHandle = (ULONG64)LoggerHandle ;
        // GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(ULONG)) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
        	RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(GUID));
        }
        pMessage->DataSize = dataBytes ;
        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list tap;
            PCHAR dest = (PCHAR)&pMessage->Data ;
            PCHAR source;
            tap = ArgList ;
            while ((source = va_arg (tap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (tap, size_t);
                RtlCopyMemory (dest, source, elemBytes);
                dest += elemBytes;
            }
        } // Allocation Block
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (pMessage != NULL) {
            EtwpFree(pMessage);
        }
        return EtwpNtStatusToDosError( GetExceptionCode() );
    }
    NtStatus = NtTraceEvent((HANDLE)LoggerHandle,
                            ETW_NT_FLAGS_TRACE_MESSAGE,
                            Size,
                            pMessage);

    if (pMessage != NULL) {
        EtwpFree(pMessage);
    }
    return EtwpNtStatusToDosError( NtStatus );

}

ULONG
WMIAPI
EtwTraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    ...
)
/*++
Routine Description:
This routine is used by WMI data providers to trace events. It expects the user
to pass in the handle to the logger. Also, the user cannot ask to log something
that is larger than the buffer size (minus buffer header).

Arguments:

    IN TRACEHANDLE LoggerHandle   - LoggerHandle obtained earlier
    IN USHORT MessageFlags        - Flags which both control what standard 
                                    values are logged and also included in the
                                    message header to control decoding.
    IN PGUID MessageGuid,         - Pointer to the message GUID of this set of 
                                    messages or if TRACE_COMPONENTID is set the
                                    actual compnent ID.
    IN USHORT MessageNumber       - The type of message being logged, associates
                                    it with the appropriate format string  
    ...                           - List of arguments to be processed with the 
                                    format string these are stored as pairs of
                                    PVOID - ptr to argument
                                    ULONG - size of argument
                                    and terminated by a pointer to NULL, length
                                    of zero pair.

Return Value:
    Status
--*/
{
    ULONG Status ;
    va_list ArgList ;

    EtwpInitProcessHeap();
    
    try {
         va_start(ArgList,MessageNumber);
         Status = EtwpTraceMessage(LoggerHandle, 
                                   MessageFlags, 
                                   MessageGuid, 
                                   MessageNumber, 
                                   ArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError( GetExceptionCode() );
    }
    return EtwpSetDosError(Status);
}


ULONG
WMIAPI
EtwTraceMessageVa(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     MessageArgList
)
// The Va version of TraceMessage
{
    ULONG Status ;

    EtwpInitProcessHeap();
    
    try {
        Status = EtwpTraceMessage(LoggerHandle, 
                                  MessageFlags, 
                                  MessageGuid, 
                                  MessageNumber, 
                                  MessageArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = EtwpNtStatusToDosError( GetExceptionCode() );
    }
    return EtwpSetDosError(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\main.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:
    
    WMI  dll main file

Author:

    16-Jan-1997 AlanWar

Revision History:

    2-Aug-2001 a-digpar

    Moved All functions to \base\wmi\inc\common.h
    This file is here to get all glogal guids.

--*/

#define INITGUID
#include "wmiump.h"
#include "evntrace.h"
#include <rpc.h>
#include "trcapi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\request.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    request.c

Abstract:

    Implements WMI requests to different data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/
#include <nt.h>
#include "wmiump.h"
#include "trcapi.h"
#include "wmiumkm.h"
#include "request.h"
//
// This is the handle to the WMI kernel mode device
extern HANDLE EtwpKMHandle;

//
// This is the one-deep Win32 event queue used to supply events for
// overlapped I/O to the WMI device.
extern HANDLE EtwpWin32Event;



ULONG EtwpSendRegisterKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    )
/*+++

Routine Description:

    This is a special SendKMRequest routine for RegisterTraceGuids. 
    We will reject MofResource from the RegisterTraceGuids call if it 
    did not come from Admin or LocalSystem. To determine that we need
    to attempt to send the Ioctl through WMIAdminDevice first. If that 
    fails, we send the request the normal way, ie., through WMI data device. 

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    OutBuffer is the output buffer for the call to the WMI device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer
    Overlapped is an option OVERLAPPED struct that is used to make the
        call async

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    ULONG Status;
    HANDLE KMHandle;

    //
    // First, we try to open the WMI Admin device
    //

    KMHandle = EtwpCreateFileW(WMIAdminDeviceName_W,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);


    if ( (KMHandle == INVALID_HANDLE_VALUE) ||  (KMHandle == NULL))
    {

        //
        // Send the Request through WMI Data Device
        //

        Status = EtwpSendWmiKMRequest( DeviceHandle, 
                                     Ioctl, 
                                     InBuffer, 
                                     InBufferSize, 
                                     OutBuffer, 
                                     MaxBufferSize, 
                                     ReturnSize,
                                     Overlapped
                                   ); 
    }
    else 
    {
        Status = EtwpSendWmiKMRequest( KMHandle,
                                       Ioctl,
                                       InBuffer,
                                       InBufferSize,
                                       OutBuffer,
                                       MaxBufferSize,
                                       ReturnSize,
                                       Overlapped
                                     );

        EtwpCloseHandle(KMHandle);
    }

    return(Status);
}


ULONG EtwpRegisterGuids(
    IN LPGUID MasterGuid,
    IN LPGUID ControlGuid,
    IN LPCWSTR MofImagePath,
    IN LPCWSTR MofResourceName,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
    )
{
    ULONG Status, StringPos, StringSize, WmiRegSize;
    ULONG SizeNeeded, InSizeNeeded, OutSizeNeeded;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
    PWMIREGREQUEST WmiRegRequest;
    PUCHAR Buffer;
    PUCHAR RegInfoBuffer;
    PWMIREGRESULTS WmiRegResults;
    ULONG ReturnSize;
    PWMIREGINFOW pWmiRegInfo;
    PWMIREGGUID  WmiRegGuidPtr;
    LPGUID pGuid;
    PWCHAR StringPtr;
    
    //
    // Allocate a buffer large enough for all in and out parameters
    //
    // Allocate space to call IOCTL_WMI_REGISTER_GUIDS
    //
    InSizeNeeded = sizeof(WMIREGREQUEST) +
                   sizeof(WMIREGINFOW) +
                   sizeof(WMIREGGUIDW);

    if (MofImagePath == NULL) {
        MofImagePath = L"";
    }

    if (MofResourceName != NULL) {
        InSizeNeeded += (wcslen(MofResourceName) + 2) * sizeof(WCHAR);
    }
    InSizeNeeded += (wcslen(MofImagePath) + 2) * sizeof(WCHAR);
    InSizeNeeded = (InSizeNeeded + 7) & ~7;

    OutSizeNeeded = sizeof(WMIREGRESULTS);

    if (InSizeNeeded > OutSizeNeeded)
    {
        SizeNeeded = InSizeNeeded;
    } else {
        SizeNeeded = OutSizeNeeded;
    }
    
    Buffer = EtwpAlloc(SizeNeeded);
    
    if (Buffer != NULL)
    {
        RtlZeroMemory(Buffer, SizeNeeded);
        //
        // Build the object attributes
        //
        WmiRegRequest = (PWMIREGREQUEST)Buffer;
        WmiRegRequest->ObjectAttributes = &ObjectAttributes;
        WmiRegRequest->WmiRegInfo32Size = sizeof(WMIREGINFOW);
        WmiRegRequest->WmiRegGuid32Size = sizeof(WMIREGGUIDW);

        RegInfoBuffer = Buffer + sizeof(WMIREGREQUEST);

        Status = EtwpBuildGuidObjectAttributes(MasterGuid,
                                               &ObjectAttributes,
                                               &GuidString,
                                               GuidObjectName);

        if (Status == ERROR_SUCCESS)
        {
            WmiRegRequest->Cookie = 0;

            pWmiRegInfo = (PWMIREGINFOW) (Buffer + sizeof(WMIREGREQUEST));
            WmiRegSize = SizeNeeded - sizeof(WMIREGREQUEST);
            StringPos = sizeof(WMIREGINFOW) + sizeof(WMIREGGUIDW);
            pWmiRegInfo->BufferSize = WmiRegSize;
            pWmiRegInfo->GuidCount = 1;

            WmiRegGuidPtr = &pWmiRegInfo->WmiRegGuid[0];
            WmiRegGuidPtr->Flags = (WMIREG_FLAG_TRACED_GUID |
                                    WMIREG_FLAG_TRACE_CONTROL_GUID);
            WmiRegGuidPtr->Guid = *ControlGuid;

            // Copy MOF resource path and name into WmiRegInfo
            if (MofResourceName != NULL) {
                pWmiRegInfo->MofResourceName = StringPos;
                StringPtr = (PWCHAR)OffsetToPtr(pWmiRegInfo, StringPos);
                Status = EtwpCopyStringToCountedUnicode(MofResourceName,
                                                        StringPtr,
                                                        &StringSize,
                                                        FALSE);
                if (Status != ERROR_SUCCESS) {
                    EtwpFree(Buffer);
                    EtwpSetLastError(Status);
                    return Status;
                }
                StringPos += StringSize;
#if DBG
                EtwpAssert(StringPos <= WmiRegSize);
#endif
            }
            if (MofImagePath != NULL) {
                pWmiRegInfo->RegistryPath = StringPos;
                StringPtr = (PWCHAR)OffsetToPtr(pWmiRegInfo, StringPos);
                Status = EtwpCopyStringToCountedUnicode(MofImagePath,
                                                        StringPtr,
                                                        &StringSize,
                                                        FALSE);
                if (Status != ERROR_SUCCESS) {
                    EtwpFree(Buffer);
                    EtwpSetLastError(Status);
                    return Status;
                }
                StringPos += StringSize;
#if DBG
                EtwpAssert(StringPos <= WmiRegSize);
#endif
            }

            Status = EtwpSendRegisterKMRequest (NULL,
                                         IOCTL_WMI_REGISTER_GUIDS,
                                         Buffer,
                                         InSizeNeeded,
                                         Buffer,
                                         OutSizeNeeded,
                                         &ReturnSize,
                                         NULL);
                                     
            if (Status == ERROR_SUCCESS)
            {
                //
                // Successful call, return the out parameters
                //
                WmiRegResults = (PWMIREGRESULTS)Buffer;
                *RegistrationHandle = WmiRegResults->RequestHandle.Handle;
                *LoggerContext = WmiRegResults->LoggerContext;
#if DBG
                if ( (WmiRegResults->MofIgnored) && (MofResourceName != NULL) 
                                                 && (MofImagePath != NULL))
                {
                    EtwpDebugPrint(("ETW: Mof %ws from %ws ignored\n",
                                     MofImagePath, MofResourceName));
                }
#endif

            }
        }
        EtwpFree(Buffer);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\notify.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Handles incoming notifications and requests for consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include "wmiump.h"
#include "evntrace.h"
#include "ntcsrdll.h"
#include "trcapi.h"
#include <strsafe.h>


//
// These globals are essentially parameters passed from the thread crating
// the event pump. The creating thread will alloc all of these resources
// so that it can know whether the pump thread will be successful or not.
// If we ever wanted to be able to have multiple pump threads then we'd
// need to move the globals into a structure and pass the struructure to the
// pump thread.
//
HANDLE EtwpEventDeviceHandle;
HANDLE EtwpPumpCommandEvent;
HANDLE EtwpMyProcessHandle;
OVERLAPPED EtwpOverlapped1, EtwpOverlapped2;
PUCHAR EtwpEventBuffer1, EtwpEventBuffer2;
ULONG EtwpEventBufferSize1, EtwpEventBufferSize2;

//
// How long to wait before the event pump thread times out. On checked
// builds we want to stress the event pump and so we timeout almost
// right away. On free builds we want to be more cautious so we timeout
// after 5 minutes.
//
#if DBG
#define EVENT_NOTIFICATION_WAIT 1
#else
#define EVENT_NOTIFICATION_WAIT (5 * 60 * 1000)
#endif

ULONG EtwpEventNotificationWait = EVENT_NOTIFICATION_WAIT;

typedef enum
{
    EVENT_PUMP_ZERO,         // Pump thread has not been started yet
    EVENT_PUMP_IDLE,         // Pump thread was started, but then exited
    EVENT_PUMP_RUNNING,      // Pump thread is running
    EVENT_PUMP_STOPPING      // Pump thread is in process of stopping
} EVENTPUMPSTATE, *PEVENTPUMPSTATE;

EVENTPUMPSTATE EtwpPumpState = EVENT_PUMP_ZERO;
BOOLEAN EtwpNewPumpThreadPending;

#define EtwpSendPumpCommand() EtwpSetEvent(EtwpPumpCommandEvent);

#define EtwpIsPumpStopping() \
    ((EtwpPumpState == EVENT_PUMP_STOPPING) ? TRUE : FALSE)


#if DBG
PCHAR GuidToStringA(
    PCHAR s,
    ULONG szBuf, 
    LPGUID piid
    )
{
    GUID XGuid; 

    if ( (s == NULL) || (piid == NULL) || (szBuf == 0) ) {
        return NULL;
    }

    XGuid = *piid;

    StringCchPrintf(s, szBuf, "%x-%x-%x-%x%x%x%x%x%x%x%x", 
                    XGuid.Data1, XGuid.Data2,
                    XGuid.Data3,
                    XGuid.Data4[0], XGuid.Data4[1],
                    XGuid.Data4[2], XGuid.Data4[3],
                    XGuid.Data4[4], XGuid.Data4[5],
                    XGuid.Data4[6], XGuid.Data4[7]);

    return(s);
}
#endif


ULONG EtwpEventPumpFromKernel(
    PVOID Param
    );

void EtwpExternalNotification(
    NOTIFICATIONCALLBACK Callback,
    ULONG_PTR Context,
    PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine dispatches an event to the appropriate callback
    routine. This process only receives events from the WMI service that
    need to be dispatched within this process. The callback address for the
    specific event is passed by the wmi service in Wnode->Linkage.

Arguments:

    Callback is address to callback

    Context is the context to callback with

    Wnode has event to deliver

Return Value:

--*/
{
    try
    {
        (*Callback)(Wnode, Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpDebugPrint(("NotificationCallbackRoutine threw exception %d\n",
            GetExceptionCode()));
    }
}


#ifdef MEMPHIS
ULONG EtwpExternalNotificationThread(
    PNOTIFDELIVERYCTX NDContext
    )
/*++

Routine Description:

    This routine is the thread function used to deliver events to event
    consumers on memphis.

Arguments:

    NDContext specifies the information about how to callback the application
    with the event.

Return Value:

--*/
{
    EtwpExternalNotification(NDContext->Callback,
                             NDContext->Context,
                             NDContext->Wnode);
    EtwpFree(NDContext);
    return(0);
}
#endif

void
EtwpProcessExternalEvent(
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags
)
{
    HANDLE ThreadHandle;
    PNOTIFDELIVERYCTX NDContext;
    PWNODE_HEADER *WnodePtr;
    BOOLEAN WnodePtrOk;
    PWNODE_HEADER WnodeCopy;
    DWORD ThreadId;
    BOOLEAN PostOk;
    ULONG Status;
    PVOID NotificationAddress;
    PVOID NotificationContext;

    NotificationAddress = DeliveryInfo;
    NotificationContext = (PVOID)DeliveryContext;

    if (NotificationFlags & NOTIFICATION_FLAG_CALLBACK_DIRECT)
    {
        //
        // Callback notifications can happen in this thread or a new
        // thread. It is up to the server to decide.
#ifdef MEMPHIS
        if (NotificationFlags & DCREF_FLAG_NO_EXTRA_THREAD)
        {
            EtwpExternalNotification(
                                    (NOTIFICATIONCALLBACK)NotificationAddress,
                                    (ULONG_PTR)NotificationContext,
                                    Wnode);
        } else {
            NDContext = EtwpAlloc(FIELD_OFFSET(NOTIFDELIVERYCTX,
                                                    WnodeBuffer) + WnodeSize);
            if (NDContext != NULL)
            {
                NDContext->Callback = (NOTIFICATIONCALLBACK)NotificationAddress;
                NDContext->Context = (ULONG_PTR)NotificationContext;
                WnodeCopy = (PWNODE_HEADER)NDContext->WnodeBuffer;
                memcpy(WnodeCopy, Wnode, WnodeSize);
                NDContext->Wnode = WnodeCopy;
                ThreadHandle = EtwpCreateThread(NULL,
                                              0,
                                              EtwpExternalNotificationThread,
                                              NDContext,
                                              0,
                                              &ThreadId);
                if (ThreadHandle != NULL)
                {
                    EtwpCloseHandle(ThreadHandle);
                } else {
                     EtwpDebugPrint(("WMI: Event dropped due to thread creation failure\n"));
                }
            } else {
                EtwpDebugPrint(("WMI: Event dropped due to lack of memory\n"));
            }
        }
#else
        //
        // On NT we deliver events in this thread since
        // the service is using async rpc.
        EtwpExternalNotification(
                            (NOTIFICATIONCALLBACK)NotificationAddress,
                            (ULONG_PTR)NotificationContext,
                            Wnode);
#endif
    }
}

void
EtwpEnableDisableGuid(
    PWNODE_HEADER Wnode,
    ULONG   RequestCode, 
    BOOLEAN bDelayEnable
    )
{
    ULONG ActionCode;
    PUCHAR Buffer = (PUCHAR)Wnode;
    PGUIDNOTIFICATION GNEntry = NULL;
    ULONG i;
    PVOID DeliveryInfo = NULL;
    ULONG_PTR DeliveryContext1;
    WMIDPREQUEST WmiDPRequest;
    PVOID RequestAddress;
    PVOID RequestContext;
    ULONG Status;
    ULONG BufferSize = Wnode->BufferSize;

    GNEntry = EtwpFindAndLockGuidNotification(&Wnode->Guid, !bDelayEnable);
    if (GNEntry != NULL) {


        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            EtwpEnterPMCritSection();
            DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
            DeliveryContext1 = GNEntry->Notifyee[i].DeliveryContext;
            EtwpLeavePMCritSection();

            if ((DeliveryInfo != NULL) &&
                (DeliveryContext1 != 0) &&
                (! EtwpIsNotifyeePendingClose(&(GNEntry->Notifyee[i] ))))
            {
                PTRACE_REG_INFO pTraceRegInfo;
                pTraceRegInfo = (PTRACE_REG_INFO) DeliveryContext1;
                WmiDPRequest = (WMIDPREQUEST) pTraceRegInfo->NotifyRoutine;
                RequestContext = pTraceRegInfo->NotifyContext;

                //
                // If this Enable is for a PrivateLogger and it is not up
                // then we need save the state and return.
                //
                if (RequestCode == WMI_ENABLE_EVENTS) {
                    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)
                                                      &Wnode->HistoricalContext;
                    if (bDelayEnable) {
                        if (pTraceRegInfo->EnabledState) {
                            Wnode->HistoricalContext = pTraceRegInfo->LoggerContext;
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        pTraceRegInfo->LoggerContext = Wnode->HistoricalContext;
                        pTraceRegInfo->EnabledState = TRUE;

                        if ( pContext->InternalFlag & 
                             EVENT_TRACE_INTERNAL_FLAG_PRIVATE  ) {

                            if (!EtwpIsPrivateLoggerOn()) {
                                continue;   // Need this for every Notifyee
                            }
                        }
                    }
                }
                else if (RequestCode == WMI_DISABLE_EVENTS) {
                    pTraceRegInfo->EnabledState = FALSE;
                    pTraceRegInfo->LoggerContext = 0;
                }


                try
                {
                    if (*WmiDPRequest != NULL) {
                        Status = (*WmiDPRequest)(Wnode->ProviderId,
                                             RequestContext,
                                             &BufferSize,
                                             Buffer);
                    }
                    else 
                        Status = ERROR_WMI_DP_NOT_FOUND;
                } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
                    Status = GetExceptionCode();
                    EtwpDebugPrint(("WMI: EnableCB exception %d\n",
                                    Status));
#endif
                    Status = ERROR_WMI_DP_FAILED;
                }

            }
        }
        //
        // We are done with the callbacks. Go ahead 
        // and unlock the GNEntry to indicate All clear for 
        // unregistering, unloading etc.,
        //
        if (!bDelayEnable) {
            EtwpUnlockCB(GNEntry);
        }
        EtwpDereferenceGNEntry(GNEntry);
    }
}


void EtwpInternalNotification(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    ULONG ActionCode;
    PUCHAR Buffer = (PUCHAR)Wnode;
    PGUIDNOTIFICATION GNEntry = NULL;
    ULONG i;
    PVOID DeliveryInfo = NULL;
    ULONG_PTR DeliveryContext1;


    //
    // This is an internal event, which is really a callback
    // from kernel mode
    //
    ActionCode = Wnode->ProviderId;

    // if this is a trace guid enable/disable call use the cookie
    // to get the address


    if ( (Wnode->Flags & WNODE_FLAG_TRACED_GUID) || (ActionCode == WmiMBRequest) )
    {
        switch (ActionCode) {
            case WmiEnableEvents:
            case WmiDisableEvents:
            {
                WMIDPREQUEST WmiDPRequest;
                PVOID RequestAddress;
                PVOID RequestContext;
                ULONG Status;
                ULONG BufferSize = Wnode->BufferSize;

                if (Wnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG64)) ) {
                    PULONG64 pLoggerContext = (PULONG64)(Buffer + sizeof(WNODE_HEADER));
                    Wnode->HistoricalContext = *pLoggerContext;
                }
                else {
                    EtwpSetLastError(ERROR_WMI_DP_FAILED);
#if DBG
                    EtwpDebugPrint(("WMI: Small Wnode %d for notifications\n", 
                                   Wnode->BufferSize));
#endif
                    return;
                }

                EtwpEnableDisableGuid(Wnode, ActionCode, FALSE);

                break;
            }
            case WmiMBRequest:
            {
                PWMI_LOGGER_INFORMATION LoggerInfo;

                if (Wnode->BufferSize < (sizeof(WNODE_HEADER) + sizeof(WMI_LOGGER_INFORMATION)) )
                {
#if DBG
                    EtwpSetLastError(ERROR_WMI_DP_FAILED);
                    EtwpDebugPrint(("WMI: WmiMBRequest with invalid buffer size %d\n",
                                        Wnode->BufferSize));
#endif
                    return;
                }

                LoggerInfo = (PWMI_LOGGER_INFORMATION) ((PUCHAR)Wnode + 
                                                          sizeof(WNODE_HEADER));


                GNEntry = EtwpFindAndLockGuidNotification(
                                                        &LoggerInfo->Wnode.Guid,
                                                        TRUE);

                if (GNEntry != NULL)
                {
                    EtwpEnterPMCritSection();
                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        if ((GNEntry->Notifyee[i].DeliveryInfo != NULL) &&
                            (! EtwpIsNotifyeePendingClose(&(GNEntry->Notifyee[i]))))
                        {
                            //
                            // Since only one ProcessPrivate logger is 
                            // allowed, we need to just find one entry. 
                            //
                            DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                            DeliveryContext1 = GNEntry->Notifyee[i].DeliveryContext;
                            break;
                        }
                    }
                    EtwpLeavePMCritSection();
                
                    if (DeliveryInfo != NULL)
                    {
                        LoggerInfo->Wnode.CountLost = Wnode->CountLost;
                        EtwpProcessUMRequest(LoggerInfo, 
                                             DeliveryInfo, 
                                             Wnode->Version
                                             );
                    }
                    EtwpUnlockCB(GNEntry);
                    EtwpDereferenceGNEntry(GNEntry);
                }
                break;
            }
            default:
            {
#if DBG
                EtwpSetLastError(ERROR_WMI_DP_FAILED);
                EtwpDebugPrint(("WMI: WmiMBRequest failed. Delivery Info not found\n" ));
#endif
            }
        }
    } else if (IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_ADDED_NOTIFICATION) ||
               IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION) )
    {
        switch (ActionCode)
        {
            case MOFEVENT_ACTION_IMAGE_PATH:
            case MOFEVENT_ACTION_REGISTRY_PATH:
            {
                //
                // We got a MOF resource added or removed notification. We have
                // to convert from regpath to imagepath and then get the list
                // of MUI image paths
                //
                EtwpProcessMofAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                         Callback,
                                         DeliveryContext,
                                         IsAnsi);
                break;
            }

            case MOFEVENT_ACTION_LANGUAGE_CHANGE:
            {
                //
                // This is a notification for adding or removing a language
                // from the system. We need to figure out which language is
                // coming or going and then build a list of the affected mof
                // resources and send mof added or removed notifications for
                // all mof resources
                //
                EtwpProcessLanguageAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                          Callback,
                                          DeliveryContext,
                                          IsAnsi);
                break;
            }


            default:
            {
                EtwpAssert(FALSE);
            }
        }
    }
}

void EtwpConvertEventToAnsi(
    PWNODE_HEADER Wnode
    )
{
    PWCHAR WPtr;

    if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
    {
        EtwpConvertWADToAnsi((PWNODE_ALL_DATA)Wnode);
    } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
               (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM)) {

        WPtr = (PWCHAR)OffsetToPtr(Wnode,
                           ((PWNODE_SINGLE_INSTANCE)Wnode)->OffsetInstanceName);
        EtwpCountedUnicodeToCountedAnsi(WPtr, (PCHAR)WPtr);
    }

    Wnode->Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

}

void EtwpDeliverAllEvents(
    PUCHAR Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Linkage = 1;
    ULONG CompositeFlags;
    ULONG i;
    PGUIDNOTIFICATION GNEntry;
    ULONG Flags;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG WnodeSize;
    ULONG CurrentOffset;
#if DBG
    PWNODE_HEADER LastWnode;
#endif          
    
    CurrentOffset = 0;
    while (Linkage != 0)
    {
        //
        // External notifications are handled here

        Linkage = Wnode->Linkage;
        Wnode->Linkage = 0;

        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // This is an internal event, which is really a callback
            // from kernel mode
            //
            EtwpInternalNotification(Wnode,
                                    NULL,
                                    0,
                                    FALSE);
        } else {        
            //
            // This is a plain old event, figure out who owns it and'
            // go deliver it
            //
            GNEntry = EtwpFindAndLockGuidNotification(&Wnode->Guid, TRUE);
            if (GNEntry != NULL)
            {
                CompositeFlags = 0;

                WnodeSize = Wnode->BufferSize;

                for (i = 0; i < GNEntry->NotifyeeCount; i++)
                {
                    EtwpEnterPMCritSection();
                    Flags = GNEntry->Notifyee[i].Flags;
                    DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                    DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                    EtwpLeavePMCritSection();
                    if ((DeliveryInfo != NULL) &&
                        ((Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == 0) &&
                          ((Flags & DCREF_FLAG_ANSI) == 0))
                    {
                        EtwpProcessExternalEvent(Wnode,
                                                WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                    }
                    CompositeFlags |= Flags;
                }

                //
                // If there is any demand for ANSI events then convert
                // event to ansi and send it off
                if (CompositeFlags & DCREF_FLAG_ANSI)
                {
                    //
                    // Caller wants ansi notification - convert
                    // instance names
                    //
                    EtwpConvertEventToAnsi(Wnode);

                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        EtwpEnterPMCritSection();
                        Flags = GNEntry->Notifyee[i].Flags;
                        DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                        DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                        EtwpLeavePMCritSection();
                        if ((DeliveryInfo != NULL) &&
                            ((Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == 0) &&
                            (Flags & DCREF_FLAG_ANSI))
                        {
                            EtwpProcessExternalEvent(Wnode,
                                                     WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                        }
                    }
                }
                EtwpUnlockCB(GNEntry);
                EtwpDereferenceGNEntry(GNEntry);
            }
        }

#if DBG
        LastWnode = Wnode;
#endif
        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
        CurrentOffset += Linkage;
        
        if (CurrentOffset >= BufferSize)
        {
            EtwpDebugPrint(("WMI: Invalid linkage field 0x%x in WNODE %p. Buffer %p, Length 0x%x\n",
                            Linkage, LastWnode, Buffer, BufferSize));
            Linkage = 0;
        }
    }
}

LIST_ENTRY EtwpGNHead = {&EtwpGNHead, &EtwpGNHead};
PLIST_ENTRY EtwpGNHeadPtr = &EtwpGNHead;

BOOLEAN
EtwpDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    )
{
    ULONG RefCount;
    BOOLEAN IsFreed;
#if DBG
    ULONG i;
#endif

    EtwpEnterPMCritSection();
    RefCount = InterlockedDecrement(&GNEntry->RefCount);
    if (RefCount == 0)
    {
        RemoveEntryList(&GNEntry->GNList);
        EtwpLeavePMCritSection();
#if DBG
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            EtwpAssert(GNEntry->Notifyee[i].DeliveryInfo == NULL);
        }
#endif
        if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
        {
            EtwpFree(GNEntry->Notifyee);
        }

        EtwpFreeGNEntry(GNEntry);
        IsFreed = TRUE;
    } else {
        IsFreed = FALSE;
        EtwpLeavePMCritSection();
    }
    return(IsFreed);
}

PGUIDNOTIFICATION
EtwpFindAndLockGuidNotification(
    LPGUID Guid,
    BOOLEAN bLock
    )
/*++

Routine Description:

        This routine finds the GUIDNOTIFICATION entry for the given Guid. 
        The bLock argument is used to synchronize Unregistering threads
        with the Callback or Pump threads. We want to avoid the situation
        where the Unregistering thread unloading the callback code before
        the callback function is called. This is done by blocking the 
        Unregister call whenever there is a callback function in progress.

        If the bLock is TRUE, the InProgressEvent will be reset. This will
        block any other threads trying to cleanup the GNEntry. 

        Note: If bLock is TRUE, then the caller must set the InProgressEvent 
              when it is safe to do so. (ie., after a callback). 
        
Arguments:

Return Value:

--*/
{
    PLIST_ENTRY GNList;
    PGUIDNOTIFICATION GNEntry;

    EtwpEnterPMCritSection();
    GNList = EtwpGNHead.Flink;
    while (GNList != &EtwpGNHead)
    {
        GNEntry = (PGUIDNOTIFICATION)CONTAINING_RECORD(GNList,
                                    GUIDNOTIFICATION,
                                    GNList);

        if (IsEqualGUID(Guid, &GNEntry->Guid))
        {
            EtwpAssert(GNEntry->RefCount > 0);
            EtwpReferenceGNEntry(GNEntry);

            //
            // If bLock is TRUE, then we need to reset the 
            // event so that any other thread looking up the event 
            // blocks.  The caller of this routine is responsible 
            // for setting the Event once the callback is done. 
            //

            if (bLock) {
                EtwpLockCB(GNEntry);
            }

            EtwpLeavePMCritSection();
            return(GNEntry);
        }
        GNList = GNList->Flink;
    }
    EtwpLeavePMCritSection();
    return(NULL);
}

ULONG
EtwpAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG NewCount;
    PNOTIFYEE NewNotifyee;
    BOOLEAN AllFull;
    ULONG EmptySlot = 0;
    ULONG i;
#if DBG
    CHAR s[MAX_PATH];
#endif

    EtwpEnterPMCritSection();
    GNEntry = EtwpFindAndLockGuidNotification(Guid, FALSE);

    if (GNEntry == NULL)
    {
        GNEntry = EtwpAllocGNEntry();
        if (GNEntry == NULL)
        {
            EtwpLeavePMCritSection();
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        memset(GNEntry, 0, sizeof(GUIDNOTIFICATION));

        GNEntry->Guid = *Guid;
        GNEntry->RefCount = 1;
        GNEntry->NotifyeeCount = STATIC_NOTIFYEE_COUNT;
        GNEntry->Notifyee = GNEntry->StaticNotifyee;
        InsertHeadList(&EtwpGNHead, &GNEntry->GNList);
    }

    //
    // We have got a GUIDNOTIFICATION by newly allocating one or by finding
    // an existing one.
    AllFull = TRUE;
    for (i = 0; i < GNEntry->NotifyeeCount; i++)
    {
        if ((GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo) &&
            (! EtwpIsNotifyeePendingClose(&GNEntry->Notifyee[i])))
        {
            EtwpDebugPrint(("WMI: Duplicate Notification Enable for guid %s, 0x%x\n",
                             GuidToStringA(s, MAX_PATH, Guid), DeliveryInfo));
            EtwpLeavePMCritSection();
            EtwpDereferenceGNEntry(GNEntry);
            return(ERROR_WMI_ALREADY_ENABLED);
        } else if (AllFull && (GNEntry->Notifyee[i].DeliveryInfo == NULL)) {
            EmptySlot = i;
            AllFull = FALSE;
        }
    }

    if (! AllFull)
    {
        GNEntry->Notifyee[EmptySlot].DeliveryInfo = DeliveryInfo;
        GNEntry->Notifyee[EmptySlot].DeliveryContext = DeliveryContext;
        GNEntry->Notifyee[EmptySlot].Flags = Flags;
        GNEntry->Notifyee[EmptySlot].GuidHandle = GuidHandle;
        EtwpLeavePMCritSection();
        return(ERROR_SUCCESS);
    }

    //
    // All Notifyee structs are full so allocate a new chunk
    NewCount = GNEntry->NotifyeeCount * 2;
    NewNotifyee = EtwpAlloc(NewCount * sizeof(NOTIFYEE));
    if (NewNotifyee == NULL)
    {
        EtwpLeavePMCritSection();
        EtwpDereferenceGNEntry(GNEntry);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(NewNotifyee, 0, NewCount * sizeof(NOTIFYEE));
    memcpy(NewNotifyee, GNEntry->Notifyee,
                              GNEntry->NotifyeeCount * sizeof(NOTIFYEE));

    if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
    {
        EtwpFree(GNEntry->Notifyee);
    }

    GNEntry->Notifyee = NewNotifyee;
    GNEntry->NotifyeeCount = NewCount;

    GNEntry->Notifyee[i].DeliveryInfo = DeliveryInfo;
    GNEntry->Notifyee[i].DeliveryContext = DeliveryContext;
    GNEntry->Notifyee[i].Flags = Flags;
    GNEntry->Notifyee[i].GuidHandle = GuidHandle;
    EtwpLeavePMCritSection();
    return(ERROR_SUCCESS);

}

BOOLEAN EtwpCloseNotifyee(
    PNOTIFYEE Notifyee,
    PGUIDNOTIFICATION GuidNotification
    )
{
    //
    // This routine assumes the PM Criticial Section is held
    //
    
    EtwpCloseHandle(Notifyee->GuidHandle);
    Notifyee->DeliveryInfo = NULL;
    Notifyee->Flags = 0;
    
    return(EtwpDereferenceGNEntry(GuidNotification));
}

void EtwpMarkPendingCloseNotifyee(
    PNOTIFYEE Notifyee
#if DBG
    , LPGUID Guid
#endif
    )
{
    WMIMARKASCLOSED MarkAsClosed;
    ULONG ReturnSize;
    NTSTATUS Status;
#if DBG
    char s[MAX_PATH];
#endif

    //
    // This routine assumes the PM Critical Section is held
    //
    
    //
    // The pump thread is running we need to
    // sync with it. Mark the handle as pending
    // closure.  Call into the kernel and inform it
    // that the handle should no longer receive
    // events. The pump thread will do the dirty
    // work of closing the handle. Also
    // the pump thread will unreference the GNEntry so that
    // it doesn't go away until after the handle is closed.
    // Lastly the pump thread needs to reset the
    // DeliveryInfo memory to NULL so that the slot is not
    // reused.
    //

    Notifyee->Flags |= NOTIFICATION_FLAG_PENDING_CLOSE;

    WmipSetHandle3264(MarkAsClosed.Handle, Notifyee->GuidHandle);                       
    Status = EtwpSendWmiKMRequest(NULL,
                         IOCTL_WMI_MARK_HANDLE_AS_CLOSED,
                         &MarkAsClosed,
                         sizeof(MarkAsClosed),
                         NULL,
                         0,
                         &ReturnSize,
                         NULL);
//  
// Only enable this for testing. If the request fails then it is not a
// fatal situaion
//
//    EtwpAssert(Status == ERROR_SUCCESS);
}


ULONG
EtwpRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG i;
    ULONG Count;
    ULONG Status;

    GNEntry = EtwpFindAndLockGuidNotification(Guid, FALSE);

    if (GNEntry != NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        Count = 0;

        EtwpEnterPMCritSection();
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            if (GNEntry->Notifyee[i].DeliveryInfo != NULL)
            {
                if ((GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo) &&
                    ( ! EtwpIsNotifyeePendingClose(&GNEntry->Notifyee[i])) &&
                    (Status != ERROR_SUCCESS))
                {
                    if ((EtwpPumpState == EVENT_PUMP_ZERO) ||
                        (EtwpPumpState == EVENT_PUMP_IDLE) )
                    {
                        //
                        // If the pump thread is not running then we
                        // don't need to worry about synchronizing with
                        // it. We can go ahead and close the handle and
                        // clean up the GNLIST
                        //
                        EtwpCloseNotifyee(&GNEntry->Notifyee[i],
                                         GNEntry);
                    } else {
                        //
                        // Since the pump thread is running we need to
                        // postpone the actual handle closure to the
                        // pump thread. 
                        //
                        EtwpMarkPendingCloseNotifyee(&GNEntry->Notifyee[i]
#if DBG
                                                    , Guid
#endif
                            );


                    }

                    Status = ERROR_SUCCESS;
                    break;
                } else if (! EtwpIsNotifyeePendingClose(&GNEntry->Notifyee[i])) {
                    Count++;
                }
            }
        }
        

        //
        // This hack will allow removal from the GNLIST in the case that the
        // passed DeliveryInfo does not match the DeliveryInfo in the GNEntry.
        // This is allowed only when there is only one NOTIFYEE in the GNENTRY
        // In the past we only supported one notifyee per guid in a process
        // and so we allowed the caller not to pass a valid DeliveryInfo when
        // unrefistering.

        if ((Status != ERROR_SUCCESS) &&
            (GNEntry->NotifyeeCount == STATIC_NOTIFYEE_COUNT) &&
            (Count == 1))
        {
            if ((GNEntry->Notifyee[0].DeliveryInfo != NULL) &&
                ( ! EtwpIsNotifyeePendingClose(&GNEntry->Notifyee[0])))
            {
                if ((EtwpPumpState == EVENT_PUMP_ZERO) ||
                    (EtwpPumpState == EVENT_PUMP_IDLE) )
                {
                    EtwpCloseNotifyee(&GNEntry->Notifyee[0],
                                     GNEntry);
                } else {
                    //
                    // Since the pump thread is running we need to
                    // postpone the actual handle closure to the
                    // pump thread. 

                    //
                    EtwpMarkPendingCloseNotifyee(&GNEntry->Notifyee[0]
#if DBG
                                                    , Guid
#endif
                                                );



                }
                
                Status = ERROR_SUCCESS;
                
            } else if ((GNEntry->Notifyee[1].DeliveryInfo != NULL) &&
                ( ! EtwpIsNotifyeePendingClose(&GNEntry->Notifyee[1]))) {
                if ((EtwpPumpState == EVENT_PUMP_ZERO) ||
                    (EtwpPumpState == EVENT_PUMP_IDLE) )
                {
                    EtwpCloseNotifyee(&GNEntry->Notifyee[1],
                                     GNEntry);
                } else {
                    //
                    // Since the pump thread is running we need to
                    // postpone the actual handle closure to the
                    // pump thread. 

                    //
                    EtwpMarkPendingCloseNotifyee(&GNEntry->Notifyee[1]
#if DBG
                                                    , Guid
#endif
                                                );


                }
                
                Status = ERROR_SUCCESS;
            }
        }

        EtwpLeavePMCritSection();

        //
        // Before Dereferencing the GNEntry make sure there is no 
        // callback in progress. If this Event is set then, it is safe
        // to exit. If it is not set we need to wait for the callback thread
        // to finish the callback and set this event. 
        //
        if (GNEntry->bInProgress) {
#if DBG
            EtwpDebugPrint(("WMI: Waiting on GNEntry %x %s %d\n", 
                           GNEntry, __FILE__, __LINE__)); 
#endif

            NtWaitForSingleObject(EtwpCBInProgressEvent, 0, NULL);
#if DBG
            EtwpDebugPrint(("WMI: Done Waiting for GNEntry %x %s %d\n", 
                       GNEntry, __FILE__, __LINE__)); 
#endif
        }

        EtwpDereferenceGNEntry(GNEntry);
    } else {
        Status = ERROR_WMI_ALREADY_DISABLED;
    }

    return(Status);
}

PVOID EtwpAllocDontFail(
    ULONG SizeNeeded,
    BOOLEAN *HoldCritSect
    )
{
    PVOID Buffer;

    do
    {
        Buffer = EtwpAlloc(SizeNeeded);
        if (Buffer != NULL)
        {
            return(Buffer);
        }

        //
        // Out of memory so we'll EtwpSleep and hope that things will get
        // better later
        //
        if (*HoldCritSect)
        {
            //
            // If we are holding the PM critical section then we need
            // to release it. The caller is going to need to check if
            // the critical section was released and if so then deal
            // with it
            //
            *HoldCritSect = FALSE;
            EtwpLeavePMCritSection();
        }
        EtwpSleep(250);
    } while (1);
}

void EtwpProcessEventBuffer(
    PUCHAR Buffer,
    ULONG ReturnSize,
    PUCHAR *PrimaryBuffer,
    ULONG *PrimaryBufferSize,
    PUCHAR *BackupBuffer,
    ULONG *BackupBufferSize,
    BOOLEAN ReallocateBuffers
    )
{
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG SizeNeeded;
    BOOLEAN HoldCritSection;

    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
    {
        //
        // The buffer passed to kernel mode was too small
        // so we need to make it larger and then try the
        // request again.
        //
        if (ReallocateBuffers)
        {
            //
            // Only do this if the caller is prepared for us to
            // allocate a new set of buffers
            //
            SizeNeeded = WnodeTooSmall->SizeNeeded;

            EtwpAssert(*PrimaryBuffer != NULL);
            EtwpFree(*PrimaryBuffer);
            HoldCritSection = FALSE;
            *PrimaryBuffer = EtwpAllocDontFail(SizeNeeded, &HoldCritSection);
            *PrimaryBufferSize = SizeNeeded;

            EtwpAssert(*BackupBuffer != NULL);
            EtwpFree(*BackupBuffer);
            HoldCritSection = FALSE;
            *BackupBuffer = EtwpAllocDontFail(SizeNeeded, &HoldCritSection);
            *BackupBufferSize = SizeNeeded;
        }
    } else if (ReturnSize >= sizeof(WNODE_HEADER)) {
        //
        // The buffer return from kernel looks good so go and
        // deliver the events returned
        //
        EtwpDeliverAllEvents(Buffer, ReturnSize);
    } else {
        //
        // If this completes successfully then we expect a decent size, but
        // we didn't get one
        //
        EtwpDebugPrint(("WMI: Bad size 0x%x returned for notification query %p\n",
                                  ReturnSize, Buffer));

        EtwpAssert(FALSE);
    }
}


ULONG
EtwpReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    )
{
    ULONG Status;
    ULONG ReturnSize;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG i;
    ULONG Linkage;

    EtwpInitProcessHeap();

    if (HandleCount == 0)
    {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          ((HandleCount-1) * sizeof(HANDLE3264));

    RcvNotification = EtwpAlloc(RcvNotificationSize);

    if (RcvNotification != NULL)
    {

        Status = ERROR_SUCCESS;
        RcvNotification->Action = Action;
        WmipSetPVoid3264(RcvNotification->UserModeCallback, UserModeCallback);
        WmipSetHandle3264(RcvNotification->UserModeProcess, ProcessHandle);
        RcvNotification->HandleCount = HandleCount;
        for (i = 0; i < HandleCount; i++)
        {
            try
            {
                RcvNotification->Handles[i].Handle = HandleList[i];
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALID_PARAMETER;
                break;
            }
        }

        BufferSize = 0x1000;
        Status = ERROR_INSUFFICIENT_BUFFER;
        while (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            Buffer = EtwpAlloc(BufferSize);
            if (Buffer != NULL)
            {
                Status = EtwpSendWmiKMRequest(NULL,
                                          IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                          RcvNotification,
                                          RcvNotificationSize,
                                          Buffer,
                                          BufferSize,
                                          &ReturnSize,
                                           NULL);

                if (Status == ERROR_SUCCESS)
                {
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                    {
                        //
                        // The buffer passed to kernel mode was too small
                        // so we need to make it larger and then try the
                        // request again
                        //
                        BufferSize = WnodeTooSmall->SizeNeeded;
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        //
                        // We got a buffer of notifications so lets go
                        // process them and callback the caller
                        //
                        Wnode = (PWNODE_HEADER)Buffer;
                        do
                        {
                            Linkage = Wnode->Linkage;
                            Wnode->Linkage = 0;

                            if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                            {
                                //
                                // Go and process the internal
                                // notification
                                //
                                EtwpInternalNotification(Wnode,
                                                         Callback,
                                                         DeliveryContext,
                                                         IsAnsi);
                            } else {
                                if (IsAnsi)
                                {
                                    //
                                    // Caller wants ansi notification - convert
                                    // instance names
                                    //
                                    EtwpConvertEventToAnsi(Wnode);
                                }

                                //
                                // Now go and deliver this event
                                //
                                EtwpExternalNotification(Callback,
                                                         DeliveryContext,
                                                         Wnode);
                            }
                            Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
                        } while (Linkage != 0);
                    }
                }
                EtwpFree(Buffer);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        EtwpFree(RcvNotification);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    EtwpSetLastError(Status);
    return(Status);
}


void EtwpMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    EtwpAssert((Wnode->Flags & WNODE_FLAG_INTERNAL) == 0);
    
    if (Callback == NULL)
    {
        //
        // This event needs to be sent to all consumers
        //
        EtwpDeliverAllEvents((PUCHAR)Wnode,
                             Wnode->BufferSize);
    } else {
        //
        // This event is targetted at a specific consumer
        //
        if (IsAnsi)
        {
            //
            // Caller wants ansi notification - convert
            // instance names
            //
            EtwpConvertEventToAnsi(Wnode);        
        }
        
        //
        // Now go and deliver this event
        //
        EtwpExternalNotification(Callback,
                                 DeliveryContext,
                                 Wnode);        
    }
}

void EtwpClosePendingHandles(
    )
{
    PLIST_ENTRY GuidNotificationList, GuidNotificationListNext;
    PGUIDNOTIFICATION GuidNotification;
    ULONG i;
    PNOTIFYEE Notifyee;

    EtwpEnterPMCritSection();

    GuidNotificationList = EtwpGNHead.Flink;
    while (GuidNotificationList != &EtwpGNHead)
    {
        GuidNotification = CONTAINING_RECORD(GuidNotificationList,
                                             GUIDNOTIFICATION,
                                             GNList);

        GuidNotificationListNext = GuidNotificationList->Flink;
        
        for (i = 0; i < GuidNotification->NotifyeeCount; i++)
        {
            Notifyee = &GuidNotification->Notifyee[i];

            if ((Notifyee->DeliveryInfo != NULL) &&
                (EtwpIsNotifyeePendingClose(Notifyee)))
            {
                //
                // This notifyee is pending closure so we clean it up
                // now. We need to close the handle, reset the
                // DeliveryInfo field and unreference the
                // GuidNotification. Note that unreferencing may cause
                // the GuidNotification to go away
                //
                if (EtwpCloseNotifyee(Notifyee,
                                      GuidNotification))
                {

                    //
                    // GuidNotification has been removed from the list.
                    // We jump out of all processing of this
                    // GuidNotification and move onto the next one
                    //
                    break;
                }
            }
        }
        GuidNotificationList = GuidNotificationListNext;
    }
    
    EtwpLeavePMCritSection();
}

void EtwpBuildReceiveNotification(
    PUCHAR *BufferPtr,
    ULONG *BufferSizePtr,
    ULONG *RequestSize,
    ULONG Action,
    HANDLE ProcessHandle
    )
{
    ULONG GuidCount;
    PUCHAR Buffer;
    ULONG BufferSize;
    PLIST_ENTRY GuidNotificationList;
    PGUIDNOTIFICATION GuidNotification;
    PWMIRECEIVENOTIFICATION ReceiveNotification;
    ULONG SizeNeeded;
    ULONG i;
    PNOTIFYEE Notifyee;
    ULONG ReturnSize;
    ULONG Status;
    BOOLEAN HoldCritSection;
    BOOLEAN HaveGroupHandle;

    Buffer = *BufferPtr;
    BufferSize = *BufferSizePtr;
    ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

TryAgain:   
    GuidCount = 0;
    SizeNeeded = FIELD_OFFSET(WMIRECEIVENOTIFICATION, Handles);

    //
    // Loop over all guid notifications and build an ioctl request for
    // all of them
    //
    EtwpEnterPMCritSection();

    GuidNotificationList = EtwpGNHead.Flink;
    while (GuidNotificationList != &EtwpGNHead)
    {
        GuidNotification = CONTAINING_RECORD(GuidNotificationList,
                                             GUIDNOTIFICATION,
                                             GNList);

        HaveGroupHandle = FALSE;
        for (i = 0; i < GuidNotification->NotifyeeCount; i++)
        {
            Notifyee = &GuidNotification->Notifyee[i];

            if ((Notifyee->DeliveryInfo != NULL) &&
                ( ! EtwpIsNotifyeePendingClose(Notifyee)))
            {
                if (((! HaveGroupHandle) ||
                     ((Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT) == 0)))
                {
                    //
                    // If there is an active handle in the notifyee slot
                    // and we either have not already inserted the group
                    // handle for this guid or the slot is not part of the
                    // guid group, then we insert the handle into the list
                    //
                    SizeNeeded += sizeof(HANDLE3264);
                    if (SizeNeeded > BufferSize)
                    {
                        //
                        // We need to grow the size of the buffer. Alloc a
                        // bigger buffer, copy over
                        //
                        BufferSize *= 2;
                        HoldCritSection = TRUE;
                        Buffer = EtwpAllocDontFail(BufferSize, &HoldCritSection);

                        memcpy(Buffer, ReceiveNotification, *BufferSizePtr);

                        EtwpFree(*BufferPtr);

                        *BufferPtr = Buffer;
                        *BufferSizePtr = BufferSize;
                        ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

                        if (! HoldCritSection)
                        {
                            //
                            // Critical section was released within
                            // EtwpAllocDontFail since we had to block. So
                            // everything could have changed. We need to go
                            // back and start over again
                            //
                            goto TryAgain;
                        }                   
                    }

                    WmipSetHandle3264(ReceiveNotification->Handles[GuidCount],
                                      Notifyee->GuidHandle);
                    GuidCount++;
                    if (Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT)
                    {
                        //
                        // This was a guid group handle and we did insert
                        // it into the list so we don't want to insert it
                        // again
                        //
                        HaveGroupHandle = TRUE;
                    }
                }
            }
        }
        GuidNotificationList = GuidNotificationList->Flink;
    }

    EtwpLeavePMCritSection();
    ReceiveNotification->HandleCount = GuidCount;
    ReceiveNotification->Action = Action;
    WmipSetPVoid3264(ReceiveNotification->UserModeCallback, EtwpEventPumpFromKernel);
    WmipSetHandle3264(ReceiveNotification->UserModeProcess, ProcessHandle);
    *RequestSize = SizeNeeded;  
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif
ULONG EtwpEventPump(
    PVOID Param
    )
{
    LPOVERLAPPED ActiveOverlapped, DeadOverlapped;
    LPOVERLAPPED PrimaryOverlapped;
    LPOVERLAPPED BackupOverlapped;
    PUCHAR ActiveBuffer, DeadBuffer;
    ULONG ActiveBufferSize, DeadBufferSize;
    PUCHAR PrimaryBuffer, BackupBuffer;
    ULONG PrimaryBufferSize, BackupBufferSize;
    ULONG ReturnSize=0; 
    ULONG DeadReturnSize=0;
    ULONG Status, WaitStatus;
    HANDLE HandleArray[2];
    ULONG RequestSize;

    //
    // We need to hold off on letting the thread into the routine until
    // the previous pump thread has had a chance to finish. This could
    // occur if a GN is added/removed while the previous thread is
    // finishing up or if an event is received as the previous thread
    // is finishing up.
    //
    while (EtwpIsPumpStopping())
    {
        //
        // wait 50ms for the previous thread to finish up
        //
        EtwpSleep(50);
    }
    
    //
    // Next thing to do is to make sure that another pump thread isn't
    // already running. This can happen in the case that both a GN is
    // added or removed and an event reaches kernel and the kernel
    // creates a new thread too. Right here we only let one of them
    // win.
    //
    EtwpEnterPMCritSection();
    if ((EtwpPumpState != EVENT_PUMP_IDLE) &&
        (EtwpPumpState != EVENT_PUMP_ZERO))
    {
        EtwpLeavePMCritSection();

        EtwpExitThread(0);
    } else {
        EtwpPumpState = EVENT_PUMP_RUNNING;
        EtwpNewPumpThreadPending = FALSE;
        EtwpLeavePMCritSection();
    }

    //
    // Make sure we have all resources we'll need to pump out events
    // since there is no way that we can return an error to the original
    // caller since we are on a new thread
    //
    EtwpAssert(EtwpEventDeviceHandle != NULL);
    EtwpAssert(EtwpPumpCommandEvent != NULL);
    EtwpAssert(EtwpMyProcessHandle != NULL);
    EtwpAssert(EtwpEventBuffer1 != NULL);
    EtwpAssert(EtwpEventBuffer2 != NULL);
    EtwpAssert(EtwpOverlapped1.hEvent != NULL);
    EtwpAssert(EtwpOverlapped2.hEvent != NULL);

    ActiveOverlapped = NULL;

    PrimaryOverlapped = &EtwpOverlapped1;
    PrimaryBuffer = EtwpEventBuffer1;
    PrimaryBufferSize = EtwpEventBufferSize1;

    BackupOverlapped = &EtwpOverlapped2;
    BackupBuffer = EtwpEventBuffer2;
    BackupBufferSize = EtwpEventBufferSize2;

    HandleArray[0] = EtwpPumpCommandEvent;

    while(TRUE)
    {
        //
        // Build request to receive events for all guids that are
        // registered
        //
        EtwpEnterPMCritSection();
        if (IsListEmpty(&EtwpGNHead))
        {
            //
            // There are no events to be received so we cancel any
            // outstanding requests and quietly exit this thread. Note
            // that once we leave the critsec there could be another
            // pump thread running so all we can do after that is exit.
            //

            EtwpCancelIo(EtwpEventDeviceHandle);

            
            //
            // Enter the idle state which implies that all of the
            // pump resources stay allocated when the thread is not
            // running
            //
            EtwpEventBuffer1 = PrimaryBuffer;
            EtwpEventBufferSize1 = PrimaryBufferSize;
            EtwpEventBuffer2 = BackupBuffer;
            EtwpEventBufferSize2 = BackupBufferSize;
                        
            EtwpPumpState = EVENT_PUMP_IDLE;
            EtwpLeavePMCritSection();
            
            EtwpExitThread(0);
        }
        EtwpLeavePMCritSection();

        if (ActiveOverlapped != NULL)
        {
            //
            // If there was a previously outstanding request then
            // we remember it and switch to the backup overlapped and
            // and data buffer
            //
            DeadOverlapped = ActiveOverlapped;
            DeadBuffer = ActiveBuffer;
            DeadBufferSize = ActiveBufferSize;

            //
            // The request being mooted should be the current primary
            //
            EtwpAssert(DeadOverlapped == PrimaryOverlapped);
            EtwpAssert(DeadBuffer == PrimaryBuffer);

            //
            // Use the backup request as the new primary
            //
            EtwpAssert(BackupOverlapped != NULL);
            EtwpAssert(BackupBuffer != NULL);

            PrimaryOverlapped = BackupOverlapped;
            PrimaryBuffer = BackupBuffer;
            PrimaryBufferSize = BackupBufferSize;

            BackupOverlapped = NULL;
            BackupBuffer = NULL;
        } else {
            //
            // If there is no outstanding request then we don't worry about
            // it
            //
            DeadOverlapped = NULL;
        }

        //
        // Build and send the request down to kernel to receive events
        //

RebuildRequest:     
        //
        // Make sure any handles that are pending closure are closed
        //
        EtwpClosePendingHandles();      
        
        EtwpBuildReceiveNotification(&PrimaryBuffer,
                                     &PrimaryBufferSize,
                                     &RequestSize,
                                     EtwpIsPumpStopping() ? RECEIVE_ACTION_CREATE_THREAD :
                                                            RECEIVE_ACTION_NONE,
                                     EtwpMyProcessHandle);

        ActiveOverlapped = PrimaryOverlapped;
        ActiveBuffer = PrimaryBuffer;
        ActiveBufferSize = PrimaryBufferSize;

        Status = EtwpSendWmiKMRequest(EtwpEventDeviceHandle,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      ActiveBuffer,
                                      RequestSize,
                                      ActiveBuffer,
                                      ActiveBufferSize,
                                      &ReturnSize,
                                      ActiveOverlapped);

        if (DeadOverlapped != NULL)
        {
            if ((Status != ERROR_SUCCESS) &&
                (Status != ERROR_IO_PENDING) &&
                (Status != ERROR_OPERATION_ABORTED))
            {
                //
                // There was a previous request which won't be cleared
                // unless the new request returns pending, cancelled
                // or success. So if the new request returns something
                // else then we need to retry the request
                //
                EtwpDebugPrint(("WMI: Event Poll error %d\n", Status));
                EtwpSleep(100);
                goto RebuildRequest;
            }

            //
            // The new request should have caused the old one to
            // be completed
            //
            if (EtwpGetOverlappedResult(EtwpEventDeviceHandle,
                                    DeadOverlapped,
                                    &DeadReturnSize,
                                    TRUE))
            {
                //
                // The dead request did succeed and was not failed by
                // the receipt of the new request. This is a unlikely
                // race condition where the requests crossed paths. So we
                // need to process the events returned in the dead request.
                // Now if the buffer returned was a WNODE_TOO_SMALL we want
                // to ignore it at this point since we are not at a
                // good position to reallocate the buffers - the
                // primary buffer is already attached to the new
                // request. That request is also going to return a
                // WNODE_TOO_SMALL and in the processing of that one we will
                // grow the buffers. So it is safe to ignore here.
                // However we will still need to dispatch any real
                // events received as they have been purged from KM.
                //
                if (DeadReturnSize != 0)
                {
                    EtwpProcessEventBuffer(DeadBuffer,
                                           DeadReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           FALSE);
                } else {
                    EtwpAssert(EtwpIsPumpStopping());
                }
            }

            //
            // Now make the completed request the backup request
            //
            EtwpAssert(BackupOverlapped == NULL);
            EtwpAssert(BackupBuffer == NULL);

            BackupOverlapped = DeadOverlapped;
            BackupBuffer = DeadBuffer;
            BackupBufferSize = DeadBufferSize;
        }

        if (Status == ERROR_IO_PENDING)
        {
            //
            // if the ioctl pended then we wait until either an event
            // is returned or a command needs processed
            //
            HandleArray[1] = ActiveOverlapped->hEvent;
            WaitStatus = EtwpWaitForMultipleObjectsEx(2,
                                              HandleArray,
                                              FALSE,
                                              EtwpEventNotificationWait,
                                              TRUE);
        } else {
            //
            // the ioctl completed immediately so we fake out the wait
            //
            WaitStatus = WAIT_OBJECT_0 + 1;
        }

        if (WaitStatus == WAIT_OBJECT_0 + 1)
        {
            if (Status == ERROR_IO_PENDING)
            {
                if (EtwpGetOverlappedResult(EtwpEventDeviceHandle,
                                        ActiveOverlapped,
                                        &ReturnSize,
                                        TRUE))
                {
                    Status = ERROR_SUCCESS;
                } else {
                    Status = EtwpGetLastError();
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                //
                // We received some events from KM so we want to go and
                // process them. If we got a WNODE_TOO_SMALL then the
                // primary and backup buffers will get reallocated with
                // the new size that is needed.
                //

                if (ReturnSize != 0)
                {
                    EtwpProcessEventBuffer(ActiveBuffer,
                                           ReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           TRUE);
                    //
                    // In the case that we are shutting down the event
                    // pump and the buffer passed to clear out all of
                    // the events was too small we need to call back
                    // down to the kernel to get the rest of the events
                    // since we cannot exit the thread with events that
                    // are not delivered. The kernel will not set the
                    // flag that a new thread is needed unless the irp
                    // clears all outstanding events
                    //
                } else {
                    EtwpAssert(EtwpIsPumpStopping());
                    if (EtwpIsPumpStopping())
                    {
                        //
                        // The irp just completed should have not only
                        // just cleared all events out of kernel mode
                        // but also setup flags that new events should
                        // cause a new pump thread to be created. So
                        // there may be a new pump thread already created
                        // Also note there could be yet
                        // another event pump thread that was created
                        // if a GN was added or removed. Once we set
                        // the pump state to IDLE we are off to the
                        // races (See code at top of function)
                        //
                        EtwpEnterPMCritSection();
                        
                        EtwpPumpState = EVENT_PUMP_IDLE;
                        EtwpEventBuffer1 = PrimaryBuffer;
                        EtwpEventBufferSize1 = PrimaryBufferSize;
                        EtwpEventBuffer2 = BackupBuffer;
                        EtwpEventBufferSize2 = BackupBufferSize;

                        //
                        // Before shutting down the pump we need to
                        // close any handles that are pending closure
                        //
                        EtwpClosePendingHandles();
                        
                        EtwpLeavePMCritSection();
                        
                        EtwpExitThread(0);
                    }

                }
                
            } else {
                //
                // For some reason the request failed. All we can do is
                // wait a bit and hope that the problem will clear up.
                // If we are stopping the thread we still need to wait
                // and try again as all events may not have been
                // cleared from the kernel. We really don't know if the
                // irp even made it to the kernel.
                //
                EtwpDebugPrint(("WMI: [%x - %x] Error %d from Ioctl\n",
                                EtwpGetCurrentProcessId(), EtwpGetCurrentThreadId(),
                                Status));
                EtwpSleep(250);
            }

            //
            // Flag that there is no longer a request outstanding
            //
            ActiveOverlapped = NULL;
        } else if (WaitStatus == STATUS_TIMEOUT) {
            //
            // The wait for events timed out so we go into the thread
            // stopping state to indicate that we are going to terminate 
            // the thread once all events are cleared out of kernel. At
            // this point we are commited to stopping the thread. If any 
            // GN are added/removed after going into the stopping state, 
            // a new (and suspended) thread will be created. Right
            // before exiting we check if that thread is pending and if
            // so resume it.
            //
            EtwpEnterPMCritSection();
            EtwpPumpState = EVENT_PUMP_STOPPING;
            EtwpLeavePMCritSection();
        }
    }

    //
    // Should never break out of infinite loop
    //
    EtwpAssert(FALSE);
        
    EtwpExitThread(0);
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


ULONG EtwpEventPumpFromKernel(
    PVOID Param
    )
{
    //
    // Note that we MUST call ExitThread when we want to shutdown the
    // thread and not return() since the thread has been created by
    // kernel mode and there is nothing on the stack to return to, so
    // we'd just AV
    //


    //
    // Call into ntdll so that it marks our thread as a CSR thread
    //
    CsrNewThread();
    
    EtwpEnterPMCritSection();
    if ((EtwpNewPumpThreadPending == FALSE) &&
        (EtwpPumpState == EVENT_PUMP_IDLE) ||
        (EtwpPumpState == EVENT_PUMP_STOPPING))
    {
        //
        // If the pump is currently idle or stopping and there is not
        // another pump thread that is pending we want our thread
        // to be the one that gets the pump going again. We mark the
        // that there is a pump thread pending which means that no more 
        // pump threads will be created when adding/removing GN 
        // and any pump threads created by kernel will just exit quickly
        //
        EtwpNewPumpThreadPending = TRUE;
        EtwpLeavePMCritSection();

        //
        // ISSUE: We cannot call EtwpEventPump with Param (ie, the
        // parameter that is passed to this function) because when the
        // thread is created by a Win64 kernel on a x86 app running
        // under win64, Param is not actually passed on the stack since
        // the code that creates the context forgets to do so
        //
        EtwpExitThread(EtwpEventPump(0));
    }
    
    EtwpLeavePMCritSection();
    
    EtwpExitThread(0);
    return(0);
}

ULONG EtwpEstablishEventPump(
    )
{
#if DBG
    #define INITIALEVENTBUFFERSIZE 0x38
#else
    #define INITIALEVENTBUFFERSIZE 0x1000
#endif
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    ULONG Status;
    BOOL b;


#if DBG
    //
    // On checked builds update the length of time to wait before a
    // pump thread times out
    //
    EtwpGetRegistryValue(PumpTimeoutRegValueText,
                         &EtwpEventNotificationWait);
#endif
    
    //
    // Make sure the event pump thread is running. We check both the
    // pump state and that the device handle is not created since there
    // is a window after the handle is created and the thread starts
    // running and changes the pump state
    //
    EtwpEnterPMCritSection();

    if ((EtwpPumpState == EVENT_PUMP_ZERO) &&
        (EtwpEventDeviceHandle == NULL))
    {
        //
        // Not only is pump not running, but the resources for it
        // haven't been allocated
        //
        EtwpAssert(EtwpPumpCommandEvent == NULL);
        EtwpAssert(EtwpMyProcessHandle == NULL);
        EtwpAssert(EtwpOverlapped1.hEvent == NULL);
        EtwpAssert(EtwpOverlapped2.hEvent == NULL);
        EtwpAssert(EtwpEventBuffer1 == NULL);
        EtwpAssert(EtwpEventBuffer2 == NULL);

        //
        // Preallocate all of the resources that the event pump will need
        // so that it has no excuse to fail
        //

        EtwpEventDeviceHandle = EtwpCreateFileW(WMIDataDeviceName_W,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_OVERLAPPED,
                              NULL);

        if (EtwpEventDeviceHandle == INVALID_HANDLE_VALUE)
        {
            Status = EtwpGetLastError();
            goto Cleanup;
        }

        EtwpPumpCommandEvent = EtwpCreateEventW(NULL, FALSE, FALSE, NULL);
        if (EtwpPumpCommandEvent == NULL)
        {
            Status = EtwpGetLastError();
            goto Cleanup;
        }

        b = EtwpDuplicateHandle(EtwpGetCurrentProcess(),
                            EtwpGetCurrentProcess(),
                            EtwpGetCurrentProcess(),
                            &EtwpMyProcessHandle,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);
        if (! b)
        {
            Status = EtwpGetLastError();
            goto Cleanup;
        }

        EtwpOverlapped1.hEvent = EtwpCreateEventW(NULL, FALSE, FALSE, NULL);
        if (EtwpOverlapped1.hEvent == NULL)
        {
            Status = EtwpGetLastError();
            goto Cleanup;
        }

        EtwpOverlapped2.hEvent = EtwpCreateEventW(NULL, FALSE, FALSE, NULL);
        if (EtwpOverlapped2.hEvent == NULL)
        {
            Status = EtwpGetLastError();
            goto Cleanup;
        }

        EtwpEventBuffer1 = EtwpAlloc(INITIALEVENTBUFFERSIZE);
        if (EtwpEventBuffer1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        EtwpEventBufferSize1 = INITIALEVENTBUFFERSIZE;

        EtwpEventBuffer2 = EtwpAlloc(INITIALEVENTBUFFERSIZE);
        if (EtwpEventBuffer2 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        EtwpEventBufferSize2 = INITIALEVENTBUFFERSIZE;

        ThreadHandle = EtwpCreateThread(NULL,
                                    0,
                                    EtwpEventPump,
                                    NULL,
                                    0,
                                    (LPDWORD)&ClientId);

        if (ThreadHandle != NULL)
        {
            EtwpNewPumpThreadPending = TRUE;
            EtwpCloseHandle(ThreadHandle);
        } else {
            //
            // Since we were able to allocate all of our pump
            // resources, but didn't get the pump thread started,
            // we will hang onto our resources and move the pump
            // state to idle. In this way when the pump is started
            // again we do not have to reallocate our resources
            //
            EtwpPumpState = EVENT_PUMP_IDLE;
            Status = EtwpGetLastError();
            goto Done;
        }

        EtwpLeavePMCritSection();
        return(ERROR_SUCCESS);
    } else {
        //
        // Pump resources should already be allocated
        //
        EtwpAssert(EtwpPumpCommandEvent != NULL);
        EtwpAssert(EtwpMyProcessHandle != NULL);
        EtwpAssert(EtwpOverlapped1.hEvent != NULL);
        EtwpAssert(EtwpOverlapped2.hEvent != NULL);
        EtwpAssert(EtwpEventBuffer1 != NULL);
        EtwpAssert(EtwpEventBuffer2 != NULL);
        if ((EtwpNewPumpThreadPending == FALSE) &&
            (EtwpPumpState == EVENT_PUMP_STOPPING) ||
            (EtwpPumpState == EVENT_PUMP_IDLE))
        {
            //
            // If pump is stopping or is idle then we need to fire up a
            // new thread
            //
            ThreadHandle = EtwpCreateThread(NULL,
                                        0,
                                        EtwpEventPump,
                                        NULL,
                                        0,
                                        (LPDWORD)&ClientId);

            if (ThreadHandle != NULL)
            {
                EtwpNewPumpThreadPending = TRUE;
                EtwpCloseHandle(ThreadHandle);
            } else {
                Status = EtwpGetLastError();
                goto Done;
            }
        } else {
            EtwpAssert((EtwpPumpState == EVENT_PUMP_RUNNING) ||
                       (EtwpNewPumpThreadPending == TRUE));
        }
        EtwpLeavePMCritSection();
        return(ERROR_SUCCESS);
    }
Cleanup:
    if (EtwpEventDeviceHandle != NULL)
    {
        EtwpCloseHandle(EtwpEventDeviceHandle);
        EtwpEventDeviceHandle = NULL;
    }

    if (EtwpPumpCommandEvent != NULL)
    {
        EtwpCloseHandle(EtwpPumpCommandEvent);
        EtwpPumpCommandEvent = NULL;
    }
    
    if (EtwpMyProcessHandle != NULL)
    {
        EtwpCloseHandle(EtwpMyProcessHandle);
        EtwpMyProcessHandle = NULL;
    }

    if (EtwpOverlapped1.hEvent != NULL)
    {
        EtwpCloseHandle(EtwpOverlapped1.hEvent);
        EtwpOverlapped1.hEvent = NULL;
    }

    if (EtwpOverlapped2.hEvent != NULL)
    {
        EtwpCloseHandle(EtwpOverlapped2.hEvent);
        EtwpOverlapped2.hEvent = NULL;
    }

    if (EtwpEventBuffer1 != NULL)
    {
        EtwpFree(EtwpEventBuffer1);
        EtwpEventBuffer1 = NULL;
    }

    if (EtwpEventBuffer2 != NULL)
    {
        EtwpFree(EtwpEventBuffer2);
        EtwpEventBuffer2 = NULL;
    }

Done:   
    EtwpLeavePMCritSection();
    return(Status);
}

ULONG EtwpAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    )
{
    ULONG Status;

    Status = EtwpAddToGNList(Guid,
                             DeliveryInfo,
                             DeliveryContext,
                             NotificationFlags,
                             GuidHandle);

    if (Status == ERROR_SUCCESS)
    {
        Status = EtwpEstablishEventPump();
        
        if (Status == ERROR_SUCCESS)
        {
            EtwpSendPumpCommand();
        } else {
            //
            // If we couldn't establish the event pump we want to
            // remove the handle from the GNList and propogate back the
            // error
            //
            EtwpRemoveFromGNList(Guid,
                                 DeliveryInfo);
        }
    } else {
        //
        // If handle could not be added to the lists then we need to
        // close the handle to prevent leaks.
        //
        
        EtwpCloseHandle(GuidHandle);
    }

    
    return(Status);
}

ULONG
EtwpNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    )
{
    HANDLE GuidHandle;
    GUID Guid;
    PVOID NotificationDeliveryContext;
    PVOID NotificationDeliveryInfo;
    ULONG NotificationFlags;
    ULONG Status;
    HANDLE ThreadHandle;
    DWORD ThreadId;
    ULONG ReturnSize;

    EtwpInitProcessHeap();

    //
    // Validate input parameters and flags
    //
    if (InGuid == NULL)
    {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        Guid = *InGuid;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (Flags == NOTIFICATION_CHECK_ACCESS)
    {
        //
        // Caller just wants to check that he has does have permission
        // to enable the notification
        //
#ifdef MEMPHIS
        return(ERROR_SUCCESS);
#else
        Status = EtwpCheckGuidAccess(&Guid, WMIGUID_NOTIFICATION);
        EtwpSetLastError(Status);
        return(Status);
#endif
    }

    //
    // Validate that flags are correct
    //
    if (Enable)
    {
        if ((Flags != NOTIFICATION_TRACE_FLAG) &&
            (Flags != NOTIFICATION_CALLBACK_DIRECT))
        {
            //
            // Invalid Flags were passed
            Status = ERROR_INVALID_PARAMETER;
        } else if (Flags == NOTIFICATION_TRACE_FLAG) {
            Status = ERROR_SUCCESS;
        } else if ((Flags == NOTIFICATION_CALLBACK_DIRECT) &&
                   (DeliveryInfo == NULL)) {
            //
            // Not a valid callback function
            Status = ERROR_INVALID_PARAMETER;
        } else {
            Status = ERROR_SUCCESS;
        }

        if (Status != ERROR_SUCCESS)
        {
            EtwpSetLastError(Status);
            return(Status);
        }
    }


    NotificationDeliveryInfo = (PVOID)DeliveryInfo;
    NotificationDeliveryContext = (PVOID)DeliveryContext;

    NotificationFlags = IsAnsi ? DCREF_FLAG_ANSI : 0;


    if (Flags & NOTIFICATION_TRACE_FLAG)
    {
        //
        // This is a tracelog enable/disable request so send it down the
        // fast lane to KM so it can be processed.
        //
        WMITRACEENABLEDISABLEINFO TraceEnableInfo;

        TraceEnableInfo.Guid = Guid;
        TraceEnableInfo.LoggerContext = LoggerContext;
        TraceEnableInfo.Enable = Enable;

        Status = EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENABLE_DISABLE_TRACELOG,
                                       &TraceEnableInfo,
                                      sizeof(WMITRACEENABLEDISABLEINFO),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);

    } else {
        //
        // This is a WMI event enable/disable event request so fixup the
        // flags and send a request off to the event pump thread.
        //
        if (Flags & NOTIFICATION_CALLBACK_DIRECT) {
            NotificationFlags |= NOTIFICATION_FLAG_CALLBACK_DIRECT;
        } else {
            NotificationFlags |= Flags;
        }

        if (Enable)
        {
            //
            // Since we are enabling, make sure we have access to the
            // guid and then make sure we can get the notification pump
            // thread running.
            //
            Status = EtwpOpenKernelGuid(&Guid,
                                         WMIGUID_NOTIFICATION,
                                         &GuidHandle,
                                         IOCTL_WMI_OPEN_GUID_FOR_EVENTS);


            if (Status == ERROR_SUCCESS)
            {

                Status = EtwpAddHandleToEventPump(&Guid,
                                                    DeliveryInfo,
                                                  DeliveryContext,
                                                  NotificationFlags |
                                                  NOTIFICATION_FLAG_GROUPED_EVENT,
                                                  GuidHandle);
            }
        } else {
            Status = EtwpRemoveFromGNList(&Guid,
                                          DeliveryInfo);
            if (Status == ERROR_SUCCESS)
            {
                EtwpSendPumpCommand();
            }

            if (Status == ERROR_INVALID_PARAMETER)
            {
                CHAR s[MAX_PATH];
                EtwpDebugPrint(("WMI: Invalid DeliveryInfo %x passed to unregister for notification %s\n",
                              DeliveryInfo,
                              GuidToStringA(s, MAX_PATH, &Guid)));
                Status = ERROR_WMI_ALREADY_DISABLED;
            }
        }
    }

    EtwpSetLastError(Status);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\mofapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    mofapi.c

Abstract:
    
    WMI MOF access apis

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "trcapi.h"
#include "common.h"


BOOLEAN EtwpCopyCountedString(
    PUCHAR Base,
    PULONG Offset,
    PULONG BufferRemaining,
    PWCHAR SourceString
    )
{
    PWCHAR w;
    ULONG BufferUsed;
    ULONG BytesUsed;
    BOOLEAN BufferNotFull;
    
    if (*BufferRemaining > 1)
    {
        w = (PWCHAR)OffsetToPtr(Base, *Offset);
        (*BufferRemaining)--;
                        
        BufferNotFull = EtwpCopyMRString(w+1,
                                         *BufferRemaining,
                                         &BufferUsed,
                                         SourceString);
        if (BufferNotFull)
        {
            BytesUsed = BufferUsed * sizeof(WCHAR);
            *w = (USHORT)BytesUsed;
            (*BufferRemaining) -= BufferUsed;
            (*Offset) += BytesUsed + sizeof(USHORT);
        }
    } else {
        BufferNotFull = FALSE;
    }
    return(BufferNotFull);
}

ULONG EtwpBuildMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN PWMIMOFLIST MofList,
    IN PWCHAR *LanguageList,
    IN ULONG LanguageCount,
    IN BOOLEAN IncludeNeutralLanguage,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    PWNODE_ALL_DATA WnodeAD;
    ULONG BytesUsed, BufferUsed;
    BOOLEAN BufferNotFull;
    PWCHAR RegPath, ImagePath, ResourceName;
    ULONG SizeNeeded;
    ULONG InstanceCount, MaxInstanceCount;
    ULONG Status;
    ULONG Offset;
    POFFSETINSTANCEDATAANDLENGTH DataLenPtr;
    PWCHAR w;
    PULONG InstanceNamesOffsets;
    PWCHAR InstanceNames;
    ULONG BufferRemaining;
    ULONG i,j;
    PWMIMOFENTRY MofEntry;  
    PWCHAR ImagePathStatic;
        
    EtwpAssert(WnodeSI->WnodeHeader.Flags & WNODE_FLAG_SINGLE_INSTANCE);

    ImagePathStatic = EtwpAlloc(MAX_PATH * sizeof(WCHAR));
    if (ImagePathStatic != NULL)
    {
        //
        // Figure out how large the WNODE_ALL_DATA will need to be and
        // guess at how much space to allocate for the image paths and
        // resource names
        //
        if (IncludeNeutralLanguage)
        {
            MaxInstanceCount = (LanguageCount + 1);
        } else {
            MaxInstanceCount = LanguageCount;
        }
        MaxInstanceCount *=  MofList->MofListCount;


    #if DBG
        SizeNeeded = sizeof(WNODE_ALL_DATA) +
                                    (MaxInstanceCount *
                                     (sizeof(ULONG) +  // offset to instance name
                                      sizeof(USHORT) + // instance name length
                                      sizeof(OFFSETINSTANCEDATAANDLENGTH))) +
                             64;
    #else
        SizeNeeded = sizeof(WNODE_ALL_DATA) +
                                    (MaxInstanceCount *
                                     (sizeof(ULONG) +  // offset to instance name
                                      sizeof(USHORT) + // instance name length
                                      sizeof(OFFSETINSTANCEDATAANDLENGTH))) +
                             0x1000;
    #endif
        WnodeAD = NULL;
        do
        {
    TryAgain:
            if (WnodeAD != NULL)
            {
                EtwpFree(WnodeAD);
            }

            WnodeAD = EtwpAlloc(SizeNeeded);
            if (WnodeAD != NULL)
            {
                //
                // Build up WNODE_ALL_DATA with all mof resources
                //
                memset(WnodeAD, 0, SizeNeeded);

                WnodeAD->WnodeHeader = WnodeSI->WnodeHeader;
                WnodeAD->WnodeHeader.Flags = WNODE_FLAG_ALL_DATA |
                                             WNODE_FLAG_EVENT_ITEM;
                WnodeAD->WnodeHeader.BufferSize = SizeNeeded;
                WnodeAD->WnodeHeader.Linkage = 0;

                //
                // Establish pointer to the data offset and length
                // structure and allocate space for all instances
                //
                Offset = FIELD_OFFSET(WNODE_ALL_DATA,
                                               OffsetInstanceDataAndLength);
                DataLenPtr = (POFFSETINSTANCEDATAANDLENGTH)OffsetToPtr(WnodeAD,
                                                                               Offset);
                Offset = (Offset +
                                  (MaxInstanceCount *
                                   sizeof(OFFSETINSTANCEDATAANDLENGTH)) + 7) & ~7;

                //
                // Establish the instance name offsets and fill in
                // the empty instance names. Note we point them all
                // to the same offset which is an empty instance
                // name.
                //
                InstanceNamesOffsets = (PULONG)OffsetToPtr(WnodeAD,
                                                                  Offset);

                WnodeAD->OffsetInstanceNameOffsets = Offset;                    
                Offset = Offset + (MaxInstanceCount * sizeof(ULONG));
                InstanceNames = (PWCHAR)OffsetToPtr(WnodeAD, Offset);
                *InstanceNames = 0;
                for (i = 0; i < MaxInstanceCount; i++)
                {
                    InstanceNamesOffsets[i] = Offset;
                }

                //
                // Establish a pointer to the data block for all of
                // the instances
                //
                Offset = (Offset +
                                  (MaxInstanceCount * sizeof(USHORT)) + 7) & ~7;
                WnodeAD->DataBlockOffset = Offset;

                BufferRemaining = (SizeNeeded - Offset) / sizeof(WCHAR);

                InstanceCount = 0;                  

                //
                // Loop over all mof resources in list
                //
                for (j = 0; j < MofList->MofListCount; j++)
                {
                    MofEntry = &MofList->MofEntry[j];
                    RegPath = (PWCHAR)OffsetToPtr(MofList,
                                          MofEntry->RegPathOffset);

                    //
                    // Convert regpath to image path if needed
                    //
                    if ((MofEntry->Flags & WMIMOFENTRY_FLAG_USERMODE) == 0)
                    {
                        ImagePath = EtwpRegistryToImagePath(ImagePathStatic,
                                                            RegPath+1);
                    } else {
                        ImagePath = RegPath;
                    }

                    if (ImagePath != NULL)
                    {
                        ResourceName = (PWCHAR)OffsetToPtr(MofList,
                                               MofEntry->ResourceOffset);

                        //
                        // Now lets go and build up the data for each
                        // instance. First fill in the language neutral mof
                        // if we are supposed to
                        //
                        if (IncludeNeutralLanguage)
                        {

                            DataLenPtr[InstanceCount].OffsetInstanceData = Offset;

                            if ((! EtwpCopyCountedString((PUCHAR)WnodeAD,
                                                     &Offset,
                                                     &BufferRemaining,
                                                     ImagePath))        ||
                                (! EtwpCopyCountedString((PUCHAR)WnodeAD,
                                                  &Offset,
                                                  &BufferRemaining,
                                                  ResourceName)))
                            {
                                SizeNeeded *=2;
                                goto TryAgain;
                            }

                            DataLenPtr[InstanceCount].LengthInstanceData = Offset -
                                                                           DataLenPtr[InstanceCount].OffsetInstanceData;

                            InstanceCount++;

                            //
                            // We cheat here and do not align the offset on an
                            // 8 byte boundry for the next data block since we
                            // know the data type is a WCHAR and we know we are
                            // on a 2 byte boundry.
                            //
                        }

                        //
                        // Now loop over and build language specific mof
                        // resources
                        //
                        for (i = 0; i < LanguageCount; i++)
                        {
                            DataLenPtr[InstanceCount].OffsetInstanceData = Offset;
                            if (BufferRemaining > 1)
                            {
                                w = (PWCHAR)OffsetToPtr(WnodeAD, Offset);

                                Status = EtwpBuildMUIPath(w+1,
                                                       BufferRemaining - 1,
                                                       &BufferUsed,
                                                       ImagePath,
                                                       LanguageList[i],
                                                       &BufferNotFull);
                                if (Status == ERROR_SUCCESS)
                                {
                                    if (BufferNotFull)
                                    {
                                        BufferRemaining--;
                                        BytesUsed = BufferUsed * sizeof(WCHAR);
                                        *w = (USHORT)BytesUsed;
                                        BufferRemaining -= BufferUsed;
                                        Offset += (BytesUsed + sizeof(USHORT));

                                        if (! EtwpCopyCountedString((PUCHAR)WnodeAD,
                                                  &Offset,
                                                  &BufferRemaining,
                                                  ResourceName))
                                        {
                                            SizeNeeded *=2;
                                            goto TryAgain;
                                        }

                                        DataLenPtr[InstanceCount].LengthInstanceData = Offset - DataLenPtr[InstanceCount].OffsetInstanceData;

                                        //
                                        // We cheat here and do not align the offset on an
                                        // 8 byte boundry for the next data block since we
                                        // know the data type is a WCHAR and we know we are
                                        // on a 2 byte boundry.
                                        //

                                        InstanceCount++;
                                    } else {
                                        SizeNeeded *=2;
                                        goto TryAgain;                                  
                                    }
                                }
                            } else {
                                SizeNeeded *=2;
                                goto TryAgain;                                  
                            }
                        }
                    }
                } 
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } while (FALSE);

        if (WnodeAD != NULL)
        {
            WnodeAD->InstanceCount = InstanceCount;
            EtwpMakeEventCallbacks((PWNODE_HEADER)WnodeAD,
                                           Callback,
                                           DeliveryContext,
                                           IsAnsi);
            EtwpFree(WnodeAD);
            Status = ERROR_SUCCESS;
        }
        EtwpFree(ImagePathStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}


void EtwpProcessMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    PWCHAR RegPath, ResourceName;
    PWCHAR *LanguageList;
    ULONG LanguageCount;
    ULONG Status;
    PWMIMOFLIST MofList;
    ULONG i;
    PWMIMOFENTRY MofEntry;
    ULONG Offset;
    ULONG SizeNeeded;
    PWCHAR w;
        
    RegPath = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
    
    EtwpAssert(*RegPath != 0);

    ResourceName = (PWCHAR)OffsetToPtr(WnodeSI,
                                           WnodeSI->DataBlockOffset +
                                           sizeof(USHORT) + 
                                           *RegPath++ + 
                                           sizeof(USHORT));
    
    SizeNeeded = sizeof(WMIMOFLIST) + ((wcslen(RegPath) +
                                           (wcslen(ResourceName) + 2)) * sizeof(WCHAR));
        
    MofList = (PWMIMOFLIST)EtwpAlloc(SizeNeeded);
    if (MofList != NULL)
    {
        Status = EtwpGetLanguageList(&LanguageList,
                                         &LanguageCount);

        if (Status == ERROR_SUCCESS)
        {
            MofList->MofListCount = 1;
            MofEntry = &MofList->MofEntry[0];
            
            Offset = sizeof(WMIMOFLIST);
            
            MofEntry->RegPathOffset = Offset;
            w = (PWCHAR)OffsetToPtr(MofList, Offset);
            wcscpy(w, RegPath);
            Offset += (wcslen(RegPath) + 1) * sizeof(WCHAR);
            
            MofEntry->ResourceOffset = Offset;
            w = (PWCHAR)OffsetToPtr(MofList, Offset);
            wcscpy(w, ResourceName);
            
            if (WnodeSI->WnodeHeader.ProviderId == MOFEVENT_ACTION_REGISTRY_PATH)
            {
                MofEntry->Flags = 0;
            } else {
                MofEntry->Flags = WMIMOFENTRY_FLAG_USERMODE;
            }
            
            Status = EtwpBuildMofAddRemoveEvent(WnodeSI,
                                                MofList,
                                                LanguageList,
                                                LanguageCount,
                                                TRUE,
                                                Callback,
                                                DeliveryContext,
                                                IsAnsi);
            //
            // Free up memory used to hold the language list
            //
            for (i = 0; i < LanguageCount; i++)
            {
                EtwpFree(LanguageList[i]);
            }
            
            EtwpFree(LanguageList);
        }
        
        EtwpFree(MofList);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (Status != ERROR_SUCCESS)
    {
        //
        // If the WNODE_ALL_DATA event wasn't fired then just fire the
        // WNDOE_SINGLE_INSTANCE event so at least we get the language
        // neutral mof
        //
        WnodeSI->WnodeHeader.Flags &= ~WNODE_FLAG_INTERNAL;
        EtwpMakeEventCallbacks((PWNODE_HEADER)WnodeSI,
                               Callback,
                               DeliveryContext,
                               IsAnsi);
    }
}

void EtwpProcessLanguageAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    ULONG Status;
    PWMIMOFLIST MofList;
    PWCHAR Language;
    
    //
    // Get list of mof resources and build an event with the list of
    // resources for the language that is coming or going
    //

    Status = EtwpGetMofResourceList(&MofList);

    if (Status == ERROR_SUCCESS)
    {
        Language = (PWCHAR)OffsetToPtr(WnodeSI,
                               WnodeSI->DataBlockOffset + sizeof(USHORT));
        Status = EtwpBuildMofAddRemoveEvent(WnodeSI,
                                            MofList,
                                            &Language,
                                            1,
                                            FALSE,
                                            Callback,
                                            DeliveryContext,
                                            IsAnsi);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\logsup.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    logsup.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:

--*/

#ifndef MEMPHIS
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include <math.h>
#include "trcapi.h"
#include "NtdllTrc.h"
#include <strsafe.h>
#include <ntperf.h>

ULONG KernelWow64 = FALSE;

#define CPU_ROOT \
    L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor"

#define MHZ_VALUE_NAME \
    L"~MHz"

typedef ULONG (WMIAPI HWCONFIG)(PWMI_LOGGER_CONTEXT);
typedef HWCONFIG * PHWCONFIG ;

HWCONFIG  EtwpDumpHWConfig;

//
// Initially in ntdll EtwpDumpHardwareConfig points
// to Dummy function EtwpDumpHWConfig
//

PHWCONFIG EtwpDumpHardwareConfig = EtwpDumpHWConfig; 

NTSTATUS
EtwpRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    );

NTSTATUS
EtwpProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    );

NTSTATUS
EtwpThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    );

extern
NTSTATUS
DumpHeapSnapShot(
        IN PWMI_LOGGER_CONTEXT Logger
        );

ULONG
EtwpDumpHWConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    return STATUS_SUCCESS;
}

//
// This function is called when advapi32.dll loads
// into process memory and gives ntdll the pointer 
// of function in advapi32 which traces the infor-
// mation of System configuration
//
 
void EtwpSetHWConfigFunction(PHWCONFIG DumpHardwareConfig, ULONG Reason)
{
    if (Reason == DLL_PROCESS_ATTACH)       
    {
        //
        // On DLL Laod Get the pointer in Advapi32.dll
        //

        EtwpDumpHardwareConfig = DumpHardwareConfig;

    } else {

        //
        // On DLL unload point it back to Dummy function.
        //

        EtwpDumpHardwareConfig = EtwpDumpHWConfig;
    }
}

__inline __int64 EtwpGetSystemTime()
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    return SystemTime.QuadPart;
}

ULONG WmiTraceAlignment = DEFAULT_TRACE_ALIGNMENT;

ULONG
EtwpStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to start
    the logger. All the required parameters must be in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    ULONG BufferSize;
    LPGUID Guid;
    PVOID SavedChecksum;
    ULONG SavedLogFileMode;
    BOOLEAN IsKernelTrace = FALSE;
    BOOLEAN bLogFile = FALSE;
    BOOLEAN bRealTime = FALSE;
    WMI_REF_CLOCK RefClock;
    LARGE_INTEGER RefClockSys, RefClockPerf, RefClockCycle;
    LARGE_INTEGER Frequency;

    Guid = &LoggerInfo->Wnode.Guid;

    if( IsEqualGUID(&HeapGuid,Guid) 
        || IsEqualGUID(&CritSecGuid,Guid)
        ){

        WMINTDLLLOGGERINFO NtdllLoggerInfo;

        NtdllLoggerInfo.LoggerInfo = LoggerInfo;
        RtlCopyMemory(&LoggerInfo->Wnode.Guid, &NtdllTraceGuid, sizeof(GUID));
        NtdllLoggerInfo.IsGet = FALSE;


        Status =  EtwpSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_NTDLL_LOGGERINFO,
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &BufferSize,
                        NULL
                        );

        return EtwpSetDosError(Status);
    }

    if (IsEqualGUID(Guid, &SystemTraceControlGuid) ||
        IsEqualGUID(Guid, &WmiEventLoggerGuid)) {
        IsKernelTrace = TRUE;
    }
    if ((LoggerInfo->LogFileName.Length > 0) &&
        (LoggerInfo->LogFileName.Buffer != NULL)) {
        bLogFile = TRUE;
    }
    SavedLogFileMode = LoggerInfo->LogFileMode;
    if (SavedLogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        bRealTime = TRUE;
    }

    //
    // If the user didn't specify the clock type, set the default clock type
    // system time.
    //

    if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_PERFCOUNTER &&
        LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME &&
        LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_CPUCYCLE) {
        LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    }

    //
    // Take a reference timestamp before actually starting the logger. This is
    // due to the fact that the Kernel logger can pump events with timestamps
    // earier than the LogFileHeader Timestamp. As a result we take the 
    // reference timestamps prior to starting anything. 
    //
    RefClockSys.QuadPart = EtwpGetSystemTime();
    RefClockCycle.QuadPart = EtwpGetCycleCount();
    Status = NtQueryPerformanceCounter(&RefClockPerf, &Frequency);

    if (SavedLogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = EtwpSendUmLogRequest(
                    WmiStartLoggerCode,
                    LoggerInfo
                    );
    }
    else if (IsKernelTrace) {
        //
        // In order to capture the process/thread rundown accurately, we need to
        // start kernel logger in two steps. Start logger with delay write,
        // do rundown from user mode and then updatelogger with filename.
        //
        WMI_LOGGER_INFORMATION DelayLoggerInfo;
        ULONG EnableFlags = LoggerInfo->EnableFlags;
        //
        // If it's only realtime start logger in one step
        //

        if (bRealTime && !bLogFile) {

            Status =  EtwpSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_START_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );
            return EtwpSetDosError(Status);
        }

        if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                       &LoggerInfo->EnableFlags;
            EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
        }


        RtlCopyMemory(&DelayLoggerInfo, 
                       LoggerInfo, 
                       sizeof(WMI_LOGGER_INFORMATION));

        RtlZeroMemory(&DelayLoggerInfo.LogFileName, sizeof(UNICODE_STRING) );

        DelayLoggerInfo.Wnode.BufferSize = sizeof(WMI_LOGGER_INFORMATION);

        DelayLoggerInfo.LogFileMode |= EVENT_TRACE_DELAY_OPEN_FILE_MODE;

        //
        // Since there's no filename in step 1 of StartLogger we need to mask
        // the NEWFILE mode to prevent kernel trying to generate a file
        //
        DelayLoggerInfo.LogFileMode &= ~EVENT_TRACE_FILE_MODE_NEWFILE;

        DelayLoggerInfo.EnableFlags = (EVENT_TRACE_FLAG_PROCESS & EnableFlags);
        DelayLoggerInfo.EnableFlags |= (EVENT_TRACE_FLAG_THREAD & EnableFlags);
        DelayLoggerInfo.EnableFlags |= 
                                    (EVENT_TRACE_FLAG_IMAGE_LOAD & EnableFlags);

        Status = EtwpSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_START_LOGGER,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
        if (Status != ERROR_SUCCESS) {
            return Status;
        }

        LoggerInfo->Wnode.ClientContext = DelayLoggerInfo.Wnode.ClientContext;

        //
        // We need to pick up any parameter adjustment done by the kernel
        // here so UpdateTrace does not fail.
        //
        LoggerInfo->Wnode.HistoricalContext = 
                                        DelayLoggerInfo.Wnode.HistoricalContext;
        LoggerInfo->MinimumBuffers          = DelayLoggerInfo.MinimumBuffers;
        LoggerInfo->MaximumBuffers          = DelayLoggerInfo.MaximumBuffers;
        LoggerInfo->NumberOfBuffers         = DelayLoggerInfo.NumberOfBuffers;
        LoggerInfo->BufferSize              = DelayLoggerInfo.BufferSize;
        LoggerInfo->AgeLimit                = DelayLoggerInfo.AgeLimit;

        BufferSize = LoggerInfo->BufferSize * 1024;

        //
        //  Add the LogHeader
        //
        LoggerInfo->Checksum = NULL;
        if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            RefClock.StartPerfClock = RefClockPerf;
        } else if (LoggerInfo->Wnode.ClientContext ==
                   EVENT_TRACE_CLOCK_CPUCYCLE) {
            RefClock.StartPerfClock= RefClockCycle;
        } else {
            RefClock.StartPerfClock = RefClockSys;
        }
        RefClock.StartTime = RefClockSys;

        Status = EtwpAddLogHeaderToLogFile(LoggerInfo, &RefClock, FALSE);


        if (Status == ERROR_SUCCESS) {
            SavedChecksum = LoggerInfo->Checksum;
            //
            // Update the logger with the filename
            //
            Status = EtwpSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_UPDATE_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );

            if (SavedChecksum != NULL) {
                EtwpFree(SavedChecksum);
                SavedChecksum = NULL;
            }
        }


        if (Status != ERROR_SUCCESS) {
            ULONG lStatus;

            //
            // Logger must be stopped now
            //
            lStatus = EtwpSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_STOP_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );

            LoggerInfo->LogFileMode = SavedLogFileMode;
            return EtwpSetDosError(Status);
        }
    }
    else {

        LoggerInfo->Checksum = NULL;
        // 
        // Query for supported clock types.  If an unsupported clock type
        // is specified this LoggerInfo will contain the kernel's default
        //
        Status = EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_CLOCK_TYPE,
                                      LoggerInfo,
                                      LoggerInfo->Wnode.BufferSize,
                                      LoggerInfo,
                                      LoggerInfo->Wnode.BufferSize,
                                      &BufferSize,
                                      NULL
                                    );

        if (Status != ERROR_SUCCESS) {
            return EtwpSetDosError(Status);
        }
        if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            RefClock.StartPerfClock = RefClockPerf;
        } else if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_CPUCYCLE) {
            RefClock.StartPerfClock= RefClockCycle;
        } else {
            RefClock.StartPerfClock = RefClockSys;
        }
        RefClock.StartTime = RefClockSys;

        Status = EtwpAddLogHeaderToLogFile(LoggerInfo, &RefClock, FALSE);
        if (Status != ERROR_SUCCESS) {
            return EtwpSetDosError(Status);
        }

        //
        // At this point we have an open handle to the logfile and memory 
        // allocation? 
        //

        BufferSize = LoggerInfo->BufferSize * 1024;
        SavedChecksum = LoggerInfo->Checksum;

       // actually start the logger here
        Status = EtwpSendWmiKMRequest(
                            NULL,
                    IOCTL_WMI_START_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                            NULL
                    );

        // Close the handle if it's not NULL
        if (LoggerInfo->LogFileHandle != NULL) {
            NtClose(LoggerInfo->LogFileHandle);
            LoggerInfo->LogFileHandle = NULL;
        }
        //
        // If the Start call failed, we will delete the logfile except 
        // when we are appending to an older file. However, we do not 
        // fixup the header!
        //

        if ( (Status != ERROR_MORE_DATA) &&
                  !(LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)) {
            if (LoggerInfo->LogFileName.Buffer != NULL) {
                EtwpDeleteFileW(LoggerInfo->LogFileName.Buffer);
            }
        }
        if (SavedChecksum != NULL) {
            EtwpFree(SavedChecksum);
        }
    }
    //
    // Restore the LogFileMode
    //
    LoggerInfo->LogFileMode = SavedLogFileMode;

    return EtwpSetDosError(Status);
}


ULONG
EtwpFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG                     Status    = ERROR_SUCCESS;
    ULONG                     ErrorCode = ERROR_SUCCESS;
    HANDLE                    LogFile   = INVALID_HANDLE_VALUE;
    LARGE_INTEGER             CurrentTime;
    WMI_LOGGER_CONTEXT        Logger;
    IO_STATUS_BLOCK           IoStatus;
    FILE_POSITION_INFORMATION FileInfo;
    FILE_STANDARD_INFORMATION FileSize;
    PWMI_BUFFER_HEADER        Buffer;  // need to initialize buffer first
    SYSTEM_BASIC_INFORMATION  SystemInfo;
    ULONG                     EnableFlags;
    ULONG                     IsKernelTrace = FALSE;
    ULONG                     IsGlobalForKernel = FALSE;
    USHORT                    LoggerId = 0;

    RtlZeroMemory(&Logger, sizeof(WMI_LOGGER_CONTEXT));
    Logger.BufferSpace = NULL;

    IsKernelTrace = IsEqualGUID(&LoggerInfo->Wnode.Guid, 
                                &SystemTraceControlGuid);


    if (LoggerInfo->LogFileName.Length > 0 ) {
        // open the file for writing synchronously for the logger
        //    others may want to read it as well.
        //
        LogFile = EtwpCreateFileW(
                   (LPWSTR)LoggerInfo->LogFileName.Buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );
        if (LogFile == INVALID_HANDLE_VALUE) {
            ErrorCode = EtwpGetLastError();
            goto cleanup;
        }

        // Truncate the file size if in PREALLOCATE mode
        if (LoggerInfo->MaximumFileSize && 
            (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
            IO_STATUS_BLOCK IoStatusBlock;
            FILE_END_OF_FILE_INFORMATION EOFInfo;
            // Do this only when we haven't reach the max file size
            if (!(LoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)) {

                if (LoggerInfo->MaximumFileSize > 
                              (((ULONGLONG)LoggerInfo->BuffersWritten * 
                              (ULONGLONG)LoggerInfo->BufferSize) / 
                              1024)) {

                    EOFInfo.EndOfFile.QuadPart = 
                                    (ULONGLONG)LoggerInfo->BuffersWritten * 
                                    (ULONGLONG)LoggerInfo->BufferSize * 
                                    1024;


                    Status = NtSetInformationFile(LogFile,
                                          &IoStatusBlock,
                                          &EOFInfo,
                                          sizeof(FILE_END_OF_FILE_INFORMATION),
                                          FileEndOfFileInformation
                                        );
                    if (!NT_SUCCESS(Status)) {
                        NtClose(LogFile);
                        ErrorCode = EtwpNtStatusToDosError(Status);
                        goto cleanup;
                    }
                }
            }
            else { // using KBytes for file size unit
                if (LoggerInfo->MaximumFileSize > 
                              ((ULONGLONG)LoggerInfo->BuffersWritten * 
                              (ULONGLONG)LoggerInfo->BufferSize)) { // 

                    EOFInfo.EndOfFile.QuadPart = 
                                    (ULONGLONG)LoggerInfo->BuffersWritten * 
                                    (ULONGLONG)LoggerInfo->BufferSize * 
                                    1024;

                    Status = NtSetInformationFile(
                                    LogFile,
                                    &IoStatusBlock,
                                    &EOFInfo,
                                    sizeof(FILE_END_OF_FILE_INFORMATION),
                                    FileEndOfFileInformation
                                   );
                    if (!NT_SUCCESS(Status)) {
                        NtClose(LogFile);
                        ErrorCode = EtwpNtStatusToDosError(Status);
                        goto cleanup;
                    }
                }
            }
        }

        Logger.BuffersWritten = LoggerInfo->BuffersWritten;

        Logger.BufferSpace = EtwpAlloc(LoggerInfo->BufferSize * 1024);
        if (Logger.BufferSpace == NULL) {
            ErrorCode = EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            goto cleanup;
        }
        Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
        RtlZeroMemory(Buffer, LoggerInfo->BufferSize * 1024);
        Buffer->Wnode.BufferSize = LoggerInfo->BufferSize * 1024;
        Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Guid = LoggerInfo->Wnode.Guid;
        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &SystemInfo, sizeof (SystemInfo), NULL);

        if (!NT_SUCCESS(Status)) {
            ErrorCode = EtwpNtStatusToDosError(Status);
            goto cleanup;
        }
        Logger.TimerResolution = SystemInfo.TimerResolution;
        Logger.LogFileHandle = LogFile;
        Logger.BufferSize = LoggerInfo->BufferSize * 1024;

        // For Circular LogFile the process rundown data is appended at the
        // last buffer written and not to the end of file.
        //
        Status = NtQueryInformationFile(
                    LogFile,
                    &IoStatus,
                    &FileSize,
                    sizeof(FILE_STANDARD_INFORMATION),
                    FileStandardInformation
                        );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = EtwpNtStatusToDosError(Status);
            goto cleanup;
        }

        //
        // For Kernel Boot Traces, we need to do the Rundown. 
        // configuration at this time. 
        // 1. The Logger ID is GLOBAL_LOGGER_ID
        // 2. The LoggerName is NT_KERNEL_LOGGER
        //
        // The First condition is true for any GlobalLogger but 
        // condition 2 is TRUE only when it is collecting kernel traces. 
        //

        LoggerId = WmiGetLoggerId (LoggerInfo->Wnode.HistoricalContext);

        if ( (LoggerId == WMI_GLOBAL_LOGGER_ID)      &&
             (LoggerInfo->LoggerName.Length > 0)     && 
             (LoggerInfo->LoggerName.Buffer != NULL) &&
             (!wcscmp(LoggerInfo->LoggerName.Buffer, KERNEL_LOGGER_NAMEW))
           ) {
            IsGlobalForKernel = TRUE;
        }

        if (  IsKernelTrace || IsGlobalForKernel )  {
            if (IsGlobalForKernel) {
                ULONG      CpuSpeed;
                ULONG      CpuNum = 0;
                
                //
                // For boot traces we need to re-set the CPU Speed in the
                // log file header as it is not available in the registry 
                // when the log file header is first created.
                //
                if (NT_SUCCESS(EtwpGetCpuSpeed(&CpuNum, &CpuSpeed))) {          
                    FileInfo.CurrentByteOffset.QuadPart =
                        LOGFILE_FIELD_OFFSET(CpuSpeedInMHz);
                    
                    Status = NtSetInformationFile(
                        LogFile,
                        &IoStatus,
                        &FileInfo,
                        sizeof(FILE_POSITION_INFORMATION),
                        FilePositionInformation
                        );
                    if (!NT_SUCCESS(Status)) {
                        ErrorCode = EtwpNtStatusToDosError(Status);
                        goto cleanup;
                    }
                    
                    Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &CpuSpeed,
                        sizeof(CpuSpeed),
                        NULL,
                        NULL
                        );
                    
                   if (NT_SUCCESS(Status)) {
                        NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                    }                
                }
            }

            if (sizeof(PVOID) != 8) {
                // For kernel trace, the pointer size is always 64 on ia64, 
                // whether or not under Wow64. Get Wow64 information and set 
                // the flag so that ProcessRunDown can dajust pointer size.
                ULONG_PTR ulp;
                Status = NtQueryInformationProcess(
                            NtCurrentProcess(),
                            ProcessWow64Information,
                            &ulp,
                            sizeof(ULONG_PTR),
                            NULL);
                if (NT_SUCCESS(Status) && (ulp != 0)) {
                    KernelWow64 = TRUE;
                }
            }

            if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {

                ULONG BufferSize = LoggerInfo->BufferSize;  // in KB
                ULONG BuffersWritten = LoggerInfo->BuffersWritten;
                ULONG maxBuffers = (LoggerInfo->MaximumFileSize * 
                                    1024) / 
                                    BufferSize;
                ULONG LastBuffer;
                ULONG StartBuffers;

                FileInfo.CurrentByteOffset.QuadPart =
                                         LOGFILE_FIELD_OFFSET(StartBuffers);
                Status = NtSetInformationFile(
                                     LogFile,
                                     &IoStatus,
                                     &FileInfo,
                                     sizeof(FILE_POSITION_INFORMATION),
                                     FilePositionInformation
                                     );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = EtwpNtStatusToDosError(Status);
                    goto cleanup;
                }

                Status = NtReadFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &StartBuffers,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = EtwpNtStatusToDosError(Status);
                    goto cleanup;
                }

                LastBuffer = (maxBuffers > StartBuffers) ?
                             (StartBuffers + (BuffersWritten - StartBuffers)
                             % (maxBuffers - StartBuffers))
                             : 0;
                FileInfo.CurrentByteOffset.QuadPart =  LastBuffer *
                                                       BufferSize * 1024;
            }
            else {
                FileInfo.CurrentByteOffset = FileSize.EndOfFile;
            }


            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = EtwpNtStatusToDosError(Status);
                goto cleanup;
            }

            EnableFlags = LoggerInfo->EnableFlags;

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;

                if (LoggerInfo->Wnode.BufferSize >= (tFlagExt->Offset + sizeof(ULONG)) )  {
                    EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
                }
                else {
                    EnableFlags = 0;    // Should not happen.
                }
            }

            Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

            EtwpProcessRunDown(&Logger, FALSE, EnableFlags);

            if (IsGlobalForKernel) {
                EtwpDumpHardwareConfig(&Logger);
            }

            {
                PWMI_BUFFER_HEADER Buffer1 =
                                (PWMI_BUFFER_HEADER) Logger.BufferSpace;
                    if (Buffer1->Offset < Logger.BufferSize) {
                        RtlFillMemory(
                                (char *) Logger.BufferSpace + Buffer1->Offset,
                                Logger.BufferSize - Buffer1->Offset,
                                0xFF);
                    }
            }
            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        Logger.BufferSpace,
                        Logger.BufferSize,
                        NULL,
                        NULL);
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                Logger.BuffersWritten++;
            }
        }


        // Update the EndTime stamp field in LogFile. No Need to 
        // to do it if it's Relogged File. The old logfile
        // header already has the correct value. 
        //
        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) ) {
            FileInfo.CurrentByteOffset.QuadPart =
                                    LOGFILE_FIELD_OFFSET(EndTime);
            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = EtwpNtStatusToDosError(Status);
                goto cleanup;
            }

            // End Time is always wallclock time.
            //
            CurrentTime.QuadPart = EtwpGetSystemTime();
            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &CurrentTime,
                        sizeof(ULONGLONG),
                        NULL,
                        NULL
                        );
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            }
        }

        //
        // Update the Number of Buffers Written field in the header
        //
        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(BuffersWritten);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = EtwpNtStatusToDosError(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &Logger.BuffersWritten,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

        ErrorCode = RtlNtStatusToDosError(Status);
        LoggerInfo->BuffersWritten = Logger.BuffersWritten;

        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) ) {
            //
            // Write the BuffersLost information into the logfile
            // We need to be careful for WOW cases because BuffersLost
            // come after pointers in log file header.
            //

            if (KernelWow64) { // KernelWow64
                FileInfo.CurrentByteOffset.QuadPart =
                                    LOGFILE_FIELD_OFFSET(BuffersLost) + 8;
            }
            else if ( LoggerInfo->Wow && 8 == sizeof(PVOID) &&
                    !(IsKernelTrace ||  IsGlobalForKernel) ) { 
                // We're stopping a non-kernel 32 bit logger in 64 bit mode.
                // The log file header in the file is 32 bit so we need to
                // adjust the field offset.
                FileInfo.CurrentByteOffset.QuadPart =
                                    LOGFILE_FIELD_OFFSET(BuffersLost) - 8;
            }
            else if ( !(LoggerInfo->Wow) && 4 == sizeof(PVOID) &&
                    !(IsKernelTrace || IsGlobalForKernel) ) { 
                // We're stopping a non-kernel logger in 32 bit mode.
                // If this is running on IA64, the log file header in the file is 
                // 64 bit so we need to adjust the field offset.
                ULONG_PTR ulp;
                Status = NtQueryInformationProcess(
                            NtCurrentProcess(),
                            ProcessWow64Information,
                            &ulp,
                            sizeof(ULONG_PTR),
                            NULL);
                if (NT_SUCCESS(Status) && (ulp != 0)) { // Current process is WOW (on IA64)
                    FileInfo.CurrentByteOffset.QuadPart =
                                        LOGFILE_FIELD_OFFSET(BuffersLost) + 8;
                }
                else { // normal x86 case
                    FileInfo.CurrentByteOffset.QuadPart =
                                        LOGFILE_FIELD_OFFSET(BuffersLost);
                }
            }
            else {
                FileInfo.CurrentByteOffset.QuadPart =
                                    LOGFILE_FIELD_OFFSET(BuffersLost);
            }
            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = EtwpNtStatusToDosError(Status);
                goto cleanup;
            }

            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &LoggerInfo->LogBuffersLost,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            }

            //
            // Write the EventsLost information into the logfile
            //
            FileInfo.CurrentByteOffset.QuadPart =
                                LOGFILE_FIELD_OFFSET(EventsLost);
            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = EtwpNtStatusToDosError(Status);
                goto cleanup;
            }

            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &LoggerInfo->EventsLost,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            }
        }

    }

cleanup:
    if (LogFile != INVALID_HANDLE_VALUE) {
        NtClose(LogFile);
    }
    if (Logger.BufferSpace != NULL) {
        EtwpFree(Logger.BufferSpace);
    }
    return EtwpSetDosError(ErrorCode);
}

ULONG
EtwpStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to stop
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode, ReturnSize;
    PTRACE_ENABLE_CONTEXT pContext;

    //
    //Check For Heap and Crit Sec Guid.
    //

    if( IsEqualGUID(&HeapGuid,&LoggerInfo->Wnode.Guid) 
        || IsEqualGUID(&CritSecGuid,&LoggerInfo->Wnode.Guid)
        ){

        WMINTDLLLOGGERINFO NtdllLoggerInfo;
        ULONG BufferSize;
        
        LoggerInfo->Wnode.BufferSize = 0;
        RtlCopyMemory(&LoggerInfo->Wnode.Guid, &NtdllTraceGuid, sizeof(GUID));

        NtdllLoggerInfo.LoggerInfo = LoggerInfo;
        NtdllLoggerInfo.IsGet = FALSE;


        ErrorCode =  EtwpSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_NTDLL_LOGGERINFO,
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &BufferSize,
                        NULL
                        );

        return EtwpSetDosError(ErrorCode);
    }

//    pContext = (PTRACE_ENABLE_CONTEXT) & LoggerInfo->Wnode.HistoricalContext;
//    if (   (pContext->InternalFlag != 0)
//        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
//        // Currently only one possible InternalFlag value. This will filter
//        // out some bogus LoggerHandle
//        //
//        return EtwpSetDosError(ERROR_INVALID_HANDLE);
//    }

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        pContext = (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
        pContext->LoggerId     = 1;
        ErrorCode = EtwpSendUmLogRequest(WmiStopLoggerCode, LoggerInfo);
    }
    else {


        ErrorCode = EtwpSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_STOP_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &ReturnSize,
                        NULL
                        );
//
// if logging to a file, then update the EndTime, BuffersWritten and do
// process rundown for kernel trace.
//
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = EtwpFinalizeLogFileHeader(LoggerInfo);
        }
    }

    return EtwpSetDosError(ErrorCode);
}


ULONG
EtwpQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to query
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status, ReturnSize;
    HANDLE LogFileHandle = NULL;
    PTRACE_ENABLE_CONTEXT pContext;
    BOOLEAN bAddAppendFlag = FALSE;
    ULONG SavedLogFileMode;
    ULONG IsPrivate;

    LoggerInfo->Checksum      = NULL;
    LoggerInfo->LogFileHandle = NULL;
    pContext = (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext;

    IsPrivate = (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                || (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE);

    //
    // If UPDATE and a new logfile is given throw in the LogFileHeader
    //

    if ( Update && LoggerInfo->LogFileName.Length > 0) {

        if ( ! IsPrivate) {
            Status = EtwpAddLogHeaderToLogFile(LoggerInfo, NULL, Update);
            if (Status  != ERROR_SUCCESS) {
                return EtwpSetDosError(Status);
            }

            LogFileHandle = LoggerInfo->LogFileHandle;
            bAddAppendFlag = TRUE;
            //
            // If we are switching to a new file, make sure it is append mode
            //
            SavedLogFileMode = LoggerInfo->LogFileMode;
        }
    }


    if (IsPrivate) {

        Status = EtwpSendUmLogRequest(
                    (Update) ? (WmiUpdateLoggerCode) : (WmiQueryLoggerCode),
                    LoggerInfo
                    );
    }
    else {
        Status = EtwpSendWmiKMRequest(
                    NULL,
                    (Update ? IOCTL_WMI_UPDATE_LOGGER : IOCTL_WMI_QUERY_LOGGER),
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &ReturnSize,
                    NULL
                    );

        // Close the handle if it's not NULL
        if (LoggerInfo->LogFileHandle != NULL) {
            NtClose(LoggerInfo->LogFileHandle);
            LoggerInfo->LogFileHandle = NULL;
        }

        if (Update && Status != ERROR_SUCCESS) {
            if (LoggerInfo->LogFileName.Buffer != NULL) {
                EtwpDeleteFileW(LoggerInfo->LogFileName.Buffer);
            }
        }

        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
    }
    if (bAddAppendFlag) {
        LoggerInfo->LogFileMode = SavedLogFileMode;
    }
    return EtwpSetDosError(Status);
}

PVOID
EtwpGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    )
{
    PSYSTEM_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER Buffer;
    THREAD_BASIC_INFORMATION ThreadInfo;
    KERNEL_USER_TIMES ThreadCpu;
    NTSTATUS Status;
    ULONG BytesUsed;
    PCLIENT_ID Cid;

    RequiredSize += sizeof (SYSTEM_TRACE_HEADER);   // add in header

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    Buffer = (PWMI_BUFFER_HEADER) Logger->BufferSpace;

    if (RequiredSize > Logger->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        EtwpSetDosError(ERROR_BUFFER_OVERFLOW);
        return NULL;
    }

    if (RequiredSize > (Logger->BufferSize - Buffer->Offset)) {
        IO_STATUS_BLOCK IoStatus;

        if (Buffer->Offset < Logger->BufferSize) {
            RtlFillMemory(
                    (char *) Buffer + Buffer->Offset,
                    Logger->BufferSize - Buffer->Offset,
                    0xFF);
        }
        Buffer->BufferType = WMI_BUFFER_TYPE_RUNDOWN;
        Buffer->BufferFlag = WMI_BUFFER_FLAG_FLUSH_MARKER;

        Status = NtWriteFile(
                    Logger->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    Logger->BufferSize,
                    NULL,
                    NULL);
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        if (!NT_SUCCESS(Status)) {
            return NULL;
        }
        Logger->BuffersWritten++;
    }
    Header = (PSYSTEM_TRACE_HEADER) ((char*)Buffer + Buffer->Offset);

    if (Logger->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
        LARGE_INTEGER Frequency;
        ULONGLONG Counter = 0;
        Status = NtQueryPerformanceCounter((PLARGE_INTEGER)&Counter,
                                            &Frequency);
        Header->SystemTime.QuadPart = Counter;
    } else if (Logger->UsePerfClock == EVENT_TRACE_CLOCK_CPUCYCLE) {
        Header->SystemTime.QuadPart = EtwpGetCycleCount();
    } else {
        Header->SystemTime.QuadPart = EtwpGetSystemTime();
    }

    Header->Header = (GroupType << 16) + RequiredSize;
    Header->Marker = SYSTEM_TRACE_MARKER;

    if (pThread == NULL) {
        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof ThreadInfo, NULL);
        if (NT_SUCCESS(Status)) {
            Cid = &ThreadInfo.ClientId;
            Header->ThreadId = HandleToUlong(Cid->UniqueThread);
            Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        }

        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadTimes,
                    &ThreadCpu, sizeof ThreadCpu, NULL);
        if (NT_SUCCESS(Status)) {
            Header->KernelTime = (ULONG) (ThreadCpu.KernelTime.QuadPart
                                      / Logger->TimerResolution);
            Header->UserTime   = (ULONG) (ThreadCpu.UserTime.QuadPart
                                      / Logger->TimerResolution);
        }
    }
    else {
        Cid = &pThread->ClientId;
        Header->ThreadId = HandleToUlong(Cid->UniqueThread);
        Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        Header->KernelTime = (ULONG) (pThread->KernelTime.QuadPart
                                / Logger->TimerResolution);
        Header->UserTime = (ULONG) (pThread->UserTime.QuadPart
                                / Logger->TimerResolution);
    }

    Buffer->Offset += RequiredSize;
    // If there is room, throw in a end of buffer marker.

    BytesUsed = Buffer->Offset;
    if ( BytesUsed <= (Logger->BufferSize-sizeof(ULONG)) ) {
        *((long*)((char*)Buffer+Buffer->Offset)) = -1;
    }
    return (PVOID) ( (char*) Header + sizeof(SYSTEM_TRACE_HEADER) );
}


VOID
EtwpCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    )
{
    ULONG SavedBufferSize = Info->Wnode.BufferSize;

    RtlCopyMemory(&Info->Wnode, &Properties->Wnode, sizeof(WNODE_HEADER));

    Info->Wnode.BufferSize = SavedBufferSize;

    Info->BufferSize            = Properties->BufferSize;
    Info->MinimumBuffers        = Properties->MinimumBuffers;
    Info->MaximumBuffers        = Properties->MaximumBuffers;
    Info->NumberOfBuffers       = Properties->NumberOfBuffers;
    Info->FreeBuffers           = Properties->FreeBuffers;
    Info->EventsLost            = Properties->EventsLost;
    Info->BuffersWritten        = Properties->BuffersWritten;
    Info->LoggerThreadId        = Properties->LoggerThreadId;
    Info->MaximumFileSize       = Properties->MaximumFileSize;
    Info->EnableFlags           = Properties->EnableFlags;
    Info->LogFileMode           = Properties->LogFileMode;
    Info->FlushTimer            = Properties->FlushTimer;
    Info->LogBuffersLost        = Properties->LogBuffersLost;
    Info->AgeLimit              = Properties->AgeLimit;
    Info->RealTimeBuffersLost   = Properties->RealTimeBuffersLost;
}

VOID
EtwpCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    )
{
    ULONG SavedSize = Properties->Wnode.BufferSize;
    RtlCopyMemory(&Properties->Wnode, &Info->Wnode, sizeof(WNODE_HEADER));
    Properties->Wnode.BufferSize = SavedSize;

    Properties->BufferSize            = Info->BufferSize;
    Properties->MinimumBuffers        = Info->MinimumBuffers;
    Properties->MaximumBuffers        = Info->MaximumBuffers;
    Properties->NumberOfBuffers       = Info->NumberOfBuffers;
    Properties->FreeBuffers           = Info->FreeBuffers;
    Properties->EventsLost            = Info->EventsLost;
    Properties->BuffersWritten        = Info->BuffersWritten;
    Properties->LoggerThreadId        = Info->LoggerThreadId;
    Properties->MaximumFileSize       = Info->MaximumFileSize;
    Properties->EnableFlags           = Info->EnableFlags;
    Properties->LogFileMode           = Info->LogFileMode;
    Properties->FlushTimer            = Info->FlushTimer;
    Properties->LogBuffersLost        = Info->LogBuffersLost;
    Properties->AgeLimit              = Info->AgeLimit;
    Properties->RealTimeBuffersLost   = Info->RealTimeBuffersLost;
}

NTSTATUS
EtwpThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    )
{
    PSYSTEM_THREAD_INFORMATION pThreadInfo;
    ULONG GroupType;
    ULONG i;
    ULONG Size;
    ULONG SystemThreadInfoSize;
    PWMI_EXTENDED_THREAD_INFORMATION ThreadInfo;
    PWMI_EXTENDED_THREAD_INFORMATION64 ThreadInfo64;

    pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);

    GroupType = EVENT_TRACE_GROUP_THREAD +
                ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                             : EVENT_TRACE_TYPE_DC_END);
    if (!KernelWow64) { // normal case

        Size = sizeof(WMI_EXTENDED_THREAD_INFORMATION);

        SystemThreadInfoSize = (bExtended)  
                               ? sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION)
                               : sizeof(SYSTEM_THREAD_INFORMATION);
        for (i=0; i < pProcessInfo->NumberOfThreads; i++) {
            if (pThreadInfo == NULL)
                break;
            ThreadInfo = (PWMI_EXTENDED_THREAD_INFORMATION)
                          EtwpGetTraceBuffer( Logger,
                                              pThreadInfo,
                                              GroupType,
                                              Size );
            if (ThreadInfo) {
                ThreadInfo->ProcessId =
                    HandleToUlong(pThreadInfo->ClientId.UniqueProcess);
                ThreadInfo->ThreadId =
                    HandleToUlong(pThreadInfo->ClientId.UniqueThread);

                if (bExtended) {
                    PSYSTEM_EXTENDED_THREAD_INFORMATION pExtThreadInfo;
                    pExtThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) 
                                     pThreadInfo;
                    ThreadInfo->StackBase = pExtThreadInfo->StackBase;
                    ThreadInfo->StackLimit = pExtThreadInfo->StackLimit;

                    ThreadInfo->StartAddr = 
                                pExtThreadInfo->ThreadInfo.StartAddress;
                    ThreadInfo->Win32StartAddr = 
                                pExtThreadInfo->Win32StartAddress;
                    ThreadInfo->UserStackBase = 0;
                    ThreadInfo->UserStackLimit = 0;
                    ThreadInfo->WaitMode = -1;
                }
                else {
                    ThreadInfo->StackBase = 0;
                    ThreadInfo->StackLimit = 0;
                    ThreadInfo->StartAddr = 0;
                    ThreadInfo->Win32StartAddr = 0;
                    ThreadInfo->UserStackBase = 0;
                    ThreadInfo->UserStackLimit = 0;
                    ThreadInfo->WaitMode = -1;
                }
            }
            pThreadInfo  = (PSYSTEM_THREAD_INFORMATION) 
                           ( (char*)pThreadInfo +SystemThreadInfoSize );
        }
    }
    else { // KernelWow64
        Size = sizeof(WMI_EXTENDED_THREAD_INFORMATION64);

        SystemThreadInfoSize = (bExtended)  
                               ? sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION)
                               : sizeof(SYSTEM_THREAD_INFORMATION);
        for (i=0; i < pProcessInfo->NumberOfThreads; i++) {
            if (pThreadInfo == NULL)
                break;
            ThreadInfo64 = (PWMI_EXTENDED_THREAD_INFORMATION64)
                           EtwpGetTraceBuffer( Logger,
                                               pThreadInfo,
                                               GroupType,
                                               Size );

            if (ThreadInfo64) {
                ThreadInfo64->ProcessId =
                    HandleToUlong(pThreadInfo->ClientId.UniqueProcess);
                ThreadInfo64->ThreadId =
                    HandleToUlong(pThreadInfo->ClientId.UniqueThread);

                if (bExtended) {
                    PSYSTEM_EXTENDED_THREAD_INFORMATION pExtThreadInfo;
                    pExtThreadInfo = 
                        (PSYSTEM_EXTENDED_THREAD_INFORMATION) pThreadInfo;
                    ThreadInfo64->StackBase64 = 0;
                    ThreadInfo64->StackBase64 = 
                        (ULONG64)(pExtThreadInfo->StackBase);
                    ThreadInfo64->StackLimit64 = 0;
                    ThreadInfo64->StackLimit64 = 
                        (ULONG64)(pExtThreadInfo->StackLimit);
                    ThreadInfo64->StartAddr64 = 0;
                    ThreadInfo64->StartAddr64 = 
                        (ULONG64)(pExtThreadInfo->ThreadInfo.StartAddress);
                    ThreadInfo64->Win32StartAddr64 = 0;
                    ThreadInfo64->Win32StartAddr64 = 
                        (ULONG64)(pExtThreadInfo->Win32StartAddress);
                    ThreadInfo64->UserStackBase64 = 0;
                    ThreadInfo64->UserStackLimit64 = 0;
                    ThreadInfo64->WaitMode = -1;
                }
                else {
                    ThreadInfo64->StackBase64 = 0;
                    ThreadInfo64->StackLimit64 = 0;
                    ThreadInfo64->StartAddr64 = 0;
                    ThreadInfo64->Win32StartAddr64 = 0;
                    ThreadInfo64->UserStackBase64 = 0;
                    ThreadInfo64->UserStackLimit64 = 0;
                    ThreadInfo64->WaitMode = -1;
                }
            }
            pThreadInfo  = (PSYSTEM_THREAD_INFORMATION)
                           ( (char*)pThreadInfo + SystemThreadInfoSize );
        }
    }
    return STATUS_SUCCESS;
}

void
EtwpLogImageLoadEvent(
    IN HANDLE ProcessID,
    IN PWMI_LOGGER_CONTEXT pLogger,
    IN PRTL_PROCESS_MODULE_INFORMATION pModuleInfo,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
)
{
    UNICODE_STRING wstrModuleName;
    ANSI_STRING    astrModuleName;
    ULONG          sizeModuleName;
    ULONG          sizeBuffer;
    PCHAR          pAuxInfo;
    PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;
    PWMI_IMAGELOAD_INFORMATION64 ImageLoadInfo64;

    if ((pLogger == NULL) || (pModuleInfo == NULL) || (pThreadInfo == NULL))
        return;

    RtlInitAnsiString( & astrModuleName, pModuleInfo->FullPathName);

    sizeModuleName = sizeof(WCHAR) * (astrModuleName.Length);
    if (!KernelWow64) { // normal case

        sizeBuffer     = sizeModuleName + sizeof(WCHAR)
                       + FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION, FileName);

        ImageLoadInfo = (PWMI_IMAGELOAD_INFORMATION)
                         EtwpGetTraceBuffer(
                            pLogger,
                            pThreadInfo,
                            EVENT_TRACE_GROUP_PROCESS + EVENT_TRACE_TYPE_LOAD,
                            sizeBuffer);

        if (ImageLoadInfo == NULL) {
            return;
        }

        ImageLoadInfo->ImageBase = pModuleInfo->ImageBase;
        ImageLoadInfo->ImageSize = pModuleInfo->ImageSize;
        ImageLoadInfo->ProcessId = HandleToUlong(ProcessID);

        wstrModuleName.Buffer    = (LPWSTR) &ImageLoadInfo->FileName[0];

        wstrModuleName.MaximumLength = (USHORT) sizeModuleName + sizeof(WCHAR);
        RtlAnsiStringToUnicodeString(& wstrModuleName, & astrModuleName, FALSE);
    }
    else { // KernelWow64
        sizeBuffer     = sizeModuleName + sizeof(WCHAR)
                       + FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION64, FileName);

        ImageLoadInfo64 = (PWMI_IMAGELOAD_INFORMATION64)
                         EtwpGetTraceBuffer(
                            pLogger,
                            pThreadInfo,
                            EVENT_TRACE_GROUP_PROCESS + EVENT_TRACE_TYPE_LOAD,
                            sizeBuffer);

        if (ImageLoadInfo64 == NULL) {
            return;
        }

        ImageLoadInfo64->ImageBase64 = 0;
        ImageLoadInfo64->ImageBase64 = (ULONG64)(pModuleInfo->ImageBase);
        ImageLoadInfo64->ImageSize64 = 0;
        ImageLoadInfo64->ImageSize64 = (ULONG64)(pModuleInfo->ImageSize);
        ImageLoadInfo64->ProcessId = HandleToUlong(ProcessID);

        wstrModuleName.Buffer    = (LPWSTR) &ImageLoadInfo64->FileName[0];

        wstrModuleName.MaximumLength = (USHORT) sizeModuleName + sizeof(WCHAR);
        RtlAnsiStringToUnicodeString(& wstrModuleName, & astrModuleName, FALSE);

    }
}

ULONG
EtwpSysModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
    )
{
    NTSTATUS   status = STATUS_SUCCESS;
    char     * pLargeBuffer1;
    ULONG      ReturnLength;
    ULONG      CurrentBufferSize;

    ULONG                           i;
    PRTL_PROCESS_MODULES            pModules;
    PRTL_PROCESS_MODULE_INFORMATION pModuleInfo;

    pLargeBuffer1 = EtwpMemReserve(MAX_BUFFER_SIZE);

    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    if (EtwpMemCommit(pLargeBuffer1, BUFFER_SIZE) == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    CurrentBufferSize = BUFFER_SIZE;

retry:
    status = NtQuerySystemInformation(
                    SystemModuleInformation,
                    pLargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength);

    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        // Increase buffer size. ReturnLength shows how much we need. Add
        // another 4K buffer for additional modules loaded since this call. 
        //
        if (CurrentBufferSize < ReturnLength) {
            CurrentBufferSize = ReturnLength;
        }
        CurrentBufferSize = PAGESIZE_MULTIPLE(CurrentBufferSize + SMALL_BUFFER_SIZE);

        if (EtwpMemCommit(pLargeBuffer1, CurrentBufferSize) == NULL)
        {
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    pModules = (PRTL_PROCESS_MODULES) pLargeBuffer1;

    for (i = 0, pModuleInfo = & (pModules->Modules[0]);
         i < pModules->NumberOfModules;
         i ++, pModuleInfo ++)
    {
        EtwpLogImageLoadEvent(NULL, pLogger, pModuleInfo, pThreadInfo);
    }

Cleanup:
    if (pLargeBuffer1)
    {
        EtwpMemFree(pLargeBuffer1);
    }
    return EtwpSetDosError(EtwpNtStatusToDosError(status));
}

ULONG
EtwpProcessModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN HANDLE                     ProcessID,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo)
{
    NTSTATUS               status = STATUS_SUCCESS;
    ULONG                  i;
    PRTL_DEBUG_INFORMATION pLargeBuffer1 = NULL;

    pLargeBuffer1 = RtlCreateQueryDebugBuffer(0, FALSE);
    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    status = RtlQueryProcessDebugInformation(
                    ProcessID,
                    RTL_QUERY_PROCESS_NONINVASIVE |  RTL_QUERY_PROCESS_MODULES,
                    pLargeBuffer1);

    if ( !NT_SUCCESS(status) || (pLargeBuffer1->Modules == NULL) )
    {
        goto Cleanup;
    }


    //
    // RtlQueryProcessDebugInformation call is returning a buffer from an 
    // untrusted source with pointers and offset and it isn't validating it. 
    // Therefore we can not assume that this buffer is trustworthy. 
    // Since we elevated our privilege to SE_DEBUG_PRIVILEGE we need a
    // condition handler here to exit cleanly and reset the privilege. 
    //
    //

    try {

        for (i = 0; i < pLargeBuffer1->Modules->NumberOfModules; i ++)
        {
            EtwpLogImageLoadEvent(
                    ProcessID,
                    pLogger,
                    & (pLargeBuffer1->Modules->Modules[i]),
                    pThreadInfo);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_NOACCESS;
    }

Cleanup:
    if (pLargeBuffer1)
    {
        RtlDestroyQueryDebugBuffer(pLargeBuffer1);
    }
    return EtwpSetDosError(EtwpNtStatusToDosError(status));
}

NTSTATUS
EtwpProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    )
{
    PSYSTEM_PROCESS_INFORMATION  pProcessInfo;
    PSYSTEM_THREAD_INFORMATION   pThreadInfo;
    char* LargeBuffer1;
    NTSTATUS status;
    ULONG ReturnLength;
    ULONG CurrentBufferSize;
    ULONG GroupType;
    ULONG TotalOffset = 0;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN WasEnabled = TRUE;
    BOOLEAN bExtended = TRUE;

    LargeBuffer1 = EtwpMemReserve ( MAX_BUFFER_SIZE );
    if (LargeBuffer1 == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (EtwpMemCommit (LargeBuffer1, BUFFER_SIZE) == NULL) {
        return STATUS_NO_MEMORY;
    }

    CurrentBufferSize = BUFFER_SIZE;
    retry:
    if (bExtended) {
        status = NtQuerySystemInformation(
                    SystemExtendedProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }
    else {
        status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //
        if (CurrentBufferSize < ReturnLength) {
            CurrentBufferSize = ReturnLength;
        }
        CurrentBufferSize = 
                      PAGESIZE_MULTIPLE(CurrentBufferSize + SMALL_BUFFER_SIZE);

        if (EtwpMemCommit (LargeBuffer1, CurrentBufferSize) == NULL) {
            return STATUS_NO_MEMORY;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {

        if (bExtended) {
            bExtended = FALSE;
            goto retry;
        }

        EtwpMemFree(LargeBuffer1);
        return(status);
    }


    //
    // Adjust Privileges to obtain the module information
    //


    if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    TRUE, FALSE, &WasEnabled);
        if (!NT_SUCCESS(status)) {
            status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                            TRUE, TRUE, &WasEnabled);
        }

        if (!NT_SUCCESS(status)) {
            EtwpMemFree(LargeBuffer1);
            return  (status);
        }
    }


    TotalOffset = 0;
    pProcessInfo = (SYSTEM_PROCESS_INFORMATION *) LargeBuffer1;
    while (TRUE) {
        ULONG Size;
        ULONG Length = 0;
        ULONG SidLength = 0;
        PUCHAR AuxPtr;
        PULONG_PTR AuxInfo;
        ANSI_STRING s;
        HANDLE Token;
        HANDLE pProcess;
        PCLIENT_ID Cid;
        ULONG TempInfo[128];
        PWMI_PROCESS_INFORMATION WmiProcessInfo;
        PWMI_PROCESS_INFORMATION64 WmiProcessInfo64;

        GroupType = EVENT_TRACE_GROUP_PROCESS +
                    ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                                 : EVENT_TRACE_TYPE_DC_END);

        pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);
        if (pProcessInfo->NumberOfThreads > 0) {
            Cid = (PCLIENT_ID) &pThreadInfo->ClientId;
        }
        else {
            Cid = NULL;
        }

        // if at termination, rundown thread first before process
        if ( (!StartFlag) &&
             (fEnableFlags & EVENT_TRACE_FLAG_THREAD) ){
            status = EtwpThreadRunDown(Logger,
                                       pProcessInfo,
                                       StartFlag,
                                       bExtended);
            if (!NT_SUCCESS(status)) {
                break;
            }

        }

        if (fEnableFlags & EVENT_TRACE_FLAG_PROCESS) {

            Length = 1;
            if ( pProcessInfo->ImageName.Buffer  &&
                     pProcessInfo->ImageName.Length > 0 ) {
                status = RtlUnicodeStringToAnsiString(
                                     &s,
                                     (PUNICODE_STRING)&pProcessInfo->ImageName,
                                     TRUE);
                if (NT_SUCCESS(status)) {
                    Length = s.Length + 1;
                }
            }

            InitializeObjectAttributes(
                    &objectAttributes, 0, 0, NULL, NULL);
            status = NtOpenProcess(
                                  &pProcess,
                                  PROCESS_QUERY_INFORMATION,
                                  &objectAttributes,
                                  Cid);
            if (NT_SUCCESS(status)) {
                status = NtOpenProcessToken(
                                      pProcess,
                                      TOKEN_READ,
                                      &Token);
                if (NT_SUCCESS(status)) {

                    status = NtQueryInformationToken(
                                             Token,
                                             TokenUser,
                                             TempInfo,
                                             256,
                                             &SidLength);
                    NtClose(Token);
                }
                NtClose(pProcess);
            }
            if ( (!NT_SUCCESS(status)) || SidLength <= 0) {
                TempInfo[0] = 0;
                SidLength = sizeof(ULONG);
            }

            if (!KernelWow64) {  // normal case
                Size = FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid);
                Size += Length + SidLength;
                WmiProcessInfo = (PWMI_PROCESS_INFORMATION)
                                  EtwpGetTraceBuffer( Logger,
                                                      pThreadInfo,
                                                      GroupType,
                                                      Size);
                if (WmiProcessInfo == NULL) {
                    status = STATUS_NO_MEMORY;
                    break;
                }
                WmiProcessInfo->ProcessId = 
                                  HandleToUlong( pProcessInfo->UniqueProcessId);
                WmiProcessInfo->ParentId = 
                    HandleToUlong( pProcessInfo->InheritedFromUniqueProcessId);
                WmiProcessInfo->SessionId = pProcessInfo->SessionId;

                WmiProcessInfo->PageDirectoryBase = 
                                                pProcessInfo->PageDirectoryBase;
                WmiProcessInfo->ExitStatus = 0;

                AuxPtr = (PUCHAR) (&WmiProcessInfo->Sid);

                RtlCopyMemory(AuxPtr, &TempInfo[0], SidLength);
                AuxPtr += SidLength;

                if (Length > 1) {
                    RtlCopyMemory(AuxPtr, s.Buffer, Length - 1);
                    AuxPtr += (Length - 1);
                    RtlFreeAnsiString(&s);
                }
                *AuxPtr = '\0';
                AuxPtr++;
            }
            else { // KernelWow64
                Size = FIELD_OFFSET(WMI_PROCESS_INFORMATION64, Sid);
                if (SidLength != sizeof(ULONG)) {
                    Size += Length + SidLength + 8;
                }
                else {
                    Size += Length + SidLength;
                }
                WmiProcessInfo64 = (PWMI_PROCESS_INFORMATION64)
                                   EtwpGetTraceBuffer( Logger,
                                                      pThreadInfo,
                                                      GroupType,
                                                      Size);
                if (WmiProcessInfo64 == NULL) {
                    status = STATUS_NO_MEMORY;
                    break;
                }
                WmiProcessInfo64->ProcessId = 
                                  HandleToUlong( pProcessInfo->UniqueProcessId);
                WmiProcessInfo64->ParentId = 
                     HandleToUlong( pProcessInfo->InheritedFromUniqueProcessId);
                WmiProcessInfo64->SessionId = pProcessInfo->SessionId;
                WmiProcessInfo64->PageDirectoryBase64 = 0;
                WmiProcessInfo64->PageDirectoryBase64 = 
                                     (ULONG64)(pProcessInfo->PageDirectoryBase);
                WmiProcessInfo64->ExitStatus = 0;

                // We need to widen TOKEN_USER structure before copying SID.
                // Technically, what follows is not the correct way to extend 
                // SID for Wow64. The correct way is to widen the pointer 
                // inside the TOKEN_USER structure within the returned SID blob.
                // However, we don't really care what the pointer value is, we 
                // just need to know that it is not 0. Hence, we copy 
                // TOKEN_USER first, leave some space out, and we copy the 
                // actual SID.

                AuxPtr = (PUCHAR) (&WmiProcessInfo64->Sid);
                if (SidLength > 8) {
                    RtlCopyMemory(AuxPtr, &TempInfo[0], 8);
                    RtlCopyMemory((AuxPtr + 16), &(TempInfo[2]), SidLength - 8);
                    AuxPtr += SidLength + 8;
                }
                else if (SidLength == sizeof(ULONG)) { 
                    RtlCopyMemory(AuxPtr, &TempInfo[0], SidLength);
                    AuxPtr += SidLength;
                }
                else { // This really cannot/should not happen.
                    RtlCopyMemory(AuxPtr, &TempInfo[0], SidLength);
                    AuxPtr += SidLength + 8;
                }
                if (Length > 1) {
                    RtlCopyMemory(AuxPtr, s.Buffer, Length - 1);
                    AuxPtr += (Length - 1);
                    RtlFreeAnsiString(&s);
                }
                *AuxPtr = '\0';
                AuxPtr++;
            }
        }


        // if at beginning, trace threads after process
        if (StartFlag) {

            if (fEnableFlags & EVENT_TRACE_FLAG_THREAD) {
                EtwpThreadRunDown(Logger, pProcessInfo, StartFlag, bExtended);
            }

            if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
                if (pProcessInfo->UniqueProcessId == 0) {
                    EtwpSysModuleRunDown(Logger, pThreadInfo);
                }
                else
                    EtwpProcessModuleRunDown(
                            Logger,
                            (HANDLE) pProcessInfo->UniqueProcessId,
                            pThreadInfo);
            }
        }
        if (pProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    //
    // Restore privileges back to what it was before
    //


    if ( (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) && WasEnabled ) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    FALSE,
                                    FALSE,
                                    &WasEnabled);
        if (!NT_SUCCESS(status)) {
            status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    FALSE,
                                    TRUE,
                                    &WasEnabled);
        }
    }

    EtwpMemFree(LargeBuffer1);

    return status;
}

VOID
EtwpInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    )
{
    PSTRING s = (PSTRING) Destination;

    s->Buffer = Buffer;
    s->Length = 0;
    if (Buffer != NULL)
        s->MaximumLength = (USHORT) Size;
    else
        s->MaximumLength = 0;
}

ULONG 
EtwpRelogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PSYSTEM_TRACE_HEADER RelogProp
    )
{
    PTRACE_LOGFILE_HEADER RelogFileHeader;
    LPWSTR FileName = NULL;
    ULONG RelogPropSize;
    HANDLE LogFile = INVALID_HANDLE_VALUE;
    ULONG BufferSize;
    IO_STATUS_BLOCK IoStatus;
    PWMI_BUFFER_HEADER Buffer;
    LPWSTR FileNameBuffer = NULL;
    PUCHAR BufferSpace;
    NTSTATUS Status;

    RelogFileHeader = (PTRACE_LOGFILE_HEADER) ((PUCHAR)RelogProp +
                                               sizeof(SYSTEM_TRACE_HEADER) );
    RelogPropSize = RelogProp->Packet.Size;
    FileName = (LPWSTR) LoggerInfo->LogFileName.Buffer;
    if (FileName == NULL) {
        return EtwpSetDosError(ERROR_BAD_PATHNAME);
    }
    LogFile = EtwpCreateFileW(
                FileName,
                GENERIC_WRITE,
                FILE_SHARE_READ, 
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
                
                
                                

    if (LogFile == INVALID_HANDLE_VALUE) {
        return EtwpGetLastError();
    }

    LoggerInfo->LogFileHandle = LogFile;
    LoggerInfo->NumberOfProcessors = RelogFileHeader->NumberOfProcessors;

    if (8 == RelogFileHeader->PointerSize && 4 == sizeof(PVOID)) {

        LoggerInfo->Wnode.ClientContext = 
                           *((PULONG)((PUCHAR)RelogFileHeader + 
                           FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) + 
                           8));
    }
    else if (4 == RelogFileHeader->PointerSize && 8 == sizeof(PVOID)) {

        LoggerInfo->Wnode.ClientContext = 
                           *((PULONG)((PUCHAR)RelogFileHeader + 
                           FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) 
                           - 8));
    }
    else {
        LoggerInfo->Wnode.ClientContext = RelogFileHeader->ReservedFlags;
    }

    BufferSize = LoggerInfo->BufferSize * 1024;
    BufferSpace   = EtwpAlloc(BufferSize);
    if (BufferSpace == NULL) {
        NtClose(LogFile);
        return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // initialize buffer first
    RtlZeroMemory(BufferSpace, BufferSize);
    Buffer         = (PWMI_BUFFER_HEADER) BufferSpace;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);

    //
    // We are making this an Application Trace always. 
    // However, if two application traces are relogged
    // the Guidmaps are not really consolidated. 
    //

    Buffer->Wnode.Guid   = LoggerInfo->Wnode.Guid;
    RelogFileHeader->LogFileMode = EVENT_TRACE_RELOG_MODE;

    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Flags   = WNODE_FLAG_TRACED_GUID;
    RelogFileHeader->BuffersWritten = 1;
    LoggerInfo->BuffersWritten = 1;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER) + RelogPropSize;
    //
    // Copy the Old LogFileHeader 
    //
    RtlCopyMemory((char*) Buffer + sizeof(WMI_BUFFER_HEADER),
                  RelogProp,
                  RelogPropSize 
                 );

    if (Buffer->Offset < BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                BufferSize - Buffer->Offset,
                0xFF);
    }
    Buffer->BufferType = WMI_BUFFER_TYPE_RUNDOWN;
    Buffer->BufferFlag = WMI_BUFFER_FLAG_FLUSH_MARKER;
    Status = NtWriteFile(
            LogFile,
            NULL,
            NULL,
            NULL,
            &IoStatus,
            BufferSpace,
            BufferSize,
            NULL,
            NULL);
    NtClose(LogFile);

    LogFile = EtwpCreateFileW(
                 FileName,
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_NO_BUFFERING,
                 NULL
                 );

    EtwpFree(BufferSpace);

    if (LogFile == INVALID_HANDLE_VALUE) {
        return EtwpGetLastError();
    }
    LoggerInfo->LogFileHandle = LogFile;

    return ERROR_SUCCESS;

}

ULONG
EtwpFixLogFileHeaderForWow64(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    IN OUT PTRACE_LOGFILE_HEADER LogfileHeader
    )
{
    PUCHAR TempSpace = NULL;
    PULONG64 Ulong64Ptr;
    ULONG SizeNeeded = 0;
    
    if (LoggerInfo == NULL || LogfileHeader == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    SizeNeeded = sizeof(TRACE_LOGFILE_HEADER)
                    + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                    + LoggerInfo->LogFileName.Length + sizeof(WCHAR)
                    + 8;

    TempSpace = EtwpAlloc(SizeNeeded);
    if (TempSpace == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(TempSpace, SizeNeeded);
    RtlCopyMemory(TempSpace, LogfileHeader, sizeof(TRACE_LOGFILE_HEADER));
    Ulong64Ptr = (PULONG64)(TempSpace + FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName));
    *Ulong64Ptr = (ULONG64)((PUCHAR)LogfileHeader + sizeof(TRACE_LOGFILE_HEADER) + 8);
    RtlCopyMemory((TempSpace + sizeof(TRACE_LOGFILE_HEADER) + 8),
                    LogfileHeader->LoggerName,
                    LoggerInfo->LoggerName.Length + sizeof(WCHAR));
    Ulong64Ptr++;
    *Ulong64Ptr = (ULONG64)((PUCHAR)LogfileHeader + sizeof(TRACE_LOGFILE_HEADER) 
                            + LoggerInfo->LoggerName.Length  + sizeof(WCHAR) + 8);
    RtlCopyMemory((TempSpace + sizeof(TRACE_LOGFILE_HEADER) + LoggerInfo->LoggerName.Length + sizeof(WCHAR) + 8),
                    LogfileHeader->LogFileName,
                    LoggerInfo->LogFileName.Length + sizeof(WCHAR));
    Ulong64Ptr++;
    RtlCopyMemory((PUCHAR)Ulong64Ptr, &(LogfileHeader->TimeZone), 
            sizeof(TRACE_LOGFILE_HEADER) - FIELD_OFFSET(TRACE_LOGFILE_HEADER, TimeZone));

    RtlCopyMemory(LogfileHeader, TempSpace, SizeNeeded);
    EtwpFree(TempSpace);
    return ERROR_SUCCESS;

}

ULONG
EtwpAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK              RefClock,
    IN     ULONG                   Update
    )
/*++

Routine Description:

    This routine creates a new log file header or updates an existing header 
    from an existing log file. StartTrace() and ControlTrace() will call this 
    routine to keep the log file header persistent.

    Notes:
    - Special cases should be considered carefully. 
        1. Append case: The headers should be read from a file first, and 
           certain parameters specified by the user cannot be updated depending
           on the value in the existing log file. In particular, the SystemTime
           field in the header need to be updated accordingly.
        2. Update case: Similar to the case above. However, we do QueryTrace()
           to get the latest info on the logging session instead of reading a 
           file header. Append and Update modes are mutually exclusive.
        3. Circular log file case: StartBuffers gets set to 
           LoggerInfo.BuffersWritten for correct post processing.
        4. Private logger case: LoggerInfo->Checksum is NULL if this is a 
           private logger.
        5. Prealloc log file case: This is the routine that extends the file 
           size. It happens at the end of the routine, just before closing and 
           opening the file for the second time.
        6. WOW64 case: Collecting kernel data under Wow64 is special in the
           sense that kernel events will still have 64-bit pointer while some 
           user mode events (DCSTART and DCEND and Image events) will have
           thunked pointers. For this reason, all events for kernel tracing on
           ia64 machines will have 64-bit pointers and PointerSize will be 
           adjusted to 8 bytes if under Wow64.
        7. PrivateLogger: We should not call QueryLogger from this routine.
           That will result in a deadlock since pump thread is executing
           this code and it could block on the call waiting for itself
           to respond. 
           
    - LogFile is a handle to a log file.  When this routine returns with success
      a handle to the logfile is open. If you call START or UPDATE ioctl 
      then it will be closed in the kernel (whether or not the call succeeds). 
    - Checksum, FileNameBuffer and Logger.BufferSpace are temporary spaces 
      allocated and used in this routine. Make sure they are freed before
      all exits.

Arguments:

    LoggerInfo      Structure that keeps the information about a logger under 
                    consideration. This will be properly updated. LogFileHandle
                    field will have a valid handle to a newly created log file.
    RefClock        Reference clock. The SystemTIme field in the header will be
                    updated accordingly. Used only in kernel trace.
    Update          Whether this is an update operation or not. Certain 
                    parameters in the LoggerInfo (notably BufferSize) will not 
                    be updated if this is TRUE.

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    HANDLE LogFile = INVALID_HANDLE_VALUE;
    ULONG BufferSize;
    ULONG MemorySize;
    ULONG TraceKernel;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    WMI_LOGGER_CONTEXT Logger;
    IO_STATUS_BLOCK IoStatus;
    PWMI_BUFFER_HEADER Buffer;
    FILE_POSITION_INFORMATION FileInfo;
    LPWSTR FileName = NULL;
    LPWSTR FileNameBuffer = NULL;
    ULONG HeaderSize;
    ULONG AppendPointerSize = 0;

    struct WMI_LOGFILE_HEADER {
           WMI_BUFFER_HEADER    BufferHeader;
           SYSTEM_TRACE_HEADER  SystemHeader;
           TRACE_LOGFILE_HEADER LogFileHeader;
    };
    struct WMI_LOGFILE_HEADER LoggerBuffer;
    BOOLEAN bLogFileAppend =
                    (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)
                  ? (TRUE) : (FALSE);

    if ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)  &&
        (LoggerInfo->LogFileName.Length > 0)) {
        HRESULT hr;

        FileName = (LPWSTR) EtwpAlloc(LoggerInfo->LogFileName.Length + 64);
        if (FileName == NULL) {
            return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        //
        // The LogFilePatten has already been validated
        //
        hr = StringCbPrintfW(FileName, 
                             LoggerInfo->LogFileName.Length + 64, 
                             LoggerInfo->LogFileName.Buffer, 
                             1);
        if (FAILED(hr)) {
            EtwpFree(FileName);
            return HRESULT_CODE(hr);
        }
        
        FileNameBuffer = FileName;
    }
    if (FileName == NULL)
        FileName = (LPWSTR) LoggerInfo->LogFileName.Buffer;

    //
    // If it is Append Mode, we need to open the file and make sure the
    // pick up the BufferSize
    //

    if ( bLogFileAppend ) {

        FILE_STANDARD_INFORMATION FileStdInfo;
        
        ULONG ReadSize   = sizeof(WMI_BUFFER_HEADER)
                         + sizeof(SYSTEM_TRACE_HEADER)
                         + sizeof(TRACE_LOGFILE_HEADER);
        ULONG nBytesRead = 0;

        //
        //  Update and Append do not mix. To Append LoggerInfo
        //  must have LogFileName
        //

        if ( (Update) || (LoggerInfo->LogFileName.Length <= 0) ) {
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }

        LogFile = EtwpCreateFileW(FileName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (LogFile == INVALID_HANDLE_VALUE) {
            // cannot OPEN_EXISTING, assume that logfile is not there and
            // create a new one.
            //
            bLogFileAppend = FALSE;
            LoggerInfo->LogFileMode = LoggerInfo->LogFileMode
                                    & (~ (EVENT_TRACE_FILE_MODE_APPEND));
        }
        else {
            // read TRACE_LOGFILE_HEADER structure and update LoggerInfo
            // members.
            //
            Status = EtwpReadFile(LogFile,
                              (LPVOID) & LoggerBuffer,
                              ReadSize,
                              & nBytesRead,
                              NULL);
            if (nBytesRead < ReadSize) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                return EtwpSetDosError(ERROR_BAD_PATHNAME);
            }
            if (  LoggerBuffer.LogFileHeader.LogFileMode
                & EVENT_TRACE_FILE_MODE_CIRCULAR) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                return EtwpSetDosError(ERROR_BAD_PATHNAME);
            }
            AppendPointerSize = LoggerBuffer.LogFileHeader.PointerSize;
            LoggerInfo->BufferSize =
                            LoggerBuffer.LogFileHeader.BufferSize / 1024;

            //
            // Check to see if the values from the logfile are valid. 
            //
            if ( (LoggerInfo->BufferSize == 0)  || 
                 (LoggerInfo->BufferSize  > MAX_ETW_BUFFERSIZE) ) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                return EtwpSetDosError(ERROR_INVALID_DATA);
            }

            //
            // If it's append, the GuidMap buffers are not accounted for
            // in the BuffersWritten count. The starttrace call will fail
            // on checksum error if it is not adjusted properly. However, 
            // this will trash the GuidMap entries in this file.
            //
            Status = NtQueryInformationFile(
                        LogFile,
                        &IoStatus,
                        &FileStdInfo,
                        sizeof(FILE_STANDARD_INFORMATION),
                        FileStandardInformation
                            );
            if (NT_SUCCESS(Status)) {
                ULONG64 FileSize = FileStdInfo.AllocationSize.QuadPart;
                ULONG64 BuffersWritten = 0;

                if (LoggerBuffer.LogFileHeader.BufferSize > 0) {
                    BuffersWritten = FileSize / 
                                 (ULONG64)LoggerBuffer.LogFileHeader.BufferSize;
                }
                LoggerInfo->BuffersWritten = (ULONG)BuffersWritten;
                LoggerBuffer.LogFileHeader.BuffersWritten = (ULONG)BuffersWritten;
            }
            else {
               NtClose(LogFile);
               if (FileNameBuffer != NULL) {
                   EtwpFree(FileNameBuffer);
               }
                return EtwpNtStatusToDosError(Status);
            }

            LoggerInfo->MaximumFileSize =
                            LoggerBuffer.LogFileHeader.MaximumFileSize;

            // Write back logfile append mode so EtwpFinalizeLogFile() correctly
            // update BuffersWritten field
            //
            FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(EndTime);
            Status = NtSetInformationFile(LogFile,
                                          & IoStatus,
                                          & FileInfo,
                                          sizeof(FILE_POSITION_INFORMATION),
                                          FilePositionInformation);
            if (!NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                return EtwpSetDosError(EtwpNtStatusToDosError(Status));
            }
            LoggerBuffer.LogFileHeader.EndTime.QuadPart = 0;
            Status = NtWriteFile(LogFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 & IoStatus,
                                 & LoggerBuffer.LogFileHeader.EndTime,
                                 sizeof(LARGE_INTEGER),
                                 NULL,
                                 NULL);
            if (! NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                return EtwpSetDosError(EtwpNtStatusToDosError(Status));
            }

            // build checksum structure
            //
            if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                LoggerInfo->Checksum = NULL;
            }
            else {
                LoggerInfo->Checksum = EtwpAlloc(
                        sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER));
                if (LoggerInfo->Checksum != NULL) {
                    PBYTE ptrChecksum = LoggerInfo->Checksum;
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.BufferHeader,
                                  sizeof(WNODE_HEADER));
                    ptrChecksum += sizeof(WNODE_HEADER);
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.LogFileHeader,
                                  sizeof(TRACE_LOGFILE_HEADER));
                }
                else {
                    NtClose(LogFile);
                    if (FileNameBuffer != NULL) {
                        EtwpFree(FileNameBuffer);
                    }
                    return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }
    }

    // get the system parameters first

    LoggerInfo->LogFileHandle = NULL;

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &SystemInfo, sizeof (SystemInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        if (LogFile != INVALID_HANDLE_VALUE) {
            // for APPEND case, the file is already opened
            NtClose(LogFile);
        }
        if (FileNameBuffer != NULL) {
            EtwpFree(FileNameBuffer);
        }
        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
        LoggerInfo->Checksum = NULL;
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

    // choose some logical default value for buffer size if user
    // has not provided one

    MemorySize = (ULONG)(SystemInfo.NumberOfPhysicalPages * SystemInfo.PageSize
                    / 1024 / 1024);
    if (MemorySize <= 64) {
        BufferSize      = SystemInfo.PageSize;
    }
    else if (MemorySize <= 512) {
        BufferSize      = SystemInfo.PageSize * 2;
    }
    else {
        BufferSize      = 64 * 1024;        // allocation size
    }

    if (LoggerInfo->BufferSize > 1024)      // limit to 1Mb
        BufferSize = 1024 * 1024;
    else if (LoggerInfo->BufferSize > 0)
        BufferSize = LoggerInfo->BufferSize * 1024;

    TraceKernel = IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid);
    if (!TraceKernel) {
        GUID guid;
        RtlZeroMemory(&guid, sizeof(GUID));
        if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &guid)) {
            // Generate a Guid for this logger stream
            // This will ensure  buffer filtering at the WMI service
            // based on this GUID.
            UUID uid;
            EtwpUuidCreate(&uid);
            LoggerInfo->Wnode.Guid = uid;
        }
    }

    if (LoggerInfo->LogFileName.Length <= 0) {
        if (LogFile != INVALID_HANDLE_VALUE) {
            // for APPEND case, the file is already opened
            NtClose(LogFile);
        }
        if (FileNameBuffer != NULL) {
            EtwpFree(FileNameBuffer);
        }
        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
        LoggerInfo->Checksum = NULL;
        return  ERROR_SUCCESS; //goto SendToKm;
    }
    //
    // We assumed the exposed API has checked for either RealTime or FileName
    // is provided

    //
    // If this is an Update call, then we need to pick up the original
    // buffer size for the LogFileHeader.
    // Otherwise, use the one computed above.
    //
    // For private loggers, a valid logger info is already given. Also, 
    // we can't afford nested IOCTL/MBReply for doing QueryLogger.
    //
    if (!Update) {
        LoggerInfo->BufferSize = BufferSize / 1024;
    }
    else if (!(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
        // Update case. This block is not needed for private loggers.
        PWMI_LOGGER_INFORMATION pTempLoggerInfo;
        PWCHAR strLoggerName = NULL;
        PWCHAR strLogFileName = NULL;
        ULONG ErrCode;
        ULONG SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + MAXSTR * sizeof(WCHAR) * 2;
        ULONG CurrentProcWow = FALSE;

        SizeNeeded = (SizeNeeded +7) & ~7;
        pTempLoggerInfo = EtwpAlloc(SizeNeeded);
        if (pTempLoggerInfo == NULL) {
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        RtlZeroMemory(pTempLoggerInfo, SizeNeeded);
        pTempLoggerInfo->Wnode.BufferSize = SizeNeeded;
        pTempLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
        pTempLoggerInfo->Wnode.HistoricalContext = LoggerInfo->Wnode.HistoricalContext;
        pTempLoggerInfo->Wnode.Guid = LoggerInfo->Wnode.Guid;

        strLoggerName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION));
        EtwpInitString(&pTempLoggerInfo->LoggerName,
                       strLoggerName,
                       MAXSTR * sizeof(WCHAR));
        if (LoggerInfo->LoggerName.Length > 0) {
            RtlCopyUnicodeString( &pTempLoggerInfo->LoggerName,
                                  &LoggerInfo->LoggerName);
        }


        strLogFileName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION)
                                    + MAXSTR * sizeof(WCHAR) );
        EtwpInitString(&pTempLoggerInfo->LogFileName,
                       strLogFileName,
                       MAXSTR * sizeof(WCHAR) );

        //
        // Call QueryLogger
        //
        ErrCode = EtwpQueryLogger(pTempLoggerInfo, FALSE);

        if (ErrCode != ERROR_SUCCESS) {
            EtwpFree(pTempLoggerInfo);
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(ErrCode);
        }
        BufferSize = pTempLoggerInfo->BufferSize * 1024;
        if (!TraceKernel && (sizeof(PVOID) != 8)) {
            // For kernel trace, the pointer size is always 64 on ia64, 
            // whether or not under Wow64.
            // Get Wow64 information, set the flag, and adjust the pointer size.
            ULONG_PTR ulp;
            Status = NtQueryInformationProcess(
                        NtCurrentProcess(),
                        ProcessWow64Information,
                        &ulp,
                        sizeof(ULONG_PTR),
                        NULL);
            if (NT_SUCCESS(Status) && (ulp != 0)) {
                CurrentProcWow = TRUE;
            }
        }
        if ( (pTempLoggerInfo->Wow && !TraceKernel && 8 == sizeof(PVOID)) || 
            (CurrentProcWow && !(pTempLoggerInfo->Wow)) ) {
            // We're trying to do 64 bit mode update on a non-kernel logger 
            // that started in 32 bit, or vice versa. We don't allow this.
            EtwpFree(pTempLoggerInfo);
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(ERROR_NOT_SUPPORTED);
        }
        EtwpFree(pTempLoggerInfo);
    }

    //
    // Now open the file for writing synchronously for the logger
    // others may want to read it as well.
    // For logfile append mode, logfile has been opened previously
    //
    if (!bLogFileAppend) {
        LogFile = EtwpCreateFileW(
                    FileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

        if (LogFile == INVALID_HANDLE_VALUE) {
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            return EtwpGetLastError();
        }
    }

    LoggerInfo->LogFileHandle = LogFile;
    //
    // All returns for error cases should have NtClose(LogFile). 
    //

    if (TraceKernel && (sizeof(PVOID) != 8)) {
        // For kernel trace, the pointer size is always 64 on ia64, 
        // whether or not under Wow64.
        // Get Wow64 information, set the flag, and adjust the pointer size.
        ULONG_PTR ulp;
        Status = NtQueryInformationProcess(
                    NtCurrentProcess(),
                    ProcessWow64Information,
                    &ulp,
                    sizeof(ULONG_PTR),
                    NULL);
        if (NT_SUCCESS(Status) && (ulp != 0)) {
            KernelWow64 = TRUE;
        }
    }

    //
    // Before Allocating the Buffer for Logfile Header make
    // sure the buffer size is atleast as large as the LogFileHeader
    //
    if (!KernelWow64) { 
        HeaderSize =  sizeof(LoggerBuffer)
                            + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                            + LoggerInfo->LogFileName.Length + sizeof(WCHAR);
    }
    else {
        HeaderSize =  sizeof(LoggerBuffer)
                            + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                            + LoggerInfo->LogFileName.Length + sizeof(WCHAR)
                            + 8;
    }

    if (HeaderSize > BufferSize) {
        //
        //  Round it to the nearest power of 2 and check for max size 1 MB
        //
        double dTemp = log (HeaderSize / 1024.0) / log (2.0);
        ULONG lTemp = (ULONG) (dTemp + 0.99);
        HeaderSize = (1 << lTemp);
        if (HeaderSize > 1024) {
            NtClose(LogFile);
            LoggerInfo->LogFileHandle = NULL;
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        LoggerInfo->BufferSize = HeaderSize;
        BufferSize = HeaderSize * 1024;
    }

    //
    // allocate a buffer to write logger header and process/thread
    // rundown information
    //
    Logger.LogFileHandle   = LogFile;
    Logger.BufferSize      = BufferSize;
    Logger.TimerResolution = SystemInfo.TimerResolution;
    Logger.BufferSpace     = EtwpAlloc(BufferSize);
    if (Logger.BufferSpace == NULL) {
        NtClose(LogFile);
        LoggerInfo->LogFileHandle = NULL;
        if (FileNameBuffer != NULL) {
            EtwpFree(FileNameBuffer);
        }
        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
        LoggerInfo->Checksum = NULL;
        return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    //
    // All returns for error cases must have EtwpFree(Logger.BufferSpace) also.
    //

    Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

    // initialize buffer first
    RtlZeroMemory(Logger.BufferSpace, BufferSize);
    Buffer         = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
    if (TraceKernel) {
        Buffer->Wnode.Guid   = SystemTraceControlGuid;
    }
    else {
        Buffer->Wnode.Guid   = LoggerInfo->Wnode.Guid;
    }
    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Flags      = WNODE_FLAG_TRACED_GUID;
    Buffer->BufferType       = WMI_BUFFER_TYPE_RUNDOWN;
    Buffer->BufferFlag       = WMI_BUFFER_FLAG_FLUSH_MARKER;

    if (bLogFileAppend) {
        ULONG CurrentPointerSize = sizeof(PVOID);
        if (KernelWow64) {
            CurrentPointerSize = sizeof(ULONG64);
        }
        if (AppendPointerSize != CurrentPointerSize) {
            NtClose(LogFile);
            LoggerInfo->LogFileHandle = NULL;
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(ERROR_INVALID_PARAMETER);
        }
        Logger.BuffersWritten  = LoggerBuffer.LogFileHeader.BuffersWritten;
        EtwpSetFilePointer(LogFile, 0, NULL, FILE_END);
    }
    else {
        PTRACE_LOGFILE_HEADER LogfileHeader;
        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER Frequency;
        ULONG CpuNum = 0, CpuSpeed;
        PPEB Peb;
        
        Status = NtQueryPerformanceCounter(&CurrentTime, &Frequency);

        Logger.BuffersWritten  = 0;
        if (!KernelWow64) {
            HeaderSize =  sizeof(TRACE_LOGFILE_HEADER)
                            + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                            + LoggerInfo->LogFileName.Length + sizeof(WCHAR);
        }
        else {
            HeaderSize =  sizeof(TRACE_LOGFILE_HEADER)
                            + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                            + LoggerInfo->LogFileName.Length + sizeof(WCHAR)
                            + 8;
        }
        LogfileHeader = (PTRACE_LOGFILE_HEADER)
                        EtwpGetTraceBuffer(
                            &Logger,
                            NULL,
                            EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_INFO,
                            HeaderSize
                            );
        if (LogfileHeader == NULL) {
            NtClose(LogFile);
            LoggerInfo->LogFileHandle = NULL;
            EtwpFree(Logger.BufferSpace);
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }


        LogfileHeader->PerfFreq = Frequency;
        LogfileHeader->ReservedFlags = Logger.UsePerfClock;
        if (NT_SUCCESS(EtwpGetCpuSpeed(&CpuNum, &CpuSpeed))) {
            LogfileHeader->CpuSpeedInMHz = CpuSpeed;
        }

        //
        // Start and End Times are wall clock time
        //
        if (RefClock != NULL) {
            PSYSTEM_TRACE_HEADER Header;
            LogfileHeader->StartTime = RefClock->StartTime;
            Header = (PSYSTEM_TRACE_HEADER) ( (char *) LogfileHeader - 
                                                  sizeof(SYSTEM_TRACE_HEADER) );
            Header->SystemTime = RefClock->StartPerfClock;
        }
        else {
            LogfileHeader->StartTime.QuadPart = EtwpGetSystemTime();
        }

        Peb = NtCurrentPeb();

        LogfileHeader->BufferSize = BufferSize;
        LogfileHeader->VersionDetail.MajorVersion =
                                         (UCHAR)Peb->OSMajorVersion;
        LogfileHeader->VersionDetail.MinorVersion =
                                         (UCHAR)Peb->OSMinorVersion;
        LogfileHeader->VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
        LogfileHeader->VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
        LogfileHeader->ProviderVersion = Peb->OSBuildNumber;
        LogfileHeader->StartBuffers = 1;
        LogfileHeader->LogFileMode
                = LoggerInfo->LogFileMode & (~(EVENT_TRACE_REAL_TIME_MODE));
        LogfileHeader->NumberOfProcessors = SystemInfo.NumberOfProcessors;
        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
        {
            LoggerInfo->NumberOfProcessors = SystemInfo.NumberOfProcessors;
        }
        LogfileHeader->MaximumFileSize = LoggerInfo->MaximumFileSize;

        LogfileHeader->TimerResolution = SystemInfo.TimerResolution;

        LogfileHeader->LoggerName = (PWCHAR) ( (PUCHAR) LogfileHeader
                                    + sizeof(TRACE_LOGFILE_HEADER) );
        LogfileHeader->LogFileName = (PWCHAR) ((PUCHAR)LogfileHeader->LoggerName
                                    + LoggerInfo->LoggerName.Length
                                    + sizeof (WCHAR));
        RtlCopyMemory(LogfileHeader->LoggerName,
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length + sizeof(WCHAR));
        RtlCopyMemory(LogfileHeader->LogFileName,
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length + sizeof(WCHAR));
        EtwpGetTimeZoneInformation(&LogfileHeader->TimeZone);
        LogfileHeader->PointerSize = sizeof(PVOID);
        if (KernelWow64) {
            LogfileHeader->PointerSize = sizeof(ULONG64);
        }

        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            LoggerInfo->Checksum = NULL;
        }
        else {
            LoggerInfo->Checksum = EtwpAlloc(
                            sizeof(WNODE_HEADER)
                          + sizeof(TRACE_LOGFILE_HEADER));
            if (LoggerInfo->Checksum != NULL) {
                PBYTE ptrChecksum = LoggerInfo->Checksum;
                RtlCopyMemory(ptrChecksum, Buffer, sizeof(WNODE_HEADER));
                ptrChecksum += sizeof(WNODE_HEADER);
                RtlCopyMemory(
                    ptrChecksum, LogfileHeader, sizeof(TRACE_LOGFILE_HEADER));
            }
            else {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (KernelWow64) {
            // ****************** IMPORTANT!!! *********************************
            // We need to fix the kernel logfile header here so that the 
            // header looks like 64 bit structure under Wow64. After this point,
            // BuffersWritten and StartBuffers are updated in this function 
            // after this point, but they are below the troublesome pointers, 
            // so it's OK.
            ULONG FixedHeaderStatus = EtwpFixLogFileHeaderForWow64(
                                                            LoggerInfo, 
                                                            LogfileHeader
                                                            );
            if (FixedHeaderStatus != ERROR_SUCCESS) {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(FixedHeaderStatus);
            }
        }
    }

    //
    // Dump the hardware config to File at the Start if it is a kernel logger
    //
    if (!Update) {
        if (TraceKernel) {
            ULONG EnableFlags = LoggerInfo->EnableFlags;
            PPERFINFO_GROUPMASK PGroupMask;
            HeaderSize = sizeof (PERFINFO_GROUPMASK); 

            PGroupMask  = (PPERFINFO_GROUPMASK) 
                          EtwpGetTraceBuffer( &Logger,
                                              NULL, 
                                              EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_EXTENSION, 
                                              HeaderSize );

            if (PGroupMask == NULL) {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }

            RtlZeroMemory( PGroupMask, HeaderSize);

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;
                EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
                if (tFlagExt->Length) {
                    RtlCopyMemory( PGroupMask, 
                                   (PCHAR)LoggerInfo + tFlagExt->Offset, 
                                   tFlagExt->Length * sizeof(ULONG));
                }
            } else {
                PGroupMask->Masks[0] = EnableFlags;
            }

            EtwpDumpHardwareConfig(&Logger);
            EtwpProcessRunDown( &Logger, TRUE, EnableFlags );
        } 
        else {
            if(IsEqualGUID(&NtdllTraceGuid, &LoggerInfo->Wnode.Guid)  && 
                                                           IsHeapLogging(NULL)){
                //Currently the return status of DumpHeapSnapShot is ignored.
                DumpHeapSnapShot(&Logger);
            }
        }
    }

    Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    // flush the last buffer
    if ( (Buffer->Offset < Logger.BufferSize)     &&
         (Buffer->Offset > sizeof(WMI_BUFFER_HEADER)) )
    {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                Logger.BufferSize - Buffer->Offset,
                0xFF);
        Status = NtWriteFile(
                LogFile,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                Logger.BufferSpace,
                BufferSize,
                NULL,
                NULL);

        Logger.BuffersWritten++;
    }

    if ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        // We need to write the number of StartBuffers in the
        // Circular Logfile header to process it properly.

        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(StartBuffers);

        Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
        if (!NT_SUCCESS(Status)) {
            NtClose(LogFile);
            LoggerInfo->LogFileHandle = NULL;
            EtwpFree(Logger.BufferSpace);
            if (FileNameBuffer != NULL) {
                EtwpFree(FileNameBuffer);
            }
            if (LoggerInfo->Checksum != NULL) {
                EtwpFree(LoggerInfo->Checksum);
            }
            LoggerInfo->Checksum = NULL;
            return EtwpSetDosError(EtwpNtStatusToDosError(Status));
        }

        Status = NtWriteFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &Logger.BuffersWritten,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
        if (NT_SUCCESS(Status)) {
            PTRACE_LOGFILE_HEADER pLogFileHeader;

            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);

            //
            // update StartBuffers in Checksum
            //
            if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
                // Checksum should have been allocated and copied 
                // if not a private logger
                if (LoggerInfo->Checksum == NULL) {
                    NtClose(LogFile);
                    LoggerInfo->LogFileHandle = NULL;
                    EtwpFree(Logger.BufferSpace);
                    if (FileNameBuffer != NULL) {
                        EtwpFree(FileNameBuffer);
                    }
                    if (LoggerInfo->Checksum != NULL) {
                        EtwpFree(LoggerInfo->Checksum);
                    }
                    LoggerInfo->Checksum = NULL;
                    return EtwpSetDosError(ERROR_INVALID_DATA);
                }
                pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                       (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
                pLogFileHeader->StartBuffers = Logger.BuffersWritten;
            }
        }
    }

    //
    // As a last thing update the Number of BuffersWritten so far
    // in the header and also update the checksum. This is to prevent
    // Logger failing Update calls under high load.
    //

    FileInfo.CurrentByteOffset.QuadPart =
                    LOGFILE_FIELD_OFFSET(BuffersWritten);

    Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
    if (!NT_SUCCESS(Status)) {
        NtClose(LogFile);
        LoggerInfo->LogFileHandle = NULL;
        EtwpFree(Logger.BufferSpace);
        if (FileNameBuffer != NULL) {
            EtwpFree(FileNameBuffer);
        }
        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
        LoggerInfo->Checksum = NULL;
        return EtwpSetDosError(EtwpNtStatusToDosError(Status));
    }

    Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &Logger.BuffersWritten,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
    if (NT_SUCCESS(Status)) {
        PTRACE_LOGFILE_HEADER pLogFileHeader;

        NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);

        // update StartBuffers in Checksum
        //
        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
            // Checksum should have been allocated and copied 
            // if not a private logger
            if (LoggerInfo->Checksum == NULL) {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(ERROR_INVALID_DATA);
            }
            pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                     (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
            pLogFileHeader->BuffersWritten = Logger.BuffersWritten;
        }
    }

    // Extend the file size if in PREALLOCATE mode
    if (LoggerInfo->MaximumFileSize && 
        (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
        IO_STATUS_BLOCK IoStatusBlock;
        FILE_END_OF_FILE_INFORMATION EOFInfo;
        if (!(LoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)) { // normal case

            EOFInfo.EndOfFile.QuadPart = ((ULONGLONG)LoggerInfo->MaximumFileSize) * (1024 * 1024);

            Status = NtSetInformationFile(LogFile,
                                          &IoStatusBlock,
                                          &EOFInfo,
                                          sizeof(FILE_END_OF_FILE_INFORMATION),
                                          FileEndOfFileInformation);
            if (!NT_SUCCESS(Status)) {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(EtwpNtStatusToDosError(Status));
            }
        }
        else { // Using KBytes as file size unit

            EOFInfo.EndOfFile.QuadPart = ((ULONGLONG)LoggerInfo->MaximumFileSize) * 1024;

            Status = NtSetInformationFile(LogFile,
                                          &IoStatusBlock,
                                          &EOFInfo,
                                          sizeof(FILE_END_OF_FILE_INFORMATION),
                                          FileEndOfFileInformation);
            if (!NT_SUCCESS(Status)) {
                NtClose(LogFile);
                LoggerInfo->LogFileHandle = NULL;
                EtwpFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    EtwpFree(FileNameBuffer);
                }
                if (LoggerInfo->Checksum != NULL) {
                    EtwpFree(LoggerInfo->Checksum);
                }
                LoggerInfo->Checksum = NULL;
                return EtwpSetDosError(EtwpNtStatusToDosError(Status));
            }
        }
    }

    NtClose(LogFile);

    LogFile = EtwpCreateFileW(
                 FileName,
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_NO_BUFFERING,
                 NULL
                 );
    if (FileNameBuffer != NULL) {
        EtwpFree(FileNameBuffer);
    }
    EtwpFree(Logger.BufferSpace);

    if (LogFile == INVALID_HANDLE_VALUE) {
        if (LoggerInfo->Checksum != NULL) {
            EtwpFree(LoggerInfo->Checksum);
        }
        LoggerInfo->Checksum = NULL;
        return EtwpGetLastError();
    }
    LoggerInfo->LogFileHandle = LogFile;
    LoggerInfo->BuffersWritten = Logger.BuffersWritten;
    return ERROR_SUCCESS;
}

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
)
/*++

Routine Description:

    This routine informs WMI that a data provider is no longer available
    to receive requests for the guids previously registered. WMI will
    unregister any guids registered with this handle.

Arguments:

    WMIHandle - Handle returned from WMIRegisterGuids that represents
                the guids whose data is not longer available.
    Guid -      Pointer to the control Guid which is unregistering

    LoggerContext - Returned value of the LoggerContext

Return Value:

    Returns status code

--*/
{
    ULONG Status;
    ULONG ReturnSize;
    WMIUNREGGUIDS UnregGuids;

    UnregGuids.RequestHandle.Handle64 = (ULONG64)WMIHandle;
    UnregGuids.Guid = *Guid;

    Status = EtwpSendWmiKMRequest(NULL,
                                         IOCTL_WMI_UNREGISTER_GUIDS,
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &ReturnSize,
                                         NULL);

    //
    // Once the Guid has been unregistered from the kernel we will not get
    // any new notifications. We still need to wait for any notifications
    // currently in progress. The following call will check for it and 
    // block until it is okay to delete the data structures. 
    //

    if (Status == ERROR_SUCCESS) 
    {
        Status = EtwpRemoveFromGNList(Guid, 
                                    (PVOID) WMIHandle);
    }

    EtwpSetDosError(Status);
    return(Status);

}

ULONG
EtwpFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to Flush
    the logger. All the required parameters must be in LoggerInfo.

    This is an internal routine and it assumes that the LoggerInfo
    structure has been set up correctly and does not perform any 
    additional checks on the structure. 

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    ULONG BufferSize;
    PTRACE_ENABLE_CONTEXT pContext;

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = EtwpSendUmLogRequest(
                    WmiFlushLoggerCode,
                    LoggerInfo
                    );
    }
    else {

        Status = EtwpSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_FLUSH_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
    }

    return EtwpSetDosError(Status);
}

NTSTATUS
EtwpGetCpuSpeed(
    OUT DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    )
{
        PWCHAR Buffer = NULL;
    NTSTATUS Status;
        ULONG DataLength;
    DWORD Size = MAXSTR;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    HRESULT hr;


        *CpuSpeed = 0;

        Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    hr = StringCbPrintfW(Buffer, 
                         DEFAULT_ALLOC_SIZE, 
                         L"%ws\\%u", CPU_ROOT, *CpuNum
                        );

    if (FAILED(hr) ) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
        return STATUS_NO_MEMORY;
    }

    Status = EtwpRegOpenKey(Buffer, &Handle);

    if (NT_SUCCESS(Status)) {
        StringCbCopyW(Buffer, DEFAULT_ALLOC_SIZE, MHZ_VALUE_NAME);
        Size = sizeof(DWORD);
        Status = EtwpRegQueryValueKey(Handle,
                                   (LPWSTR) Buffer,
                                   Size,
                                   CpuSpeed,
                                   &DataLength
                                   );
        NtClose(Handle);
    }

    RtlFreeHeap (RtlProcessHeap(),0,Buffer);
        
        return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\tracelib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.c

Abstract:

    Private trace libraries and stubs that allows user-mode to reside in NTDLL.

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "tracelib.h"
#include "trcapi.h"

HANDLE BaseNamedObjectDirectory;

HANDLE
EtwpCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    )
{
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    SECURITY_QUALITY_OF_SERVICE SQos;

    RtlInitUnicodeString(&FileName, lpFileName);
    if (!RtlDosPathNameToRelativeNtPathName_U(
                lpFileName,
                &FileName,
                NULL,
                &RelativeName)) {
        EtwpSetDosError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }
    FreeBuffer = FileName.Buffer;
    if (RelativeName.RelativeName.Length) {
        FileName = RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
    SQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SQos.ImpersonationLevel = SecurityImpersonation;
    SQos.EffectiveOnly = TRUE;
    SQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &SQos;

    Status = NtCreateFile(
                &FileHandle,
                (ACCESS_MASK) dwDesiredAccess
                    | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &ObjectAttributes,
                &Iosb,
                NULL,
                FILE_ATTRIBUTE_NORMAL
                    & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                dwCreationDisposition,
                dwCreateFlags | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            EtwpSetDosError(ERROR_FILE_EXISTS);
        }
        else {
            EtwpSetDosError(EtwpNtStatusToDosError(Status));
        }
        FileHandle = INVALID_HANDLE_VALUE;
    }
    RtlReleaseRelativeName(&RelativeName);
    if (lpFileName != FreeBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }
    return FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\ntdlltrc.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ntdlltrc.c

Abstract:

    This file implements Event Tracing for Heap functions .

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include "wmiump.h"
#include "evntrace.h"
#include "ntdlltrc.h"
#include "trcapi.h"
#include "traceump.h"
#include "tracelib.h"


LONG NtdllTraceInitializeLock = 0;
LONG NtdllLoggerLock = 0;
PNTDLL_EVENT_HANDLES NtdllTraceHandles = NULL;
BOOL bNtdllTrace = FALSE;           // Flag determines that Tracing is enabled or disabled for this process.
ULONG GlobalCounter = 0;            // Used to determine that we have stale information about logger
LONG TraceLevel = 0;

extern LONG EtwpLoggerCount;
extern ULONG WmiTraceAlignment;
extern BOOLEAN LdrpInLdrInit;
extern PWMI_LOGGER_CONTEXT EtwpLoggerContext;
extern BOOLEAN EtwLocksInitialized;

extern PWMI_BUFFER_HEADER FASTCALL EtwpSwitchFullBuffer(IN PWMI_BUFFER_HEADER OldBuffer );
extern ULONG EtwpReleaseFullBuffer( IN PWMI_BUFFER_HEADER Buffer );
extern PWMI_BUFFER_HEADER FASTCALL EtwpGetFullFreeBuffer( VOID );
extern ULONG EtwpStopUmLogger( IN ULONG WnodeSize, IN OUT ULONG *SizeUsed,
                               OUT ULONG *SizeNeeded,IN OUT PWMI_LOGGER_INFORMATION LoggerInfo );
extern ULONG EtwpStartUmLogger( IN ULONG WnodeSize, IN OUT ULONG *SizeUsed, OUT ULONG *SizeNeeded,
                                IN OUT PWMI_LOGGER_INFORMATION LoggerInfo );
extern
ULONG
WMIAPI
EtwRegisterTraceGuidsA(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCSTR       MofImagePath,
    IN LPCSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    );

extern
ULONG
WMIAPI
EtwUnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );

#define MAXSTR                  1024
#define BUFFER_STATE_FULL       2 
#define EtwpIsLoggerOn() \
        (EtwpLoggerContext != NULL) && \
        (EtwpLoggerContext != (PWMI_LOGGER_CONTEXT) &EtwpLoggerContext)

#define EtwpLockLogger() InterlockedIncrement(&EtwpLoggerCount)
#define EtwpUnlockLogger() InterlockedDecrement(&EtwpLoggerCount)

NTSTATUS
InitializeEtwHandles(PPNTDLL_EVENT_HANDLES ppEtwHandle)
/*++

Routine Description:

    This function does groundwork to start Tracing for Heap and Critcal Section.
	With the help of global lock NtdllTraceInitializeLock the function
	allocates memory for NtdllTraceHandles and initializes the various variables needed
	for heap and critical tracing.

Arguments

  ppEtwHandle : OUT Pointer is set to value of NtdllTraceHandles


Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/
{

    NTSTATUS st = STATUS_UNSUCCESSFUL;
    PNTDLL_EVENT_HANDLES pEtwHandle = NULL;

    __try  {

        EtwpInitProcessHeap();

        pEtwHandle = (PNTDLL_EVENT_HANDLES)EtwpAlloc(sizeof(NTDLL_EVENT_HANDLES));

        if(pEtwHandle){

            pEtwHandle->hRegistrationHandle		= (TRACEHANDLE)INVALID_HANDLE_VALUE;
            pEtwHandle->pThreadListHead			= NULL;

            // 
            // Allocate TLS
            //

            pEtwHandle->dwTlsIndex = EtwpTlsAlloc();

            if(pEtwHandle->dwTlsIndex == FAILED_TLSINDEX){

                EtwpFree(pEtwHandle);

            }  else {

                st = RtlInitializeCriticalSection(&pEtwHandle->CriticalSection);
                if (NT_SUCCESS (st)) {
                    *ppEtwHandle = pEtwHandle;
                    st =  STATUS_SUCCESS;
                }
                else {
                    EtwpFree(pEtwHandle);
                    *ppEtwHandle = NULL; 
                }

            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        if(pEtwHandle !=NULL ) {
            EtwpFree(pEtwHandle);
            pEtwHandle = NULL;
        }

        EtwpDebugPrint(("InitializeEtwHandles threw an exception %d\n", GetExceptionCode()));
    }

    return st;
}

void
CleanOnThreadExit()
/*++

Routine Description:

    This function cleans up the Thread buffer and takes its node out of the Link list 
    which contains information of all threads involved in tracing.

--*/
{

    PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
    PWMI_BUFFER_HEADER pEtwBuffer;

    if(NtdllTraceHandles != NULL ){

        pThreadLocalData = (PTHREAD_LOCAL_DATA)EtwpTlsGetValue(NtdllTraceHandles->dwTlsIndex);

        //
        // Remove the node from the Link List
        //

        if(pThreadLocalData !=  NULL ){

            RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

            __try {

                if(pThreadLocalData->BLink == NULL ){

                    NtdllTraceHandles->pThreadListHead = pThreadLocalData->FLink;

                    if(NtdllTraceHandles->pThreadListHead){

                        NtdllTraceHandles->pThreadListHead->BLink = NULL;

                    }

                } else {

                    pThreadLocalData->BLink->FLink = pThreadLocalData->FLink;

                    if(pThreadLocalData->FLink != NULL ){

                        pThreadLocalData->FLink->BLink = pThreadLocalData->BLink;

                    }
                }

                pEtwBuffer = pThreadLocalData->pBuffer;

                if(pEtwBuffer){

                    EtwpReleaseFullBuffer(pEtwBuffer);

                }

                pThreadLocalData->pBuffer = NULL;
                pThreadLocalData->ReferenceCount = 0;

                EtwpFree(pThreadLocalData);
                EtwpTlsSetValue(NtdllTraceHandles->dwTlsIndex, NULL);

            } __finally {

                RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

            }
        }
    }
}

void
CleanUpAllThreadBuffers(BOOLEAN Release)
/*++

Routine Description:

    This function cleans up the All Thread buffers and sets them to NULL. This
    function is called when the tracing is disabled for the process.

--*/
{

    PTHREAD_LOCAL_DATA	pListHead;
    BOOL bAllClear = FALSE;
    PWMI_BUFFER_HEADER pEtwBuffer;
    int retry = 0;

    RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

    __try {

        while(bAllClear != TRUE && retry <= 10){

            bAllClear = TRUE;
            pListHead = NtdllTraceHandles->pThreadListHead;

            while(pListHead != NULL ){

                if(Release){

                    pEtwBuffer = pListHead->pBuffer;

                    if(pEtwBuffer){

                        if(InterlockedIncrement(&(pListHead->ReferenceCount)) == 1){

                            EtwpReleaseFullBuffer(pEtwBuffer);
                            pListHead->pBuffer = NULL;
                            InterlockedDecrement(&(pListHead->ReferenceCount));

                        } else {

                            InterlockedDecrement(&(pListHead->ReferenceCount));
                            bAllClear = FALSE;
                        }
                    }
                } else {
                    pListHead->pBuffer = NULL;
                    pListHead->ReferenceCount = 0;
                }

                pListHead = pListHead->FLink;
            }

            retry++;

            if(!bAllClear){

                EtwpSleep(250);
            }
        }

    } __finally {

        RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

    }
}

void 
ShutDownEtwHandles()
/*++

Routine Description:

    This function is called when the process is exiting. This cleans all the thread 
    buffers and releases the memory allocated for NtdllTraceHandless.

--*/

{

    if(NtdllTraceHandles == NULL) return;

    bNtdllTrace  = FALSE;

    RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

    __try {

        if(NtdllTraceHandles->hRegistrationHandle != (TRACEHANDLE)INVALID_HANDLE_VALUE){

            EtwUnregisterTraceGuids(NtdllTraceHandles->hRegistrationHandle);

        }

        if(NtdllTraceHandles->pThreadListHead != NULL){

            PTHREAD_LOCAL_DATA	pListHead, pNextListHead;

            pListHead = NtdllTraceHandles->pThreadListHead;

            while(pListHead != NULL ){

                if(pListHead->pBuffer != NULL){

                    EtwpReleaseFullBuffer(pListHead->pBuffer);
                    pListHead->pBuffer = NULL;
                    InterlockedDecrement(&(pListHead->ReferenceCount));

                }

                pNextListHead = pListHead->FLink;
                EtwpFree(pListHead);
                pListHead = pNextListHead;
            }
        }

        EtwpTlsFree(NtdllTraceHandles->dwTlsIndex);

    } __finally {

        RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

    }

    RtlDeleteCriticalSection(&NtdllTraceHandles->CriticalSection);

    EtwpFree(NtdllTraceHandles);
    NtdllTraceHandles = NULL;
}

NTSTATUS
GetLoggerInfo(PWMI_LOGGER_INFORMATION LoggerInfo)
{

    ULONG st = STATUS_UNSUCCESSFUL;
    WMINTDLLLOGGERINFO NtdllLoggerInfo;
    ULONG BufferSize;

    if(LoggerInfo == NULL) return st;

    NtdllLoggerInfo.LoggerInfo = LoggerInfo;
    NtdllLoggerInfo.LoggerInfo->Wnode.Guid = NtdllTraceGuid;
    NtdllLoggerInfo.IsGet = TRUE;

    st =  EtwpSendWmiKMRequest(
                                NULL,
                                IOCTL_WMI_NTDLL_LOGGERINFO,
                                &NtdllLoggerInfo,
                                sizeof(WMINTDLLLOGGERINFO),
                                &NtdllLoggerInfo,
                                sizeof(WMINTDLLLOGGERINFO),
                                &BufferSize,
                                NULL
                                );

    return st;

}

BOOLEAN
GetPidInfo(ULONG CheckPid, PWMI_LOGGER_INFORMATION LoggerInfo)
{

    NTSTATUS st;
    BOOLEAN Found = FALSE;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;

    st = GetLoggerInfo(LoggerInfo);

    if(NT_SUCCESS(st)){

        PULONG PidArray = NULL;
        ULONG count;

        FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
        PidArray = (PULONG)(FlagExt->Offset + (PCHAR)LoggerInfo);

        for(count = 0; count <  FlagExt->Length; count++){

            if(CheckPid == PidArray[count]){
                Found = TRUE;
                break;
            }
        }
    }

    return Found;
}

ULONG 
WINAPI 
NtdllCtrlCallback(
    WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize, 
    PVOID Buffer
    )
/*++

Routine Description:

	This is WMI control callback function used at the time of registration.

--*/
{
    ULONG ret;

    ret = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:  //Enable Provider.
        {
            if(bNtdllTrace == TRUE) break;

            if(EtwpIsLoggerOn()){

                bNtdllTrace = TRUE;
                break;

            }

            if(InterlockedIncrement(&NtdllLoggerLock) == 1){

                if( bNtdllTrace == FALSE ){

                    BOOLEAN PidEntry = FALSE;
                    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;

                    ULONG sizeNeeded = sizeof(WMI_LOGGER_INFORMATION)  
                                       + (2 * MAXSTR * sizeof(WCHAR)) 
                                       + (MAX_PID + 1) * sizeof(ULONG);

                    //
                    // Check to see that this process is allowed to log events 
                    // or not.
                    //

                    LoggerInfo = EtwpAlloc(sizeNeeded);

                    if(LoggerInfo){

                        //
                        // Check to see that this process is allowed to 
                        // register or not.
                        //


                        RtlZeroMemory(LoggerInfo, sizeNeeded);

                        if(GetPidInfo(EtwpGetCurrentProcessId(), LoggerInfo)){

                            LoggerInfo->LoggerName.Buffer = 
                                        (PWCHAR)(((PUCHAR) LoggerInfo) 
                                       + sizeof(WMI_LOGGER_INFORMATION));

                            LoggerInfo->LogFileName.Buffer = 
                                        (PWCHAR)(((PUCHAR) LoggerInfo) 
                                       + sizeof(WMI_LOGGER_INFORMATION)
                                       + LoggerInfo->LoggerName.MaximumLength);

                            LoggerInfo->InstanceCount   = 0;
                            LoggerInfo->InstanceId = EtwpGetCurrentProcessId();

                            TraceLevel = (LONG)LoggerInfo->Wnode.HistoricalContext;
                            LoggerInfo->Wnode.HistoricalContext = 0;
                            LoggerInfo->Wnode.ClientContext = 
                                                     EVENT_TRACE_CLOCK_CPUCYCLE;

                            //Start Logger Here

                            ret = EtwpStartUmLogger(sizeNeeded,
                                                    &sizeNeeded, 
                                                    &sizeNeeded,
                                                    LoggerInfo
                                                    );

                            if(ret == ERROR_SUCCESS ){

                                CleanUpAllThreadBuffers(FALSE);
                                bNtdllTrace = TRUE;
                                InterlockedIncrement(&NtdllLoggerLock);
                            } 
                        }

                        EtwpFree(LoggerInfo);

                    } else {
                        EtwpDebugPrint(("LoggerInfo failed to get Heap Allocation during Enable Events\n"));
                    }
                }
            }

            InterlockedDecrement(&NtdllLoggerLock);
            break;
        }
        case WMI_DISABLE_EVENTS:  //Disable Provider.
        {

            if( bNtdllTrace == TRUE ){

                ULONG WnodeSize,SizeUsed,SizeNeeded;
                WMI_LOGGER_INFORMATION LoggerInfo;

                bNtdllTrace = FALSE;

                //
                // The above boolean bNtdllTrace is turned off as this 
                // function will again be called back by EtwpStopUmLogger
                // so it will fall into endless loop of incrementing and 
                // decrementing NtdllLoggerLock.( see below ).
                // This assignment SHOULD NOT BE MOVED FROM THIS PLACE.
                //

                while(  InterlockedIncrement(&NtdllLoggerLock) != 1 ){

                    InterlockedDecrement(&NtdllLoggerLock);
                    EtwpSleep(250);

                }

                if(!EtwpIsLoggerOn()){

                    InterlockedDecrement(&NtdllLoggerLock);
                    break;

                }

                //
                // Now release thread buffer memory here.
                //

                CleanUpAllThreadBuffers(TRUE);
                WnodeSize = sizeof(WMI_LOGGER_INFORMATION);
                RtlZeroMemory(&LoggerInfo, WnodeSize);
                LoggerInfo.Wnode.CountLost = ((PWNODE_HEADER)Buffer)->CountLost;
                LoggerInfo.Wnode.BufferSize = WnodeSize;
                SizeUsed   = 0;
                SizeNeeded = 0;

                EtwpStopUmLogger(WnodeSize,
                                 &SizeUsed,
                                 &SizeNeeded,
                                 &LoggerInfo);

                InterlockedDecrement(&NtdllLoggerLock);
            }

            break;
        }

        default:
        {

            ret = ERROR_INVALID_PARAMETER;
            break;

        }
    }
    return ret;
}


ULONG 
RegisterNtdllTraceEvents() 
/*++

Routine Description:

    This function registers the guids with WMI for tracing.

Return Value:

	The return value of RegisterTraceGuidsA function.

--*/
{
        
    //Create the guid registration array
    NTSTATUS status;

    TRACE_GUID_REGISTRATION TraceGuidReg[] =
    {
        { 
        (LPGUID) &HeapGuid, 
        NULL 
        },
        { 
        (LPGUID) &CritSecGuid, 
        NULL 
        }

    };

    //Now register this process as a WMI trace provider.
    status = EtwRegisterTraceGuidsA(
                  (WMIDPREQUEST)NtdllCtrlCallback,  // Enable/disable function.
                  NULL,                             // RequestContext parameter
                  (LPGUID)&NtdllTraceGuid,          // Provider GUID
                  2,                                // TraceGuidReg array size
                  TraceGuidReg,              // Array of TraceGuidReg structures
                  NULL,                        // Optional WMI - MOFImagePath
                  NULL,                        // Optional WMI - MOFResourceName
                  &(NtdllTraceHandles->hRegistrationHandle)	// Handle unregister
                                );

    return status;
}


NTSTATUS 
InitializeAndRegisterNtdllTraceEvents()
/*++

Routine Description:

This functions checks for global variable NtdllTraceHandles and if not set then
calls fucntion InitializeEtwHandles to initialize it. NtdllTraceHandles 
contains handles used for Heap tracing. If NtdllTraceHandles is already 
initialized then  a call is  made  to register the guids.

Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/

{
    NTSTATUS  st = STATUS_UNSUCCESSFUL;

    if(NtdllTraceHandles == NULL){

        if(InterlockedIncrement(&NtdllTraceInitializeLock) == 1){

            st = InitializeEtwHandles(&NtdllTraceHandles);

            if(NT_SUCCESS(st)){

	            st = RegisterNtdllTraceEvents();

            } 
        }
    }

    return st;
}


NTSTATUS
AllocateMemoryForThreadLocalData(PPTHREAD_LOCAL_DATA ppThreadLocalData)
/*++

Routine Description:

	This functions allcates memory for tls and adds it to Link list which
	contains informations of all threads involved in tracing.

Arguments

  ppThreadLocalData : The OUT pointer to the tls.

Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    PTHREAD_LOCAL_DATA		pThreadLocalData = NULL;

    pThreadLocalData = (PTHREAD_LOCAL_DATA)EtwpAlloc(sizeof(THREAD_LOCAL_DATA));

    if(pThreadLocalData != NULL){

        if(EtwpTlsSetValue(NtdllTraceHandles->dwTlsIndex, (LPVOID)pThreadLocalData) == TRUE){

            pThreadLocalData->pBuffer   = NULL;
            pThreadLocalData->ReferenceCount = 0;

            RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

            if(NtdllTraceHandles->pThreadListHead == NULL ){

                pThreadLocalData->BLink = NULL;
                pThreadLocalData->FLink = NULL;

            } else {

                pThreadLocalData->FLink = NtdllTraceHandles->pThreadListHead;
                pThreadLocalData->BLink = NULL;
                NtdllTraceHandles->pThreadListHead->BLink = pThreadLocalData;

            }

            NtdllTraceHandles->pThreadListHead = pThreadLocalData;

            RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

            st = STATUS_SUCCESS;
        } 

    } else {
        EtwpDebugPrint(("pThreadLocalData failed to get Heap Allocation\n"));    
    }

    if(!NT_SUCCESS(st) && pThreadLocalData != NULL){

        EtwpFree(pThreadLocalData);
        pThreadLocalData = NULL;

    }

    *ppThreadLocalData = pThreadLocalData;

    return st;
}


void
ReleaseBufferLocation(PTHREAD_LOCAL_DATA pThreadLocalData)
{

    PWMI_BUFFER_HEADER pEtwBuffer;

    pEtwBuffer = pThreadLocalData->pBuffer;

    if(pEtwBuffer){

        PPERFINFO_TRACE_HEADER EventHeader =  (PPERFINFO_TRACE_HEADER) (pEtwBuffer->SavedOffset
                                            + (PCHAR)(pEtwBuffer));

        EventHeader->Marker = PERFINFO_TRACE_MARKER;
        EventHeader->TS = EtwpGetCycleCount();
        
    }

    InterlockedDecrement(&(pThreadLocalData->ReferenceCount));

    EtwpUnlockLogger();
}


PCHAR
ReserveBufferSpace(PTHREAD_LOCAL_DATA pThreadLocalData, PUSHORT ReqSize)
{


    PWMI_BUFFER_HEADER TraceBuffer = pThreadLocalData->pBuffer;

    *ReqSize = (USHORT) ALIGN_TO_POWER2(*ReqSize, WmiTraceAlignment);

    if(TraceBuffer == NULL) return NULL;

    if(EtwpLoggerContext->BufferSize - TraceBuffer->CurrentOffset < *ReqSize) {

        PWMI_BUFFER_HEADER NewTraceBuffer = NULL;

        NewTraceBuffer = EtwpSwitchFullBuffer(TraceBuffer);

        if( NewTraceBuffer == NULL ){
             pThreadLocalData->pBuffer = NULL;
             return NULL;

        } else {

            pThreadLocalData->pBuffer = NewTraceBuffer;
            TraceBuffer = NewTraceBuffer;
        }
    }

    TraceBuffer->SavedOffset = TraceBuffer->CurrentOffset;
    TraceBuffer->CurrentOffset += *ReqSize;

    return  (PCHAR)( TraceBuffer->SavedOffset + (PCHAR) TraceBuffer );
}

NTSTATUS 
AcquireBufferLocation(PVOID *ppEvent, PPTHREAD_LOCAL_DATA ppThreadLocalData, PUSHORT ReqSize)
/*++

Routine Description:

    This  function is  called from heap.c and heapdll.c  whenever  there is some
    Heap activity. It looks up the buffer location where the even can be written 
    and gives back the pointer.

Arguments:

    ppEvent             - The pointer to pointer of buffer location
    ppThreadLocalData   - The pointer to pointer of thread event storing struct.

Return Value:

     STATUS_UNSUCCESSFUL if failed otherwise  STATUS_SUCCESS

--*/
{
	
    NTSTATUS  st = STATUS_SUCCESS;
    PWMI_BUFFER_HEADER pEtwBuffer;

    if( bNtdllTrace ){

         EtwpLockLogger();

        if(EtwpIsLoggerOn()){

            *ppThreadLocalData = (PTHREAD_LOCAL_DATA)EtwpTlsGetValue(NtdllTraceHandles->dwTlsIndex);

            //
            //If there is no tls then create one here
            //

            if(*ppThreadLocalData ==  NULL ) {

                st = AllocateMemoryForThreadLocalData(ppThreadLocalData);

            } 

            //
            //If the thread buffer is NULL then get it from logger.
            //

            if( NT_SUCCESS(st) && (*ppThreadLocalData)->pBuffer == NULL ){

                (*ppThreadLocalData)->pBuffer  = EtwpGetFullFreeBuffer();

                if((*ppThreadLocalData)->pBuffer == NULL){

                    st = STATUS_UNSUCCESSFUL;

                }
            }

            if(NT_SUCCESS(st)){

                //
                // Check ReferenceCount. If is 1 then the cleaning process 
                // might be in progress.
                //

                pEtwBuffer = (*ppThreadLocalData)->pBuffer;

                if(pEtwBuffer){

                    if(InterlockedIncrement(&((*ppThreadLocalData)->ReferenceCount)) == 1 ){

                        *ppEvent = ReserveBufferSpace(*ppThreadLocalData, ReqSize );

                        if(*ppEvent == NULL) {

                            InterlockedDecrement(&((*ppThreadLocalData)->ReferenceCount));
                            EtwpUnlockLogger();

                        } 

                    } else { 

                        InterlockedDecrement(&((*ppThreadLocalData)->ReferenceCount));

                    }

                }

           }
        } else {

            EtwpUnlockLogger();

        }
    } else if ( LdrpInLdrInit == FALSE && EtwLocksInitialized  && NtdllTraceInitializeLock == 0 ){ 

        //
        // Make sure that process is not in initialization phase
        // Also we test for NtdllTraceInitializeLock. If is 
        // greater than 0 then it was registered earlier so no 
        // need to fire IOCTLS  everytime
        //

        if((UserSharedData->TraceLogging >> 16) != GlobalCounter){

            PWMI_LOGGER_INFORMATION LoggerInfo = NULL;

            ULONG sizeNeeded = sizeof(WMI_LOGGER_INFORMATION)  
                                + (2 * MAXSTR * sizeof(TCHAR)) 
                                + (MAX_PID + 1) * sizeof(ULONG);

            GlobalCounter = UserSharedData->TraceLogging >> 16;

            EtwpInitProcessHeap();

            LoggerInfo = EtwpAlloc(sizeNeeded);

            if(LoggerInfo != NULL){

                //
                // Check to see that this process is allowed to register or not.
                //

                if(GetPidInfo(EtwpGetCurrentProcessId(), LoggerInfo)){

                    st = InitializeAndRegisterNtdllTraceEvents();

                }

                EtwpFree(LoggerInfo);
            } else {
                EtwpDebugPrint(("LoggerInfo failed to get Heap Allocation \n"));    
            }
        }
    }
    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\umlog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umlog.c

Abstract:

    Process Private Logger.

Author:

    20-Oct-1998 Melur Raghuraman

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include "trcapi.h"
#include <strsafe.h>

//
// The following structures must match what's in ntos\wmi\tracelog.c
//
#define DEFAULT_BUFFER_SIZE               4096
#define MAXSTR                            1024
#define BUFFER_STATE_UNUSED     0               // Buffer is empty, not used
#define BUFFER_STATE_DIRTY      1               // Buffer is being used
#define BUFFER_STATE_FULL       2               // Buffer is filled up
#define BUFFER_STATE_FLUSH      4               // Buffer ready for flush
#define SEMAPHORE_LIMIT      1024
#define DEFAULT_AGE_LIMIT      15
#define ERROR_RETRY_COUNT       10
#define ROUND_TO_PAGES(Size, Page)  (((ULONG)(Size) + Page-1) & ~(Page-1))
#define BYTES_PER_MB              1048576       // Conversion for FileSizeLimit

extern ULONG WmiTraceAlignment;
extern LONG NtdllLoggerLock;
extern
__inline __int64 EtwpGetSystemTime();


LONG  EtwpLoggerCount = 0;                     // Use to refcount UM Log
ULONG EtwpGlobalSequence = 0;
RTL_CRITICAL_SECTION UMLogCritSect;

#define EtwpEnterUMCritSection() RtlEnterCriticalSection(&UMLogCritSect)
#define EtwpLeaveUMCritSection() RtlLeaveCriticalSection(&UMLogCritSect)

#define EtwpIsLoggerOn() \
        ((EtwpLoggerContext != NULL) && \
        (EtwpLoggerContext != (PWMI_LOGGER_CONTEXT) &EtwpLoggerContext))

#define EtwpIsThisLoggerOn(x) \
        ((x != NULL) && \
        (x != (PWMI_LOGGER_CONTEXT) &EtwpLoggerContext))
//
// Increase refcount on a logger context
#define EtwpLockLogger() \
            InterlockedIncrement(&EtwpLoggerCount)

// Decrease refcount on a logger context
#define EtwpUnlockLogger() InterlockedDecrement(&EtwpLoggerCount)

PWMI_LOGGER_CONTEXT EtwpLoggerContext = NULL; // Global pointer to LoggerContext
LARGE_INTEGER       OneSecond = {(ULONG)(-1 * 1000 * 1000 * 10), -1};

// #define EtwpReleaseTraceBuffer(BufferResource) \
//         InterlockedDecrement(&((BufferResource)->ReferenceCount))
LONG
FASTCALL
EtwpReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    );

#pragma warning( disable: 4035 )    /* Don't complain about lack of ret value */
#pragma warning( disable: 4127 )
#pragma warning( default: 4035 )
#pragma warning( default: 4127 )

#if DBG
#define TraceDebug(x)    DbgPrint x
#else
#define TraceDebug(x)
#endif

ULONG
EtwpReceiveReply(
    HANDLE ReplyHandle,
    ULONG ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    );


VOID
EtwpLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
EtwpStopUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpQueryUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpUpdateUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG 
EtwpFlushUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

PWMI_LOGGER_CONTEXT
EtwpInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
EtwpAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
EtwpFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER  Buffer,
    IN USHORT              BufferFlag
    );

ULONG
EtwpFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext);

PWMI_BUFFER_HEADER
FASTCALL
EtwpSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    );

ULONG
EtwpFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    );

BOOLEAN
FASTCALL
EtwpIsPrivateLoggerOn()
{
    if (!EtwpIsLoggerOn())
        return FALSE;
    return ( EtwpLoggerContext->CollectionOn  == TRUE);
}

ULONG
EtwpSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine send a UserMode Logger Request (Start/Stop/Query).

Arguments:

    RequestCode - Request Code
    LoggerInfo  - Logger Information necessary for the request


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;
    ULONG SizeNeeded;
    PWMICREATEUMLOGGER   UmRequest;
    ULONG RetSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    PUCHAR Buffer;
    PWNODE_HEADER Wnode;

    SizeNeeded = sizeof(WMICREATEUMLOGGER) + 
                 ((PWNODE_HEADER)LoggerInfo)->BufferSize;

    SizeNeeded = ALIGN_TO_POWER2 (SizeNeeded, 8);

    Buffer = EtwpAlloc(SizeNeeded);
    if (Buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    UmRequest = (PWMICREATEUMLOGGER) Buffer;

    UmRequest->ObjectAttributes = &ObjectAttributes;
    UmRequest->ControlGuid = LoggerInfo->Wnode.Guid;

    Status = EtwpBuildGuidObjectAttributes(&UmRequest->ControlGuid,
                                        &ObjectAttributes,
                                        &GuidString,
                                        GuidObjectName);

    if (Status == ERROR_SUCCESS) {
        Wnode = (PWNODE_HEADER)((PUCHAR)Buffer + sizeof(WMICREATEUMLOGGER));
        RtlCopyMemory(Wnode, LoggerInfo, LoggerInfo->Wnode.BufferSize);

        Wnode->ProviderId = RequestCode;   // This Wnode is part of the Message.


        Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_CREATE_UM_LOGGER,
                                  Buffer,
                                  SizeNeeded,
                                  Buffer,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);

        if (Status == ERROR_SUCCESS) {
#if DBG
            TraceDebug(("ETW: Expect %d replies\n", UmRequest->ReplyCount));
#endif

            Status = EtwpReceiveReply(UmRequest->ReplyHandle.Handle,
                                      UmRequest->ReplyCount,
                                      Wnode->Version,
                                      LoggerInfo,
                                      LoggerInfo->Wnode.BufferSize);

            //
            // This check is just a protection to make sure the handle
            // is valid. The handle is supposed to be valid once the 
            // Create IOCTL succeeds. 
            //

            if (Status != ERROR_INVALID_HANDLE) {
                NtClose(UmRequest->ReplyHandle.Handle);
            }

        }
        else {
            TraceDebug(("ETW: IOCTL_WMI_CREATE_UM_LOGGER Status %d\n", Status));
        }
    }

    EtwpFree(Buffer);

    return Status;
}

void
EtwpAddInstanceIdToNames(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG Offset;

    Offset = sizeof(WMI_LOGGER_INFORMATION);
    LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);

    Offset += LoggerInfo->LoggerName.MaximumLength;
    LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
    EtwpInitString(&LoggerContext->LoggerName, NULL, 0);

    RtlCreateUnicodeString(&LoggerContext->LoggerName,
                         LoggerInfo->LoggerName.Buffer);

    EtwpInitString(&LoggerContext->LogFileName, NULL, 0);

    if (LoggerInfo->InstanceCount == 1) {
        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                              LoggerInfo->LogFileName.Buffer);

    }
    else {
        WCHAR TempStr[MAXSTR+16];

        LoggerInfo->InstanceId = EtwpGetCurrentProcessId();
    
        if ( LoggerInfo->LogFileName.MaximumLength  <= MAXSTR) {
            StringCchPrintfW(TempStr, MAXSTR, L"%s_%d",
                                   LoggerInfo->LogFileName.Buffer, 
                                   LoggerInfo->InstanceId);
        }
        else {

            StringCchCopyW(TempStr, MAXSTR, LoggerInfo->LogFileName.Buffer);
            
        }
        RtlCreateUnicodeString (&LoggerContext->LogFileName, TempStr);
    }

    LoggerInfo->LoggerName = LoggerContext->LoggerName;
    LoggerInfo->LogFileName = LoggerContext->LogFileName;
}

ULONG
EtwpQueryUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Offset;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    EtwpLockLogger();

    TraceDebug(("QueryUm: %d->%d\n", RefCount-1, RefCount));

    LoggerContext = EtwpLoggerContext;

    if (!EtwpIsThisLoggerOn(LoggerContext)) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("QueryUm: %d->%d OBJECT_NOT_FOUND\n", RefCount+1,RefCount));
        return ERROR_OBJECT_NOT_FOUND;
    }


    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < *SizeNeeded) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("QueryUm: %d->%d ERROR_MORE_DATA\n", RefCount+1, RefCount));
        return ERROR_MORE_DATA;
    }

    LoggerInfo->Wnode.Guid      = LoggerContext->InstanceGuid;
    LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;
    LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
    LoggerInfo->FlushTimer      = (ULONG)(LoggerContext->FlushTimer.QuadPart
                                           / OneSecond.QuadPart);
    LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->EventsLost      = LoggerContext->EventsLost;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;
    LoggerInfo->BuffersWritten  = LoggerContext->BuffersWritten;
    LoggerInfo->LogBuffersLost  = LoggerContext->LogBuffersLost;
    LoggerInfo->RealTimeBuffersLost = LoggerContext->RealTimeBuffersLost;
    LoggerInfo->AgeLimit        = (ULONG)(LoggerContext->BufferAgeLimit.QuadPart
                                        / OneSecond.QuadPart / 60);
    LoggerInfo->LoggerThreadId = LoggerContext->LoggerThreadId;
    LoggerInfo->Wnode.ClientContext = LoggerContext->UsePerfClock;
    WmiSetLoggerId(1,
            (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext);

    // Copy LogFileName and LoggerNames into Buffer, if space is available
    //
    Offset = sizeof(WMI_LOGGER_INFORMATION);
    if ((Offset + LoggerContext->LoggerName.MaximumLength) < WnodeSize) {
        LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
        LoggerInfo->LoggerName.MaximumLength = LoggerContext->LoggerName.MaximumLength; 
        RtlCopyUnicodeString(&LoggerInfo->LoggerName,
                                 &LoggerContext->LoggerName);

        *SizeNeeded += LoggerContext->LoggerName.MaximumLength;
    }


    Offset += LoggerInfo->LoggerName.MaximumLength;
    if ((Offset + LoggerContext->LogFileName.MaximumLength) < WnodeSize) {
        LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
        LoggerInfo->LogFileName.MaximumLength = LoggerContext->LogFileName.MaximumLength; 
        RtlCopyUnicodeString(&LoggerInfo->LogFileName,
                              &LoggerContext->LogFileName);
        *SizeNeeded += LoggerContext->LogFileName.MaximumLength;
    }
    *SizeUsed = *SizeNeeded;

    //
    // Trim the return size down to essential bits. 
    //

    if (*SizeNeeded < LoggerInfo->Wnode.BufferSize) {
        LoggerInfo->Wnode.BufferSize = *SizeNeeded;
    }
#if DBG
        RefCount =
#endif
    EtwpUnlockLogger();
    TraceDebug(("QueryUm: %d->%d ERROR_SUCCESS\n", RefCount+1, RefCount));
    return ERROR_SUCCESS;
}

//
// For private loggers, we allow only two things to be updated: 
// FlushTimer and LogFileName
//
ULONG
EtwpUpdateUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;

    //
    // Check for parameters first
    //
    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < * SizeNeeded) {
        return ERROR_MORE_DATA;
    }

    if (LoggerInfo->BufferSize != 0 || LoggerInfo->MinimumBuffers != 0
                                    || LoggerInfo->MaximumBuffers != 0
                                    || LoggerInfo->MaximumFileSize != 0
                                    || LoggerInfo->EnableFlags != 0
                                    || LoggerInfo->AgeLimit != 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Lock logger down if it is running
    //
    EtwpLockLogger();
    LoggerContext = EtwpLoggerContext;

    if (!EtwpIsThisLoggerOn(LoggerContext) ) {
        EtwpUnlockLogger();
        return ERROR_OBJECT_NOT_FOUND;
    }


    if (((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
         (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL))
        || ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
            && (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))
        || (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        EtwpUnlockLogger();
        return (ERROR_INVALID_PARAMETER);
    }

    LoggerInfo->LoggerName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
    LoggerInfo->LogFileName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                  + LoggerInfo->LoggerName.MaximumLength);

    if (LoggerInfo->FlushTimer > 0) {
        LoggerContext->FlushTimer.QuadPart = LoggerInfo->FlushTimer
                                               * OneSecond.QuadPart;
    }

    if (LoggerInfo->LogFileName.Length > 0) {
        if (LoggerContext->LogFileHandle != NULL) {
            PWMI_LOGGER_INFORMATION EtwpLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            EtwpLoggerInfo = (PWMI_LOGGER_INFORMATION) EtwpAlloc(lSizeUsed);
            if (EtwpLoggerInfo == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            RtlZeroMemory(EtwpLoggerInfo, lSizeUsed);
            EtwpLoggerInfo->Wnode.BufferSize  = lSizeUsed;
            EtwpLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
            Status = EtwpQueryUmLogger(
                            EtwpLoggerInfo->Wnode.BufferSize,
                            & lSizeUsed,
                            & lSizeNeeded,
                            EtwpLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                EtwpFree(EtwpLoggerInfo);
                goto Cleanup;
            }
            NtClose(LoggerContext->LogFileHandle);
            Status = EtwpFinalizeLogFileHeader(EtwpLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                EtwpFree(EtwpLoggerInfo);
                goto Cleanup;
            }
            EtwpFree(EtwpLoggerInfo);
        }

        LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
        LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
        LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;

        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(& LoggerContext->LogFileName);
        }
        EtwpAddInstanceIdToNames(LoggerInfo, LoggerContext);
        Status = EtwpAddLogHeaderToLogFile(LoggerInfo, NULL, TRUE);
        if (Status != ERROR_SUCCESS) {
            goto Cleanup;
        }
        LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;

        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                               LoggerInfo->LogFileName.Buffer);
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        Status = EtwpQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    EtwpUnlockLogger();
    return (Status);
}

ULONG 
EtwpFlushUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine flushes active buffers. Effectively this is accomplished by
    putting all the buffers in the FlushList. If there is no available buffer
    for switching ERROR_NOT_ENOUGH_MEMORY is returned.

Arguments:

    WnodeSize   - Size of Wnode 
    SizeUsed    - Used only to pass to QueryLogger()
    SizeNeeded  - Used only for LoggerInfo size checking.
    LoggerInfo  - Logger Information. It will be updated.


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;
    PWMI_BUFFER_HEADER Buffer, OldBuffer;
    ULONG Offset, i;

#if DBG
    LONG RefCount;

    RefCount =
#endif
    EtwpLockLogger();

    LoggerContext = EtwpLoggerContext;
    TraceDebug(("FlushUm: %d->%d\n", RefCount-1, RefCount));

    if (!EtwpIsThisLoggerOn(LoggerContext) ) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("FlushUm: %d->%d OBJECT_NOT_FOUND\n", RefCount+1,RefCount));
        return ERROR_OBJECT_NOT_FOUND;
    }


    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < *SizeNeeded) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("FlushUm: %d->%d ERROR_MORE_DATA\n", RefCount+1, RefCount));
        return ERROR_MORE_DATA;
    }
    //
    // Go through each buffer, mark it "FULL", and put it in the FlushList.
    //
    EtwpEnterUMCritSection();
    for (i = 0; i < (ULONG)LoggerContext->NumberOfProcessors; i++) {
        Buffer = (PWMI_BUFFER_HEADER)LoggerContext->ProcessorBuffers[i];
        if (Buffer == NULL)
            continue;

        if (Buffer->CurrentOffset == sizeof(WMI_BUFFER_HEADER)) {
            Buffer->Flags = BUFFER_STATE_UNUSED;
            continue;
        }
        if (Buffer->Flags == BUFFER_STATE_UNUSED) {
            continue;
        }
        else {
            Buffer->Flags = BUFFER_STATE_FULL;
        }
        // Increment the refcount so that the buffer doesn't go away
        InterlockedIncrement(&Buffer->ReferenceCount);
        Offset = Buffer->CurrentOffset; 
        if (Offset <LoggerContext->BufferSize) {
            Buffer->SavedOffset = Offset;       // save this for FlushBuffer
        }
        // We need a free buffer for switching. If no buffer is available, exit. 
        if ((LoggerContext->NumberOfBuffers == LoggerContext->MaximumBuffers)
             && (LoggerContext->BuffersAvailable == 0)) {
            InterlockedDecrement(&Buffer->ReferenceCount);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            TraceDebug(("FlushUm: %d->%d ERROR_NOT_ENOUGH_MEMORY\n", RefCount+1, RefCount));
            break;
        }
        OldBuffer = Buffer;
        Buffer = EtwpSwitchBuffer(LoggerContext, OldBuffer, i);
        if (Buffer == NULL) {
            // Switching failed. Exit. 
            Buffer = OldBuffer;
            InterlockedDecrement(&Buffer->ReferenceCount);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            TraceDebug(("FlushUm: %d->%d ERROR_NOT_ENOUGH_MEMORY\n", RefCount+1, RefCount));
            break;
        }
        // Decrement the refcount back.
        InterlockedDecrement(&OldBuffer->ReferenceCount);
        Buffer->ClientContext.ProcessorNumber = (UCHAR)i;
        // Now wake up the logger thread.
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }
    EtwpLeaveUMCritSection();

    if (Status == ERROR_SUCCESS) {
        Status = EtwpQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    EtwpUnlockLogger();
    return (Status);
}

ULONG
EtwpStartUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    NTSTATUS Status;
    ULONG ErrorCode;
    LARGE_INTEGER TimeOut = {(ULONG)(-2000 * 1000 * 10), -1};  // 2 secs
    UNICODE_STRING SavedLoggerName;
    UNICODE_STRING SavedLogFileName;
    PTRACE_ENABLE_CONTEXT pContext;
    CLIENT_ID ClientId;

    PWNODE_HEADER Wnode = (PWNODE_HEADER)&LoggerInfo->Wnode;
    PVOID RequestAddress;
    PVOID RequestContext;
    ULONG RequestCookie;
    ULONG BufferSize;
    PWMI_LOGGER_CONTEXT LoggerContext;
    HANDLE LoggerThreadHandle;
#if DBG
    LONG RefCount;
#endif
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return ERROR_INVALID_PARAMETER;

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) ) {
        return ERROR_INVALID_PARAMETER;
    }

#if DBG
    RefCount =
#endif
    EtwpLockLogger();
    TraceDebug(("StartUm: %d->%d\n", RefCount-1, RefCount));

    if (InterlockedCompareExchangePointer(&EtwpLoggerContext,
                                          &EtwpLoggerContext,
                                          NULL
                                         )  != NULL) {
#if DBG
    RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("StartUm: %d->%d ALREADY_ENABLED\n", RefCount+1, RefCount));
        return ERROR_WMI_ALREADY_ENABLED;
    }

    LoggerContext = EtwpInitLoggerContext(LoggerInfo);
    if (LoggerContext == NULL) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("StartUm: %d->%d InitLoggerContext FAILED\n", RefCount+1, RefCount));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Create LoggerEvent
    //

    Status = NtCreateEvent(
                &LoggerContext->LoggerEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE);
    if (!NT_SUCCESS(Status)) {
        TraceDebug(("StartUm: Error %d Creating LoggerEvent\n", ERROR_OBJECT_NOT_FOUND));
        // EtwpInitLoggerContext() does not do much other than allocating LoggerContext.
        EtwpFree(LoggerContext);
        return ERROR_OBJECT_NOT_FOUND;
    }

    //
    // The LogFileName and LoggerNames are passed in as offset to the
    // LOGGER_INFORMATION structure. Reassign the Pointers for UNICODE_STRING
    //

    SavedLoggerName = LoggerInfo->LoggerName;
    SavedLogFileName = LoggerInfo->LogFileName;

    //
    // Since there may multiple processes registering for the same control guid
    // we want to make sure a start logger call from all of them do not
    // collide on the same file. So we tag on a InstanceId to the file name.
    //

    if (LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) {
        PSYSTEM_TRACE_HEADER RelogProp;
        ULONG Offset;
        Offset = sizeof(WMI_LOGGER_INFORMATION) +
                 LoggerInfo->LoggerName.MaximumLength +
                 LoggerInfo->LogFileName.MaximumLength;
        Offset = ALIGN_TO_POWER2 (Offset, 8);
        RelogProp = (PSYSTEM_TRACE_HEADER) ((PUCHAR)LoggerInfo + Offset);

        EtwpAddInstanceIdToNames(LoggerInfo, LoggerContext);
        ErrorCode = EtwpRelogHeaderToLogFile( LoggerInfo, RelogProp );
    }
    else {
        EtwpAddInstanceIdToNames(LoggerInfo, LoggerContext);
        ErrorCode = EtwpAddLogHeaderToLogFile(LoggerInfo, NULL, FALSE);
    }
    if (ErrorCode != ERROR_SUCCESS) {
        TraceDebug(("StartUm: LogHeadertoLogFile Error %d\n", ErrorCode));
        goto Cleanup;
    }
    else
    {
        ULONG Min_Buffers, Max_Buffers;
        ULONG NumberProcessors;

        NumberProcessors = LoggerInfo->NumberOfProcessors;
        LoggerContext->NumberOfProcessors = NumberProcessors;

        // EventsLost is UNIONed to NumberOfProcessors in WMI_LOGGER_INFORMATION
        // in UM case. Need to reset EventsLost back to 0
        //
        LoggerInfo->EventsLost = 0;

        Min_Buffers            = NumberProcessors + 2;
        Max_Buffers            = 1024;

        if (LoggerInfo->MaximumBuffers >= Min_Buffers ) {
            LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
        }
        else {
            LoggerContext->MaximumBuffers = Min_Buffers + 22;
        }

        if (LoggerInfo->MinimumBuffers >= Min_Buffers &&
            LoggerInfo->MinimumBuffers <= LoggerContext->MaximumBuffers) {
            LoggerContext->MinimumBuffers = LoggerInfo->MinimumBuffers;
        }
        else {
            LoggerContext->MinimumBuffers = Min_Buffers;
        }

        if (LoggerContext->MaximumBuffers > Max_Buffers)
            LoggerContext->MaximumBuffers = Max_Buffers;
        if (LoggerContext->MinimumBuffers > Max_Buffers)
            LoggerContext->MinimumBuffers = Max_Buffers;
        LoggerContext->NumberOfBuffers  = LoggerContext->MinimumBuffers;
    }

    LoggerContext->LogFileHandle       = LoggerInfo->LogFileHandle;
    LoggerContext->BufferSize          = LoggerInfo->BufferSize * 1024;
    LoggerContext->BuffersWritten      = LoggerInfo->BuffersWritten;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                           * LoggerInfo->BufferSize * 1024;
    // For a kernel logger, FirstBufferOffset is set in the kernel.
    // For a private logger, we need to do it here.
    LoggerContext->FirstBufferOffset.QuadPart = 
                                            LoggerContext->ByteOffset.QuadPart;
    LoggerContext->InstanceGuid        = LoggerInfo->Wnode.Guid;
    LoggerContext->MaximumFileSize     = LoggerInfo->MaximumFileSize;

    LoggerContext->UsePerfClock = LoggerInfo->Wnode.ClientContext;

    ErrorCode = EtwpAllocateTraceBuffers(LoggerContext);
    if (ErrorCode != ERROR_SUCCESS) {
        goto Cleanup;
    }

    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;

    pContext = (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext;

    pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
    pContext->LoggerId = 1;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
        EtwpGlobalSequence = 0;
        LoggerContext->SequencePtr = &EtwpGlobalSequence;
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE)
        LoggerContext->SequencePtr = &LoggerContext->LocalSequence;

    //
    // We set the CollectionOn here prior to LoggerThread start in case
    // it takes a while for the LoggerThread to get going and we don't want 
    // to miss any events during that time. The flood gates will be open
    // when we set the EtwpLoggerContext is set whether or not 
    // logger thread started to run. 
    //

    LoggerContext->CollectionOn = TRUE;

    LoggerThreadHandle     = EtwpCreateThread(NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE) &EtwpLogger,
                                 (LPVOID)LoggerContext,
                                 0,
                                 (LPDWORD)&ClientId);


    if (LoggerThreadHandle == NULL) {
        ErrorCode = EtwpGetLastError();
        TraceDebug(("StartUm: CreateThread Failed with %d\n", ErrorCode));
        LoggerContext->CollectionOn = FALSE;
        //
        // Signal the LoggerEvent in case any StopTrace is blocked 
        // waiting for LoggerThread to respond.
        //
        NtSetEvent(LoggerContext->LoggerEvent, NULL);
        goto Cleanup;
    }
    else {
        EtwpCloseHandle(LoggerThreadHandle);
    }

    //
    // This routine may be called from dll initialize and we can not guarantee
    // that the LoggerThread will be up and running to signal us. So we will
    // set the CollectionOn to LOGGER_ON flag and let TraceUmEvents through
    // upto Max Buffers. Hopefully by that time the logger thread will be
    // up and running. If not, we would lose events. 
    //

    EtwpLoggerContext = LoggerContext;

    // 
    // At this point we will start accepting TraceUmEvent calls. Also Control
    // operations would get through. As a result we should not touch 
    // LoggerContext beyond this point. It may be gone. 
    //

    //
    // Look to see if this Provider is currently enabled.
    //

    EtwpEnableDisableGuid(Wnode, WMI_ENABLE_EVENTS, TRUE);
   
Cleanup:
    LoggerInfo->LogFileName = SavedLogFileName;
    LoggerInfo->LoggerName = SavedLoggerName;

    if (ErrorCode != ERROR_SUCCESS) {
        if (LoggerInfo->LogFileHandle) {
            NtClose(LoggerInfo->LogFileHandle);
            LoggerInfo->LogFileHandle = NULL;
            if (LoggerContext != NULL) {
                LoggerContext->LogFileHandle = NULL;
            }
        }
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("StartUm: %d->%d %d\n", RefCount+1, RefCount, ErrorCode));
        EtwpFreeLoggerContext(LoggerContext);
    }
    else {
        *SizeUsed = LoggerInfo->Wnode.BufferSize;
        *SizeNeeded = LoggerInfo->Wnode.BufferSize;
        // Logger remains locked with refcount = 1
    }
    return ErrorCode;
}

ULONG
EtwpStopLoggerInstance(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut = {(ULONG)(-1000 * 1000 * 10), -1}; // 1sec
    ULONG Result;

    if (LoggerContext == NULL) {
        return  ERROR_OBJECT_NOT_FOUND;
    }

    //
    // We can not shut down the logger if the LoggerThread never got up
    // to set the UMTHREAD_ON flag. Therefore, the StopUmLogger call might
    // fail even though IsLoggerOn calls continue to succeed. 
    //

    Result = InterlockedCompareExchange(&LoggerContext->CollectionOn, 
                                        FALSE,
                                        TRUE 
                                        );

    if (!Result) {
         return ERROR_OBJECT_NOT_FOUND;
    }

    NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);

    Status = STATUS_TIMEOUT;
    while (Status == STATUS_TIMEOUT) {
        Status = NtWaitForSingleObject(
                    LoggerContext->LoggerEvent, FALSE, &TimeOut);
#if DBG
        EtwpAssert(Status != STATUS_TIMEOUT);
#endif
    }

    return ERROR_SUCCESS;
}

ULONG
EtwpDisableTraceProvider(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    WNODE_HEADER Wnode;
    ULONG BufferSize = sizeof(WNODE_HEADER);

    RtlCopyMemory(&Wnode, &LoggerInfo->Wnode, BufferSize);

    Wnode.BufferSize = BufferSize;

    Wnode.ProviderId =  WMI_DISABLE_EVENTS;

    EtwpEnableDisableGuid(&Wnode, WMI_DISABLE_EVENTS, TRUE);

    return ERROR_SUCCESS;
}


ULONG
EtwpStopUmLogger(
        IN ULONG WnodeSize,
        IN OUT ULONG *SizeUsed,
        OUT ULONG *SizeNeeded,
        IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    EtwpLockLogger();
    LoggerContext = EtwpLoggerContext;
    TraceDebug(("StopUm: %d->%d\n", RefCount-1, RefCount));
    if (!EtwpIsThisLoggerOn(LoggerContext)) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("StopUm: %d->%d INSTANCE_NOT_FOUND\n",RefCount+1,RefCount));
        return (ERROR_WMI_INSTANCE_NOT_FOUND);
    }
    Status = EtwpStopLoggerInstance(LoggerContext);

    if (Status == ERROR_SUCCESS) {
        Status = EtwpQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    if (Status != ERROR_SUCCESS) {

#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("StopUm: %d->%d %d\n", RefCount+1, RefCount, Status));
        EtwpSetLastError(Status);
        return(Status);
    }

    //
    // Finalize LogHeader ?
    //
    if (Status == ERROR_SUCCESS) {
        LoggerInfo->BuffersWritten = LoggerContext->BuffersWritten;
        LoggerInfo->LogFileMode = LoggerContext->LogFileMode;
        LoggerInfo->EventsLost = LoggerContext->EventsLost;
        Status = EtwpFinalizeLogFileHeader(LoggerInfo);
#if DBG
        if (Status != ERROR_SUCCESS) {
            TraceDebug(("StopUm: Error %d FinalizeLogFileHeader\n", Status));
        }
#endif
    }

#if DBG
    RefCount =
#endif
    EtwpUnlockLogger();
    TraceDebug(("StopUm: %d->%d %d\n", RefCount+1, RefCount, Status));
    EtwpFreeLoggerContext(LoggerContext);
    EtwpDisableTraceProvider(LoggerInfo);

    return Status;
}

ULONG
EtwpValidateLoggerInfo( 
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{

    if (LoggerInfo == NULL) {
        return ERROR_INVALID_DATA;
    }
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return ERROR_INVALID_DATA;

    if (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return ERROR_INVALID_DATA;

    if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}



ULONG
EtwpProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    )
{
    ULONG Status;
    PWMIMBREPLY Reply;
    ULONG BufferSize;
    PUCHAR Buffer = NULL;
    ULONG WnodeSize = 0;
    ULONG SizeUsed, SizeNeeded;
    ULONG RequestCode = 0;
    ULONG RetSize;
    struct {
        WMIMBREPLY MBreply;
        ULONG      StatusSpace;
    } DefaultReply;
    Reply = (PWMIMBREPLY) &DefaultReply;

    Reply->Handle.Handle = (HANDLE)DeliveryContext;
    Reply->ReplyIndex = ReplyIndex;

    BufferSize = sizeof(DefaultReply);

    //
    // If the WMI_CREATE_UM_LOGGER got blasted with random bits, we might 
    // end up here and we need to ensure that the LoggerInfo is a valid one. 
    // 

    Status = EtwpValidateLoggerInfo( LoggerInfo );
    if (Status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (DeliveryContext == NULL) {
        Status = ERROR_INVALID_DATA;
        goto cleanup;
    }

    RequestCode = LoggerInfo->Wnode.ProviderId;
    WnodeSize = LoggerInfo->Wnode.BufferSize;
    SizeUsed = 0;
    SizeNeeded = 0;
    switch (RequestCode) {
        case WmiStartLoggerCode:
                Status = EtwpStartUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiStopLoggerCode:
                Status = EtwpStopUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiQueryLoggerCode:
                Status = EtwpQueryUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiUpdateLoggerCode:
            Status = EtwpUpdateUmLogger(WnodeSize,
                                     &SizeUsed,
                                     &SizeNeeded,
                                     LoggerInfo);
                break;
        case WmiFlushLoggerCode:
            Status = EtwpFlushUmLogger(WnodeSize,
                                     &SizeUsed,
                                     &SizeNeeded,
                                     LoggerInfo);
                break;
        default:
                Status = ERROR_INVALID_PARAMETER;
                break;
    }

    if (Status == ERROR_SUCCESS) {

        BufferSize += LoggerInfo->Wnode.BufferSize;
        // 
        // Does this have to be aligned to 8 bytes? 
        //

        Buffer = EtwpAlloc(BufferSize);
        if (Buffer == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        else {
            RtlZeroMemory(Buffer, BufferSize);
            Reply = (PWMIMBREPLY) Buffer;
            Reply->Handle.Handle = (HANDLE)DeliveryContext;
            Reply->ReplyIndex = ReplyIndex;

            if (LoggerInfo != NULL)
            {
                RtlCopyMemory(Reply->Message,  
                              LoggerInfo,  
                              LoggerInfo->Wnode.BufferSize
                             );
            }
        }
    }

cleanup:
    if (Status != ERROR_SUCCESS) {
        BufferSize = sizeof(DefaultReply);
        RtlCopyMemory(Reply->Message,  &Status,  sizeof(ULONG) );
    }

    Status = EtwpSendWmiKMRequest(NULL,
                              IOCTL_WMI_MB_REPLY,
                              Reply,
                              BufferSize,
                              Reply,
                              BufferSize,
                              &RetSize,
                              NULL);

   if (Buffer != NULL) {
       EtwpFree(Buffer);
   }
   return Status;
}

PWMI_LOGGER_CONTEXT
EtwpInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION SystemInfo;

    LoggerContext = (PWMI_LOGGER_CONTEXT) EtwpAlloc(sizeof(WMI_LOGGER_CONTEXT));
    if (LoggerContext == NULL) {
        return LoggerContext;
    }

    RtlZeroMemory(LoggerContext, sizeof(WMI_LOGGER_CONTEXT));

    if (LoggerInfo->BufferSize > 0) {
        LoggerContext->BufferSize = LoggerInfo->BufferSize * 1024;
    }
    else {
        LoggerContext->BufferSize       = DEFAULT_BUFFER_SIZE;
    }
    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;


    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof (SystemInfo),
                                       NULL);

    if (!NT_SUCCESS(Status)) {
        EtwpFree(LoggerContext);
        return NULL;
    }

    //
    // Round the Buffer Size to page size multiple and save it
    // for allocation later.
    //

    LoggerContext->BufferPageSize = ROUND_TO_PAGES(LoggerContext->BufferSize,
                                       SystemInfo.PageSize);

    LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                         * LoggerInfo->BufferSize * 1024;


    LoggerContext->LogFileMode      = EVENT_TRACE_PRIVATE_LOGGER_MODE;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
    else
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;

    if (LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) {
        LoggerContext->LogFileMode |= EVENT_TRACE_RELOG_MODE; 
    }

    LoggerContext->EventsLost       = 0;
    LoggerContext->BuffersWritten   = LoggerInfo->BuffersWritten;
    LoggerContext->BuffersAvailable = LoggerContext->NumberOfBuffers;

    LoggerContext->ProcessorBuffers = NULL;

    LoggerContext->StartTime.QuadPart = EtwpGetSystemTime();

    InitializeListHead(&LoggerContext->FreeList);
    InitializeListHead(&LoggerContext->FlushList);

    LoggerContext->BufferAgeLimit.QuadPart =
            15 * OneSecond.QuadPart * 60 * DEFAULT_AGE_LIMIT;
    if (LoggerInfo->AgeLimit > 0) {
        LoggerContext->BufferAgeLimit.QuadPart =
            LoggerInfo->AgeLimit * OneSecond.QuadPart * 60;
    }
    else if (LoggerInfo->AgeLimit < 0)
        LoggerContext->BufferAgeLimit.QuadPart = 0;

    Status = NtCreateSemaphore(
                &LoggerContext->Semaphore,
                SEMAPHORE_ALL_ACCESS,
                NULL,
                0,
                SEMAPHORE_LIMIT);

    if (!NT_SUCCESS(Status)) {
        EtwpFree(LoggerContext);
        return NULL;
    }

    return LoggerContext;
}

PWMI_BUFFER_HEADER
FASTCALL
EtwpGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWMI_BUFFER_HEADER Buffer = NULL;

    //
    // Note: This routine must be called with UMCritSect Held
    //

    if (IsListEmpty(&LoggerContext->FreeList)) {
        ULONG BufferSize = LoggerContext->BufferPageSize;
        ULONG MaxBuffers = LoggerContext->MaximumBuffers;
        ULONG NumberOfBuffers = LoggerContext->NumberOfBuffers;

        if (NumberOfBuffers < MaxBuffers) {
            Buffer = (PWMI_BUFFER_HEADER)
                        EtwpMemCommit(
                            (PVOID)((char*)LoggerContext->BufferSpace +
                                     BufferSize *  NumberOfBuffers),
                            BufferSize);
            if (Buffer != NULL) {
                RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
                Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
                Buffer->Flags               = BUFFER_STATE_DIRTY;
                Buffer->ReferenceCount      = 0;
                Buffer->SavedOffset         = 0;
                Buffer->Wnode.ClientContext = 0;
                InterlockedIncrement(&LoggerContext->NumberOfBuffers);
            }
        }
    }
    else {
        PLIST_ENTRY pEntry = RemoveHeadList(&LoggerContext->FreeList);
        if (pEntry != NULL) {
            Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
            InterlockedDecrement(&LoggerContext->BuffersAvailable);
            Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
            Buffer->Flags               = BUFFER_STATE_DIRTY;
            Buffer->SavedOffset         = 0;
            Buffer->ReferenceCount      = 0;
            Buffer->Wnode.ClientContext = 0;
        }
    }
    return Buffer;
}


ULONG
EtwpAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to allocate the necessary buffers for user-mode
    only logging. Need to have the UMCritSection to touch the lists. 

Arguments:

    None

Return Value:

    Status of allocating the buffers
--*/

{
    ULONG Processors;
    ULONG BufferSize;
    ULONG BufferPageSize;
    ULONG NumberOfBuffers;
    ULONG i;
    PVOID BufferSpace;
    PWMI_BUFFER_HEADER Buffer;

    Processors = LoggerContext->NumberOfProcessors;
    if (Processors == 0)
        Processors = 1;
    BufferSize = LoggerContext->BufferSize;
    if (BufferSize < 1024)
        BufferSize = 4096;

    NumberOfBuffers = LoggerContext->NumberOfBuffers;
    if (NumberOfBuffers < Processors+1)
        NumberOfBuffers = Processors + 1;

    //
    // Determine the number of processors first
    //
    LoggerContext->ProcessorBuffers = EtwpAlloc( Processors
                                                 * sizeof(PWMI_BUFFER_HEADER));
    if (LoggerContext->ProcessorBuffers == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    BufferSpace = EtwpMemReserve( LoggerContext->MaximumBuffers *
                                  LoggerContext->BufferPageSize );
    if (BufferSpace == NULL) {
        EtwpFree(LoggerContext->ProcessorBuffers);
        LoggerContext->ProcessorBuffers = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LoggerContext->BufferSpace = BufferSpace;

    for (i=0; i<NumberOfBuffers; i++) {
        Buffer = (PWMI_BUFFER_HEADER)
                    EtwpMemCommit(
                        (PVOID)((char*)BufferSpace + i * LoggerContext->BufferPageSize),
                        BufferSize);
        if (Buffer == NULL) {
            EtwpMemFree(LoggerContext->BufferSpace);
            EtwpFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
        Buffer->TimeStamp.QuadPart = EtwpGetSystemTime();
        Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Flags = BUFFER_STATE_DIRTY;
        InsertTailList(&LoggerContext->FreeList, & (Buffer->Entry));
    }
    LoggerContext->NumberOfBuffers  = NumberOfBuffers;
    LoggerContext->BuffersAvailable = NumberOfBuffers;
    for (i=0; i<Processors; i++) {
        Buffer = (PWMI_BUFFER_HEADER) EtwpGetFreeBuffer(LoggerContext);
        LoggerContext->ProcessorBuffers[i] = Buffer;
        if (Buffer != NULL) {
            Buffer->ClientContext.ProcessorNumber = (UCHAR) i;
        }
        else {
            EtwpMemFree(LoggerContext->BufferSpace);
            EtwpFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ERROR_SUCCESS;
}

VOID
EtwpLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This function is the logger itself. It is started as a separate thread.
    It will not return until someone has stopped data collection or it
    is not successful is flushing out a buffer (e.g. disk is full).

Arguments:

    None.

Return Value:

    The status of running the buffer manager

--*/

{
    NTSTATUS Status=STATUS_SUCCESS;
    ULONG    ErrorCount=0;
    PCLIENT_ID Cid;

    LoggerContext->LoggerStatus = Status;

    //
    // Elevate the priority of the Logging thread to highest
    //
    if (!EtwpSetThreadPriority(NtCurrentThread(), THREAD_PRIORITY_HIGHEST)) {
        TraceDebug(("ETW: SetLoggerThreadPriority Failed with %d\n", EtwpGetLastError()));
    }

    Cid = &NtCurrentTeb()->ClientId;
    LoggerContext->LoggerThreadId = Cid->UniqueThread;

    InterlockedDecrement(&NtdllLoggerLock);

// by now, the caller has been notified that the logger is running

//
// Loop and wait for buffers to be filled until someone turns off CollectionOn
//
    while (LoggerContext->CollectionOn) { 
        ULONG Counter;
        ULONG DelayFlush;
        PLARGE_INTEGER FlushTimer;
        PWMI_BUFFER_HEADER Buffer;
        PLIST_ENTRY pEntry;
        LIST_ENTRY  FlushList;
        BOOLEAN StopLogging = FALSE;
        ULONG i;

        if (LoggerContext->FlushTimer.QuadPart == 0) {
            FlushTimer = NULL;
        }
        else {
            FlushTimer = &LoggerContext->FlushTimer;
        }

        Status = NtWaitForSingleObject( LoggerContext->Semaphore, FALSE,
                                      FlushTimer);

        DelayFlush = FALSE;
        if ( Status == WAIT_TIMEOUT) {
//
// FlushTimer used, and we just timed out. Go through per processor buffer
// and mark each as FULL so that it will get flushed next time
//
            for (i=0; i<(ULONG)LoggerContext->NumberOfProcessors; i++) {
                Buffer = (PWMI_BUFFER_HEADER)LoggerContext->ProcessorBuffers[i];
                if (Buffer == NULL)
                    continue;

                if (Buffer->CurrentOffset == sizeof(WMI_BUFFER_HEADER))
                    Buffer->Flags = BUFFER_STATE_UNUSED;
                if (Buffer->Flags != BUFFER_STATE_UNUSED) {
                    Buffer->Flags = BUFFER_STATE_FULL;
                    DelayFlush = TRUE; // let ReserveTraceBuffer send semaphore
                }
            }
        }

        if (DelayFlush)    // will only be TRUE if FlushTimer is used
            continue;

        if (IsListEmpty(&LoggerContext->FlushList)){ //shouldn't happen normally
            continue;
        }

        EtwpEnterUMCritSection();

        //
        // Copy the current LoggerContext->Flushlist information to 
        // new FlushList
        //

        FlushList.Flink  = LoggerContext->FlushList.Flink;
        FlushList.Flink->Blink = &FlushList;

        FlushList.Blink = LoggerContext->FlushList.Blink;
        FlushList.Blink->Flink = &FlushList;

        //
        // Reinitialize LoggerContext->FlushList
        //

        InitializeListHead(&LoggerContext->FlushList);

        EtwpLeaveUMCritSection();

        do{
            pEntry = IsListEmpty(&FlushList) ? NULL 
                                             : RemoveHeadList(&FlushList);

            if (pEntry ){

                Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
#if DBG
                EtwpAssert(Buffer->Flags != BUFFER_STATE_UNUSED);
#endif
                // If the refcount is not 0, someone is still writing to it.
                // Put it back in the regular flushlist.
                if (Buffer->ReferenceCount != 0) {
                    EtwpEnterUMCritSection();
                    InsertHeadList(&LoggerContext->FlushList, &Buffer->Entry);
                    EtwpLeaveUMCritSection();
                    continue;
                }
                Status = EtwpFlushBuffer(LoggerContext, Buffer, WMI_BUFFER_FLAG_NORMAL);

                EtwpEnterUMCritSection();
                if (LoggerContext->BufferAgeLimit.QuadPart == 0) {
                    InsertTailList(&LoggerContext->FreeList, &Buffer->Entry);
                }
                else {
                    InsertHeadList(&LoggerContext->FreeList, &Buffer->Entry);
                }
                EtwpLeaveUMCritSection();

                if (!NT_SUCCESS(Status)) {

                    if((Status == STATUS_LOG_FILE_FULL)    ||
                       (Status == STATUS_NO_DATA_DETECTED) ||
                       (Status == STATUS_SEVERITY_WARNING)){

                       if (Status == STATUS_LOG_FILE_FULL){
                           ErrorCount++;
                       } else {
                           ErrorCount = 0;    // reset to zero otherwise
                       }

                       if (ErrorCount > ERROR_RETRY_COUNT){
                            StopLogging = TRUE;
                            break;
                       }
                    } else {
                        StopLogging = TRUE; // Some Kind of Severe Error
                        break;
                    }
                }
            }

        }while( pEntry );

        if (StopLogging) {
#if DBG
            LONG RefCount;
#endif
            Status = NtClose(LoggerContext->LogFileHandle);
            LoggerContext->LogFileHandle = NULL;

            // Need to set event since EtwpStopLoggerInstance
            // will wait for it to be set.
            NtSetEvent(LoggerContext->LoggerEvent, NULL);
            EtwpStopLoggerInstance(LoggerContext);
            // Need to Deref once to set the RefCount to 0
            // before calling EtwpFreeLoggerContext.
#if DBG
            RefCount =
#endif
            EtwpUnlockLogger();
            TraceDebug(("EtwpLogger: %d->%d\n", RefCount-1, RefCount));
            EtwpFreeLoggerContext (LoggerContext);
            EtwpSetDosError(EtwpNtStatusToDosError(Status));
            EtwpExitThread(0);
        }
    } // while loop

    // if a normal collection end, flush out all the buffers before stopping
    //
    EtwpFlushAllBuffers(LoggerContext);

    NtSetEvent(LoggerContext->LoggerEvent, NULL);
    EtwpExitThread(0); // check to see if this thread terminate itself with this
}


ULONG
EtwpFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER  Buffer,
    IN USHORT              BufferFlag
    )
/*++

Routine Description:
    This function is responsible for flushing a filled buffer out to
    disk. Assumes a FileHandle is available to write to. 

Arguments:

    LoggerContext       Context of the logger
    Buffer              Buffer to flush
    BufferFlag          Flag

Return Value:

    The status of flushing the buffer

--*/
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWMI_BUFFER_HEADER OldBuffer;
    ULONG BufferSize;

//
// Grab the buffer to be flushed
//
    BufferSize = LoggerContext->BufferSize;
//
// Put end of record marker in buffer if available space
//
    if (Buffer->SavedOffset > 0) {
        Buffer->Offset = Buffer->SavedOffset;
    }
    else {
        Buffer->Offset = Buffer->CurrentOffset;
    }

    if (Buffer->Offset < BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                BufferSize - Buffer->Offset,
                0xFF);
    }
    if (Buffer->Offset < sizeof(WMI_BUFFER_HEADER)) { // should not happen
        Status = STATUS_INVALID_PARAMETER;
        goto ResetTraceBuffer;
    }
    //
    // If the Buffer type is FlushMarker, then we write it even if it's 
    // empty
    //
    if ( (Buffer->Offset == sizeof(WMI_BUFFER_HEADER)) && 
          (BufferFlag != WMI_BUFFER_FLAG_FLUSH_MARKER) ) { // empty buffer
        Status = STATUS_NO_DATA_DETECTED;
        goto ResetTraceBuffer;
    }
    Buffer->BufferFlag = BufferFlag;
    Status = STATUS_SUCCESS;
    Buffer->Wnode.BufferSize       = BufferSize;
    Buffer->ClientContext.LoggerId = (USHORT) LoggerContext->LoggerId;

    Buffer->ClientContext.Alignment = (UCHAR) WmiTraceAlignment;
    RtlCopyMemory(&Buffer->Wnode.Guid, 
                  &LoggerContext->InstanceGuid, 
                  sizeof(GUID));
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    Buffer->Wnode.TimeStamp.QuadPart = EtwpGetSystemTime();

    if (LoggerContext->LogFileHandle == NULL) {
        goto ResetTraceBuffer;
    }

    if (LoggerContext->MaximumFileSize > 0) { // if quota given
        ULONG64 FileSize = LoggerContext->LastFlushedBuffer * BufferSize;
        ULONG64 FileLimit = LoggerContext->MaximumFileSize * BYTES_PER_MB;
        if (LoggerContext->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
            FileLimit = LoggerContext->MaximumFileSize * 1024;
        }
        if ( FileSize >= FileLimit ) { // reaches maximum file size
           ULONG LoggerMode = LoggerContext->LogFileMode & 0X000000FF;
           LoggerMode &= ~EVENT_TRACE_FILE_MODE_APPEND;
           LoggerMode &= ~EVENT_TRACE_FILE_MODE_PREALLOCATE;

            switch (LoggerMode) {


            case EVENT_TRACE_FILE_MODE_SEQUENTIAL :
                // do not write to logfile anymore
                Status = STATUS_LOG_FILE_FULL; // control needs to stop logging
                // need to fire up a Wmi Event to control console
                break;

            case EVENT_TRACE_FILE_MODE_CIRCULAR   :
            {
                // reposition file

                LoggerContext->ByteOffset
                    = LoggerContext->FirstBufferOffset;
                LoggerContext->LastFlushedBuffer = (ULONG)
                      (LoggerContext->FirstBufferOffset.QuadPart
                        / LoggerContext->BufferSize);
                break;
            }
            default :
                break;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = NtWriteFile(
                    LoggerContext->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    BufferSize,
                    &LoggerContext->ByteOffset,
                    NULL);
    }

    if (NT_SUCCESS(Status)) {
        LoggerContext->ByteOffset.QuadPart += BufferSize;
    }

 ResetTraceBuffer:

    if (NT_SUCCESS(Status)) {
        LoggerContext->BuffersWritten++;
        LoggerContext->LastFlushedBuffer++;
    }
    else {
        if ((Status != STATUS_NO_DATA_DETECTED) &&
            (Status != STATUS_SEVERITY_WARNING))
            LoggerContext->LogBuffersLost++;
    }

//
// Reset the buffer state
//

    Buffer->BufferType     = WMI_BUFFER_TYPE_GENERIC;
    Buffer->SavedOffset    = 0;
    Buffer->ReferenceCount = 0;
    Buffer->Flags          = BUFFER_STATE_UNUSED;

//
// Try and remove an unused buffer if it has not been used for a while
//

    InterlockedIncrement(& LoggerContext->BuffersAvailable);
    return Status;
}

PVOID
FASTCALL
EtwpReserveTraceBuffer(
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
{
    PWMI_BUFFER_HEADER Buffer, OldBuffer;
    PVOID       ReservedSpace;
    ULONG       Offset;
    ULONG Processor = (ULONG) (NtCurrentTeb()->IdealProcessor);
    PWMI_LOGGER_CONTEXT LoggerContext = EtwpLoggerContext;

    //
    // NOTE: This routine assumes that the caller has verified that
    // EtwpLoggerContext is valid and is locked
    //
    if (Processor >= LoggerContext->NumberOfProcessors) {
        Processor = LoggerContext->NumberOfProcessors-1;
    }
#if DBG
    if (LoggerContext->NumberOfProcessors == 0) {
        TraceDebug(("EtwpReserveTraceBuffer: Bad Context %x\n", LoggerContext));
    }
#endif

    *BufferResource = NULL;

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

  TryFindSpace:
    //
    // Get the processor specific buffer pool
    //
    Buffer = LoggerContext->ProcessorBuffers[Processor];
    if (Buffer == NULL) {
        return NULL;
    }

    //
    // Increment refcount to buffer first to prevent it from going away
    //
    InterlockedIncrement(&Buffer->ReferenceCount);
    if ((Buffer->Flags != BUFFER_STATE_FULL) &&
        (Buffer->Flags != BUFFER_STATE_UNUSED)) {
        //
        // This should happen 99% of the time. Offset will have the old value
        //
        Offset = (ULONG) InterlockedExchangeAdd(
                                & Buffer->CurrentOffset, RequiredSize);

        //
        // First, check to see if there is enough space. If not, it will
        // need to get another fresh buffer, and have the current buffer flushed
        //
        if (Offset+RequiredSize < LoggerContext->BufferSize) {
            //
            // Found the space so return it. This should happen 99% of the time
            //
            ReservedSpace = (PVOID) (Offset +  (char*)Buffer);
            if (LoggerContext->SequencePtr) {
                *((PULONG) ReservedSpace) =
                    InterlockedIncrement(LoggerContext->SequencePtr);
            }
            goto FoundSpace;
        }
    }
    else {
        Offset = Buffer->CurrentOffset; // Initialize Local Variable
                                        // tracelog.c v40 -> v41
    }
    if (Offset <LoggerContext->BufferSize) {
        Buffer->SavedOffset = Offset;       // save this for FlushBuffer
    }

    //
    //  if there is absolutely no more buffers, then return quickly
    //
    if ((LoggerContext->NumberOfBuffers == LoggerContext->MaximumBuffers)
         && (LoggerContext->BuffersAvailable == 0)) {
        goto LostEvent;
    }

    //
    // Out of buffer space. Need to take the long route to find a buffer
    //
    Buffer->Flags = BUFFER_STATE_FULL;

    OldBuffer = Buffer;
    Buffer = EtwpSwitchBuffer(LoggerContext, OldBuffer, Processor);
    if (Buffer == NULL) {
        Buffer = OldBuffer;
        goto LostEvent;
    }

    //
    // Decrement the refcount that we blindly incremented earlier
    // and possibly wake up the logger.
    //
    EtwpReleaseTraceBuffer( OldBuffer );
    Buffer->ClientContext.ProcessorNumber = (UCHAR) (Processor);

    goto TryFindSpace;

LostEvent:
    //
    // Will get here if we are throwing away events.
    // from tracelog.c v36->v37
    //
    LoggerContext->EventsLost ++;
    InterlockedDecrement(& Buffer->ReferenceCount);
    Buffer        = NULL;
    ReservedSpace = NULL;
    if (LoggerContext->SequencePtr) {
        InterlockedIncrement(LoggerContext->SequencePtr);
    }

FoundSpace:
    //
    // notify the logger after critical section
    //
    *BufferResource = Buffer;

    return ReservedSpace;
}



//
// This Routine is called to Relog an event for straigtening out an ETL
// in time order. This will result in two events being, one for Processor
// number and the actual event  without any modifications.
//

ULONG
FASTCALL
EtwpRelogEvent(
    IN PWNODE_HEADER Wnode,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PEVENT_TRACE pEvent = (PEVENT_TRACE) Wnode;

    PUCHAR BufferSpace;
    PULONG Marker;
    ULONG Size;
    ULONG MaxSize;
    ULONG SavedProcessor = (ULONG)NtCurrentTeb()->IdealProcessor;
    ULONG Processor;
    ULONG Mask;
    ULONG status;

    if (pEvent->Header.Size < sizeof(EVENT_TRACE) ) {
        return ERROR_INVALID_PARAMETER;
    }
    Processor = ((PWMI_CLIENT_CONTEXT)&pEvent->ClientContext)->ProcessorNumber;

    Size = pEvent->MofLength;
    MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
    if ((Size == 0) || (Size > MaxSize)) {
        LoggerContext->EventsLost++;
        return ERROR_BUFFER_OVERFLOW;
    }
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)Processor;
    BufferSpace = (PUCHAR)
        EtwpReserveTraceBuffer(
            Size,
            &BufferResource
            );
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)SavedProcessor;

    if (BufferSpace == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    RtlCopyMemory(BufferSpace, pEvent->MofData, Size);
    EtwpReleaseTraceBuffer( BufferResource );

    return ERROR_SUCCESS;
}



ULONG
FASTCALL
EtwpTraceUmEvent(
    IN PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine is used by WMI data providers to trace events.
    It expects the user to pass in the handle to the logger.
    Also, the user cannot ask to log something that is larger than
    the buffer size (minus buffer header).

Arguments:

    Wnode           The WMI node header that will be overloaded


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    PEVENT_TRACE_HEADER TraceRecord = (PEVENT_TRACE_HEADER) Wnode;
    ULONG WnodeSize, Size, Flags, HeaderSize;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG Marker;
    MOF_FIELD MofFields[MAX_MOF_FIELDS];
    long MofCount = 0;
    PCLIENT_ID Cid;
#if DBG
    LONG RefCount;
#endif


    HeaderSize = sizeof(WNODE_HEADER);  // same size as EVENT_TRACE_HEADER
    Size = Wnode->BufferSize;     // take the first DWORD flags
    Marker = Size;
    if (Marker & TRACE_HEADER_FLAG) {
        if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                == TRACE_HEADER_TYPE_INSTANCE )
            HeaderSize = sizeof(EVENT_INSTANCE_HEADER);
        Size = TraceRecord->Size;
    }
    WnodeSize = Size;           // WnodeSize is for the contiguous block
                                    // Size is for what we want in buffer

    Flags = Wnode->Flags;
    if (!(Flags & WNODE_FLAG_LOG_WNODE) &&
        !(Flags & WNODE_FLAG_TRACED_GUID))
        return ERROR_INVALID_PARAMETER;

#if DBG
    RefCount =
#endif
    EtwpLockLogger();
#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount-1, RefCount));
#endif

    LoggerContext = EtwpLoggerContext;

    if (!EtwpIsThisLoggerOn(LoggerContext)) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d INVALID_HANDLE\n",
                        RefCount+1, RefCount));
#endif
        return ERROR_INVALID_HANDLE;
    }

    if (Flags & WNODE_FLAG_NO_HEADER) {
        ULONG Status;

        Status = EtwpRelogEvent( Wnode, LoggerContext );
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();

#if DBG
        if (Status != ERROR_SUCCESS) {
            TraceDebug(("TraceUm: %d->%d Relog Error \n",
                            RefCount+1, RefCount));
        }
#endif
        return Status;

    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Need to compute the total size required, since the MOF fields
    // in Wnode merely contains pointers
    //
        long i;
        PCHAR Offset = ((PCHAR)Wnode) + HeaderSize;
        ULONG MofSize, MaxSize;

        MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
        MofSize = WnodeSize - HeaderSize;
        // allow only the maximum
        if (MofSize > (sizeof(MOF_FIELD) * MAX_MOF_FIELDS))
            return ERROR_INVALID_DATA;

        RtlZeroMemory( MofFields, MAX_MOF_FIELDS * sizeof(MOF_FIELD));
        if (MofSize > 0) {
            RtlCopyMemory(MofFields, Offset, MofSize);
        }
        Size = HeaderSize;

        MofCount = MofSize / sizeof(MOF_FIELD);
        for (i=0; i<MofCount; i++) {
            MofSize = MofFields[i].Length;
            if (MofSize > (MaxSize - Size)) {
#if DBG
                RefCount =
#endif
                EtwpUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW1\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }

            Size += MofSize;
            if ((Size > MaxSize) || (Size < MofSize)) {
#if DBG
                RefCount =
#endif
                EtwpUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW2\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    }
    if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        LoggerContext->EventsLost++;
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW3\n",
                    RefCount+1, RefCount));
#endif
        return ERROR_BUFFER_OVERFLOW;
    }

// So, now reserve some space in logger buffer and set that to TraceRecord

    TraceRecord = (PEVENT_TRACE_HEADER)
        EtwpReserveTraceBuffer(
            Size,
            &BufferResource
            );

    if (TraceRecord == NULL) {
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d NO_MEMORY\n", RefCount+1, RefCount));
#endif
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Now we need to probe and copy all the MOF data fields
    //
        PVOID MofPtr;
        ULONG MofLen;
        long i;
        PCHAR TraceOffset = ((PCHAR) TraceRecord) + HeaderSize;

        RtlCopyMemory(TraceRecord, Wnode, HeaderSize);
        TraceRecord->Size = (USHORT)Size;           // reset to Total Size
        for (i=0; i<MofCount; i++) {
            MofPtr = (PVOID) MofFields[i].DataPtr;
            MofLen = MofFields[i].Length;

            if (MofPtr == NULL || MofLen == 0)
                continue;

            RtlCopyMemory(TraceOffset, MofPtr, MofLen);
            TraceOffset += MofLen;
        }
    }
    else {
        RtlCopyMemory(TraceRecord, Wnode, Size);
    }
    if (Flags & WNODE_FLAG_USE_GUID_PTR) {
        PVOID GuidPtr = (PVOID) ((PEVENT_TRACE_HEADER)Wnode)->GuidPtr;

        RtlCopyMemory(&TraceRecord->Guid, GuidPtr, sizeof(GUID));
    }

    //
    // By now, we have reserved space in the trace buffer
    //

    if (Marker & TRACE_HEADER_FLAG) {
        if (! (WNODE_FLAG_USE_TIMESTAMP & TraceRecord->MarkerFlags) )
            TraceRecord->ProcessorTime = EtwpGetCycleCount();

        if (LoggerContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            TraceRecord->TimeStamp.QuadPart = TraceRecord->ProcessorTime;
        }
        else {
            TraceRecord->TimeStamp.QuadPart = EtwpGetSystemTime();
        }
        Cid = &NtCurrentTeb()->ClientId;
        TraceRecord->ThreadId = HandleToUlong(Cid->UniqueThread);
        TraceRecord->ProcessId = HandleToUlong(Cid->UniqueProcess);
    }

    EtwpReleaseTraceBuffer( BufferResource );
#if DBG
    RefCount =
#endif
    EtwpUnlockLogger();

#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount+1, RefCount));
#endif

    return ERROR_SUCCESS;
}

PWMI_BUFFER_HEADER
FASTCALL
EtwpSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    )
{
    PWMI_BUFFER_HEADER Buffer;
    ULONG CircularBufferOnly = FALSE;

    //
    // Need an assert for Processor
    //
#if DBG
    EtwpAssert( Processor < (ULONG)LoggerContext->NumberOfProcessors );
#endif

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }
    EtwpEnterUMCritSection();
    if (OldBuffer != LoggerContext->ProcessorBuffers[Processor]) {
        EtwpLeaveUMCritSection();
        return OldBuffer;
    }
    Buffer = EtwpGetFreeBuffer(LoggerContext);
    if (Buffer == NULL) {
        EtwpLeaveUMCritSection();
        return NULL;
    }
    LoggerContext->ProcessorBuffers[Processor] = Buffer;
    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &OldBuffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &OldBuffer->Entry);
    }
    EtwpLeaveUMCritSection();

    return Buffer;
}

ULONG
EtwpFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LONG RefCount;
    //
    // We use LoggerEvent as a timer in EtwpFreeLoggerContext().
    // This event should be set by the logger thread when it stopped.
    // We need to reset it.
    //
    NtClearEvent(LoggerContext->LoggerEvent);

    if (LoggerContext != NULL) {
        LARGE_INTEGER Timeout = {(ULONG)(-300 * 1000 * 10), -1};  // 300ms
        RefCount = EtwpLoggerCount;
        if (RefCount > 1) {
            LONG count = 0;
            NTSTATUS Status = STATUS_TIMEOUT;

            while (Status == STATUS_TIMEOUT) {
                count ++;
                Status = NtWaitForSingleObject(
                            EtwpLoggerContext->LoggerEvent, FALSE, &Timeout);
                if (EtwpLoggerCount <= 1)
                    break;
                if (EtwpLoggerCount == RefCount) {
#if DBG
                    TraceDebug(("FreeLogger: RefCount remained at %d\n",
                                 RefCount));
#endif
                    if (count >= 10) {
                        EtwpLoggerCount = 0;
                        TraceDebug(("FreeLogger: Setting RefCount to 0\n"));
                    }
                }
            }
        }
        if (LoggerContext->BufferSpace != NULL) {
            EtwpMemFree(LoggerContext->BufferSpace);
        }
        if (LoggerContext->ProcessorBuffers != NULL) {
            EtwpFree(LoggerContext->ProcessorBuffers);
        }
        if (LoggerContext->LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LoggerName);
        }
        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LogFileName);
        }
        EtwpLoggerContext = NULL;
        EtwpFree(LoggerContext);

    }
    return ERROR_SUCCESS;
}

ULONG
EtwpFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS           Status = STATUS_SUCCESS;
    ULONG              i;
    ULONG              NumberOfBuffers;
    PLIST_ENTRY        pEntry;
    PWMI_BUFFER_HEADER Buffer;
    ULONG RetryCount;

    EtwpEnterUMCritSection();

    // First, move the per processor buffer out to FlushList
    //
    for (i = 0; i < LoggerContext->NumberOfProcessors; i ++) {
        Buffer = (PWMI_BUFFER_HEADER) LoggerContext->ProcessorBuffers[i];
        LoggerContext->ProcessorBuffers[i] = NULL;
        if (Buffer != NULL) {

            //
            // Check to see if the Buffer ReferenceCount is 0. If Yes,
            // no one is writing to this buffer and it's okay to flush it.
            // If No, we need to wait until the other thread is done
            // writing to this buffer before flushing.
            //

            RetryCount = 0;
            while (Buffer->ReferenceCount != 0) {
                EtwpSleep (250);  // Retry every 1/4 second.
                RetryCount++;
                if (RetryCount > 300) {
                    //
                    // Since there is no guarantee that the ReferenceCount
                    // will ever go down to zero, we try this for over a minute.
                    // After that time we continue and free the buffer
                    // instead of spinning for ever.
#if DBG
                    TraceDebug(("EtwpFlushAllBuffer: RetryCount %d exceeds limit", RetryCount));
#endif
                    break;
                }
            }
            InsertTailList(& LoggerContext->FlushList, & Buffer->Entry);
        }
    }
    NumberOfBuffers = LoggerContext->NumberOfBuffers;

    while (   NT_SUCCESS(Status)
           && NumberOfBuffers > 0
           && (  LoggerContext->BuffersAvailable
               < LoggerContext->NumberOfBuffers))
    {
        USHORT BufferFlag;
        pEntry = IsListEmpty(& LoggerContext->FlushList)
               ? NULL
               : RemoveHeadList(& LoggerContext->FlushList);

        if (pEntry == NULL)
            break;

        Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
        //
        // Mark the last buffer with FLUSH_MARKER in order to guarantee
        // writing a marked buffer even when it's empty. 
        // NOTE: This assumes that there is atleast one buffer in the 
        // FlushList at this point. 
        //
        if ((NumberOfBuffers == 1) ||
           (LoggerContext->NumberOfBuffers == LoggerContext->BuffersAvailable+1)) {
            BufferFlag = WMI_BUFFER_FLAG_FLUSH_MARKER;
        }
        else {
            BufferFlag = WMI_BUFFER_FLAG_NORMAL;
        }

        Status = EtwpFlushBuffer(LoggerContext, Buffer, BufferFlag);
        InsertHeadList(& LoggerContext->FreeList, & Buffer->Entry);
        NumberOfBuffers --;
    }

    // Note that LoggerContext->LogFileObject needs to remain set
    // for QueryLogger to work after close
    //
    Status = NtClose(LoggerContext->LogFileHandle);

    LoggerContext->LogFileHandle = NULL;
    LoggerContext->LoggerStatus = Status;

    EtwpLeaveUMCritSection();

    return ERROR_SUCCESS;
}


ULONG
EtwpFlushUmLoggerBuffer()
/*++

Routine Description:

    This routine is used to stop and dump the private logger buffers
    when the process is shutting down (when ntdll is unloading). 

    LoggerThread may have been shut dowm abruptly so this routine can not
    block for the LoggerThread or any other thread to release the refcount. 

    It is currently not used. 

Arguments:



Return Value:

    STATUS_SUCCESS  

--*/
{
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG Status = ERROR_SUCCESS;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    EtwpLockLogger();
    TraceDebug(("FlushUmLoggerBuffer: %d->%d\n", RefCount-1, RefCount));

    LoggerContext = EtwpLoggerContext; 
    if (EtwpIsThisLoggerOn(LoggerContext)) {
        LoggerContext->CollectionOn = FALSE;
        Status = EtwpFlushAllBuffers(LoggerContext);
        if (Status == ERROR_SUCCESS) {
            PWMI_LOGGER_INFORMATION EtwpLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            EtwpLoggerInfo = (PWMI_LOGGER_INFORMATION) EtwpAlloc(lSizeUsed);
            if (EtwpLoggerInfo == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                RtlZeroMemory(EtwpLoggerInfo, lSizeUsed);
                EtwpLoggerInfo->Wnode.BufferSize  = lSizeUsed;
                EtwpLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
                Status = EtwpQueryUmLogger(
                                EtwpLoggerInfo->Wnode.BufferSize,
                                & lSizeUsed,
                                & lSizeNeeded,
                                EtwpLoggerInfo);

                if (Status == ERROR_SUCCESS) {
                    Status = EtwpFinalizeLogFileHeader(EtwpLoggerInfo);
                }
                EtwpFree(EtwpLoggerInfo);
            }
        }
#if DBG
        RefCount =
#endif
        EtwpUnlockLogger();
        TraceDebug(("FlushUmLoggerBuffer: %d->%d\n", RefCount-1, RefCount));
        EtwpFreeLoggerContext(LoggerContext);
    }

    return Status;
}

LONG
FASTCALL
EtwpReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    )
{
    ULONG RefCount;

    if (BufferResource == NULL)
        return 0;

    RefCount = InterlockedDecrement(&BufferResource->ReferenceCount);
    if ((RefCount == 0) && (BufferResource->Flags == BUFFER_STATE_FULL)) {
        NtReleaseSemaphore(EtwpLoggerContext->Semaphore, 1, NULL);
    }
    return RefCount;
}


ULONG
EtwpReceiveReply(
    HANDLE ReplyHandle,
    ULONG  ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    )
/*++

Routine Description:

    This routine receives the replies to a CreateUM call asynchronously. 
    The ReplyCount and ReplyHandle are what was returned from the CreateUM
    call. 

    It is possible to lose events (replies) in the kernel due to lack of 
    buffer space. The buffer is allocated once and not expanded if more 
    replies arrive. Kernel indicates this by setting the CountLost field to 
    the number of events that were lost.  This is done only in a valid 
    response. If for some reason all responses were lost, then we will not 
    know the CountLost and potentiallly hang. 

    If a provider died before sending a response, the request object cleanup
    code will send a dummy response with the ProvideId set to WmiRequestDied. 

    Since the caller to CreateUm does not know how many instances are present,
    the OutBufferSize may not be sifficient to copy all the replies. 
    Therefore, we simply copy the last valid response into the OutBuffer but
    indicate the number of instances of such a reply in the ProviderId field. 


Arguments:

    ReplyHandle      Handle to the ReplyObject which receives the reply
    ReplyCount       Expect this many replies
    ReplyIndex       Index to the Array in RequestObject (not useful!)
    OutBuffer        Buffer to copy result to 
    OutBufferSize    Size of the output buffer


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    ULONG Status = ERROR_SUCCESS;
    ULONG ErrorStatus = ERROR_SUCCESS;
    ULONG ReturnSize = 0;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG Linkage;
    ULONG RcvCount = 0;
    ULONG InstanceCount=0;
    ULONG CountLost;
    struct {
        WMIRECEIVENOTIFICATION Notification;
        HANDLE3264 Handle;
    } NotificationInfo;


    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          sizeof(HANDLE3264);

    RcvNotification = (PWMIRECEIVENOTIFICATION) &NotificationInfo;

    Status = ERROR_SUCCESS;

    RcvNotification->Handles[0].Handle64 = 0;
    RcvNotification->Handles[0].Handle = ReplyHandle;
    RcvNotification->HandleCount = 1;
    RcvNotification->Action = RECEIVE_ACTION_NONE;
    WmipSetPVoid3264(RcvNotification->UserModeCallback, NULL);

    BufferSize = 0x2000; //  Kernel default for EventQueue->Buffer
    Status = ERROR_SUCCESS;
    while ( (Status == ERROR_INSUFFICIENT_BUFFER) ||
            ((Status == ERROR_SUCCESS) && (RcvCount < ReplyCount)) )
    {
        Buffer = EtwpAlloc(BufferSize);
        if (Buffer != NULL)
        {
            Status = EtwpSendWmiKMRequest(NULL,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      RcvNotification,
                                      RcvNotificationSize,
                                      Buffer,
                                      BufferSize,
                                      &ReturnSize,
                                      NULL);


             if (Status == ERROR_SUCCESS)
             {
                 WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                 if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                     (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                 {
                    //
                    // The buffer passed to kernel mode was too small
                    // so we need to make it larger and then try the
                    // request again
                    //
                    BufferSize = WnodeTooSmall->SizeNeeded;
                    Status = ERROR_INSUFFICIENT_BUFFER;
                 } else {
                    //
                    // We got a buffer of notifications so lets go
                    // process them and callback the caller
                    //
                    PUCHAR Result = (PUCHAR)OutBuffer;
                    ULONG SizeNeeded = 0;
                    ULONG SizeUsed = 0;
                    Wnode = (PWNODE_HEADER)Buffer;

                    do
                    {
                        Linkage = Wnode->Linkage;
                        Wnode->Linkage = 0;

                        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                        {
                             // If this is the Reply copy it to the buffer
                             PWMI_LOGGER_INFORMATION LoggerInfo;

                             RcvCount++;

                             CountLost = (Wnode->Version) >> 16;                             
                             if (CountLost > 0) {
                                RcvCount += CountLost;
                             }

                             if ((Wnode->ProviderId != WmiRequestDied) &&
                                (Wnode->BufferSize >= 2*sizeof(WNODE_HEADER))) {

                                 LoggerInfo = (PWMI_LOGGER_INFORMATION)
                                              ((PUCHAR)Wnode + 
                                              sizeof(WNODE_HEADER));
                                 SizeNeeded = LoggerInfo->Wnode.BufferSize;

                                 if (SizeNeeded <= OutBufferSize) {
                                    PWNODE_HEADER lWnode; 
                                     InstanceCount++;
                                     RtlCopyMemory(Result, 
                                                   LoggerInfo, 
                                                   LoggerInfo->Wnode.BufferSize
                                                  );

                                    //
                                    // Since we do not know how many instances
                                    // got started apriori, we simply return one
                                    // instance's status and indicate the number
                                    // of instances in the ProviderId field. 
                                    //


                                    lWnode = (PWNODE_HEADER) Result;
                                    lWnode->ProviderId = InstanceCount;
                                 }
                                 else {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                 }
                            }
                            else {
                                //
                                // Logger had an error. Pick up the status
                                //
                                if (Wnode->BufferSize >= 
                                    sizeof(WNODE_HEADER)+sizeof(ULONG) ) {
                                    PULONG LoggerStatus; 
                                    LoggerStatus = (PULONG) ((PUCHAR)Wnode+
                                                         sizeof(WNODE_HEADER));
                                    ErrorStatus = *LoggerStatus;
                                    TraceDebug(("ETW: LoggerError %d\n", 
                                                *LoggerStatus));
                                }
                            }
                        }
                        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);

                        //
                        // Make sure we didn't get Linkage larger than 
                        // OutBufferSize
                        //
#if DBG
                        EtwpAssert( (ULONG)((PBYTE)Wnode - (PBYTE)Buffer) <= ReturnSize);
#endif
                     } while (Linkage != 0);
                 }
             }
             EtwpFree(Buffer);
         } else {
             Status = ERROR_NOT_ENOUGH_MEMORY;
         }
     }
     // This can happen if all the replies we got were bad.
     if (InstanceCount == 0) {
        if (Status == ERROR_SUCCESS) {
            Status = ErrorStatus;
        }
        if (Status == ERROR_SUCCESS) {
            Status = ERROR_WMI_INSTANCE_NOT_FOUND;
        }
     }

     return Status;
}


NTSTATUS
EtwpTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
)
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    PMESSAGE_TRACE_HEADER Header;
    char * pMessageData ;
    PWMI_BUFFER_HEADER BufferResource = NULL ;
    ULONG SequenceNumber ;
    PWMI_LOGGER_CONTEXT LoggerContext;

    EtwpLockLogger();                           // Lock the logger
    LoggerContext = EtwpLoggerContext;
    if (!EtwpIsThisLoggerOn(LoggerContext) ) {
        EtwpUnlockLogger();
        return STATUS_INVALID_HANDLE;
    }

    try {
         // Figure the total size of the message including the header
         Size += (MessageFlags&TRACE_MESSAGE_SEQUENCE ? sizeof(ULONG):0) +
                 (MessageFlags&TRACE_MESSAGE_GUID ? sizeof(GUID):0) +
                 (MessageFlags&TRACE_MESSAGE_COMPONENTID ? sizeof(ULONG):0) +
                 (MessageFlags&(TRACE_MESSAGE_TIMESTAMP | TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) ? sizeof(LARGE_INTEGER):0) +
                 (MessageFlags&TRACE_MESSAGE_SYSTEMINFO ? 2 * sizeof(ULONG):0) +
                 sizeof (MESSAGE_TRACE_HEADER) ;

        //
        // Allocate Space in the Trace Buffer
        //
         if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
             LoggerContext->EventsLost++;
             EtwpUnlockLogger();
             return STATUS_BUFFER_OVERFLOW;
         }

        if ((Header = (PMESSAGE_TRACE_HEADER)EtwpReserveTraceBuffer(Size, &BufferResource)) == NULL) {
            EtwpUnlockLogger();
            return STATUS_NO_MEMORY;
        }
        //
        // Sequence Number is returned in the Marker field of the buffer
        //
        SequenceNumber = Header->Marker ;

        //
        // Now copy the necessary information into the buffer
        //

        Header->Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        Header->Size = (USHORT)(Size & 0xFFFF) ;
        Header->Packet.OptionFlags = ((USHORT)MessageFlags &
                                      (TRACE_MESSAGE_SEQUENCE |
                                      TRACE_MESSAGE_GUID |
                                      TRACE_MESSAGE_COMPONENTID |
                                      TRACE_MESSAGE_TIMESTAMP |
                                      TRACE_MESSAGE_PERFORMANCE_TIMESTAMP |
                                      TRACE_MESSAGE_SYSTEMINFO)) &
                                      TRACE_MESSAGE_FLAG_MASK ;
        // Message Number
        Header->Packet.MessageNumber =  MessageNumber ;

        //
        // Now add in the header options we counted.
        //
        pMessageData = &(((PMESSAGE_TRACE)Header)->Data);


        //
        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            RtlCopyMemory(pMessageData, &SequenceNumber, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(GUID));
            pMessageData += sizeof(GUID) ;
        }

        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            LARGE_INTEGER Perfcount ;
            if (MessageFlags&TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) {
                LARGE_INTEGER Frequency ;
                NTSTATUS Status ;
                Status = NtQueryPerformanceCounter(&Perfcount, &Frequency);
            } else {
                Perfcount.QuadPart = EtwpGetSystemTime();
            };
            RtlCopyMemory(pMessageData,&Perfcount,sizeof(LARGE_INTEGER));
            pMessageData += sizeof(LARGE_INTEGER);
        }


        // [Fourth Entry] System Information?
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            PCLIENT_ID Cid;
            ULONG Id;     // match with NTOS version

            Cid = &NtCurrentTeb()->ClientId;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueThread);
            pMessageData += sizeof(ULONG) ;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueProcess);
            pMessageData += sizeof(ULONG) ;
        }

        //
        // Add New Header Entries immediately before this comment!
        //

        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (ap, size_t);
                RtlCopyMemory (pMessageData, source, elemBytes);
                pMessageData += elemBytes;
            }
        } // Allocation Block

        //
        // Buffer Complete, Release
        //
        EtwpReleaseTraceBuffer( BufferResource );
        EtwpUnlockLogger();
        //
        // Return Success
        //
        return (STATUS_SUCCESS);

    } except  (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
               EtwpReleaseTraceBuffer ( BufferResource );   // also unlocks the logger
        }
        EtwpUnlockLogger();
        return GetExceptionCode();
    }
}


PWMI_BUFFER_HEADER
FASTCALL
EtwpGetFullFreeBuffer(
    VOID
    )
{

    PWMI_BUFFER_HEADER Buffer;

    PWMI_LOGGER_CONTEXT LoggerContext = EtwpLoggerContext;

    EtwpEnterUMCritSection();
 
    Buffer = EtwpGetFreeBuffer(LoggerContext);

    if(Buffer) {
        
        InterlockedIncrement(&Buffer->ReferenceCount);

    } else {

        LoggerContext->EventsLost ++;
    }
    
    EtwpLeaveUMCritSection();

    return Buffer;
}

ULONG
EtwpReleaseFullBuffer(
    IN PWMI_BUFFER_HEADER Buffer
    )
{
    
    PWMI_LOGGER_CONTEXT LoggerContext = EtwpLoggerContext;
    ULONG CircularBufferOnly = FALSE;

    if(!Buffer) return STATUS_UNSUCCESSFUL;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }

    EtwpEnterUMCritSection();

    Buffer->SavedOffset = Buffer->CurrentOffset;
    Buffer->Flags = BUFFER_STATE_FULL;
    Buffer->CurrentOffset = EtwpGetCurrentThreadId();

    InterlockedDecrement(&Buffer->ReferenceCount);

    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &Buffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &Buffer->Entry);
    }

    EtwpLeaveUMCritSection();

    return ERROR_SUCCESS;
}

PWMI_BUFFER_HEADER
FASTCALL
EtwpSwitchFullBuffer(
    IN PWMI_BUFFER_HEADER OldBuffer
    )
{
    PWMI_BUFFER_HEADER Buffer;
    PWMI_LOGGER_CONTEXT LoggerContext = EtwpLoggerContext;
    ULONG CircularBufferOnly = FALSE;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }

    EtwpEnterUMCritSection();

    Buffer = EtwpGetFullFreeBuffer();

    OldBuffer->SavedOffset = OldBuffer->CurrentOffset;
    OldBuffer->Flags = BUFFER_STATE_FULL;
    OldBuffer->CurrentOffset = EtwpGetCurrentThreadId();

    InterlockedDecrement(&OldBuffer->ReferenceCount);

    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &OldBuffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &OldBuffer->Entry);
    }
    EtwpLeaveUMCritSection();

    if (!CircularBufferOnly) {
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }
    
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\trcapi.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:



Abstract:



Author:



Revision History:

--*/


#include "basedll.h"
#include "mountmgr.h"
#include "aclapi.h"
#include "winefs.h"
#include "ntrtl.h"

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement 
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchange _InterlockedCompareExchange


NTSTATUS
EtwpUuidCreate(
    OUT UUID *Uuid
    );

NTSTATUS 
EtwpRegOpenKey(
    IN PCWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    );

#define EtwpGetLastError RtlGetLastWin32Error
#define EtwpSetLastError RtlSetLastWin32Error
#define EtwpBaseSetLastNTError RtlSetLastWin32ErrorAndNtStatusFromNtStatus

DWORD
WINAPI
EtwpGetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

HANDLE
WINAPI
EtwpCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

HANDLE
EtwpBaseGetNamedObjectDirectory(
    VOID
    );



POBJECT_ATTRIBUTES
EtwpBaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    );


HANDLE
APIENTRY
EtwpCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

DWORD
WINAPI
EtwpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );


BOOL
WINAPI
EtwpReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );



BOOL
EtwpCloseHandle(
    HANDLE hObject
    );

DWORD
APIENTRY
EtwpWaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

BOOL
WINAPI
EtwpGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );

PLARGE_INTEGER
EtwpBaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    );

DWORD
EtwpWaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );

BOOL
WINAPI
EtwpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );

BOOL
WINAPI
EtwpCancelIo(
    HANDLE hFile
    );

extern PRTLP_EXIT_THREAD RtlpExitThreadFunc;
extern PRTLP_START_THREAD RtlpStartThreadFunc;

#define EtwpExitThread(x) RtlpExitThreadFunc(x)
#define EtwpGetCurrentProcessId() RtlGetCurrentProcessId()
#define EtwpGetCurrentThreadId() RtlGetCurrentThreadId()
#define EtwpGetCurrentProcess() NtCurrentProcess()

BOOL
EtwpSetEvent(
    HANDLE hEvent
    );

DWORD
APIENTRY
EtwpWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

HANDLE
APIENTRY
EtwpCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

DWORD
APIENTRY
EtwpSleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

VOID
EtwpSleep(
    DWORD dwMilliseconds
    );

BOOL
APIENTRY
EtwpSetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

BOOL
EtwpDuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );

ULONG EtwpAnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    );

DWORD
EtwpTlsAlloc(VOID);

LPVOID
EtwpTlsGetValue(DWORD dwTlsIndex);

BOOL
EtwpTlsSetValue(DWORD dwTlsIndex,LPVOID lpTlsValue);

BOOL
EtwpTlsFree(DWORD dwTlsIndex);


DWORD
APIENTRY
EtwpGetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD
APIENTRY
EtwpGetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

BOOL
EtwpResetEvent(
    HANDLE hEvent
    );

BOOL
WINAPI
EtwpGetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

BOOL
APIENTRY
EtwpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

BOOL
APIENTRY
EtwpDeleteFileW(
    LPCWSTR lpFileName
    );

UINT
APIENTRY
EtwpGetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );


DWORD
EtwpExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );

HANDLE
EtwpFindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

BOOL
EtwpFindClose(
    HANDLE hFindFile
    );

UINT
APIENTRY
EtwpGetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );

BOOL
EtwpEnumUILanguages(
    UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);

__inline 
ULONG
EtwpSetDosError(
    IN ULONG DosError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\tracelib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.h

Abstract:

    Private headers for user-mode trace library

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#ifndef _TRACELIB_H_
#define _TRACELIB_H_

#define EtwpNtStatusToDosError(Status) ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

#if defined(_IA64_)
#include <ia64reg.h>
#endif

//
// GetCycleCounts
//
// Since we do not want to make a kernel mode  transition to get the
// thread CPU Times, we settle for just getting the CPU Cycle counts.
// We use the following macros from BradW to get the CPU cycle count.
// This method may be inaccurate if the clocks are not synchronized
// between processors.
//

#if defined(_X86_)
__inline
LONGLONG
EtwpGetCycleCount(
    )
{
    __asm{
        RDTSC
    }
}
#elif defined(_AMD64_)
#define EtwpGetCycleCount() ReadTimeStampCounter()
#elif defined(_IA64_)
#define EtwpGetCycleCount() __getReg(CV_IA64_ApITC)
#else
#error "perf: a target architecture must be defined."
#endif

#define SMALL_BUFFER_SIZE 4096
#define PAGESIZE_MULTIPLE(x) \
     (((ULONG)(x) + ((SMALL_BUFFER_SIZE)-1)) & ~((ULONG)(SMALL_BUFFER_SIZE)-1))

PVOID
EtwpMemReserve(
    IN SIZE_T Size
    );

PVOID
EtwpMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    );

ULONG
EtwpMemFree(
    IN PVOID Buffer
    );

HANDLE
EtwpCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    );

NTSTATUS
EtwpGetCpuSpeed(
    OUT DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    );

#endif // _TRACELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\proppage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmiprop.rc
//
#define IDC_PROPERTY_LISTBOX            1001
#define IDC_DATA_SPIN                   1002
#define IDC_DATA_EDIT                   1003
#define IDC_DATA_COMBO                  1004
#define IDC_DATA_BUTTON                 1005
#define IDC_ARRAY_EDIT                  1006
#define IDC_ARRAY_SPIN                  1007
#define IDC_DATA_CHECK                  1008
#define IDC_DESCRIPTION_TEXT            1009
#define IDC_ARRAY_TEXT                  1010
#define IDC_ARRAY_STATIC                1011
#define ID_WMI_PROPPAGE                 3400
#define IDC_WMI_CONNECT_ERR             3401
#define IDC_WMI_EMBEDDED_OK             3402
#define IDC_WMI_EMBEDDED_CANCEL         3403
#define IDS_WMI_VALIDATION_ERROR        3500


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\ntdll\trcapi.c ===
/*++

Copyright (c) Corporation

Module Name:

    trcapi.c

Abstract:

    This module contains implementations of win32 api's used in wmi files.

Author:


Revision History:

--*/

#include <nt.h>
#include "nls.h"
#include "wmiump.h"
#include "trcapi.h"

#include <strsafe.h>

ULONG BaseDllTag;

#define TLS_MASK 0x80000000
#define TMP_TAG 0

#if defined(_WIN64) || defined(BUILD_WOW6432)
SYSTEM_BASIC_INFORMATION SysInfo;
#define BASE_SYSINFO (SysInfo)
#else
#define BASE_SYSINFO (BaseStaticServerData->SysInfo)
#endif

#if defined(BUILD_WOW6432)
#define UStr64ToUStr(dst, src) ( (dst)->Length = (src)->Length, \
                                 (dst)->MaximumLength = (src)->MaximumLength, \
                                 (dst)->Buffer = (PWSTR) ((src)->Buffer), \
                                 (dst) \
                              )

// In the 32BIT kernel32, on NT64 multiple the index by 2 since pointer 
// are twice are large.
#define BASE_SHARED_SERVER_DATA (NtCurrentPeb()->ReadOnlyStaticServerData[BASESRV_SERVERDLL_INDEX*2]) 
#define BASE_SERVER_STR_TO_LOCAL_STR(d,s) UStr64ToUStr(d,s)
#else
#define BASE_SHARED_SERVER_DATA (NtCurrentPeb()->ReadOnlyStaticServerData[BASESRV_SERVERDLL_INDEX])
#define BASE_SERVER_STR_TO_LOCAL_STR(d,s) *(d)=*(s)
#endif

DWORD
WINAPI
EtwpGetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using EtwpGetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    //
    // get the timezone data from the system
    // If it's terminal server session use client time zone

        Status = NtQuerySystemInformation(
                    SystemCurrentTimeZoneInformation,
                    &tzi,
                    sizeof(tzi),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            EtwpBaseSetLastNTError(Status);
            return 0xffffffff;
            }


        lpTimeZoneInformation->Bias         = tzi.Bias;
        lpTimeZoneInformation->StandardBias = tzi.StandardBias;
        lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;

        RtlMoveMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
        RtlMoveMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

        lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
        lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
        lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
        lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
        lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
        lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
        lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
        lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

        lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
        lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
        lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
        lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
        lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
        lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
        lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
        lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

        return USER_SHARED_DATA->TimeZoneId;
}

HANDLE
WINAPI
EtwpCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

      - If the hTemplateFile parameter is specified, any extended
        attributes associated with the file are assigned to the new file.

    If a new file is not created, then the hTemplateFile is ignored as
    are any extended attributes.

    For DOS based systems running share.exe the file sharing semantics
    work as described above.  Without share.exe no share level
    protection exists.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new file.

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.  If the hTemplateFile is specified,
            then any extended attributes associated with that file are
            propogated to the new file.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
            hTemplateFile is specified, then any extended attributes
            associated with that file are propogated to the new file.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

        FILE_FLAG_POSIX_SEMANTICS - Indicates that the file being opened
            should be accessed in a manner compatible with the rules used
            by POSIX.  This includes allowing multiple files with the same
            name, differing only in case.  WARNING:  Use of this flag may
            render it impossible for a DOS, WIN-16, or WIN-32 application
            to access the file.

        FILE_FLAG_OPEN_REPARSE_POINT - Indicates that the file being opened
            should be accessed as if it were a reparse point.  WARNING:  Use
            of this flag may inhibit the operation of file system filter drivers
            present in the I/O subsystem.

        FILE_FLAG_OPEN_NO_RECALL - Indicates that all the state of the file
            should be acessed without changing its storage location.  Thus,
            in the case of files that have parts of its state stored at a
            remote servicer, no permanent recall of data is to happen.

    Security Quality of Service information may also be specified in
        the dwFlagsAndAttributes parameter.  These bits are meaningful
        only if the file being opened is the client side of a Named
        Pipe.  Otherwise they are ignored.

        SECURITY_SQOS_PRESENT - Indicates that the Security Quality of
            Service bits contain valid values.

    Impersonation Levels:

        SECURITY_ANONYMOUS - Specifies that the client should be impersonated
            at Anonymous impersonation level.

        SECURITY_IDENTIFICAION - Specifies that the client should be impersonated
            at Identification impersonation level.

        SECURITY_IMPERSONATION - Specifies that the client should be impersonated
            at Impersonation impersonation level.

        SECURITY_DELEGATION - Specifies that the client should be impersonated
            at Delegation impersonation level.

    Context Tracking:

        SECURITY_CONTEXT_TRACKING - A boolean flag that when set,
            specifies that the Security Tracking Mode should be
            Dynamic, otherwise Static.

        SECURITY_EFFECTIVE_ONLY - A boolean flag indicating whether
            the entire security context of the client is to be made
            available to the server or only the effective aspects of
            the context.

    hTemplateFile - An optional parameter, then if specified, supplies a
        handle with GENERIC_READ access to a template file.  The
        template file is used to supply extended attributes for the file
        being created.  When the new file is created, the relevant attributes
        from the template file are used in creating the new file.

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using EtwpGetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaSize;
    PUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = 0;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    HANDLE Heap;

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OPEN;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                EtwpBaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            EtwpBaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    // temporary routing code

    RtlInitUnicodeString(&FileName,lpFileName);

    if ( FileName.Length > 1 && lpFileName[(FileName.Length >> 1)-1] == (WCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }
/*
    if ((lpConsoleName = EtwpBaseIsThisAConsoleName(&FileName,dwDesiredAccess)) ) {

        Handle = INVALID_HANDLE_VALUE;

        bInheritHandle = FALSE;
        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }

        Handle = EtwpOpenConsoleW(lpConsoleName,
                           dwDesiredAccess,
                           bInheritHandle,
                           FILE_SHARE_READ | FILE_SHARE_WRITE //dwShareMode
                          );

        if ( Handle == INVALID_HANDLE_VALUE ) {
            EtwpBaseSetLastNTError(STATUS_ACCESS_DENIED);
            return INVALID_HANDLE_VALUE;
            }
        else {
            EtwpSetLastError(0);
             return Handle;
            }
        }*/
    // end temporary code

    CreateFlags = 0;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        EtwpSetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS) ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT ) {

        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING) {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;

        } else {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY) {

            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;

        } else {

            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = SQOSFlags >> 16;


    } else {

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    EaBuffer = NULL;
    EaSize = 0;

    if ( ARGUMENT_PRESENT(hTemplateFile) ) {
        Status = NtQueryInformationFile(
                    hTemplateFile,
                    &IoStatusBlock,
                    &EaInfo,
                    sizeof(EaInfo),
                    FileEaInformation
                    );
        if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
            EaSize = EaInfo.EaSize;
            do {
                EaSize *= 2;
                EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                if ( !EaBuffer ) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    EtwpBaseSetLastNTError(STATUS_NO_MEMORY);
                    return INVALID_HANDLE_VALUE;
                    }
                Status = NtQueryEaFile(
                            hTemplateFile,
                            &IoStatusBlock,
                            EaBuffer,
                            EaSize,
                            FALSE,
                            (PVOID)NULL,
                            0,
                            (PULONG)NULL,
                            TRUE
                            );
                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                    EaBuffer = NULL;
                    IoStatusBlock.Information = 0;
                    }
                } while ( Status == STATUS_BUFFER_OVERFLOW ||
                          Status == STATUS_BUFFER_TOO_SMALL );
            EaSize = (ULONG)IoStatusBlock.Information;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT ) {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL ) {
        CreateFlags |= FILE_OPEN_NO_RECALL;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }
    else {

        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) ) {
             CreateFlags |= FILE_DIRECTORY_FILE;
             }
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaSize
                );

    RtlReleaseRelativeName(&RelativeName);
    
    RtlFreeHeap(Heap = RtlProcessHeap(), 0,FreeBuffer);

    RtlFreeHeap(Heap, 0, EaBuffer);

    if ( !NT_SUCCESS(Status) ) {
        EtwpBaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            EtwpSetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                EtwpSetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                EtwpSetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        EtwpSetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        EtwpSetLastError(0);
        }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            EtwpBaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
            }
        }

    //
    // Deal with hTemplateFile
    //

    return Handle;
}

HANDLE
EtwpBaseGetNamedObjectDirectory(
    VOID
    )
{
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    UNICODE_STRING RestrictedObjectDirectory;
    ACCESS_MASK DirAccess = DIRECTORY_ALL_ACCESS &
                            ~(DELETE | WRITE_DAC | WRITE_OWNER);
    HANDLE hRootNamedObject;
    HANDLE BaseHandle;


    if ( BaseNamedObjectDirectory != NULL) {
        return BaseNamedObjectDirectory;
    }

    RtlAcquirePebLock();

    if ( !BaseNamedObjectDirectory ) {

        PBASE_STATIC_SERVER_DATA tmpBaseStaticServerData = BASE_SHARED_SERVER_DATA;
        BASE_READ_REMOTE_STR_TEMP(TempStr);
        InitializeObjectAttributes( &Obja,
                                    BASE_READ_REMOTE_STR(tmpBaseStaticServerData->NamedObjectDirectory, TempStr),
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );

        Status = NtOpenDirectoryObject( &BaseHandle,
                                        DirAccess,
                                        &Obja
                                      );

        // if the intial open failed, try again with just traverse, and
        // open the restricted subdirectory

        if ( !NT_SUCCESS(Status) ) {
            Status = NtOpenDirectoryObject( &hRootNamedObject,
                                            DIRECTORY_TRAVERSE,
                                            &Obja
                                          );
            if ( NT_SUCCESS(Status) ) {
                RtlInitUnicodeString( &RestrictedObjectDirectory, L"Restricted");

                InitializeObjectAttributes( &Obja,
                                            &RestrictedObjectDirectory,
                                            OBJ_CASE_INSENSITIVE,
                                            hRootNamedObject,
                                            NULL
                                            );
                Status = NtOpenDirectoryObject( &BaseHandle,
                                                DirAccess,
                                                &Obja
                                              );
                NtClose( hRootNamedObject );
            }

        }
        if ( NT_SUCCESS(Status) ) {
            BaseNamedObjectDirectory = BaseHandle;
        }
    }
    RtlReleasePebLock();
    return BaseNamedObjectDirectory;
}


POBJECT_ATTRIBUTES
EtwpBaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes
        structure that contains a superset of the information provided
        by the security attributes structure.

    SecurityAttributes - Supplies the address of a security attributes
        structure that needs to be transformed into an NT object
        attributes structure.

    ObjectName - Supplies a name for the object relative to the
        BaseNamedObjectDirectory object directory.

Return Value:

    NULL - A value of null should be used to mimic the behavior of the
        specified SecurityAttributes structure.

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    HANDLE RootDirectory;
    ULONG Attributes;
    PVOID SecurityDescriptor;

    if ( ARGUMENT_PRESENT(SecurityAttributes) ||
         ARGUMENT_PRESENT(ObjectName) ) {

        if ( SecurityAttributes ) {
            Attributes = (SecurityAttributes->bInheritHandle ? OBJ_INHERIT : 0);
            SecurityDescriptor = SecurityAttributes->lpSecurityDescriptor;
            }
        else {
            Attributes = 0;
            SecurityDescriptor = NULL;
            }

        if ( ARGUMENT_PRESENT(ObjectName) ) {

            Attributes |= OBJ_OPENIF;
            RootDirectory = EtwpBaseGetNamedObjectDirectory();
            }
        else {
            RootDirectory = NULL;
            }

        InitializeObjectAttributes(
            ObjectAttributes,
            ObjectName,
            Attributes,
            RootDirectory,
            SecurityDescriptor
            );
        return ObjectAttributes;
        }
    else {
        return NULL;
        }
}


HANDLE
APIENTRY
EtwpCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using EtwpGetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = EtwpBaseFormatObjectAttributes(&Obja,lpEventAttributes,&ObjectName);
        }
    else {
        pObja = EtwpBaseFormatObjectAttributes(&Obja,lpEventAttributes,NULL);
        }

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            EtwpSetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            EtwpSetLastError(0);
            }
        return Handle;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return NULL;
        }
}


//
// Event Services
//

DWORD
WINAPI
EtwpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        EtwpGetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        EtwpBaseSetLastNTError(STATUS_INVALID_HANDLE);
        return (DWORD)-1;
        }

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                EtwpBaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                EtwpBaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            EtwpSetLastError(ERROR_INVALID_PARAMETER);
            return (DWORD)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        EtwpSetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            EtwpSetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}



BOOL
WINAPI
EtwpReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using EtwpGetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }
    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
            }
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) && ARGUMENT_PRESENT(lpNumberOfBytesRead)) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
EtwpCloseHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;

    } else {

        EtwpBaseSetLastNTError(Status);
        return FALSE;
    }
}

DWORD
APIENTRY
EtwpWaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. EtwpGetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {

        Peb = NtCurrentPeb();
        switch( HandleToUlong(hHandle) ) {
            case STD_INPUT_HANDLE:  hHandle = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hHandle = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hHandle = Peb->ProcessParameters->StandardError;
                                    break;
            }

        pTimeOut = EtwpBaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            EtwpBaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}


BOOL
WINAPI
EtwpGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the EtwpGetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        EtwpGetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = EtwpWaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            EtwpSetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}


PLARGE_INTEGER
EtwpBaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}


DWORD
EtwpWaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return EtwpWaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}


BOOL
WINAPI
EtwpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        EtwpGetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            try {
                *lpBytesReturned = 0;
                *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                }
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;
        if (!(ARGUMENT_PRESENT(lpBytesReturned) ) ) {
            EtwpSetDosError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
EtwpCancelIo(
    HANDLE hFile
    )

/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        EtwpGetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Simply cancel the I/O for the specified file.
    //

    Status = NtCancelIoFile(hFile, &IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }

}

BOOL
EtwpSetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using EtwpGetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
APIENTRY
EtwpWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. EtwpGetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        if (nCount > 8) {
            HandleArray = (LPHANDLE) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nCount*sizeof(HANDLE));
            if (HandleArray == NULL) {
                EtwpBaseSetLastNTError(STATUS_NO_MEMORY);
                Status = (NTSTATUS)0xffffffff;
                leave;
            }
        } else {
            HandleArray = Handles;
        }
        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();
        for (i=0;i<nCount;i++) {
            switch( HandleToUlong(HandleArray[i]) ) {
                case STD_INPUT_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardInput;
                                        break;
                case STD_OUTPUT_HANDLE: HandleArray[i] = Peb->ProcessParameters->StandardOutput;
                                        break;
                case STD_ERROR_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardError;
                                        break;
                }
            }

        pTimeOut = EtwpBaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForMultipleObjects(
                     nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if ( !NT_SUCCESS(Status) ) {
            EtwpBaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

VOID
EtwpSleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    EtwpSleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
EtwpSleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        pTimeOut = EtwpBaseFormatTimeOut(&TimeOut,dwMilliseconds);
        if (pTimeOut == NULL) {
            //
            // If Sleep( -1 ) then delay for the longest possible integer
            // relative to now.
            //

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;
            pTimeOut = &TimeOut;
            }

    rewait:
        Status = NtDelayExecution(
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

BOOL
APIENTRY
EtwpSetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using EtwpGetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;

    BasePriority = (LONG)nPriority;


    //
    // saturation is indicated by calling with a value of 16 or -16
    //

    if ( BasePriority == THREAD_PRIORITY_TIME_CRITICAL ) {
        BasePriority = ((HIGH_PRIORITY + 1) / 2);
        }
    else if ( BasePriority == THREAD_PRIORITY_IDLE ) {
        BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }
    Status = NtSetInformationThread(
                hThread,
                ThreadBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );
    if ( !NT_SUCCESS(Status) ) {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
EtwpDuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using EtwpGetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hSourceHandle) ) {
        case STD_INPUT_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hSourceHandle = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardError;
                                break;
        }

    Status = NtDuplicateObject(
                hSourceProcessHandle,
                hSourceHandle,
                hTargetProcessHandle,
                lpTargetHandle,
                (ACCESS_MASK)dwDesiredAccess,
                bInheritHandle ? OBJ_INHERIT : 0,
                dwOptions
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }

    return FALSE;
}

HANDLE
APIENTRY
EtwpCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
    HANDLE ThreadHandle;

    //
    // We changed the code from RtlCreateUserThread to RtlpStartThreadFunc
    // to create WIN32 threads. When kernel32 loads it hands over the pointer
    // of BaseCreateThreadPoolThread and assigns it to RtlpStartThreadFunc.
    // So we can happily create WIN32 Thread using RtlpStartThreadFunc.
    //


    NTSTATUS st = RtlpStartThreadFunc(lpStartAddress,
                                      lpParameter,
                                      &ThreadHandle);
    if(NT_SUCCESS(st)){

        st = NtResumeThread(ThreadHandle,NULL);

        if(NT_SUCCESS(st)){
        
            return ThreadHandle;

        } else {

            NtTerminateThread(ThreadHandle,st);

            NtClose(ThreadHandle);
        }
    }
    return NULL;
}


/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

// TLS FUNCTIONS

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

DWORD
EtwpTlsAlloc(
    VOID
    )

/*++

Routine Description:

    A TLS index may be allocated using TlsAllocHelper.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFreeHelper, TlsSetValueHelper, or TlsGetValueHelper.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    RtlAcquirePebLock();
    try {

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);
        if ( Index == 0xffffffff ) {
            Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsExpansionBitmap,1,0);
            if ( Index == 0xffffffff ) {
                EtwpSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
            }
            else {
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlClearBits((PRTL_BITMAP)Peb->TlsExpansionBitmap,Index,1);
                        Index = 0xffffffff;
                        EtwpSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
                        leave;
                    }
                }
                Teb->TlsExpansionSlots[Index] = NULL;
                Index += TLS_MINIMUM_AVAILABLE;
            }
        }
        else {
            Teb->TlsSlots[Index] = NULL;
        }
    }
    finally {
        RtlReleasePebLock();
    }
#if DBG
    Index |= TLS_MASK;
#endif
    return Index;
}

LPVOID
EtwpTlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAllocHelper and TlsGetValueHelper as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAllocHelper.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValueHelper.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValueHelper.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValueHelper to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFreeHelper call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    PTEB Teb;
    LPVOID *Slot;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsGetValueHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex < TLS_MINIMUM_AVAILABLE ) {
        Slot = &Teb->TlsSlots[dwTlsIndex];
        Teb->LastErrorValue = 0;
        return *Slot;
        }
    else {
        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS ) {
            EtwpSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
            return NULL;
            }
        else {
            Teb->LastErrorValue = 0;
            if ( Teb->TlsExpansionSlots ) {
                return  Teb->TlsExpansionSlots[dwTlsIndex-TLS_MINIMUM_AVAILABLE];
                }
            else {
                return NULL;
                }
            }
        }
}

BOOL
EtwpTlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAllocHelper and TlsSetValueHelper as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAllocHelper.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValueHelper.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValueHelper.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValueHelper to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFreeHelper call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PTEB Teb;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsSetValueHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
        dwTlsIndex -= TLS_MINIMUM_AVAILABLE;
        if ( dwTlsIndex < TLS_EXPANSION_SLOTS ) {
            if ( !Teb->TlsExpansionSlots ) {
                RtlAcquirePebLock();
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlReleasePebLock();
                        EtwpSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
                        return FALSE;
                        }
                    }
                RtlReleasePebLock();
                }
            Teb->TlsExpansionSlots[dwTlsIndex] = lpTlsValue;
            }
        else {
            EtwpSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
            return FALSE;
            }
        }
    else {
        Teb->TlsSlots[dwTlsIndex] = lpTlsValue;
        }
    return TRUE;
}

BOOL
EtwpTlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFreeHelper.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful.  Calling TlsTranslateIndex with
        this index will fail.  TlsAllocHelper is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PPEB Peb;
    BOOLEAN ValidIndex;
    PRTL_BITMAP TlsBitmap;
    NTSTATUS Status;
    DWORD Index2;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsFreeHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Peb = NtCurrentPeb();

    RtlAcquirePebLock();
    try {

        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
            Index2 = dwTlsIndex - TLS_MINIMUM_AVAILABLE;
            if ( Index2 >= TLS_EXPANSION_SLOTS ) {
                ValidIndex = FALSE;
            }
            else {
                TlsBitmap = (PRTL_BITMAP)Peb->TlsExpansionBitmap;
                ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
            }
        }
        else {
            TlsBitmap = (PRTL_BITMAP)Peb->TlsBitmap;
            Index2 = dwTlsIndex;
            ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
        }
        if ( ValidIndex ) {

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadZeroTlsCell,
                        &dwTlsIndex,
                        sizeof(dwTlsIndex)
                        );
            if ( !NT_SUCCESS(Status) ) {
                EtwpSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
                ValidIndex = FALSE;
                leave;
            }

            RtlClearBits(TlsBitmap,Index2,1);
        }
        else {
            EtwpSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        }
    }
    finally {
        RtlReleasePebLock();
    }
    return ValidIndex;
}

BOOL
EtwpBasep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    )
/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into a heap-allocated
    UNICODE string

Arguments:

    UnicodeString - location where UNICODE_STRING is stored

    lpSourceString - string in OEM or ANSI

Return Value:

    TRUE if string is correctly stored, FALSE if an error occurred.  In the
    error case, the last error is correctly set.

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Convert input into dynamic unicode string
    //

    RtlInitString( &AnsiString, lpSourceString );
    Status = RtlAnsiStringToUnicodeString( UnicodeString, &AnsiString, TRUE );

    //
    //  If we couldn't do this, fail
    //

    if (!NT_SUCCESS( Status )){
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            EtwpSetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            EtwpBaseSetLastNTError( Status );
        }
        return FALSE;
        }

    return TRUE;
}


DWORD
APIENTRY
EtwpGetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to GetFullPathNameW

--*/

{

    NTSTATUS Status;
    ULONG UnicodeLength;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeResult;
    ANSI_STRING AnsiResult;
    PWSTR Ubuff;
    PWSTR FilePart=NULL;
    PWSTR *FilePartPtr;
    INT PrefixLength = 0;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
        }
    else {
        FilePartPtr = NULL;
        }

    if (!EtwpBasep8BitStringToDynamicUnicodeString( &UnicodeString, lpFileName )) {
        return 0;
    }

    Ubuff = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (MAX_PATH<<1) + sizeof(UNICODE_NULL));
    if ( !Ubuff ) {
        RtlFreeUnicodeString(&UnicodeString);
        EtwpBaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }

    UnicodeLength = RtlGetFullPathName_U(
                        UnicodeString.Buffer,
                        (MAX_PATH<<1),
                        Ubuff,
                        FilePartPtr
                        );

    //
    // UnicodeLength contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to get
    // the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS environment,
    // it's definitely WRONG.
    //
    if ( UnicodeLength <= ((MAX_PATH * sizeof(WCHAR) + sizeof(UNICODE_NULL))) ) {

        Status = RtlUnicodeToMultiByteSize(&UnicodeLength, Ubuff, UnicodeLength);
        //
        // At this point, UnicodeLength variable contains
        // Ansi based byte length.
        //
        if ( NT_SUCCESS(Status) ) {
            if ( UnicodeLength && ARGUMENT_PRESENT(lpFilePart) && FilePart != NULL ) {
                INT UnicodePrefixLength;

                UnicodePrefixLength = (INT)(FilePart - Ubuff) * sizeof(WCHAR);
                Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                    Ubuff,
                                                    UnicodePrefixLength );
                //
                // At this point, PrefixLength variable contains
                // Ansi based byte length.
                //
                if ( !NT_SUCCESS(Status) ) {
                    EtwpBaseSetLastNTError(Status);
                    UnicodeLength = 0;
                }
            }
        } else {
            EtwpBaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        //
        // we exceed the MAX_PATH limit. we should log the error and
        // return zero. however US code returns the byte count of
        // buffer required and doesn't log any error.
        //
        UnicodeLength = 0;
    }
    if ( UnicodeLength && UnicodeLength < nBufferLength ) {
        RtlInitUnicodeString(&UnicodeResult,Ubuff);
        Status = RtlUnicodeStringToAnsiString(&AnsiResult,&UnicodeResult,TRUE);
        if ( NT_SUCCESS(Status) ) {
            RtlMoveMemory(lpBuffer,AnsiResult.Buffer,UnicodeLength+1);
            RtlFreeAnsiString(&AnsiResult);

            if ( ARGUMENT_PRESENT(lpFilePart) ) {
                if ( FilePart == NULL ) {
                    *lpFilePart = NULL;
                    }
                else {
                    *lpFilePart = lpBuffer + PrefixLength;
                    }
                }
            }
        else {
            EtwpBaseSetLastNTError(Status);
            UnicodeLength = 0;
            }
        }
    else {
        if ( UnicodeLength ) {
            UnicodeLength++;
            }
        }
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeHeap(RtlProcessHeap(), 0,Ubuff);

    return (DWORD)UnicodeLength;
}

DWORD
APIENTRY
EtwpGetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to return the fully qualified path name
    corresponding to the specified file name.

    This function is used to return a fully qualified pathname
    corresponding to the specified filename.  It does this by merging
    the current drive and directory together with the specified file
    name.  In addition to this, it calculates the address of the file
    name portion of the fully qualified pathname.

Arguments:

    lpFileName - Supplies the file name of the file whose fully
        qualified pathname is to be returned.

    nBufferLength - Supplies the length in number of wide characters of the 
        buffer that is to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        specified file.

    lpFilePart - Returns the address of the last component of the fully
        qualified pathname.

Return Value:

    The return value is the length of the string(in number of wide characters)
    copied to lpBuffer, not including the terminating null character.  
    If the return value is greater than nBufferLength, the return value is the 
    size of the buffer required to hold the pathname.  The return value is zero
    if the function failed.

--*/

{

    return (DWORD) RtlGetFullPathName_U(
                        lpFileName,
                        nBufferLength*2,
                        lpBuffer,
                        lpFilePart
                        )/2;
}


BOOL
EtwpResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
EtwpGetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    union {
        FILE_FS_SIZE_INFORMATION Normal;
        FILE_FS_FULL_SIZE_INFORMATION Full;
    } SizeInfo;

    WCHAR DefaultPath[2];
    ULARGE_INTEGER BytesPerAllocationUnit;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;

    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpDirectoryName) ? lpDirectoryName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        EtwpSetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        EtwpBaseSetLastNTError(Status);
        if ( EtwpGetLastError() == ERROR_FILE_NOT_FOUND ) {
            EtwpSetLastError(ERROR_PATH_NOT_FOUND);
            }
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    //
    // If the caller wants the volume total then try to get a full
    // file size.
    //

    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {

        Status = NtQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo.Full),
                    FileFsFullSizeInformation
                    );

        if ( NT_SUCCESS(Status) ) {

            NtClose(Handle);

            BytesPerAllocationUnit.QuadPart =
                SizeInfo.Full.BytesPerSector * SizeInfo.Full.SectorsPerAllocationUnit;

            if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
                lpFreeBytesAvailableToCaller->QuadPart =
                    BytesPerAllocationUnit.QuadPart *
                    SizeInfo.Full.CallerAvailableAllocationUnits.QuadPart;
                }
            if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
                lpTotalNumberOfBytes->QuadPart =
                    BytesPerAllocationUnit.QuadPart * SizeInfo.Full.TotalAllocationUnits.QuadPart;
                }
            lpTotalNumberOfFreeBytes->QuadPart =
                BytesPerAllocationUnit.QuadPart *
                SizeInfo.Full.ActualAvailableAllocationUnits.QuadPart;

            return TRUE;
        }
    }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo.Normal),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }

    BytesPerAllocationUnit.QuadPart =
        SizeInfo.Normal.BytesPerSector * SizeInfo.Normal.SectorsPerAllocationUnit;

    FreeBytesAvailableToCaller.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.AvailableAllocationUnits.QuadPart;

    TotalNumberOfBytes.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.TotalAllocationUnits.QuadPart;

    if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
        lpFreeBytesAvailableToCaller->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
        lpTotalNumberOfBytes->QuadPart = TotalNumberOfBytes.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {
        lpTotalNumberOfFreeBytes->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }

    return TRUE;
}


BOOL
APIENTRY
EtwpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    The main attributes of a file can be obtained using GetFileAttributesEx.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    fInfoLevelId - Supplies the info level indicating the information to be
        returned about the file.

    lpFileInformation - Supplies a buffer to receive the specified information
        about the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LPWIN32_FILE_ATTRIBUTE_DATA AttributeData;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    //
    // Check the parameters.  Note that for now there is only one info level,
    // so there's no special code here to determine what to do.
    //

    if ( fInfoLevelId >= GetFileExMaxInfoLevel || fInfoLevelId < GetFileExInfoStandard ) {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        EtwpSetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
EtwpDeleteFileW(
    LPCWSTR lpFileName
    )

/*++

    Routine Description:

    An existing file can be deleted using DeleteFile.

    This API provides the same functionality as DOS (int 21h, function 41H)
    and OS/2's DosDelete.

Arguments:

    lpFileName - Supplies the file name of the file to be deleted.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    BOOLEAN fIsSymbolicLink = FALSE;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        EtwpSetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );
    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                EtwpBaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            //
            // A second case of interest is when the caller does not have rights 
            // to read attributes yet it does have rights to delete the file.
            // In this case Status is to be STATUS_ACCESS_DENIED.
            //
            
            if ( Status != STATUS_ACCESS_DENIED ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                EtwpBaseSetLastNTError(Status);
                return FALSE;
                }
            
            // 
            // Re-open inhibiting reparse point and not requiring read attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                EtwpBaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // If we are here, Handle is valid.
            //
            // Moreover, Handle is to a file for which the caller has DELETE right yet
            // does not have FILE_READ_ATTRIBUTES rights. 
            //
            // The underlying file may or not be a reparse point. 
            // As the caller does not have rights to read the attributes this code
            // will delete this file without giving the opportunity to the 
            // appropriate manager of these reparse points to clean-up its internal 
            // state at this time.
            //
            }
        }
    else {
        //
        // If we found a reparse point that is not a symbolic link, we re-open
        // without inhibiting the reparse behavior.
        //

        Status = NtQueryInformationFile(
                     Handle,
                     &IoStatusBlock,
                     (PVOID) &FileTagInformation,
                     sizeof(FileTagInformation),
                     FileAttributeTagInformation
                     );
        if ( !NT_SUCCESS(Status) ) {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a 
            // non-supported information class is requested to a back-level 
            // File System. As all the parameters to NtQueryInformationFile
            // are correct, we can infer that we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                 (Status != STATUS_INVALID_PARAMETER) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);
                EtwpBaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ) {
            if ( FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {
                fIsSymbolicLink = TRUE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
             !fIsSymbolicLink) {
            //
            // Re-open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            NtClose(Handle);
            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if ( Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED ) {
                    //
                    // We re-open (possible 3rd open) for delete access 
                    // inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(
                                 &Handle,
                                 (ACCESS_MASK)DELETE,
                                 &Obja,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | 
                                                   FILE_SHARE_DELETE,
                                 FILE_NON_DIRECTORY_FILE | 
                                 FILE_OPEN_FOR_BACKUP_INTENT | 
                                 FILE_OPEN_REPARSE_POINT
                                 );
                    }

                if ( !NT_SUCCESS(Status) ) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    EtwpBaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        EtwpBaseSetLastNTError(Status);
        return FALSE;
        }
}


UINT
APIENTRY
EtwpGetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the Windows system
    subdirectory.  The system subdirectory contains such files as
    Windows libraries, drivers, and font files.

    The pathname retrieved by this function does not end with a
    backslash unless the system directory is the root directory.  For
    example, if the system directory is named WINDOWS\SYSTEM on drive
    C:, the pathname of the system subdirectory retrieved by this
    function is C:\WINDOWS\SYSTEM.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    UNICODE_STRING WindowsSystemDirectory;
    PBASE_STATIC_SERVER_DATA tmpBaseStaticServerData = BASE_SHARED_SERVER_DATA;

#ifdef WX86
    if (NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll) {
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
        BASE_SERVER_STR_TO_LOCAL_STR(&WindowsSystemDirectory, &tmpBaseStaticServerData->WindowsSys32x86Directory);
        }
#else 
        BASE_SERVER_STR_TO_LOCAL_STR(&WindowsSystemDirectory, &tmpBaseStaticServerData->WindowsDirectory);
#endif

    if ( uSize*2 < WindowsSystemDirectory.MaximumLength ) {
        return WindowsSystemDirectory.MaximumLength/2;
        }
    RtlMoveMemory(
        lpBuffer,
        WindowsSystemDirectory.Buffer,
        WindowsSystemDirectory.Length
        );
    lpBuffer[(WindowsSystemDirectory.Length>>1)] = UNICODE_NULL;
    return WindowsSystemDirectory.Length/2;
}

///
/// Duplicated code form intlrndp.c
///

#define DEFAULT_GUID_COUNT        100

ULONG
EtwpEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG MaxGuidCount = 0;
    PWMIGUIDLISTINFO GuidInfo;
    ULONG RetSize=0;
    ULONG GuidInfoSize;

    MaxGuidCount = DEFAULT_GUID_COUNT;
retry:
    GuidInfoSize = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                     MaxGuidCount * sizeof(WMIGUIDPROPERTIES);
         
    GuidInfo = (PWMIGUIDLISTINFO)EtwpAlloc(GuidInfoSize);

    if (GuidInfo == NULL)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    
    RtlZeroMemory(GuidInfo, GuidInfoSize);

    Status = EtwpSendWmiKMRequest(NULL,
                                  IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES,
                                  GuidInfo,
                                  GuidInfoSize,
                                  GuidInfo,
                                  GuidInfoSize,
                                  &RetSize,
                                  NULL);
    if (Status == ERROR_SUCCESS)
    {
        if ((RetSize < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) ||
            (RetSize < (FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                GuidInfo->ReturnedGuidCount * sizeof(WMIGUIDPROPERTIES))))
        {
            //
            // WMI KM returned to us a bad size which should not happen
            //
            Status = ERROR_WMI_DP_FAILED;
            EtwpAssert(FALSE);
        EtwpFree(GuidInfo);
        } else {

            //
            // If RPC was successful, then build a WMI DataBlock with the data
            //
  
            if (GuidInfo->TotalGuidCount > GuidInfo->ReturnedGuidCount) {
                MaxGuidCount = GuidInfo->TotalGuidCount;
                EtwpFree(GuidInfo);
                goto retry;
            }
        }

        //
        // If the call was successful, return the pointers and the caller
        // must free the storage. 
        //

        *pGuidInfo = GuidInfo;
    }

    return Status;
}

///////
////// Duplicated from chunkimp.h
//////


ULONG EtwpBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    )
{
    WCHAR GuidChar[37];
    HRESULT hr;

    EtwpAssert(Guid != NULL);
    EtwpAssert(GuidString != NULL);
    EtwpAssert(GuidObjectName != NULL);
    
    //
    // Build up guid name into the ObjectAttributes
    //

    hr = StringCbPrintfW(GuidChar, sizeof(GuidChar),L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               Guid->Data1, Guid->Data2,
               Guid->Data3,
               Guid->Data4[0], Guid->Data4[1],
               Guid->Data4[2], Guid->Data4[3],
               Guid->Data4[4], Guid->Data4[5],
               Guid->Data4[6], Guid->Data4[7]);

    WmipAssert(hr == S_OK);

    hr = StringCchCopyW(GuidObjectName,
                 WmiGuidObjectNameLength+1,
                 WmiGuidObjectDirectory);

    WmipAssert(hr == S_OK);

    hr = StringCchCatW(GuidObjectName,
                WmiGuidObjectNameLength+1,
                GuidChar);    

    WmipAssert(hr == S_OK);

    RtlInitUnicodeString(GuidString, GuidObjectName);
    
    memset(ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes->Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes->ObjectName = GuidString;
    
    return(ERROR_SUCCESS);    
}

///////
////// Duplicated from chunkimp.h
//////

ULONG EtwpCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    )
{
    HANDLE Handle;
    ULONG Status;

    Status = EtwpOpenKernelGuid(Guid,
                                DesiredAccess,
                                &Handle,
                                IOCTL_WMI_OPEN_GUID
                );

    if (Status == ERROR_SUCCESS)
    {
        EtwpCloseHandle(Handle);
    }

    return(Status);
}


///////
////// Duplicated from chunkimp.h
//////

ULONG EtwpOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    UNICODE_STRING GuidString;
    ULONG ReturnSize;
    ULONG Status;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;

    Status = EtwpBuildGuidObjectAttributes(Guid,
                                           &ObjectAttributes,
                                           &GuidString,
                                           GuidObjectName);
                                       
    if (Status == ERROR_SUCCESS)
    {
        WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;
        WmiOpenGuidBlock.DesiredAccess = DesiredAccess;

        Status = EtwpSendWmiKMRequest(NULL, 
                                      Ioctl,
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      &ReturnSize,
                      NULL);

        if (Status == ERROR_SUCCESS)
        {
            *Handle = WmiOpenGuidBlock.Handle.Handle;
        } else {
            *Handle = NULL;
        }
    }
    return(Status);
}

DWORD
EtwpExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    DWORD iSize;

    if ( nSize > (MAXUSHORT >> 1)-2 ) {
        iSize = (MAXUSHORT >> 1)-2;
        }
    else {
        iSize = nSize;
        }

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(iSize * sizeof( WCHAR ));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( NULL,
                                            &Source,
                                            &Destination,
                                            &Length
                                          );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length / sizeof( WCHAR ) );
        }
    else {
        EtwpBaseSetLastNTError( Status );
        return( 0 );
        }
}

HANDLE
EtwpBaseFindFirstDevice(
    PCUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    This function is called when find first file encounters a device
    name. This function returns a successful psuedo file handle and
    fills in the find file data with all zeros and the devic name.

Arguments:

    FileName - Supplies the device name of the file to find.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    Always returns a static find file handle value of
    BASE_FIND_FIRST_DEVICE_HANDLE

--*/

{
    RtlZeroMemory(lpFindFileData,sizeof(*lpFindFileData));
    lpFindFileData->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;

    //
    // Check for size just to be safe
    // 

    if (FileName->MaximumLength <= MAX_PATH * sizeof(WCHAR)) {

        RtlMoveMemory(
            &lpFindFileData->cFileName[0],
            FileName->Buffer,
            FileName->MaximumLength
            );
    } 
    else {
#if DBG
        EtwpAssert(FALSE);
#endif
        EtwpSetLastError(ERROR_BUFFER_OVERFLOW);
        return INVALID_HANDLE_VALUE;
    }
    return BASE_FIND_FIRST_DEVICE_HANDLE;
}


PFINDFILE_HANDLE
EtwpBasepInitializeFindFileHandle(
    IN HANDLE DirectoryHandle
    )
{
    PFINDFILE_HANDLE FindFileHandle;

    FindFileHandle = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( FIND_TAG ), sizeof(*FindFileHandle));
    if ( FindFileHandle ) {
        FindFileHandle->DirectoryHandle = DirectoryHandle;
        FindFileHandle->FindBufferBase = NULL;
        FindFileHandle->FindBufferNext = NULL;
        FindFileHandle->FindBufferLength = 0;
        FindFileHandle->FindBufferValidLength = 0;
        if ( !NT_SUCCESS(RtlInitializeCriticalSection(&FindFileHandle->FindBufferLock)) ){
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            FindFileHandle = NULL;
            }
        }
    return FindFileHandle;
}

HANDLE
EtwpFindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFileEx.

    This API is provided to open a find file handle and return
    information about the first file whose name matchs the specified
    pattern.  If the fSearchOp is FindExSearchNameMatch, then that is
    the extent of the filtering, and lpSearchFilter MUST be NULL.
    Otherwise, additional subfiltering is done depending on this value.

        FindExSearchLimitToDirectories - If this search op is specified,
            then lpSearchFilter MUST be NULL.  For each file that
            matches the specified filename, and that is a directory, and
            entry for that file is returned.

            If the underlying file/io system does not support this type
            of filtering, the API will fail with ERROR_NOT_SUPPORTED,
            and the application will have to perform its own filtering
            by calling this API with FindExSearchNameMatch.

        FindExSearchLimitToDevices - If this search op is specified, the
            lpFileName MUST be *, and FIND_FIRST_EX_CASE_SENSITIVE
            must NOT be specified.  Only device names are returned.
            Device names are generally accessible through
            \\.\name-of-device naming.

    The data returned by this API is dependent on the fInfoLevelId.

        FindExInfoStandard - The lpFindFileData pointer is the standard
            LPWIN32_FIND_DATA structure.

        At this time, no other information levels are supported


    Once established, the find file handle can be used to search for
    other files that match the same pattern with the same filtering
    being performed.  When the find file handle is no longer needed, it
    should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFileEx.

    This API is a complete superset of existing FindFirstFile. FindFirstFile
    could be coded as the following macro:

#define FindFirstFile(a,b)
    FindFirstFileEx((a),FindExInfoStandard,(b),FindExSearchNameMatch,NULL,0);


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    fInfoLevelId - Supplies the info level of the returned data.

    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

    fSearchOp - Specified the type of filtering to perform above and
        beyond simple wildcard matching.

    lpSearchFilter - If the specified fSearchOp needs structured search
        information, this pointer points to the search criteria.  At
        this point in time, both search ops do not require extended
        search information, so this pointer is NULL.

    dwAdditionalFlags - Supplies additional flag values that control the
        search.  A flag value of FIND_FIRST_EX_CASE_SENSITIVE can be
        used to cause case sensitive searches to occur.  The default is
        case insensitive.

Return Value:

    Not -1 - Returns a find first handle that can be used in a
        subsequent call to FindNextFileEx or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

#define FIND_FIRST_EX_INVALID_FLAGS (~FIND_FIRST_EX_CASE_SENSITIVE)
    HANDLE hFindFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
        } Buffer;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    PFINDFILE_HANDLE FindFileHandle;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    BOOLEAN StrippedTrailingSlash;

    //
    // check parameters
    //

    if ( fInfoLevelId >= FindExInfoMaxInfoLevel ||
         fSearchOp >= FindExSearchLimitToDevices ||
        dwAdditionalFlags & FIND_FIRST_EX_INVALID_FLAGS ) {
        EtwpSetLastError(fSearchOp == FindExSearchLimitToDevices ? ERROR_NOT_SUPPORTED : ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
        }

    FindFileData = (LPWIN32_FIND_DATAW)lpFindFileData;

    RtlInitUnicodeString(&UnicodeInput,lpFileName);

    //
    // Bogus code to workaround ~* problem
    //

    if ( UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == (WCHAR)'.' ) {
        EndsInDot = TRUE;
        }
    else {
        EndsInDot = FALSE;
        }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        EtwpSetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
    } else {
        FileName.Length = 0;
        }

    FileName.MaximumLength = FileName.Length;
    if ( RelativeName.RelativeName.Length &&
         RelativeName.RelativeName.Buffer != FileName.Buffer ) {

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)RelativeName.RelativeName.Buffer);
            PathName.MaximumLength = PathName.Length;
            PathName.Buffer = RelativeName.RelativeName.Buffer;
            }

        }
    else {
        RelativeName.ContainingDirectory = NULL;

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
            PathName.MaximumLength = PathName.Length;
            }
        }
    if ( PathName.Buffer[(PathName.Length>>1)-2] != (WCHAR)':' &&
         PathName.Buffer[(PathName.Length>>1)-1] != (WCHAR)'\\'   ) {

        PathName.Length -= sizeof(UNICODE_NULL);
        StrippedTrailingSlash = TRUE;
        }
    else {
        StrippedTrailingSlash = FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        (dwAdditionalFlags & FIND_FIRST_EX_CASE_SENSITIVE) ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hFindFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( (Status == STATUS_INVALID_PARAMETER ||
          Status == STATUS_NOT_A_DIRECTORY) && StrippedTrailingSlash ) {
        //
        // open of a pnp style path failed, so try putting back the trailing slash
        //
        PathName.Length += sizeof(UNICODE_NULL);
        Status = NtOpenFile(
                    &hFindFile,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );
        PathName.Length -= sizeof(UNICODE_NULL);
        }

    if ( !NT_SUCCESS(Status) ) {
        ULONG DeviceNameData;
        UNICODE_STRING DeviceName;

        RtlReleaseRelativeName(&RelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

        //
        // The full path does not refer to a directory. This could
        // be a device. Check for a device name.
        //

        if ( DeviceNameData = RtlIsDosDeviceName_U(UnicodeInput.Buffer) ) {
            DeviceName.Length = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.MaximumLength = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.Buffer = (PWSTR)
                ((PUCHAR)UnicodeInput.Buffer + (DeviceNameData >> 16));
            return EtwpBaseFindFirstDevice(&DeviceName,FindFileData);
            }

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        EtwpBaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // Get an entry
    //

    //
    // If there is no file part, but we are not looking at a device,
    // then bail.
    //

    if ( !FileName.Length ) {
        RtlReleaseRelativeName(&RelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        NtClose(hFindFile);
        EtwpSetLastError(ERROR_FILE_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    DirectoryInfo = &Buffer.DirInfo;

    //
    //  Special case *.* to * since it is so common.  Otherwise transmogrify
    //  the input name according to the following rules:
    //
    //  - Change all ? to DOS_QM
    //  - Change all . followed by ? or * to DOS_DOT
    //  - Change all * followed by a . into DOS_STAR
    //
    //  These transmogrifications are all done in place.
    //

    if ( (FileName.Length == 6) &&
         (RtlCompareMemory(FileName.Buffer, L"*.*", 6) == 6) ) {

        FileName.Length = 2;

    } else {

        ULONG Index;
        WCHAR *NameChar;

        for ( Index = 0, NameChar = FileName.Buffer;
              Index < FileName.Length/sizeof(WCHAR);
              Index += 1, NameChar += 1) {

            if (Index && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar - 1) = DOS_STAR;
            }

            if ((*NameChar == L'?') || (*NameChar == L'*')) {

                if (*NameChar == L'?') { *NameChar = DOS_QM; }

                if (Index && *(NameChar-1) == L'.') { *(NameChar-1) = DOS_DOT; }
            }
        }

        if (EndsInDot && *(NameChar - 1) == L'*') { *(NameChar-1) = DOS_STAR; }
    }

    Status = NtQueryDirectoryFile(
                hFindFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                DirectoryInfo,
                sizeof(Buffer),
                FileBothDirectoryInformation,
                TRUE,
                &FileName,
                FALSE
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        NtClose(hFindFile);
        EtwpBaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( FindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( FindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    //
    // For NTFS reparse points we return the reparse point data tag in dwReserved0.
    //

    if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        FindFileData->dwReserved0 = DirectoryInfo->EaSize;
        }

    FindFileHandle = EtwpBasepInitializeFindFileHandle(hFindFile);
    if ( !FindFileHandle ) {
        NtClose(hFindFile);
        EtwpSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
        }

    return (HANDLE)FindFileHandle;

}

HANDLE
EtwpFindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFile.

    This API is provided to open a find file handle and return
    information about the first file whose name match the specified
    pattern.  Once established, the find file handle can be used to
    search for other files that match the same pattern.  When the find
    file handle is no longer needed, it should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Eh), and OS/2's
    DosFindFirst.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file:

        WIN32_FIND_DATA Structure:

        DWORD dwFileAttributes - Returns the file attributes of the found
            file.

        FILETIME ftCreationTime - Returns the time that the file was created.
            A value of 0,0 specifies that the file system containing the
            file does not support this time field.

        FILETIME ftLastAccessTime - Returns the time that the file was last
            accessed.  A value of 0,0 specifies that the file system
            containing the file does not support this time field.

        FILETIME ftLastWriteTime - Returns the time that the file was last
            written.  A file systems support this time field.

        DWORD nFileSizeHigh - Returns the high order 32 bits of the
            file's size.

        DWORD nFileSizeLow - Returns the low order 32-bits of the file's
            size in bytes.

        UCHAR cFileName[MAX_PATH] - Returns the null terminated name of
            the file.

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return EtwpFindFirstFileExW(
                lpFileName,
                FindExInfoStandard,
                lpFindFileData,
                FindExSearchNameMatch,
                NULL,
                0
                );
}


BOOL
EtwpFindClose(
    HANDLE hFindFile
    )

/*++

Routine Description:

    A find file context created by FindFirstFile can be closed using
    FindClose.

    This API is used to inform the system that a find file handle
    created by FindFirstFile is no longer needed.  On systems that
    maintain internal state for each find file context, this API informs
    the system that this state no longer needs to be maintained.

    Once this call has been made, the hFindFile may not be used in a
    subsequent call to either FindNextFile or FindClose.

    This API has no DOS counterpart, but is similar to OS/2's
    DosFindClose.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile that is no longer needed.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PFINDFILE_HANDLE FindFileHandle;
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;

    if ( hFindFile == BASE_FIND_FIRST_DEVICE_HANDLE ) {
        return TRUE;
        }

    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        EtwpSetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    try {

        FindFileHandle = (PFINDFILE_HANDLE)hFindFile;
        RtlEnterCriticalSection(&FindFileHandle->FindBufferLock);
        DirectoryHandle = FindFileHandle->DirectoryHandle;
        FindBufferBase = FindFileHandle->FindBufferBase;
        FindFileHandle->DirectoryHandle = INVALID_HANDLE_VALUE;
        FindFileHandle->FindBufferBase = NULL;
        RtlLeaveCriticalSection(&FindFileHandle->FindBufferLock);

        Status = NtClose(DirectoryHandle);
        if ( NT_SUCCESS(Status) ) {
            if (FindBufferBase) {
                RtlFreeHeap(RtlProcessHeap(), 0,FindBufferBase);
                }
            RtlDeleteCriticalSection(&FindFileHandle->FindBufferLock);
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            return TRUE;
            }
        else {
            EtwpBaseSetLastNTError(Status);
            return FALSE;
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        EtwpBaseSetLastNTError(GetExceptionCode());
        return FALSE;
        }
    return FALSE;
}


UINT
APIENTRY
EtwpGetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system Windows directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in wchars) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    UNICODE_STRING tmpBaseWindowsDirectory;

    PBASE_STATIC_SERVER_DATA tmpBaseStaticServerData = BASE_SHARED_SERVER_DATA;
    BASE_SERVER_STR_TO_LOCAL_STR(&tmpBaseWindowsDirectory, &tmpBaseStaticServerData->WindowsDirectory);

    if ( uSize*2 < tmpBaseWindowsDirectory.MaximumLength ) {
        return tmpBaseWindowsDirectory.MaximumLength/2;
        }
    RtlMoveMemory(
        lpBuffer,
        tmpBaseWindowsDirectory.Buffer,
        tmpBaseWindowsDirectory.Length
        );
    lpBuffer[(tmpBaseWindowsDirectory.Length>>1)] = UNICODE_NULL;
    return tmpBaseWindowsDirectory.Length/2;
}


#define ENUM_MAX_UILANG_SIZE 4    // max size (wchar) for UI langguage id in registry

#define NLS_CALL_ENUMPROC_BREAK_4( Locale,                                 \
                                   lpNlsEnumProc,                          \
                                   dwFlags,                                \
                                   pUnicodeBuffer,                         \
                                   lParam)                                 \
{                                                                          \
    if (((*((NLS_ENUMPROC4)lpNlsEnumProc))(pUnicodeBuffer,                 \
                          lParam)) != TRUE)                                \
    {                                                                      \
        break;                                                             \
    }                                                                      \
}


#define NLS_CALL_ENUMPROC_TRUE_4( Locale,                                  \
                                  lpNlsEnumProc,                           \
                                  dwFlags,                                 \
                                  pUnicodeBuffer,                          \
                                  lParam)                                  \
{                                                                          \
    if (((*((NLS_ENUMPROC4)lpNlsEnumProc))(pUnicodeBuffer,             \
                          lParam)) != TRUE)                            \
    {                                                                  \
        return (TRUE);                                                 \
    }                                                                  \
}

LANGID                gSystemInstallLang;   // system's original install language

LPWSTR FASTCALL EtwpNlsStrCpyW(
    LPWSTR pwszDest,
    LPCWSTR pwszSrc)
{
    LPWSTR pwszRet = pwszDest;         // ptr to beginning of string

    loop:
        if (!(pwszDest[0x0] = pwszSrc[0x0]))   goto done;
        if (!(pwszDest[0x1] = pwszSrc[0x1]))   goto done;
        if (!(pwszDest[0x2] = pwszSrc[0x2]))   goto done;
        if (!(pwszDest[0x3] = pwszSrc[0x3]))   goto done;
        if (!(pwszDest[0x4] = pwszSrc[0x4]))   goto done;
        if (!(pwszDest[0x5] = pwszSrc[0x5]))   goto done;
        if (!(pwszDest[0x6] = pwszSrc[0x6]))   goto done;
        if (!(pwszDest[0x7] = pwszSrc[0x7]))   goto done;
        if (!(pwszDest[0x8] = pwszSrc[0x8]))   goto done;
        if (!(pwszDest[0x9] = pwszSrc[0x9]))   goto done;
        if (!(pwszDest[0xA] = pwszSrc[0xA]))   goto done;
        if (!(pwszDest[0xB] = pwszSrc[0xB]))   goto done;
        if (!(pwszDest[0xC] = pwszSrc[0xC]))   goto done;
        if (!(pwszDest[0xD] = pwszSrc[0xD]))   goto done;
        if (!(pwszDest[0xE] = pwszSrc[0xE]))   goto done;
        if (!(pwszDest[0xF] = pwszSrc[0xF]))   goto done;

        pwszDest+= 0x10;
        pwszSrc+= 0x10;

        goto loop;

    done:
        return (pwszRet);
}

ULONG EtwpNlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size)
{
    UNICODE_STRING ObString;                // value string
    UINT ctr;                               // loop counter
    LPWSTR pBufPtr;                         // ptr to result buffer
    WCHAR pTmpBuf[MAX_PATH_LEN];            // ptr to temp buffer
    ULONG rc = 0L;                          // return code

    //
    // Just to be safe we will check to see if the Size if less than 
    // the sizeof buffer we use on the stack. 
    //
    if (Size > MAX_PATH_LEN) {
        EtwpSetLastError(ERROR_BUFFER_OVERFLOW);
#if DBG
        //
        // If we hit this assert then, someone made a code change that
        // busted the assumptions made in this routine. Either this routine 
        // or the caller needs to be modified. 
        // 
        EtwpAssert(FALSE);
#endif
        
        return 0;
    }

    //
    //  Set up the Unicode string structure.
    //
    ObString.Length = (USHORT)(Size * sizeof(WCHAR));
    ObString.MaximumLength = (USHORT)(Size * sizeof(WCHAR));
    ObString.Buffer = pTmpBuf;

    //
    //  Get the value as a string.
    //
    if (rc = RtlIntegerToUnicodeString(Value, Base, &ObString))
    {
        return (rc);
    }

    //
    //  Pad the string with the appropriate number of zeros.
    //
    pBufPtr = pResultBuf;
    for (ctr = GET_WC_COUNT(ObString.Length);
         ctr < Padding;
         ctr++, pBufPtr++)
    {
        *pBufPtr = NLS_CHAR_ZERO;
    }
    EtwpNlsStrCpyW(pBufPtr, ObString.Buffer);

    //
    //  Return success.
    //
    return (NO_ERROR);
}

LANGID WINAPI EtwpGetSystemDefaultUILanguage()
{
    //
    //  Get the original install language and return it.
    //
    if (gSystemInstallLang == 0)
    {
        if (NtQueryInstallUILanguage(&gSystemInstallLang) != STATUS_SUCCESS)
        {
            gSystemInstallLang = 0;
            return (NLS_DEFAULT_UILANG);
        }
    }

    return (gSystemInstallLang);
}


BOOL EtwpInternal_EnumUILanguages(
    NLS_ENUMPROC lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull = NULL;
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];

    LANGID LangID;                     // language id
    WCHAR szLang[MAX_PATH];            // language id string
    HANDLE hKey = NULL;                // handle to muilang key
    ULONG Index;                       // index for enumeration
    ULONG ResultLength;                // # bytes written
    WCHAR wch;                         // first char of name
    LPWSTR pName;                      // ptr to name string from registry
    ULONG NameLen;                     // length of name string
    ULONG rc = 0L;                     // return code


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpUILanguageEnumProc == NULL)
    {
        EtwpSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags must be 0
    //
    if (dwFlags != 0)
    {
        EtwpSetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Call the appropriate callback function with the user's UI
    //  language.
    //
    LangID = EtwpGetSystemDefaultUILanguage();
    if (EtwpNlsConvertIntegerToString(LangID, 16, 4, szLang, MAX_PATH) == NO_ERROR)
    {
        NLS_CALL_ENUMPROC_TRUE_4( gSystemLocale,
                                  lpUILanguageEnumProc,
                                  dwFlags,
                                  szLang,
                                  lParam);
    }
    else
    {
        szLang[0] = 0;
    }

    //
    //  Open the MUILanguages registry key.  It is acceptable if the key
    //  does not exist, so return TRUE as there are no items to enumerate.
    //
    if(hKey == NULL )
    {
        NTSTATUS st;
        PWCHAR Buffer;
        HRESULT hr;

        Buffer = EtwpAlloc(DEFAULT_ALLOC_SIZE);
        
        if (Buffer == NULL) {
#ifdef DBG 
            EtwpDebugPrint(("WMI: Failed to Allcate memory for Buffer in EtwpInternal_EnumUILanguages \n"));
#endif 
            EtwpSetLastError(STATUS_NO_MEMORY);
            return (FALSE);
        }

        hr = StringCbPrintfW(Buffer, DEFAULT_ALLOC_SIZE, L"%ws\\%ws", NLS_HKLM_SYSTEM, NLS_MUILANG_KEY);

        WmipAssert(hr == S_OK);

        st = EtwpRegOpenKey(Buffer, &hKey);

        EtwpFree(Buffer);

        if(!NT_SUCCESS(st))
        {
            //
            // If NLS key doesn't exist then it is not a failure as
            // this means we just don't have any new languages
            //
            return TRUE;
        }
    }

    //
    //  Loop through the MUILanguage ids in the registry, call the
    //  function pointer for each.
    //
    //  End loop if either FALSE is returned from the callback function
    //  or the end of the list is reached.
    //
    Index = 0;
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
    rc = NtEnumerateValueKey( hKey,
                              Index,
                              KeyValueFullInformation,
                              pKeyValueFull,
                              MAX_KEY_VALUE_FULLINFO,
                              &ResultLength );

    while (rc != STATUS_NO_MORE_ENTRIES)
    {
        if (!NT_SUCCESS(rc))
        {
            //
            //  If we get a different error, then the registry
            //  is corrupt.  Just return FALSE.
            //
            KdPrint(("NLSAPI: MUI Languages Enumeration Error - registry corrupt. - %lx.\n",
                     rc));
            EtwpSetLastError(ERROR_BADDB);
            return (FALSE);
        }

        //
        //  Skip over any entry that does not have data associated with it.
        //
        pName = pKeyValueFull->Name;
        wch = *pName;
        NameLen = pKeyValueFull->NameLength / sizeof(WCHAR);
        if ( (NameLen == ENUM_MAX_UILANG_SIZE) &&
             (((wch >= NLS_CHAR_ZERO) && (wch <= NLS_CHAR_NINE)) ||
              (((wch | 0x0020) >= L'a') && ((wch | 0x0020) <= L'f'))) &&
              (pKeyValueFull->DataLength > 2) )
        {
            //
            //  Make sure the UI language is zero terminated.
            //
            pName[NameLen] = 0;

            //
            //  Make sure it's not the same as the user UI language
            //  that we already enumerated.
            //
            if (wcscmp(szLang, pName) != 0)
            {
                //
                //  Call the appropriate callback function.
                //
                NLS_CALL_ENUMPROC_BREAK_4( gSystemLocale,
                                           lpUILanguageEnumProc,
                                           dwFlags,
                                           pName,
                                           lParam );
            }
        }

        //
        //  Increment enumeration index value and get the next enumeration.
        //
        Index++;
        RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
        rc = NtEnumerateValueKey( hKey,
                                  Index,
                                  KeyValueFullInformation,
                                  pKeyValueFull,
                                  MAX_KEY_VALUE_FULLINFO,
                                  &ResultLength );
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return success.
    //
    return (TRUE);
}

BOOL EtwpEnumUILanguages(
    UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (EtwpInternal_EnumUILanguages( (NLS_ENUMPROC)lpUILanguageEnumProc,
                                      dwFlags,
                                      lParam));
}

ULONG EtwpAnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    ){

    UNICODE_STRING DestinationString;
    ANSI_STRING SourceString;
    NTSTATUS Status;
    BOOLEAN AllocateString;
    ULONG UnicodeLength;

    //
    // If output is null then return error as we don't have 
    // any place to put output string
    //

    if(ppszW==NULL){

        return(STATUS_INVALID_PARAMETER_2);
    }

    //
    // If input is null then just return the same.
    //

    if (pszA == NULL)
    {
        *ppszW = NULL;
        return(ERROR_SUCCESS);
    }

    //
    // We ASSUME that if *ppszW!=NULL then we have sufficient
    // amount of memory to copy
    //

    AllocateString = ((*ppszW) == NULL );

    RtlInitAnsiString(&SourceString,(PCHAR)pszA);

    UnicodeLength = RtlAnsiStringToUnicodeSize(&SourceString);

    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_1;
        }

    DestinationString.Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    DestinationString.MaximumLength = (USHORT)UnicodeLength;
    DestinationString.Buffer = EtwpAlloc(UnicodeLength);
    if ( !DestinationString.Buffer ) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlAnsiStringToUnicodeString( &DestinationString, &SourceString, FALSE );

    if( NT_SUCCESS(Status)) {
        if(AllocateString){
            *ppszW = DestinationString.Buffer;
        } else {
            memcpy((*ppszW),DestinationString.Buffer,UnicodeLength);
            EtwpFree(DestinationString.Buffer);
        }
    } else {
        EtwpFree(DestinationString.Buffer);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\proppage\wmiprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmiprop.h
//
//--------------------------------------------------------------------------

#ifndef ___wmiprop_h___
#define ___wmiprop_h___

typedef TCHAR *PTCHAR;

//
// Datablock description
//

//
// Holds a list of valid values for an enumeration type
//
typedef struct _ENUMERATIONITEM
{
    ULONG64 Value;
    PTCHAR Text;
    ULONG Reserved;
} ENUMERATIONITEM, *PENUMERATIONITEM;

typedef struct _ENUMERATIONINFO
{
    ULONG Count;
    ULONG Reserved;
    ENUMERATIONITEM List[1];
} ENUMERATIONINFO, *PENUMERATIONINFO;

//
// Holds a range of values
typedef struct
{
    ULONG64 Minimum;
    ULONG64 Maximum;
} RANGEINFO, *PRANGEINFO;

//
// Holds a list of ranges of values
//
typedef struct
{
    ULONG Count;
    RANGEINFO Ranges[1];
} RANGELISTINFO, *PRANGELISTINFO;

typedef enum VALIDATIONFUNC
{
    WmiStringValidation,
    WmiDateTimeValidation,
    WmiRangeValidation,
    WmiValueMapValidation,
    WmiEmbeddedValidation
} VALIDATIONFUNC, *PVALIDATIONFUNC;
#define WmiMaximumValidation WmiEmbeddedValidation

struct _DATA_BLOCK_DESCRIPTION;

typedef struct _DATA_ITEM_DESCRIPTION
{
    // CONSIDER: Make Name a BSTR
    PTCHAR Name;
    PTCHAR DisplayName;
    PTCHAR Description;
    CIMTYPE DataType;
    ULONG DataSize;
    VALIDATIONFUNC ValidationFunc;
    union
    {
        //
        // Used for enumeration data types
        //
        PENUMERATIONINFO EnumerationInfo;
    
        //
        // Used for a range of numbers
        PRANGELISTINFO RangeListInfo;    

        //
	// Used for embedded classes
        struct _DATA_BLOCK_DESCRIPTION *DataBlockDesc;
    };
    
    //
    // Number of elements in array if this item is an array
    //
    ULONG ArrayElementCount;
	ULONG CurrentArrayIndex;
    

	//
	// Flags about property
	//
    ULONG IsReadOnly : 1;
    ULONG IsSignedValue : 1;
    ULONG DisplayInHex : 1;
    ULONG IsFixedArray : 1;
    ULONG IsVariableArray : 1;
	
    //
    // Actual value of the property
    //
    union
    {
        //
		// storage for non array
		//
        UCHAR Data;

        BOOLEAN boolval;
        CHAR sint8;
        SHORT sint16;
        LONG sint32;
        LONG64 sint64;
        UCHAR uint8;
        USHORT uint16;
        ULONG uint32;
        ULONG64 uint64;
        PTCHAR String;
        PTCHAR DateTime;
        IWbemClassObject *pIWbemClassObject;
	
		//
		// pointer for storage to arrays
		//
        PVOID ArrayPtr;

        BOOLEAN *boolArray;
        CHAR *sint8Array;
        SHORT *sint16Array;
        LONG *sint32Array;
        LONG64 *sint64Array;
        UCHAR *uint8Array;
        USHORT *uint16Array;
        ULONG *uint32Array;
        ULONG64 *uint64Array;
        PTCHAR *StringArray;
        PTCHAR *DateTimeArray;
		IWbemClassObject **pIWbemClassObjectArray;
    };
           
} DATA_ITEM_DESCRIPTION, *PDATA_ITEM_DESCRIPTION;

typedef struct _DATA_BLOCK_DESCRIPTION
{
    PTCHAR Name;
    PTCHAR DisplayName;
    PTCHAR Description;
    struct _DATA_BLOCK_DESCRIPTION *ParentDataBlockDesc;
	IWbemClassObject *pInstance;
    ULONG DataItemCount;
	ULONG CurrentDataItem;
	BOOLEAN UpdateClass;
    DATA_ITEM_DESCRIPTION DataItems[1];    
} DATA_BLOCK_DESCRIPTION, *PDATA_BLOCK_DESCRIPTION;

BOOLEAN ValidateEnumeration(
    PDATA_ITEM_DESCRIPTION DataItem,
    PTCHAR Value
    );

BOOLEAN ValidateRangeList(
    PDATA_ITEM_DESCRIPTION DataItem,
    ULONG64 Value
    );

BOOLEAN ValidateDateTime(
    PDATA_ITEM_DESCRIPTION DataItem,
    PTCHAR DateTime
    );


typedef struct
{
    PTCHAR MachineName;
    PTCHAR RelPath;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    IWbemServices *pIWbemServices;
} CONFIGCLASS, *PCONFIGCLASS;


//
// PageInfo and Prototypes
//

typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    HKEY             hKeyDev;

    CONFIGCLASS ConfigClass;
} PAGE_INFO, * PPAGE_INFO;


//
// Debug support
//
#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define DEBUG_BUFFER_LENGTH 256

#define DebugPrint(x) WmiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );




//
// function prototype
//

void WmiCleanDataItemDescData(
    PDATA_ITEM_DESCRIPTION DataItemDesc
    );

void WmiHideAllControls(
    HWND hDlg,
    BOOLEAN HideEmbeddedControls,
    BOOLEAN HideArrayControls						
    );


BOOLEAN WmiValidateNumber(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

BOOLEAN WmiValidateDateTime(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

BOOLEAN WmiValidateRange(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

PPAGE_INFO
WmiCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                  IN PSP_DEVINFO_DATA deviceInfoData);

void
WmiDestroyPageInfo(PPAGE_INFO * ppPageInfo);

//
// Function Prototypes
//
BOOL APIENTRY
WmiPropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam);

HPROPSHEETPAGE
WmiCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi);

UINT CALLBACK
WmiDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp);

INT_PTR APIENTRY
WmiDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam);

BOOLEAN
WmiApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg);

void
WmiUpdate (PPAGE_INFO ppi,
           HWND       hDlg);

BOOL
WmiContextMenu(HWND HwndControl,
                           WORD Xpos,
                           WORD Ypos);

void
WmiHelp(HWND       ParentHwnd,
                LPHELPINFO HelpInfo);

#endif // ___Wmiprop_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\proppage\wmiprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmiprop.c
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <prsht.h>
#include <ole2.h>

extern "C" {
#include <commdlg.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
}

#include <wbemidl.h>

#include "wmiprop.h"
#include "resource.h"


HINSTANCE g_hInstance;



#if DBG
#define DEBUG_HEAP 1

#define WmiAssert(x) if (! (x) ) { \
    DebugPrint((1, "WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    DebugBreak(); }
#else
#define WmiAssert(x)
#endif

#if DEBUG_HEAP
#undef LocalAlloc
#undef LocalFree
#define LocalAlloc(lptr, size) DebugAlloc(size)
#define LocalFree(p) DebugFree(p)

PVOID WmiPrivateHeap;

PVOID DebugAlloc(ULONG size)
{
    PVOID p = NULL;
    
    if (WmiPrivateHeap == NULL)
    {
        WmiPrivateHeap = RtlCreateHeap(HEAP_GROWABLE | 
                                      HEAP_TAIL_CHECKING_ENABLED |
                                      HEAP_FREE_CHECKING_ENABLED | 
                                      HEAP_DISABLE_COALESCE_ON_FREE,
                                      NULL,
                                      0,
                                      0,
                                      NULL,
                                      NULL);
    }
    
    if (WmiPrivateHeap != NULL)
    {
        p = RtlAllocateHeap(WmiPrivateHeap, 0, size);
        if (p != NULL)
        {
            memset(p, 0, size);
        }
    }
    return(p);
}

void DebugFree(PVOID p)
{
    RtlFreeHeap(WmiPrivateHeap, 0, p);
}
#endif

#if DBG
PCHAR WmiGuidToString(
    PCHAR s,
    LPGUID piid
    )
{
    GUID XGuid = *piid;

    sprintf(s, "%x-%x-%x-%x%x%x%x%x%x%x%x",
               XGuid.Data1, XGuid.Data2,
               XGuid.Data3,
               XGuid.Data4[0], XGuid.Data4[1],
               XGuid.Data4[2], XGuid.Data4[3],
               XGuid.Data4[4], XGuid.Data4[5],
               XGuid.Data4[6], XGuid.Data4[7]);

    return(s);
}
#endif

TCHAR *WmiDuplicateString(
    TCHAR *String
    )
{
    ULONG Len;
    PTCHAR Copy;

    Len = _tcslen(String);
    Copy = (PTCHAR)LocalAlloc(LPTR,
                              (Len+1) * sizeof(TCHAR));
    if (Copy != NULL)
    {
        _tcscpy(Copy, String);
    }
    return(Copy);
}

BOOLEAN WmiGetDataBlockDesc(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    OUT PDATA_BLOCK_DESCRIPTION *DBD,
    IN PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc,
    IN BOOLEAN IsParentReadOnly
    );

BOOLEAN WmiRefreshDataBlockFromWbem(
    IWbemClassObject *pIWbemClassObject,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    );

BOOLEAN WmiRefreshWbemFromDataBlock(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN BOOLEAN IsEmbeddedClass
    );


BOOLEAN WmiBstrToTchar(
    OUT PTCHAR *TString,
    IN BSTR BString
    )
/*+++

Routine Description:

    This routine will convert a BSTR into a TCHAR *
        
Arguments:

    BString is the BSTR to convert from
        
    *TString returns with a pointer to a string containing the contents of
        the BSTR. It should be freed with LocalFree.

Return Value:

    TRUE if successful else FALSE

---*/
{
    ULONG SizeNeeded;
    BOOLEAN ReturnStatus;
    
    WmiAssert(BString != NULL);
    WmiAssert(TString != NULL);
    
    SizeNeeded = (SysStringLen(BString)+1) * sizeof(TCHAR);
    *TString = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
    if (*TString != NULL)
    {
        _tcscpy(*TString, BString);
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiBstrToUlong64(
    OUT PULONG64 Number,
    IN BSTR BString
    )
/*+++

Routine Description:

    This routine will convert a BSTR into a ULONG64 number
        
Arguments:

    BString is the BSTR to convert from
        
    *Number returns with the value of the contents of BString converted to
        a number

Return Value:

    TRUE if successful else FALSE

---*/
{
    WmiAssert(BString != NULL);
    WmiAssert(Number != NULL);

    *Number = _ttoi64(BString);
    
    return(TRUE);
}

BOOLEAN WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
)
/*+++

Routine Description:

    This routine will information about the size and bounds of a single
    dimensional safe array.
        
Arguments:

    Array is the safe array
        
    *LBound returns with the lower bound of the array

    *UBound returns with the upper bound of the array
        
    *NumberElements returns with the number of elements in the array

Return Value:

    TRUE if successful else FALSE

---*/
{
    HRESULT hr;
    BOOLEAN ReturnStatus;

    WmiAssert(Array != NULL);
    WmiAssert(LBound != NULL);
    WmiAssert(UBound != NULL);
    WmiAssert(NumberElements != NULL);
    
    //
    // Only single dim arrays are supported
    //
    WmiAssert(SafeArrayGetDim(Array) == 1);
    
    hr = SafeArrayGetLBound(Array, 1, LBound);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = SafeArrayGetUBound(Array, 1, UBound);
        *NumberElements = (*UBound - *LBound) + 1;
        ReturnStatus = (hr == WBEM_S_NO_ERROR);
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}



BOOLEAN WmiConnectToWbem(
    PTCHAR MachineName,
    IWbemServices **pIWbemServices
    )
/*+++

Routine Description:

    This routine will establishes a connection to the WBEM service and
    saves the global IWbemServices interface

Arguments:

    MachineName is the name of the remote machine we should connect to.
    If NULL then we connect to the local machine.

Return Value:

    if this routine is successful then *pIWbemServices will have a valid
    IWbemServices pointer, if not then it is NULL.

---*/
{
    #define Namespace TEXT("root\\wmi")
    
    IWbemLocator *pIWbemLocator;
    DWORD hr;
    SCODE sc;
    BSTR s;
    BOOLEAN ReturnStatus = FALSE;
    PTCHAR NamespacePath;
    
    WmiAssert(pIWbemServices != NULL);

    if (MachineName == NULL)
    {
        NamespacePath = Namespace;
    } else {
        NamespacePath = (PTCHAR)LocalAlloc(LPTR,  (_tcslen(Namespace) +
                                           _tcslen(MachineName) +
                                           2) * sizeof(TCHAR) );
        if (NamespacePath != NULL)
        {
            _tcscpy(NamespacePath, MachineName);
            _tcscat(NamespacePath, TEXT("\\"));
            _tcscat(NamespacePath, Namespace);
        } else {
            DebugPrint((1, "WMIPROP: Could not alloc memory for NamespacePath\n"));
            return(FALSE);
        }
    }
    
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pIWbemLocator);
    if (hr == S_OK)
    {
        s = SysAllocString(NamespacePath);
        if (s != NULL)
        {
            *pIWbemServices = NULL;
            sc = pIWbemLocator->ConnectServer(s,
                            NULL,                           // Userid
                            NULL,                           // PW
                            NULL,                           // Locale
                            0,                              // flags
                            NULL,                           // Authority
                            NULL,                           // Context
                            pIWbemServices
                           );
                       
           SysFreeString(s);
                       
           if (sc != WBEM_NO_ERROR) 
           {
               *pIWbemServices = NULL;
           } else {
               //
               // Set security level to IMPERSONATE so that access
               // to wbem objects will be granted
               //
               sc = CoSetProxyBlanket( (IUnknown *)*pIWbemServices,
                                       RPC_C_AUTHN_WINNT,
                                       RPC_C_AUTHZ_NONE,
                                       NULL,
                                       RPC_C_AUTHN_LEVEL_CALL,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       NULL,
                                       0);
                   
               if (sc == S_OK)
               {
                   ReturnStatus = TRUE;
               } else {
                    (*pIWbemServices)->Release();
                   *pIWbemServices = NULL;
               }
           }
       
           pIWbemLocator->Release();
       } else {
           *pIWbemServices = NULL;
       }
    }
    
    if (MachineName != NULL)
    {       
        LocalFree(NamespacePath);
    }
    
    return(ReturnStatus);
}

#define IsWhiteSpace(c) ( (c == TEXT(' ')) || (c == TEXT('\t')) )

BOOLEAN WmiHexToUlong64(
    IN PTCHAR Text,
    OUT PULONG64 Number
    )
/*+++

Routine Description:

    This routine will convert a string with number in hex format into
    a ULONG64
        
Arguments:

    Text is the string
        
    *Number returns with the hex value for string

Return Value:

    TRUE if successful else FALSE

---*/
{
    ULONG64 Value;
    ULONG Count;

    WmiAssert(Text != NULL);
    WmiAssert(Number != NULL);
    
    Value = 0;
    Count = 0;
    while ((*Text != 0) && (! IsWhiteSpace(*Text)))
    {
        if (Count == 16)
        {
            return(FALSE);
        }
        
        if (*Text >= '0' && *Text <= '9')
            Value = (Value << 4) + *Text - '0';
        else if (*Text >= 'A' && *Text <= 'F')
            Value = (Value << 4) + *Text - 'A' + 10;
        else if (*Text >= 'a' && *Text <= 'f')
            Value = (Value << 4) + *Text - 'a' + 10;
        else
            return(FALSE);
        
        Text++;
    }

    *Number = Value;
    return(TRUE);
    
}

BOOLEAN WmiValidateRange(
    IN struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    OUT PULONG64 Number,
    IN PTCHAR Text
    )
/*+++

Routine Description:

    This routine will validate that the value proposed for the property is
    correct. It checks that the value is a well formed number and within
    the appropriate range
        
Arguments:

    DataItemDesc is the data item description for the property being validated

    *Number returns with the value as a ULONG64
        
    Text is the proposed value for the property. Note that hex values are
        required to be preceeded with 0x
        
Return Value:

    TRUE if Value is appropriate for the property

---*/
{
    #define HexMarkerText TEXT("0x")
        
    BOOLEAN ReturnStatus;
    PTCHAR s;
    PRANGELISTINFO RangeListInfo;
    PRANGEINFO RangeInfo;
    ULONG i;
   
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(Number != NULL);
    WmiAssert(Text != NULL);
    
    //
    // Skip over any leading spaces
    //
    s = Text;
    while (IsWhiteSpace(*s) && (*s != 0))
    {
        s++;
    }
    
    if (*s != 0)
    {
        //
        // If this is not an empty string then go parse the number
        //
        if (_tcsnicmp(s, 
                      HexMarkerText, 
                      (sizeof(HexMarkerText) / sizeof(TCHAR))-1) == 0)
        {
            //
            // this is a hex number (starts with 0x), advance string ptr
            // and setup to use hex digit validation
            //
            s += (sizeof(HexMarkerText) / sizeof(TCHAR)) - 1;
            ReturnStatus = WmiHexToUlong64(s, Number);
        } else {
            *Number = _ttoi64(s);
            ReturnStatus = TRUE;
            while ((*s != 0) && ReturnStatus)
            {
                ReturnStatus = (_istdigit(*s) != 0);
                s++;
            }    
        }

        //
        // Make sure that all characters are digits
        //
        if (ReturnStatus)
        {
            //
            // Now verify that the value is within the correct range
            //
            RangeListInfo = DataItemDesc->RangeListInfo;
            WmiAssert(RangeListInfo != NULL);
            
            ReturnStatus = FALSE;
            for (i = 0; (i < RangeListInfo->Count) && (! ReturnStatus); i++)
            {
                RangeInfo = &RangeListInfo->Ranges[i];
                ReturnStatus = ( (*Number >= RangeInfo->Minimum) &&
                                 (*Number <= RangeInfo->Maximum) );
            }
        }
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiValidateDateTime(
    IN struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    IN PTCHAR Value
    )
/*+++

Routine Description:

    This routine will validate that the value proposed for the property is
    correct. It will make sure that it is in a valid format for a 
    DATETIME with is of the form 19940525133015.000000-300
        
Arguments:

    DataItemDesc is the data item description for the property being validated

    Value is the proposed value for the property
        
Return Value:

    TRUE if Value is appropriate for the property

---*/
{
    #define DATETIME_LENGTH 25
        
    ULONG Length;
    BOOLEAN ReturnStatus;
    ULONG i;
    
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(Value != NULL);
    
    //
    // Validate that datetime is in correct format
    // TODO: Validate that the component parts of the DATETIME are correct,
    //       for example that the month is between 1 and 12, the correct
    //       month doesn't have too many days, The time is ok (not 30:11)
    //
    Length = _tcslen(Value);
    if (Length == DATETIME_LENGTH)
    {
        ReturnStatus = TRUE;
        for (i = 0; (i < 14) && ReturnStatus; i++)
        {
            ReturnStatus = (_istdigit(Value[i]) != 0);
        }
        
        if (ReturnStatus)
        {
            ReturnStatus = (Value[14] == TEXT('.')) &&
                           ((Value[21] == TEXT('-')) ||
                            (Value[21] == TEXT('+')) );
                        
            if (ReturnStatus)
            {
                for (i = 22; (i < DATETIME_LENGTH) && ReturnStatus; i++)
                {
                    ReturnStatus =  (_istdigit(Value[i]) != 0);
                }
            }
        }
    } else {
        ReturnStatus = FALSE;
    }
        
    return(ReturnStatus);
}

BOOLEAN WmiGet8bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 8 bit values can come back as signed or unsigned
    // or as 16 or 32 bit values
    //
    switch(Value->vt)
    {
        case VT_I1:
        {
            *((PCHAR)Result) = Value->cVal;
            break;
        }
                            
        case VT_UI1:
        {
            *((PUCHAR)Result) = Value->bVal;
            break;
        }
                            
        case VT_I2:
        {
            *((PCHAR)Result) = (CHAR)Value->iVal;
            break;
        }
                            
        case VT_I4:
        {
            *((PCHAR)Result) = (CHAR)Value->lVal;
            break;
        }
                                
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiGet16bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 16 bit values can come back as signed or unsigned
    // or as 32 bit values
    //
    switch(Value->vt)
    {
        case VT_I2:
        {
            *((PSHORT)Result) = Value->iVal;
            break;
        }
                            
        case VT_UI2:
        {
            *((PUSHORT)Result) = Value->uiVal;
            break;
        }
                            
        case VT_I4:
        {
            *((PSHORT)Result) = (SHORT)Value->lVal;
            break;
        }
                                
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiGet32bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 32 bit values can come back as signed or unsigned
    //
    switch (Value->vt)
    {
        case VT_UI4:
        {
            *((PULONG)Result) = Value->ulVal;
            break;
        }
            
        case VT_I4:
        {
            *((PLONG)Result) = Value->lVal;
            break;
        }
            
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    
    return(ReturnStatus);   
}

BOOLEAN WmiGetSint64FromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // 64 bit numbers are returned in a BSTR with the
    // number represented as a string. So we need to 
    // convert back to a 64bit number.
    //
    WmiAssert(Value->vt == VT_BSTR);
    *((PLONGLONG)Result) = _ttoi64(Value->bstrVal);
                        
    return(ReturnStatus);   
}

BOOLEAN WmiGetUint64FromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // 64 bit numbers are returned in a BSTR with the
    // number represented as a string. So we need to 
    // convert back to a 64bit number.
    //
    WmiAssert(Value->vt == VT_BSTR);
    *((PULONGLONG)Result) = _ttoi64(Value->bstrVal);
                        
    return(ReturnStatus);   
}

BOOLEAN WmiGetBooleanFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // BOOLEAN values are true or false
    //
    WmiAssert(Value->vt == VT_BOOL);
    *((PBOOLEAN)Result) = (Value->boolVal != 0) ? 
                                            1 : 0;

    return(ReturnStatus);
}

BOOLEAN WmiGetStringFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    WmiAssert( *((PTCHAR)Result) == NULL);
    ReturnStatus = WmiBstrToTchar((PTCHAR *)Result,
                                  Value->bstrVal);
    
    return(ReturnStatus);
}


BOOLEAN WmiGetObjectFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    IUnknown *punk;
    HRESULT hr;

    punk = Value->punkVal;
    hr = punk->QueryInterface(IID_IWbemClassObject,
                              (PVOID *)Result);
    
    return(hr == WBEM_S_NO_ERROR);
}

ULONG WmiGetElementSize(
    CIMTYPE CimType
    )
{
    ULONG Size;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            Size = sizeof(CHAR);
            break;
        }
        
        case CIM_CHAR16:
        case CIM_UINT16:
        case CIM_SINT16:
        {
            Size = sizeof(SHORT);
            break;
        }
        
        case CIM_UINT32:
        case CIM_SINT32:
        {
            Size = sizeof(LONG);
            break;
        }
        
        case CIM_SINT64:
        {
            Size = sizeof(LONGLONG);
            break;
        }
        
        case CIM_UINT64:
        {
            Size = sizeof(ULONGLONG);
            break;
        }
        
        case CIM_BOOLEAN:
        {
            Size = sizeof(BOOLEAN);
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            Size = sizeof(PTCHAR);
            break;
        }

        case CIM_OBJECT:
        {
            Size = sizeof(IWbemClassObject *);
            break;
        }
        
        //
        // Floating point values not supported
        //
        case CIM_REAL32:
        case CIM_REAL64:
            
        default:
        {
            Size = 0;
            break;
        }       
    }
    
    return(Size);
}


typedef BOOLEAN (*GETVALUEFROMVARIANTFUNC)(
    VARIANT *Value,
    PVOID Result
);


BOOLEAN WmiGetValueFunc(
    CIMTYPE CimType,
    GETVALUEFROMVARIANTFUNC *GetValueFunc
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            *GetValueFunc = WmiGet8bitFromVariant;
            break;
        }
        
        case CIM_CHAR16:
        case CIM_UINT16:
        case CIM_SINT16:
        {
            *GetValueFunc = WmiGet16bitFromVariant;
            break;
        }
        
        case CIM_UINT32:
        case CIM_SINT32:
        {
            *GetValueFunc = WmiGet32bitFromVariant;
            break;
        }
        
        case CIM_SINT64:
        {
            *GetValueFunc = WmiGetSint64FromVariant;
            break;
        }
        
        case CIM_UINT64:
        {
            *GetValueFunc = WmiGetUint64FromVariant;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            *GetValueFunc = WmiGetBooleanFromVariant;
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            *GetValueFunc = WmiGetStringFromVariant;
            break;
        }

        case CIM_OBJECT:
        {
            *GetValueFunc = WmiGetObjectFromVariant;
            break;
        }
        
        //
        // Floating point values not supported
        //
        case CIM_REAL32:
        case CIM_REAL64:
            
        default:
        {
            *GetValueFunc = NULL;
            ReturnStatus = FALSE;
            break;
        }       
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataItemFromWbem(
    IN OUT PDATA_ITEM_DESCRIPTION DataItemDesc,
    IN IWbemClassObject *pIWbemClassObject
    )
/*+++

Routine Description:

    This routine will call WBEM to get the latest value for the property
    represented by the DataItemDesc
        
Arguments:

    DataItemDesc is the data item description for the property

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    ULONG i;
    LONG i1;
    BSTR s;
    HRESULT hr;
    VARIANT Value;
    CIMTYPE ValueType;
    BOOLEAN ReturnStatus;
    ULONG ElementSize;
    GETVALUEFROMVARIANTFUNC GetValueFunc;

    WmiAssert(DataItemDesc != NULL);
    WmiAssert(pIWbemClassObject != NULL);

    DebugPrint((1,"WMI: Refreshing data item %ws\n", DataItemDesc->Name));
    ReturnStatus = FALSE;
    s = SysAllocString(DataItemDesc->Name);
    if (s != NULL)
    {
        hr = pIWbemClassObject->Get(s,
                                        0,
                                        &Value,
                                        &ValueType,
                                        NULL);
        if (hr == WBEM_S_NO_ERROR)
        {
            DebugPrint((1, "WMIPROP: Got value for %ws as variant type 0x%x, cim type 0x%x at variant %p\n",
                            s, Value.vt, ValueType, &Value));
            WmiAssert((ValueType & ~CIM_FLAG_ARRAY) == DataItemDesc->DataType);
            
            WmiCleanDataItemDescData(DataItemDesc);
            
            if ( (ValueType & CIM_FLAG_ARRAY) == 0)
            {
                //
                // Non Array value, just pull the value out of the variant
                // and stash into DataItemDesc
                //
                WmiAssert(DataItemDesc->IsVariableArray == 0);
                WmiAssert(DataItemDesc->IsFixedArray == 0);
                
                //
                // For all  types we get the getvalue
                // function and the pull the value out of the
                // variant and into the DataItemDesc
                //
                if (WmiGetValueFunc(DataItemDesc->DataType,
                                    &GetValueFunc))
                {
                    //
                    // TODO: Keep track of data item position and
                    //       padding within data block
                    //
                    ReturnStatus = (*GetValueFunc)(
                                       &Value,
                                   (PVOID)&DataItemDesc->Data);
#if DBG
                    if (ReturnStatus == FALSE)
                    {
                        DebugPrint((1, "WMIPROP: Property %ws is type %d, but got type %d variant %p\n",
                                        DataItemDesc->Name,
                                        DataItemDesc->DataType,
                                        Value.vt, &Value));
                                        WmiAssert(FALSE);
                    }
#endif
                }
                
            } else {
                //
                // Get all of the data for an array
                //
                LONG LBound, UBound, NumberElements;
                PUCHAR Array;
                LONG Index;
                VARIANT Element;
                ULONG ElementSize;
                ULONG SizeNeeded;
                VARTYPE vt;
            
                WmiAssert((DataItemDesc->IsVariableArray != 0) || 
                          (DataItemDesc->IsFixedArray != 0));
                
                WmiAssert(Value.vt & VT_ARRAY);
                
                if (WmiGetArraySize(Value.parray,
                                    &LBound,
                                    &UBound,
                                    &NumberElements))
                {
                    if (WmiGetValueFunc(DataItemDesc->DataType,
                                        &GetValueFunc))
                    {
                        //
                        // The size of each element is not allowed to
                        // change, but the number of elements are
                        //
                        WmiAssert(DataItemDesc->ArrayPtr == NULL);
                        ElementSize = DataItemDesc->DataSize;
                        SizeNeeded = NumberElements * ElementSize;

                        Array = (PUCHAR)LocalAlloc(LPTR, SizeNeeded);
                        DataItemDesc->ArrayElementCount = NumberElements;
                        DebugPrint((1,"WMIPROP: Alloc 0x%x bytes at %p\n", SizeNeeded, Array));
                        memset(Array, 0, SizeNeeded);
                        
                        if (Array != NULL)
                        {
                            // CONSIDER: Use SafeArrayAccessData for number
                            //           types
                            //
                            // Now that we have memory for the array data
                            // extract the data from the safe array and 
                            // store it in the C array
                            //
                            DataItemDesc->ArrayPtr = (PVOID)Array;
                            hr = SafeArrayGetVartype(Value.parray,
                                                     &vt);
                            if (hr == WBEM_S_NO_ERROR)
                            {
                                ReturnStatus = TRUE;
                                for (i1 = 0, Index = LBound; 
                                     (i1 < NumberElements) && ReturnStatus; 
                                     i1++, Index++)
                                {
                                    VariantInit(&Element);
                                    Element.vt = vt;
                                    hr = SafeArrayGetElement(Value.parray,
                                                             &Index,
                                                             &Element.boolVal);
                                    if (hr == WBEM_S_NO_ERROR)
                                    {    
                                        Element.vt = vt;
                                        DebugPrint((1, "WMIPROP: GetValueFunc at %p\n", Array));
                                        ReturnStatus = (*GetValueFunc)(
                                                                &Element,
                                                                (PVOID)Array);
                                        Array += ElementSize;
                                    } else {
                                        ReturnStatus = FALSE;
                                    }
                                }
                            }
                        }
                    } else {
                        DebugPrint((1, "WMIPROP: Property %ws is array of type %d, but got type %d variant %p\n",
                                            DataItemDesc->Name,
                                            DataItemDesc->DataType,
                                            Value.vt, &Value));
                        WmiAssert(FALSE);
                    }
                }
            }
            VariantClear(&Value);
        }
        
        SysFreeString(s);
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataBlockFromWbem(
    IN IWbemClassObject *pIWbemClassObject,
    IN OUT PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
/*+++

Routine Description:

    This routine will call WBEM to get the latest values for all property
    in data block represented by the DataBlockDesc
        
Arguments:

    DataBlockDesc is the data item description for the class

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN ReturnStatus;
    ULONG i;
    
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    
    ReturnStatus = TRUE;
    for (i = 0; (i < DataBlockDesc->DataItemCount) && ReturnStatus; i++)
    {
        DataItemDesc = &DataBlockDesc->DataItems[i];
        ReturnStatus = WmiRefreshDataItemFromWbem(DataItemDesc,
                                                  pIWbemClassObject);
    }
    
    return(ReturnStatus);
}

VARTYPE WmiVarTypeForCimType(
    CIMTYPE CimType
    )
{
    VARTYPE vt;
    
    //
    // Most things match their CIM types, except those below
    vt = (VARTYPE)CimType;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            vt = VT_I4;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            vt = VT_I2;
            break;
        }
                                                                            
        case CIM_UINT32:                        
        {
            vt = VT_I4;
            break;
        }
                            
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            vt = VT_BSTR;
            break;
        }
        
        case CIM_OBJECT:
        {
            vt = VT_UNKNOWN;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            vt = VT_BOOL;
            break;
        }
        
        
    }
    return(vt); 
}

typedef BOOLEAN (*SETVALUEFUNC)(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    );

BOOLEAN WmiSetBooleanValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    BOOLEAN Value;
    
    //
    // A boolean needs to ve expressed as a VARIANT_TRUE or VARIANT_FALSE
    //
    Value = *((PBOOLEAN)DataPtr);
    *((VARIANT_BOOL *)DestPtr) = Value ? VARIANT_TRUE : VARIANT_FALSE;
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetStringValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    BSTR s;
    PTCHAR String;
    BOOLEAN ReturnStatus;
    
    //
    // Strings must be converted to BSTR
    //
    String = *((PTCHAR *)DataPtr);
    
    WmiAssert(String != NULL);
    
    s = SysAllocString(String);
    if (s != NULL)
    {
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiSetEmbeddedValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    IUnknown *pUnk;
    IWbemClassObject *pIWbemClassObject;
    HRESULT hr;
    BOOLEAN ReturnStatus;
            
    //
    // QI for IUnknown since we are expected to put the IUnknown into
    // the property.
    //
    pIWbemClassObject = *((IWbemClassObject **)DataPtr);
    hr = pIWbemClassObject->QueryInterface(IID_IUnknown,
                                          (PVOID *)&pUnk);
                                      
    if (hr == WBEM_S_NO_ERROR)
    {
        *((IUnknown **)DestPtr) = pUnk;
        *SetPtr = (PVOID)pUnk;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }                
    return(ReturnStatus);
}

BOOLEAN WmiSetSint8ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // CHARs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (LONG)(*((CHAR *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint8ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // UCHARs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (LONG)(*((UCHAR *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint16ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // SHORTs must be expressed as a SHORT to keep WBEM happy
    //
    *((SHORT *)DestPtr) = (*((SHORT *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint16ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // USHORTs must be expressed as a SHORT to keep WBEM happy
    //
    *((SHORT *)DestPtr) = (SHORT)(*((USHORT *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint32ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // LONGs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (*((LONG *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint32ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // ULONGs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (ULONG)(*((ULONG *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint64ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    TCHAR Text[MAX_PATH];
    BSTR s;
    BOOLEAN ReturnStatus;
    
    //
    // 64 bit values must be set via a BSTR
    //
    wsprintf(Text, TEXT("%I64d"), *((LONGLONG *)DataPtr));
                   
    s = SysAllocString(Text);
    if (s != NULL)
    {            
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiSetUint64ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    TCHAR Text[MAX_PATH];
    BSTR s;
    BOOLEAN ReturnStatus;
    
    //
    // 64 bit values must be set via a BSTR
    //
    wsprintf(Text, TEXT("%I64d"), *((ULONGLONG *)DataPtr));
                   
    s = SysAllocString(Text);
    if (s != NULL)
    {            
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

SETVALUEFUNC WmiGetSetValueFunc(
    CIMTYPE CimType
    )
{
    SETVALUEFUNC SetValueFunc;
    
    switch(CimType)
    {
        case CIM_SINT8:
        {
            SetValueFunc = WmiSetSint8ValueFunc;
            break;
        }
        
        case CIM_UINT8:
        {
            SetValueFunc = WmiSetUint8ValueFunc;
            break;
        }
        
        case CIM_CHAR16:
        case CIM_SINT16:
        {
            SetValueFunc = WmiSetSint16ValueFunc;
            break;
        }
        
        case CIM_UINT16:
        {
            SetValueFunc = WmiSetUint16ValueFunc;
            break;
        }
        
        case CIM_SINT32:
        {
            SetValueFunc = WmiSetSint32ValueFunc;
            break;
        }
        
        case CIM_UINT32:
        {
            SetValueFunc = WmiSetUint32ValueFunc;
            break;
        }
        
        case CIM_SINT64:
        {
            SetValueFunc = WmiSetSint64ValueFunc;
            break;
        }
        
        case CIM_UINT64:
        {
            SetValueFunc = WmiSetUint64ValueFunc;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            SetValueFunc = WmiSetBooleanValueFunc;
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            SetValueFunc = WmiSetStringValueFunc;
            break;
        }

        case CIM_OBJECT:
        {
            SetValueFunc = WmiSetEmbeddedValueFunc;
            break;
        }
        
        default:
        {
            SetValueFunc = NULL;
            break;
        }               
    }
    return(SetValueFunc);
}

BOOLEAN WmiAssignToVariantFromDataItem(
    OUT VARIANT *NewValue,
    IN PDATA_ITEM_DESCRIPTION DataItemDesc
)
/*+++

Routine Description:

    This routine will assign the value for a property from the DataItemDesc
    into an initied variant. It will figure out all of the strange rules
    for what types of variants WBEM likes for different data types.
        
Arguments:

    DataBlockDesc is the data item description for the class

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    BOOLEAN ReturnStatus;
    BSTR s;
    TCHAR Text[MAX_PATH];
    SETVALUEFUNC SetValueFunc;
    VARTYPE vt;
    PVOID SetPtr;
    
    WmiAssert(NewValue != NULL);
    WmiAssert(DataItemDesc != NULL);    
        
    SetValueFunc = WmiGetSetValueFunc(DataItemDesc->DataType);

    if (SetValueFunc != NULL)
    {
        ReturnStatus = TRUE;
        vt = WmiVarTypeForCimType(DataItemDesc->DataType);

        if ((DataItemDesc->IsFixedArray == 0) &&
            (DataItemDesc->IsVariableArray == 0))
        {
            //
            // This is a non array case
            //
            NewValue->vt = vt;
            ReturnStatus = (*SetValueFunc)((PVOID)&DataItemDesc->Data,
                                           &NewValue->lVal,
                                           &SetPtr);    
        } else {
            //
            // This is an array, so we need to create a safe array in order to
            // call WBEM.
            //
            SAFEARRAY *SafeArray;
            PUCHAR DataArray;
            PVOID DataPtr;
            PVOID Temp;
            HRESULT hr;
            ULONG i;

            //
            // We do not support arrays of embedded classes
            //
            SafeArray = SafeArrayCreateVector(vt,
                                          0,
                                          DataItemDesc->ArrayElementCount);
            if (SafeArray != NULL)
            {
                DataArray = (PUCHAR)DataItemDesc->ArrayPtr;
                WmiAssert(DataArray != NULL);

                ReturnStatus = TRUE;
                for (i = 0; 
                     (i < DataItemDesc->ArrayElementCount) && ReturnStatus; 
                     i++)
                {
                    ReturnStatus = (*SetValueFunc)(DataArray, &Temp, &SetPtr);
                    if (ReturnStatus)
                    {
                        hr = SafeArrayPutElement(SafeArray,
                                               (PLONG)&i,
                                               SetPtr);
                        if (hr == WBEM_S_NO_ERROR)
                        {
                            DataArray += DataItemDesc->DataSize;
                        } else {
                            ReturnStatus = FALSE;
                        }
                    }
                }

                if (ReturnStatus == FALSE)
                {
                    //
                    // if we failed to build the safearray we need to clean
                    // it up.
                    //
                    SafeArrayDestroy(SafeArray);
                } else {
                    NewValue->vt = vt | VT_ARRAY;
                    NewValue->parray = SafeArray;
                }

            } else {
                ReturnStatus = FALSE;
            }
        }
    } else {
        WmiAssert(FALSE);
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshWbemFromDataItem(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will update the WBEM property with the value specified in
    the DataItemDesc.
        
Arguments:

    DataItemDesc is the data item description for the property

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    VARIANT NewValue;
    BOOLEAN ReturnStatus;
    HRESULT hr;
    BSTR s;

    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    ReturnStatus = TRUE;
    if (DataItemDesc->IsReadOnly == 0)
    {
        //
        // Property is not read only so we want to try to update it
        //
                    
        //
        // Now build the value into a variant and call WBEM to get him
        // to update it.
        //
        VariantInit(&NewValue);        
        
        ReturnStatus = WmiAssignToVariantFromDataItem(&NewValue,
                                                      DataItemDesc);
        //
        // if we need to update the value of the property do so and then
        // free up the variant
        //
        if (ReturnStatus)
        {
            s = SysAllocString(DataItemDesc->Name);
            if (s != NULL)
            {
                DebugPrint((1, "WMIPROP: Property %ws (%p) being updated to 0x%x (type 0x%x)\n",
                             DataItemDesc->Name,
                             DataItemDesc,
                             NewValue.ulVal,
                             NewValue.vt));
                hr = pIWbemClassObject->Put(s,
                                        0,
                                        &NewValue,
                                        0);
#if DBG                                            
                if (hr != WBEM_S_NO_ERROR)
                {
                    DebugPrint((1, "WMIPROP: Property %ws (%p) Error %x from pIWbemClassObejct->Put\n", 
                    DataItemDesc->Name,
                    DataItemDesc,
                    hr));
                }
#endif                    
                SysFreeString(s);
            }
            VariantClear(&NewValue);
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiRefreshWbemFromDataBlock(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN BOOLEAN IsEmbeddedClass
)
/*+++

Routine Description:

    This routine will update the WBEM class with the values specified in
    the DataBlockDesc. If the class is not an embedded (ie, top level) then
    it will put the instance which will update the values in the schema and
    call the provider (ie, device driver).
        
Arguments:

    pIWbemServices is the Wbem Service interface

    pIWbemClassObject is the instance class object interface for the class
        
    DataBlockDesc is the data block description for the class
    
    IsEmbeddedClass is TRUE if the class is an embedeed class.
        
Return Value:

    TRUE if successful

---*/
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN ReturnStatus;
    HRESULT hr;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    ReturnStatus = TRUE;
    
    for (i = 0; (i < DataBlockDesc->DataItemCount) && ReturnStatus; i++)
    {
        DataItemDesc = &DataBlockDesc->DataItems[i];
        ReturnStatus = WmiRefreshWbemFromDataItem(pIWbemServices,
                                                  pIWbemClassObject,
                                                  DataItemDesc);
    }
    
    if ((ReturnStatus) && (! IsEmbeddedClass))
    {
        //
        // No need to do PutInsance on embedded classes, only top level ones
        //
        hr = pIWbemServices->PutInstance(pIWbemClassObject,
                                         WBEM_FLAG_UPDATE_ONLY,
                                         NULL,
                                         NULL);
#if DBG
        if (hr != WBEM_S_NO_ERROR)
        {
            DebugPrint((1, "WMIPROP: Error %x returned from PutInstance for %ws (%p)\n",
                            hr, DataBlockDesc->Name, DataBlockDesc));
        }
#endif
                                     
        ReturnStatus = (hr == WBEM_S_NO_ERROR);
    }
    
    return(ReturnStatus);
}



PTCHAR WmiGetDeviceInstanceId(
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData,
    IN HANDLE           MachineHandle
    )
/*+++

Routine Description:

    This routine will obtain the device instance id for the device that
    we are working with.

Arguments:

    deviceInfoSet
    deviceInfoData            

Return Value:

    returns pointer to device instance id or NULL if unavailable

---*/
{
    ULONG Status;
    PTCHAR Id;    
    ULONG SizeNeeded;

    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    SizeNeeded = (MAX_DEVICE_ID_LEN + 1) * sizeof(TCHAR);
    Id = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
    if (Id != NULL)
    {
        Status = CM_Get_Device_ID_Ex(deviceInfoData->DevInst,
                                     Id,
                                     SizeNeeded / sizeof(TCHAR),
                                     0,
                                     MachineHandle);
            
        if (Status != CR_SUCCESS)
        {   
            DebugPrint((1, "WMIPROP: CM_Get_Device_ID_Ex returned %d\n",
                         Status));
            LocalFree(Id);
            Id = NULL;
        }
        
    } else {
        DebugPrint((1, "WMIPROP: Could not alloc for device Id\n"));
    }
    return(Id);
}

PTCHAR WmiGetDeviceInstanceName(
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData,
    IN HANDLE           MachineHandle
    )
/*+++

Routine Description:

    This routine will obtain the WMI instance name id for the device that
    we are working with.

Arguments:

    deviceInfoSet
    deviceInfoData            

Return Value:

    returns pointer to device instance name or NULL if unavailable

---*/
{
    #define InstanceNumberText TEXT("_0")
    PTCHAR Id, in, s;
    PTCHAR InstanceName;
    ULONG SizeNeeded;
    
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    InstanceName = NULL;
    Id = WmiGetDeviceInstanceId(deviceInfoSet,
                                deviceInfoData,
                                MachineHandle);
                            
    if (Id != NULL)
    {
        //
        // We need to play some games with the device id to make it into
        // a WMI instance name.
        //
        // 1. We need to convert any "\\" in the instance name to "\\\\".
        //    For some reason wbem likes it this way.
        // 2. We need to append a "_0" to the end to indicate the instance
        //    number we are dealing with.
            
        s = Id;
        SizeNeeded = (_tcslen(Id) * sizeof(TCHAR)) + 
                     sizeof(InstanceNumberText);
        while (*s != 0)
        {
            if (*s++ == TEXT('\\'))
            {
                SizeNeeded += sizeof(TCHAR);
            }
        }
        
        InstanceName = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
        if (InstanceName != NULL)
        {
            in = InstanceName;
            s = Id;
            while (*s != 0)
            {
                *in++ = *s;
                if (*s++ == TEXT('\\'))
                {
                    *in++ = TEXT('\\');
                }
            }
            _tcscat(InstanceName, InstanceNumberText);
        }
        LocalFree(Id);
    }
    return(InstanceName);
}


BOOLEAN WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PTCHAR QualifierName,
    IN VARTYPE Type,
    OUT VARIANT *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific qualifier
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    QualifierName is the name of the qualifier
        
    Type is the type of qualifier expected
        
    *Value returns with the value of the qualifier

Return Value:

    returns pointer to device instance name or NULL if unavailable

---*/
{
    BSTR s;
    HRESULT hr;
    BOOLEAN ReturnStatus;

    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(QualifierName != NULL);
    WmiAssert(Value != NULL);
    
    s = SysAllocString(QualifierName);
    if (s != NULL)
    {
        hr = pIWbemQualifierSet->Get(s,
                                0,
                                Value,
                                NULL);
                
        if (hr == WBEM_S_NO_ERROR)
        {
            ReturnStatus  = ((Value->vt & ~CIM_FLAG_ARRAY) == Type);
        } else {
            ReturnStatus = FALSE;
        }
        
        SysFreeString(s);
    } else {
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiParseRange(
    OUT PRANGEINFO RangeInfo,
    IN BSTR Range
    )
/*+++

Routine Description:

    This routine will parse a range specified in the for x or x - y. The 
    former means the value x and the latter means from x to y.
        
Arguments:

    *RangeInfo returns with the range specified
        
    Range is the text representation of the range
        
Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RangeSeparator TEXT('-')
    #define Space TEXT(' ')
    #define MAX_RANGE_VALUE_LENGTH 64
        
    LONG64 BeginValue, EndValue;
    TCHAR *s;
    TCHAR *d;
    TCHAR ValueText[MAX_RANGE_VALUE_LENGTH];
    ULONG i;
    BOOLEAN ReturnStatus;
 
    WmiAssert(RangeInfo != NULL);
    WmiAssert(Range != NULL);
    
    //
    // Obtain the beginning value by copying up to the separator and
    // then converting to a number
    //
    s = Range;
    d = ValueText;
    i = 0;
    while ((*s != 0) && (*s != RangeSeparator) && (*s != Space) &&
           (i < MAX_RANGE_VALUE_LENGTH))
    {
        *d++ = *s++;
        i++;
    }
    *d = 0;
    
    if (i < MAX_RANGE_VALUE_LENGTH)
    {
        BeginValue = _ttoi64(ValueText);
        EndValue = BeginValue;
        if (*s != 0)
        {
            //
            // Skip to the beginning of the next number
            //
            while ( (*s != 0) && 
                    ((*s == RangeSeparator) || (*s == Space)) )
            {
                s++;
            }
            
            if (*s != 0)
            {
                //
                // We do have a second number, copy it out
                //
                d = ValueText;
                i = 0;
                while ((*s != 0) && (*s != Space) &&
                       (i < MAX_RANGE_VALUE_LENGTH))
                  {
                    *d++ = *s++;
                    i++;
                 }
                *d = 0;
                
                if (*s == 0)
                {
                    EndValue = _ttoi64(ValueText);
                }
                
            }
        }        
        
        //
        // Fill out the output RangeInfo making sure that the smaller value
        // is placed in the miniumum and larger in the maximum.
        //
        if (BeginValue < EndValue)
        {
            RangeInfo->Minimum = BeginValue;
            RangeInfo->Maximum = EndValue;
        } else {
            RangeInfo->Minimum = EndValue;
            RangeInfo->Maximum = BeginValue;
        }        
        
        ReturnStatus = TRUE;
    } else {
        //
        // if range text is too long then give up
        //
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiRangeProperty(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will obtain information about the valid ranges of values
    for the data item
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    DataItemDesc gets filled with info about ranges

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RangeText TEXT("Range")
        
    VARIANT Range;
    BSTR RangeData;
    LONG RangeLBound, RangeUBound, RangeElements;
    LONG i, Index;
    HRESULT hr;
    ULONG SizeNeeded;
    PRANGELISTINFO RangeListInfo;
    BOOLEAN ReturnStatus;
            
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    if (WmiGetQualifier(pIWbemQualifierSet,
                         RangeText,
                         VT_BSTR, // array
                         &Range))
    {
        if (Range.vt & CIM_FLAG_ARRAY)
        {
            //
            // Array of ranges
            //
            if (WmiGetArraySize(Range.parray, 
                                &RangeLBound,
                                &RangeUBound,
                                &RangeElements))
            {
                SizeNeeded = sizeof(RANGELISTINFO) + 
                             (RangeElements * sizeof(RANGEINFO));
                RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, SizeNeeded);
                if (RangeListInfo != NULL)
                {
                    ReturnStatus = TRUE;
                    DataItemDesc->RangeListInfo = RangeListInfo;
                    RangeListInfo->Count = RangeElements;
                    for (i = 0; (i < RangeElements) && ReturnStatus; i++)
                    {
                        Index = i + RangeLBound;
                        hr = SafeArrayGetElement(Range.parray,
                                                 &Index,
                                                 &RangeData);
                        if (hr == WBEM_S_NO_ERROR)
                        {
                            ReturnStatus = WmiParseRange(
                                                    &RangeListInfo->Ranges[i],
                                                    RangeData);
#if DBG
                            if (ReturnStatus == FALSE)
                            {
                                DebugPrint((1, "WMIPROP: Error parsing range %ws\n",
                                              RangeData));
                            }
#endif
                        } else {
                            ReturnStatus = FALSE;
                        }
                    }
                } else {
                    ReturnStatus = FALSE;
                }
            } else {
                ReturnStatus = FALSE;
            }
        } else {
            // 
            // Single range
            //
            RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, sizeof(RANGELISTINFO));
            if (RangeListInfo != NULL)
            {
                DataItemDesc->RangeListInfo = RangeListInfo;
                RangeListInfo->Count = 1;
                ReturnStatus = WmiParseRange(&RangeListInfo->Ranges[0],
                                              Range.bstrVal);
            } else {
                ReturnStatus = FALSE;
            }
        }
        VariantClear(&Range);
    } else {
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}


BOOLEAN WmiValueMapProperty(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will obtain information about the enumeration values for
    the data block
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    DataItemDesc gets filled with info about enumerations

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define ValueMapText TEXT("ValueMap")
    #define ValuesText TEXT("Values")
        
    VARIANT Values, ValueMap;
    BSTR ValuesData, ValueMapData;
    BOOLEAN ReturnStatus = FALSE;
    VARTYPE ValuesType, ValueMapType;
    LONG ValuesUBound, ValuesLBound, ValuesSize;
    LONG ValueMapUBound, ValueMapLBound, ValueMapSize;
    ULONG SizeNeeded;
    PENUMERATIONINFO EnumerationInfo;
    LONG i;
    LONG Index;
    HRESULT hr;
    
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    //
    // Get the Values and ValueMap qualifier values. These can be single
    // strings or arrays of strings.
    //
    if ((WmiGetQualifier(pIWbemQualifierSet,
                         ValuesText,
                         VT_BSTR, // array
                         &Values)) &&
        (WmiGetQualifier(pIWbemQualifierSet,
                         ValueMapText,
                         VT_BSTR, // array
                         &ValueMap)))
    {
        //
        // if we've got both qualifiers then we can do value map, make sure
        // that both of them are strings and are either scalar or arrays with
        // the same length.
        //
        ValuesType = Values.vt & ~CIM_FLAG_ARRAY;
        ValueMapType = ValueMap.vt & ~CIM_FLAG_ARRAY;
        if ((ValuesType == CIM_STRING) && 
            (ValueMapType == CIM_STRING) && 
            (Values.vt == ValueMap.vt))
        {
            if (Values.vt & CIM_FLAG_ARRAY)
            {
                //
                // We have sets of arrays for the value map, make sure
                // both arrays are the same size
                //                
                SAFEARRAY *ValuesArray = Values.parray;
                SAFEARRAY *ValueMapArray = ValueMap.parray;
                if ((WmiGetArraySize(ValuesArray,
                                     &ValuesLBound,
                                     &ValuesUBound,
                                     &ValuesSize)) &&
                    (WmiGetArraySize(ValueMapArray,
                                     &ValueMapLBound,
                                     &ValueMapUBound,
                                     &ValueMapSize)) &&
                    (ValueMapSize == ValuesSize))
                {
                    //
                    // Everything checks out with the arrays, just need to 
                    // copy the values and valuemap into data item desc
                    //
                    SizeNeeded = sizeof(ENUMERATIONINFO) + 
                                 ValuesSize * sizeof(ENUMERATIONITEM);
                    EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                                  SizeNeeded);
                    if (EnumerationInfo != NULL)
                    {
                        //
                        // We have memory to store the enumeration info
                        // loop over all enumations and record the info
                        //
                        ReturnStatus = TRUE;
                        DataItemDesc->EnumerationInfo = EnumerationInfo;
                        EnumerationInfo->Count = ValuesSize;
                        for (i = 0; (i < ValuesSize) && ReturnStatus; i++)
                        {
                            Index = i + ValuesLBound;
                            hr = SafeArrayGetElement(ValuesArray,
                                                 &Index,
                                                 &ValuesData);
                            if (hr == WBEM_S_NO_ERROR)
                            {
                                Index = i + ValueMapLBound;
                                hr = SafeArrayGetElement(ValueMapArray,
                                                     &Index,
                                                     &ValueMapData);
                                if (hr == WBEM_S_NO_ERROR)
                                {
                                    ReturnStatus = 
                        (WmiBstrToTchar(&EnumerationInfo->List[i].Text,
                                        ValuesData)) &&
                        (WmiBstrToUlong64(&EnumerationInfo->List[i].Value,
                                          ValueMapData));
                                                   
                                }
                            } else {
                                ReturnStatus = FALSE;
                            }
                        }
                    }
                }
            } else {
                //
                // Single value in ValueMap
                //
                EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                      sizeof(ENUMERATIONINFO));
                if (EnumerationInfo != NULL)
                {
                    DataItemDesc->EnumerationInfo = EnumerationInfo;
                    EnumerationInfo->Count = 1;
                    ReturnStatus = 
                        (WmiBstrToTchar(&EnumerationInfo->List[0].Text,
                                        Values.bstrVal)) &&
                        (WmiBstrToUlong64(&EnumerationInfo->List[0].Value,
                                          ValueMap.bstrVal));
                                                   
                } else {
                    ReturnStatus = FALSE;
                }
            }
        }                        
    }
    
    VariantClear(&Values);
    VariantClear(&ValueMap);
    
    return(ReturnStatus);
}

BOOLEAN WmiGetEmbeddedDataItem(
    IN IWbemServices *pIWbemServices,
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    #define ObjectColonText TEXT("object:")
    #define ObjectColonTextChars ((sizeof(ObjectColonText)/sizeof(TCHAR))-1)
    #define CIMTYPEText TEXT("CIMTYPE")
        
    IWbemClassObject *pIWbemClassObjectEmbedded;
    VARIANT CimType;
    BSTR s;
    HRESULT hr;
    BOOLEAN ReturnStatus;
    
    //
    // This is an embedded class, so we need to dig
    // out the name of the embedded class from the CIMTYPE
    // qualifier for the property and then go and get
    // that class object (via IWbemServices) as if it
    // were just another top level class. 
    //
    ReturnStatus = FALSE;

    if (WmiGetQualifier(pIWbemQualifierSet,
                        CIMTYPEText,
                        VT_BSTR,
                        &CimType))
    {
        //
        // Make sure that CIMTYPE value starts with object:
        //
        if (_tcsnicmp(CimType.bstrVal, 
                      ObjectColonText, 
                      ObjectColonTextChars) == 0)
        {
            //
            // and if so then the rest of the string is the embedded class
            // name, so make that a bstr so we can get a class object to it.
            //
            s = SysAllocString(CimType.bstrVal + ObjectColonTextChars);
            if (s != NULL)
            {
                pIWbemClassObjectEmbedded = NULL;
                hr = pIWbemServices->GetObject(s,
                                               WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                               NULL,
                                               &pIWbemClassObjectEmbedded,
                                               NULL);
                if (hr == WBEM_S_NO_ERROR)
                {
                    DebugPrint((1, "WMIPROP: Parsing embedded class %ws for %ws \n",
                                           s, DataItemDesc->Name));
                    ReturnStatus = WmiGetDataBlockDesc(
                                       pIWbemServices,
                                       pIWbemClassObjectEmbedded,
                                       &DataItemDesc->DataBlockDesc,
                                       DataBlockDesc,
                                       (DataItemDesc->IsReadOnly == 1));
                    DebugPrint((1, "WMIPROP: Parsed embedded class %ws for %ws (%p) %ws\n",
                                  s,
                                  DataItemDesc->Name,
                                     DataItemDesc->DataBlockDesc,
                                  ReturnStatus ? L"ok" : L"failed"));
        
                    pIWbemClassObjectEmbedded->Release();
                    
                }
                SysFreeString(s);
            }
        }
        VariantClear(&CimType);
    } 
    return(ReturnStatus);
}
        

BOOLEAN WmiGetDataItem(
    IWbemServices *pIWbemServices,
    IWbemClassObject *pIWbemClassObject,
    BSTR PropertyName,
    IWbemQualifierSet *pIWbemQualifierSet,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsParentReadOnly
    )
{
    #define DescriptionText TEXT("Description")
    #define MaxText TEXT("max")
    #define WmiSizeIsText TEXT("WmiSizeIs")
    #define WriteText TEXT("Write")
    #define WmiDisplayInHexText TEXT("WmiDisplayInHex")
    #define WmiDisplayNameText TEXT("DisplayName")
    
    HRESULT hr;
    CIMTYPE PropertyType;
    LONG PropertyFlavor;
    VARIANT WriteValue;
    VARIANT DisplayHexValue;
    VARIANT MaxValue;
    VARIANT WmiSizeIsValue;
    BOOLEAN ReturnStatus;
    VARIANT Description;
    VARIANT DisplayName;
    PRANGELISTINFO RangeListInfo;
    PRANGEINFO RangeInfo;
    VARIANT PropertyValue;

    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(PropertyName != NULL);
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    hr = pIWbemClassObject->Get(PropertyName,
                                0,
                                &PropertyValue,
                                &PropertyType,
                                &PropertyFlavor);
                            
    if (hr == WBEM_S_NO_ERROR)
    {
        DebugPrint((1, "Property %ws (%p) is Type %x\n",
                            PropertyName, DataItemDesc, PropertyType));
        //
        // Make sure this is not a system property
        //
        WmiAssert((PropertyFlavor & WBEM_FLAVOR_ORIGIN_SYSTEM) == 0);
            
        //
        // Gather up the important information about the data item and
        // remember it
        //
        if (WmiBstrToTchar(&DataItemDesc->Name, PropertyName))
        {
            ReturnStatus = TRUE;
            DataItemDesc->DataType = (PropertyType & ~CIM_FLAG_ARRAY);
        
            //
            // Get Description for data item
            //
            if (WmiGetQualifier(pIWbemQualifierSet,
                                DescriptionText,
                                VT_BSTR,
                                &Description))
            {
                WmiBstrToTchar(&DataItemDesc->Description, 
                           Description.bstrVal);
                DebugPrint((1, "Property %ws (%p) has description %ws\n",
                             PropertyName, DataItemDesc,
                            DataItemDesc->Description));
                VariantClear(&Description);
            }

            //
            // Get display name for data item
            //
            if (WmiGetQualifier(pIWbemQualifierSet,
                                WmiDisplayNameText,
                                VT_BSTR,
                                &DisplayName))
            {
                WmiBstrToTchar(&DataItemDesc->DisplayName, 
                           DisplayName.bstrVal);
                DebugPrint((1, "Property %ws (%p) has display name %ws\n",
                             PropertyName, DataItemDesc,
                            DataItemDesc->DisplayName));             
                VariantClear(&DisplayName);
            }

            //
            // Lets see if this should be displayed in Hex
            // 
            DataItemDesc->DisplayInHex = 0;
            if (WmiGetQualifier(pIWbemQualifierSet,
                             WmiDisplayInHexText,
                             VT_BOOL,
                             &DisplayHexValue))
            {
                if (DisplayHexValue.boolVal != 0)
                {
                    DataItemDesc->DisplayInHex = 1;
                    DebugPrint((1, "Property %ws (%p) is DisplayInHex\n",
                                 DataItemDesc->Name, DataItemDesc));
                }
                VariantClear(&DisplayHexValue);
            }
            
            
            //
            // Lets see if this is read only or not
            // 
            DataItemDesc->IsReadOnly = 1;
            if ( (IsParentReadOnly == FALSE) &&
                 (WmiGetQualifier(pIWbemQualifierSet,
                             WriteText,
                             VT_BOOL,
                             &WriteValue)) )
            {
                if (WriteValue.boolVal != 0)
                {
                    DataItemDesc->IsReadOnly = 0;
                    DebugPrint((1, "Property %ws (%p) is Read/Write\n",
                                 DataItemDesc->Name, DataItemDesc));
                }
                VariantClear(&WriteValue);
            }
            
            //
            // See if this is an array and if so which kind
            //
            if (PropertyType & CIM_FLAG_ARRAY)
            {
                DataItemDesc->CurrentArrayIndex = 0;
                if (WmiGetQualifier(pIWbemQualifierSet,
                                MaxText,
                                VT_I4,
                                &MaxValue))
                {
                    //
                    // A fixed length array
                    //
                    DataItemDesc->IsFixedArray = 1;
                    DataItemDesc->ArrayElementCount = MaxValue.lVal;
                } else if (WmiGetQualifier(pIWbemQualifierSet,
                                    WmiSizeIsText,
                                    VT_BSTR,
                                    &WmiSizeIsValue)) {
                    //
                    // A VL arrays
                    //
                    DataItemDesc->IsVariableArray = 1;
                } else {
                    //
                    // Arrays must be fixed or variable length
                    //
                    ReturnStatus = FALSE;
                }                
            }
            
            if (ReturnStatus)
            {
                //
                // Now we know enough to assign the validation function
                //
                DataItemDesc->DataSize = WmiGetElementSize(DataItemDesc->DataType);
                switch(DataItemDesc->DataType)
                {
                    case CIM_SINT8:
                    case CIM_UINT8:
                    case CIM_SINT16:
                    case CIM_UINT16:
                    case CIM_SINT32:
                    case CIM_UINT32:
                    case CIM_SINT64:
                    case CIM_UINT64:
                    {
                        //
                        // Numbers can be validated by ranges or value maps
                        // 
                        if (WmiValueMapProperty(pIWbemQualifierSet,
                                                DataItemDesc))
                        {
                            //
                            // Validation is based upon value map
                            //
                            DataItemDesc->ValidationFunc = WmiValueMapValidation;                            
                            DebugPrint((1, "Property %ws (%p) is a ValueMap (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, DataItemDesc->EnumerationInfo));
                        } else if (WmiRangeProperty(pIWbemQualifierSet,
                                                    DataItemDesc)) {
                            //
                            // Validation is based upon ranges
                            //
                            DataItemDesc->ValidationFunc = WmiRangeValidation;
                            DebugPrint((1, "Property %ws (%p) is an explicit range (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, DataItemDesc->EnumerationInfo));
                        } else {
                            //
                            // No validation specified for number so create
                            // a range that corresponds to the minimum and
                            // maximum values for the data type
                            //
                            DataItemDesc->ValidationFunc = WmiRangeValidation;
                            RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, 
                                                       sizeof(RANGELISTINFO));
                            if (RangeListInfo != NULL)
                            {
                                DebugPrint((1, "Property %ws (%p) is an implicit range (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, RangeListInfo));
                                DataItemDesc->RangeListInfo = RangeListInfo;
                                RangeListInfo->Count = 1;
                                RangeInfo = &RangeListInfo->Ranges[0];
                                RangeInfo->Minimum = 0;
                                DataItemDesc->IsSignedValue = 0;
                                switch(DataItemDesc->DataType)
                                {
                                    case CIM_SINT8:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT8:
                                    {
                                        RangeInfo->Maximum = 0xff;
                                        break;
                                    }
                                    
                                    case CIM_SINT16:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT16:
                                    {
                                        RangeInfo->Maximum = 0xffff;
                                        break;
                                    }
                                    
                                    case CIM_SINT32:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT32:
                                    {
                                        RangeInfo->Maximum = 0xffffffff;
                                        break;
                                    }
                                    
                                    case CIM_SINT64:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT64:
                                    {
                                        RangeInfo->Maximum = 0xffffffffffffffff;
                                        break;
                                    }
                                }
                                    
                            } else {
                                ReturnStatus = FALSE;
                            }
                        }
                        break;
                    }
                    
                    case CIM_BOOLEAN:
                    {
                        ULONG SizeNeeded;
                        PENUMERATIONINFO EnumerationInfo;
                        
                        //
                        // We create a Valuemap with TRUE being 1 and
                        // FALSE being 0
                        //
                        DebugPrint((1, "Property %ws (%p) uses boolean validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiValueMapValidation;                            
                        SizeNeeded = sizeof(ENUMERATIONINFO) +
                                     2 * sizeof(ENUMERATIONITEM);
                        EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                                  SizeNeeded);
                        if (EnumerationInfo != NULL)
                        {                           
                            DataItemDesc->EnumerationInfo = EnumerationInfo;
                            EnumerationInfo->Count = 2;
                            EnumerationInfo->List[0].Value = 0;
                            EnumerationInfo->List[0].Text = WmiDuplicateString(TEXT("FALSE"));
                            EnumerationInfo->List[1].Value = 1;
                            EnumerationInfo->List[1].Text = WmiDuplicateString(TEXT("TRUE"));
                        }
                        
                        break;
                    }
                    
                    case CIM_STRING:
                    {
                        //
                        // String values are also validated simply
                        //
                        DebugPrint((1, "Property %ws (%p) uses string validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiStringValidation;
                        break;
                    }
                    
                    case CIM_DATETIME:
                    {
                        //
                        // Date time values are also validated simply
                        //
                        DebugPrint((1, "Property %ws (%p) uses datetime validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiDateTimeValidation;
                        break;
                    }
                    
                    case CIM_REAL32:
                    case CIM_REAL64:
                    {
                        //
                        // Floating point are not supported
                        //
                        DebugPrint((1, "Property %ws (%p) is floating point - not supported\n",
                                     DataItemDesc->Name, DataItemDesc));
                        ReturnStatus = FALSE;
                        break;
                    }
                    
                    case CIM_OBJECT:
                    {
                        if (WmiGetEmbeddedDataItem(pIWbemServices,
                                                   pIWbemQualifierSet,
                                                   DataBlockDesc,
                                                   DataItemDesc))
                        {
                            DataItemDesc->ValidationFunc = WmiEmbeddedValidation;
                        } else {
                            ReturnStatus = FALSE;
                        }
                        break;
                    }
                    
                    default:
                    {
                        DebugPrint((1, "Property %ws (%p) is unknoen type %d\n",
                                     DataItemDesc->Name, DataItemDesc,
                                     DataItemDesc->DataType));
                        ReturnStatus = FALSE;
                        break;
                    }
                }
            }
            
        } else {
            ReturnStatus = FALSE;
        }
        
        VariantClear(&PropertyValue);
    } else {
        ReturnStatus = FALSE;
    }
        
    return(ReturnStatus);
}

#if DBG
void WmiDumpQualifiers(
    IWbemQualifierSet *pIWbemQualiferSet
)
{
    HRESULT hr;
    LONG UBound, LBound, Count, i;
    BSTR s;
    SAFEARRAY *Quals = NULL;

    WmiAssert(pIWbemQualiferSet != NULL);
    
    hr = pIWbemQualiferSet->GetNames(0,
                                      &Quals);
        
    hr = SafeArrayGetLBound(Quals, 1, &LBound);
    hr = SafeArrayGetUBound(Quals, 1, &UBound);
    Count = UBound - LBound + 1;
    for (i = LBound; i < Count; i++)
    {
        hr = SafeArrayGetElement(Quals,  
                                 &i,
                                 &s);        
        DebugPrint((1, "qual - %ws\n", s));
    }
    SafeArrayDestroy(Quals);    
}
#endif

BOOLEAN WmiGetAllDataItems(
    IWbemServices *pIWbemServices,
    IWbemClassObject *pIWbemClassObject,
    SAFEARRAY *Names,
    LONG LBound,
    LONG Count,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsParentReadOnly
    )
{
    #define WmiDataIdText TEXT("WmiDataId")
        
    BOOLEAN ReturnStatus = TRUE;
    HRESULT hr;
    BSTR s;
    VARIANT DataIdIndex;
    LONG Index;
    LONG i;
    BSTR PropertyName;
    CIMTYPE PropertyType;
    VARIANT PropertyValue;
    LONG PropertyFlavor;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    IWbemQualifierSet *pIWbemQualifierSet;
 
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(Names != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    //
    // Loop over all of the WmiDataItem property
    for (i = 0; (i < Count) && ReturnStatus; i++)
    {
        //
        // Get the name of the first property
        //
        PropertyName = NULL;
        Index = i + LBound;
        hr = SafeArrayGetElement(Names,  
                                 &Index,
                                 &PropertyName);
        if (hr == WBEM_S_NO_ERROR)
        {
            //
            // Now lets get the qualifier list so we can determine 
            // interesting things about the property
            // 
            hr = pIWbemClassObject->GetPropertyQualifierSet(PropertyName,
                                                        &pIWbemQualifierSet);
            if (hr == WBEM_S_NO_ERROR)
            {                
                if (WmiGetQualifier(pIWbemQualifierSet,
                                    WmiDataIdText,
                                    VT_I4,
                                    &DataIdIndex))
                {
                    WmiAssert(DataIdIndex.vt == VT_I4);
                    Index = DataIdIndex.lVal - 1;
                    VariantClear(&DataIdIndex);
                    DataItemDesc = &DataBlockDesc->DataItems[Index];
                    DebugPrint((1, "Property %ws (%p) has WmiDataId %d\n",
                                    PropertyName, DataItemDesc, Index));
                    ReturnStatus = WmiGetDataItem(pIWbemServices,
                                                  pIWbemClassObject,
                                                  PropertyName,
                                                  pIWbemQualifierSet,
                                                  DataItemDesc,
                                                  DataBlockDesc,
                                                  IsParentReadOnly);
                                              
#if DBG
                    if (! ReturnStatus)
                    {
                        DebugPrint((1, "Property %ws (%p) failed WmiGetDataItem\n",
                                        PropertyName, DataItemDesc));
                    }
#endif
                } else {
                    //
                    // Since our IWbemClassObject->GetNames call specified
                    // only retrieve those properties with WmiDataId qualifier
                    // we expect that it will be found
                    //
                    WmiAssert(FALSE);
                }
                
                pIWbemQualifierSet->Release();
            } else {
                ReturnStatus = FALSE;
            }                    
        } else {
            ReturnStatus = FALSE;
        }
        
        SysFreeString(PropertyName);
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiGetDataBlockDesc(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    OUT PDATA_BLOCK_DESCRIPTION *DBD,
    IN PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc,
    IN BOOLEAN IsParentReadOnly
    )
{
    HRESULT hr;
    BSTR s;
    SAFEARRAY *Names = NULL;
    BOOLEAN ReturnStatus = FALSE;
    LONG LBound, UBound, Count;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    VARIANT DisplayName, Description;
    IWbemQualifierSet *pIWbemQualifierSet;
    ULONG SizeNeeded;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DBD != NULL);
    
    *DBD = NULL;
    s = SysAllocString(WmiDataIdText);
    if (s != NULL)
    {
        hr = pIWbemClassObject->GetNames(s,
                           WBEM_FLAG_ONLY_IF_TRUE | WBEM_FLAG_NONSYSTEM_ONLY,
                           NULL,
                           &Names);
        if (hr == WBEM_S_NO_ERROR)
        {
#if DBG            
            //
            // Verify that the safe array of names has 1 dimension and is
            // an array of BSTR.
            //
            {
                HRESULT hr;
                VARTYPE vt;
                
                WmiAssert(SafeArrayGetDim(Names) == 1);
                hr = SafeArrayGetVartype(Names, &vt);
                WmiAssert( (hr == WBEM_S_NO_ERROR) &&
                        (vt == VT_BSTR) );
            }
#endif                
            hr = SafeArrayGetLBound(Names, 1, &LBound);
            if (hr == WBEM_S_NO_ERROR)
            {
                hr = SafeArrayGetUBound(Names, 1, &UBound);
                if (hr == WBEM_S_NO_ERROR)
                {
                    Count = (UBound - LBound) + 1;
                    DebugPrint((1, "WMIPROP: %d properties found for class\n", 
                                 Count));
                    if (Count > 0)
                    {
                        SizeNeeded = sizeof(DATA_BLOCK_DESCRIPTION) + 
                                  Count * sizeof(DATA_ITEM_DESCRIPTION);

                        DataBlockDesc = (PDATA_BLOCK_DESCRIPTION)LocalAlloc(LPTR, 
                                                                      SizeNeeded);
                        if (DataBlockDesc != NULL)
                        {
                            DataBlockDesc->ParentDataBlockDesc = ParentDataBlockDesc;
                            if (WmiGetAllDataItems(pIWbemServices,
                                                   pIWbemClassObject,
                                                   Names,
                                                   LBound,
                                                   Count,
                                                   DataBlockDesc,
                                                   IsParentReadOnly))
                            {
                                DataBlockDesc->DataItemCount = Count;
                                DataBlockDesc->CurrentDataItem = 0;

                                //
                                // Get display name and description for class
                                //                                
                                pIWbemQualifierSet = NULL;
                                hr = pIWbemClassObject->GetQualifierSet(
                                                             &pIWbemQualifierSet);
                                if (hr == WBEM_S_NO_ERROR)
                                {
                                    if (WmiGetQualifier(pIWbemQualifierSet,
                                                    WmiDisplayNameText,
                                                    VT_BSTR,
                                                    &DisplayName))
                                    {
                                        WmiBstrToTchar(&DataBlockDesc->DisplayName,
                                                       DisplayName.bstrVal);
                                        VariantClear(&DisplayName);
                                    }

                                    if (WmiGetQualifier(pIWbemQualifierSet,
                                                    DescriptionText,
                                                    VT_BSTR,
                                                    &Description))
                                    {
                                        WmiBstrToTchar(&DataBlockDesc->Description,
                                                       Description.bstrVal);
                                        VariantClear(&Description);
                                    }
                                    pIWbemQualifierSet->Release();
                                } else {
                                    DebugPrint((1, "WMIPROP: Error %x getting qualifier set from %ws\n",
                                            hr, s));
                                }

                                *DBD = DataBlockDesc;
                                ReturnStatus = TRUE;
                            } else {
                                LocalFree(DataBlockDesc);
                            }
                        }
                    } else {
                        ReturnStatus = FALSE;
                    }
                }                
            }
            SafeArrayDestroy(Names);
        }
        SysFreeString(s);
    }
    return(ReturnStatus);
}
    

BOOLEAN WmiBuildConfigClass(
    IN PTCHAR MachineName,
    IN IWbemServices *pIWbemServices,
    IN PTCHAR ClassName,
    IN PTCHAR InstanceName,
    OUT PCONFIGCLASS ConfigClass
    )
/*+++

Routine Description:

    This routine will try to get the wbem object corresponding to the 
    ClassName and InstanceName and then query the class to gather info
    needed to fill the ConfigClass.
        
Arguments:

    ClassName is the name of the class
        
    InstanceName is the name of the instance 
        
    ConfigClass 

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RelPathText1 TEXT(".InstanceName=\"")        
    #define RelPathText2 TEXT("\"")

    ULONG RelPathSize;
    PTCHAR RelPath;
    HRESULT hr;
    IWbemClassObject *pIWbemClassObject, *pInstance;
    ULONG SizeNeeded, i;
    BOOLEAN ReturnStatus = FALSE;
    BSTR sRelPath, sClassName;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(ClassName != NULL);
    WmiAssert(InstanceName != NULL);
    WmiAssert(ConfigClass != NULL);

    if (MachineName != NULL)
    {
        RelPathSize = (_tcslen(MachineName) + 1) * sizeof(TCHAR);
        ConfigClass->MachineName = (PTCHAR)LocalAlloc(LPTR, RelPathSize);
        if (ConfigClass->MachineName != NULL)
        {
            _tcscpy(ConfigClass->MachineName, MachineName);
        } else {
            return(FALSE);
        }
    }

    
    //
    // Build up the relative path to the object
    //
    RelPathSize = 
                  (_tcslen(ClassName) * sizeof(TCHAR)) + 
                  sizeof(RelPathText1) + 
                  (_tcslen(InstanceName) * sizeof(TCHAR)) +
                  sizeof(RelPathText2) + 
                  sizeof(TCHAR);
              
    RelPath = (PTCHAR)LocalAlloc(LPTR, RelPathSize);
    if (RelPath != NULL)
    {
        _tcscpy(RelPath, ClassName);
        _tcscat(RelPath, RelPathText1);
        _tcscat(RelPath, InstanceName);
        _tcscat(RelPath, RelPathText2);
        ConfigClass->RelPath = RelPath;
                        
        //
        // CONSIDER: Use semisynchronous call
        //
        sRelPath = SysAllocString(RelPath);
        if (sRelPath != NULL)
        {
            pInstance = NULL;        
            hr = pIWbemServices->GetObject(sRelPath,
                                  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                  NULL,
                                  &pInstance,
                                  NULL);

            if (hr == WBEM_S_NO_ERROR)
            {            
                //
                // Now we know that the instance of the class exists so
                // we need to get a class object for the class only. We
                // need to do this since the instance class object does
                // not have any of the qualifiers, but the class only
                // class object does. 
                //
                sClassName = SysAllocString(ClassName);
                if (sClassName != NULL)
                {
                    pIWbemClassObject= NULL;
                    hr = pIWbemServices->GetObject(sClassName,
                                                   WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                   NULL,
                                                   &pIWbemClassObject,
                                                   NULL);
                    if (hr == WBEM_S_NO_ERROR)
                    {            

                        //
                        // Go and get the data block description for
                        // the class. Note that if we are on a remote
                        // machine we force the entire data block to be
                        // read only so that it is consistent with the
                        // rest of device manager
                        //
                        if (WmiGetDataBlockDesc(pIWbemServices,
                                                pIWbemClassObject,
                                                &ConfigClass->DataBlockDesc,
                                                NULL,
                                                (MachineName != NULL) ?
                                                    TRUE :
                                                    FALSE))
                        {
                            WmiBstrToTchar(&ConfigClass->DataBlockDesc->Name,
                                           sClassName);
                                       
                            ReturnStatus = TRUE;
                        }
                        pIWbemClassObject->Release();
                    } else {
                        DebugPrint((1, "WMIPROP: Error %x getting %ws class \n", hr, sClassName));
                    }
                    
                    SysFreeString(sClassName);
                }
                //
                // we have to release the class object to the instance of the
                // class. We cannot hang onto the interface since it is 
                // only valid in this thread.  We will again get a new
                // instnace interface later in the window message thread
                //
                pInstance->Release();
            } else {
                DebugPrint((1, "WMIPROP: Error %x getting %ws class instance\n", hr, sRelPath));
            }
        }
        
        SysFreeString(sRelPath);
    }
    return(ReturnStatus);
}

void WmiCleanDataItemDescData(
    PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    ULONG j;
    
    if ((DataItemDesc->IsVariableArray == 1) ||
        (DataItemDesc->IsFixedArray == 1))
    {
        if (DataItemDesc->ArrayPtr != NULL)
        {
            if ((DataItemDesc->DataType == CIM_STRING) ||
                (DataItemDesc->DataType == CIM_DATETIME))
            {
                for (j = 0; j < DataItemDesc->ArrayElementCount; j++)
                {
                    if (DataItemDesc->StringArray[j] != NULL)
                    {
                        LocalFree(DataItemDesc->StringArray[j]);
                        DataItemDesc->StringArray[j] = NULL;
                    }
                }
            } else if (DataItemDesc->DataType == CIM_OBJECT) {
                for (j = 0; j < DataItemDesc->ArrayElementCount; j++)
                {
                    if (DataItemDesc->StringArray[j] != NULL)
                    {
                        DataItemDesc->pIWbemClassObjectArray[j]->Release();
                        DataItemDesc->pIWbemClassObjectArray[j] = NULL;
                    }
                }
            }

            LocalFree(DataItemDesc->ArrayPtr);
            DataItemDesc->ArrayPtr = NULL;
        }
    } else {
        if ((DataItemDesc->DataType == CIM_STRING) ||
            (DataItemDesc->DataType == CIM_DATETIME))
        {
            LocalFree(DataItemDesc->String);
            DataItemDesc->String = NULL;
        }

        if (DataItemDesc->DataType == CIM_OBJECT)
        {
            if (DataItemDesc->pIWbemClassObject != NULL)
            {
                DataItemDesc->pIWbemClassObject->Release();
                DataItemDesc->pIWbemClassObject = NULL;
            }
        }
    }
}

void WmiFreeDataBlockDesc(
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
/*+++

Routine Description:

    This routine will free all resources used by a data block description
        
Arguments:


Return Value:

---*/
{
    ULONG i,j;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    PENUMERATIONINFO EnumerationInfo;
    PRANGELISTINFO RangeListInfo;
    
    if (DataBlockDesc != NULL)
    {
        //
        // This is freed when walking the data item desc looking for
        // embedded classes
        //
        DataBlockDesc->ParentDataBlockDesc = NULL;
        
        if (DataBlockDesc->Name != NULL)
        {
            LocalFree(DataBlockDesc->Name);
            DataBlockDesc->Name = NULL;
        }
        
        if (DataBlockDesc->DisplayName != NULL)
        {
            LocalFree(DataBlockDesc->DisplayName);
            DataBlockDesc->DisplayName = NULL;
        }
        
        if (DataBlockDesc->Description != NULL)
        {
            LocalFree(DataBlockDesc->Description);
            DataBlockDesc->Description = NULL;
        }

        if (DataBlockDesc->pInstance != NULL)
        {
            DataBlockDesc->pInstance->Release();
            DataBlockDesc->pInstance = NULL;
        }
        
        for (i = 0; i < DataBlockDesc->DataItemCount; i++)
        {
            DataItemDesc = &DataBlockDesc->DataItems[i];
            
            DebugPrint((1, "WMIPROP: Freeing %ws (%p) index %d\n",
                             DataItemDesc->Name,
                             DataItemDesc,
                             i));

            WmiCleanDataItemDescData(DataItemDesc);
            
            if (DataItemDesc->Name != NULL)
            {
                LocalFree(DataItemDesc->Name);
                DataItemDesc->Name = NULL;
            }
            
            if (DataItemDesc->DisplayName != NULL)
            {
                LocalFree(DataItemDesc->DisplayName);
                DataItemDesc->DisplayName = NULL;
            }
            
            if (DataItemDesc->Description != NULL)
            {
                LocalFree(DataItemDesc->Description);
                DataItemDesc->Description = NULL;
            }
            
            
            if ((DataItemDesc->ValidationFunc == WmiValueMapValidation) &&
                (DataItemDesc->EnumerationInfo))
            {
                EnumerationInfo = DataItemDesc->EnumerationInfo;
                for (j = 0; j < EnumerationInfo->Count; j++)
                {
                    if (EnumerationInfo->List[j].Text != NULL)
                    {
                        LocalFree(EnumerationInfo->List[j].Text);
                        EnumerationInfo->List[j].Text = NULL;
                    }
                }
                
                LocalFree(EnumerationInfo);
                DataItemDesc->EnumerationInfo = NULL;
            }
            
            if ((DataItemDesc->ValidationFunc == WmiRangeValidation) &&
                (DataItemDesc->RangeListInfo != NULL))
            {
                LocalFree(DataItemDesc->RangeListInfo);
                DataItemDesc->RangeListInfo = NULL;
            }            
            
            if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation)
            {
                if (DataItemDesc->DataBlockDesc != NULL)
                {
                    WmiFreeDataBlockDesc(DataItemDesc->DataBlockDesc);
                    DataItemDesc->DataBlockDesc = NULL;
                }                
            }
        }
        
        LocalFree(DataBlockDesc);
    }
}

void WmiFreePageInfo(
    PPAGE_INFO PageInfo
    )
/*+++

Routine Description:

    This routine will free all resources used by a page info
        
Arguments:


Return Value:

---*/
{
    ULONG i;
    PCONFIGCLASS ConfigClass;
    
    WmiAssert(PageInfo != NULL);
    
    if (PageInfo->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) 
    {
        RegCloseKey(PageInfo->hKeyDev);
        PageInfo->hKeyDev = (HKEY) INVALID_HANDLE_VALUE;
    }

    ConfigClass = &PageInfo->ConfigClass;
    if (ConfigClass->RelPath != NULL)
    {
        LocalFree(ConfigClass->RelPath);
        ConfigClass->RelPath = NULL;                
    }
        
    if (ConfigClass->pIWbemServices != NULL)
    {
        ConfigClass->pIWbemServices->Release();
        ConfigClass->pIWbemServices = NULL;
    }

    if (ConfigClass->MachineName != NULL)
    {
        LocalFree(ConfigClass->MachineName);
        ConfigClass->MachineName = NULL;
    }
    
    WmiFreeDataBlockDesc(ConfigClass->DataBlockDesc);
    
    LocalFree(PageInfo);
}

PPAGE_INFO WmiCreatePageInfo(
    IN PTCHAR MachineName,
    IN IWbemServices *pIWbemServices,
    IN PTCHAR ClassName,
    IN PTCHAR InstanceName,
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData
    )
/*+++

Routine Description:

    This routine will create a PAGE_INFO structure that is used to describe
    property pages.
        
Arguments:


Return Value:

---*/
{
    PPAGE_INFO  PageInfo;
    BOOLEAN ReturnStatus;
    HKEY hKeyDev;

    WmiAssert(pIWbemServices != NULL);
    WmiAssert(ClassName != NULL);
    WmiAssert(InstanceName != NULL);
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    //
    // Allocate room to store data for the property page
    //
    PageInfo = (PPAGE_INFO)LocalAlloc(LPTR, sizeof(PAGE_INFO));
    if (PageInfo == NULL) {
        return(NULL);
    }
    
    hKeyDev = SetupDiCreateDevRegKey(deviceInfoSet,
                               deviceInfoData,
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DEV,
                               NULL,
                               NULL);
        
    PageInfo->hKeyDev = hKeyDev;
    PageInfo->deviceInfoSet = deviceInfoSet;
    PageInfo->deviceInfoData = deviceInfoData;
    
    ReturnStatus = WmiBuildConfigClass(MachineName,
                                       pIWbemServices,
                                       ClassName, 
                                       InstanceName,
                                       &PageInfo->ConfigClass);
    if (! ReturnStatus)
    {
        WmiFreePageInfo(PageInfo);
        PageInfo = NULL;
    }
    
    return(PageInfo);
}

void
WmiDestroyPageInfo(PPAGE_INFO * ppPageInfo)
{
    PPAGE_INFO ppi = *ppPageInfo;

    WmiFreePageInfo(ppi);
    *ppPageInfo = NULL;
}

HPROPSHEETPAGE
WmiCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi,
                      PTCHAR ClassName)
{
    
    WmiAssert(ppi != NULL);
    WmiAssert(ppsp != NULL);
    WmiAssert(ClassName != NULL);
    
    //
    // Add the Port Settings property page
    //
    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
    ppsp->dwFlags     = PSP_USECALLBACK | PSP_USETITLE; // | PSP_HASHELP;
    ppsp->hInstance   = g_hInstance;
    ppsp->pszTemplate = MAKEINTRESOURCE(ID_WMI_PROPPAGE);
    ppsp->pszTitle = ClassName;

    //
    // following points to the dlg window proc
    //
    ppsp->pfnDlgProc = WmiDlgProc;
    ppsp->lParam     = (LPARAM) ppi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    ppsp->pfnCallback = WmiDlgCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(ppsp);
}

BOOLEAN WmiIsDuplicateClass(
    PTCHAR ClassName,
    PTCHAR ClassList,
    PTCHAR ClassListEnd
    )
{
    BOOLEAN Found;
    ULONG NameLen;

    Found = FALSE;
    NameLen = _tcslen(ClassName);
    
    while (ClassList < ClassListEnd)
    {
        if (_tcsnicmp(ClassList, ClassName, NameLen) == 0)
        {
            //
            // We found a duplicate name
            //
            return(TRUE);
        }

        while (*ClassList != ',')
        {
            if (ClassList >= ClassListEnd)
            {
                return(FALSE);
            }

            ClassList++;
        }
        ClassList++;
    }

    return(Found);
}

PTCHAR WmiGetNextClass(
    PTCHAR *ClassList 
    )
{
    PTCHAR s = *ClassList;
    PTCHAR Class, ClassName;
    ULONG Len;
    
    //
    // skip over any white space
    //
    while (IsWhiteSpace(*s) && (*s != 0))
    {
        s++;
    }
    
    //
    // Search for separator or end of string
    //
    ClassName = s;
    Len = 0;
    while ((*s != TEXT(',')) && (*s != 0))
    {
        s++;
        Len++;
    }
    
    if (*s != 0)
    {
        //
        // If we have a string then alloc and copy it over
        //
        Class = (PTCHAR)LocalAlloc(LPTR, (Len+1)*sizeof(TCHAR));
        if (Class != NULL)
        {
            _tcsncpy(Class, ClassName, Len);
            DebugPrint((1,"WMIPROP: Class %ws is in list\n", Class));
        }
        
        s++;
    } else {
        //
        // End of string, all done
        //
        Class = NULL;
    }

    *ClassList = s;
    return(Class);
}

BOOL
WmiPropPageProvider(HDEVINFO                  deviceInfoSet,
                    PSP_DEVINFO_DATA          deviceInfoData,
                    PSP_ADDPROPERTYPAGE_DATA  AddPPageData,
                    PTCHAR                    MachineName,
                    HANDLE                    MachineHandle
                   )
{
    #define WmiConfigClassesText TEXT("WmiConfigClasses")
        
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    TCHAR ClassListStatic[MAX_PATH];
    TCHAR *ClassList, *DeviceList;
    ULONG Status, Size, ClassListSize, DeviceListSize;
    ULONG RegType;
    HKEY hKeyDev, hKeyClass;
    BOOLEAN PageAdded;    
    PPAGE_INFO ppi;
    TCHAR *s;
    IWbemServices *pIWbemServices;
    PTCHAR InstanceName;
    PTCHAR ClassName;
    ULONG PageIndex;
    PUCHAR Ptr;
    CHAR ss[MAX_PATH];
    PTCHAR ClassListEnd;

    DebugPrint((1, "WMI: Enter WmiPropPageProvider(%p, %p, %p) \n",
                        deviceInfoSet,
                deviceInfoData,
                AddPPageData));
   
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    PageAdded = FALSE;

    //
    // Get List of classes from registry. It should be in the 
    // WmiConfigClasses value under class specific key
    // HKLM\CurrentControlSet\Control\CLASS\<ClassGuid>
    // key.
    //
    ClassList = ClassListStatic;
    Size = sizeof(ClassListStatic);
    *ClassList = 0;
    
    hKeyClass = SetupDiOpenClassRegKeyEx(&deviceInfoData->ClassGuid,
                                      KEY_READ,
                                      DIOCR_INSTALLER,
                                      MachineName,
                                      NULL);
    if (hKeyClass != NULL)
    {
        Status = RegQueryValueEx(hKeyClass,
                                 WmiConfigClassesText,
                                 NULL,
                                 &RegType,
                                 (PUCHAR)ClassList,
                                 &Size);
        
        if (Status == ERROR_MORE_DATA)
        {
            //
            // The class list is bigger than we though so allocate room
            // for the bigger class list and extra room for the device
            // list
            //
            Size = 2*(Size + sizeof(WCHAR));
            ClassList = (PTCHAR)LocalAlloc(LPTR, Size);
            if (ClassList != NULL)
            {
                Status = RegQueryValueEx(hKeyClass,
                                         WmiConfigClassesText,
                                         NULL,
                                         &RegType,
                                         (PUCHAR)ClassList,
                                         &Size);
            } else {
                //
                // We couldn't alloc memory for the class list so we
                // forget about it
                //
                Status = ERROR_NOT_ENOUGH_MEMORY;
                ClassList = ClassListStatic;
                Size = sizeof(ClassListStatic);
                *ClassList = 0;
            }
        }
               
        RegCloseKey(hKeyClass);
    } else {
        Status = ERROR_INVALID_PARAMETER;
        DebugPrint((1, "WMIPROP: Could not open class key for %s --> %d\n",
                    WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                    GetLastError()));
    }

    //
    // Compute size and location of device list
    //
    if ((Status == ERROR_SUCCESS) && (RegType == REG_SZ))
    {
        if (*ClassList != 0)
        {
            //
            // If there is a class be sure to add a , at the end to
            // aid in parsing
            //
            _tcscat(ClassList, TEXT(","));
        }

        //
        // Compute location to append the device class list
        //
        ClassListSize = _tcslen(ClassList) * sizeof(TCHAR);
        DeviceList = (PTCHAR)((PUCHAR)ClassList + ClassListSize);
        WmiAssert(*DeviceList == 0);
        DeviceListSize = Size - ClassListSize;
    } else {
        ClassListSize = 0;
        DeviceList = ClassList;
        DeviceListSize = Size;
        DebugPrint((1, "WMIPROP: Query for class list in class key %s failed %d\n",
                    WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                    Status));
    }   

    
    //
    // Get List of classes from registry. It should be in the 
    // WmiConfigClasses value under device specific key
    // HKLM\CurrentControlSet\Control\CLASS\<ClassGuid>\<inst id>
    // key.
    //
    hKeyDev = SetupDiCreateDevRegKey(deviceInfoSet,
                               deviceInfoData,
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DRV,
                               NULL,
                               NULL);
    
    if (hKeyDev != (HKEY)INVALID_HANDLE_VALUE)
    {
        Size = DeviceListSize;
        Status = RegQueryValueEx(hKeyDev,
                                 WmiConfigClassesText,
                                 NULL,
                                 &RegType,
                                 (PUCHAR)DeviceList,
                                 &Size);
        
        if (Status == ERROR_MORE_DATA)
        {
            //
            // Not enough room for the device list so allocate enough
            // memory for the class and device lists combined and copy
            // the class list into the new buffer
            //
            Ptr = (PUCHAR)LocalAlloc(LPTR, Size+ClassListSize);
            if (Ptr != NULL)
            {
                memcpy(Ptr, ClassList, ClassListSize);

                if (ClassList != ClassListStatic)
                {
                    LocalFree(ClassList);
                }
                ClassList = (PTCHAR)Ptr;

                DeviceList = (PTCHAR)(Ptr + ClassListSize);
                WmiAssert(*DeviceList == 0);
                Status = RegQueryValueEx(hKeyDev,
                                         WmiConfigClassesText,
                                         NULL,
                                         &RegType,
                                         (PUCHAR)DeviceList,
                                         &Size);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        
        RegCloseKey(hKeyDev);
        
        if ((Status != ERROR_SUCCESS) || (RegType != REG_SZ))
        {
            *DeviceList = 0;
            DebugPrint((1, "WMIPROP: Query for class list in class key %s failed %d\n",
                         WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                        Status));
        }
    }
        
    if (*ClassList != 0)
    {
        //
        // Establish connection to WBEM and obtain information 
        // about the class whose properties are being acted upon
        //
        if (WmiConnectToWbem(MachineName, &pIWbemServices))
        {
            WmiAssert(pIWbemServices != NULL);
                
            //
            // Get WMI InstanceName for device
            //
            InstanceName = WmiGetDeviceInstanceName(deviceInfoSet,
                                                    deviceInfoData,
                                                    MachineHandle);
            if (InstanceName != NULL)
            {
                //
                // Loop over all classes specified and create property
                // page for each one
                //
                DebugPrint((1, "WMIPROP: Setup propsheets for %ws for classlist %ws\n",
                                InstanceName,
                                ClassList));
                s  = ClassList;
                do 
                {
                    ClassListEnd = s;
                    ClassName = WmiGetNextClass(&s);
                    if (ClassName != NULL)
                    {
                        if (*ClassName != 0)
                        {
                            if (! WmiIsDuplicateClass(ClassName,
                                                      ClassList,
                                                      ClassListEnd))
                            {
                                //
                                // create property page data structure
                                // that corresponds to this class
                                //
                                DebugPrint((1, "WMIPROP: Parsing class %ws for instance %ws\n",
                                        ClassName, InstanceName));
                                ppi = WmiCreatePageInfo(MachineName,
                                                        pIWbemServices,
                                                        ClassName,
                                                        InstanceName,
                                                        deviceInfoSet,
                                                        deviceInfoData);
                                if (ppi != NULL)
                                {
                                    hpsp = WmiCreatePropertyPage(
                                        &psp,
                                        ppi,
                                        ppi->ConfigClass.DataBlockDesc->DisplayName ? 
                                        ppi->ConfigClass.DataBlockDesc->DisplayName :
                                        ClassName);

                                    if (hpsp != NULL) 
                                    {   
                                        //
                                        // Add the sheet into the list
                                        //
                                        PageIndex = AddPPageData->NumDynamicPages;
                                        if (PageIndex < MAX_INSTALLWIZARD_DYNAPAGES)
                                        {
                                            AddPPageData->NumDynamicPages++;
                                            AddPPageData->DynamicPages[PageIndex] = hpsp;
                                            PageAdded = TRUE;
                                        } else {
                                            DebugPrint((1, "WMIPROP: Can add page, already %d pages",
                                                        PageIndex));                                            
                                        }
                                    } else {
                                        WmiFreePageInfo(ppi);
                                    }
                                }
                            }
                        }
                        LocalFree(ClassName);
                    }
                } while (ClassName != NULL);
                LocalFree(InstanceName);
            } else {
                DebugPrint((1, "WMIPROP: Unable to get instance name\n"));
            }
                
            //
            // We release the interface rather than holding it 
            // since it cannot be used in a different thread and 
            // we'll be running in a different thread later.
            //
            pIWbemServices->Release();
        } else {
            DebugPrint((1, "WMIPROP: Unable to connect to wbem\n"));
        }
    }

    if (ClassList != ClassListStatic)
    {
        LocalFree(ClassList);
    }
    
    DebugPrint((1, "WMI: Leave %s WmiPropPageProvider(%p, %p, %p) \n",
                PageAdded ? "TRUE" : "FALSE",
                        deviceInfoSet,
                deviceInfoData,
                AddPPageData));
   
    
    return(PageAdded);
}

UINT CALLBACK
WmiDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp)
{
    PPAGE_INFO ppi;

    DebugPrint((1, "WMI: Enter WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
    switch (uMsg) {
    case PSPCB_CREATE:
        DebugPrint((1, "WMI: Leave TRUE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) ppsp->lParam;
        WmiDestroyPageInfo(&ppi);

        DebugPrint((1, "WMI: Leave FALSE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
        return 0;       // return value ignored

    default:
        break;
    }

    DebugPrint((1, "WMI: Leave TRUE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
    return TRUE;
}

BOOLEAN WmiGetDataItemValue(
    IN PDATA_ITEM_DESCRIPTION DataItemDesc,
    OUT ULONG64 *DataValue
    )
{
    ULONG64 ReturnValue;
    BOOLEAN ReturnStatus = TRUE;
    BOOLEAN IsArray;
    ULONG Index;

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);
    Index = DataItemDesc->CurrentArrayIndex;
    
    switch(DataItemDesc->DataType)
    {
        case CIM_SINT8:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint8Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint8;
            }
            break;
        }
                    
        case CIM_UINT8:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint8Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint8;
            }
            break;
        }

        case CIM_SINT16:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint16Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint16;
            }
            break;
        }
                                                                        
        case CIM_UINT16:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint16Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint16;
            }
            break;
        }
                                                                        
        case CIM_SINT32:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint32Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint32;
            }
            break;
        }
                                                
        case CIM_UINT32:                        
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint32Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint32;
            }
            break;
        }
                                                
        case CIM_SINT64:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint64Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint64;
            }
            break;
        }
                                                
        case CIM_UINT64:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint64Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint64;
            }
            break;
        }
                        
        case CIM_BOOLEAN:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->boolArray[Index] == 0 ? 0 : 1;
            } else {
                ReturnValue = DataItemDesc->boolval == 0 ? 0 : 1;
            }
            break;
        }
                        
        case CIM_REAL32:
        case CIM_REAL64:
        default:
        {
            WmiAssert(FALSE);
            ReturnStatus = FALSE;
            ReturnValue = 0;
        }
        
    }
    *DataValue = ReturnValue;
    return(ReturnStatus);
}

BOOLEAN WmiSetDataItemValue(
    IN PDATA_ITEM_DESCRIPTION DataItemDesc,
    IN ULONG64 DataValue
    )
{
    BOOLEAN ReturnStatus = TRUE;
    BOOLEAN IsArray;
    ULONG Index;
    
    WmiAssert(DataItemDesc != NULL);

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);
    Index = DataItemDesc->CurrentArrayIndex;
    
    switch(DataItemDesc->DataType)
    {
        case CIM_SINT8:
        {
            if (IsArray)
            {
                DataItemDesc->sint8Array[Index] = (CHAR)DataValue;
            } else {
                DataItemDesc->sint8 = (CHAR)DataValue;
            }
            break;
        }
                    
        case CIM_UINT8:
        {
            if (IsArray)
            {
                DataItemDesc->uint8Array[Index] = (UCHAR)DataValue;
            } else {
                DataItemDesc->uint8 = (UCHAR)DataValue;
            }
            break;
        }

        case CIM_SINT16:
        {
            if (IsArray)
            {
                DataItemDesc->sint16Array[Index] = (SHORT)DataValue;
            } else {
                DataItemDesc->sint16 = (SHORT)DataValue;
            }
            break;
        }
                                                                        
        case CIM_UINT16:
        {
            if (IsArray)
            {
                DataItemDesc->uint16Array[Index] = (USHORT)DataValue;
            } else {
                DataItemDesc->uint16 = (USHORT)DataValue;
            }
            break;
        }
                                                                        
        case CIM_SINT32:
        {
            if (IsArray)
            {
                DataItemDesc->sint32Array[Index] = (LONG)DataValue;
            } else {
                DataItemDesc->sint32 = (LONG)DataValue;
            }
            break;
        }
                                                
        case CIM_UINT32:                        
        {
            if (IsArray)
            {
                DataItemDesc->uint32Array[Index] = (ULONG)DataValue;
            } else {
                DataItemDesc->uint32 = (ULONG)DataValue;
            }
            break;
        }
                                                
        case CIM_SINT64:
        {
            if (IsArray)
            {
                DataItemDesc->sint64Array[Index] = (LONG64)DataValue;
            } else {
                DataItemDesc->sint64 = (LONG64)DataValue;
            }
            break;
        }
                                                
        case CIM_UINT64:
        {
            if (IsArray)
            {
                DataItemDesc->uint64Array[Index] = DataValue;
            } else {
                DataItemDesc->uint64 = DataValue;
            }
            break;
        }

        case CIM_BOOLEAN:
        {
            if (IsArray)
            {
                DataItemDesc->boolArray[Index] = (DataValue == 0) ? 0 : 1;
            } else {
                DataItemDesc->boolval = (DataValue == 0) ? 0 : 1;
            }
            break;
        }
                        
        case CIM_REAL32:
        case CIM_REAL64:
        default:
        {
            WmiAssert(FALSE);
            ReturnStatus = FALSE;
        }
        
    }
    return(ReturnStatus);
}


void WmiRefreshDataItemToControl(
    HWND hDlg,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    BOOLEAN FullUpdate
    )
{
    HWND hWnd;
    BOOLEAN IsReadOnly, IsArray;
    PTCHAR v;
    
    WmiAssert(hDlg != NULL);
    WmiAssert(DataItemDesc != NULL);

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);

    if (FullUpdate)
    {
        //
        // This code is run when we switch from one property to another
        // property
        //
        if (DataItemDesc->Description != NULL)
        {
            hWnd = GetDlgItem(hDlg, IDC_DESCRIPTION_TEXT);
            if (hWnd != NULL)
            {
                SendMessage(hWnd,
                            WM_SETTEXT,
                            0,
                            (LPARAM)DataItemDesc->Description);
                ShowWindow(hWnd, SW_SHOW);
            }
        }
    }

    if ((DataItemDesc->ValidationFunc == WmiStringValidation) ||
        (DataItemDesc->ValidationFunc == WmiDateTimeValidation) )
    {
        ULONG64 DataItemValue;
        TCHAR s[MAX_PATH];

        hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);

        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ?  FALSE : TRUE);

        if (IsArray)
        {
            v = DataItemDesc->StringArray[DataItemDesc->CurrentArrayIndex];
        } else {
            v = DataItemDesc->String;
        }

        if (hWnd != NULL)
        {
            WmiAssert(DataItemDesc->String != NULL);
            SendMessage(hWnd,
                        WM_SETTEXT,
                        0,
                        (LPARAM)v);
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiRangeValidation) {
        ULONG64 DataItemValue;
        TCHAR s[MAX_PATH];
        PTCHAR FormatString;
        ULONG FormatStringIndex;
        static PTCHAR FormatStringList[8] = { TEXT("%lu"),
                                              TEXT("%ld"),
                                              TEXT("0x%lx"),
                                              TEXT("0x%lx"),
                                              TEXT("%I64u"),
                                              TEXT("%I64d"),
                                              TEXT("0x%I64x"),
                                              TEXT("0x%I64x") };

        hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);

        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ? FALSE : TRUE);

        if (hWnd != NULL)
        {
            if (WmiGetDataItemValue(DataItemDesc, &DataItemValue))
            {
                FormatStringIndex = DataItemDesc->DisplayInHex * 2 +
                                    DataItemDesc->IsSignedValue;
                if ((DataItemDesc->DataType == CIM_SINT64) ||
                    (DataItemDesc->DataType == CIM_UINT64))
                {
                    FormatStringIndex += 4;
                }
                
                FormatString = FormatStringList[FormatStringIndex];

                wsprintf(s, 
                         FormatString,
                         DataItemValue);
                SendMessage(hWnd,
                                WM_SETTEXT,
                                0,
                                (LPARAM)s);
            }
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiValueMapValidation) {
        PENUMERATIONINFO EnumerationInfo;
        ULONG j;
        ULONG64 DataItemValue;

        hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);

        if (hWnd != NULL)
        {
            EnumerationInfo = DataItemDesc->EnumerationInfo;
            WmiAssert(EnumerationInfo != NULL);

            SendMessage(hWnd,
                        CB_RESETCONTENT,
                        0,
                        0);

            for (j = 0; j < EnumerationInfo->Count; j++)
            {
                WmiAssert(EnumerationInfo->List[j].Text != NULL);
                SendMessage(hWnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM)EnumerationInfo->List[j].Text);
            }
            ShowWindow(hWnd, SW_SHOW);
            EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ?
                                                      FALSE : TRUE);

            if (WmiGetDataItemValue(DataItemDesc, &DataItemValue))
            {
                for (j = 0; j < EnumerationInfo->Count; j++)
                {
                    if (DataItemValue == EnumerationInfo->List[j].Value)
                    {
                        SendMessage(hWnd,
                                        CB_SETCURSEL,
                                        (WPARAM)j,
                                        0);
                        break;
                    }
                }
            }
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation) {
        hWnd = GetDlgItem(hDlg, IDC_DATA_BUTTON);
        if (hWnd != NULL)
        {
            SendMessage(hWnd,
                        WM_SETTEXT,
                        0,
                        (LPARAM) (DataItemDesc->DisplayName ? 
                                           DataItemDesc->DisplayName :
                                           DataItemDesc->Name));
            ShowWindow(hWnd, SW_SHOW);
            EnableWindow(hWnd, TRUE);

        } else {
            WmiAssert(FALSE);
        }
    } else {
        WmiAssert(FALSE);
    }

    if (FullUpdate)
    {
        if (IsArray)
        {
            TCHAR s[MAX_PATH];

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
            if (hWnd != NULL)
            {
                SendMessage(hWnd,
                            UDM_SETRANGE32,
                            (WPARAM)1,
                            (LPARAM)DataItemDesc->ArrayElementCount);

                DebugPrint((1, "WMIPROP: SetPos32 -> %d\n",
                                DataItemDesc->CurrentArrayIndex+1));
                SendMessage(hWnd,
                            UDM_SETPOS32,
                            (WPARAM)0,
                            (LPARAM)DataItemDesc->CurrentArrayIndex+1);

                ShowWindow(hWnd, SW_SHOW);
            }

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_SHOW);
            }

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_STATIC);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_SHOW);
            }
        }
    }
}

void
WmiRefreshDataBlockToControls(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN FullUpdate
    )
{
    ULONG i;
 
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(DataBlockDesc->CurrentDataItem < DataBlockDesc->DataItemCount);

    WmiHideAllControls(hDlg, FALSE, FullUpdate);
    WmiRefreshDataItemToControl(hDlg,
                                &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem],
                                FullUpdate);
}


void
WmiInitializeControlsFromDataBlock(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsEmbeddedClass
    )
{
    HWND hWnd, hWndBuddy;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    ULONG i;
    BSTR s;
    int ShowOrHide;
    BOOLEAN IsReadOnly;
        
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);

    WmiHideAllControls(hDlg, TRUE, TRUE);
    
    hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
    if (hWnd != NULL)
    {
        SendMessage(hWnd,
                    LB_RESETCONTENT,
                    0,
                    0);

        for (i = 0; i < DataBlockDesc->DataItemCount; i++)
        {
            DataItemDesc = &DataBlockDesc->DataItems[i];
            SendMessage(hWnd,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) (DataItemDesc->DisplayName ? 
                                           DataItemDesc->DisplayName :
                                           DataItemDesc->Name));
        }
        
        SendMessage(hWnd,
                    LB_SETCURSEL,
                    (WPARAM)DataBlockDesc->CurrentDataItem,
                    0);


        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, TRUE);
        
        //
        // Refresh data from wbem and if successful update the controls
        //

        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      TRUE);
        
    }

    ShowOrHide = IsEmbeddedClass ? SW_SHOW : SW_HIDE;
    
    hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_OK);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, ShowOrHide);
    }

    hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_CANCEL);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, ShowOrHide);
    }

    hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
    if (hWnd != NULL)
    {
        hWndBuddy = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
        SendMessage(hWnd,
                    UDM_SETBUDDY,
                    (WPARAM)hWndBuddy,
                    0);
    }
}


BOOLEAN WmiReconnectToWbem(
    PCONFIGCLASS ConfigClass,
    IWbemClassObject **pInstance
    )
{
    BOOLEAN ReturnStatus;
    IWbemClassObject *pIWbemClassObject;
    IWbemServices *pIWbemServices;
    HRESULT hr;
    BSTR s;
    
    WmiAssert(ConfigClass != NULL);
    
    //
    // Reestablish our interfaces to WBEM now that we are on the
    // window message thread
    //
    ReturnStatus = FALSE;
    if (WmiConnectToWbem(ConfigClass->MachineName,
                         &pIWbemServices))
    {
        ConfigClass->pIWbemServices = pIWbemServices;
        s = SysAllocString(ConfigClass->RelPath);
        if (s != NULL)
        {
            pIWbemClassObject = NULL;
            hr = pIWbemServices->GetObject(s,
                                           WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                           NULL,
                                           &pIWbemClassObject,
                                           NULL);
            if (hr == WBEM_S_NO_ERROR)
            {
                *pInstance = pIWbemClassObject;
                ReturnStatus = TRUE;
            } else {
                DebugPrint((1, "WMIPROP: Error %x reestablishing IWbemClassObject to instance for %ws\n",
                             hr, ConfigClass->RelPath));
            }
            SysFreeString(s);
        }
    }                 
        
    return(ReturnStatus);
}

void WmiHideAllControls(
    HWND hDlg,
    BOOLEAN HideEmbeddedControls,
    BOOLEAN HideArrayControls                       
    )
{
    HWND hWnd;
    
    WmiAssert(hDlg != NULL);
    
    hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_CHECK);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_BUTTON);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_ARRAY_EDIT);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    if (HideArrayControls)
    {
        hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_ARRAY_STATIC);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }
    }

    if (HideEmbeddedControls)
    {
        hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_OK);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_CANCEL);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }
    }
}

void
WmiInitializeDialog(
    PPAGE_INFO   ppi,
    HWND         hDlg
    )
{
    PCONFIGCLASS ConfigClass;
    HWND hWnd;
    BOOLEAN ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    ConfigClass = &ppi->ConfigClass;
    
    ReturnStatus = FALSE;
    if (WmiReconnectToWbem(ConfigClass,
                           &ConfigClass->DataBlockDesc->pInstance))
    {
        if (WmiRefreshDataBlockFromWbem( ConfigClass->DataBlockDesc->pInstance,
                                         ConfigClass->DataBlockDesc))
        {
            WmiInitializeControlsFromDataBlock(hDlg,
                                               ConfigClass->DataBlockDesc,
                                               FALSE);
            hWnd = GetDlgItem(hDlg, IDC_WMI_CONNECT_ERR);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_HIDE);
            }
            ReturnStatus = TRUE;
        }
    }
        
    if (! ReturnStatus)
    {
        //
        // Hide all controls except for a static string that says we cannot
        // connect to wbem.
        //
        hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        WmiHideAllControls(hDlg, TRUE, TRUE);
        hWnd = GetDlgItem(hDlg, IDC_WMI_CONNECT_ERR);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_SHOW);
        }
    }
}


BOOLEAN WmiGetControlText(
    HWND hWnd,
    PTCHAR *Text
)
{
    ULONG SizeNeeded;
    BOOLEAN ReturnStatus = FALSE;
    ULONG CharNeeded, CharCopied;
    
    WmiAssert(hWnd != NULL);
    WmiAssert(Text != NULL);
    
    CharNeeded = (ULONG)SendMessage(hWnd,
                             WM_GETTEXTLENGTH,
                             0,
                             0);
    if (CharNeeded > 0)
    {
        SizeNeeded = (++CharNeeded) * sizeof(TCHAR);
        *Text = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
        if (*Text != NULL)
        {
            CharCopied = (ULONG)SendMessage(hWnd,
                                     WM_GETTEXT,
                                     CharNeeded,
                                     (LPARAM)*Text);
            ReturnStatus = TRUE;
        }
    }
    return(ReturnStatus);
}

void WmiValidationError(
    HWND hWnd,
    PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    TCHAR buf[MAX_PATH];
    TCHAR buf2[MAX_PATH];
    ULONG Bytes;
    
    //
    // TODO: Do a better job of informing the user
    //
    
    
    //
    // Get the string template for the error message
    //
    Bytes = LoadString(g_hInstance, 
                       IDS_WMI_VALIDATION_ERROR, 
                       buf, 
                       MAX_PATH);
    wsprintf(buf2, buf, DataItemDesc->Name);
    MessageBox(hWnd, buf2, NULL, MB_ICONWARNING);
}

BOOLEAN WmiRefreshDataItemFromControl(
    HWND hDlg,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    PBOOLEAN UpdateValues
    )
{
    HWND hWnd;
    BOOLEAN ReturnStatus;
 
    WmiAssert(hDlg != NULL);
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(UpdateValues != NULL);
    
    ReturnStatus = TRUE;
    *UpdateValues = FALSE;
    if (DataItemDesc->IsReadOnly == 0)
    {
        //
        // Property is not read only so see what we need to update
        //
        if (DataItemDesc->ValidationFunc == WmiValueMapValidation)
        {
            //
            // if a value map or enumeration then we get the current
            // location and then lookup the corresponding value to
            // set
            //
            ULONG CurSel;
            ULONG64 EnumValue;
                    
            hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);
            if (hWnd != NULL)
            {                    
                CurSel = (ULONG)SendMessage(hWnd,
                                     CB_GETCURSEL,
                                     0,
                                     0);
                                     
                if (CurSel != CB_ERR)
                {
                    if (CurSel < DataItemDesc->EnumerationInfo->Count)
                    {
                        EnumValue = DataItemDesc->EnumerationInfo->List[CurSel].Value;
                        WmiSetDataItemValue(DataItemDesc,
                                            EnumValue);
                        
                        *UpdateValues = TRUE;
                    } else {
                        WmiAssert(FALSE);
                    }
                }
            } else {
                WmiAssert(FALSE);
            }
        } else {
            //
            // All of the rest of the validation types are based
            // upon the contents of the edit box, so get the value
            // from there
            //
            PTCHAR Text;
            ULONG64 Number;
                    
            hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);
            if (hWnd != NULL)
            {
                if (WmiGetControlText(hWnd,
                                      &Text))
                {
                    if (DataItemDesc->ValidationFunc == WmiRangeValidation) {
                        if (WmiValidateRange(DataItemDesc, &Number, Text))
                        {
                            WmiSetDataItemValue(DataItemDesc,
                                                Number);
                        
                            *UpdateValues = TRUE;
                        } else {
                            //
                            // Validation failed, go tell user
                            //
                             WmiValidationError(hDlg, DataItemDesc);
                             ReturnStatus = FALSE;
                        }
                    } else if (DataItemDesc->ValidationFunc == WmiDateTimeValidation) {
                        if (WmiValidateDateTime(DataItemDesc, Text))
                        {
                            DataItemDesc->DateTime = Text;
                            Text = NULL;
                            *UpdateValues = TRUE;
                        } else {
                            //
                            // Validation failed, go tell user
                            //
                            WmiValidationError(hDlg, DataItemDesc);
                            ReturnStatus = FALSE;
                        }
                    } else if (DataItemDesc->ValidationFunc == WmiStringValidation) {
                        DataItemDesc->String = Text;
                        Text = NULL;
                        *UpdateValues = TRUE;
                    }
                                    
                    if (Text != NULL)
                    {
                        LocalFree(Text);
                    }
                }
            } else {
                WmiAssert(FALSE);
            }
        }
    }    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataBlockFromControls(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    PBOOLEAN UpdateValues
    )
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN UpdateItem, ReturnStatus;
    
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(UpdateValues != NULL);

    *UpdateValues = FALSE;
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];
        
    //
    // We are not going to worry about failures from this function
    // so we'll just use the previous values in the function
    //
    ReturnStatus = WmiRefreshDataItemFromControl(hDlg,
                                  DataItemDesc,
                                  &UpdateItem);
    if (ReturnStatus && UpdateItem)
    {
        *UpdateValues = TRUE;
        DataBlockDesc->UpdateClass = TRUE;
    }
    
    return(ReturnStatus);
}

void WmiPushIntoEmbeddedClass(
    HWND hDlg,
    PPAGE_INFO ppi,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;

    WmiAssert(ppi != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];
    
    if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation)
    {
        //
        // The property is an embedded class so all we need to do
        // is to change the controls to our embededded class
        //
        DataBlockDesc = DataItemDesc->DataBlockDesc;
        WmiAssert(DataBlockDesc != NULL);
        DataBlockDesc->UpdateClass = FALSE;

        if ((DataItemDesc->IsVariableArray) ||
            (DataItemDesc->IsFixedArray))
        {
            DataBlockDesc->pInstance = DataItemDesc->pIWbemClassObjectArray[DataItemDesc->CurrentArrayIndex];
        } else {
            DataBlockDesc->pInstance = DataItemDesc->pIWbemClassObject;
        }
        DataBlockDesc->pInstance->AddRef();
        
        WmiRefreshDataBlockFromWbem(DataBlockDesc->pInstance,
                                    DataBlockDesc);
                                    
        ppi->ConfigClass.DataBlockDesc = DataBlockDesc;
    } else {
        WmiAssert(FALSE);
    }   
}

void WmiPopOutEmbeddedClass(
    HWND hDlg,
    PPAGE_INFO ppi,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN SaveChanges
    )
{    
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;

    ParentDataBlockDesc = DataBlockDesc->ParentDataBlockDesc;
    WmiAssert(ParentDataBlockDesc != NULL);

    if ((SaveChanges) && (DataBlockDesc->UpdateClass))
    {
        //
        // Copy the properties for the data block back into WBEM
        //
        WmiRefreshWbemFromDataBlock(ppi->ConfigClass.pIWbemServices,
                                    DataBlockDesc->pInstance,
                                    DataBlockDesc,
                                    TRUE);
        ParentDataBlockDesc->UpdateClass = TRUE;
    }

    DataBlockDesc->pInstance->Release();
    DataBlockDesc->pInstance = NULL;
                                
    ppi->ConfigClass.DataBlockDesc = ParentDataBlockDesc;   
}

void WmiButtonSelected(
    HWND hDlg,
    PPAGE_INFO ppi,
    ULONG ControlId
    )
{
    BOOLEAN UpdateValues, ReturnStatus;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    
    WmiAssert(ppi != NULL);
    
    if (ControlId == IDC_DATA_BUTTON)
    {
        DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        WmiAssert(DataBlockDesc != NULL);
        
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateValues);

        if (ReturnStatus)
        {
            WmiPushIntoEmbeddedClass(hDlg,
                                     ppi,
                                     DataBlockDesc);

            WmiInitializeControlsFromDataBlock(hDlg,
                                               ppi->ConfigClass.DataBlockDesc,
                                               TRUE);
        } else {
            WmiRefreshDataBlockToControls(hDlg,
                                          DataBlockDesc,
                                          FALSE);
        }
    }
}

void WmiButtonEmbeddedOk(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;
    BOOLEAN UpdateValues, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                    DataBlockDesc,
                                    &UpdateValues);

    if (ReturnStatus)
    {
        WmiPopOutEmbeddedClass(hDlg,
                               ppi,
                               DataBlockDesc,
                               TRUE);

        ParentDataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        WmiAssert(ParentDataBlockDesc != NULL);
        WmiInitializeControlsFromDataBlock(hDlg, 
                                           ParentDataBlockDesc, 
                           (ParentDataBlockDesc->ParentDataBlockDesc != NULL));
    } else {
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
}

void WmiButtonEmbeddedCancel(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;
    BOOLEAN UpdateValues, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    WmiPopOutEmbeddedClass(hDlg,
                               ppi,
                               DataBlockDesc,
                               FALSE);

    ParentDataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(ParentDataBlockDesc != NULL);
    WmiInitializeControlsFromDataBlock(hDlg, 
                                           ParentDataBlockDesc, 
                           (ParentDataBlockDesc->ParentDataBlockDesc != NULL));
}

BOOLEAN
WmiApplyChanges(
    PPAGE_INFO ppi,
    HWND       hDlg
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    IWbemClassObject *pIWbemClassObject;
    BOOLEAN UpdateClass, ReturnStatus;
    IWbemServices *pIWbemServices;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    pIWbemServices =  ppi->ConfigClass.pIWbemServices;
            
    ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                    DataBlockDesc,
                                    &UpdateClass);

    if (ReturnStatus)
    {
        //
        // Pop out of embedded classes to the root class
        //
        while (DataBlockDesc->ParentDataBlockDesc != NULL)
        {
            WmiPopOutEmbeddedClass(hDlg,
                                   ppi,
                                   DataBlockDesc,
                                   TRUE);
            DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        }


        //
        // Now we are at the root class so save that
        //
        if (DataBlockDesc->UpdateClass)
        {
            WmiRefreshWbemFromDataBlock(pIWbemServices,
                                        DataBlockDesc->pInstance,
                                        DataBlockDesc,
                                        FALSE);
            UpdateClass = TRUE;
        }

        DataBlockDesc->pInstance->Release();
        DataBlockDesc->pInstance = NULL;
    } else {
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
    
    return(ReturnStatus);
}

INT_PTR WmipDataItemSelectionChange(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    HWND hWnd;
    BOOLEAN UpdateClass, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
    if (hWnd != NULL)
    {
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateClass);

        if (UpdateClass)
        {
            DataBlockDesc->UpdateClass = TRUE;
        }

        //
        // New value for data item is ok, refresh display with new
        // data item
        //
        DataBlockDesc->CurrentDataItem = (ULONG)SendMessage(hWnd,
                                                     LB_GETCURSEL,
                                                     0,
                                                     0);
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      TRUE);
    }
    
    return(0);
}

void WmiSetArrayIndex(
    HWND hDlg,
    PPAGE_INFO ppi,
    int NewIndex
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    HWND hWnd;
    BOOLEAN UpdateClass, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DebugPrint((1, "WMIPROP: Set index to %d\n", NewIndex));
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];

    if ((ULONG)NewIndex < DataItemDesc->ArrayElementCount)
    {
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateClass);

        if (UpdateClass)
        {
            DataBlockDesc->UpdateClass = TRUE;
        }

        DataItemDesc->CurrentArrayIndex = NewIndex;

        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
}

INT_PTR WmiControlColorStatic(
    HDC DC,
    HWND HStatic
    )
{
    UINT id = GetDlgCtrlID(HStatic);
    UINT ControlType;

    //
    // WM_CTLCOLORSTATIC is sent for the edit controls because they are read 
    // only
    //
    if ((id == IDC_DATA_CHECK) ||
        (id == IDC_DATA_BUTTON))
    {
        SetBkColor(DC, GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    }

    return FALSE;
    
}

INT_PTR APIENTRY
WmiDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam)
{
    PPAGE_INFO ppi;
    BOOLEAN ReturnStatus;

    DebugPrint((7, "WMI: Enter WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                hDlg, uMessage, wParam, lParam));
    
    ppi = (PPAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) {
    case WM_INITDIALOG:

        //
        // on WM_INITDIALOG call, lParam points to the property
        // sheet page.
        //
        // The lParam field in the property sheet page struct is set by the
        // caller. When I created the property sheet, I passed in a pointer
        // to a struct containing information about the device. Save this in
        // the user window long so I can access it on later messages.
        //
        ppi = (PPAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) ppi);

        //
        // Initialize dlg controls
        //
        WmiInitializeDialog(ppi,
                            hDlg);

        //
        // Didn't set the focus to a particular control.  If we wanted to,
        // then return FALSE
        //
        DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   
   
        return TRUE;

    case WM_COMMAND:

        if (HIWORD(wParam) == LBN_SELCHANGE)
        {
            WmipDataItemSelectionChange(hDlg, ppi);
            return(TRUE);
        }

        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
           PropSheet_Changed(GetParent(hDlg), hDlg);
           DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   

           return TRUE;
        }

        switch (wParam)
        {
            case IDC_DATA_BUTTON:
            {
                WmiButtonSelected(hDlg, ppi, (ULONG)wParam);
                break;
            }
        
            case IDC_WMI_EMBEDDED_OK:
            {
                WmiButtonEmbeddedOk(hDlg, ppi);
                break;
            }

            case IDC_WMI_EMBEDDED_CANCEL:
            {
                WmiButtonEmbeddedCancel(hDlg, ppi);
                break;
            }
        }

#if 0
        //
        // Add this code back in if we will need it
        //
        switch(LOWORD(wParam)) {

        default:
            break;
        }
#endif 
        break;

    case WM_CONTEXTMENU:
        DebugPrint((7, "WMI: Leave ? WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   
   
        return WmiContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        WmiHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_CTLCOLORSTATIC:
        return WmiControlColorStatic((HDC)wParam, (HWND)lParam);
        
    case WM_NOTIFY:

        switch (((NMHDR *)lParam)->code) {

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            //
            // Do what ever action is necessary
            //
            ReturnStatus = WmiApplyChanges(ppi,
                            hDlg);

            if (ReturnStatus)
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                            hDlg, uMessage, wParam, lParam));
            }

            SetWindowLong(hDlg,
                          DWLP_MSGRESULT, ReturnStatus ?
                                            PSNRET_NOERROR : PSNRET_INVALID);

            return(TRUE);

        case UDN_DELTAPOS:
        {
            LPNMUPDOWN UpDown = (LPNMUPDOWN)lParam;
            
            //
            // Array spinner has changed. Note that it is biased +1 as
            // compared with the array index
            //
            DebugPrint((1, "WMIPROP: iPos = %d, iDelta = %d\n",
                             UpDown->iPos, UpDown->iDelta));
            
            WmiSetArrayIndex(hDlg,
                             ppi,
                             UpDown->iPos + UpDown->iDelta - 1);
            
            return(TRUE);
        }
            
        default:
            break;
        }

        break;
   }

   SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

   DebugPrint((7, "WMI: Leave FALSE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                hDlg, uMessage, wParam, lParam));   
   
   return FALSE;
}

void
WmiUpdate (PPAGE_INFO ppi,
           HWND       hDlg)
{
}

BOOL
WmiContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    return FALSE;
}

void
WmiHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
}

//
// Debug support
//
#if DBG

#include <stdio.h>          // for _vsnprintf
ULONG WmiDebug = 0;
CHAR WmiBuffer[DEBUG_BUFFER_LENGTH];


VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for properties pages - stolen from classpnp\class.c

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (WmiDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & WmiDebug)) {

        _vsnprintf(WmiBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        OutputDebugStringA(WmiBuffer);
    }

    va_end(ap);

} // end WmiDebugPrint()

#else

//
// WmiDebugPrint stub
//

VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
}

#endif // DBG


HRESULT DifAddPropertyPageAdvanced(
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN     PTCHAR                    MachineName,
    IN     HANDLE                    MachineHandle
    )
{
    SP_ADDPROPERTYPAGE_DATA AddPropertyPageData;
    BOOL b, PageAdded;

    memset(&AddPropertyPageData, 0, sizeof(SP_ADDPROPERTYPAGE_DATA));
    AddPropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    
    b = SetupDiGetClassInstallParams(DeviceInfoSet, DeviceInfoData,
                             (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                             sizeof(SP_ADDPROPERTYPAGE_DATA), NULL );
    if (b)
    {
        if (AddPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
        {
            PageAdded = WmiPropPageProvider(DeviceInfoSet,
                                            DeviceInfoData,
                                            &AddPropertyPageData,
                                            MachineName,
                                            MachineHandle);
            if (PageAdded)
            {
                b = SetupDiSetClassInstallParams(
                                DeviceInfoSet,
                                DeviceInfoData,
                                (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                sizeof(SP_ADDPROPERTYPAGE_DATA));
                if (! b)
                {
                    DebugPrint((1, "WMIPROP: SetupDiSetClassInstallParams(%p, %p) failed %d\n",
                                DeviceInfoSet, DeviceInfoData, GetLastError()));                    
                }
                    
            }
        } else {
            DebugPrint((1, "WMIPROP: Already %d property sheets\n",
                        AddPropertyPageData.NumDynamicPages));
        }
    } else {
        DebugPrint((1, "WMIPROP: SetupDiGetClassInstallParams(%p, %p) failed %d\n",
                    DeviceInfoSet, DeviceInfoData, GetLastError()));                    
    }

            
    return(NO_ERROR);
}

//+---------------------------------------------------------------------------
//
//  Function:   MyCoInstaller
//
//  Purpose:    Responds to co-installer messages
//
//  Arguments:
//      InstallFunction   [in] 
//      DeviceInfoSet     [in]
//      DeviceInfoData    [in]
//      Context           [inout]
//
//  Returns:    NO_ERROR, ERROR_DI_POSTPROCESSING_REQUIRED, or an error code.
//
HRESULT
WmiPropCoInstaller (
               IN     DI_FUNCTION               InstallFunction,
               IN     HDEVINFO                  DeviceInfoSet,
               IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
               IN OUT PCOINSTALLER_CONTEXT_DATA Context
               )
{
    if (DeviceInfoData != NULL)
    {
        //
        // Only try to display property page for devices and not for
        // the class
        //
        switch (InstallFunction)
        {
            case DIF_ADDPROPERTYPAGE_ADVANCED:
            {


                DifAddPropertyPageAdvanced(DeviceInfoSet,
                                           DeviceInfoData,
                                           NULL,
                                           NULL);

                break;
            }

            case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
            {
                SP_DEVINFO_LIST_DETAIL_DATA Detail;

                Detail.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
                if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet,
                                                    &Detail))
                {
                    DebugPrint((1, "WMIPROP: Adding remote property pages for %ws\n",
                                Detail.RemoteMachineName));
                    DifAddPropertyPageAdvanced(DeviceInfoSet,
                                               DeviceInfoData,
                                               Detail.RemoteMachineName,
                                               Detail.RemoteMachineHandle);
                } else {
                    DebugPrint((1, "WMIPROP: SetupDiGetDeviceInfoListDetailA failed %d\n",
                                GetLastError()));
                }
                break;
            }

            default:
            {
                break;
            }
        }
    }
    
    return NO_ERROR;    
}

BOOL WINAPI
DllMain(
    HINSTANCE DllInstance,
    DWORD Reason,
    PVOID Reserved
    )
{
    switch(Reason) {

        case DLL_PROCESS_ATTACH: {

            g_hInstance = DllInstance;
            DisableThreadLibraryCalls(DllInstance);
            break;
        }

        case DLL_PROCESS_DETACH: {
            g_hInstance = NULL;
            break;
        }

        default: {
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\collectioncontrol.cpp ===
// CollectionControl.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************



#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"


#include "Persistor.h"
#include "Logger.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Utilities.h"

#include "CollectionControl.h"
 
extern CConstantMap g_ConstantMap;

#if 0



Command line arguments:
Must provide at least -action, and -file.
-action is one of start, stop, enable, query, update or queryall
-file is a single data file.
Examples: 
-file E:\EventTrace\TCODataFiles\ANSI\1-1-1-2.txt
-detail E:\EventTrace\TCOLogFiles\ANSI\TestRuns



If you are using this framework to drive non-collection control tests
use -action scenario.


#endif


#define ERROR_COULD_NOT_CREATE_PROCESS      10
#define ERROR_COULD_NOT_GET_PROCESS_RETURN	11
#define ERROR_WAIT_FAILED					12


struct ProcessData
{
	// Passed from caller.
	LPTSTR m_lptstrExePath;
	LPTSTR m_lptstrCmdLine;
	LPTSTR m_lptstrTCOId;
	LPTSTR m_lptstrLogFile;
	int m_nGuids;
	LPGUID m_lpguidArray;
	HANDLE m_hEventContinue;
	HANDLE m_hEventProcessCompleted;
	// Filled in by thread that starts the process
	DWORD m_dwThreadReturn;
	HANDLE m_hProcess;
	DWORD m_dwProcessReturn;
	int m_nSystemError;
};

struct StartTraceWithProviderData
{
	TCOData *m_pstructTCOData;
	TCOFunctionalData *m_pstructTCOFunctionalData;
	LPTSTR m_lptstrAction;
	LPTSTR m_lptstrDataFile;
	LPTSTR m_lptstrDetailPath;
	
	LPTSTR m_lptstrTCOTestError;
	ProcessData *m_pstructProcessData;
	bool m_bStartConsumers;
	ProcessData **m_pstructConsumerDataArray;
	HANDLE *m_handleConsmers;
};

void FreeStartTraceWithProviderData(StartTraceWithProviderData *p);
void FreeStartTraceWithProviderDataArray(StartTraceWithProviderData **p, int nP);

ProcessData *InitializeProcessData
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath, 
	int nProcessIndex,
	bool bProvider
);

void FreeProcessData(ProcessData *pProcessData);
void FreeProcessDataArray(ProcessData **pProcessData, int nProcessData);

void InitializeExeAndCmdLine
(
	ProcessData *&pstructProcessData,
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
);

// Just allows the test to be driven programatically in addition to from
// the command line.  Dispatches based upon lptstrAction.
int BeginTCOTest
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	LPTSTR lptstrProviderExe,
	bool bLogExpected,
	bool bUseTraceHandle
);

// List of files or single file.
int ActionScenario
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionStartTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionStopTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionEnableTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionQueryTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionUpdateTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionQueryAllTraces
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDetailPath
);

int ActionStartProvider
(
	LPTSTR lptstrAction,
	LPTSTR lptstrProviderExe
);

int RunActionScenarioWithProvider
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR &lptstrAction,
	LPTSTR &lpctstrDataFile,		
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrTCOTestError
);

unsigned int __stdcall RunActionScenarioWithProvider(void *pVoid);

int GetArgs
(
	t_string tsCommandLine,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe,
	bool &bLogExpected,
	bool &bUseTraceHandle		// QueryTrace, EnableTrace,  UpdateTrace, and StopTrace
);

int FreeArgs
(
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe
);

t_string GetTestName(LPTSTR lptstrDataFile);

unsigned int __stdcall RunProcess (void * pVoid);

void ThreadLogger
(int nState, LPCTSTR lptstrFunction, LPCTSTR lptstrMsg, bool bUseULONGValue, ULONG ulValue);

CLogger g_ThreadLogger(_T("E:\\EventTrace\\TCOLogFiles\\ThreadLog.txt"), false);

// Command line 
// -action starttrace  -file E:\EventTrace\TCODataFiles\unicode\1-1-1-2.txt  -detail E:\EventTrace\TCOLogFiles\ANSI\TestRuns 

#ifdef NT5BUILD
__cdecl
#else
int
#endif
main(int argc, char* argv[])
{
	LPTSTR lptstrAction = NULL;
	LPTSTR lptstrDataFile = NULL;
	LPTSTR lptstrDetailPath = NULL;
	LPTSTR lptstrUpdateDataFile = NULL;
	LPTSTR lptstrProviderExe = NULL;

	bool bLogExpected = true;
	bool bUseTraceHandle = false;

	t_string tsCommandLine;
	LPTSTR lptstrCommandLine = NewTCHAR (GetCommandLine());
	tsCommandLine = lptstrCommandLine;
	free(lptstrCommandLine);
	lptstrCommandLine = NULL;

	int nReturn = 
		GetArgs
		(
			tsCommandLine,
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe,
			bLogExpected,
			bUseTraceHandle
		);

	if (nReturn != 0)
	{
		t_cout << _T("Command line error with: \n") << tsCommandLine.c_str() << _T(".\n");
		FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe
		);

		return nReturn;
	} 

	if (!lptstrDataFile && 
		!(case_insensitive_compare(lptstrAction,_T("queryalltraces")) == 0 ||
		  case_insensitive_compare(lptstrAction,_T("providerexe")) == 0 || 
		  case_insensitive_compare(lptstrAction,_T("line")) == 0 ||
		  case_insensitive_compare(lptstrAction,_T("sleep")) == 0)
	    )
	{
		t_cout << _T("Must provide a data file!\n");
		FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe
		);
	
		return -1;
	}

	nReturn = 
		BeginTCOTest 
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe,
			bLogExpected,
			bUseTraceHandle
		);

	FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			lptstrUpdateDataFile,
			lptstrProviderExe
		);

	return nReturn;

}

int BeginTCOTest
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	LPTSTR lptstrProviderExe,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nReturn = ERROR_SUCCESS;

	if (case_insensitive_compare(lptstrAction,_T("scenario")) == 0)
	{
		nReturn = 
			ActionScenario
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("starttrace")) == 0)
	{
		nReturn = 
			ActionStartTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("stoptrace")) == 0)
	{
		nReturn = 
			ActionStopTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("enabletrace")) == 0)
	{
		nReturn = 
			ActionEnableTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("querytrace")) == 0)
	{
		nReturn = 
			ActionQueryTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("updatetrace")) == 0)
	{
		// If bUseTraceHandle is true we will start things with the 
		// lptstrDataFile and update with the lptstrUpdateDataFile.
		// If bUseTraceHandle is false we will update with the
		// lptstrDataFile.  
		nReturn = 
			ActionUpdateTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				lptstrUpdateDataFile,
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("queryalltraces")) == 0)
	{
		nReturn = 
			ActionQueryAllTraces
			(
				lptstrAction,
				lptstrDetailPath
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("providerexe")) == 0)
	{
		nReturn = 
			ActionStartProvider
			(
				lptstrAction,
				lptstrProviderExe
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("sleep")) == 0)
	{
		nReturn = ERROR_SUCCESS;
		Sleep(5000);
	}
	else if (case_insensitive_compare(lptstrAction,_T("line")) == 0)
	{
		t_cout << _T("\n");
	}

	return nReturn;
}

int ActionStartTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
		
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	nResult = 
		StartTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionStopTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
		
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);
	t_string tsError;

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);
			return nResult;
		}

		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
		// Restore this.
		nAPICallResult = ERROR_SUCCESS;
	}

	nResult = 
		StopTraceAPI
		(
			lptstrAction,	
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionEnableTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
	
	t_string tsError;


	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	nResult = 
		StartTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			false,
			pstructTCOData,
			&nAPICallResult
		);

	// We have a problem here if nResult != ERROR_SUCCESS and nAPICallResult == ERROR_SUCCESS
	// we need to call EnableTrace so that the provider can be stopped via a StopTrace
	// call.
	if (nResult != ERROR_SUCCESS && nAPICallResult == ERROR_SUCCESS)
	{
		Sleep(2000);
		// Do not really care what result is!
		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
		// Restore this.
		nAPICallResult = ERROR_SUCCESS;
	}
	
	if (nResult == ERROR_SUCCESS)
	{
		Sleep(2000);

		nResult = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				bLogExpected,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
	}

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionQueryTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;

	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		t_string tsError;

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}
		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}

		Sleep(5000);
	}

	nResult = 
		QueryTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionUpdateTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOData *pstructUpdateData = NULL;  // Remember to free!
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;

	if (bUseTraceHandle && !lptstrUpdateDataFile)
	{
		t_cout << _T("Error in ActionUpdateTrace:  If -usetracehandle 1 is true you must provide an -updatedata argument.\n");
		return -1;
	}

	if (bUseTraceHandle && lptstrUpdateDataFile)
	{
		nResult = 
				GetAllTCOData
				(
					lptstrUpdateDataFile ,
					&pstructUpdateData,
					NULL,
					&lptstrTCOTestError,
					false
				);
	}
	
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		t_string tsError;

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}
		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}

		Sleep(5000);
	}

	if (bUseTraceHandle)
	{
		pstructUpdateData->m_pTraceHandle =  
			(TRACEHANDLE *) malloc (sizeof(TRACEHANDLE));
		*pstructUpdateData->m_pTraceHandle = *pstructTCOData->m_pTraceHandle;
	}

	nResult = 
		UpdateTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			bUseTraceHandle ? pstructUpdateData : pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);
	FreeTCOData(pstructUpdateData);

	return nResult;
}

int ActionQueryAllTraces
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDetailPath
)
{
	int nAPICallResult = ERROR_SUCCESS;
		
	int nResult = 
		QueryAllTracesAPI
		(
			lptstrAction,		
			&nAPICallResult
		);


	t_string tsError;

	if (nResult != ERROR_SUCCESS)
	{
		tsError = ULONGVarToTString(nResult, true);
		LPTSTR lptstrError = DecodeStatus(nResult);
		t_cout << _T("ActionQueryAllTraces Failure: ") << tsError;
		if (lptstrError)
		{
			t_cout << _T(" - ") << lptstrError << _T("\n");
		}
		else
		{
			t_cout << _T(".\n");
		}
		free (lptstrError);
		lptstrError = NULL;
	
	}

	return nResult;
}

int ActionStartProvider
(
	LPTSTR lptstrAction,
	LPTSTR lptstrProviderExe
)
{
	t_string tsExeAndCmdLine;
	tsExeAndCmdLine = lptstrProviderExe;
	int nEndExe = tsExeAndCmdLine.find(_T(".exe"));
	nEndExe += 4;

	t_string tsExe;
	tsExe = tsExeAndCmdLine.substr(0,nEndExe);

	t_string tsCmdLine;

	if (nEndExe + 1 < tsExeAndCmdLine.length())
	{
		tsCmdLine = tsExeAndCmdLine.substr(nEndExe + 1,t_string::npos);
	}

	PROCESS_INFORMATION pinfoProvider;

	RtlZeroMemory(&pinfoProvider, sizeof(PROCESS_INFORMATION));

	STARTUPINFO sinfoProvider;

	RtlZeroMemory(&sinfoProvider, sizeof(STARTUPINFO));

	sinfoProvider.cb = sizeof(sinfoProvider);
	sinfoProvider.lpReserved = NULL;
	sinfoProvider.lpDesktop = NULL;
	sinfoProvider.lpTitle = NULL;
	sinfoProvider.dwFlags = 0;
	sinfoProvider.cbReserved2 = 0;
	sinfoProvider.lpReserved2 = NULL;
	sinfoProvider.hStdInput = NULL;
	sinfoProvider.hStdOutput = NULL;
	sinfoProvider.hStdError = NULL;

	BOOL bReturn =
		CreateProcess(
				tsExe.c_str(),
				(TCHAR *) tsCmdLine.c_str(),
				NULL,
				NULL,
				NULL,
				DETACHED_PROCESS,
				NULL,
				NULL,
				&sinfoProvider,
				&pinfoProvider);


	if (!bReturn)
	{
		DWORD dwError = GetLastError();
		t_cout << _T("\nCreateProcess failed for provider ") << tsExe << _T("\n");
		t_cout << _T("with command line ") << tsCmdLine << _T(".\n");
		LPTSTR lpstrReturnedError = DecodeStatus(dwError);
		t_cout << _T("Error: ") << lpstrReturnedError << _T("\n");
		free(lpstrReturnedError);

		return ERROR_COULD_NOT_CREATE_PROCESS;
	}


	t_cout << _T("\nCreateProcess succeeded for provider ") << tsExe << _T("\n");
	t_cout << _T("with command line ") << tsCmdLine << _T(".\n");

	// Do not need to hold on to this!
	CloseHandle(pinfoProvider.hProcess);
	CloseHandle(pinfoProvider.hThread);

	// Give the process 5 seconds to get going.
	Sleep(5000);

	return ERROR_SUCCESS;
}


int ActionScenario
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;

	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	nResult = 
		RunActionScenarioWithProvider
		(
			pstructTCOData,
			pstructTCOFunctionalData,
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			lptstrTCOTestError
		);

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	t_string tsError;
	if (nResult != ERROR_SUCCESS)
	{
		tsError = ULONGVarToTString(nResult, true);
		LPTSTR lptstrError = DecodeStatus(nResult);
		t_cout << _T("ActionScenario Failure: ") << tsError;
		if (lptstrError)
		{
			t_cout << _T(" - ") << lptstrError << _T("\n");
		}
		else
		{
			t_cout << _T(".\n");
		}
		free (lptstrError);
		lptstrError = NULL;
	}

	return nResult;
}

int RunActionScenarioWithProvider
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	LPTSTR &lptstrTCOTestError
)
{	
	bool bLast = false;
	int nResult = ERROR_SUCCESS;
	int i;

	ProcessData **pstructProviderDataArray = NULL;
	StartTraceWithProviderData  **pstructStartTraceData = NULL;
	HANDLE *phandleProviderThreads = NULL;

	// Here we want to build up array of provider ProcessData./
	// Start a thread for each.
	// Wait for all of the provider threads to complete.

	if (pstructTCOFunctionalData->m_nProviders > 0)
	{
		pstructStartTraceData = 
			(StartTraceWithProviderData **) malloc
				(sizeof (StartTraceWithProviderData *) * 
					pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(pstructStartTraceData, 
			 sizeof (StartTraceWithProviderData *) * 
					pstructTCOFunctionalData->m_nProviders);

		for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
		{
			pstructStartTraceData[i] = 
				(StartTraceWithProviderData *) malloc (sizeof(StartTraceWithProviderData));

			RtlZeroMemory
			(pstructStartTraceData[i], 
			 sizeof (StartTraceWithProviderData));
		}

		pstructProviderDataArray = 
			(ProcessData **) malloc 
				(sizeof (ProcessData *) * 
					pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(pstructProviderDataArray, 
			 sizeof (ProcessData *) * 
			 pstructTCOFunctionalData->m_nProviders);

		phandleProviderThreads = 
			(HANDLE *) malloc (sizeof (HANDLE) * 
								pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(phandleProviderThreads,
			 sizeof (HANDLE) * 
			 pstructTCOFunctionalData->m_nProviders);

		for (int n = 0; n < pstructTCOFunctionalData->m_nProviders; n++)
		{
				pstructProviderDataArray[n] = 
					InitializeProcessData
					(
						pstructTCOData,
						pstructTCOFunctionalData,
						lptstrDetailPath,
						n,		// 0 index gets the first provider or consumer.
						true	// bProvider, if false we get Consumer.
					);

				if (!pstructProviderDataArray[n]->m_hEventContinue || 
					!pstructProviderDataArray[n]->m_hEventProcessCompleted)
				{
					lptstrTCOTestError = 
						NewTCHAR(_T("Provider Data Array:  Could not create events."));
					FreeProcessDataArray
						(pstructProviderDataArray,pstructTCOFunctionalData->m_nProviders);
					return -1;
				}

		}
	}

	ProcessData **pstructConsumerDataArray = NULL;
	int npstructStartTraceDataWithConsumers = -1;

	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (i == pstructTCOFunctionalData->m_nProviders - 1)
		{
			bLast = true;
		}

		bool bStartConsumers = 
			(!pstructTCOData->m_pProps)
			? false
			:
			 (pstructTCOData->m_pProps->LogFileMode == EVENT_TRACE_REAL_TIME_MODE && i == 0) 
			 ? true 
			 : (pstructTCOData->m_pProps->LogFileMode != EVENT_TRACE_REAL_TIME_MODE && bLast)
			   ?
			   true:
			   false;

		pstructStartTraceData[i]->m_pstructTCOData = pstructTCOData;
		pstructStartTraceData[i]->m_pstructTCOFunctionalData = pstructTCOFunctionalData;
		pstructStartTraceData[i]->m_lptstrAction = lptstrAction;
		pstructStartTraceData[i]->m_lptstrDataFile = lptstrDataFile;
		pstructStartTraceData[i]->m_lptstrDetailPath = lptstrDetailPath;
		pstructStartTraceData[i]->m_pstructProcessData = pstructProviderDataArray[i];
		pstructStartTraceData[i]->m_bStartConsumers = bStartConsumers;
		pstructStartTraceData[i]->m_pstructConsumerDataArray = pstructConsumerDataArray;
		if (bStartConsumers)
		{
			pstructStartTraceData[i]->m_handleConsmers = 
				(HANDLE *) malloc (sizeof(HANDLE) *  pstructTCOFunctionalData->m_nConsumers);
			RtlZeroMemory(pstructStartTraceData[i]->m_handleConsmers,
						  sizeof(HANDLE) *  pstructTCOFunctionalData->m_nConsumers);
			npstructStartTraceDataWithConsumers = i;
		}
	
		// Start the provider processes via a thread.  The thread will become
		// the surogate for thr process.

		UINT uiThreadId = NULL;

		phandleProviderThreads[i]  = 
			(HANDLE) _beginthreadex
				(NULL,  0, RunActionScenarioWithProvider, 
				(void *) pstructStartTraceData[i], 0 , &uiThreadId);

		HANDLE hTemp = phandleProviderThreads[i];
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("Just created thread with handle"),true,
					 (ULONG)hTemp);

		if (phandleProviderThreads[i] == 0)
		{
			int nError = errno;
			lptstrTCOTestError = 
				NewTCHAR(_T("Could not start RunActionScenarioWithProvider thread."));
			nResult = nError;
			break;
		}
	}

	// Big logic here.  This is where we wait for all of the 
	// conusmer processes to complete if we have consumers and
	// all of the provider threads.  The provider threads wait for the
	// provider processes to complete so we just wait on the threads.
	// One of the provider threads starts the consumer processes but
	// does not wait on them.  So we wait on them here.  Again, we
	// wait on the consumer threads.

	// After the threads complete we will call StopTrace.

	// Create an array to hold the handles
	HANDLE *phandleAllThreads = 
			(HANDLE *) malloc (sizeof (HANDLE) * 
								(pstructTCOFunctionalData->m_nProviders +
								pstructTCOFunctionalData->m_nConsumers));

	RtlZeroMemory
			(phandleAllThreads,
			 sizeof (HANDLE) * 
			 (pstructTCOFunctionalData->m_nProviders +
								pstructTCOFunctionalData->m_nConsumers));

	int nHandles = 0;

	// Copy handles into it.
	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (phandleProviderThreads[i])
		{
			phandleAllThreads[nHandles++] = phandleProviderThreads[i];
		}
	}

	for (i = 0; i < pstructTCOFunctionalData->m_nConsumers; i++)
	{
		if (pstructStartTraceData[npstructStartTraceDataWithConsumers]->m_handleConsmers[i])
		{
			phandleAllThreads[nHandles++] = 
				pstructStartTraceData[npstructStartTraceDataWithConsumers]->m_handleConsmers[i];
		}
	}
	
	Sleep (5000);
	// Wait for the provider and consumer threads to complete.
	DWORD dwWait = 
		WaitForMultipleObjects
		(
			nHandles,
			phandleAllThreads,
			TRUE,
			10000
		);
 
	free(phandleAllThreads);  // Just free storage the handles get closed elsewhere.

	int nAPICallResult = 0;

	if (pstructStartTraceData[0]->m_pstructTCOData->m_pProps->LoggerName &&
		pstructStartTraceData[0]->m_pstructTCOData->m_pProps)
	{
		nResult = StopTraceAPI
			(	
				lptstrAction,
				NULL,	// Only use name.
				NULL,	// If valid we will log to it, can be NULL.
				false,
				true,
				pstructStartTraceData[0]->m_pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			LPTSTR lptstrError = 
				DecodeStatus(nAPICallResult);
			t_string tsError;
			tsError = _T("StopTraceAPI failed with error: ");
			tsError += lptstrError;
			lptstrTCOTestError = 
				NewTCHAR(tsError.c_str());
			free (lptstrError);
			lptstrError = NULL;
			nResult = nAPICallResult;
		}
	}

	// Need to CloseHandle(); before we free these guys!
	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (phandleProviderThreads[i])
		{
			if (phandleProviderThreads[i])
			{
				CloseHandle(phandleProviderThreads[i]);
			}
		}
	}
	free (phandleProviderThreads);

	FreeProcessDataArray
		(pstructProviderDataArray,pstructTCOFunctionalData->m_nProviders);

	FreeProcessDataArray
		(pstructConsumerDataArray,pstructTCOFunctionalData->m_nConsumers);

	FreeStartTraceWithProviderDataArray
		(pstructStartTraceData,pstructTCOFunctionalData->m_nProviders);

	return nResult;
}

// This gets started in its own thread and its caller waits for it to complete.
unsigned int __stdcall RunActionScenarioWithProvider(void *pVoid)
{
	StartTraceWithProviderData  *pData = 
		(StartTraceWithProviderData  *) pVoid;

	t_string tsLogMsg;

	tsLogMsg = _T("RunActionScenarioWithProvider");

	ThreadLogger(1,tsLogMsg.c_str(),_T(""),false,0);

	pData->m_pstructConsumerDataArray = NULL;

	// We do not exit this function until the process has failed to be
	// created or has completed.  We can not free things in the ProcessData
	// structure until we are sure that the thread has exited one way or
	// another.
	
	UINT uiThreadId = NULL;

	HANDLE hThreadProvider = 
		(HANDLE) _beginthreadex
			(NULL,  0, RunProcess, (void *) pData->m_pstructProcessData, 0 , &uiThreadId);

	if (hThreadProvider == 0)
	{
		int nError = errno;
		pData->m_lptstrTCOTestError = 
			NewTCHAR(_T("Could not start RunProcesss thread."));
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					pData->m_lptstrTCOTestError,true, nError);
		_endthreadex(nError);
		return nError;
	}

	DWORD dwReturn = 
		WaitForSingleObject
			(pData->m_pstructProcessData->m_hEventContinue, 6000);

	// Give the thread 1 second to get going.
	Sleep(3000);

	// If the thread is not active there was a problem getting it 
	// started so we will bail.
	DWORD dwExitCode;
	GetExitCodeThread(hThreadProvider, &dwExitCode);
	if (dwExitCode != STILL_ACTIVE || 
		pData->m_pstructProcessData->m_dwThreadReturn == ERROR_COULD_NOT_CREATE_PROCESS)
	{
		CloseHandle(hThreadProvider);
		if (pData->m_pstructProcessData->m_dwThreadReturn == ERROR_COULD_NOT_CREATE_PROCESS)
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Could not create process."));
		}
		else
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Error in RunProcesss thread."));
		}
		if(pData->m_pstructProcessData->m_hProcess)
		{
			CloseHandle(pData->m_pstructProcessData->m_hProcess);
			pData->m_pstructProcessData->m_hProcess = NULL;
		}
		ThreadLogger(2,_T("RunActionScenarioWithProvider"),
					pData->m_lptstrTCOTestError,false, 0);
		_endthreadex(-1);
		return -1;
	}

	t_string tsDetailFile;
	if (pData->m_lptstrDetailPath)
	{
		tsDetailFile = pData->m_lptstrDetailPath;
		tsDetailFile += _T("\\");
		tsDetailFile += GetTestName(pData->m_lptstrDataFile);
	}

	// nAPICallResult is what the StartTrace call returned.
	// If the call does not succeed we have to clean up the 
	// process.  If the call does succeed we need to call
	// EnableTrace to get the provider going.
	int nAPICallResult = ERROR_SUCCESS;

	int nResult = 
		StartTraceAPI
		(
			pData->m_lptstrAction,
			pData->m_lptstrDataFile,
			pData->m_lptstrDetailPath ? tsDetailFile.c_str() : NULL,
			false,
			pData->m_pstructTCOData,
			&nAPICallResult
		);

	// Big assumption here!
	// If nAPICallResult == 0x000000a1 we assume that multiple StartTraces and that
	// the first one succeeded!

	if (nAPICallResult == ERROR_BAD_PATHNAME)
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTraceAPI function returned ERROR_BAD_PATHNAME. Proceeding."),false, 0);
		nAPICallResult = ERROR_SUCCESS;
		nResult = ERROR_SUCCESS;
	}
	else
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTraceAPI function returned "),true, nResult);
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTrace API call returned "),true, nAPICallResult);
	}


	if (nAPICallResult != ERROR_SUCCESS)
	{
		// Here we must cleanup process because 
		// provider is running and we must stop it!
		BOOL bResult = 
			TerminateProcess(pData->m_pstructProcessData->m_hProcess,0);

		if (!bResult)
		{
			int nError = GetLastError();
			ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("Could not terminate process "),true, nError);

		}
		// Do not want to free the data structures until process
		// terminates.  Use thread as surrogate for process.
		GetExitCodeThread(hThreadProvider, &dwExitCode);
		while (dwExitCode == STILL_ACTIVE)
		{
			Sleep(500);
			GetExitCodeThread(hThreadProvider, &dwExitCode);
		}
	}

	// If we were able to call StartTrace successfully we must call
	// EnableTrace to get the provider going so it can complete.
	// If we do not successfully call EnableTrace we need to
	// clean up the thread and the process.
	if (nAPICallResult == ERROR_SUCCESS)
	{
		// If we cannot start the provider using the GUID in 
		// Wnode.Guid we give up.  Also, we do not care
		// if EnableTrace fails for the other GUIDs.
		ULONG ulStatus = EnableTraceAPI
				(	
					pData->m_lptstrAction,
					NULL,
					NULL,
					false,
					-1,
					pData->m_pstructTCOData,
					&nAPICallResult
				);

		// Exit here after we clean up!
		if (nAPICallResult != ERROR_SUCCESS)
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Could not EnableTrace to start provider."));
			// Here we must cleanup thread and process because 
			// EnableTrace failed.
			TerminateProcess(pData->m_pstructProcessData->m_hProcess,0);
			// Do not want to free the data structures until process
			// terminates.  Use thread as surrogate for process.
			GetExitCodeThread(hThreadProvider, &dwExitCode);
			while (dwExitCode == STILL_ACTIVE)
			{
				Sleep(500);
			}
			CloseHandle(hThreadProvider); 
			if(pData->m_pstructProcessData->m_hProcess)
			{
				CloseHandle(pData->m_pstructProcessData->m_hProcess);
				pData->m_pstructProcessData->m_hProcess = NULL;
			}
			ThreadLogger(2,_T("RunActionScenarioWithProvider"),
						pData->m_lptstrTCOTestError,true,ulStatus);
			_endthreadex(nAPICallResult);
			return nAPICallResult;
		}     

		if (pData->m_bStartConsumers)
		{
			if (pData->m_pstructTCOFunctionalData->m_nConsumers > 0)
			{
				pData->m_pstructConsumerDataArray = 
					(ProcessData **) malloc 
							(sizeof (ProcessData *) * 
								pData->m_pstructTCOFunctionalData->m_nConsumers);
				RtlZeroMemory
					(pData->m_pstructConsumerDataArray, 
					 sizeof (ProcessData *) * 
					 pData->m_pstructTCOFunctionalData->m_nConsumers);

				int n;
				for (n = 0; n < pData->m_pstructTCOFunctionalData->m_nConsumers; n++)
				{
					pData->m_pstructConsumerDataArray[n] = 
						InitializeProcessData
						(
							pData->m_pstructTCOData,
							pData->m_pstructTCOFunctionalData,
							pData->m_lptstrDetailPath,
							n,		// 0 index gets the first provider or consumer.
							false	// bProvider, if false we get Consumer.
						);

						if (!pData->m_pstructConsumerDataArray[n]->m_hEventContinue || 
							!pData->m_pstructConsumerDataArray[n]->m_hEventProcessCompleted)
						{
							pData->m_lptstrTCOTestError = 
								NewTCHAR(_T("Could not create events."));
							CloseHandle(hThreadProvider); 
							if(pData->m_pstructProcessData->m_hProcess)
							{
								CloseHandle(pData->m_pstructProcessData->m_hProcess);
								pData->m_pstructProcessData->m_hProcess = NULL;
							}
							ThreadLogger(2,_T("RunActionScenarioWithProvider"),
										pData->m_lptstrTCOTestError,false,0);
							_endthreadex(-1);
							return -1;
						}

				}


				for (n = 0; n < pData->m_pstructTCOFunctionalData->m_nConsumers; n++)
				{
					UINT uiThreadId = NULL;

					pData->m_handleConsmers[n] = 
						(HANDLE) _beginthreadex
							(NULL,  
							0, 
							RunProcess, 
							(void *) pData->m_pstructConsumerDataArray[n], 
							0 , 
							&uiThreadId);
					// We use the thread as the surrogate for the process because
					// we do not exit the thread until the process ends or is
					// terminated.
					if (pData->m_handleConsmers[n] == 0)
					{
						int nError = errno;
						pData->m_lptstrTCOTestError = 
							NewTCHAR(_T("Could not start RunProcesss thread for consumer."));
						CloseHandle(hThreadProvider); 
						if(pData->m_pstructProcessData->m_hProcess)
						{
							CloseHandle(pData->m_pstructProcessData->m_hProcess);
							pData->m_pstructProcessData->m_hProcess = NULL;
						}
						ThreadLogger(2,_T("RunActionScenarioWithProvider"),
										pData->m_lptstrTCOTestError,true,errno);
						_endthreadex(errno);
						return nError;
					}
					Sleep(3000);
					// We do not need the handle to the process.
					if (pData->m_pstructConsumerDataArray[n]->m_hProcess)
					{
						CloseHandle(pData->m_pstructConsumerDataArray[n]->m_hProcess);
						pData->m_pstructConsumerDataArray[n]->m_hProcess = 0;
					}
				}
			}

		}

		// Enable the other GUIDS for provider.  We do not check
		// the return code.
		for (int i = 0; i < pData->m_pstructTCOData->m_nGuids; i++)
		{
			EnableTraceAPI
				(	
					pData->m_lptstrAction,
					NULL,
					NULL,
					false,
					i,
					pData->m_pstructTCOData,
					&nAPICallResult	
				);
			Sleep(3000);
		}
	}


	// Do not need this. 
	CloseHandle(hThreadProvider); 


	
	if (nAPICallResult == ERROR_SUCCESS)
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("About to wait for process to complete "),false, 0);

		dwReturn = 
		WaitForSingleObject
			(pData->m_pstructProcessData->m_hEventProcessCompleted, 6000);

		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("After wait for process to complete "),false, 0);
	}

	if (nResult != ERROR_SUCCESS)
	{
		t_string tsError;
		tsError = _T("Failure in RunActionScenarioWithProvider: StartTraceAPI failed.");
		pData->m_lptstrTCOTestError = NewTCHAR(tsError.c_str());
		if (nAPICallResult != ERROR_SUCCESS)
		{
			if(pData->m_pstructProcessData->m_hProcess)
			{
				CloseHandle(pData->m_pstructProcessData->m_hProcess);
				pData->m_pstructProcessData->m_hProcess = NULL;
			}
			ThreadLogger(2,_T("RunActionScenarioWithProvider"),
						pData->m_lptstrTCOTestError,true,nResult);
			_endthreadex(nResult);
			return nResult;
		}
	}
          
	if(pData->m_pstructProcessData->m_hProcess)
	{
		CloseHandle(pData->m_pstructProcessData->m_hProcess);
		pData->m_pstructProcessData->m_hProcess = NULL;
	}

	ThreadLogger(2,_T("RunActionScenarioWithProvider"),
				_T("Normal exit"),true,nResult);
	_endthreadex(nResult);
	return nResult;
}


// This can deal with command line arguments in double quotes and
// you must double quote command line arguments which contain spaces.
t_string FindValue(t_string tsCommandLine, int nPos)
{
	int nLen = tsCommandLine.length();

	TCHAR tc = tsCommandLine[nPos];
	bool bQuote = false;

	while ((nPos < nLen) && tc == _T(' ') || tc == _T('\t') || tc == _T('"'))
	{
		if (tc == _T('"'))
		{
			// Quotes allow embedded white spaces.
			bQuote = true;
		}
		++nPos;
		tc = tsCommandLine[nPos];
	}

	if (nPos == nLen)
	{
		return _T("");  // Empty string means failure.
	}


	int nEnd = nPos;

	tc = tsCommandLine[nEnd];

	while ((nEnd < nLen) && 
			( (!bQuote && (tc != _T(' ') && tc != _T('\t'))) 
			  || 
			  (bQuote && tc != _T('"'))
			)
		  )
	{
		++nEnd;
		tc = tsCommandLine[nEnd];
	}

	t_string tsReturn;
	tsReturn = tsCommandLine.substr(nPos,nEnd - nPos);

	return tsReturn; 

}

int GetArgs
(
	t_string tsCommandLine,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe,
	bool &bLogExpected,
	bool &bUseTraceHandle
)
{
	int nFind;

	nFind = tsCommandLine.find(_T("-action"));
	t_string tsValue;

	if (nFind != t_string::npos)
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrAction = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-file"));

	if (nFind != t_string::npos)
	{
		nFind += 5;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrDataFile = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-detail"));

	if (nFind == t_string::npos)
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
	}
	else
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrDetailPath = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-logexpected"));

	if (nFind != t_string::npos)
	{
		nFind += 12;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			int nComp = tsValue.compare(_T("0"));
			if (nComp == 0)
			{
				bLogExpected = false;
			}
			else
			{
				bLogExpected = true;
			}
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-usetracehandle"));

	if (nFind != t_string::npos)
	{
		nFind += 15;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			int nComp = tsValue.compare(_T("0"));
			if (nComp == 0)
			{
				bUseTraceHandle = false;
			}
			else
			{
				bUseTraceHandle = true;
			}
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-providerexe"));

	if (nFind != t_string::npos)
	{
		nFind += 12;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrProviderExe = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-updatedata"));

	if (nFind != t_string::npos)
	{
		nFind += 11;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrUpdateDataFile = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}


	return 0;
}


int FreeArgs
(
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe
)
{
	free (lptstrAction);
	free (lptstrDataFile);
	free (lptstrDetailPath);
	free (lptstrUpdateDataFile);
	free (lptstrProviderExe);

	lptstrAction = NULL;
	lptstrDataFile = NULL;
	lptstrDetailPath = NULL;
	lptstrUpdateDataFile = NULL;
	lptstrProviderExe = NULL;

	return 0;
}

unsigned int __stdcall RunProcess(void * pVoid)
{
	ProcessData *pProcessData = (ProcessData *) pVoid;
	pProcessData->m_dwProcessReturn = 0;
	pProcessData->m_dwThreadReturn = 0;
	pProcessData->m_nSystemError = 0;
		
	PROCESS_INFORMATION pinfoProvider;

	RtlZeroMemory(&pinfoProvider, sizeof(PROCESS_INFORMATION));

	STARTUPINFO sinfoProvider;

	RtlZeroMemory(&sinfoProvider, sizeof(STARTUPINFO));

	sinfoProvider.cb = sizeof(sinfoProvider);
	sinfoProvider.lpReserved = NULL;
	sinfoProvider.lpDesktop = NULL;
	sinfoProvider.lpTitle = NULL;
	sinfoProvider.dwFlags = 0;
	sinfoProvider.cbReserved2 = 0;
	sinfoProvider.lpReserved2 = NULL;
	sinfoProvider.hStdInput = NULL;
	sinfoProvider.hStdOutput = NULL;
	sinfoProvider.hStdError = NULL;

	BOOL bReturn =
		CreateProcess(
				pProcessData->m_lptstrExePath,
				pProcessData->m_lptstrCmdLine,
				NULL,
				NULL,
				NULL,
				DETACHED_PROCESS,
				NULL,
				NULL,
				&sinfoProvider,
				&pinfoProvider);


	if (!bReturn)
	{
		pProcessData->m_nSystemError = GetLastError();
		pProcessData->m_dwThreadReturn = ERROR_COULD_NOT_CREATE_PROCESS;
		SetEvent(pProcessData->m_hEventContinue);
		_endthreadex(ERROR_COULD_NOT_CREATE_PROCESS);
		return ERROR_COULD_NOT_CREATE_PROCESS;
	}

	pProcessData->m_hProcess = pinfoProvider.hProcess;

	// Do not need to hold on to this!
	CloseHandle(pinfoProvider.hThread);

	// Give the process 5 seconds to get going.
	Sleep(5000);

	SetEvent(pProcessData->m_hEventContinue);

	pProcessData->m_dwProcessReturn =
		WaitForSingleObject(pinfoProvider.hProcess,6000);

	if (pProcessData->m_dwProcessReturn != WAIT_OBJECT_0)
	{
		pProcessData->m_nSystemError = GetLastError();  
		pProcessData->m_dwThreadReturn = ERROR_WAIT_FAILED;
		SetEvent(pProcessData->m_hEventProcessCompleted);
		_endthreadex(ERROR_WAIT_FAILED);
		return (ERROR_WAIT_FAILED);
	}

	bReturn =
		GetExitCodeProcess
		(pinfoProvider.hProcess, &pProcessData->m_dwProcessReturn);

	if (!bReturn)
	{
		pProcessData->m_nSystemError = GetLastError();
		pProcessData->m_dwThreadReturn = 
			ERROR_COULD_NOT_GET_PROCESS_RETURN;
		SetEvent(pProcessData->m_hEventProcessCompleted);
		_endthreadex(ERROR_COULD_NOT_GET_PROCESS_RETURN);
		return (ERROR_COULD_NOT_GET_PROCESS_RETURN);
	}

	bReturn = SetEvent(pProcessData->m_hEventProcessCompleted);

	if (!bReturn)
	{
		int n = GetLastError();
	}

	_endthreadex(0);
	return (0);

}

t_string GetTestName(LPTSTR lptstrDataFile)
{
	t_string tsTemp;
	
	tsTemp = lptstrDataFile;

	t_string tsPath;

	int nBeg = tsTemp.find_last_of(_T('\\'));
	++nBeg;

	int nEnd = tsTemp.find_last_of(_T('.'));
	if (nEnd == t_string::npos)
	{
		nEnd = tsTemp.length();
	}

	int nNum = nEnd - nBeg;

	tsTemp = tsTemp.substr(nBeg, nNum);
	tsTemp += _T("Detail.txt");

	return tsTemp;
}


ProcessData *InitializeProcessData
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
)
{
	ProcessData *pstructProcessData = (ProcessData *) malloc(sizeof(ProcessData));
	RtlZeroMemory(pstructProcessData, sizeof(ProcessData));

	InitializeExeAndCmdLine
	(
		pstructProcessData, 
		pstructTCOData,
		pstructTCOFunctionalData,
		lptstrDetailPath,
		nProcessIndex,
		bProvider
	);

	pstructProcessData->m_lptstrTCOId =
			NewTCHAR(pstructTCOData->m_lptstrShortDesc);
	pstructProcessData->m_lptstrLogFile = 
			NewTCHAR(lptstrDetailPath);
	// First Guid is in the properties.
	
	int nGuids;
	int nDelta;
	if (pstructTCOData->m_pProps != NULL)
	{
		nGuids= pstructTCOData->m_nGuids + 1;
		pstructProcessData->m_lpguidArray = 
			(GUID *) malloc (sizeof (GUID) * nGuids);
		pstructProcessData->m_lpguidArray[0] = pstructTCOData->m_pProps->Wnode.Guid;
		nDelta = 1;
	}
	else
	{
		nGuids= pstructTCOData->m_nGuids;
		if (nGuids > 0)
		{
			pstructProcessData->m_lpguidArray = 
				(GUID *) malloc (sizeof (GUID) * nGuids);
		}
		else
		{
			pstructProcessData->m_lpguidArray = NULL;
		}
		nDelta = 0;
	}
	
	for (int i = 0; i < pstructTCOData->m_nGuids; i++)
	{
		pstructProcessData->m_lpguidArray[i + nDelta] = 
			pstructTCOData->m_lpguidArray[i];
	}
	

	pstructProcessData->m_hEventContinue = CreateEvent(NULL,FALSE,FALSE,NULL);;
	pstructProcessData->m_hEventProcessCompleted = CreateEvent(NULL,FALSE,FALSE,NULL);;

	pstructProcessData->m_hProcess = NULL;
	pstructProcessData->m_dwProcessReturn = 0;
	pstructProcessData->m_dwThreadReturn = 0;
	pstructProcessData->m_nSystemError = 0;

	return pstructProcessData;
}

void InitializeExeAndCmdLine
(
	ProcessData *&pstructProcessData,
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
)
{
	t_string tsProcess;
	if (bProvider)
	{
		tsProcess = pstructTCOFunctionalData->m_lptstrProviderArray[nProcessIndex];
	}
	else
	{
		tsProcess = pstructTCOFunctionalData->m_lptstrConsumerArray[nProcessIndex];
	}
	
	t_string tsExe;
	t_string tsCmdLine;

	int nEndExe = tsProcess.find(_T(".exe"));
	nEndExe += 4;

	tsExe = tsProcess.substr(0,nEndExe);

	if (nEndExe + 1 < tsExe.length())
	{
		tsCmdLine = tsProcess.substr(nEndExe + 1,t_string::npos);
	}

	tsCmdLine += _T(" -TESTID ");
	tsCmdLine += pstructTCOData->m_lptstrShortDesc;

	if (lptstrDetailPath)
	{
		tsCmdLine += _T("-TESTLOGPATH ");
		tsCmdLine += lptstrDetailPath;
	}

	tsCmdLine += _T("-GUIDS ");

	LPTSTR lptstrGuid = NULL;

	if (pstructTCOData->m_pProps != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data1 != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data2 != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data3 != 0)
	{
		lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_pProps->Wnode.Guid);
		tsCmdLine += lptstrGuid;
		free (lptstrGuid);
		lptstrGuid = NULL;
		if (pstructTCOData->m_nGuids > 0)
		{
				tsCmdLine += _T(",");
		}
	}

	if (pstructTCOData->m_pProps != 0)
	{
		for (int i = 0; i < pstructTCOData->m_nGuids; i++) 
		{
			lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_lpguidArray[i]);
			tsCmdLine += lptstrGuid;
			free (lptstrGuid);
			lptstrGuid = NULL;
			if (pstructTCOData->m_nGuids > 1 
				&& i < pstructTCOData->m_nGuids - 1)
			{
				tsCmdLine += _T(",");
			}
		}
	}

	t_string tsTemp;
	if (bProvider)
	{
		tsCmdLine += _T(" -EnableFlag ");
		tsTemp = ULONGVarToTString(pstructTCOData->m_ulEnableFlag ,true);
		tsCmdLine += tsTemp;
		
		tsCmdLine += _T(" -EnableLevel ");
		tsTemp = ULONGVarToTString(pstructTCOData->m_ulEnableLevel ,true);
		tsCmdLine += tsTemp;
		
	}
	else
	{
	
		if (pstructTCOData->m_pProps != 0)
		{
			tsCmdLine += _T(" -LogFile ");
			tsCmdLine += pstructTCOData->m_pProps->LogFileName;
			tsCmdLine += _T(" -Logger ");
			tsCmdLine += pstructTCOData->m_pProps->LoggerName;
		}
	}
	pstructProcessData->m_lptstrExePath = NewTCHAR(tsExe.c_str());
	
	pstructProcessData->m_lptstrCmdLine = NewTCHAR(tsCmdLine.c_str());
}

void FreeProcessDataArray(ProcessData **pProcessData, int nProcessData)
{
	if (pProcessData == NULL)
	{
		return;
	}

	for (int i = 0; i < nProcessData; i++)
	{
		if (pProcessData[i])
		{
			FreeProcessData(pProcessData[i]);
		}
	}

	free (pProcessData);
}

void FreeProcessData(ProcessData *pProcessData)
{
	free (pProcessData->m_lptstrExePath);
	free (pProcessData->m_lptstrCmdLine);
	free (pProcessData->m_lptstrTCOId);
	free (pProcessData->m_lptstrLogFile);
	free (pProcessData->m_lpguidArray);
	pProcessData->m_nGuids = 0;

	if (pProcessData->m_hEventContinue)
	{ 
		if (pProcessData->m_hEventContinue)
		{
			CloseHandle(pProcessData->m_hEventContinue);
		}
	}

	if (pProcessData->m_hEventProcessCompleted)
	{
		if (pProcessData->m_hEventProcessCompleted)
		{
			CloseHandle(pProcessData->m_hEventProcessCompleted);
		}
	}

	if (pProcessData->m_hProcess)
	{
		if (pProcessData->m_hProcess)
		{
			CloseHandle(pProcessData->m_hProcess);
		}
	}
	
	pProcessData->m_lptstrExePath = NULL;
	pProcessData->m_lptstrCmdLine = NULL;
	pProcessData->m_lptstrTCOId = NULL;
	pProcessData->m_lptstrLogFile = NULL;
	pProcessData->m_lpguidArray = NULL;
	pProcessData->m_hEventContinue = NULL;
	pProcessData->m_hEventProcessCompleted = NULL;
	pProcessData->m_hProcess = NULL;
	
	free (pProcessData);
}

void FreeStartTraceWithProviderData(StartTraceWithProviderData *p)
{
	if (!p)
	{
		return;
	}

	free (p->m_lptstrTCOTestError);
	p->m_lptstrTCOTestError = NULL;

	int nConsumers = p->m_pstructTCOFunctionalData->m_nConsumers;

	if (p->m_handleConsmers)
	{
		for (int i = 0; i < nConsumers; i++)
		{
			CloseHandle(p->m_handleConsmers[i]);
		}

		free(p->m_handleConsmers);
	}

	free(p);

	// All other data is shared and freed elsewhere!

}
void FreeStartTraceWithProviderDataArray(StartTraceWithProviderData **p, int nP)
{
	if (!p) 
	{
		return;
	}

	for (int i = 0; i < nP; i++)
	{
		if (p[i])
		{
			FreeStartTraceWithProviderData(p[i]);
		}
	}

	free(p);


}

// nState 1 = entering, 2 - leaving, 3 = none of the above.
void ThreadLogger
(int nState, LPCTSTR lptstrFunction, LPCTSTR lptstrMsg, bool bUseULONGValue, ULONG ulValue)
{

	CRITICAL_SECTION csMyCriticalSection;

	InitializeCriticalSection (&csMyCriticalSection);

	__try
	{
		EnterCriticalSection (&csMyCriticalSection);

		g_ThreadLogger.LogTCHAR(_T("\n"));

		g_ThreadLogger.LogTCHAR(_T("Thread ID: "));
		g_ThreadLogger.LogULONG((ULONG) GetCurrentThreadId());
		g_ThreadLogger.LogTCHAR(_T(".\n"));

		if (nState == 1)
		{
			g_ThreadLogger.LogTCHAR(_T("Entering - "));

		}
		else if (nState == 2)
		{
			g_ThreadLogger.LogTCHAR(_T("Leaving - "));
		}

		g_ThreadLogger.LogTCHAR(lptstrFunction);

		if (_tcslen(lptstrMsg) > 0)
		{
			g_ThreadLogger.LogTCHAR(_T(":\n"));
			g_ThreadLogger.LogTCHAR(lptstrMsg);
		}

		if (bUseULONGValue)
		{
			g_ThreadLogger.LogTCHAR(_T(" - "));
			g_ThreadLogger.LogULONG(ulValue);
		}
			
		g_ThreadLogger.LogTCHAR(_T(".\n"));	
	}
	 __finally
	 {
		// Release ownership of the critical section
		LeaveCriticalSection (&csMyCriticalSection);

	 }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\constantmap.h ===
// ConstantMap.h: interface for the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef pair<t_string, unsigned int> MAPPAIR;
typedef map<t_string, unsigned int> CONSTMAP;


class CConstantMap  
{
public:
	CConstantMap();
	virtual ~CConstantMap();
	CONSTMAP m_Map;
};

#endif // !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\logger.cpp ===
// Logger.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>

using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Logger.h"


#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff,0x0d, 0x0a};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

CLogger::CLogger(LPCTSTR lpctstrFileName, bool bAppend)
{
#ifdef _UNICODE
	m_sFileName = NewLPSTR((LPCWSTR) const_cast<LPTSTR>(lpctstrFileName));
#else
	m_sFileName = NewTCHAR(lpctstrFileName);
#endif

	m_pPersistor = new CPersistor(m_sFileName, ios::out, false);
	m_hr = m_pPersistor -> OpenLog(bAppend);
}

CLogger::~CLogger()
{
	free(m_sFileName);
	delete m_pPersistor;
}

int CLogger::LogTCHAR(LPCTSTR lpctstrOut)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (lpctstrOut)
	{
		PutALine(m_pPersistor->Stream(), lpctstrOut, -1);
		m_pPersistor->Stream().flush();
	}

	return 0;
}

int CLogger::LogTime(time_t &Time)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	TCHAR tcArray[26];
	LPCTSTR lpctstrTime = t_ctime(&Time);
	_tcscpy(tcArray,lpctstrTime);
	tcArray[24] = _T('\0');
	TCHAR *p = tcArray;

	PutALine(m_pPersistor->Stream(), p, -1);
	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogULONG(ULONG ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONGVar(m_pPersistor->Stream(), ul, bHex);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogULONG64(ULONG64 ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONG64Var(m_pPersistor->Stream(), ul);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogGUID(GUID Guid)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	GUIDOut(m_pPersistor->Stream(), Guid);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (pProps == NULL)
	{
		PutALine(m_pPersistor->Stream(),_T("_EVENT_TRACE_PROPERTIES Instance NULL\n"),-1);
		return 0;
	}

	CEventTraceProperties Props(pProps);

	m_pPersistor->Stream() << Props;

	m_pPersistor->Stream().flush();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\constantmap.cpp ===
// ConstantMap.cpp: implementation of the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************


#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;



#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"

#include "ConstantMap.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
   
CConstantMap::CConstantMap()
{
	MAPPAIR pair;

	pair.first = _T("EVENT_TRACE_TYPE_INFO");
	pair.second = EVENT_TRACE_TYPE_INFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_START");
	pair.second = EVENT_TRACE_TYPE_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_END");
	pair.second = EVENT_TRACE_TYPE_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_START");
	pair.second = EVENT_TRACE_TYPE_DC_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_END");
	pair.second = EVENT_TRACE_TYPE_DC_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_EXTENSION");
	pair.second = EVENT_TRACE_TYPE_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_REPLY");
	pair.second = EVENT_TRACE_TYPE_REPLY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED7");
	pair.second = EVENT_TRACE_TYPE_RESERVED7;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED8");
	pair.second = EVENT_TRACE_TYPE_RESERVED8;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED9");
	pair.second = EVENT_TRACE_TYPE_RESERVED9;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_LOAD");
	pair.second = EVENT_TRACE_TYPE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_READ");
	pair.second = EVENT_TRACE_TYPE_IO_READ;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_WRITE");
	pair.second = EVENT_TRACE_TYPE_IO_WRITE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_TF");
	pair.second = EVENT_TRACE_TYPE_MM_TF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_DZF");
	pair.second = EVENT_TRACE_TYPE_MM_DZF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_COW");
	pair.second = EVENT_TRACE_TYPE_MM_COW;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_GPF");
	pair.second = EVENT_TRACE_TYPE_MM_GPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SEND");
	pair.second = EVENT_TRACE_TYPE_SEND;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RECEIVE");
	pair.second = EVENT_TRACE_TYPE_RECEIVE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONNECT");
	pair.second = EVENT_TRACE_TYPE_CONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DISCONNECT");
	pair.second = EVENT_TRACE_TYPE_DISCONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_GUIDMAP");
	pair.second = EVENT_TRACE_TYPE_GUIDMAP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONFIG");
	pair.second = EVENT_TRACE_TYPE_CONFIG;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SIDINFO");
	pair.second = EVENT_TRACE_TYPE_SIDINFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_PROCESS");
	pair.second = EVENT_TRACE_FLAG_PROCESS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_THREAD");
	pair.second = EVENT_TRACE_FLAG_THREAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
	pair.second = EVENT_TRACE_FLAG_IMAGE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_FILE_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
	pair.second = EVENT_TRACE_FLAG_NETWORK_TCPIP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_EXTENSION");
	pair.second = EVENT_TRACE_FLAG_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
	pair.second = EVENT_TRACE_FLAG_FORWARD_WMI;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NONE");
	pair.second = EVENT_TRACE_FILE_MODE_NONE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
	pair.second = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
	pair.second = EVENT_TRACE_FILE_MODE_CIRCULAR;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
	pair.second = EVENT_TRACE_FILE_MODE_NEWFILE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
	pair.second = EVENT_TRACE_PRIVATE_LOGGER_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_REAL_TIME_MODE");
	pair.second = EVENT_TRACE_REAL_TIME_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
	pair.second = EVENT_TRACE_DELAY_OPEN_FILE_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_BUFFERING_MODE");
	pair.second = EVENT_TRACE_BUFFERING_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_QUERY");
	pair.second = EVENT_TRACE_CONTROL_QUERY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_STOP");
	pair.second = EVENT_TRACE_CONTROL_STOP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_UPDATE");
	pair.second = EVENT_TRACE_CONTROL_UPDATE;
	m_Map.insert(pair);

	pair.first = _T("WNODE_FLAG_TRACED_GUID");
	pair.second = WNODE_FLAG_TRACED_GUID;
	m_Map.insert(pair);

	pair.first = _T("ERROR_SUCCESS");
	pair.second = ERROR_SUCCESS;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_PARAMETER");
	pair.second = ERROR_INVALID_PARAMETER;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_NAME");
	pair.second = ERROR_INVALID_NAME;
	m_Map.insert(pair);

	pair.first = _T("ERROR_BAD_LENGTH");
	pair.second = ERROR_BAD_LENGTH;
	m_Map.insert(pair);


	pair.first = _T("VALUE_NULL");
	pair.second = NULL;
	m_Map.insert(pair);

	pair.first = _T("VALUE_MAX_MEMORY");
	pair.second = 0;
	m_Map.insert(pair);

	pair.first = _T("VALUE_ZERO");
	pair.second = 0;
	m_Map.insert(pair);

}

CConstantMap::~CConstantMap()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\collectioncontrol.h ===
#if !defined(AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

int StartTraceAPI
(
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StartTrace API call return
);

int StopTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StopTrace API call return
);

// Enable all Guids
int EnableTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
);

// Only enable one Guid
int EnableTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN int nGuidIndex,					// Index or if -1 use Guid from WNode.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
);

int QueryTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// QueryTrace API call return
);

int UpdateTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// UpdateTrace API call return
);

int QueryAllTracesAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	OUT int *pAPIReturn					// QueryAllTraces API call return
);

#endif // !defined(AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\enabletraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
// Enable all Guids
int EnableTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
)
{
	*pAPIReturn = -1;


	ULONG ulResult =
		EnableTraceAPI
		(	
			lptstrAction,
			lpctstrDataFile,
			lpctstrTCODetailFile,
			bLogExpected,
			-1,
			pstructTCOData,
			pAPIReturn
		);

	for (int i = 0; i < pstructTCOData->m_nGuids; i++)
	{
		ulResult = 
			EnableTraceAPI
			(	
				lptstrAction,
				lpctstrDataFile,
				NULL,		// Write detail only for the first Guid enabled!
				bLogExpected,
				i,
				pstructTCOData,
				pAPIReturn	
			);
	}
	return ulResult;

}

int EnableTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN int nGuidIndex,					// Index or if -1 use Guid from WNode.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
)
{	

	LPTSTR lpstrReturnedError = NULL;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is EnableTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::EnableTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}
	

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string lpstrReturnedError.
		
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("EnableTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("EnableTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("EnableTrace"),
		bLogExpected
	);

	GUID Guid = nGuidIndex == -1 ?
				pstructTCOData->m_pProps->Wnode.Guid:
				pstructTCOData->m_lpguidArray[nGuidIndex];

	*pAPIReturn =
		EnableTrace
		(	 
			pstructTCOData->m_ulEnable ? TRUE : FALSE,
			pstructTCOData->m_ulEnableFlag,
			pstructTCOData->m_ulEnableLevel,
			&Guid,
			*pstructTCOData->m_pTraceHandle
		);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS)
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::EnableTraceTest &&
			pstructTCOData->m_lptstrValidator && 
			_tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	t_string tsBanner;
	LPTSTR lptstrGuid = NULL;

	if (pstructTCOData->m_pProps != 0 &&
		Guid.Data1 != 0 &&
		Guid.Data2 != 0 &&
		Guid.Data3 != 0)
	{
		lptstrGuid = LPTSTRFromGuid(Guid);
		tsBanner = _T("EnableTrace for Guid:");
		tsBanner += lptstrGuid;
		free (lptstrGuid);
		lptstrGuid = NULL;
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			true,
			bAdmin,
			tsBanner.length() > 0 ? tsBanner.c_str() : NULL,
			false
		);
	}

	tsBanner.erase();

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);


	free(lpstrReturnedError);
	lpstrReturnedError = NULL;

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\persistor.cpp ===
// Persistor.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>

using namespace std;

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "StructureWapperHelpers.h"



#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CPersistor::CPersistor
(const char *pszFilename, int nMode, bool bLoading)
{
	m_sFilename = pszFilename;
	m_nMode = nMode;
	m_bLoading = bLoading;
	m_pfsFile = NULL;
	m_bFirst = true;
	m_pfsFile = NULL;
}

CPersistor::~CPersistor()
{
	Close();
}

HRESULT CPersistor::Close()
{
	if (m_pfsFile && m_pfsFile->is_open())
	{
#ifdef _UNICODE
		if (!m_bLoading)
		{
		
		}
#endif
		m_pfsFile->flush();
		m_pfsFile->close();
		delete m_pfsFile;
		m_pfsFile = NULL;
	}
	else if (m_pfsFile)
	{
		delete m_pfsFile;
		m_pfsFile = NULL;
	}

	return S_OK;

}

HRESULT CPersistor::Open()
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
				(m_sFilename.c_str(),m_nMode | ios_base::binary);

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		if (m_bFirst && !m_bLoading)
		{
			// To Do:  Need to write out here the UNICODE string.
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		}
		else if (m_bFirst)
		{
			// Need to skip over the UNICODE string.
			fpos_t p = m_pfsFile->tellp();
			if (p == (fpos_t) 0)
			{
				TCHAR tc;
				tc = Stream().peek();
				// Need to make sure that the file is unicode.
				if (tc != 0xff)
				{
					m_pfsFile ->close();
					delete m_pfsFile;
					m_pfsFile = NULL;
					return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
				}
				
				TCHAR t;

				GetAChar(Stream(), t);
				
			}
		}
#else
		if (m_bFirst && m_bLoading)
		{
			// Need to make sure that the file is not unicode.
			int tc;
			tc = Stream().peek();
			if (tc == 0xff)
			{
				m_pfsFile ->close();
				delete m_pfsFile;
				m_pfsFile = NULL;
				return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
			}
		}
#endif
		m_bFirst = false;
		return S_OK;
	}


}

// 
HRESULT CPersistor::OpenLog(bool bAppend)
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
		(m_sFilename.c_str(),m_nMode | ios_base::binary | (bAppend ?  ios::app : 0));

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		//m_pfsFile->seekp(ios::end);
		//fpos_t p = m_pfsFile->tellp();
		//if (p == (fpos_t) 0)
		//{
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		//}
#endif
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\logger.h ===
#if !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogger
{
public:
	CLogger(LPCTSTR lpctstrFileName,  bool bAppend = true);
	~CLogger();
	int LogTCHAR(LPCTSTR lpctstrOut);
	int LogULONG(ULONG uLong, bool bHex = true);
	int LogULONG64(ULONG64 uLong64,  bool bHex = true);
	int LogGUID(GUID Guid);
	int LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	int LogTime(time_t &Time);
	void Flush() {m_pPersistor->Stream().flush();}
	HRESULT GetOpenStatus() {return m_hr;}
private:
	CPersistor *m_pPersistor;
	char *m_sFileName;
	HRESULT m_hr;
};

#endif // !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\persistor.h ===
// Persistor.h: interface for the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPersistor  
{
public:
	virtual ~CPersistor();
	CPersistor(const char *pszFilename, int nMode, bool bLoading = true );
	HRESULT Close();
	HRESULT Open();
	// For logging support.  We only log out.
	HRESULT OpenLog(bool bAppend = true);
	t_fstream &Stream() {return *m_pfsFile;}
	bool IsLoading() {return m_bLoading;}
	const char* GetFilename() {return m_sFilename.c_str();} 
protected:
	t_fstream *m_pfsFile;
	bool m_bLoading;
	string m_sFilename;
	int m_nMode;
	bool m_bFirst;
};

#endif // !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\queryalltracesapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int QueryAllTracesAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	OUT int *pAPIReturn					// QueryAllTraces API call return
)
{
	*pAPIReturn = ERROR_SUCCESS;

	int nResult = 0;
			
	t_cout << _T("QueryAllTracesAPI TCO tests 1.6.1.\n");
	

	PEVENT_TRACE_PROPERTIES pPropsArray = NULL;
	ULONG ulSessionCount = 0;

	// 1.6.1.1
	ULONG ulStatus = 
		QueryAllTraces
		(	
			NULL,
			32,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.1 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.1 - Failed\n");
	}

	InitializePropsArray(pPropsArray, 4);

	// 1.6.1.2
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			32,
			&ulSessionCount
		);

	if (ulStatus == ERROR_SUCCESS)
	{
		t_cout << _T("1.6.1.2 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.2 - Failed\n");
	}

	// 1.6.1.3
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			4,
			&ulSessionCount
		);

	if (ulStatus == ERROR_SUCCESS)
	{
		t_cout << _T("1.6.1.3 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.3 - Failed\n");
	}

	// 1.6.1.4
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			0,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.4 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.4 - Failed\n");
	}

	// 1.6.1.5
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			33,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.5 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.5 - Failed\n");
	}

	// 1.6.1.6
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			4,
			NULL
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.6 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.1 - Failed\n");
	}
	
	return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	TestStartTrace.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\querytraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int QueryTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// QueryTrace API call return
)
{	
	// If bUseTracehandle is true we can check for differences in 
	// props.

	*pAPIReturn = -1;

	LPTSTR lptstrReturnedError = NULL;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is QueryTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::QueryTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lptstrReturnedError
			);
	}

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.

		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StartTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lptstrReturnedError,
			bLogExpected
		);
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("QueryTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	CEventTraceProperties CProps (pstructTCOData->m_pProps);
	PEVENT_TRACE_PROPERTIES pProps = CProps.GetEventTracePropertiesInstance();
	free(pProps->LogFileName);
	free(pProps->LoggerName);
	pProps->LogFileName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
	pProps->LoggerName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("QueryTrace"),
		bLogExpected
	);

	*pAPIReturn = 
		QueryTrace
		( 
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL, 
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pProps);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lptstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::QueryTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lptstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	bool bDiff = FALSE;
	if (bUseTraceHandle)
	{
		bDiff = 
			LogPropsDiff
			(
				NULL,
				pstructTCOData->m_pProps,
				pProps
			);
	}

	// If there were differences and 
	// *pAPIReturn == ERROR_SUCCESS == pstructTCOData->m_ulExpectedResult
	// we need to set return codes to indicate differences.  Look in detail
	// log for differences.
	if (bDiff &&
		*pAPIReturn == ERROR_SUCCESS &&
		pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS)
	{
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		*pAPIReturn = -1;
		lptstrReturnedError = 
			NewTCHAR(_T("Different values returned in EVENT_TRACE_PROPERTIES structure."));
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pProps,
			*pAPIReturn,
			lptstrReturnedError,
			true,
			bAdmin,
			NULL,
			*pAPIReturn == ERROR_SUCCESS // Do not print out Props if not a good return.
		);	
	}

	if (bUseTraceHandle)
	{
		LogPropsDiff
			(
				pDetailLogger,
				pstructTCOData->m_pProps,
				pProps
			);
	}

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lptstrReturnedError,
			bLogExpected
		);
	
	free (lptstrReturnedError);
	lptstrReturnedError = NULL;

	delete pDetailLogger;

	if (pProps)
	{
		free(pProps->LoggerName);
		free(pProps->LogFileName);
	}
	free(pProps);	

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\starttraceapi.cpp ===
// StartTraceAPI.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"



int StartTraceAPI
(
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StartTrace API call return
)
{
	LPTSTR lpstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is StartTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::StartTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}
	
	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.

		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StartTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file, not to be confused with the StartTrace
	// log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("StartTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	if (pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS 
		&& pstructTCOData->m_ulAPITest != TCOData::OtherTest)
	{
		// We will verify that the LogFileName is valid if we expect the
		// call to succeed because it will fail if not a valid file.
		if (pstructTCOData->m_pProps && 
			pstructTCOData->m_pProps->LogFileName != NULL 
			&& _tcslen(pstructTCOData->m_pProps->LogFileName) > 0)
		{	
			// Verify file.
			HANDLE fileHandle = 
				CreateFile
				(
					pstructTCOData->m_pProps->LogFileName,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ,
					NULL,
					OPEN_ALWAYS,
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
					NULL
				);

			if (fileHandle == INVALID_HANDLE_VALUE) 
			{
				DWORD dwError = HRESULT_FROM_WIN32(GetLastError());

				LPTSTR lptstrError  = DecodeStatus(dwError);

				t_string tsError;

				tsError = _T("StartTraceAPI error on CreateFile for ");
				tsError += pstructTCOData->m_pProps->LogFileName;
				tsError += _T(":  ");
				t_string tsError2;
				tsError2 = lptstrError;
				tsError += tsError2;
				
				free (lptstrError);
				lptstrError = NULL;

				if (pDetailLogger)
				{
					pDetailLogger->LogTCHAR(tsError.c_str());
					pDetailLogger->Flush();
				}
				
				delete pDetailLogger;

				LogSummaryBeforeCall
				(	
					pstructTCOData, 
					lpctstrDataFile,
					lptstrAction,
					_T("StartTrace"),
					bLogExpected
				);

				LogSummaryAfterCall
				(	
					pstructTCOData, 
					lpctstrDataFile,
					lptstrAction,
					*pAPIReturn,
					(TCHAR *) tsError.c_str(),
					bLogExpected
				);

				return dwError;
			}
			
			CloseHandle(fileHandle);
			// Delete the file so that we have a clean slate. 
			DeleteFile(pstructTCOData->m_pProps->LogFileName);
		}
		else
		{
			// File either null of empty.
			t_string tsError;

			tsError = _T("StartTraceAPI got null or empty LogFileName ");
			tsError += _T("from the TCO data file.\n");

			if (pDetailLogger)
			{
				pDetailLogger->LogTCHAR(tsError.c_str());
				pDetailLogger->Flush();
			}
			
			delete pDetailLogger;

			LogSummaryBeforeCall
			(	
				pstructTCOData, 
				lpctstrDataFile,
				lptstrAction,
				_T("StartTrace"),
				bLogExpected
			);

			LogSummaryAfterCall
			(	
				pstructTCOData, 
				lpctstrDataFile,
				lptstrAction,
				*pAPIReturn,
				(TCHAR *) tsError.c_str(),
				bLogExpected
			);

			return -1;
		}
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StartTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("StartTrace"),
		bLogExpected
	);

	// Finally, make the dang API call!
	*pAPIReturn = 
		StartTrace
		(
			pstructTCOData->m_pTraceHandle, 
			pstructTCOData->m_lptstrInstanceName, 
			pstructTCOData->m_pProps
		);


	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	bool bValid = true;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::StartTraceTest && 
			 pstructTCOData->m_lptstrValidator && 
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}
		
	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			bValid,
			bAdmin
		);
	}

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);

	free(lpstrReturnedError);
	lpstrReturnedError = NULL;
	
	delete pDetailLogger;

	return ulResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
#define AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
#ifndef NT5BUILD
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\stoptraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int StopTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.	
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StopTrace API call return
)
{	
	LPTSTR lpstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is StopTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::StopTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string plpstrReturnedError.
			
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;

		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("StopTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

	*pAPIReturn = 
		StopTrace
		(
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL,
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pstructTCOData->m_pProps
		);

	
	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	bool bValid = true;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS )
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::StopTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}
		

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			bValid,
			bAdmin
		);
	}


	LogSummaryAfterCall
		(
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);
	

	free(lpstrReturnedError);
	lpstrReturnedError = NULL;

	delete pDetailLogger;

	return ulResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\structurewapperhelpers.cpp ===
// StructureWapperHelpers.cpp
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"


#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"
  
extern CConstantMap g_ConstantMap;

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif


// Why we are not using formatted input:
#if 0
From:	Phil Lucido (Exchange) 
Sent:	Friday, April 16, 1999 10:34 AM
To:	Judy Powell
Cc:	Visual C++ Special Interest Group
Subject:	RE: Wide character output via wfstream from the "Standard Library" 
using VC 6 Enterprise Edition SP2 on NT4 SP4

It looks like our iostreams implementation for wide-char streams is actually wide-char 
in memory, multibyte chars on disk.  The reason you get an empty file is because wctomb 
is failing on 0xfeff.

This should work more like the stdio stuff, where a text mode wide-char stream writes 
multibyte chars to a file, but binary mode writes the raw unicode.

We get our C++ Library implementation from Dinkumware (P.J. Plauger).  I'll check with 
him to see about changing this implementation so binary mode wide-char iostream is 
compatible with wide-char stdio.

...Phil
#endif

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode)
{
// EVENT_TRACE_FILE_MODE_NONE          0x0000  // logfile is off
// EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x0001  // log sequentially
// EVENT_TRACE_FILE_MODE_CIRCULAR      0x0002  // log in circular manner
// EVENT_TRACE_FILE_MODE_NEWFILE       0x0004  // log to new file if full
// EVENT_TRACE_REAL_TIME_MODE          0x0100  // real time mode on
// EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x0200  // delay opening file
// EVENT_TRACE_BUFFERING_MODE          0x0400  // buffering mode only

	t_string tsOut;
	
	// @#$ENUM: says that we are not storing a literal value. 
	tsOut = _T("\"LogFileMode:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	// Values we anticipate.
	if (LogFileMode == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NONE)
	{
		tsOut = _T("EVENT_TRACE_FILE_MODE_NONE");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_BUFFERING_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	
	// A value we did not anticipate.

	ULONG uExpected = 
		EVENT_TRACE_FILE_MODE_NONE | 
		EVENT_TRACE_FILE_MODE_SEQUENTIAL | 
		EVENT_TRACE_FILE_MODE_CIRCULAR |
		EVENT_TRACE_FILE_MODE_NEWFILE |
		EVENT_TRACE_REAL_TIME_MODE |
		EVENT_TRACE_DELAY_OPEN_FILE_MODE |
		EVENT_TRACE_BUFFERING_MODE | 
		EVENT_TRACE_PRIVATE_LOGGER_MODE;

	if ((uExpected | LogFileMode) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
	}

	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags)
{
// EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
// EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
// EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

// EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
// EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

// EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
// EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

// EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive
//
// Pre-defined Enable flags for everybody else
//
// EVENT_TRACE_FLAG_PRIVATE            0xC0000000  // Private buffering
// EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
// EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
// EVENT_TRACE_FLAG_ENABLE_RESERVE1    0x20000000  // Reserved
// EVENT_TRACE_FLAG_ENABLE_RESERVE2    0x10000000  // Reserved

	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"EnableFlags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (EnableFlags == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_PROCESS)
	{
		tsOut = _T("EVENT_TRACE_FLAG_PROCESS");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_PRIVATE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_FORWARD_WMI)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE1)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE2)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	ULONG uExpected = 
		EVENT_TRACE_FLAG_PROCESS | 
		EVENT_TRACE_FLAG_THREAD | 
		EVENT_TRACE_FLAG_IMAGE_LOAD |
		EVENT_TRACE_FLAG_DISK_IO |
		EVENT_TRACE_FLAG_DISK_FILE_IO |
		EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS |
		EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS | 
		EVENT_TRACE_FLAG_NETWORK_TCPIP | 
		EVENT_TRACE_FLAG_EXTENSION |
		EVENT_TRACE_FLAG_FORWARD_WMI;

	if ((uExpected | EnableFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags)
{
	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"Wnode.Flags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (WnodeFlags & WNODE_FLAG_TRACED_GUID)
	{
		if (bFirstOut)
		{
			tsOut = _T("WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
		}
	}

	ULONG uExpected = 
		WNODE_FLAG_TRACED_GUID;

	if ((uExpected | WnodeFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

}

// We print out a GUID in the form:
//  "{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// typedef struct _GUID
// {
//    DWORD  Data1;
//    WORD   Data2;
//    WORD   Data3;
//    BYTE   Data4[8];
// } GUID;
// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
// the third group of 4 hexadecimal digits. The remaining 6 bytes 
// contain the final 12 hexadecimal digits.  We have separate
// logic for acsii and unicode for Data4.
void GUIDOut(t_ostream &ros, GUID Guid)
{
	t_string tsOut;
	t_strstream strStream;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ros.flags() | ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	PutALine(ros, tsOut.c_str() , -1);
}

void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large)
{
	t_string tsOut;
	tsOut = _T("{0x");
	PutALine(ros, tsOut.c_str() , -1);

	LONG Long = Large.u.HighPart;
	PutALONGVar(ros, Large.u.HighPart,true);

	DWORD DWord = Large.u.LowPart;
	PutADWORDVar(ros, DWord);

	tsOut = _T("}");
	PutALine(ros, tsOut.c_str() , -1);
	
}

void InitializeTCHARVar(t_string &rtsValue , void *pVar)
{
	TCHAR **pTCHAR = reinterpret_cast<TCHAR **> (pVar);
	if (rtsValue.length() > 0)
	{
		// Null string.
		if (case_insensitive_compare(rtsValue,_T("@#$STRING_NULL")) == 0)
		{
			*pTCHAR = NULL;
		}
		// Empty string.
		else if (case_insensitive_compare(rtsValue,_T("@#$STRING_EMPTY")) == 0)
		{
			*pTCHAR = NewTCHAR(_T(""));
		}
		else // Just a string.
		{
			*pTCHAR = NewTCHAR(rtsValue.c_str());
		}
	}
	else // Empty string.
	{
		*pTCHAR = NewTCHAR(_T(""));
	}
}

//"EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
//"EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:0x20"
void InitializeEnumVar(t_string &rtsValue , void *pVar)
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);
	*pULong = 0;

	int nEndPos;
	int nBegPos = 0;
	int nSubstrLen;

	t_string tsTemp;

	CONSTMAP::iterator Iterator;

	bool bDone = false;

	while (!bDone)
	{
		nEndPos = rtsValue.find(_T("|"), nBegPos); 

		if (nEndPos == t_string::npos)
		{
			bDone = true;
			nEndPos = rtsValue.length();
		}

		nSubstrLen = nEndPos - nBegPos;

		tsTemp = rtsValue.substr(nBegPos, nSubstrLen);

		Iterator = g_ConstantMap.m_Map.find(tsTemp);

		if (Iterator == g_ConstantMap.m_Map.end())
		{
			// Had better be @#$UNKNOWNVALUE:0x
			if (tsTemp.compare(0, 18, _T("@#$UNKNOWNVALUE:0x")) == 0)
			{		
				tsTemp = rtsValue.substr(nBegPos + 18);
				ULONG ulTemp;
				InitializeULONGVar(tsTemp , (void *) &ulTemp, true);
				*pULong |= ulTemp;
			}

		}
		else
		{
			*pULong |= (*Iterator).second; 
		}

		nBegPos = nEndPos + 1;
	}


}

// Expect HANDLEs to be in the form 0xnnnnnnnn
void InitializeHandleVar(t_string &rtsValue , void *pVar)
{
	HANDLE *pHandle = reinterpret_cast<HANDLE *> (pVar);
	HANDLE handle;

	t_strstream strStream;

	t_string tsTemp;
	tsTemp = rtsValue.substr(2);
	
	strStream << tsTemp;

	strStream >> handle;

	*pHandle = handle;

}

void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex )
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);

	ULONG uLong;

	t_strstream strStream;
	
	strStream << rtsValue;

	if (bHex)
	{
		strStream >> hex >> uLong;
	}
	else
	{
		strStream >> uLong;
	}


	*pULong = uLong;
}

void InitializeLONGVar(t_string &rtsValue , void *pVar)
{
	LONG *pLong = reinterpret_cast<LONG *> (pVar);
	LONG Long;

	t_strstream strStream;
	
	strStream << rtsValue;

	strStream >> Long;

	*pLong = Long;

}

t_istream &GetAChar(t_istream &ris,TCHAR &tc)
{
#ifndef _UNICODE
	tc = ris.get();
	return ris;
#else
	char *pChar = (char *) &tc;
	
	pChar[0] = ris.get();
	pChar[1] = ris.get();

	return ris;

#endif
}


// See note at top of this file to understand why we are not using
// formatted input.
// We are reading in a wide character file one byte at a time and
// creating our two byte characters from each two byte sequence.
t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
	t_istream &r = ris.getline(tcBuffer,nBufferSize - 1,_T('\n'));
	// Docs for getline say that it sould eat the new line.  It does
	// not, and it does even worse.  It returns a 0x0d which we delete.
	// This should work even when getline does
	// what the docs say it will.
	int n = _tcsclen(tcBuffer) - 1;

	if (tcBuffer[n] == 0x0d)
	{
		tcBuffer[n] = _T('\0');
	}

	return r;
#else
	char *pChar = (char *) tcBuffer;
	bool bSkipNext = false;
	bool bEOL = false;
	int intIn1;
	int intIn2;
	int i = 0;
	int count = 0;
	while (1)
	{
		intIn1 = ris.get();
		if (ris.eof())
		{
			break;
		}
		intIn2 = ris.get();
		
		if (intIn1 == 0x0d && intIn2 == 0x0)
		{
			// Found 0x0d so eat the 0x0a.
			intIn1 = ris.get();
			intIn2 = ris.get();
			tcBuffer[i / 2] = _T('\0');
			break;
		}
		else 
		{
			pChar[i++] = intIn1;
			pChar[i++] = intIn2;
		}
	}

	if (i == 0)
	{
		tcBuffer[0] = _T('\0');
	}

	return ris;

#endif

}

// See note at top of this file to understand why we are not using
// formatted input.
// We are writing out a wide character file one byte at a time.
// nBufferSize is the number of TCHARS not size in bytes.
// if nBufferSize == -1 tcBuffer better be a null terminated string.
// Will handle a unicode string with "proper" and "inproper" newlines. 
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
//	return ros << tcBuffer;
	const char *pBuffer =  tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 1] != 0x0d)
		{
			ros.put(0x0d);
		}
		ros.put(intOut);
	}
	
	return ros;
#else
	char *pBuffer = (char *) tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize * 2; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 2] != 0x0d)
		{
			ros.put(0x0d);
			ros.put(0x0);
		}
		ros.put(intOut);
	}
	
	return ros;
#endif

}

// Hex flavor not tested for non-unicode.
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << l;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << l;
	}
#else

	t_string tsTemp;
	t_strstream strStream;
	
	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << l;
	}
	else
	{
		strStream << l;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64)
{
	ULONG *lArray = (ULONG *) &ul64;
	PutAULONGVar( ros, lArray[0], true);
	PutAULONGVar( ros, lArray[1], true);
	return ros;
}

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << ul;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << ul;
	}
#else

	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw)
{
#ifndef _UNICODE
	TCHAR f = ros.fill(_T('0'));
	int w = ros.width(8);
	int fl =	ros.flags(ros.flags() | ios_base::right);
	ros << hex << dw;
	ros.fill(f);
	ros.width(w);
	ros.flags(fl);

	return ros << dec;
#else

	t_string tsTemp;
	t_strstream strStream;
	
	strStream.width(8);
	strStream.fill('0');
	strStream.flags(ios_base::right);
	strStream << hex << dw;
	
	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}


void InitializeGUIDVar(t_string &rtsValue , void *pVar)
{
	GUID *pGUID = reinterpret_cast<GUID *> (pVar);
	if (rtsValue.length() > 0 && case_insensitive_compare(rtsValue,_T("@#$NA")) != 0)
	{
		wGUIDFromString(rtsValue.c_str(), pGUID);
	}
	else
	{
		RtlZeroMemory(pGUID, sizeof(GUID));
	}


}

// *** Following routine copied from WMI\MofCheck. to convert 
// a guid string to a GUID. 
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------

BOOL HexStringToDword(LPCTSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
    if (*lpsz == '{' )
        lpsz++;
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

int case_insensitive_compare(t_string &r1, t_string &r2)
{

	t_string tsTemp1;
	t_string tsTemp2;
	tsTemp1 = r1.c_str();
	tsTemp2 = r2.c_str();

	int i;
	for (i = 0; i < tsTemp1.length(); i++)
	{
		tsTemp1.replace(i,1,1, toupper(tsTemp1[i]));
	}

	for (i = 0; i < tsTemp2.length(); i++)
	{
		tsTemp2.replace(i,1,1, toupper(tsTemp2[i]));
	}

	return tsTemp1.compare(tsTemp2);
}

int case_insensitive_compare(TCHAR *p, t_string &r2)
{ 
	if (p == NULL)
	{
		return -1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(tsTemp, r2);
}

int case_insensitive_compare(t_string &r1,TCHAR *p )
{ 
	if (p == NULL)
	{
		return 1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(r1, tsTemp);
}

int case_insensitive_compare(TCHAR *p1,TCHAR *p2)
{
	if (!p1 && !p2)
	{
		return 0;
	}
	else if (!p1)
	{
		return -1;
	} else if (!p2)
	{
		return 1;
	}

	int l1 = _tcslen(p1);
	int l2 = _tcslen(p2);

	int nCompare = _tcsnicmp(p1,p2,_MIN(l1,l2));

	if (nCompare == 0)
	{
		if (l1 == l2)
		{
			return 0;
		}
		else if (l1 < l2)
		{
			return -1;
		}
		else
		{
			return 1;
		}
	}
	else
	{
		return nCompare;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\structurewrappers.h ===
// StructureWrappers.h: interface for the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CPersistor;
class CEventTraceProperties;

// Need to be declared before seen in class.  Well, duh!
t_ostream& operator<<
	(t_ostream &ros,const CEventTraceProperties &r);
t_istream& operator>>
	(t_istream &ris,CEventTraceProperties &r);


// The general methodology used here may seem clunky to
// a C programmer.  
// If you want to serialize an existing
// EVENT_TRACE_PROPERTIES instance use the Constructor
// "CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)"
// to create a CEventTraceProperties instance, call
// Persist, and then destroy the CEventTraceProperties
// instance.
// If you want to de-deserialize an instance call the 
// Constructor "CEventTraceProperties()", call Persist,
// call GetEventTracePropertiesInstance, then destroy the
// CEventTraceProperties instance.
// The copy constructor and assignment operators are included
// only for completeness and it is anticipated that they
// will not be used.
// Using Persist for de-serialization assumes you have a valid
// stream which contains a serialized instance.   
class CEventTraceProperties 
{
private:
	friend t_ostream& operator<<
		(t_ostream &ros,const CEventTraceProperties &r);
	friend t_istream& operator>>
		(t_istream &ris,CEventTraceProperties &r);
	friend class CPersistor;

public:
	CEventTraceProperties();
	// This constructor creates a new EVENT_TRACE_PROPERTIES 
	// instance.
	CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	virtual ~CEventTraceProperties();

	CEventTraceProperties(CEventTraceProperties &rhs);
	CEventTraceProperties &CEventTraceProperties::operator=
					(CEventTraceProperties &rhs);

	virtual HRESULT Persist (CPersistor &rPersistor);
	bool DeSerializationOK() {return m_bDeSerializationOK;}

	// Constructs an new EVENT_TRACE_PROPERTIES instance and
	// returns it.
	PEVENT_TRACE_PROPERTIES GetEventTracePropertiesInstance();
	bool IsNULL() {return m_bIsNULL;}

protected:
	bool m_bDeSerializationOK;
	bool m_bIsNULL;
	void Initialize(PEVENT_TRACE_PROPERTIES pProps);
	void InitializeMemberVar(TCHAR *ptszValue, int nVar);
	void *m_pVarArray[19];


	PEVENT_TRACE_PROPERTIES m_pProps;



};

#endif // !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\structurewrappers.cpp ===
// StructureWrappers.cpp: implementation of the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"


//////////////////////////////////////////////////////////////////////
// Wrappers that serialize and de-serialize Event Tracing Data 
// Structures.
//////////////////////////////////////////////////////////////////////
#define MAX_LINE 1024

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif

CConstantMap g_ConstantMap;

//////////////////////////////////////////////////////////////////////
// _EVENT_TRACE_PROPERTIES
//////////////////////////////////////////////////////////////////////

CEventTraceProperties::CEventTraceProperties()
{
	m_pProps = NULL;
	m_bIsNULL = true;
}

CEventTraceProperties::CEventTraceProperties
(PEVENT_TRACE_PROPERTIES pProps)
{
	Initialize(pProps);
}

CEventTraceProperties::~CEventTraceProperties()
{
	if (m_pProps)
	{
		free(m_pProps->LogFileName);
		m_pProps->LogFileName = NULL;
		free(m_pProps->LoggerName);
		m_pProps->LoggerName = NULL;
		free(m_pProps);
		m_pProps = NULL;
	}
	m_bIsNULL = true;

}

CEventTraceProperties::CEventTraceProperties(CEventTraceProperties &rhs)
{
	Initialize(rhs.m_pProps);

}

CEventTraceProperties &CEventTraceProperties::operator=
(CEventTraceProperties &rhs)
{
	if ( this != &rhs ) 
	{
    	delete this;
    	
		Initialize(rhs.m_pProps);
    }
    
	return *this;

}
#if 0
"_EVENT_TRACE_PROPERTIES Instance Begin"
"BufferSize:ULONG:32"
"MinimunBuffers:ULONG:2"
"MaximunBuffers:ULONG:3"
"MaximunFileSize:ULONG:4"
"LogFileMode:@#$ENUM:EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
"FlushTimer:ULONG:6"
"EnableFlags:@#$ENUM:EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:20"
"NumberOfBuffers:ULONG:8"
"FreeBuffers:ULONG:9"
"EventsLost:ULONG:10"
"BuffersWritten:ULONG:11"
"LogBuffersLost:ULONG:12"
"RealTimeBuffersLost:ULONG:13"
"AgeLimit:LONG:-14"
"LoggerThreadId:HANDLE:0000000F"
"LogFileName:TCHAR*:Log file name"
"LoggerName:TCHAR*:Logger name"
"_EVENT_TRACE_PROPERTIES Instance End"
#endif
void CEventTraceProperties::InitializeMemberVar(TCHAR *tcBuffer, int nVar)
{

	int nDebug = 0;
	if (nVar == 17 || nVar == 18)
	{
		nDebug = nVar;
	}

	t_string tsTemp;
	
	tsTemp = tcBuffer;

	int nPos = tsTemp.find(_T(":"), 0);

	// The first character in the type.
	int nPosType = nPos + 1;

	if (nPos == t_string::npos)
	{
		m_bDeSerializationOK = false;
		return;
	}

	nPos = tsTemp.find(_T(":"), nPos + 1);
	
	t_string tsType;

	tsType = tsTemp.substr(nPosType,nPos - nPosType);

	// The first chatacter in the value.
	++nPos;

	t_string tsValue;
	tsValue = tsTemp.substr(nPos, (tsTemp.length() - nPos) - 1);

	// a TCHAR * value
	if (tsType.compare(_T("TCHAR*")) == 0)
	{
		InitializeTCHARVar(tsValue ,m_pVarArray[nVar]);
	}
	// A #define value
	else if (tsType.compare(_T("@#$ENUM")) == 0)
	{
		InitializeEnumVar(tsValue , m_pVarArray[nVar]);
	}
	// A HEX
	else if (tsType.compare(_T("HANDLE")) == 0)
	{
		InitializeHandleVar(tsValue , m_pVarArray[nVar]);
	}
	// An unsigned value
	else if (tsType.compare(_T("ULONG")) == 0)
	{
		InitializeULONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("LONG")) == 0)
	{
		InitializeLONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("GUID")) == 0)
	{
		InitializeGUIDVar(tsValue , m_pVarArray[nVar]);
	}

}

void CEventTraceProperties::Initialize
(PEVENT_TRACE_PROPERTIES pProps)
{
	m_bDeSerializationOK = true;
	if (pProps == NULL)
	{
		m_pProps = NULL;
		m_bIsNULL = true;
	}

	m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(m_pProps, sizeof(EVENT_TRACE_PROPERTIES));
	*m_pProps = *pProps;
	
	m_pProps -> LogFileName = pProps -> LogFileName ? 
								NewTCHAR(pProps -> LogFileName) :
								NULL;
	m_pProps -> LoggerName = pProps -> LoggerName ?
								NewTCHAR(pProps -> LoggerName) :
								NULL;

	m_pProps -> Wnode.BufferSize = sizeof(*m_pProps);

	m_bIsNULL = false;

}

PEVENT_TRACE_PROPERTIES 
CEventTraceProperties::GetEventTracePropertiesInstance()
{
	if (m_pProps == NULL)
	{
		return NULL;
	}

	EVENT_TRACE_PROPERTIES *pProps = 
		(EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(pProps, sizeof(EVENT_TRACE_PROPERTIES));

	*pProps = *m_pProps;
	
	pProps -> LogFileName = m_pProps -> LogFileName ? 
								NewTCHAR(m_pProps -> LogFileName) :
								NULL;
	pProps -> LoggerName = m_pProps -> LoggerName ?
								NewTCHAR(m_pProps -> LoggerName) :
								NULL;
	int n1 = sizeof(*pProps);
	int n2 = sizeof(EVENT_TRACE_PROPERTIES);

	pProps -> Wnode.BufferSize = sizeof(*pProps);
	
	return pProps;
}

HRESULT CEventTraceProperties::Persist (CPersistor &rPersistor)
{
	if (rPersistor.IsLoading())
	{
		rPersistor.Stream() >> *this;
	}
	else
	{
		rPersistor.Stream() << *this;
	}

	return S_OK;

}

t_ostream& operator<<(t_ostream &ros, const CEventTraceProperties &r)
{
	t_string tsOut;

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"\n");
	PutALine(ros, tsOut.c_str());

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	tsOut = _T("\"Wnode.Guid:GUID:");
	PutALine(ros, tsOut.c_str());
	GUIDOut(ros, r.m_pProps -> Wnode.Guid);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	WnodeFlagsOut(ros, r.m_pProps -> Wnode.Flags);

	tsOut = _T("\"BufferSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BufferSize);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MinimunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MinimumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunFileSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumFileSize);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	LogFileModeOut(ros, r.m_pProps -> LogFileMode );

	tsOut = _T("\"FlushTimer:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FlushTimer);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	EnableFlagsOut(ros,r.m_pProps -> EnableFlags);

//	ros << _T("\"NumberOfBuffers:ULONG:") << r.m_pProps -> NumberOfBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"NumberOfBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> NumberOfBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"FreeBuffers:ULONG:") << r.m_pProps -> FreeBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"FreeBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FreeBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"EventsLost:ULONG:") << r.m_pProps -> EventsLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"EventsLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> EventsLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"BuffersWritten:ULONG:") << r.m_pProps -> BuffersWritten << g_tcDQuote << g_atcNL;

	tsOut = _T("\"BuffersWritten:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BuffersWritten);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogBuffersLost:ULONG:") << r.m_pProps -> LogBuffersLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"LogBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> LogBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());


//	ros << _T("\"RealTimeBuffersLost:ULONG:") << r.m_pProps -> RealTimeBuffersLost << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"RealTimeBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> RealTimeBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
	
	
//	ros << _T("\"AgeLimit:LONG:") << r.m_pProps -> AgeLimit << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"AgeLimit:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutALONGVar(ros, r.m_pProps -> AgeLimit);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	// Handles are in hex.
//	ros << _T("\"LoggerThreadId:HANDLE:0x") << r.m_pProps -> LoggerThreadId << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerThreadId:HANDLE:0x");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, (ULONG) r.m_pProps -> LoggerThreadId, true);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogFileName:TCHAR*:") << r.m_pProps -> LogFileName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LogFileName:TCHAR*:");
	if (r.m_pProps -> LogFileName)
	{
		tsOut += r.m_pProps -> LogFileName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LoggerName:TCHAR*:") << r.m_pProps -> LoggerName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerName:TCHAR*:");
	if (r.m_pProps -> LoggerName)
	{
		tsOut += r.m_pProps -> LoggerName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance End\"\n");
	PutALine(ros, tsOut.c_str());

	return ros;
}

t_istream& operator>>(t_istream &ris,CEventTraceProperties &r)
{
	r.m_bDeSerializationOK = true;

	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	GetALine(ris, ptcBuffer,MAX_LINE);


	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance NULL\"")) == 0)
	{
		r.~CEventTraceProperties();
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);
		return ris;
	}

	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"")) != 0)
	{
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);

		return ris;
	}

	r.~CEventTraceProperties();

	r.m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(r.m_pProps, sizeof(EVENT_TRACE_PROPERTIES));

	r.m_pProps->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	r.m_pVarArray[0] = &r.m_pProps->Wnode.Guid;
	r.m_pVarArray[1] = &r.m_pProps->Wnode.Flags;
	r.m_pVarArray[2] = &r.m_pProps->BufferSize;
	r.m_pVarArray[3] = &r.m_pProps->MinimumBuffers;
	r.m_pVarArray[4] = &r.m_pProps->MaximumBuffers;
	r.m_pVarArray[5] = &r.m_pProps->MaximumFileSize;
	r.m_pVarArray[6] = &r.m_pProps->LogFileMode;
	r.m_pVarArray[7] = &r.m_pProps->FlushTimer;
	r.m_pVarArray[8] = &r.m_pProps->EnableFlags;
	r.m_pVarArray[9] = &r.m_pProps->NumberOfBuffers;
	r.m_pVarArray[10] = &r.m_pProps->FreeBuffers;
	r.m_pVarArray[11] = &r.m_pProps->EventsLost;
	r.m_pVarArray[12] = &r.m_pProps->BuffersWritten;
	r.m_pVarArray[13] = &r.m_pProps->LogBuffersLost;
	r.m_pVarArray[14] = &r.m_pProps->RealTimeBuffersLost;
	r.m_pVarArray[15] = &r.m_pProps->AgeLimit;
	r.m_pVarArray[16] = &r.m_pProps->LoggerThreadId;
	r.m_pVarArray[17] = &r.m_pProps->LogFileName;
	r.m_pVarArray[18] = &r.m_pProps->LoggerName;


	int n = 0;
	while (n < 19 && GetALine(ris,ptcBuffer,MAX_LINE))
	{
		r.InitializeMemberVar(ptcBuffer,n++);
	}

	// Consume end of Props
	GetALine(ris,ptcBuffer,MAX_LINE);

	free(ptcBuffer);

	BOOL bHeapGood = HeapValidate(GetProcessHeap(), 0, NULL);

	return ris;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\structurewapperhelpers.h ===
// StructureWapperHelpers.h
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode);
void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags);
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags);
void GUIDOut(t_ostream &ros, GUID Guid);
void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large);

void InitializeTCHARVar(t_string &rtsValue , void *pVar);
void InitializeEnumVar(t_string &rtsValue , void *pVar);
void InitializeHandleVar(t_string &rtsValue , void *pVar);
void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex = false);
void InitializeLONGVar(t_string &rtsValue , void *pVar);
void InitializeGUIDVar(t_string &rtsValue , void *pVar);

t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize);
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize = -1);

t_istream &GetAChar(t_istream &ris,TCHAR &tc);

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex = false);
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex = false);
t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw);
t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64);

BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid);

int case_insensitive_compare(t_string &r1, t_string &r2);
int case_insensitive_compare(TCHAR *p, t_string &r2);
int case_insensitive_compare(t_string &r1,TCHAR *p );
int case_insensitive_compare(TCHAR *p1,TCHAR *p2);





#endif // !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\tcodata.h ===
#if !defined(AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


struct TCOData
{
	LPTSTR m_lptstrShortDesc;
	LPTSTR m_lptstrLongDesc;
	ULONG m_ulExpectedResult;
	ULONG m_ulAPITest;
	LPTSTR m_lptstrExpectedResult;
	TRACEHANDLE *m_pTraceHandle;
	LPTSTR m_lptstrInstanceName;
	LPTSTR m_lptstrLoggerMode;	
	int m_nGuids;
	LPGUID m_lpguidArray;
	ULONG m_ulEnable;
	ULONG m_ulEnableFlag;
	ULONG m_ulEnableLevel;
	PEVENT_TRACE_PROPERTIES m_pProps;		
	LPTSTR m_lptstrValidator;
	enum 
	{ 
		OtherTest = 0,
		StartTraceTest = 1,
		StopTraceTest = 2,
		EnableTraceTest = 3,
		QueryTraceTest = 4,
		UpdateTraceTest = 5,
		QueryAllTracesTest = 6
	};

};

struct TCOFunctionalData
{
	int m_nProviders;
	LPTSTR *m_lptstrProviderArray;
	int m_nConsumers;
	LPTSTR *m_lptstrConsumerArray;
};


void FreeTCOData (TCOData *pstructTCOData);
void FreeTCOFunctionalData (TCOFunctionalData *pstructTCOFunctionalData);

int GetAllTCOData
(
	IN LPCTSTR lpctstrFile,
	OUT TCOData **pstructTCOData,
	OUT TCOFunctionalData **pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc, // Any error we had.
	IN bool bGetFunctionalData = true
);

int GetTCOData
(
	IN CPersistor &PersistorIn,
	OUT TCOData *pstructTCOData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);

int GetTCOData
(	IN CPersistor &PersistorIn,
	OUT LPTSTR *plptstrShortDesc,
	OUT LPTSTR *plptstrLongDesc,
	OUT ULONG *pExpectedResult,
	OUT LPTSTR *plptstrExpectedResult,
	OUT TRACEHANDLE **pTraceHandle,
	OUT LPTSTR *plptstrInstanceName,
	OUT LPTSTR *plptstrLoggerMode,
	OUT PEVENT_TRACE_PROPERTIES *pProps,
	OUT LPTSTR *plptstrValidator,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);


int TCOFunctionalObjects
(	IN CPersistor &PersistorIn,
	IN OUT TCOFunctionalData *pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
);

#endif // !defined(AFX_TCODATA_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\tcodata.cpp ===
// StartTrace.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <fcntl.h>
#include <io.h>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 

#include "CollectionControl.h"
 
extern CConstantMap g_ConstantMap;

#define MAX_LINE 2048

int ParseGuids
(
	TCHAR *ptcBuffer, 
	TCOData *pstructTCOData, 
	LPTSTR *plptstrErrorDesc
);

int ParseExeData
(
	t_string &tsData, 
	int &nExes, 
	LPTSTR *&lptstrArray,
	LPTSTR *plptstrErrorDesc
);


// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int GetAllTCOData
(
	IN LPCTSTR lpctstrFile,
	OUT TCOData **pstructTCOData,
	OUT TCOFunctionalData **pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc, // Any error we had.
	IN bool bGetFunctionalData
)
{
	*pstructTCOData = (TCOData *) malloc (sizeof(TCOData));
	RtlZeroMemory(*pstructTCOData , sizeof(TCOData));

	if (bGetFunctionalData)
	{
		*pstructTCOFunctionalData = (TCOFunctionalData *) malloc(sizeof(TCOFunctionalData));
		RtlZeroMemory(*pstructTCOFunctionalData , sizeof(TCOFunctionalData));
	}

	LPSTR lpstrFile;
#ifdef UNICODE
	lpstrFile = NewLPSTR(lpctstrFile);
#else
	lpstrFile = NewTCHAR(lpctstrFile);
#endif

	CPersistor PersistorIn
		(lpstrFile, 
		ios::in | 0x20, // ios::nocreate = 0x20 - cannot get to compile!!!
		true );

	HRESULT hr = PersistorIn.Open();

	if (FAILED(hr))
	{
		t_string tsTemp;
		tsTemp = _T("TCOData error:  Could not open file or file was not in correct character set (Unicode or ANSI) for file ");
		t_string tsFile;
#ifdef _UNICODE
		LPWSTR lpwstrTemp = NewLPWSTR(lpstrFile);
		tsFile = lpwstrTemp;
		free(lpwstrTemp);
#else
		tsFile = lpstrFile;
	
#endif
		tsTemp += tsFile;
		free (lpstrFile);
		lpstrFile = NULL;
		tsTemp += _T(".");
		*plptstrErrorDesc = NewTCHAR(tsTemp.c_str());
		return -1;
	}

	free (lpstrFile);
	lpstrFile = NULL;

	int nReturn = 
		GetTCOData
		(
			PersistorIn,
			*pstructTCOData,
			plptstrErrorDesc // Any error we had.
		);

	if (nReturn != ERROR_SUCCESS)
	{
		PersistorIn.Close();
		return nReturn;
	}

	if (bGetFunctionalData)
	{
		nReturn = 
			TCOFunctionalObjects
			(	
				PersistorIn,
				*pstructTCOFunctionalData,
				plptstrErrorDesc // Describes error this function had.
			);
	}


	PersistorIn.Close();
	return nReturn;

}

// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int GetTCOData
(
	IN CPersistor &PersistorIn,
	OUT TCOData *pstructTCOData,
	OUT LPTSTR *plptstrErrorDesc // Any error we had.
)
{
	RtlZeroMemory(pstructTCOData , sizeof(TCOData));

	
	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	*plptstrErrorDesc = NULL;

	// Short description
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrShortDesc = NewTCHAR(ptcBuffer);

	// Long description.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrLongDesc = NewTCHAR(ptcBuffer);

	// Expected result had better be in the Constant map.
	// Constant map is used to map a string to an undsigned int.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	t_string tsTemp;
	tsTemp = ptcBuffer;

	CONSTMAP::iterator Iterator;
	Iterator = g_ConstantMap.m_Map.find(tsTemp);

	// If you do not find your value in the map look in 
	// ConstantMap.cpp.  You probably forgot to add it;->
	if (Iterator == g_ConstantMap.m_Map.end())
	{
		*plptstrErrorDesc = NewTCHAR(_T("TCOData error:  Expected error is not in map"));
		free(ptcBuffer);
		return -1;
	}
	else
	{
		pstructTCOData->m_lptstrExpectedResult = NewTCHAR(ptcBuffer);
		pstructTCOData->m_ulExpectedResult = (*Iterator).second; 
	}

	// TraceHandle values are VALUE_VALID or VALUE_NULL
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;

	if (case_insensitive_compare(tsTemp,_T("VALUE_VALID")) == 0)
	{
		pstructTCOData->m_pTraceHandle = 
			(TRACEHANDLE *) malloc (sizeof(TRACEHANDLE));
		*pstructTCOData->m_pTraceHandle = NULL;
	}
	else if (case_insensitive_compare(tsTemp,_T("VALUE_NULL")) == 0)
	{
		pstructTCOData->m_pTraceHandle = (TRACEHANDLE *) NULL;
	}
	else
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Error in value of TraceHandle.  Valid values are \"VALUE_VALID\" or \"VALUE_NULL\"."));
		free(ptcBuffer);
		return -1;	
	}

	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	InitializeTCHARVar(tsTemp , (void *) &pstructTCOData->m_lptstrInstanceName);

	// API test - valid values 0 - 6
	//  OtherTest = 0,
	//	StartTraceTest = 1,
	//	StopTraceTest = 2,
	//	EnableTraceTest = 3,
	//	QueryTraceTest = 4,
	//	UpdateTrace = 5,
	//	QueryAllTraces = 6
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	InitializeULONGVar(tsTemp , (void *) &pstructTCOData->m_ulAPITest);

	if (pstructTCOData->m_ulAPITest < 0 || pstructTCOData->m_ulAPITest > 6)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Error in value of m_ulAPITest.  Valid values are 0 - 6.  See enum in TCOData.h"));
		free(ptcBuffer);
		return -1;	
	}

	// Valid values are KERNEL_LOGGER or PRIVATE_LOGGER
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	pstructTCOData->m_lptstrLoggerMode = NewTCHAR(ptcBuffer);


	// Enable is used for EnableTrace.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,7),_T("ENABLE:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  Enable: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeULONGVar(tsTemp.substr(7) , &pstructTCOData->m_ulEnable);
	}

	// EnableFlag is used for EnableTrace and is passed to the provider.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,11),_T("ENABLEFLAG:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  EnableFlag: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeHandleVar(tsTemp.substr(11) , &pstructTCOData->m_ulEnableFlag);
	}

	// EnableLevel is used for EnableTrace and is passed to the provider.
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	tsTemp = ptcBuffer;
	if (case_insensitive_compare(tsTemp.substr(0,12),_T("ENABLELEVEL:")) != 0)
	{
		*plptstrErrorDesc = 
			NewTCHAR
			(_T("TCOData error:  EnableLevel: expected."));
		free(ptcBuffer);
		return -1;	
	}
	else
	{
		InitializeHandleVar(tsTemp.substr(12) , &pstructTCOData->m_ulEnableLevel);
	}

	CEventTraceProperties cPropsIn;

	// This has to be mofified to allow a NULL strucutre.
	cPropsIn.Persist( PersistorIn);
	
	pstructTCOData->m_pProps = cPropsIn.GetEventTracePropertiesInstance();
	if (pstructTCOData->m_pProps &&
		case_insensitive_compare(tsTemp,_T("PRIVATE_LOGGER")) == 0)
	{
		pstructTCOData->m_pProps->LogFileMode = 
			pstructTCOData->m_pProps->LogFileMode | EVENT_TRACE_PRIVATE_LOGGER_MODE;
	}
	
	GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
	int nReturn = ParseGuids(ptcBuffer, pstructTCOData, plptstrErrorDesc);

	if(nReturn != ERROR_SUCCESS)
	{
		return nReturn;
	}

	// Validator
	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		pstructTCOData->m_lptstrValidator = NewTCHAR(ptcBuffer);
	}

	free(ptcBuffer);
	return 0;
}

// If an error occurs you users of this function must delete
// plptstrErrorDesc.  It will contain a string describing
// the error.
int TCOFunctionalObjects
(	IN CPersistor &PersistorIn,
	IN OUT TCOFunctionalData *pstructTCOFunctionalData,
	OUT LPTSTR *plptstrErrorDesc // Describes error this function had.
)
{
	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	*plptstrErrorDesc = NULL;

	t_string tsTemp;
	t_string tsError;
	t_string tsSubstr;

	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		tsTemp = ptcBuffer;
		tsSubstr = tsTemp.substr(0,9);
		if (case_insensitive_compare(tsSubstr,_T("provider:")) == 0)
		{
			tsSubstr = tsTemp.substr(9);
			int nReturn = 
				ParseExeData
				(
					tsSubstr, 
					pstructTCOFunctionalData->m_nProviders, 
					pstructTCOFunctionalData->m_lptstrProviderArray,
					plptstrErrorDesc
				);

			if (nReturn != ERROR_SUCCESS)
			{
				tsError = _T("Invalid providers argument: ");
				tsError += tsTemp;
				tsError += _T(".");
				*plptstrErrorDesc = NewTCHAR(tsError.c_str());
				free(ptcBuffer);
				return -1;
			}
		}
		else
		{
			tsError = _T("Invalid providers argument: ");
			tsError += tsTemp;
			tsError += _T(".");
			*plptstrErrorDesc = NewTCHAR(tsError.c_str());
			free(ptcBuffer);
			return -1;
		}
	}

	// We may have a DataProvider.  If not we us our default.
	if (PersistorIn.Stream().eof() == false)
	{
		GetALine(PersistorIn.Stream(),ptcBuffer, MAX_LINE);
		tsTemp = ptcBuffer;
		tsSubstr = tsTemp.substr(0,9);
		if (case_insensitive_compare(tsSubstr,_T("consumer:")) == 0)
		{
			tsSubstr = tsTemp.substr(9);
			int nReturn = 
				ParseExeData
				(
					tsSubstr, 
					pstructTCOFunctionalData->m_nConsumers, 
					pstructTCOFunctionalData->m_lptstrConsumerArray,
					plptstrErrorDesc
				);

			if (nReturn != ERROR_SUCCESS)
			{
				tsError = _T("Invalid consumers argument: ");
				tsError += tsTemp;
				tsError += _T(".");
				*plptstrErrorDesc = NewTCHAR(tsError.c_str());
				free(ptcBuffer);
				return -1;
			}
		}
		else
		{
			tsError = _T("Invalid consumers argument: ");
			tsError += tsTemp;
			tsError += _T(".");
			*plptstrErrorDesc = NewTCHAR(tsError.c_str());
			free(ptcBuffer);
			return -1;
		}
	}

	free(ptcBuffer);
	return 0;
}


void FreeTCOData (TCOData *pstructTCOData)
{
	if (!pstructTCOData)
	{
		return;
	}

	free(pstructTCOData->m_lptstrShortDesc);
	free(pstructTCOData->m_lptstrLongDesc);
	free(pstructTCOData->m_lptstrExpectedResult);
	free(pstructTCOData->m_pTraceHandle);
	free(pstructTCOData->m_lptstrInstanceName);
	free(pstructTCOData->m_lptstrLoggerMode);
	free(pstructTCOData->m_lpguidArray);
	if (pstructTCOData->m_pProps)
	{
		free(pstructTCOData->m_pProps->LoggerName);
		free(pstructTCOData->m_pProps->LogFileName);
	}
	free(pstructTCOData->m_pProps);		
	free(pstructTCOData->m_lptstrValidator);

	free(pstructTCOData);
}

void FreeTCOFunctionalData (TCOFunctionalData *pstructTCOFunctionalData)
{
	if (!pstructTCOFunctionalData)
	{
		return;
	}

	int i;
	TCHAR *pTemp;

	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		pTemp = pstructTCOFunctionalData->m_lptstrProviderArray[i];
		free (pTemp);
	}
	 
	free (pstructTCOFunctionalData->m_lptstrProviderArray);

	for (i = 0; i < pstructTCOFunctionalData->m_nConsumers; i++)
	{
		pTemp = pstructTCOFunctionalData->m_lptstrConsumerArray[i];
		free (pTemp);
	}
	 
	free (pstructTCOFunctionalData->m_lptstrConsumerArray);

	free(pstructTCOFunctionalData);
}

int ParseExeData
(
	t_string &tsData, 
	int &nExes, 
	LPTSTR *&lptstrArray,
	LPTSTR *plptstrErrorDesc
)
{
	// Embedded " are not allowed in the command line.  Had to draw
	// the line somewhere.
	// Tokenize on "," and " at end of line.
	list <t_string> listExes;

	bool bDone = false;
	
	int nBeg = 0;
	int nFind = tsData.find(_T(","), nBeg);
	
	t_string tsExe;

	while (!bDone)
	{
		if (nFind != t_string::npos)
		{
			tsExe = tsData.substr(nBeg,nFind - nBeg);
			listExes.push_back(tsExe);
			tsExe.erase();
		}
		else
		{
			tsExe = tsData.substr(nBeg,t_string::npos);
			listExes.push_back(tsExe);
			bDone = true;
			tsExe.erase();
		}
		nBeg = nFind + 1;
		nFind = tsData.find(_T(","), nBeg);
	}

	// Allocate the Exe array
	nExes = listExes.size();
	lptstrArray = 
			(TCHAR **) malloc (sizeof(TCHAR *) * nExes);
	RtlZeroMemory
			(lptstrArray, 
			sizeof(sizeof(TCHAR *) * nExes));

	list<t_string>::iterator pListExes;

	int i = 0;

	for (pListExes = listExes.begin(); pListExes != listExes.end() ; ++pListExes)
	{
		tsExe = (*pListExes);
		lptstrArray[i++] = NewTCHAR(tsExe.c_str());
	}

	return ERROR_SUCCESS;
}


int ParseGuids
(
	TCHAR *ptcBuffer, 
	TCOData *pstructTCOData, 
	LPTSTR *plptstrErrorDesc
)
{

	// Is Wnode does not have a GUID put the first one from list in it.
	t_string tsTemp;
	tsTemp = ptcBuffer;

	if (case_insensitive_compare(tsTemp.substr(0,6),_T("guids:")) != 0)
	{
		tsTemp.erase();
		tsTemp = _T("Invalid Guids entry: ");
		tsTemp += ptcBuffer;
		tsTemp += _T(".");
		*plptstrErrorDesc = NewTCHAR(tsTemp.c_str());
		return -1;
	}

	// Count the commas
	int nFind = tsTemp.find(_T(','));

	t_string tsGuid;
	int nBeg = 6;

	if(nBeg == tsTemp.length())
	{
		pstructTCOData->m_nGuids = 0;
		pstructTCOData->m_lpguidArray = NULL;
		return 0;
	}

	// We only have one GUID.
	if (nFind == t_string::npos)
	{
		tsGuid = tsTemp.substr(nBeg,nFind - nBeg);
		// Allocate the GUID array
		pstructTCOData->m_nGuids = 1;
		pstructTCOData->m_lpguidArray = 
			(GUID *) malloc (sizeof(GUID) * pstructTCOData->m_nGuids);
		RtlZeroMemory
			(pstructTCOData->m_lpguidArray , 
			sizeof(sizeof(GUID) * pstructTCOData->m_nGuids));
		// Just one GUID, thank you.
		wGUIDFromString(tsGuid.c_str(), &pstructTCOData->m_lpguidArray[0]);
	
		return 0;
	}

	// We have more than one GUID.
	bool bDone = false;


	list <t_string> listGuids;

	while (!bDone)
	{
		if (nFind != t_string::npos)
		{
			tsGuid = tsTemp.substr(nBeg,nFind - nBeg);
			listGuids.push_back(tsGuid);
			tsGuid.erase();
		}
		else
		{
			tsGuid = tsTemp.substr(nBeg,t_string::npos);
			listGuids.push_back(tsGuid);
			bDone = true;
			tsGuid.erase();
		}
		nBeg = nFind + 1;
		nFind = tsTemp.find(',', nBeg);
	}

	// Allocate the GUID array
	pstructTCOData->m_nGuids = listGuids.size();
	pstructTCOData->m_lpguidArray = 
			(GUID *) malloc (sizeof(GUID) * pstructTCOData->m_nGuids);
	RtlZeroMemory
			(pstructTCOData->m_lpguidArray , 
			sizeof(sizeof(GUID) * pstructTCOData->m_nGuids));

	list<t_string>::iterator pListGuids;

	int i = 0;

	for (pListGuids = listGuids.begin(); pListGuids != listGuids.end() ; ++pListGuids)
	{
		tsGuid = (*pListGuids);
		wGUIDFromString(tsGuid.c_str(), &pstructTCOData->m_lpguidArray[i++]);
	}

	
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\t_string.cpp ===
//////////////////////////////////////////////////////////////////////
// Implementaion of WC to MBCS and MBCS to WC routines that do the 
// right thing if compiled non-UNICODE or UNICODE.
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"
#include "t_string.h"

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\t_string.h ===
// t_string.h: interface for the t_string class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
#define AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifndef t_string

#ifndef _UNICODE
// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled non-UNICODE.
#define t_string string
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout cout
#define t_cin cin
#define t_strstream strstream
#define t_strstreambuf strstreambuf
#define t_ctime ctime
#define t_cerr cerr

#else

// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled UNICODE.
#define t_string wstring
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout wcout
#define t_cin wcin
#define t_strstream wstringstream
#define t_strstreambuf wstrstreambuf
#define t_ctime _wctime
#define t_cerr wcerr

#endif

#endif

// We do not need conversion routines if compiling under UNICODE
#define mbsrtowcs t_mbsrtowcs


#endif // !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\updatetraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Logger.h"
#include "Validator.h"

#include "CollectionControl.h"
  
int UpdateTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// UpdateTrace API call return
)
{	

	LPTSTR lptstrReturnedError = NULL;
	*pAPIReturn = -1;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is UpdateTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::UpdateTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lptstrReturnedError
			);
	}
	
	if (FAILED(nResult))
	{
		delete pDetailLogger;
	
		//  Open log files sets error string lptstrReturnedError.
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("StopTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lptstrReturnedError,
			bLogExpected
		);

		free(lptstrReturnedError);
		lptstrReturnedError = NULL;

		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("UpdateTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	CEventTraceProperties CProps (pstructTCOData->m_pProps);
	PEVENT_TRACE_PROPERTIES pProps = CProps.GetEventTracePropertiesInstance();
	
	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("UpdateTrace"),
		bLogExpected
	);

	*pAPIReturn = 
		ControlTrace
		( 
			bUseTraceHandle ? *pstructTCOData->m_pTraceHandle : NULL, 
			bUseTraceHandle ? NULL : pstructTCOData->m_lptstrInstanceName, 
			pProps,
			EVENT_TRACE_CONTROL_UPDATE
		);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS) 
	{
		lptstrReturnedError = DecodeStatus(*pAPIReturn);	
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::UpdateTraceTest &&
			 pstructTCOData->m_lptstrValidator &&
			 _tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lptstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	bool bDiff = 
		LogPropsDiff
		(
			NULL,
			pstructTCOData->m_pProps,
			pProps
		);
	
	// If there were differences and 
	// *pAPIReturn == ERROR_SUCCESS == pstructTCOData->m_ulExpectedResult
	// we need to set return codes to indicate differences.  Look in detail
	// log for differences.
	if (bDiff &&
		*pAPIReturn == ERROR_SUCCESS &&
		pstructTCOData->m_ulExpectedResult == ERROR_SUCCESS)
	{
		free (lptstrReturnedError);
		lptstrReturnedError = NULL;
		*pAPIReturn = -1;
		lptstrReturnedError = 
			NewTCHAR(_T("Different values returned in EVENT_TRACE_PROPERTIES structure."));
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pProps,
			*pAPIReturn,
			lptstrReturnedError,
			true,
			bAdmin
		);
	}

	LogPropsDiff
	(
		pDetailLogger,
		pstructTCOData->m_pProps,
		pProps
	);

	LogSummaryAfterCall
	(
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		*pAPIReturn,
		lptstrReturnedError,
		bLogExpected
	);
	
	delete pDetailLogger;

	free(lptstrReturnedError);
	lptstrReturnedError = NULL;

	if (pProps)
	{
		free(pProps->LoggerName);
		free(pProps->LogFileName);
	}

	free(pProps);	

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\utilities.h ===
// Utilities.h: interface for the CUtilities class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

TCHAR *NewTCHAR(const TCHAR *ptcToCopy);

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy);

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy);

LPTSTR DecodeStatus(IN ULONG Status);

int GetFileList(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList);

BOOL IsAdmin();  // From Q118626

LPTSTR LPTSTRFromGuid(GUID Guid);

t_string ULONGVarToTString(ULONG ul, bool bHex);

ULONG InitializePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances);

ULONG FreePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances);

int LogDetailBeforeCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData,
	BOOL bAdmin
);

int LogDetailAfterCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData, 
	PEVENT_TRACE_PROPERTIES *pProps,
	ULONG ulResult,
	LPTSTR lpstrReturnedError,
	bool bValid,
	BOOL bAdmin,
	LPCTSTR lptstrBanner = NULL,
	bool bPrintProps = true
);

int LogSummaryBeforeCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	LPCTSTR lptstrAPI,
	bool bLogExpected
);

int LogSummaryAfterCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	ULONG ulActualResult,
	LPTSTR lptstrErrorDesc,
	bool bLogExpected				// If true we log expected vs actual result.
);

int OpenLogFiles
(	LPCTSTR lpctstrTCODetailFile,	
	CLogger *&pDetailLogger,
	LPTSTR *plpstrReturnedError
);

bool LogPropsDiff
(	CLogger *pDetailLogger,
	PEVENT_TRACE_PROPERTIES pProps1,
	PEVENT_TRACE_PROPERTIES pProps2
);

#define MAX_STR 1024

#endif // !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\validator.cpp ===
// Validator.cpp: implementation of the CValidator class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>

using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Validator.h"

#define DEFAULT_MIN_BUFFERS 2

CValidator::CValidator() 
{

}


CValidator::~CValidator()
{
	
}

bool CValidator::Validate
(
	TRACEHANDLE *pTraceHandle, 
	LPTSTR lptstrInstanceName, 
	PEVENT_TRACE_PROPERTIES	pProps, 
	LPTSTR lptstrValidator
)
{
	bool bReturn = true;

	if (case_insensitive_compare(lptstrValidator, _T("VALIDATION_1.1.1.10.5")))
	{
		bReturn = pProps->MinimumBuffers == DEFAULT_MIN_BUFFERS;	
		if (bReturn)
		{
			t_cout << _T("Validator passed.\n"); 
		}
		else
		{
			t_cout << _T("Validator failed.\n"); 
		}
	}

	return bReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\validator.h ===
#if !defined(AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CValidator
{
public:
	CValidator();
	~CValidator();
	bool Validate
			(	TRACEHANDLE *pTraceHandle, 
				LPTSTR lptstrInstanceName, 
				PEVENT_TRACE_PROPERTIES	pProps, 
				LPTSTR lptstrValidator
			);

private:

};

#endif // !defined(AFX_Validator_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\logger\utilities.cpp ===
// Utilities.cpp: implementation of the CUtilities class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>

using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <malloc.h>

#include <WTYPES.H>
#include "t_string.h"
#include <tchar.h>
#include <list>


#include "Persistor.h"
#include "Logger.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "TCOData.h"
#include "Utilities.h"


//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

TCHAR *NewTCHAR(const TCHAR *ptcToCopy)
{
	if (ptcToCopy == NULL)
	{
		return NULL;
	}

	int nString = _tcsclen(ptcToCopy) + 1;
	int nTCHAR = sizeof(TCHAR);

	int nLen = nString * (nTCHAR); 

	TCHAR *pNew = (TCHAR*) malloc(nLen);

	_tcscpy(pNew,ptcToCopy);

	return pNew;
}

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy)
{
	int nLen = (wcslen(lpwstrToCopy) + 1) * sizeof(WCHAR);
	LPSTR pNew = (char *)malloc( nLen );
   
	wcstombs(pNew, lpwstrToCopy, nLen);

	return pNew;
}

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy)
{
	int nLen = (strlen(lpstrToCopy) + 1);
	LPWSTR pNew = (WCHAR *)malloc( nLen  * sizeof(WCHAR));
	mbstowcs(pNew, lpstrToCopy, nLen);

	return pNew;

}

LPTSTR DecodeStatus(IN ULONG Status)
{
	LPTSTR lptstrError = (LPTSTR) malloc (MAX_STR * (sizeof(TCHAR)));

    memset( lptstrError, 0, MAX_STR );

    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        lptstrError,
        MAX_STR,
        NULL );

	for (int i = 0; i < MAX_STR; i++)
	{
		if (lptstrError[i] == 0x0d)
		{
			lptstrError[i] = _T('\0');
			break;
		}
	}

    return lptstrError;
}

int GetFileList
(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList)
{
	t_string tsFind;

	tsFind = lptstrPath;
	tsFind += _T("\\");
	tsFind += lptstrFileType;


	WIN32_FIND_DATA wfdFile;
	HANDLE hFindHandle = 
		FindFirstFile(tsFind.c_str(), &wfdFile);

	if (hFindHandle == INVALID_HANDLE_VALUE)
	{
		return HRESULT_FROM_WIN32(GetLastError()); 
	}

	if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
	{
		tsFind = lptstrPath;
		tsFind += _T("\\");
		tsFind += wfdFile.cFileName;
		rList.push_back(tsFind);
		tsFind.erase();
	}

	while (FindNextFile(hFindHandle, &wfdFile))
	{
		if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
		{
			tsFind = lptstrPath;
			tsFind += _T("\\");
			tsFind += wfdFile.cFileName;
			rList.push_back(tsFind);
			tsFind.erase();
		}
	}

	FindClose(hFindHandle);

	return ERROR_SUCCESS;
} 

// From Q 118626
BOOL IsAdmin()
{
  HANDLE hAccessToken;
  UCHAR InfoBuffer[1024];
  PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
  DWORD dwInfoBufferSize;
  PSID psidAdministrators;
  SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
  UINT x;
  BOOL bSuccess;

  if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
	 &hAccessToken )) {
	 if(GetLastError() != ERROR_NO_TOKEN)
		return FALSE;
	 //
	 // retry against process token if no thread token exists
	 //
	 if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
		&hAccessToken))
		return FALSE;
  }

  bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
	 1024, &dwInfoBufferSize);

  CloseHandle(hAccessToken);

  if(!bSuccess )
	 return FALSE;

  if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
	 SECURITY_BUILTIN_DOMAIN_RID,
	 DOMAIN_ALIAS_RID_ADMINS,
	 0, 0, 0, 0, 0, 0,
	 &psidAdministrators))
	 return FALSE;

// assume that we don't find the admin SID.
  bSuccess = FALSE;

  for(x=0;x<ptgGroups->GroupCount;x++)
  {
	 if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
	 {
		bSuccess = TRUE;
		break;
	 }

  }
  FreeSid(psidAdministrators);
  return bSuccess;
}

t_string GUIDToTString(GUID Guid)
{
	t_strstream strStream;
	t_string tsOut;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	return tsOut;
}

LPTSTR LPTSTRFromGuid(GUID Guid)
{
	t_string tsGuid = GUIDToTString(Guid);
	return NewTCHAR(tsGuid.c_str());
}

t_string ULONGVarToTString(ULONG ul, bool bHex)
{
	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	if (bHex)
	{
		t_string tsHex;
		tsHex = _T("0x");
		tsHex += tsTemp;
		return tsHex;
	}
	else
	{
		return tsTemp;
	}
}

ULONG InitializePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances)
{
	pPropsArray = 
		(PEVENT_TRACE_PROPERTIES) malloc 
		(sizeof(EVENT_TRACE_PROPERTIES) * nInstances);

	RtlZeroMemory(pPropsArray, sizeof(EVENT_TRACE_PROPERTIES) * nInstances);

	for (int i = 0; i < nInstances; i++)
	{
		pPropsArray[i].LoggerName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
		RtlZeroMemory(pPropsArray[i].LoggerName, sizeof(TCHAR) * MAX_STR);
		pPropsArray[i].LogFileName = (TCHAR *) malloc (sizeof(TCHAR) * MAX_STR);
		RtlZeroMemory(pPropsArray[i].LogFileName, sizeof(TCHAR) * MAX_STR);
	}

	return 0;
}

ULONG FreePropsArray
(PEVENT_TRACE_PROPERTIES &pPropsArray, int nInstances)
{
	for (int i = 0; i < nInstances; i++)
	{
		free(pPropsArray[i].LoggerName);
		free(pPropsArray[i].LogFileName);
	}

	free(pPropsArray);

	return 0;
}

int OpenLogFiles
(	LPCTSTR lpctstrTCODetailFile,	
	CLogger *&pDetailLogger,
	LPTSTR *plpstrReturnedError
)
{
	HRESULT hr = S_OK;
	t_string tsError;

	if (lpctstrTCODetailFile)
	{
		// Open *our* logger file.
		pDetailLogger = new CLogger(lpctstrTCODetailFile, false);
		hr = pDetailLogger->GetOpenStatus();
		if (FAILED (hr))
		{
			tsError = _T("Could not open detail log file \"");
			tsError += lpctstrTCODetailFile;
			tsError += _T("\".");
			*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}

	return hr;
}




int LogDetailBeforeCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData,
	BOOL bAdmin
)
{
	// Want to log the security context, user must have administrative priviledge!

	pDetailLogger->LogTCHAR(_T("----  Input Data ----\n"));
	pDetailLogger->LogTCHAR(_T("Description: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrLongDesc);
	pDetailLogger->LogTCHAR(_T("\n"));


	pDetailLogger->LogTCHAR(_T("User Security Context: "));
	if (bAdmin)
	{
		pDetailLogger->LogTCHAR(_T("Has administrative priviledge.\n"));
	}
	else
	{
		pDetailLogger->LogTCHAR(_T("Does not have administrative priviledge.\n"));
	}


	pDetailLogger->LogTCHAR(_T("LoggerType: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrLoggerMode);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Enable: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnable);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("EnableFlag: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnableFlag);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("EnableLevel: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulEnableLevel);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Expected Result: "));
	pDetailLogger->LogULONG(pstructTCOData->m_ulExpectedResult, true);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Trace Handle: "));
	if (pstructTCOData->m_pTraceHandle == NULL)
	{
		pDetailLogger->LogULONG64(0, true);
	}
	else
	{
		pDetailLogger->LogULONG64(*pstructTCOData->m_pTraceHandle, true);
	}
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogTCHAR(_T("Instance Name: "));
	pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrInstanceName);
	pDetailLogger->LogTCHAR(_T("\n"));

	pDetailLogger->LogEventTraceProperties(pstructTCOData->m_pProps);

	pDetailLogger->LogTCHAR(_T("Guids:"));

	LPTSTR lptstrGuid;

	if (pstructTCOData->m_pProps != 0)
	{
		for (int i = 0; i < pstructTCOData->m_nGuids; i++) 
		{
			lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_lpguidArray[i]);
			pDetailLogger->LogTCHAR(lptstrGuid);
			free (lptstrGuid);
			lptstrGuid = NULL;
			if (pstructTCOData->m_nGuids > 1 
				&& i < pstructTCOData->m_nGuids - 1)
			{
				pDetailLogger->LogTCHAR(_T(","));
			}
		}
	}

	pDetailLogger->LogTCHAR(_T("\n"));
	pDetailLogger->Flush();

	return 0;
}


int LogDetailAfterCall
(	CLogger *pDetailLogger,
	TCOData *pstructTCOData, 
	PEVENT_TRACE_PROPERTIES *pProps,
	ULONG ulResult,
	LPTSTR lpstrReturnedError,
	bool bValid,
	BOOL bAdmin,
	LPCTSTR lptstrBanner,
	bool bPrintProps
)
{
	pDetailLogger->LogTCHAR(_T("----  Returned Values ----\n"));

	if (lptstrBanner)
	{
		pDetailLogger->LogTCHAR(lptstrBanner);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	if (!bAdmin && ulResult == ERROR_SUCCESS 
		&& ulResult == pstructTCOData->m_ulExpectedResult)
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" failed\n"));
		pDetailLogger->LogTCHAR(_T("SecurityContextError:  API should have failed because the user does not have administrative privledge.\n"));	
	}
	else if (ulResult == pstructTCOData->m_ulExpectedResult)
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" passed\n"));

	}
	else
	{
		pDetailLogger->LogTCHAR(_T("Test: "));
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		pDetailLogger->LogTCHAR(_T(" failed\n"));
		pDetailLogger->LogTCHAR(_T("Expected result: "));
		pDetailLogger->LogULONG(pstructTCOData->m_ulExpectedResult, true);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	pDetailLogger->LogTCHAR(_T("Test result: "));
	pDetailLogger->LogULONG(ulResult, true);
	pDetailLogger->LogTCHAR(_T("\n"));

	if (ulResult && lpstrReturnedError)
	{
		pDetailLogger->LogTCHAR(_T("Error Description: "));
		pDetailLogger->LogTCHAR(lpstrReturnedError);
		pDetailLogger->LogTCHAR(_T("\n"));
	}

	pDetailLogger->LogTCHAR(_T("Trace Handle: "));
	if (pstructTCOData->m_pTraceHandle == NULL)
	{
		pDetailLogger->LogULONG64(0, true);
	}
	else
	{
		pDetailLogger->LogULONG64(*pstructTCOData->m_pTraceHandle, true);
	}
	pDetailLogger->LogTCHAR(_T("\n"));

	if (bPrintProps)
	{
		pDetailLogger->LogEventTraceProperties(*pProps);
		pDetailLogger->LogTCHAR(_T("-------------------------------------------------------\n"));

	}

	pDetailLogger->Flush();

	return 0;
}

int LogSummaryBeforeCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	LPCTSTR lptstrAPI,
	bool bLogExpected
)
{
	t_cout << _T("\n") << lptstrAPI << _T(" called with TCOTest = ") 
		<< pstructTCOData->m_lptstrShortDesc << _T("\n");
	t_cout << _T("Action = ") << lptstrAction << _T("\n");
	if (lpctstrDataFile)
	{
		t_cout <<  _T("DataFile = ") << lpctstrDataFile  << _T("\n");
	}
	if (bLogExpected && pstructTCOData->m_lptstrLongDesc)
	{
		t_cout <<  _T("Description = ") << pstructTCOData->m_lptstrLongDesc << _T("\n");
	}

	return ERROR_SUCCESS;
}

int LogSummaryAfterCall
(	
	TCOData *pstructTCOData, 
	LPCTSTR lpctstrDataFile,
	LPCTSTR lptstrAction,
	ULONG ulActualResult,
	LPTSTR lptstrErrorDesc,
	bool bLogExpected
)
{
	t_string tsOut1;
	t_string tsOut2;

	tsOut1 = ULONGVarToTString(ulActualResult, true);
	tsOut2 = ULONGVarToTString(pstructTCOData->m_ulExpectedResult, true);

	if (ulActualResult == pstructTCOData->m_ulExpectedResult && bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Passed:  Actual result "); 
		t_cout << tsOut1 << _T(" = to expected result ") << tsOut2 << _T(".\n");
	}
	else if (ulActualResult != pstructTCOData->m_ulExpectedResult && bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Failed:  Actual result "); 
		t_cout << tsOut1 << _T(" not = to expected result ") << tsOut2 << _T(".\n");
	}
	else if (ulActualResult == ERROR_SUCCESS && !bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Passed.\n"); 
	}
	else if (ulActualResult != ERROR_SUCCESS && !bLogExpected)
	{
		t_cout << pstructTCOData->m_lptstrShortDesc << _T(" - Failed.\n"); 
	}

	if (lptstrErrorDesc && ulActualResult != pstructTCOData->m_ulExpectedResult)
	{
		t_cout << _T("Error: ") << lptstrErrorDesc << _T("\n"); 
	}

	return 0;
}

bool LogPropsDiff
(	CLogger *pDetailLogger,
	PEVENT_TRACE_PROPERTIES pProps1,
	PEVENT_TRACE_PROPERTIES pProps2
)
{
	bool bDiff = false;
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("EVENT_TRACE_PROPERTIES data items which differ:\n"));
		pDetailLogger->Flush();
	}

    if (pProps1->BufferSize != pProps2->BufferSize)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  BufferSize\n"));
		}
		bDiff = true;
	}

	if (pProps1->MinimumBuffers != pProps2->MinimumBuffers)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MinimumBuffers\n"));
		}
		bDiff = true;
	}
    
	if (pProps1->MaximumBuffers != pProps2->MaximumBuffers)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MaximumBuffers\n"));
		}
		bDiff = true;
	}
  
	if (pProps1->MaximumFileSize != pProps2->MaximumFileSize)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  MaximumFileSize\n"));
		}
		bDiff = true;
	}

	if (pProps1->LogFileMode != pProps2->LogFileMode)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  LogFileMode\n"));
		}
		bDiff = true;
	}

	if (pProps1->FlushTimer != pProps2->FlushTimer)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  FlushTimer\n"));
		}
		bDiff = true;
	}

	if (pProps1->EnableFlags != pProps2->EnableFlags)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  EnableFlags\n"));
		}
		bDiff = true;
	}

	if (pProps1->AgeLimit != pProps2->AgeLimit)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  AgeLimit\n"));
		}
		bDiff = true;
	}

	if (!bDiff)
	{
		if (pDetailLogger)
		{
			pDetailLogger->LogTCHAR(_T("  None\n"));
		}
	}
		
	if (pDetailLogger)
	{
		pDetailLogger->Flush();
	}

	return bDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\mcegen\cli\mcegen.c ===
#include "mcegen.h"

#if 0
ULONG DumpMCE(
    void
    )
{
	HANDLE Handle;
	GUID Guid = { 0x23602a8a,0xdadd,0x462f, { 0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b } };
	ULONG Status;
	ULONG SizeNeeded;

	Status = WmiOpenBlock(&Guid,
						  0,
						  &Handle);
	
	if (Status == ERROR_SUCCESS)
	{
		SizeNeeded = 0;
		Status = WmiQueryAllData(Handle,
								 &SizeNeeded,
								 NULL);
		if (Status == ERROR_BUFFER_TOO_SMALL)
		{
			Buffer = malloc(SizeNeeded);
			if (Buffer != NULL)
			{
				Status = WmiQueryAllData(Handle,
										 &SizeNeeded,
										 Buffer);
				if (Status == ERROR_SUCCESS)
				{
					Wnode = (PWNODE_ALL_DATA)Buffer;
					MCAData = (PMSMCAInfo_RawMCAData)OffsetToPtr(Wnode,
						                                         Wnode->
				}
			}
		}
	}
}
#endif

void Usage()
{
	printf("MCEGen <code> [<count> <threads>]\n\n");
	printf("    Generates a MCE exception. <code> specifies the type\n");
	printf("    of exception to generate\n\n");
	printf("    Note that the MCAHCT driver must be installed and started\n\n");
	printf("        101   -   Generates a single bit memory error. Note memerr.efi must have already seeded an error (460GX platform only)\n");
	printf("        102   -   Generates a multi bit memory error. Note memerr.efi must have already seeded an error (460GX platform only)\n");
	printf("        103   -   Generates a CMC via FSB (460GX platform only)\n");
	printf("        104   -   Generates fatal MCA TLB error (460GX platform only)\n");
	printf("        105   -   Generates fatal MCA PCI bus error (SoftSur only)\n");
	printf("        106   -   Generates fatal MCA PCI bus error (Lion only)\n");
	printf("        456   -   Generates a fatal MCA (Itanium only)\n");
	printf("        490   -   Generates a L1 1-bit ECC CMC (Itanium only)\n");
	printf("        900   -   Generate single bit ECC error in user mode. Memerr.efi must have been run (460GX only)\n");
	printf("        901   -   Generate double bit ECC error in user mode. Memerr.efi must have been run (460GX only)\n");
	printf("       1001/2001/3001 - Fatal/Corrected CMC/CPE SMBIOS MCE\n");
	printf("       1002/2002/3002 - Fatal/Corrected CMC/CPE Cache Level 1 MCE\n");
	printf("       1003/2003/3003 - Fatal/Corrected CMC/CPE TLB level 2 MCE\n");
	printf("       1004/2004/3004 - Fatal/Corrected CMC/CPE Unknown PCI Bus\n");
	printf("       1005/2005/3005 - Fatal/Corrected CMC/CPE Unknown PCI Bus\n");
	printf("       1006/2006/3006 - Fatal/Corrected CMC/CPE PCI Bus Parity Error\n");
	printf("       1007/2007/3007 - Fatal/Corrected CMC/CPE System Eventlog\n");
	printf("       1008/2008/3008 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1009/2009/3009 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1010/2010/3010 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1011/2011/3011 - Fatal/Corrected CMC/CPE Memory\n");
	printf("       1012/2012/3012 - Fatal/Corrected CMC/CPE SMBIOS and Platform Specific\n");
	printf("       1013/2013/3013 - Fatal/Corrected CMC/CPE PCI Component\n");
	printf("       1014/2014/3014 - Fatal/Corrected CMC/CPE SMBIOS (100KB in size)\n");
	printf("       1015/2015/3015 - Fatal/Corrected Invalid\n");
	printf("       1016/2016/3016 - Fatal/Corrected CMC/CPE CPU 1 MS check\n");
	printf("       1017/2017/3017 - Fatal/Corrected CMC/CPE CPU 1 Bus check, 1 RegFile check\n");
	printf("       1018/2018/3018 - Fatal/Corrected CMC/CPE CPU 1 reg check, 2 MS  check\n");
	printf("       1019/2019/3019 - Fatal/Corrected CMC/CPE CPU nothing valid\n");
	printf("       1020/2020/3020 - Fatal/Corrected CMC/CPE Memory Error nothing valid\n");
	printf("       1021/2021/3021 - Fatal/Corrected CMC/CPE PCI Bus Error nothing valid\n");
	printf("       1116/2116/3116 - Fatal/Corrected Over temp\n");
	printf("       1117/2117/3117 - Fatal/Corrected Normal temp\n");
	printf("       1118/2118/3118 - Generate simulated single bit ECC error\n");
	printf("       1019/2019/3019 - Fatal/Corrected CMC/CPE SMBIOS and informational Platform Specific\n");
	
}

int _cdecl main(int argc, char *argv[])
{
	ULONG Status;
	ULONG Code, Threads, Count;
	HANDLE h;
	ULONG i;
	DWORD Id;
	
	if (argc < 2)
	{
		Usage();
	} else {
		Code = atoi(argv[1]);
		if (argc == 2) {
			THREADCONTROL ThreadControl;
			
			//
			// parameter is code number to generate MCE
			//
			ThreadControl.Count = 1;
			ThreadControl.Code = Code;
			GenerateMCE(&ThreadControl);
		} else {
			PHANDLE Events;
			
			if (argc >= 4)
			{
				//
				// specified multiple generation threads
				//
				Threads = atoi(argv[3]);			
			} else {
				Threads = 1;
			}
			
			//
			// Get number of MCE to generate
			//
			Count = atoi(argv[2]);

			Events = malloc(Threads * sizeof(HANDLE));
			for (i = 0; i < Threads; i++)
			{
				PTHREADCONTROL  ThreadControl;

				ThreadControl = malloc(sizeof(THREADCONTROL));
				ThreadControl->Count = Count;
				ThreadControl->Code = Code;
				Events[i] = CreateThread(NULL,
							 0,
							 GenerateMCE,
							 ThreadControl,
							 0,
							 &Id);
				if (Events[i] == NULL)
				{
					printf("CreateThread failed %d\n", GetLastError());					
				}
			}
			
			printf("Waiting for threads to complete\n");
			
			WaitForMultipleObjects(Threads, Events, TRUE, INFINITE);
		}
	}

	
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\reducer\reducer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    reducer.c

Abstract:

    Trace Reducer Tool

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

//#define _UNICODE
//#define UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include "cpdapi.h"

#define MAXSTR       1024
#define MAXLOGFILES    16

void ReducerUsage()
{
    printf("Usage: reducer [Options] <EtlFile1 EtlFile2 ...> | [-h | -help | -?]\n");
    printf("\t-out <filename> Output file name. Default is Workload.txt\n");
    printf("\t-h        \n");
    printf("\t-help        \n");
    printf("\t-?     Display usage information\n");

//    printf("\t-start <time-stamp>        Start Time\n");
//    printf("\t-end   <time-stamp>        End Time\n");
//    printf("\t       <time-stamp> can be found in tracedmp result\n");
//    printf("\n");
//    printf("\t-base                      Original reducer report (default report)\n");
//    printf("\t-file                      Hot File Report\n");
//    printf("\t-pf                        page fault report\n");
//    printf("\t    -summary processes     summary of faults per process (default PF report).\n");
//    printf("\t             modules       summary of faults per module.\n");
//    printf("\t    -process <image name>  rundown for specific process.\n");
//    printf("\t             all\n");
//    printf("\t    -module  <module name> rundown for specific modules.\n");
//    printf("\t             all\n");
//    printf("\t    -sort    ALL           sort by all fault total.\n");
//    printf("\t             HPF           sort by HPF fault total.\n");
//    printf("\t             TF            sort by TF  fault total.\n");
//    printf("\t             DZF           sort by DZF fault total.\n");
//    printf("\t             COW           sort by COW fault total.\n");
//    printf("\n");
//    printf("\tNote: (1) Cannot generate HotFile Report and PageFault Report\n");
//    printf("\t          at the same time\n");
//    printf("\t0x%08X,%d,\n", STATUS_SEVERITY_WARNING, RtlNtStatusToDosError(STATUS_SEVERITY_WARNING));
}

void stowc(char *str, WCHAR *wstr)
{
    int len, i;
    PUCHAR AnsiChar;

    len = strlen(str);
    for (i = 0; i < len; i++)
    {
        AnsiChar = &str[i];
        wstr[i]  = RtlAnsiCharToUnicodeChar(&AnsiChar);
    }
    wstr[len] = 0;
}

ULONGLONG
ParseTimeString(char * strTime)
{
#if 0
    CHAR          lstrTime[25];
    PCHAR         strYear, strMonth, strDate,
                  strHour, strMinute, strSecond, strMilliSecond;
    LARGE_INTEGER largeTime;
    FILETIME      localTime, stdTime;
    SYSTEMTIME    sysTime;

    if (strTime == NULL)
        return (ULONGLONG) 0;

    strcpy(lstrTime, strTime);

    strMonth = lstrTime;
    for (strDate = strMonth;
         *strDate && *strDate >= '0' && *strDate <= '9';
         strDate ++);
    *strDate = '\0';
    strDate ++;

    for (strYear = strDate;
         *strYear && *strYear >= '0' && *strYear <= '9';
         strYear ++);
    *strYear = '\0';
    strYear ++;

    for (strHour = strYear;
         *strHour && *strHour >= '0' && *strHour <= '9';
         strHour ++);
    *strHour = '\0';
    strHour ++;

    for (strMinute = strHour;
         *strMinute && *strMinute >= '0' && *strMinute <= '9';
         strMinute ++);
    *strMinute = '\0';
    strMinute ++;

    for (strSecond = strMinute;
         *strSecond && *strSecond >= '0' && *strSecond <= '9';
         strSecond ++);
    *strSecond = '\0';
    strSecond ++;

    for (strMilliSecond = strSecond;
         *strMilliSecond && *strMilliSecond >= '0' && *strMilliSecond <= '9';
         strMilliSecond ++);
    *strMilliSecond = '\0';
    strMilliSecond ++;

    sysTime.wYear         = atoi(strYear);
    sysTime.wMonth        = atoi(strMonth);
    sysTime.wDay          = atoi(strDate);
    sysTime.wHour         = atoi(strHour);
    sysTime.wMinute       = atoi(strMinute);
    sysTime.wSecond       = atoi(strSecond);
    sysTime.wMilliseconds = atoi(strMilliSecond);

    SystemTimeToFileTime(&sysTime, &localTime);
    LocalFileTimeToFileTime(&localTime, &stdTime);
    largeTime.HighPart = stdTime.dwHighDateTime;
    largeTime.LowPart  = stdTime.dwLowDateTime;
    return (ULONGLONG) largeTime.QuadPart;
#else
    ULONGLONG TimeStamp = 0;
    ULONG     i = 0;

    for (i = 0; strTime[i] != '\0'; i ++)
    {
        TimeStamp = TimeStamp * 10 + (strTime[i] - '0');
    }

    return TimeStamp;
#endif
}

VOID
ProcessTrace(
    IN ULONG      LogFileCount,
    IN LPCSTR   * LogFileName,
    IN ULONGLONG  StartTime,
    IN ULONGLONG  EndTime,
    IN ULONGLONG  DSStartTime,
    IN ULONGLONG  DSEndTime,
    IN ULONG      MoreFlags,
    IN PVOID      pUserContext,
    IN LPSTR      pOutFileName
    )
{
    // Call TraceLib and process it. 
    //
    TRACE_BASIC_INFO TraceBasicInfo;

    memset(&TraceBasicInfo, 0, sizeof(TRACE_BASIC_INFO));
    TraceBasicInfo.Flags        = TRACE_REDUCE | MoreFlags;
    TraceBasicInfo.LogFileName  = LogFileName; 
    TraceBasicInfo.LogFileCount = LogFileCount;
    TraceBasicInfo.pUserContext = pUserContext;
    TraceBasicInfo.StartTime    = StartTime;
    TraceBasicInfo.EndTime      = EndTime;
    TraceBasicInfo.DSStartTime  = DSStartTime;
    TraceBasicInfo.DSEndTime    = DSEndTime;

    TraceBasicInfo.ProcFileName = pOutFileName;
    InitTraceContext(&TraceBasicInfo);
    DeinitTraceContext(&TraceBasicInfo);
}
    
void __cdecl main(int argc ,char * argv[])
{
    LPCSTR   LogFileName = "C:\\perflogs\\perfdata_980406.blg";
    CHAR     TraceLogFile[MAXSTR];
    WCHAR    PerfLogFile[MAXSTR];
    BOOLEAN  bTrace  = FALSE;
    LPCSTR   EvmFile[MAXLOGFILES];
    ULONGLONG StartTime = 0, EndTime = 0;
    ULONG    i;
    ULONG    LogFileCount = 0;

    ULONG               flagsMore    = 0;
    PVOID               pUserContext = NULL;
    CPD_USER_CONTEXT_MM UserContextMM;

    UserContextMM.reportNow  = REPORT_SUMMARY_PROCESS;
    UserContextMM.sortNow    = REPORT_SORT_ALL;
    UserContextMM.strImgName = NULL;
    memset(&TraceLogFile, 0, sizeof(CHAR) * MAXSTR); 

    while (--argc > 0)
    {
        ++argv;
        if (**argv == '-' || **argv == '/')
        { 
            ** argv = '-';
            if (!_stricmp(argv[0], "-out"))
            {
                if (argc > 1)
                {
                    CHAR TempStr[MAXSTR];

                    strcpy(TempStr, argv[1]);
                    //stowc(argv[1], TempStr); 
                    ++argv; --argc;
                    _fullpath(TraceLogFile, TempStr, MAXSTR);
                    printf("Setting output file to: '%s'\n", TraceLogFile);
                    bTrace = TRUE;
                }
            }
            else if (!_stricmp(argv[0], "-start"))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    StartTime  = ParseTimeString(argv[1]);
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-end"))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    EndTime    = ParseTimeString(argv[1]);
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-base"))
            {
                flagsMore   |= TRACE_LOG_REPORT_BASIC;
            }
            else if (!_stricmp(argv[0], "-total"))
            {
                flagsMore   |= TRACE_LOG_REPORT_TOTALS;
            }
            else if (!_stricmp(argv[0], "-file"))
            {
                flagsMore   |= TRACE_LOG_REPORT_FILE;
                if (argc > 1 && argv[1][0] >= '0' && argv[1][0] <= '9')
                {
                    (ULONG) pUserContext = atoi(argv[1]);
                    argc --; argv ++;
                }
                else
                {
                    (ULONG) pUserContext = DEFAULT_FILE_REPORT_SIZE;
                }
            }
            else if (!_stricmp(argv[0], "-hpf"))
            {
                flagsMore   |= TRACE_LOG_REPORT_HARDFAULT;
            }
            else if (!_stricmp(argv[0], "-pf"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
            }
            else if (!_stricmp(argv[0], "-summary"))
            {
                if (argc > 1)
                {
                    flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                    pUserContext = (PVOID) & UserContextMM;

                    if (!_stricmp(argv[1], "processes"))
                    {
                        argc --; argv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_PROCESS;
                    }
                    else if (!_stricmp(argv[1], "modules"))
                    {
                        argc --; argv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_MODULE;
                    }
                }
            }

            else if (!_stricmp(argv[0], "-process"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_PROCESS;

                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (_stricmp(argv[1], "all"))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(WCHAR) * (strlen(argv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            stowc(argv[1], UserContextMM.strImgName);
                        }
                    }
                    argc --; argv ++;
                }
            }
            else if (!_stricmp(argv[0], "-module"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_MODULE;

                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (_stricmp(argv[1], "all"))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(WCHAR) * (strlen(argv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            stowc(argv[1], UserContextMM.strImgName);
                        }
                    }
                    argc --; argv ++;
                }
            }

            else if (!_stricmp(argv[0], "-sort"))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
 
                if ((argc > 1) && (argv[1][0] != '-' || argv[1][0] != '/'))
                {
                    if (!_stricmp(argv[1], "hpf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_HPF;
                    }
                    else if (!_stricmp(argv[1], "tf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_TF;
                    }
                    else if (!_stricmp(argv[1], "dzf"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_DZF;
                    }
                    else if (!_stricmp(argv[1], "cow"))
                    {
                        UserContextMM.sortNow = REPORT_SORT_COW;
                    }
                    else
                    {
                        UserContextMM.sortNow = REPORT_SORT_ALL;
                    }
                    argc --; argv ++;
                }
            }
            else
            {
                goto Usage;
            }
        }
        else
        {
            LPCSTR pLogFile;

            pLogFile = malloc(sizeof(CHAR) * MAXSTR);
            RtlZeroMemory((char *) pLogFile, sizeof(CHAR) * MAXSTR);
            EvmFile[LogFileCount] = pLogFile;
            strcpy((char *) EvmFile[LogFileCount ++], argv[0]);
            bTrace = TRUE;

            printf("LogFile %s\n", (char *) EvmFile[LogFileCount - 1]);
        }
    }

    if (LogFileCount == 0)
    {
        goto Usage;
    }

    if (flagsMore == 0)
    {
        flagsMore |= TRACE_LOG_REPORT_BASIC;
    }

    if (   (flagsMore & TRACE_LOG_REPORT_MEMORY)
        && (flagsMore & TRACE_LOG_REPORT_FILE))
    {
        printf("Error: cannot generate HotFile report and PageFault report at the same time.\n");
        goto Cleanup;
    }

    if (bTrace)
    {
        ProcessTrace(LogFileCount, EvmFile, (ULONGLONG) 0, (ULONGLONG) 0,
                StartTime, EndTime, flagsMore, pUserContext, TraceLogFile);
    }

    for (i=0; i < LogFileCount; i++) 
    {
        free((char*)EvmFile[i]);
    }

    if (UserContextMM.strImgName)
    {
        free(UserContextMM.strImgName);
    }

Cleanup:
    return;

Usage:
    ReducerUsage();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\rcvevent\rcvevent.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))
//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}
//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


PTCHAR GuidToString(
    PTCHAR s,
    LPGUID piid
    )
{
    wsprintf(s, TEXT("%x-%x-%x-%x%x%x%x%x%x%x%x"),
               piid->Data1, piid->Data2, 
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}

#if 0
void WackOnFile(void)
{
    ULONG Status;
    HANDLE FH;
    
    
        FH = CreateFile("e:\\foo.baz",
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        
        if (FH != INVALID_HANDLE_VALUE)
    {
            Status = ERROR_SUCCESS;
        CloseHandle(FH);
    } else {
            Status = GetLastError();
    }
    
    printf("CreateFile --> %d\n", Status);
        
}

void CheckOwnPriv(
    void
	)
{
    UCHAR Buffer[4096];
    HANDLE TokenHandle;
    ULONG SizeNeeded;
    BOOL b;
    ULONG i;
    PTOKEN_PRIVILEGES TokenPrivInfo;

	if (! ImpersonateSelf(SecurityImpersonation))
	{
		printf("Impersonatself -> %d\n", GetLastError());
		return;
	}
	
    b = OpenThreadToken(GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                &TokenHandle);
        
    if (! b)
    {
        printf("OpenThreadToken failed %d\n", GetLastError());
        return;
    }
    
    printf("OpenThreadToken succeeded\n");
    
    TokenPrivInfo = (PTOKEN_PRIVILEGES)Buffer;
    b = GetTokenInformation(TokenHandle,
                            TokenPrivileges,
                            TokenPrivInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation(YokenPriv) -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
		
    RevertToSelf();
    if (b)
    {
        printf("Priv count is %d\n", TokenPrivInfo->PrivilegeCount);
    	for (i = 0; i < TokenPrivInfo->PrivilegeCount; i++)
		{
			UCHAR PrivName[1024];
			ULONG SizePrivName = sizeof(PrivName);
			
			if ( ! LookupPrivilegeName(NULL, 
                                       &TokenPrivInfo->Privileges[i].Luid,
                                       PrivName,
                                       &SizePrivName))
            {
		        sprintf(PrivName, "[Error %d]", GetLastError());
			}
                                              
            printf("Priv %s %x%x has attr %x\n",
                   PrivName,
				   TokenPrivInfo->Privileges[i].Luid.HighPart,
				   TokenPrivInfo->Privileges[i].Luid.LowPart,
				   TokenPrivInfo->Privileges[i].Attributes);
		}
		printf("\n");
    }
}

PCHAR SidUsage[] = 
{
    "SidTypeZero",
    "SidTypeUser",
    "SidTypeGroup",
    "SidTypeDomain",
    "SidTypeAlias",
    "SidTypeWellKnownGroup",
    "SidTypeDeletedAccount",
    "SidTypeInvalid",
    "SidTypeUnknown",
    "SidTypeComputer",
};

void GetCallerInfo(BOOLEAN Impersonating)
{
    UCHAR Buffer[4096];
    PTOKEN_USER TokenUserInfo = (PTOKEN_USER)Buffer;
    PSID_AND_ATTRIBUTES SidAndAttributes = &TokenUserInfo->User;
    PSID Sid;
    HANDLE TokenHandle;
    ULONG SizeNeeded;
    BOOLEAN b;
    CHAR Name[MAX_PATH];
    CHAR Domain[MAX_PATH];
    ULONG NameSize = sizeof(Name);
    ULONG DomainSize = sizeof(Domain);
    SID_NAME_USE SidNameUse;
    ULONG i;
  
    PUCHAR SidBuffer;
    SID_IDENTIFIER_AUTHORITY    NtAuthority         = SECURITY_NT_AUTHORITY;
    PTOKEN_PRIVILEGES TokenPrivInfo;
    
    SidBuffer = malloc(RtlLengthRequiredSid( 1 ));
    RtlInitializeSid( SidBuffer, &NtAuthority, 1);
    *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
    
    b = OpenThreadToken(GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                &TokenHandle);
        
    if (! b)
    {
        printf("OpenThreadToken failed %d\n", GetLastError());
        return;
    }
    
    printf("OpenThreadToken succeeded\n");
    
    TokenPrivInfo = (PTOKEN_PRIVILEGES)Buffer;
    b = GetTokenInformation(TokenHandle,
                            TokenPrivileges,
                            TokenPrivInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation(YokenPriv) -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
    if (b)
    {
		RpcRevertToSelf();
        printf("Priv count is %d\n", TokenPrivInfo->PrivilegeCount);
    	for (i = 0; i < TokenPrivInfo->PrivilegeCount; i++)
		{
			UCHAR PrivName[1024];
			ULONG SizePrivName = sizeof(PrivName);
			
			if ( ! LookupPrivilegeName(NULL, 
                                       &TokenPrivInfo->Privileges[i].Luid,
                                       PrivName,
                                       &SizePrivName))
            {
		        sprintf(PrivName, "[Error %d]", GetLastError());
			}
                                              
            printf("Priv %s %x%x has attr %x\n",
                   PrivName,
				   TokenPrivInfo->Privileges[i].Luid.HighPart,
				   TokenPrivInfo->Privileges[i].Luid.LowPart,
				   TokenPrivInfo->Privileges[i].Attributes);
		}
		printf("\n");
        RpcImpersonateClient(0);
    }
    
    
        
    b = GetTokenInformation(TokenHandle,
                            TokenUser,
                            TokenUserInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    printf("GetTokenInformation -> %s (%d), sizeNeeded = %d\n", 
        b ? "TRUE" : "FALSE", GetLastError(),
            SizeNeeded);
    if (b)
    {
        if (Impersonating)
        {
            RpcRevertToSelf();
        }
        Sid = SidAndAttributes->Sid;

        if (EqualSid(Sid, (PSID)SidBuffer) && GetLastError() == ERROR_SUCCESS)
    {
            printf("Called by LocalSystem !!\n");
    } else {
            printf("EqualSid %d\n", GetLastError());
    }

        b = LookupAccountSid(NULL,
                             Sid,
                             Name,
                             &NameSize,
                             Domain,
                             &DomainSize,
                             &SidNameUse);
    
        if (Impersonating)
    {
        RpcImpersonateClient(0);
    }
        if (b)
    {
            printf("Account: %s\\%s Type %s\n", Domain, Name, SidUsage[SidNameUse]);
    } else {
            printf("LookupAccountSid %d\n", GetLastError());
    }
    }
    CloseHandle(TokenHandle);
}
#endif

void EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG Context);

#define DATA_PROVIDER_PNPID_GUID \
    { 0xc7bf35d2,0xaadb,0x11d1, { 0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }
GUID GuidXYZ = DATA_PROVIDER_PNPID_GUID;

ULONG EventsReceived;

void EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PWNODE_SINGLE_INSTANCE WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWNODE_HEADER Wnode = WnodeHeader;
    LPGUID EventGuid = &WnodeHeader->Guid;        
    CHAR s[MAX_PATH];
    ULONG Status;
    WMIHANDLE Handle;
#if 0
    GetCallerInfo(FALSE);
      
    RevertToSelf();
    
    GetCallerInfo(FALSE);
    WackOnFile();    

    Status = RpcImpersonateClient(0);
    printf("RpcImpersonateClient -> %d\n", Status);
    if (Status == ERROR_SUCCESS)
    {
        WmiOpenBlock(&GuidXYZ, GENERIC_READ, &Handle);
        GetCallerInfo(TRUE);
        WackOnFile();
        RpcRevertToSelf();
    }
#endif    
    EventsReceived++;

    printf("Receieved event for guid %s\n", GuidToString(s, EventGuid));
    
    printf("BufferSize = 0x%x\n", Wnode->BufferSize);
    printf("ProviderId = %x\n", Wnode->ProviderId);    // Provider Id of driver returning this buffer
    printf("Version = %x\n", Wnode->Version);           // Reserved
    printf("Linkage = %x\n", Wnode->Linkage);           // Linkage field reserved for WMI
    printf("ClientContext = %x\n", Wnode->ClientContext);
    printf("Flags = %x\n", Wnode->Flags);             // Flags, see below
    
    if (Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE)
    {
        printf("WNODE_SINGLE_INSTANCE\n");
    printf("OffsetInstanceName = %x\n", WnodeSI->OffsetInstanceName);
    printf("InstanceIndex = %x\n", WnodeSI->InstanceIndex);    // (Static Instance Names)

    printf("DataBlockOffset = %x\n", WnodeSI->DataBlockOffset);  // offset from beginning of WNODE to data block
    printf("SizeDataBlock = %x\n", WnodeSI->SizeDataBlock);    // Size of data block for instance


    }

	printf("\n%d events received\n", EventsReceived);
}

#if 0
#define WmiRpcProtocolSequence1 TEXT("ncacn_np")
#define WmiRpcProtocolSequence2 TEXT("ncalrpc")
#define MaxRpcCalls RPC_C_PROTSEQ_MAX_REQS_DEFAULT

void
CreateEndpoints(void)
{
    ULONG i;
    ULONG Status;
    CHAR UniqueEndpoint[MAX_PATH];
    SECURITY_DESCRIPTOR SD;
    
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SD, TRUE, NULL, FALSE);
    
    for (i = 0; i < 20; i++)
    {
        sprintf(UniqueEndpoint, "TESTLRPCEP_%x", i);

        Status = RpcServerUseProtseqEp(WmiRpcProtocolSequence2,
                                               MaxRpcCalls,
                                               UniqueEndpoint,
                                               &SD);  // Security descriptor
                               
        if (Status != ERROR_SUCCESS)
    {
        printf("RpcServerUseProtseqEp failed %d\n", Status);
    }
    
    }

    for (i = 0; i < 20; i++)
    {
        sprintf(UniqueEndpoint, "\\pipe\\TESTEP_%x", i);

        Status = RpcServerUseProtseqEp(WmiRpcProtocolSequence1,
                                               MaxRpcCalls,
                                               UniqueEndpoint,
                                               &SD);  // Security descriptor
                               
        if (Status != ERROR_SUCCESS)
    {
        printf("RpcServerUseProtseqEp failed %d\n", Status);
    }
    
    }
}
#endif

PWNODE_HEADER EventPtrBuffer;
int _cdecl main(int argc, char *argv[])
{
    ULONG Status;
    GUID Guid;
    ULONG c,i;

#if 0
    c = 1;
    for (i = 0; i < 101; i++)
    {
        c += i;
    }
    printf("c = %d\n",c);
#endif	
    
    if ((argc != 2) && (argc != 3))
    {
        printf("getevent <guid>\n");
        return(0);
    }

#if 0
    CheckOwnPriv();    
    if (argc == 3)
    {
        printf("Creating endpoints\n");
        CreateEndpoints();
    }	
#endif    
    
    //
    // Parse the guid parameter
    if (! wGUIDFromString(argv[1], &Guid))
    {
        printf("Bad guid %s\n", argv[1]);
        return(0);
    }
    
    
    Status = WmiNotificationRegistration(&Guid,
                                     TRUE,
                                         EventCallbackRoutine,
                     0,
                                         NOTIFICATION_CALLBACK_DIRECT);
    if (Status != ERROR_SUCCESS)
    {
        printf("WMINotificationRegistration %d\n", Status);
        return(1);
    }

    // Loop forever receiving events
    while (1) Sleep(1000*1000);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\constantmap.cpp ===
// ConstantMap.cpp: implementation of the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////


#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;



#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"
#include "ConstantMap.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
   
CConstantMap::CConstantMap()
{
	MAPPAIR pair;

	pair.first = _T("EVENT_TRACE_TYPE_INFO");
	pair.second = EVENT_TRACE_TYPE_INFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_START");
	pair.second = EVENT_TRACE_TYPE_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_END");
	pair.second = EVENT_TRACE_TYPE_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_START");
	pair.second = EVENT_TRACE_TYPE_DC_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_END");
	pair.second = EVENT_TRACE_TYPE_DC_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_EXTENSION");
	pair.second = EVENT_TRACE_TYPE_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_REPLY");
	pair.second = EVENT_TRACE_TYPE_REPLY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED7");
	pair.second = EVENT_TRACE_TYPE_RESERVED7;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED8");
	pair.second = EVENT_TRACE_TYPE_RESERVED8;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED9");
	pair.second = EVENT_TRACE_TYPE_RESERVED9;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_LOAD");
	pair.second = EVENT_TRACE_TYPE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_READ");
	pair.second = EVENT_TRACE_TYPE_IO_READ;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_WRITE");
	pair.second = EVENT_TRACE_TYPE_IO_WRITE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_TF");
	pair.second = EVENT_TRACE_TYPE_MM_TF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_DZF");
	pair.second = EVENT_TRACE_TYPE_MM_DZF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_COW");
	pair.second = EVENT_TRACE_TYPE_MM_COW;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_GPF");
	pair.second = EVENT_TRACE_TYPE_MM_GPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SEND");
	pair.second = EVENT_TRACE_TYPE_SEND;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RECEIVE");
	pair.second = EVENT_TRACE_TYPE_RECEIVE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONNECT");
	pair.second = EVENT_TRACE_TYPE_CONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DISCONNECT");
	pair.second = EVENT_TRACE_TYPE_DISCONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_GUIDMAP");
	pair.second = EVENT_TRACE_TYPE_GUIDMAP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONFIG");
	pair.second = EVENT_TRACE_TYPE_CONFIG;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SIDINFO");
	pair.second = EVENT_TRACE_TYPE_SIDINFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_PROCESS");
	pair.second = EVENT_TRACE_FLAG_PROCESS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_THREAD");
	pair.second = EVENT_TRACE_FLAG_THREAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
	pair.second = EVENT_TRACE_FLAG_IMAGE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_FILE_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
	pair.second = EVENT_TRACE_FLAG_NETWORK_TCPIP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_EXTENSION");
	pair.second = EVENT_TRACE_FLAG_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
	pair.second = EVENT_TRACE_FLAG_FORWARD_WMI;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NONE");
	pair.second = EVENT_TRACE_FILE_MODE_NONE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
	pair.second = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
	pair.second = EVENT_TRACE_FILE_MODE_CIRCULAR;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
	pair.second = EVENT_TRACE_FILE_MODE_NEWFILE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
	pair.second = EVENT_TRACE_PRIVATE_LOGGER_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_REAL_TIME_MODE");
	pair.second = EVENT_TRACE_REAL_TIME_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
	pair.second = EVENT_TRACE_DELAY_OPEN_FILE_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_BUFFERING_MODE");
	pair.second = EVENT_TRACE_BUFFERING_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_QUERY");
	pair.second = EVENT_TRACE_CONTROL_QUERY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_STOP");
	pair.second = EVENT_TRACE_CONTROL_STOP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_UPDATE");
	pair.second = EVENT_TRACE_CONTROL_UPDATE;
	m_Map.insert(pair);

	pair.first = _T("WNODE_FLAG_TRACED_GUID");
	pair.second = WNODE_FLAG_TRACED_GUID;
	m_Map.insert(pair);

	pair.first = _T("ERROR_SUCCESS");
	pair.second = ERROR_SUCCESS;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_PARAMETER");
	pair.second = ERROR_INVALID_PARAMETER;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_NAME");
	pair.second = ERROR_INVALID_NAME;
	m_Map.insert(pair);

	pair.first = _T("ERROR_BAD_LENGTH");
	pair.second = ERROR_BAD_LENGTH;
	m_Map.insert(pair);


	pair.first = _T("VALUE_NULL");
	pair.second = NULL;
	m_Map.insert(pair);

	pair.first = _T("VALUE_MAX_MEMORY");
	pair.second = 0;
	m_Map.insert(pair);

	pair.first = _T("VALUE_ZERO");
	pair.second = 0;
	m_Map.insert(pair);

}

CConstantMap::~CConstantMap()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\logger.h ===
#if !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#define UNICODE
#define _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogger
{
public:
	CLogger(LPCTSTR lpctstrFileName,  bool bAppend = true);
	~CLogger();
	int LogTCHAR(LPCTSTR lpctstrOut);
	int LogULONG(ULONG uLong, bool bHex = true);
	int LogULONG64(ULONG64 uLong64,  bool bHex = true);
	int LogGUID(GUID Guid);
	int LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	int LogTime(time_t &Time);
	void Flush() {m_pPersistor->Stream().flush();}
	HRESULT GetOpenStatus() {return m_hr;}
private:
	CPersistor *m_pPersistor;
	char *m_sFileName;
	HRESULT m_hr;
};

#endif // !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\logger.cpp ===
// Logger.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Logger.h"


#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff,0x0d, 0x0a};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

CLogger::CLogger(LPCTSTR lpctstrFileName, bool bAppend)
{
#ifdef _UNICODE
	m_sFileName = NewLPSTR((LPCWSTR) const_cast<LPTSTR>(lpctstrFileName));
#else
	m_sFileName = NewTCHAR(lpctstrFileName);
#endif

	m_pPersistor = new CPersistor(m_sFileName, ios::out, false);
	m_hr = m_pPersistor -> OpenLog(bAppend);
}

CLogger::~CLogger()
{
	free(m_sFileName);
	delete m_pPersistor;
}

int CLogger::LogTCHAR(LPCTSTR lpctstrOut)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	PutALine(m_pPersistor->Stream(), lpctstrOut, -1);

	return 0;
}

int CLogger::LogTime(time_t &Time)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	TCHAR tcArray[26];
	LPCTSTR lpctstrTime = t_ctime(&Time);
	_tcscpy(tcArray,lpctstrTime);
	tcArray[24] = _T('\0');
	TCHAR *p = tcArray;

	PutALine(m_pPersistor->Stream(), p, -1);

	return 0;
}

int CLogger::LogULONG(ULONG ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONGVar(m_pPersistor->Stream(), ul, bHex);

	return 0;
}

int CLogger::LogULONG64(ULONG64 ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONG64Var(m_pPersistor->Stream(), ul);

	return 0;
}

int CLogger::LogGUID(GUID Guid)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	GUIDOut(m_pPersistor->Stream(), Guid);

	return 0;
}

int CLogger::LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (pProps == NULL)
	{
		PutALine(m_pPersistor->Stream(),_T("_EVENT_TRACE_PROPERTIES Instance NULL\n"),-1);
		return 0;
	}

	CEventTraceProperties Props(pProps);

	m_pPersistor->Stream() << Props;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\constantmap.h ===
// ConstantMap.h: interface for the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_

#define UNICODE
#define _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef pair<t_string, unsigned int> MAPPAIR;
typedef map<t_string, unsigned int> CONSTMAP;


class CConstantMap  
{
public:
	CConstantMap();
	virtual ~CConstantMap();
	CONSTMAP m_Map;
};

#endif // !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	TestStartTrace.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
#define AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
#ifndef NT5BUILD
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__991FD5F0_FC29_11D2_8052_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\main.h ===
#ifndef _MAIN_H
#define _MAIN_H


#include "t_string.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
//#include "ConstantMap.h" 
//#include "TCOData.h"
#include "Logger.h"
//#include "Validator.h"

ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    OUT ULONG *InOutBufferSize,
    OUT PVOID Buffer);

void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid );

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

//int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\persistor.cpp ===
// Persistor.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>

using namespace std;

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "StructureWapperHelpers.h"



#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CPersistor::CPersistor
(const char *pszFilename, int nMode, bool bLoading)
{
	m_sFilename = pszFilename;
	m_nMode = nMode;
	m_bLoading = bLoading;
	m_pfsFile = NULL;
	m_bFirst = true;
	m_pfsFile = NULL;
}

CPersistor::~CPersistor()
{
	Close();
}

HRESULT CPersistor::Close()
{
	if (m_pfsFile && m_pfsFile->is_open())
	{
#ifdef _UNICODE
		if (!m_bLoading)
		{
		
		}
#endif
		m_pfsFile->flush();
		m_pfsFile->close();
		delete m_pfsFile;
		m_pfsFile = NULL;
	}
	else if (m_pfsFile)
	{
		delete m_pfsFile;
		m_pfsFile = NULL;
	}

	return S_OK;

}

HRESULT CPersistor::Open()
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
				(m_sFilename.c_str(),m_nMode | ios_base::binary);

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		if (m_bFirst && !m_bLoading)
		{
			// To Do:  Need to write out here the UNICODE string.
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		}
		else if (m_bFirst)
		{
			// Need to skip over the UNICODE string.
			fpos_t p = m_pfsFile->tellp();
			if (p == (fpos_t) 0)
			{
				TCHAR tc;
				tc = Stream().peek();
				// Need to make sure that the file is unicode.
				if (tc != 0xff)
				{
					m_pfsFile ->close();
					delete m_pfsFile;
					m_pfsFile = NULL;
					return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
				}
				
				TCHAR t;

				GetAChar(Stream(), t);
				
			}
		}
#else
		if (m_bFirst && m_bLoading)
		{
			// Need to make sure that the file is not unicode.
			int tc;
			tc = Stream().peek();
			if (tc == 0xff)
			{
				m_pfsFile ->close();
				delete m_pfsFile;
				m_pfsFile = NULL;
				return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
			}
		}
#endif
		m_bFirst = false;
		return S_OK;
	}


}

// 
HRESULT CPersistor::OpenLog(bool bAppend)
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
		(m_sFilename.c_str(),m_nMode | ios_base::binary | (bAppend ?  ios::app : 0));

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		//m_pfsFile->seekp(ios::end);
		//fpos_t p = m_pfsFile->tellp();
		//if (p == (fpos_t) 0)
		//{
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		//}
#endif
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\main.cpp ===
#define MAX_STR 256
#define MAX_GUIDS 10

#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "main.h"





TRACEHANDLE LoggerHandle = (TRACEHANDLE) 2;
ULONG TraceEventFlag = 0, EnableLevel = 0, EnableFlags = 0;
ULONG LoggerEnableLevel, LoggerEnableFlag;
ULONG TraceMode;
ULONG DataBlockSize = 0;
ULONG TraceEventInstanceFlag = 0;
PREGISTER_TRACE_GUID RegisterTraceGuid;
GUID TransactionGuid[12] =  {	{ 0xa7301ec8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa8558716, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa9226a42, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa395d64, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa8ccfb2, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaad4563e, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab171816, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab55153a, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab84c442, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabb210f0, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabe1bff8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xb01e8dee, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 } };


typedef struct _BLOCK1 {
    UCHAR                 EventChar;
	ULONG                 EventUlong;
} BLOCK1, *PBLOCK1;

typedef struct _EVENT_BLOCK1 {
    EVENT_TRACE_HEADER    Header;
	BLOCK1                Block1;
} EVENT_BLOCK1, *P_EVENT_BLOCK1;

typedef struct _EVENT_INSTANCE_BLOCK1 {
	EVENT_INSTANCE_HEADER Header;
	UCHAR				  EventChar;
	ULONG				  EventUlong;
} EVENT_INSTANCE_BLOCK1, *P_EVENT_INSTANCE_BLOCK1;

typedef struct _EVENT_BLOCK2 {
	EVENT_TRACE_HEADER Header;
	MOF_FIELD  MofField;
} EVENT_BLOCK2, *P_EVENT_BLOCK2;


BLOCK1 Block1;
EVENT_BLOCK1 EventBlock1;
EVENT_BLOCK2 EventBlock2;
EVENT_INSTANCE_BLOCK1 EventInstanceBlock1;
TRACE_GUID_REGISTRATION TraceGuidReg[MAX_GUIDS];

main(int argc, char* argv[])
{
	LPTSTR CommandFile;
	TRACEHANDLE RegistrationHandle;	
	ULONG Status;
	LPTSTR *commandLine;
	LPGUID pGuid;
	ULONG Count;
	ULONG GuidCount = 0;
	//CLogger *pLoggingInfo;
	LPCTSTR LogFileName;
	LPTSTR *targv;
	int i;
	

	pGuid = (LPGUID ) malloc(MAX_GUIDS * sizeof(GUID));
	CommandFile = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	LogFileName = (LPCTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	targv = (LPTSTR *) malloc(argc*sizeof(LPTSTR));
	for( i = 0; i < argc; i++ )
		targv[i] = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);

	SplitCommandLine( GetCommandLine(), targv);
	for( i = 0; i < MAX_GUIDS; i++)
		TraceGuidReg[i].Guid = &TransactionGuid[i];
	Count = 1;
	while ( Count <= (argc-1) )
	{
		if ( !_tcsicmp(targv[Count], _T("-guids") )) 
		{
			Count++;
			if (Count <= argc) 
			{
				ConvertAsciiToGuid( targv[Count], &pGuid[GuidCount]);
				GuidCount++;
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-file") ))
		{
			Count++;
			if ( Count <= argc)
			{
				CommandFile = targv[Count];
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-flag") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableFlag = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-level") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableLevel = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-mode") ))
		{
			Count++;
			if( Count <= argc)
			{
				TraceMode = atoi(argv[Count]);
				Count++;
				continue;
			}
		}

		if( !_tcsicmp(targv[Count], _T("-TraceEventInstance") ))
		{
			Count++;
			TraceEventInstanceFlag = 1;
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-log") ))
		{
			Count++;
			if( Count <= argc )
			{
				//LogFileName = _T(argv[Count]);
				LogFileName = _T("C:\\");
				Count++;
				continue;
			}
		}

		Count++;
		continue;
	}
        
	Count = sizeof(REGISTER_TRACE_GUID);
	RegisterTraceGuid = (PREGISTER_TRACE_GUID ) malloc(sizeof(REGISTER_TRACE_GUID));
	RegisterTraceGuid->ControlGuid  = (LPGUID) malloc(sizeof(GUID));
	RegisterTraceGuid->MofImagePath = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);
	RegisterTraceGuid->MofResourceName = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);

	if( RegisterTraceGuid == NULL)
	{
		printf("\nGufooo");
		exit(0);
	}
	InitializeRegisterTraceGuid( RegisterTraceGuid );

	RegisterTraceGuid->UseMofPtrFlag = 0;
	RegisterTraceGuid->UseGuidPtrFlag = 0;
	
	Status = ReadInputFile( CommandFile, RegisterTraceGuid );


	if( RegisterTraceGuid->GuidCount != 0)
		RegisterTraceGuid->GuidCount = GuidCount;
	
	if( RegisterTraceGuid->CallBackFunction != 0)
		RegisterTraceGuid->CallBackFunction = ProviderCallBack;

	if( RegisterTraceGuid->TraceGuidReg != 0 )
		RegisterTraceGuid->TraceGuidReg = ( PTRACE_GUID_REGISTRATION) &TraceGuidReg[0];

	if( RegisterTraceGuid->RegistrationHandle != 0 )
		RegisterTraceGuid->RegistrationHandle = &RegistrationHandle;

	if( RegisterTraceGuid->GuidCount != 0 )
		RegisterTraceGuid->GuidCount = MAX_GUIDS;

	//InitializeLogging( LogFileName, pLoggingInfo);

	//if (pLoggingInfo)
	//{
		//pLoggingInfo->LogTCHAR(_T("\n*******************************************************\n"));
		//pLoggingInfo->LogTCHAR(_T("StartTraceAPI TCO test "));
		//pLoggingInfo->Flush();	
	//}



	Status = RegisterTraceGuids( ProviderCallBack,
								NULL, //Context
								pGuid,
								RegisterTraceGuid->GuidCount,
								RegisterTraceGuid->TraceGuidReg,
								RegisterTraceGuid->MofImagePath,
								RegisterTraceGuid->MofResourceName,
								RegisterTraceGuid->RegistrationHandle );

	if( RegisterTraceGuid->UnRegistrationHandle != 0 )
	{
		Status = UnregisterTraceGuids( (TRACEHANDLE) 0 );
		return;
	}

	if( Status == ERROR_SUCCESS)
	{
		Count = 0;
		do
		{
			if( (TraceEventFlag ) && ( TraceEventInstanceFlag) )
			{
				Status = TraceEventInstances( TraceMode, (Count%10), Count);
				Count++;
			}
			else if (TraceEventFlag)
			{
				Status = TraceEvents( TraceMode, (Count%10), (Count%100));
				Count++;
			}

		}while(1);
		Status = UnregisterTraceGuids( *(RegisterTraceGuid->RegistrationHandle));
	}
}


ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize,
    PVOID Buffer)
{
	switch (RequestCode )
	{
		case WMI_ENABLE_EVENTS:
		{
			TraceEventFlag = 1;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
			break;
		}
		
		case WMI_DISABLE_EVENTS:
		{
			TraceEventFlag = 0;
			break;
		}
	}
		return 0;
}


void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid )
{
	//Initialize with some random values and then read from the input
	//file. If any of these parameters needs to be tested with 0, 
	//input files will set this as zero.
	if( RegisterTraceGuid )
	{
		RegisterTraceGuid->GuidCount = 0xa5;
		RegisterTraceGuid->CallBackFunction = (PVOID) 0xa5a5a5;
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) (0xa5a5a5);
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
	}

}

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;

	switch ( TraceMode )
	{
		case 0 :
		{
			if( RegisterTraceGuid->UseMofPtrFlag != 1)
			{
				EventBlock1.Header.Size = sizeof(EventBlock1);
				ULONG Temp = sizeof(Block1);
				EventBlock1.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock1.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock1.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				EventBlock1.Block1.EventChar = (UCHAR) Count;
				EventBlock1.Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock1);
			}
			else
			{
				EventBlock2.Header.Size = sizeof(EventBlock2);
				EventBlock2.Header.Flags = WNODE_FLAG_USE_MOF_PTR;
				EventBlock2.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock2.Header.Flags |= WNODE_FLAG_TRACED_GUID;
				EventBlock2.MofField.DataPtr = (ULONGLONG) &Block1;
				EventBlock2.MofField.Length = sizeof(BLOCK1);
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock2.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock2.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				Block1.EventChar = (UCHAR) Count;
				Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock2);

			}
			break;
		}
	}
	return Status;

}


ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;
	EVENT_INSTANCE_INFO InstanceInfo;
	switch ( TraceMode )
	{
		case 0 :
		{
			EventInstanceBlock1.Header.Size = sizeof(EventInstanceBlock1);
			EventInstanceBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
			if( RegisterTraceGuid->UseMofPtrFlag == 1)
				EventInstanceBlock1.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
			EventInstanceBlock1.EventChar = (UCHAR) Count;
			EventInstanceBlock1.EventUlong = Count;
			Status = CreateTraceInstanceId( TraceGuidReg[TraceGuid].RegHandle,
											&InstanceInfo);
			if( Status == ERROR_SUCCESS )
				Status = TraceEventInstance( LoggerHandle, (PEVENT_INSTANCE_HEADER) &EventBlock1,
											 &InstanceInfo,
											 NULL);
			break;
		}
	}
	return Status;

}

/*
int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo)
{
	HRESULT hr = S_OK;
//	t_string tsError;

	if (lpctstrTCOFile)
	{
		// Open *our* logger file.
		pLoggingInfo = new CLogger(lpctstrTCOFile, false);
		hr = pLoggingInfo->GetOpenStatus();
		if (FAILED (hr))
		{
//			tsError = _T("Could not open detail log file \"");
//			tsError += lpctstrTCOFile;
//			tsError += _T("\".");
			//*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\persistor.h ===
// Persistor.h: interface for the CPersistor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPersistor  
{
public:
	virtual ~CPersistor();
	CPersistor(const char *pszFilename, int nMode, bool bLoading = true );
	HRESULT Close();
	HRESULT Open();
	// For logging support.  We only log out.
	HRESULT OpenLog(bool bAppend = true);
	t_fstream &Stream() {return *m_pfsFile;}
	bool IsLoading() {return m_bLoading;}
	const char* GetFilename() {return m_sFilename.c_str();} 
protected:
	t_fstream *m_pfsFile;
	bool m_bLoading;
	string m_sFilename;
	int m_nMode;
	bool m_bFirst;
};

#endif // !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\readfile.h ===
#define UNICODE
#define _UNICODE

#ifndef _READFILE_H
#define _READFILE_H
/*
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>

#include "struct.h"
#include "utils.h"
*/
#define MAX_STR 256


ULONG
ReadInputFile(LPTSTR InputFile, PREGISTER_TRACE_GUID RegisterTraceGuid);

BOOLEAN
ReadGuid( LPGUID ControlGuid );

BOOLEAN
ReadUlong( ULONG *GuidCount);

BOOLEAN
ReadString( TCHAR *String, ULONG StringLength);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\readfile.cpp ===
#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "main.h"





FILE *FileP;


LPGUID ControlGuid;

ULONG
ReadInputFile(LPTSTR InputFile, PREGISTER_TRACE_GUID RegisterTraceGuid)
{

	TCHAR *String;

	String = (TCHAR *) malloc( MAX_STR*sizeof(TCHAR) );
	String = (TCHAR *) malloc(100);
	if (InputFile == NULL )
		return 1;

	FileP = _tfopen(InputFile, _T("r"));
	if (FileP== NULL )
		return 1;

	//Now Read MofImagePath
	if( !ReadString ( (TCHAR *)RegisterTraceGuid->MofImagePath, MAX_STR) )
	{
		//Log here and then return
		return 1;
	}
	if ( !_tcsicmp(RegisterTraceGuid->MofImagePath, _T("NULL")  ))
		RegisterTraceGuid->MofImagePath = (TCHAR *) 0;

	//Now Read MofResourceName
	if( !ReadString ( (TCHAR *)RegisterTraceGuid->MofResourceName, MAX_STR) )
	{
		//Log here and then return
		return 1;
	}
	if ( !_tcsicmp(RegisterTraceGuid->MofResourceName, _T("NULL")  ))
		RegisterTraceGuid->MofResourceName = (TCHAR *) 0;

	//Now Read Call backfunction...
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{	
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->CallBackFunction = (PVOID) 0;

	//Now Read TraceGuidReg.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) 0;

	//Now Read Registration Handle.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) 0;

	//Now Read GuidCount
	//GuidCome will come from main process..But to test 0, this is required.
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("0000")  ))
		RegisterTraceGuid->GuidCount = 0;

	//Now Read Handle for  UnregisterTraceGuid
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) 0;


	//Now Read Handle for  GetTraceLoggerHandle
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceLoggerHandle = (PTRACEHANDLE) 0;

	//Now Read Handle for  GetTraceEnableLevel
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceEnableLevel = (PTRACEHANDLE) 0;


	//Now Read Handle for  GetTraceEnableFlags
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->GetTraceEnableFlag = (PTRACEHANDLE) 0;

	//Now Read Handle for  UnregisterTraceGuid
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("NULL")  ))
		RegisterTraceGuid->TraceHandle = (PTRACEHANDLE) 0;


	//Now Read if Guid Ptr is TRUE
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("USE_GUID_PTR")  ))
		RegisterTraceGuid->UseGuidPtrFlag = 1;

		//Now Read if Mof Ptr is TRUE
	if( !ReadString ( (TCHAR *)String, MAX_STR) )
	{
		//This is optional input so can return success if it is not present
		return 0;
	}
	if ( !_tcsicmp(String, _T("USE_MOF_PTR")  ))
		RegisterTraceGuid->UseMofPtrFlag = 1;

	fclose( FileP );
	return 0;
}

BOOLEAN
ReadGuid( LPGUID Guid )
{

	TCHAR Temp[100];
	TCHAR arg[100];
	ULONG i;

	if( _fgetts(Temp, 100, FileP) != NULL )
	{
		_tcsncpy(arg, Temp, 37);
		arg[8] = 0;
		Guid->Data1 = ahextoi(arg);

		_tcsncpy(arg, &Temp[9], 4);
		arg[4] = 0;
		Guid->Data2 = (USHORT) ahextoi(arg);

		_tcsncpy(arg, &Temp[14], 4);
		arg[4] = 0;
		Guid->Data3 = (USHORT) ahextoi(arg);
		

        for (i=0; i<2; i++) 
		{
			_tcsncpy(arg, &Temp[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) 
		{
            _tcsncpy(arg, &Temp[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }

	return true;
	}
	return false;
}

BOOLEAN
ReadUlong( ULONG *GuidCount)
{
	TCHAR Temp[100];

	if( _fgetts(Temp, 100, FileP) != NULL )
	{
		RemoveComment( Temp);
		Temp[4] = 0;
		*GuidCount = ahextoi(Temp);
		return true;
	}
	return false;
}


BOOLEAN
ReadString( TCHAR *String, ULONG StringLength)
{
	if( _fgetts(String, StringLength, FileP) != NULL)
	{
		RemoveComment( String);
		return true;
	}
	else
		return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\struct.h ===
#define UNICODE
#define _UNICODE

#ifndef _STRUCT_H
#define _STRUCT_H

typedef struct _REGISTER_TRACE_GUID {

	LPGUID ControlGuid;
	LPTSTR MofImagePath;
	LPTSTR MofResourceName;
	ULONG GuidCount;
	PVOID CallBackFunction;
	PTRACE_GUID_REGISTRATION TraceGuidReg;
	PTRACEHANDLE RegistrationHandle;
	PTRACEHANDLE UnRegistrationHandle;
	PTRACEHANDLE GetTraceLoggerHandle;
	PTRACEHANDLE GetTraceEnableLevel;
	PTRACEHANDLE GetTraceEnableFlag;
	PTRACEHANDLE TraceHandle;
	ULONG UseMofPtrFlag;
	ULONG UseGuidPtrFlag;
} REGISTER_TRACE_GUID, *PREGISTER_TRACE_GUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\umprovider.h ===
#ifndef _MAIN_H
#define _MAIN_H


#include "t_string.h"
#include "Utilities.h"
#include "Persistor.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
//#include "ConstantMap.h" 
//#include "TCOData.h"
#include "Logger.h"
//#include "Validator.h"

ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    OUT ULONG *InOutBufferSize,
    OUT PVOID Buffer);

void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid );

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count);

//int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\structurewapperhelpers.cpp ===
// StructureWapperHelpers.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"
#include "Utilities.h"

#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"
  
extern CConstantMap g_ConstantMap;

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif


// Why we are not using formatted input:
#if 0
From:	Phil Lucido (Exchange) 
Sent:	Friday, April 16, 1999 10:34 AM
To:	Judy Powell
Cc:	Visual C++ Special Interest Group
Subject:	RE: Wide character output via wfstream from the "Standard Library" 
using VC 6 Enterprise Edition SP2 on NT4 SP4

It looks like our iostreams implementation for wide-char streams is actually wide-char 
in memory, multibyte chars on disk.  The reason you get an empty file is because wctomb 
is failing on 0xfeff.

This should work more like the stdio stuff, where a text mode wide-char stream writes 
multibyte chars to a file, but binary mode writes the raw unicode.

We get our C++ Library implementation from Dinkumware (P.J. Plauger).  I'll check with 
him to see about changing this implementation so binary mode wide-char iostream is 
compatible with wide-char stdio.

...Phil
#endif

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode)
{
// EVENT_TRACE_FILE_MODE_NONE          0x0000  // logfile is off
// EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x0001  // log sequentially
// EVENT_TRACE_FILE_MODE_CIRCULAR      0x0002  // log in circular manner
// EVENT_TRACE_FILE_MODE_NEWFILE       0x0004  // log to new file if full
// EVENT_TRACE_REAL_TIME_MODE          0x0100  // real time mode on
// EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x0200  // delay opening file
// EVENT_TRACE_BUFFERING_MODE          0x0400  // buffering mode only

	t_string tsOut;
	
	// @#$ENUM: says that we are not storing a literal value. 
	tsOut = _T("\"LogFileMode:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	// Values we anticipate.
	if (LogFileMode == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NONE)
	{
		tsOut = _T("EVENT_TRACE_FILE_MODE_NONE");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_SEQUENTIAL");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut =  _T("|EVENT_TRACE_FILE_MODE_CIRCULAR");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FILE_MODE_NEWFILE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_REAL_TIME_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_DELAY_OPEN_FILE_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_PRIVATE_LOGGER_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}

	if (LogFileMode & EVENT_TRACE_BUFFERING_MODE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_BUFFERING_MODE");
			PutALine(ros, tsOut.c_str());
		}
	}
	
	// A value we did not anticipate.

	ULONG uExpected = 
		EVENT_TRACE_FILE_MODE_NONE | 
		EVENT_TRACE_FILE_MODE_SEQUENTIAL | 
		EVENT_TRACE_FILE_MODE_CIRCULAR |
		EVENT_TRACE_FILE_MODE_NEWFILE |
		EVENT_TRACE_REAL_TIME_MODE |
		EVENT_TRACE_DELAY_OPEN_FILE_MODE |
		EVENT_TRACE_BUFFERING_MODE | 
		EVENT_TRACE_PRIVATE_LOGGER_MODE;

	if ((uExpected | LogFileMode) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & LogFileMode, true);
		}
	}

	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags)
{
// EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
// EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
// EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

// EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
// EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

// EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
// EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

// EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive
//
// Pre-defined Enable flags for everybody else
//
// EVENT_TRACE_FLAG_PRIVATE            0xC0000000  // Private buffering
// EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
// EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
// EVENT_TRACE_FLAG_ENABLE_RESERVE1    0x20000000  // Reserved
// EVENT_TRACE_FLAG_ENABLE_RESERVE2    0x10000000  // Reserved

	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"EnableFlags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (EnableFlags == 0)
	{
		tsOut = _T("0");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_PROCESS)
	{
		tsOut = _T("EVENT_TRACE_FLAG_PROCESS");
		PutALine(ros, tsOut.c_str());
		bFirstOut = false;
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_THREAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_THREAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_IMAGE_LOAD");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_DISK_FILE_IO");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_NETWORK_TCPIP");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_PRIVATE)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_PRIVATE");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_EXTENSION");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_FORWARD_WMI)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_FORWARD_WMI");
			PutALine(ros, tsOut.c_str());
		}
	}
#if 0
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE1)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE1");
			PutALine(ros, tsOut.c_str());
		}
	}
	if (EnableFlags & EVENT_TRACE_FLAG_ENABLE_RESERVE2)
	{
		if (bFirstOut)
		{
			tsOut = _T("EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|EVENT_TRACE_FLAG_ENABLE_RESERVE2");
			PutALine(ros, tsOut.c_str());
		}
	}
#endif
	ULONG uExpected = 
		EVENT_TRACE_FLAG_PROCESS | 
		EVENT_TRACE_FLAG_THREAD | 
		EVENT_TRACE_FLAG_IMAGE_LOAD |
		EVENT_TRACE_FLAG_DISK_IO |
		EVENT_TRACE_FLAG_DISK_FILE_IO |
		EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS |
		EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS | 
		EVENT_TRACE_FLAG_NETWORK_TCPIP | 
		EVENT_TRACE_FLAG_EXTENSION |
		EVENT_TRACE_FLAG_FORWARD_WMI;

	if ((uExpected | EnableFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & EnableFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
}

// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags)
{
	t_string tsOut;

	// @#$ENUM: says that we are not storing a literal value. 
	tsOut =  _T("\"Wnode.Flags:@#$ENUM:");
	PutALine(ros, tsOut.c_str());
	bool bFirstOut = true;

	if (WnodeFlags & WNODE_FLAG_TRACED_GUID)
	{
		if (bFirstOut)
		{
			tsOut = _T("WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
			bFirstOut = false;
		}
		else
		{
			tsOut = _T("|WNODE_FLAG_TRACED_GUID");
			PutALine(ros, tsOut.c_str());
		}
	}

	ULONG uExpected = 
		WNODE_FLAG_TRACED_GUID;

	if ((uExpected | WnodeFlags) != uExpected)
	{
		if (bFirstOut)
		{
			tsOut = _T("@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
		else
		{
			tsOut = _T("|@#$UNKNOWNVALUE:0x");
			PutALine(ros, tsOut.c_str());
			PutAULONGVar(ros, ~uExpected & WnodeFlags, true);
		}
	}
	
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

}

// We print out a GUID in the form:
//  "{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// typedef struct _GUID
// {
//    DWORD  Data1;
//    WORD   Data2;
//    WORD   Data3;
//    BYTE   Data4[8];
// } GUID;
// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
// the third group of 4 hexadecimal digits. The remaining 6 bytes 
// contain the final 12 hexadecimal digits.  We have separate
// logic for acsii and unicode for Data4.
void GUIDOut(t_ostream &ros, GUID Guid)
{
	t_string tsOut;
	t_strstream strStream;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ros.flags() | ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	PutALine(ros, tsOut.c_str() , -1);
}

void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large)
{
	t_string tsOut;
	tsOut = _T("{0x");
	PutALine(ros, tsOut.c_str() , -1);

	LONG Long = Large.u.HighPart;
	PutALONGVar(ros, Large.u.HighPart,true);

	DWORD DWord = Large.u.LowPart;
	PutADWORDVar(ros, DWord);

	tsOut = _T("}");
	PutALine(ros, tsOut.c_str() , -1);
	
}

void InitializeTCHARVar(t_string &rtsValue , void *pVar)
{
	TCHAR **pTCHAR = reinterpret_cast<TCHAR **> (pVar);
	if (rtsValue.length() > 0)
	{
		// Null string.
		if (case_insensitive_compare(rtsValue,_T("@#$STRING_NULL")) == 0)
		{
			*pTCHAR = NULL;
		}
		// Empty string.
		else if (case_insensitive_compare(rtsValue,_T("@#$STRING_EMPTY")) == 0)
		{
			*pTCHAR = NewTCHAR(_T(""));
		}
		else // Just a string.
		{
			*pTCHAR = NewTCHAR(rtsValue.c_str());
		}
	}
	else // Empty string.
	{
		*pTCHAR = NewTCHAR(_T(""));
	}
}

//"EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
//"EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:0x20"
void InitializeEnumVar(t_string &rtsValue , void *pVar)
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);
	*pULong = 0;

	int nEndPos;
	int nBegPos = 0;
	int nSubstrLen;

	t_string tsTemp;

	CONSTMAP::iterator Iterator;

	bool bDone = false;

	while (!bDone)
	{
		nEndPos = rtsValue.find(_T("|"), nBegPos); 

		if (nEndPos == t_string::npos)
		{
			bDone = true;
			nEndPos = rtsValue.length();
		}

		nSubstrLen = nEndPos - nBegPos;

		tsTemp = rtsValue.substr(nBegPos, nSubstrLen);

		Iterator = g_ConstantMap.m_Map.find(tsTemp);

		if (Iterator == g_ConstantMap.m_Map.end())
		{
			// Had better be @#$UNKNOWNVALUE:0x
			if (tsTemp.compare(0, 18, _T("@#$UNKNOWNVALUE:0x")) == 0)
			{		
				tsTemp = rtsValue.substr(nBegPos + 18);
				ULONG ulTemp;
				InitializeULONGVar(tsTemp , (void *) &ulTemp, true);
				*pULong |= ulTemp;
			}

		}
		else
		{
			*pULong |= (*Iterator).second; 
		}

		nBegPos = nEndPos + 1;
	}


}

// Expect HANDLEs to be in the form 0xnnnnnnnn
void InitializeHandleVar(t_string &rtsValue , void *pVar)
{
	HANDLE *pHandle = reinterpret_cast<HANDLE *> (pVar);
	HANDLE handle;

	t_strstream strStream;

	t_string tsTemp;
	tsTemp = rtsValue.substr(2);
	
	strStream << tsTemp;

	strStream >> handle;

	*pHandle = handle;

}

void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex )
{
	ULONG *pULong = reinterpret_cast<ULONG *> (pVar);

	ULONG uLong;

	t_strstream strStream;
	
	strStream << rtsValue;

	if (bHex)
	{
		strStream >> hex >> uLong;
	}
	else
	{
		strStream >> uLong;
	}


	*pULong = uLong;
}

void InitializeLONGVar(t_string &rtsValue , void *pVar)
{
	LONG *pLong = reinterpret_cast<LONG *> (pVar);
	LONG Long;

	t_strstream strStream;
	
	strStream << rtsValue;

	strStream >> Long;

	*pLong = Long;

}

t_istream &GetAChar(t_istream &ris,TCHAR &tc)
{
#ifndef _UNICODE
	tc = ris.get();
	return ris;
#else
	char *pChar = (char *) &tc;
	
	pChar[0] = ris.get();
	pChar[1] = ris.get();

	return ris;

#endif
}


// See note at top of this file to understand why we are not using
// formatted input.
// We are reading in a wide character file one byte at a time and
// creating our two byte characters from each two byte sequence.
t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
	t_istream &r = ris.getline(tcBuffer,nBufferSize - 1,_T('\n'));
	// Docs for getline say that it sould eat the new line.  It does
	// not, and it does even worse.  It returns a 0x0d which we delete.
	// This should work even when getline does
	// what the docs say it will.
	int n = _tcsclen(tcBuffer) - 1;

	if (tcBuffer[n] == 0x0d)
	{
		tcBuffer[n] = _T('\0');
	}

	return r;
#else
	char *pChar = (char *) tcBuffer;
	bool bSkipNext = false;
	bool bEOL = false;
	int intIn1;
	int intIn2;
	int i = 0;
	int count = 0;
	while (1)
	{
		intIn1 = ris.get();
		if (ris.eof())
		{
			break;
		}
		intIn2 = ris.get();
		
		if (intIn1 == 0x0d && intIn2 == 0x0)
		{
			// Found 0x0d so eat the 0x0a.
			intIn1 = ris.get();
			intIn2 = ris.get();
			tcBuffer[i / 2] = _T('\0');
			break;
		}
		else 
		{
			pChar[i++] = intIn1;
			pChar[i++] = intIn2;
		}
	}

	if (i == 0)
	{
		tcBuffer[0] = _T('\0');
	}

	return ris;

#endif

}

// See note at top of this file to understand why we are not using
// formatted input.
// We are writing out a wide character file one byte at a time.
// nBufferSize is the number of TCHARS not size in bytes.
// if nBufferSize == -1 tcBuffer better be a null terminated string.
// Will handle a unicode string with "proper" and "inproper" newlines. 
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize)
{
#ifndef _UNICODE
//	return ros << tcBuffer;
	const char *pBuffer =  tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 1] != 0x0d)
		{
			ros.put(0x0d);
		}
		ros.put(intOut);
	}
	
	return ros;
#else
	char *pBuffer = (char *) tcBuffer;
	int nSize = nBufferSize;
	if (nBufferSize == -1)
	{
		nSize = _tcsclen(tcBuffer);
	}

	for (int i = 0; i < nSize * 2; i++)
	{
		int intOut = pBuffer[i];
		if (intOut == 0x0a && pBuffer[i - 2] != 0x0d)
		{
			ros.put(0x0d);
			ros.put(0x0);
		}
		ros.put(intOut);
	}
	
	return ros;
#endif

}

// Hex flavor not tested for non-unicode.
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << l;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << l;
	}
#else

	t_string tsTemp;
	t_strstream strStream;
	
	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << l;
	}
	else
	{
		strStream << l;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64)
{
	ULONG *lArray = (ULONG *) &ul64;
	PutAULONGVar( ros, lArray[0], true);
	PutAULONGVar( ros, lArray[1], true);
	return ros;
}

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex)
{
#ifndef _UNICODE
	if (bHex)
	{
		TCHAR f = ros.fill(_T('0'));
		int w = ros.width(8);
		int fl =	ros.flags(ros.flags() | ios_base::right);
		ros << hex << ul;
		ros.fill(f);
		ros.width(w);
		ros.flags(fl);

		return ros << dec;
	}
	else
	{
		return ros << ul;
	}
#else

	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}

t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw)
{
#ifndef _UNICODE
	TCHAR f = ros.fill(_T('0'));
	int w = ros.width(8);
	int fl =	ros.flags(ros.flags() | ios_base::right);
	ros << hex << dw;
	ros.fill(f);
	ros.width(w);
	ros.flags(fl);

	return ros << dec;
#else

	t_string tsTemp;
	t_strstream strStream;
	
	strStream.width(8);
	strStream.fill('0');
	strStream.flags(ios_base::right);
	strStream << hex << dw;
	
	strStream >> tsTemp;

	PutALine(ros, tsTemp.c_str() , -1);

	return ros;
#endif
}


void InitializeGUIDVar(t_string &rtsValue , void *pVar)
{
	GUID *pGUID = reinterpret_cast<GUID *> (pVar);
	if (rtsValue.length() > 0 && case_insensitive_compare(rtsValue,_T("@#$NA")) != 0)
	{
		wGUIDFromString(rtsValue.c_str(), pGUID);
	}
	else
	{
		RtlZeroMemory(pGUID, sizeof(GUID));
	}


}

// *** Following routine copied from WMI\MofCheck. to convert 
// a guid string to a GUID. 
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------

BOOL HexStringToDword(LPCTSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
    if (*lpsz == '{' )
        lpsz++;
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

int case_insensitive_compare(t_string &r1, t_string &r2)
{

	t_string tsTemp1;
	t_string tsTemp2;
	tsTemp1 = r1.c_str();
	tsTemp2 = r2.c_str();

	int i;
	for (i = 0; i < tsTemp1.length(); i++)
	{
		tsTemp1.replace(i,1,1, toupper(tsTemp1[i]));
	}

	for (i = 0; i < tsTemp2.length(); i++)
	{
		tsTemp2.replace(i,1,1, toupper(tsTemp2[i]));
	}

	return tsTemp1.compare(tsTemp2);
}

int case_insensitive_compare(TCHAR *p, t_string &r2)
{ 
	if (p == NULL)
	{
		return -1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(tsTemp, r2);
}

int case_insensitive_compare(t_string &r1,TCHAR *p )
{ 
	if (p == NULL)
	{
		return 1;
	}

	t_string tsTemp; 
	tsTemp = p; 
	return case_insensitive_compare(r1, tsTemp);
}

int case_insensitive_compare(TCHAR *p1,TCHAR *p2)
{
	if (!p1 && !p2)
	{
		return 0;
	}
	else if (!p1)
	{
		return -1;
	} else if (!p2)
	{
		return 1;
	}

	int l1 = _tcslen(p1);
	int l2 = _tcslen(p2);

	return (_tcsnicmp(p1,p2,_MIN(l1,l2)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\t_string.cpp ===
//////////////////////////////////////////////////////////////////////
// Implementaion of WC to MBCS and MBCS to WC routines that do the 
// right thing if compiled non-UNICODE or UNICODE.
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "t_string.h"

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\structurewrappers.h ===
// StructureWrappers.h: interface for the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CPersistor;
class CEventTraceProperties;

// Need to be declared before seen in class.  Well, duh!
t_ostream& operator<<
	(t_ostream &ros,const CEventTraceProperties &r);
t_istream& operator>>
	(t_istream &ris,CEventTraceProperties &r);


// The general methodology used here may seem clunky to
// a C programmer.  
// If you want to serialize an existing
// EVENT_TRACE_PROPERTIES instance use the Constructor
// "CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)"
// to create a CEventTraceProperties instance, call
// Persist, and then destroy the CEventTraceProperties
// instance.
// If you want to de-deserialize an instance call the 
// Constructor "CEventTraceProperties()", call Persist,
// call GetEventTracePropertiesInstance, then destroy the
// CEventTraceProperties instance.
// The copy constructor and assignment operators are included
// only for completeness and it is anticipated that they
// will not be used.
// Using Persist for de-serialization assumes you have a valid
// stream which contains a serialized instance.   
class CEventTraceProperties 
{
private:
	friend t_ostream& operator<<
		(t_ostream &ros,const CEventTraceProperties &r);
	friend t_istream& operator>>
		(t_istream &ris,CEventTraceProperties &r);
	friend class CPersistor;

public:
	CEventTraceProperties();
	// This constructor creates a new EVENT_TRACE_PROPERTIES 
	// instance.
	CEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	virtual ~CEventTraceProperties();

	CEventTraceProperties(CEventTraceProperties &rhs);
	CEventTraceProperties &CEventTraceProperties::operator=
					(CEventTraceProperties &rhs);

	virtual HRESULT Persist (CPersistor &rPersistor);
	bool DeSerializationOK() {return m_bDeSerializationOK;}

	// Constructs an new EVENT_TRACE_PROPERTIES instance and
	// returns it.
	PEVENT_TRACE_PROPERTIES GetEventTracePropertiesInstance();
	bool IsNULL() {return m_bIsNULL;}

protected:
	bool m_bDeSerializationOK;
	bool m_bIsNULL;
	void Initialize(PEVENT_TRACE_PROPERTIES pProps);
	void InitializeMemberVar(TCHAR *ptszValue, int nVar);
	void *m_pVarArray[19];


	PEVENT_TRACE_PROPERTIES m_pProps;



};

#endif // !defined(AFX_STRUCTUREWRAPPERS_H__138A24E0_ED34_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\structurewapperhelpers.h ===
// StructureWapperHelpers.h
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)

#define AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

void LogFileModeOut(t_ostream &ros, ULONG LogFileMode);
void EnableFlagsOut(t_ostream &ros, ULONG EnableFlags);
void WnodeFlagsOut(t_ostream &ros, ULONG WnodeFlags);
void GUIDOut(t_ostream &ros, GUID Guid);
void LARGE_INTEGEROut(t_ostream &ros, LARGE_INTEGER Large);

void InitializeTCHARVar(t_string &rtsValue , void *pVar);
void InitializeEnumVar(t_string &rtsValue , void *pVar);
void InitializeHandleVar(t_string &rtsValue , void *pVar);
void InitializeULONGVar(t_string &rtsValue , void *pVar, bool bHex = false);
void InitializeLONGVar(t_string &rtsValue , void *pVar);
void InitializeGUIDVar(t_string &rtsValue , void *pVar);

t_istream &GetALine(t_istream &ris,TCHAR *tcBuffer, int nBufferSize);
t_ostream &PutALine(t_ostream &ros,const TCHAR *tcBuffer, int nBufferSize = -1);

t_istream &GetAChar(t_istream &ris,TCHAR &tc);

t_ostream &PutAULONGVar(t_ostream &ros, ULONG ul, bool bHex = false);
t_ostream &PutALONGVar(t_ostream &ros, LONG l, bool bHex = false);
t_ostream &PutADWORDVar(t_ostream &ros, DWORD dw);
t_ostream &PutAULONG64Var(t_ostream &ros, ULONG64 ul64);

BOOL wGUIDFromString(LPCTSTR lpsz, LPGUID pguid);

int case_insensitive_compare(t_string &r1, t_string &r2);
int case_insensitive_compare(TCHAR *p, t_string &r2);
int case_insensitive_compare(t_string &r1,TCHAR *p );
int case_insensitive_compare(TCHAR *p1,TCHAR *p2);





#endif // !defined(AFX_STRUCTUREWAPPERHELPERS_H__A349C060_ED4F_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\umprovider.cpp ===
#define MAX_STR 256
#define MAX_GUIDS 10

#define _UNICODE
#define UNICODE

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>

/*

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>
using namespace std;
#include <malloc.h>
#include <windows.h>


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
*/
#include "struct.h"
#include "utils.h"
#include "Readfile.h"
#include "umprovider.h"





TRACEHANDLE LoggerHandle = (TRACEHANDLE) 2;
ULONG TraceEventFlag = 0, EnableLevel = 0, EnableFlags = 0;
ULONG LoggerEnableLevel, LoggerEnableFlag;
ULONG TraceMode;
ULONG DataBlockSize = 0;
ULONG TraceEventInstanceFlag = 0;
PREGISTER_TRACE_GUID RegisterTraceGuid;
GUID TransactionGuid[12] =  {	{ 0xa7301ec8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa8558716, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xa9226a42, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa395d64, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaa8ccfb2, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xaad4563e, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab171816, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab55153a, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xab84c442, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabb210f0, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xabe1bff8, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 },
								{ 0xb01e8dee, 0x1200, 0x11d3, 0x99, 0x06, 0x00, 0xc0, 0x4f, 0x79, 0xb3, 0xf8 } };


typedef struct _BLOCK1 {
    UCHAR                 EventChar;
	ULONG                 EventUlong;
} BLOCK1, *PBLOCK1;

typedef struct _EVENT_BLOCK1 {
    EVENT_TRACE_HEADER    Header;
	BLOCK1                Block1;
} EVENT_BLOCK1, *P_EVENT_BLOCK1;

typedef struct _EVENT_INSTANCE_BLOCK1 {
	EVENT_INSTANCE_HEADER Header;
	UCHAR				  EventChar;
	ULONG				  EventUlong;
} EVENT_INSTANCE_BLOCK1, *P_EVENT_INSTANCE_BLOCK1;

typedef struct _EVENT_BLOCK2 {
	EVENT_TRACE_HEADER Header;
	MOF_FIELD  MofField;
} EVENT_BLOCK2, *P_EVENT_BLOCK2;


BLOCK1 Block1;
EVENT_BLOCK1 EventBlock1;
EVENT_BLOCK2 EventBlock2;
EVENT_INSTANCE_BLOCK1 EventInstanceBlock1;
TRACE_GUID_REGISTRATION TraceGuidReg[MAX_GUIDS];

main(int argc, char* argv[])
{
	LPTSTR CommandFile;
	TRACEHANDLE RegistrationHandle;	
	ULONG Status;
	LPTSTR *commandLine;
	LPGUID pGuid;
	ULONG Count;
	ULONG GuidCount = 0;
	//CLogger *pLoggingInfo;
	LPCTSTR LogFileName;
	LPTSTR *targv;
	int i;
	

	pGuid = (LPGUID ) malloc(MAX_GUIDS * sizeof(GUID));
	CommandFile = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	LogFileName = (LPCTSTR) malloc(sizeof(TCHAR)*MAX_STR);
	targv = (LPTSTR *) malloc(argc*sizeof(LPTSTR));
	for( i = 0; i < argc; i++ )
		targv[i] = (LPTSTR) malloc(sizeof(TCHAR)*MAX_STR);

	SplitCommandLine( GetCommandLine(), targv);
	for( i = 0; i < MAX_GUIDS; i++)
		TraceGuidReg[i].Guid = &TransactionGuid[i];
	Count = 1;
	while ( Count <= (argc-1) )
	{
		if ( !_tcsicmp(targv[Count], _T("-guids") )) 
		{
			Count++;
			if (Count <= argc) 
			{
				ConvertAsciiToGuid( targv[Count], &pGuid[GuidCount]);
				GuidCount++;
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-file") ))
		{
			Count++;
			if ( Count <= argc)
			{
				CommandFile = targv[Count];
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-flag") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableFlag = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-level") ))
		{
			Count++;
			if( Count <= argc)
			{
				LoggerEnableLevel = atoi(argv[Count]);
				Count++;
			}
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-mode") ))
		{
			Count++;
			if( Count <= argc)
			{
				TraceMode = atoi(argv[Count]);
				Count++;
				continue;
			}
		}

		if( !_tcsicmp(targv[Count], _T("-TraceEventInstance") ))
		{
			Count++;
			TraceEventInstanceFlag = 1;
			continue;
		}

		if( !_tcsicmp(targv[Count], _T("-log") ))
		{
			Count++;
			if( Count <= argc )
			{
				//LogFileName = _T(argv[Count]);
				LogFileName = _T("C:\\");
				Count++;
				continue;
			}
		}

		Count++;
		continue;
	}
        
	Count = sizeof(REGISTER_TRACE_GUID);
	RegisterTraceGuid = (PREGISTER_TRACE_GUID ) malloc(sizeof(REGISTER_TRACE_GUID));
	RegisterTraceGuid->ControlGuid  = (LPGUID) malloc(sizeof(GUID));
	RegisterTraceGuid->MofImagePath = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);
	RegisterTraceGuid->MofResourceName = (TCHAR *) malloc (sizeof(TCHAR)*MAX_STR);

	if( RegisterTraceGuid == NULL)
	{
		printf("\nGufooo");
		exit(0);
	}
	InitializeRegisterTraceGuid( RegisterTraceGuid );

	RegisterTraceGuid->UseMofPtrFlag = 0;
	RegisterTraceGuid->UseGuidPtrFlag = 0;
	
	Status = ReadInputFile( CommandFile, RegisterTraceGuid );


	if( RegisterTraceGuid->GuidCount != 0)
		RegisterTraceGuid->GuidCount = GuidCount;
	
	if( RegisterTraceGuid->CallBackFunction != 0)
		RegisterTraceGuid->CallBackFunction = ProviderCallBack;

	if( RegisterTraceGuid->TraceGuidReg != 0 )
		RegisterTraceGuid->TraceGuidReg = ( PTRACE_GUID_REGISTRATION) &TraceGuidReg[0];

	if( RegisterTraceGuid->RegistrationHandle != 0 )
		RegisterTraceGuid->RegistrationHandle = &RegistrationHandle;

	if( RegisterTraceGuid->GuidCount != 0 )
		RegisterTraceGuid->GuidCount = MAX_GUIDS;

	//InitializeLogging( LogFileName, pLoggingInfo);

	//if (pLoggingInfo)
	//{
		//pLoggingInfo->LogTCHAR(_T("\n*******************************************************\n"));
		//pLoggingInfo->LogTCHAR(_T("StartTraceAPI TCO test "));
		//pLoggingInfo->Flush();	
	//}



	Status = RegisterTraceGuids( ProviderCallBack,
								NULL, //Context
								pGuid,
								RegisterTraceGuid->GuidCount,
								RegisterTraceGuid->TraceGuidReg,
								RegisterTraceGuid->MofImagePath,
								RegisterTraceGuid->MofResourceName,
								RegisterTraceGuid->RegistrationHandle );

	if( RegisterTraceGuid->UnRegistrationHandle != 0 )
	{
		Status = UnregisterTraceGuids( (TRACEHANDLE) 0 );
		return;
	}

	if( Status == ERROR_SUCCESS)
	{
		Count = 0;
		do
		{
			if( (TraceEventFlag ) && ( TraceEventInstanceFlag) )
			{
				Status = TraceEventInstances( TraceMode, (Count%10), Count);
				Count++;
			}
			else if (TraceEventFlag)
			{
				Status = TraceEvents( TraceMode, (Count%10), (Count%100));
				Count++;
			}

		}while(1);
		Status = UnregisterTraceGuids( *(RegisterTraceGuid->RegistrationHandle));
	}
}


ULONG ProviderCallBack(WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize,
    PVOID Buffer)
{
	switch (RequestCode )
	{
		case WMI_ENABLE_EVENTS:
		{
			TraceEventFlag = 1;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
			break;
		}
		
		case WMI_DISABLE_EVENTS:
		{
			TraceEventFlag = 0;
			break;
		}
	}
		return 0;
}


void
InitializeRegisterTraceGuid( PREGISTER_TRACE_GUID RegisterTraceGuid )
{
	//Initialize with some random values and then read from the input
	//file. If any of these parameters needs to be tested with 0, 
	//input files will set this as zero.
	if( RegisterTraceGuid )
	{
		RegisterTraceGuid->GuidCount = 0xa5;
		RegisterTraceGuid->CallBackFunction = (PVOID) 0xa5a5a5;
		RegisterTraceGuid->TraceGuidReg = (PTRACE_GUID_REGISTRATION) (0xa5a5a5);
		RegisterTraceGuid->RegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
		RegisterTraceGuid->UnRegistrationHandle = (PTRACEHANDLE) (0xa5a5a5);
	}

}

ULONG
TraceEvents ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;

	switch ( TraceMode )
	{
		case 0 :
		{
			if( RegisterTraceGuid->UseMofPtrFlag != 1)
			{
				EventBlock1.Header.Size = sizeof(EventBlock1);
				ULONG Temp = sizeof(Block1);
				EventBlock1.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock1.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock1.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				EventBlock1.Block1.EventChar = (UCHAR) Count;
				EventBlock1.Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock1);
			}
			else
			{
				EventBlock2.Header.Size = sizeof(EventBlock2);
				EventBlock2.Header.Flags = WNODE_FLAG_USE_MOF_PTR;
				EventBlock2.Header.Guid = TransactionGuid[TraceGuid];
				EventBlock2.Header.Flags |= WNODE_FLAG_TRACED_GUID;
				EventBlock2.MofField.DataPtr = (ULONGLONG) &Block1;
				EventBlock2.MofField.Length = sizeof(BLOCK1);
				if( RegisterTraceGuid->UseGuidPtrFlag == 1)
				{
					EventBlock2.Header.Flags |= WNODE_FLAG_USE_GUID_PTR;
					EventBlock2.Header.GuidPtr = (ULONGLONG) &TransactionGuid[TraceGuid];
				}
				Block1.EventChar = (UCHAR) Count;
				Block1.EventUlong = Count;
				Status = TraceEvent( LoggerHandle, (PEVENT_TRACE_HEADER) &EventBlock2);

			}
			break;
		}
	}
	return Status;

}


ULONG
TraceEventInstances ( ULONG TraceMode, ULONG TraceGuid, ULONG Count)
{
	ULONG Status;
	EVENT_INSTANCE_INFO InstanceInfo;
	switch ( TraceMode )
	{
		case 0 :
		{
			EventInstanceBlock1.Header.Size = sizeof(EventInstanceBlock1);
			EventInstanceBlock1.Header.Flags = WNODE_FLAG_TRACED_GUID;
			if( RegisterTraceGuid->UseMofPtrFlag == 1)
				EventInstanceBlock1.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
			EventInstanceBlock1.EventChar = (UCHAR) Count;
			EventInstanceBlock1.EventUlong = Count;
			Status = CreateTraceInstanceId( TraceGuidReg[TraceGuid].RegHandle,
											&InstanceInfo);
			if( Status == ERROR_SUCCESS )
				Status = TraceEventInstance( LoggerHandle, (PEVENT_INSTANCE_HEADER) &EventBlock1,
											 &InstanceInfo,
											 NULL);
			break;
		}
	}
	return Status;

}

/*
int InitializeLogging( LPCTSTR lpctstrTCOFile,	CLogger *&pLoggingInfo)
{
	HRESULT hr = S_OK;
//	t_string tsError;

	if (lpctstrTCOFile)
	{
		// Open *our* logger file.
		pLoggingInfo = new CLogger(lpctstrTCOFile, false);
		hr = pLoggingInfo->GetOpenStatus();
		if (FAILED (hr))
		{
//			tsError = _T("Could not open detail log file \"");
//			tsError += lpctstrTCOFile;
//			tsError += _T("\".");
			//*plpstrReturnedError = NewTCHAR(tsError.c_str());
			return hr;
		}
	}
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\structurewrappers.cpp ===
// StructureWrappers.cpp: implementation of the CStructureWrappers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"
#include "Utilities.h"

#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h"


//////////////////////////////////////////////////////////////////////
// Wrappers that serialize and de-serialize Event Tracing Data 
// Structures.
//////////////////////////////////////////////////////////////////////
#define MAX_LINE 1024

static TCHAR g_tcNl = _T('\n');
static TCHAR g_tcCR = 0x0d;
static TCHAR g_tcLF = 0x0a;

#ifdef _UNICODE
static TCHAR g_tcDQuote[] = _T("\"");
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#else
static TCHAR g_atcNL[] = {g_tcNl};
static TCHAR g_tcDQuote = _T('"');
#endif

CConstantMap g_ConstantMap;

//////////////////////////////////////////////////////////////////////
// _EVENT_TRACE_PROPERTIES
//////////////////////////////////////////////////////////////////////

CEventTraceProperties::CEventTraceProperties()
{
	m_pProps = NULL;
	m_bIsNULL = true;
}

CEventTraceProperties::CEventTraceProperties
(PEVENT_TRACE_PROPERTIES pProps)
{
	Initialize(pProps);
}

CEventTraceProperties::~CEventTraceProperties()
{
	if (m_pProps)
	{
		free(m_pProps->LogFileName);
		m_pProps->LogFileName = NULL;
		free(m_pProps->LoggerName);
		m_pProps->LoggerName = NULL;
		free(m_pProps);
		m_pProps = NULL;
	}
	m_bIsNULL = true;

}

CEventTraceProperties::CEventTraceProperties(CEventTraceProperties &rhs)
{
	Initialize(rhs.m_pProps);

}

CEventTraceProperties &CEventTraceProperties::operator=
(CEventTraceProperties &rhs)
{
	if ( this != &rhs ) 
	{
    	delete this;
    	
		Initialize(rhs.m_pProps);
    }
    
	return *this;

}
#if 0
"_EVENT_TRACE_PROPERTIES Instance Begin"
"BufferSize:ULONG:32"
"MinimunBuffers:ULONG:2"
"MaximunBuffers:ULONG:3"
"MaximunFileSize:ULONG:4"
"LogFileMode:@#$ENUM:EVENT_TRACE_FILE_MODE_NEWFILE|EVENT_TRACE_REAL_TIME_MODE|@#$UNKNOWNVALUE:0x20"
"FlushTimer:ULONG:6"
"EnableFlags:@#$ENUM:EVENT_TRACE_FLAG_IMAGE_LOAD|EVENT_TRACE_FLAG_DISK_IO|@#$UNKNOWNVALUE:20"
"NumberOfBuffers:ULONG:8"
"FreeBuffers:ULONG:9"
"EventsLost:ULONG:10"
"BuffersWritten:ULONG:11"
"LogBuffersLost:ULONG:12"
"RealTimeBuffersLost:ULONG:13"
"AgeLimit:LONG:-14"
"LoggerThreadId:HANDLE:0000000F"
"LogFileName:TCHAR*:Log file name"
"LoggerName:TCHAR*:Logger name"
"_EVENT_TRACE_PROPERTIES Instance End"
#endif
void CEventTraceProperties::InitializeMemberVar(TCHAR *tcBuffer, int nVar)
{

	int nDebug = 0;
	if (nVar == 17 || nVar == 18)
	{
		nDebug = nVar;
	}

	t_string tsTemp;
	
	tsTemp = tcBuffer;

	int nPos = tsTemp.find(_T(":"), 0);

	// The first character in the type.
	int nPosType = nPos + 1;

	if (nPos == t_string::npos)
	{
		m_bDeSerializationOK = false;
		return;
	}

	nPos = tsTemp.find(_T(":"), nPos + 1);
	
	t_string tsType;

	tsType = tsTemp.substr(nPosType,nPos - nPosType);

	// The first chatacter in the value.
	++nPos;

	t_string tsValue;
	tsValue = tsTemp.substr(nPos, (tsTemp.length() - nPos) - 1);

	// a TCHAR * value
	if (tsType.compare(_T("TCHAR*")) == 0)
	{
		InitializeTCHARVar(tsValue ,m_pVarArray[nVar]);
	}
	// A #define value
	else if (tsType.compare(_T("@#$ENUM")) == 0)
	{
		InitializeEnumVar(tsValue , m_pVarArray[nVar]);
	}
	// A HEX
	else if (tsType.compare(_T("HANDLE")) == 0)
	{
		InitializeHandleVar(tsValue , m_pVarArray[nVar]);
	}
	// An unsigned value
	else if (tsType.compare(_T("ULONG")) == 0)
	{
		InitializeULONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("LONG")) == 0)
	{
		InitializeLONGVar(tsValue , m_pVarArray[nVar]);
	}
	// A long value
	else if (tsType.compare(_T("GUID")) == 0)
	{
		InitializeGUIDVar(tsValue , m_pVarArray[nVar]);
	}

}

void CEventTraceProperties::Initialize
(PEVENT_TRACE_PROPERTIES pProps)
{
	m_bDeSerializationOK = true;
	if (pProps == NULL)
	{
		m_pProps = NULL;
		m_bIsNULL = true;
	}

	m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(m_pProps, sizeof(EVENT_TRACE_PROPERTIES));
	*m_pProps = *pProps;
	
	m_pProps -> LogFileName = pProps -> LogFileName ? 
								NewTCHAR(pProps -> LogFileName) :
								NULL;
	m_pProps -> LoggerName = pProps -> LoggerName ?
								NewTCHAR(pProps -> LoggerName) :
								NULL;

	m_pProps -> Wnode.BufferSize = sizeof(*m_pProps);

	m_bIsNULL = false;

}

PEVENT_TRACE_PROPERTIES 
CEventTraceProperties::GetEventTracePropertiesInstance()
{
	if (m_pProps == NULL)
	{
		return NULL;
	}

	EVENT_TRACE_PROPERTIES *pProps = 
		(EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(pProps, sizeof(EVENT_TRACE_PROPERTIES));

	*pProps = *m_pProps;
	
	pProps -> LogFileName = m_pProps -> LogFileName ? 
								NewTCHAR(m_pProps -> LogFileName) :
								NULL;
	pProps -> LoggerName = m_pProps -> LoggerName ?
								NewTCHAR(m_pProps -> LoggerName) :
								NULL;
	int n1 = sizeof(*pProps);
	int n2 = sizeof(EVENT_TRACE_PROPERTIES);

	pProps -> Wnode.BufferSize = sizeof(*pProps);
	
	return pProps;
}

HRESULT CEventTraceProperties::Persist (CPersistor &rPersistor)
{
	if (rPersistor.IsLoading())
	{
		rPersistor.Stream() >> *this;
	}
	else
	{
		rPersistor.Stream() << *this;
	}

	return S_OK;

}

t_ostream& operator<<(t_ostream &ros, const CEventTraceProperties &r)
{
	t_string tsOut;

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"\n");
	PutALine(ros, tsOut.c_str());

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	tsOut = _T("\"Wnode.Guid:GUID:");
	PutALine(ros, tsOut.c_str());
	GUIDOut(ros, r.m_pProps -> Wnode.Guid);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	WnodeFlagsOut(ros, r.m_pProps -> Wnode.Flags);

	tsOut = _T("\"BufferSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BufferSize);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MinimunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MinimumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumBuffers);
	tsOut = g_tcDQuote;
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"MaximunFileSize:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> MaximumFileSize);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	LogFileModeOut(ros, r.m_pProps -> LogFileMode );

	tsOut = _T("\"FlushTimer:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FlushTimer);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	EnableFlagsOut(ros,r.m_pProps -> EnableFlags);

//	ros << _T("\"NumberOfBuffers:ULONG:") << r.m_pProps -> NumberOfBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"NumberOfBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> NumberOfBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"FreeBuffers:ULONG:") << r.m_pProps -> FreeBuffers << g_tcDQuote << g_atcNL;

	tsOut = _T("\"FreeBuffers:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> FreeBuffers);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"EventsLost:ULONG:") << r.m_pProps -> EventsLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"EventsLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> EventsLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"BuffersWritten:ULONG:") << r.m_pProps -> BuffersWritten << g_tcDQuote << g_atcNL;

	tsOut = _T("\"BuffersWritten:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> BuffersWritten);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogBuffersLost:ULONG:") << r.m_pProps -> LogBuffersLost << g_tcDQuote << g_atcNL;

	tsOut = _T("\"LogBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> LogBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());


//	ros << _T("\"RealTimeBuffersLost:ULONG:") << r.m_pProps -> RealTimeBuffersLost << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"RealTimeBuffersLost:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, r.m_pProps -> RealTimeBuffersLost);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());
	
	
//	ros << _T("\"AgeLimit:LONG:") << r.m_pProps -> AgeLimit << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"AgeLimit:ULONG:");
	PutALine(ros, tsOut.c_str());
	PutALONGVar(ros, r.m_pProps -> AgeLimit);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	// Handles are in hex.
//	ros << _T("\"LoggerThreadId:HANDLE:0x") << r.m_pProps -> LoggerThreadId << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerThreadId:HANDLE:0x");
	PutALine(ros, tsOut.c_str());
	PutAULONGVar(ros, (ULONG) r.m_pProps -> LoggerThreadId, true);
	tsOut = g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LogFileName:TCHAR*:") << r.m_pProps -> LogFileName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LogFileName:TCHAR*:");
	if (r.m_pProps -> LogFileName)
	{
		tsOut += r.m_pProps -> LogFileName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

//	ros << _T("\"LoggerName:TCHAR*:") << r.m_pProps -> LoggerName << g_tcDQuote <<g_atcNL;

	tsOut = _T("\"LoggerName:TCHAR*:");
	if (r.m_pProps -> LoggerName)
	{
		tsOut += r.m_pProps -> LoggerName;
	}
	tsOut += g_tcDQuote; 
	tsOut += g_atcNL;
	PutALine(ros, tsOut.c_str());

	tsOut = _T("\"_EVENT_TRACE_PROPERTIES Instance End\"\n");
	PutALine(ros, tsOut.c_str());

	return ros;
}

t_istream& operator>>(t_istream &ris,CEventTraceProperties &r)
{
	r.m_bDeSerializationOK = true;

	// We are doing line oriented serailization and assume that
	// a line in the stream is 1024 or less TCHARS.
	TCHAR *ptcBuffer = (TCHAR *) malloc(MAX_LINE * sizeof(TCHAR));

	GetALine(ris, ptcBuffer,MAX_LINE);


	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance NULL\"")) == 0)
	{
		r.~CEventTraceProperties();
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);
		return ris;
	}

	if (_tcscmp(ptcBuffer,_T("\"_EVENT_TRACE_PROPERTIES Instance Begin\"")) != 0)
	{
		r.m_bDeSerializationOK = false;

		free(ptcBuffer);

		return ris;
	}

	r.~CEventTraceProperties();

	r.m_pProps = (EVENT_TRACE_PROPERTIES *) malloc (sizeof(EVENT_TRACE_PROPERTIES));
	RtlZeroMemory(r.m_pProps, sizeof(EVENT_TRACE_PROPERTIES));

	r.m_pProps->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);

// "Wnode.Guid:GUID:{0000cbd1-0011-11d0-0d00-00aa006d010a}"
// "Wnode.Flags:@#$ENUM:WNODE_FLAG_ALL_DATA"

	r.m_pVarArray[0] = &r.m_pProps->Wnode.Guid;
	r.m_pVarArray[1] = &r.m_pProps->Wnode.Flags;
	r.m_pVarArray[2] = &r.m_pProps->BufferSize;
	r.m_pVarArray[3] = &r.m_pProps->MinimumBuffers;
	r.m_pVarArray[4] = &r.m_pProps->MaximumBuffers;
	r.m_pVarArray[5] = &r.m_pProps->MaximumFileSize;
	r.m_pVarArray[6] = &r.m_pProps->LogFileMode;
	r.m_pVarArray[7] = &r.m_pProps->FlushTimer;
	r.m_pVarArray[8] = &r.m_pProps->EnableFlags;
	r.m_pVarArray[9] = &r.m_pProps->NumberOfBuffers;
	r.m_pVarArray[10] = &r.m_pProps->FreeBuffers;
	r.m_pVarArray[11] = &r.m_pProps->EventsLost;
	r.m_pVarArray[12] = &r.m_pProps->BuffersWritten;
	r.m_pVarArray[13] = &r.m_pProps->LogBuffersLost;
	r.m_pVarArray[14] = &r.m_pProps->RealTimeBuffersLost;
	r.m_pVarArray[15] = &r.m_pProps->AgeLimit;
	r.m_pVarArray[16] = &r.m_pProps->LoggerThreadId;
	r.m_pVarArray[17] = &r.m_pProps->LogFileName;
	r.m_pVarArray[18] = &r.m_pProps->LoggerName;


	int n = 0;
	while (n < 19 && GetALine(ris,ptcBuffer,MAX_LINE))
	{
		r.InitializeMemberVar(ptcBuffer,n++);
	}

	// Consume end of Props
	GetALine(ris,ptcBuffer,MAX_LINE);

	free(ptcBuffer);

	BOOL bHeapGood = HeapValidate(GetProcessHeap(), 0, NULL);

	return ris;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\t_string.h ===
// t_string.h: interface for the t_string class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
#define AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifndef t_string

#ifndef _UNICODE
// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled non-UNICODE.
#define t_string string
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout cout
#define t_cin cin
#define t_strstream strstream
#define t_strstreambuf strstreambuf
#define t_ctime ctime
#define t_cerr cerr

#else

// Definitions for WC to MBCS and MBCS to WC routines that do the right thing
// if compiled UNICODE.
#define t_string wstring
#define t_fstream fstream
#define t_istream istream
#define t_ostream ostream
#define t_cout wcout
#define t_cin wcin
#define t_strstream wstringstream
#define t_strstreambuf wstrstreambuf
#define t_ctime _wctime
#define t_cerr wcerr

#endif

#endif

// We do not need conversion routines if compiling under UNICODE
#define mbsrtowcs t_mbsrtowcs


#endif // !defined(AFX_T_STRING_H__32BF27CE_EAD9_11D2_9C53_00A0249F63EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\utilities.h ===
// Utilities.h: interface for the CUtilities class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

TCHAR *NewTCHAR(const TCHAR *ptcToCopy);

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy);

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy);

LPTSTR DecodeStatus(IN ULONG Status);

int GetFileList(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList);

BOOL IsAdmin();  // From Q118626

LPTSTR LPTSTRFromGuid(GUID Guid);

t_string ULONGVarToTString(ULONG ul, bool bHex);

#endif // !defined(AFX_UTILITIES_H__C37E8DD0_ED3E_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\utilities.cpp ===
// Utilities.cpp: implementation of the CUtilities class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)


#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>

using namespace std;

#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <malloc.h>

#include <WTYPES.H>
#include "t_string.h"
#include <tchar.h>
#include <list>


#include "Persistor.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Utilities.h"

#define MAX_STR 1024

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

TCHAR *NewTCHAR(const TCHAR *ptcToCopy)
{
	if (ptcToCopy == NULL)
	{
		return NULL;
	}

	// This is a gross hack.  Need to pin down heap corruption.
	int nString = _tcsclen(ptcToCopy) + 100;
	int nTCHAR = sizeof(TCHAR);

	int nLen = nString * (nTCHAR); 

	TCHAR *pNew = (TCHAR*) malloc(nLen);

	_tcscpy(pNew,ptcToCopy);

	return pNew;
}

LPSTR NewLPSTR(LPCWSTR lpwstrToCopy)
{
	int nLen = (wcslen(lpwstrToCopy) + 1) * sizeof(WCHAR);
	LPSTR pNew = (char *)malloc( nLen );
   
	wcstombs(pNew, lpwstrToCopy, nLen);

	return pNew;
}

LPWSTR NewLPWSTR(LPCSTR lpstrToCopy)
{
	int nLen = (strlen(lpstrToCopy) + 1);
	LPWSTR pNew = (WCHAR *)malloc( nLen  * sizeof(WCHAR));
	mbstowcs(pNew, lpstrToCopy, nLen);

	return pNew;

}

LPTSTR DecodeStatus(IN ULONG Status)
{
	LPTSTR lptstrError = (LPTSTR) malloc (MAX_STR);

    memset( lptstrError, 0, MAX_STR );

    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        lptstrError,
        MAX_STR,
        NULL );

	for (int i = 0; i < MAX_STR; i++)
	{
		if (lptstrError[i] == 0x0d)
		{
			lptstrError[i] = _T('\0');
			break;
		}
	}

    return lptstrError;
}

int GetFileList
(LPTSTR lptstrPath, LPTSTR lptstrFileType, list<t_string> &rList)
{
	t_string tsFind;

	tsFind = lptstrPath;
	tsFind += _T("\\");
	tsFind += lptstrFileType;


	WIN32_FIND_DATA wfdFile;
	HANDLE hFindHandle = 
		FindFirstFile(tsFind.c_str(), &wfdFile);

	if (hFindHandle == INVALID_HANDLE_VALUE)
	{
		return HRESULT_FROM_WIN32(GetLastError()); 
	}

	if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
	{
		tsFind = lptstrPath;
		tsFind += _T("\\");
		tsFind += wfdFile.cFileName;
		rList.push_back(tsFind);
		tsFind.erase();
	}

	while (FindNextFile(hFindHandle, &wfdFile))
	{
		if ((_tcscmp(wfdFile.cFileName,_T(".")) != 0) &&
			(_tcscmp(wfdFile.cFileName,_T("..")) != 0))
		{
			tsFind = lptstrPath;
			tsFind += _T("\\");
			tsFind += wfdFile.cFileName;
			rList.push_back(tsFind);
			tsFind.erase();
		}
	}

	FindClose(hFindHandle);

	return ERROR_SUCCESS;
} 

// From Q 118626
BOOL IsAdmin()
{
  HANDLE hAccessToken;
  UCHAR InfoBuffer[1024];
  PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
  DWORD dwInfoBufferSize;
  PSID psidAdministrators;
  SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
  UINT x;
  BOOL bSuccess;

  if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
	 &hAccessToken )) {
	 if(GetLastError() != ERROR_NO_TOKEN)
		return FALSE;
	 //
	 // retry against process token if no thread token exists
	 //
	 if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
		&hAccessToken))
		return FALSE;
  }

  bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
	 1024, &dwInfoBufferSize);

  CloseHandle(hAccessToken);

  if(!bSuccess )
	 return FALSE;

  if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
	 SECURITY_BUILTIN_DOMAIN_RID,
	 DOMAIN_ALIAS_RID_ADMINS,
	 0, 0, 0, 0, 0, 0,
	 &psidAdministrators))
	 return FALSE;

// assume that we don't find the admin SID.
  bSuccess = FALSE;

  for(x=0;x<ptgGroups->GroupCount;x++)
  {
	 if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
	 {
		bSuccess = TRUE;
		break;
	 }

  }
  FreeSid(psidAdministrators);
  return bSuccess;
}

t_string GUIDToTString(GUID Guid)
{
	t_strstream strStream;
	t_string tsOut;

	strStream << _T("{");
	
	strStream.fill(_T('0'));
	strStream.width(8);
	strStream.flags(ios_base::right);

	strStream << hex << Guid.Data1;

	strStream << _T("-");

	strStream.width(4);

	strStream << hex << Guid.Data2;

	strStream << _T("-");

	strStream << hex << Guid.Data3;

	strStream << _T("-");

	// Data4 specifies an array of 8 bytes. The first 2 bytes contain 
	// the third group of 4 hexadecimal digits. The remaining 6 bytes 
	// contain the final 12 hexadecimal digits. 

#ifndef _UNICODE
	int i;

	strStream.width(1);

	BYTE Byte;
	int Int;
	for (i = 0; i < 2; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream <<  hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}

	strStream << _T("-");

	strStream.width(1);


	for (i = 2; i < 8; i++)
	{
		BYTE Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		Int = Byte;
		strStream << hex << Int;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		Int = Byte;
		strStream << hex << Int;
	}
#else
	int i;

	for (i = 0; i < 2; i++)
	{
		TCHAR tc = Guid.Data4[i];
		// For some reason the width is reset each time through the 
		// loop to be one.
		strStream.width(2);
		strStream << hex << tc;
	}

	strStream << _T("-");
	
	BYTE Byte;
	strStream.width(1);
	for (i = 2; i < 8; i++)
	{
		Byte = Guid.Data4[i];
		Byte = Byte >> 4;
		strStream << hex << Byte;
		Byte = Guid.Data4[i];
		Byte = 0x0f & Byte;
		strStream << hex << Byte;
	}
#endif

	strStream << _T("}");

	strStream >> tsOut;

	return tsOut;
}

LPTSTR LPTSTRFromGuid(GUID Guid)
{
	t_string tsGuid = GUIDToTString(Guid);
	return NewTCHAR(tsGuid.c_str());
}

t_string ULONGVarToTString(ULONG ul, bool bHex)
{
	t_string tsTemp;
	t_strstream strStream;

	if (bHex)
	{
		strStream.width(8);
		strStream.fill('0');
		strStream.flags(ios_base::right);
		strStream << hex << ul;
	}
	else
	{
		strStream << ul;
	}

	strStream >> tsTemp;

	if (bHex)
	{
		t_string tsHex;
		tsHex = _T("0x");
		tsHex += tsTemp;
		return tsHex;
	}
	else
	{
		return tsTemp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\utils.h ===
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>

ULONG ahextoi( TCHAR *s);

void RemoveComment( TCHAR *String);
void ConvertAsciiToGuid( TCHAR *String, LPGUID Guid);
void SplitCommandLine( LPTSTR CommandLine, LPTSTR* pArgv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\umtrprov\utils.cpp ===
#include "utils.h"
#include "struct.h"
#include "Readfile.h"
ULONG ahextoi( TCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void RemoveComment( TCHAR *String)
{
	ULONG i = 0;

	while( String[i] != 0 )
	{
		if( String[i] == '/' )
		{
			String[i] = 0;
			break;
		}
		i++;
	}
}

void
ConvertAsciiToGuid( TCHAR* arg, LPGUID Guid)
{

	ULONG i;
	TCHAR Temp[MAX_STR];

	_tcsncpy(Temp, arg, 37);
	Temp[8] = 0;
	Guid->Data1 = ahextoi(Temp);

	_tcsncpy(Temp, &arg[9], 4);
	Temp[4] = 0;
	Guid->Data2 = (USHORT) ahextoi(Temp);

	_tcsncpy(Temp, &arg[14], 4);
	Temp[4] = 0;
	Guid->Data3 = (USHORT) ahextoi(Temp);
		

	for (i=0; i<2; i++) 
	{
		_tcsncpy(Temp, &arg[19 + (i*2)], 2);
        Temp[2] = 0;
        Guid->Data4[i] = (UCHAR) ahextoi(Temp);
    }
    for (i=2; i<8; i++) 
	{
		_tcsncpy(Temp, &arg[20 + (i*2)], 2);
        Temp[2] = 0;
        Guid->Data4[i] = (UCHAR) ahextoi(Temp);
    }

}



void
SplitCommandLine( 
    LPTSTR CommandLine, 
    LPTSTR* pArgv 
    )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg); 
        arg = _tcstok(NULL, _T(" \t"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\trace.net\assemblyinfo.cs ===
using System.Reflection;

[assembly:AssemblyVersion("1.0.0.0")]
[assembly:AssemblyKeyFileAttribute("trace.snk")]
[assembly:System.CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wbemlib\cimmap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cimmap.cpp
//
//
//  This file contains routines that will establish a mapping between
//  Wdm class instances and Cdm class instances. See
//  MapWdmClassToCimClass for more information.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wbemidl.h>

#include "debug.h"
#include "wbemmisc.h"
#include "useful.h"
#include "cimmap.h"

HRESULT WdmInstanceNameToPnPId(
    IWbemServices *pWdmServices,
    BSTR WdmInstanceName,
    VARIANT /* FREE */ *PnPId
    )
/*+++

Routine Description:

	This routine will convert a Wdm instance name into its
	corresponding pnp id
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace 

	WdmInstanceName

	*PnPId returns with the pnp id
		
Return Value:

    HRESULT

---*/
{
	WCHAR Query[2 * MAX_PATH];
	WCHAR s[MAX_PATH];
	BSTR sQuery;
	HRESULT hr;
	IEnumWbemClassObject *pWdmEnumInstances;
	IWbemClassObject *pWdmInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(PnPId != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		//
		// First get PnP id from Instance name from the MSWmi_PnPDeviceId
		// class (select * from MSWMI_PnPDeviceId where InstanceName =
		// "<WdmInstanceName>"
		//
		wsprintfW(Query,
				L"select * from MSWmi_PnPDeviceId where InstanceName = \"%ws\"",
				AddSlashesToStringW(s, WdmInstanceName));
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = pWdmServices->ExecQuery(sWQL,
									sQuery,
									WBEM_FLAG_FORWARD_ONLY |
									WBEM_FLAG_ENSURE_LOCATABLE,
									NULL,
									&pWdmEnumInstances);

			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pWdmEnumInstances->Next(WBEM_INFINITE,
											  1,
											  &pWdmInstance,
											  &Count);
				if ((hr == WBEM_S_NO_ERROR) &&
					(Count == 1))
				{
					hr = WmiGetProperty(pWdmInstance,
										L"PnPDeviceId",
										CIM_STRING,
										PnPId);

					pWdmInstance->Release();
				}

				pWdmEnumInstances->Release();
			} else {
				WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								sQuery, hr));
			}
			
			SysFreeString(sQuery);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}

		SysFreeString(sWQL);
	} else {
		hr  = WBEM_E_OUT_OF_MEMORY;
	}

	return(hr);
}

HRESULT FindCimClassByWdmInstanceName(
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR CimClassName,
    IN BSTR WdmInstanceName,
    OUT BSTR *PnPId,
    OUT BSTR /* FREE */ *CimRelPath
    )
/*+++

Routine Description:

	This routine will find the Cim class instance that corresponds to a
	particular Wdm class instance
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace
	
	pCdmServices is the pointer to the root\cimv2 namespace 

	CimClassName is the name of the cim class that the wdm instance
		would map to
		
	WdmInstanceName

    *PnPId returns with the PnP id for the device stack
    
	*CimRelPath returns with the relpath for the Cim instance
		
Return Value:

    HRESULT

---*/
{
	HRESULT hr;
	VARIANT v;
	IEnumWbemClassObject *pCimEnumInstances;
	IWbemClassObject *pCimInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(CimRelPath != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{

		// ****************************************************************
		// Note: Net cards need to do something similar. We get the
		// netcard address in class MSNDIS_???? and then get the CIM class
		// by matching the netcard addresses.
		// ****************************************************************
		
		//
		// First thing is to convert from an instance name to a pnpid
		//
		hr = WdmInstanceNameToPnPId(pWdmServices,
									WdmInstanceName,
									&v);

		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Next select * from CimClassName where PnPDeviceId = "<PnPDevice
			// Id from above>".
			//
			WCHAR Query[2 * MAX_PATH];
			WCHAR s[MAX_PATH];
			BSTR sQuery;

			wsprintfW(Query,
					  L"select * from %ws where PnPDeviceId = \"%ws\"",
					  CimClassName,
					  AddSlashesToStringW(s, v.bstrVal));
			*PnPId = v.bstrVal;

			sQuery = SysAllocString(Query);

			if (sQuery != NULL)
			{
				hr = pCimServices->ExecQuery(sWQL,
										sQuery,
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_ENSURE_LOCATABLE,
										NULL,
										&pCimEnumInstances);

				SysFreeString(sQuery);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = pCimEnumInstances->Next(WBEM_INFINITE,
												  1,
												  &pCimInstance,
												  &Count);
					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1))
					{

						//
						// Finally grab the relpath from cim class and we're done
						//

						hr = WmiGetProperty(pCimInstance,
											L"__RELPATH",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							*CimRelPath = SysAllocString(v.bstrVal);
							if (*CimRelPath == NULL)
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
							
							VariantClear(&v);
						}

						pCimInstance->Release();
					}

					pCimEnumInstances->Release();
				} else {
					WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								Query, hr));
				}

			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}		
		}
		
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}


	return(hr);
}

HRESULT GetEnumCount(
    IN IEnumWbemClassObject *pEnumInstances,
	OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will return the count of instances in the enumeration
        
Arguments:

	pEnumInstance is the instance enumerator

	*RelPathCount returns the number of instances in the enumeration
		
Return Value:

    HRESULT

---*/
{
	ULONG Count;
	HRESULT hr;
	IWbemClassObject *pInstance;

	WmipAssert(pEnumInstances != NULL);
	WmipAssert(RelPathCount != NULL);
	
	*RelPathCount = 0;
	do
	{
		hr = pEnumInstances->Next(WBEM_INFINITE,
									 1,
									 &pInstance,
									 &Count);

		if ((hr == WBEM_S_NO_ERROR) &&
			(Count == 1))
		{
			(*RelPathCount)++;
			pInstance->Release();
		} else {
			if (hr == WBEM_S_FALSE)
			{
				hr = WBEM_S_NO_ERROR;
			}
			break;
		}
	} while (TRUE);
	
	return(hr);
}

HRESULT AllocateBstrArrays(
    ULONG Size,
    CBstrArray *WdmRelPaths,
    CBstrArray *CimRelPaths,
    CBstrArray *WdmInstanceNames,
    CBstrArray *PnPDeviceIds,
    CBstrArray *FriendlyName,
    CBstrArray *DeviceDesc
    )
{
	HRESULT hr;

	hr = WdmRelPaths->Initialize(Size);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = CimRelPaths->Initialize(Size);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = WdmInstanceNames->Initialize(Size);
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = PnPDeviceIds->Initialize(Size);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = FriendlyName->Initialize(Size);
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = DeviceDesc->Initialize(Size);
					}
				}
			}
		}
	}

	//
	// We don't worry about cleaning up in the case of a failure since
	// the destructors for CBstrArray will take care of that for us
	//
	
	return(hr);
}
						   
HRESULT GetDeviceProperties(
    IN IWbemContext *pCtx,
    IN IWbemServices *pWdmServices,
	IN PWCHAR InstanceName,
    OUT BSTR *FriendlyName,
    OUT BSTR *DeviceDesc
    )
{
	HRESULT hr, hrDontCare;
	VARIANT v;
	IWbemClassObject *pInstance;
	
	WmipAssert(pWdmServices != NULL);
	WmipAssert(InstanceName != NULL);
	WmipAssert(FriendlyName != NULL);
	WmipAssert(DeviceDesc != NULL);
	
	hr = GetInstanceOfClass(pCtx,
		                    pWdmServices,
							L"MSWmi_ProviderInfo",
							L"InstanceName",
							InstanceName,
							NULL,
							&pInstance);
	
	if (hr == WBEM_S_NO_ERROR)
	{
		hrDontCare = WmiGetProperty(pInstance,
							L"FriendlyName",
							CIM_STRING,
							&v);
		if (hrDontCare == WBEM_S_NO_ERROR)
		{
			*FriendlyName = v.bstrVal;
		} else {
			*FriendlyName = NULL;
		}

		hrDontCare = WmiGetProperty(pInstance,
							L"Description",
							CIM_STRING,
							&v);
		if (hrDontCare == WBEM_S_NO_ERROR)
		{
			*DeviceDesc = v.bstrVal;
		} else {
			*DeviceDesc = NULL;
		}

		pInstance->Release();
	}

	return(hr);
}


HRESULT MapWdmClassToCimClassViaPnpId(
    IWbemContext *pCtx,
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR WdmClassName,
    IN BSTR CimClassName,
    OUT CBstrArray *PnPDeviceIds,							  
    OUT CBstrArray *FriendlyName,							  
    OUT CBstrArray *DeviceDesc,							  
    OUT CBstrArray *WdmInstanceNames,							  
    OUT CBstrArray *WdmRelPaths,
    OUT CBstrArray *CimRelPaths,
    OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will perform a mapping between the instances of WDM
	classes and Cim Classes
        
Arguments:

	pWdmServices

	pCdmServices

	WdmClassName

	CimClassName

	*PnPDeviceIds return with the an array of PnP device ids

	*WdmInstanceNames returns with an array of Wdm instnace names

	*WdmRelPaths returns with an array of relpaths to Wdm instances

	*CimRelpaths returns with an array of relapaths to Cim instance

	*RelPathCount returns with the count of instances that are mapped
	
Return Value:

    HRESULT

---*/
{
	IWbemClassObject *pWdmInstance;
	IEnumWbemClassObject *pWdmEnumInstances;
	HRESULT hr;
	int i, NumberWdmInstances;
	VARIANT v;
	ULONG Count;
	BSTR bstr1, bstr2;
	BSTR f,d;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(WdmClassName != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(RelPathCount != NULL);
	WmipAssert((PnPDeviceIds != NULL) && ( ! PnPDeviceIds->IsInitialized()));
	WmipAssert((FriendlyName != NULL) && ( ! FriendlyName->IsInitialized()));
	WmipAssert((DeviceDesc != NULL) && ( ! DeviceDesc->IsInitialized()));
	WmipAssert((WdmInstanceNames != NULL) && (! WdmInstanceNames->IsInitialized()));
	WmipAssert((WdmRelPaths != NULL) && ( ! WdmRelPaths->IsInitialized()));
	WmipAssert((CimRelPaths != NULL) && ( ! CimRelPaths->IsInitialized()));

	//
	// Get all instances of the Wdm Class
	//
	hr = pWdmServices->CreateInstanceEnum(WdmClassName,
										  WBEM_FLAG_USE_AMENDED_QUALIFIERS |
										  WBEM_FLAG_SHALLOW,
										  NULL,
										  &pWdmEnumInstances);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = GetEnumCount(pWdmEnumInstances,
						  RelPathCount);

		NumberWdmInstances = *RelPathCount;
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = Alloc