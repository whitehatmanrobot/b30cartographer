 if (dwAccess & MQ_SEND_ACCESS)
    {
        ASSERT(!fJournalQueue);
        dwDesiredAccess |= MQSEC_WRITE_MESSAGE;
    }

    if (dwAccess & MQ_PEEK_ACCESS)
    {
        dwDesiredAccess |= MQSEC_PEEK_MESSAGE;
    }

    return dwDesiredAccess;
}


/***************************************************************************

Function:
    DoDSAccessCheck
    DoDSAccessCheck
    DoPrivateAccessCheck
    DoAdminAccessCheck

Description:
    Helper funcitons for VerifyOpenQueuePremissions

Environment:
    Windows NT only

***************************************************************************/
static
HRESULT
DoDSAccessCheck(
    AD_OBJECT eObject,
    const GUID *pID,
    BOOL fInclSACL,
    BOOL fTryDS,
    LPCWSTR pObjectName,
    DWORD dwDesiredAccess
    )
{
    CQMDSSecureableObject so(eObject, pID, fInclSACL, fTryDS, pObjectName);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 460);
}


static
HRESULT
DoDSAccessCheck(
    AD_OBJECT eObject,
    const GUID *pID,
    PSECURITY_DESCRIPTOR pSD,
    LPCWSTR pObjectName,
    DWORD dwDesiredAccess
    )
{
	if(pSD == NULL)
	{
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 465);
	}

	ASSERT(IsValidSecurityDescriptor(pSD));
    CQMDSSecureableObject so(eObject, pID, pSD, pObjectName);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 470);
}


static
HRESULT
DoPrivateAccessCheck(
    AD_OBJECT eObject,
    ULONG ulID,
    DWORD dwDesiredAccess
    )
{
    CQMSecureablePrivateObject so(eObject, ulID);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 480);
}


static
HRESULT
DoAdminAccessCheck(
    AD_OBJECT eObject,
    const GUID* pID,
    LPCWSTR pObjectName,
    DWORD dwAccessMask,
    DWORD dwDesiredAccess
    )
{
    PSECURITY_DESCRIPTOR pSD = GetAdminGroupSecurityDescriptor(dwAccessMask);

    if(pSD == 0)
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 500);

    HRESULT hr;
    hr = DoDSAccessCheck(eObject, pID, pSD, pObjectName, dwDesiredAccess);
    FreeAdminGroupSecurityDescriptor(pSD);
    return LogHR(hr, s_FN, 510);
}


/***************************************************************************

Function:
    VerifyOpenPermissionRemoteQueue

Description:
    Verify open premissions on non local queues

Environment:
    Windows NT only

***************************************************************************/
static
HRESULT
VerifyOpenPermissionRemoteQueue(
    const CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess
    )
{
    //
    // Check open queue premissions on non local queues only (outgoing)
    //
    HRESULT hr2;

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_DIRECT:
        case QUEUE_FORMAT_TYPE_MULTICAST:
            if(dwAccess & MQ_SEND_ACCESS)
            {
                //
                // We do not check send permissions on remote machines. We say
                // that it's OK. The remote machine will accept or reject the
                // message.
                //
                // System direct queues should have been replaced with machine queues
                // at this stage
                //
                ASSERT(!pQueueFormat->IsSystemQueue());
                return MQ_OK;
            }

            ASSERT(dwAccess & MQ_ADMIN_ACCESS);

            hr2 = DoAdminAccessCheck(
                        eQUEUE,
                        pQueue->GetQueueGuid(),
                        pQueue->GetQueueName(),
                        MQSEC_QUEUE_GENERIC_READ,
                        MQSEC_RECEIVE_MESSAGE);
            return LogHR(hr2, s_FN, 520);


        case QUEUE_FORMAT_TYPE_CONNECTOR:
            if(!IsRoutingServer())  //[adsrv] CQueueMgr::GetMQS() == SERVICE_NONE) - Raphi
            {
                //
                // Connector queue can only be opend on MSMQ servers
                //
                return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 530);
            }

            hr2 = DoDSAccessCheck(
                        eFOREIGNSITE,
                        &pQueueFormat->ConnectorID(),
                        TRUE,
                        TRUE,
                        NULL,
                        MQSEC_CN_OPEN_CONNECTOR);
            return LogHR(hr2, s_FN, 535);

        case QUEUE_FORMAT_TYPE_MACHINE:
        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 540);
    }
}


/***************************************************************************

Function:
    VerifyOpenPermissionLocalQueue

Description:
    Verify open premissions on local queues only

Environment:
    Windows NT only

***************************************************************************/
static
HRESULT
VerifyOpenPermissionLocalQueue(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue
    )
{
    //
    // Check open queue premissions on local queues only.
    //

    HRESULT hr2;

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
			{
				R<CQueueSecurityDescriptor> pcSD = pQueue->GetSecurityDescriptor();
				hr2 = DoDSAccessCheck(
							eQUEUE,
							&pQueueFormat->PublicID(),
							pcSD->GetSD(),
							pQueue->GetQueueName(),
							MapQueueOpenAccess(dwAccess, fJournalQueue));
				return LogHR(hr2, s_FN, 550);
			}

        case QUEUE_FORMAT_TYPE_MACHINE:
            hr2 = DoDSAccessCheck(
                        eMACHINE,
                        &pQueueFormat->MachineID(),
                        TRUE,
                        FALSE,
                        g_szMachineName,
                        MapMachineQueueAccess(dwAccess, fJournalQueue));
            return LogHR(hr2, s_FN, 560);

        case QUEUE_FORMAT_TYPE_PRIVATE:
            hr2 = DoPrivateAccessCheck(
                        eQUEUE,
                        pQueueFormat->PrivateID().Uniquifier,
                        MapQueueOpenAccess(dwAccess, fJournalQueue));
            return LogHR(hr2, s_FN, 570);

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // This is a local DIRECT queue.
            // The queue object is either of PUBLIC or PRIVATE type.
            //
            switch(pQueue->GetQueueType())
            {
                case QUEUE_TYPE_PUBLIC:
					{
						R<CQueueSecurityDescriptor> pcSD = pQueue->GetSecurityDescriptor();
						hr2 = DoDSAccessCheck(
								eQUEUE,
								pQueue->GetQueueGuid(),
								pcSD->GetSD(),
								pQueue->GetQueueName(),
								MapQueueOpenAccess(dwAccess, fJournalQueue));
						return LogHR(hr2, s_FN, 580);
					}

                case QUEUE_TYPE_PRIVATE:
                    hr2 = DoPrivateAccessCheck(
                                eQUEUE,
                                pQueue->GetPrivateQueueId(),
                                MapQueueOpenAccess(dwAccess, fJournalQueue));
                    return LogHR(hr2, s_FN, 590);

                default:
                    ASSERT(0);
                    return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 600);
            }

        case QUEUE_FORMAT_TYPE_CONNECTOR:
        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 610);
    }
}


/***************************************************************************

Function:
    VerifyOpenPermission

Description:
    Verify open premissions for any queue

Environment:
    Windows NT, Windows 9x

***************************************************************************/
HRESULT
VerifyOpenPermission(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue,
    BOOL fLocalQueue
    )
{
    if(fLocalQueue)
    {
        return LogHR(VerifyOpenPermissionLocalQueue(pQueue, pQueueFormat, dwAccess, fJournalQueue), s_FN, 620);
    }
    else
    {
        return LogHR(VerifyOpenPermissionRemoteQueue(pQueue, pQueueFormat, dwAccess), s_FN, 630);
    }

}

/***************************************************************************

Function:
    VerifyMgmtPermission

Description:
    Verify Managment premissions for the machine
    This function is used for "admin" access, i.e., to verify if
    caller is local admin.

Environment:
    Windows NT

***************************************************************************/

HRESULT
VerifyMgmtPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    )
{
    HRESULT hr = DoAdminAccessCheck(
                    eMACHINE,
                    MachineId,
                    MachineName,
                    MQSEC_MACHINE_GENERIC_ALL,
                    MQSEC_SET_MACHINE_PROPERTIES
                    );
    return LogHR(hr, s_FN, 640);
}

/***************************************************************************

Function:
    VerifyMgmtGetPermission

Description:
    Verify Managment "get" premissions for the machine
    Use local cache of security descriptor.

Environment:
    Windows NT

***************************************************************************/

HRESULT
VerifyMgmtGetPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    )
{
    HRESULT hr = DoDSAccessCheck( eMACHINE,
                                  MachineId,
                                  TRUE,   // fInclSACL,
                                  FALSE,  // fTryDS,
                                  MachineName,
                                  MQSEC_GET_MACHINE_PROPERTIES ) ;

    return LogHR(hr, s_FN, 660);
}
\
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmutil.cpp

Abstract:

    QM utilities

--*/

#include "stdh.h"
#include "uniansi.h"
#include "qmutil.h"
#include "_rstrct.h"
#include "cqueue.h"
#include "_registr.h"
#include "mqprops.h"
#include "sessmgr.h"
#include "mqformat.h"
#include "mqsocket.h"
#include "ad.h"
#include "acioctl.h"
#include "acapi.h"
#include "cm.h"
#include <nspapi.h>
#include <Fn.h>
#include <no.h>
#include <string>
#include <Clusapi.h>
#include <Resapi.h>
#include <list>
#include <SmartHandleImpl.h>
#include <autoreln.h>
#include <strsafe.h>
#include "st.h"


#include "qmutil.tmh"

extern LPTSTR           g_szMachineName;
extern CSessionMgr      SessionMgr;
extern AP<WCHAR> g_szComputerDnsName;


static WCHAR *s_FN=L"qmutil";


void TA2StringAddr(IN const TA_ADDRESS * pa, OUT LPTSTR psz, IN int length)
{
    ASSERT(psz != NULL);
    ASSERT(pa != NULL);
    ASSERT(pa->AddressType == IP_ADDRESS_TYPE ||
           pa->AddressType == FOREIGN_ADDRESS_TYPE);

    switch(pa->AddressType)
    {
        case IP_ADDRESS_TYPE:
        {
            char * p = inet_ntoa(*(struct in_addr *)(pa->Address));
			HRESULT hr = StringCchPrintf(psz, length, TEXT("%d %S"), pa->AddressType, p);
			ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);
            break;
        }

        case FOREIGN_ADDRESS_TYPE:
        {
            GUID_STRING strUuid;
            MQpGuidToString((GUID*)(pa->Address), strUuid);
			HRESULT hr = StringCchPrintf(psz, length, TEXT("%d %S"), pa->AddressType, strUuid);
			ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);
            break;
        }

        default:
            ASSERT(0);
    }
}


//
// CRefreshIntervals class is used to encapsulate the different refresh
// intervals - site, enterprise and error retry. It reads the values from
// the registry, handles defaults and converts all the values to Miliseconds.
// YoelA, 24-Oct-2000
//
class CRefreshIntervals
{
public:
    unsigned __int64 GetSiteInterval();
    unsigned __int64 GetEnterpriseInterval();
    unsigned __int64 GetErrorRetryInterval();
    CRefreshIntervals();

private:
    void InitOnce(); // Initialize Values if not initialized yet
    void GetTimeIntervalFromRegistry (
        LPCTSTR pszValueName,
        unsigned __int64 *pui64Value,
        DWORD dwUnitMultiplier,
        unsigned __int64 ui64DefaultInMiliseconds);

    unsigned __int64 m_ui64SiteInterval;
    unsigned __int64 m_ui64EnterpriseInterval;
    unsigned __int64 m_ui64ErrorRetryInterval;
    bool m_fInitialized;
} s_RefreshIntervals;

//
// GetSystemTimeAsFileTime gives the time in 100 nanoseconds intervals, while we keep
// our intervals in miliseconds, so convertion is needed.
//
const DWORD x_dwSysTimeIntervalsInMilisecond = 10000;

//
// WriteFutureTimeToRegistry - this function writes a future time into the registry,
// given the time interval from present in miliseconds.
//
LONG
WriteFutureTimeToRegistry(
    LPCTSTR          pszValueName,
    unsigned __int64 ui64MilisecondsInterval)
{
    union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
    } ft;


    GetSystemTimeAsFileTime(&ft.ft_struct);

    ft.ft_scalar += ui64MilisecondsInterval * x_dwSysTimeIntervalsInMilisecond;

    DWORD dwSize = sizeof(ft);
    DWORD dwType = REG_QWORD;

    LONG rc = SetFalconKeyValue( pszValueName,
                                 &dwType,
                                 &ft.ft_scalar,
                                 &dwSize) ;

    return rc;
}

//
// DidRegTimeArrive returns true if a time, that was stored in the registry under pszValueName,
// already passed.
// If the time did not pass, it returns false, and *pui64MilisecondsToWait
// will hold the time interval, in miliseconds, till the time stored in the registry will arrive.
//
bool
DidRegTimeArrive(
    LPCTSTR pszValueName,
    unsigned __int64 *pui64MilisecondsToWait
    )
{
    //
    // Tolerance - how much time before the time arrives will be considered OK.
    // the values is 1 minute, converted to units of 100 nanoseconds (same units
    // as GetSystemTimeAsFileTime)
    //
    const unsigned __int64 x_ui64Tolerance = x_dwSysTimeIntervalsInMilisecond * 1000 * 60;

    //
    // If the time already ellapsed, the time to wait for it to arrive is
    // as close to infinite as possible...
    //
    *pui64MilisecondsToWait = _UI64_MAX;

    //
    // Get current time
    //
    union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
    } ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent.ft_struct);

    unsigned __int64 ui64RegTime;

    DWORD dwSize = sizeof(ui64RegTime);
    DWORD dwType = REG_QWORD;

    LONG rc = GetFalconKeyValue( pszValueName,
                                 &dwType,
                                 &ui64RegTime,
                                 &dwSize) ;

    if ((rc != ERROR_SUCCESS) || (dwSize != sizeof(ui64RegTime)))
    {
        //
        // Assume there is no such value in registry. Return true.
        // As far as registry is concerned, it's legal to have
        // (rc == ERROR_SUCCESS) but size not equal size of QWORD if you
        // manually erase part of registry value using regedt32.
        //
        return true;
    }

    if (ui64RegTime <= ftCurrent.ft_scalar + x_ui64Tolerance)
    {
        //
        // The time passed
        //
        return true;
    }

    //
    // Time did not pass. Return the remaining time in Miliseconds
    //
    *pui64MilisecondsToWait = (ui64RegTime - ftCurrent.ft_scalar) / x_dwSysTimeIntervalsInMilisecond;
    return false;
}

//
// CRefreshIntervals Implementation
//
CRefreshIntervals::CRefreshIntervals() :
    m_ui64SiteInterval(0) ,
    m_ui64EnterpriseInterval (0) ,
    m_ui64ErrorRetryInterval (0) ,
    m_fInitialized(false)
{}

unsigned __int64 CRefreshIntervals::GetSiteInterval()
{
    InitOnce();
    return m_ui64SiteInterval;
}

unsigned __int64 CRefreshIntervals::GetEnterpriseInterval()
{
    InitOnce();
    return m_ui64EnterpriseInterval;
}

unsigned __int64 CRefreshIntervals::GetErrorRetryInterval()
{
    InitOnce();
    return m_ui64ErrorRetryInterval;
}

//
//  GetTimeIntervalFromRegistry - Reads a time interval (at key pszValueName) from
//                                the registry and returns it in Miliseconds.
//                                If the key does not exist in the registry, the default is returned.
//
void CRefreshIntervals::GetTimeIntervalFromRegistry (
    LPCTSTR             pszValueName,
    unsigned __int64    *pui64Value,
    DWORD               dwUnitMultiplier, // 3600 * 1000 for hours, 60 * 1000 for minutes
    unsigned __int64    ui64DefaultInMiliseconds
    )
{
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD;

    DWORD dwValueInTimeUnits;

    LONG res = GetFalconKeyValue(
                            pszValueName,
                            &dwType,
                            &dwValueInTimeUnits,
                            &dwSize);

    if (res == ERROR_SUCCESS)
    {
        *pui64Value = static_cast<unsigned __int64>(dwValueInTimeUnits) *
                      static_cast<unsigned __int64>(dwUnitMultiplier);
    }
    else
    {
        *pui64Value = ui64DefaultInMiliseconds;
    }
}


void CRefreshIntervals::InitOnce()
{
    if (m_fInitialized)
    {
        return;
    }
    m_fInitialized = true;


    const DWORD x_MiliSecondsInHour = 60 * 60 * 1000;
    const DWORD x_MiliSecondsInMinute = 60 * 1000;

    unsigned __int64 ui64DefaultSiteInterval, ui64DefaultEnterpriseInterval;

    ui64DefaultSiteInterval =
                  MSMQ_DEFAULT_DS_SITE_LIST_REFRESH * x_MiliSecondsInHour;
    ui64DefaultEnterpriseInterval =
            MSMQ_DEFAULT_DS_ENTERPRISE_LIST_REFRESH * x_MiliSecondsInHour;

    //
    // Get the site and enterprise refresh intervals.
    // Note - the reg value is in hours, and we translate it to miliseconds.
    // If the old value was specified, it is used as a default. Otherwise,
    // the constant default is used.
    //

    //
    // Get site refresh value
    //
    GetTimeIntervalFromRegistry (
        MSMQ_DS_SITE_LIST_REFRESH_REGNAME,
        &m_ui64SiteInterval,
        x_MiliSecondsInHour,
        ui64DefaultSiteInterval
    );

    //
    // Get enterprise refresh value
    //
    GetTimeIntervalFromRegistry (
        MSMQ_DS_ENTERPRISE_LIST_REFRESH_REGNAME,
        &m_ui64EnterpriseInterval,
        x_MiliSecondsInHour,
        ui64DefaultEnterpriseInterval
    );

    //
    // Get Retry on error value
    //
    unsigned __int64 ui64DefaultErrorRetryInterval = MSMQ_DEFAULT_DSLIST_REFRESH_ERROR_RETRY_INTERVAL * x_MiliSecondsInMinute;

    GetTimeIntervalFromRegistry (
        MSMQ_DSLIST_REFRESH_ERROR_RETRY_INTERVAL,
        &m_ui64ErrorRetryInterval,
        x_MiliSecondsInMinute,
        ui64DefaultErrorRetryInterval
    );
}
/*======================================================

Function:         GetDsServerList

Description:      This routine gets the list of ds
                  servers from the DS

========================================================*/

DWORD g_dwDefaultTimeToQueue = MSMQ_DEFAULT_LONG_LIVE ;

DWORD GetDsServerList(OUT WCHAR *pwcsServerList, IN  DWORD dwLen)
{
    #define MAX_NO_OF_PROPS 21

    //
    //  Get the names of all the servers that
    //  belong to the site
    //

    ASSERT (dwLen >= MAX_REG_DSSERVER_LEN);
    DBG_USED(dwLen);

    HRESULT       hr = MQ_OK;
    HANDLE        hQuery;
    DWORD         dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT   result[ MAX_NO_OF_PROPS ] ;
    PROPVARIANT*  pvar;
    DWORD         index = 0;

    GUID guidEnterprise = McGetEnterpriseId();
    GUID guidSite = McGetSiteId();

    //
    // Get the default Time-To-Queue from MQIS
    //
    PROPID      aProp[1];
    PROPVARIANT aVar[1];

    aProp[0] = PROPID_E_LONG_LIVE ;
    aVar[0].vt = VT_UI4;

    hr = ADGetObjectPropertiesGuid(
				eENTERPRISE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&guidEnterprise,
				1,
				aProp,
				aVar
				);
    if (FAILED(hr))
    {
       return 0 ;
    }

    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD;

    LONG rc = SetFalconKeyValue( MSMQ_LONG_LIVE_REGNAME,
                                 &dwType,
                                 (PVOID) &aVar[0].ulVal,
                                 &dwSize ) ;
    ASSERT(rc == ERROR_SUCCESS) ;
	DBG_USED(rc);
    g_dwDefaultTimeToQueue = aVar[0].ulVal ;




	//
	//	First assume NT5 DS server, and ask for the DNS names
	//	of the DS servers
	//
    CColumns      Colset;
    Colset.Add(PROPID_QM_PATHNAME_DNS);
	Colset.Add(PROPID_QM_PATHNAME);

    DWORD   lenw;

    hr =  ADQuerySiteServers(
                    NULL,           // pwcsDomainController
					false,			// fServerName
                    &guidSite,      // In  this machine's Site
                    eDS,            // DS server only
                    Colset.CastToStruct(),
                    &hQuery
                    );
	if ( hr == MQ_ERROR)
	{
		//
		//	Most likely, the DS server is not NT5
		//

		CColumns      ColsetNT4;
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		hr = ADQuerySiteServers(
                    NULL,           // pwcsDomainController
					false,			// fServerName
                    &guidSite,      // In  this machine's Site
                    eDS,            // DS server only
					ColsetNT4.CastToStruct(),
					&hQuery
                    );
	}

    BOOL fAlwaysLast = FALSE ;
    BOOL fForceFirst = FALSE ;

    if ( SUCCEEDED(hr))
    {
        while ( SUCCEEDED ( hr = ADQueryResults( hQuery, &dwProps, result)))
        {
            //
            //  No more results to retrieve
            //
            if (!dwProps)
                break;

            pvar = result;

            for (DWORD i = 0; i < (dwProps/2) ; i++, pvar+=2)
            {
                //
                //  Add the server name to the list
                //  For load balancing, write sometimes at the
                //  beginning of the string, sometimes at the end. Like
                //  that we will have  BSCs and PSC in a random order
                //
                WCHAR * p;
				WCHAR * pwszVal;
				AP<WCHAR> pCleanup1;
				AP<WCHAR> pCleanup2 = (pvar+1)->pwszVal;

				if ( pvar->vt != VT_EMPTY)
				{
					//
					// there may be cases where server will not have DNS name
					// ( migration)
					//
					pwszVal = pvar->pwszVal;
					pCleanup1 = pwszVal;
				}
				else
				{
					pwszVal = (pvar+1)->pwszVal;
				}
                lenw = wcslen( pwszVal);

                if ( index + lenw + 4 <  MAX_REG_DSSERVER_LEN)
                {
                   if (!_wcsicmp(g_szMachineName, pwszVal))
                   {
                      //
                      // Our machine should be first on the list.
                      //
                      ASSERT(!fForceFirst) ;
                      fForceFirst = TRUE ;
                   }
                   if(index == 0)
                   {
                      //
                      // Write the 1st string
                      //
                      p = &pwcsServerList[0];
                      if (fForceFirst)
                      {
                         //
                         // From now on write all server at the end
                         // of the list is our machine remain the
                         // first in the list.
                         //
                         fAlwaysLast = TRUE ;
                      }
                   }
                   else if (fAlwaysLast ||
                             ((rand() > (RAND_MAX / 2)) && !fForceFirst))
                   {
                      //
                      // Write at the end of the string
                      //
                      pwcsServerList[index] = DS_SERVER_SEPERATOR_SIGN;
                      index ++;
                      p = &pwcsServerList[index];
                   }
                   else
                   {
                      if (fForceFirst)
                      {
                         //
                         // From now on write all server at the end
                         // of the list is our machine remain the
                         // first in the list.
                         //
                         fAlwaysLast = TRUE ;
                      }
                      //
                      // Write at the beginning of the string
                      //
                      DWORD dwSize = lenw                 +
                                     2 /* protocols flags */ +
                                     1 /* Separator    */ ;
                      //
                      // Must use memmove because buffers overlap.
                      //
                      memmove( &pwcsServerList[dwSize],
                               &pwcsServerList[0],
                               index * sizeof(WCHAR));
                      pwcsServerList[dwSize - 1] = DS_SERVER_SEPERATOR_SIGN;
                      p = &pwcsServerList[0];
                      index++;
                   }

                   //
                   // Mark only IP as supported protocol
                   //
                   *p++ = TEXT('1');
                   *p++ = TEXT('0');

                   memcpy(p, pwszVal, lenw * sizeof(WCHAR));
                   index += lenw + 2;

                }
            }
        }
        pwcsServerList[index] = '\0';
        //
        // close the query handle
        //
        hr = ADEndQuery( hQuery);

    }

    return((index) ? index+1 : 0);
}

//+------------------------------------------------------------------------
//
//   RefreshSiteServersList()
//
// RefreshSiteServersList - refresh the list of servers, that belong to
// the current site, in the registry
//
//+------------------------------------------------------------------------

HRESULT
RefreshSiteServersList()
{
    WCHAR pwcsServerList[ MAX_REG_DSSERVER_LEN ];

    DWORD dwLen = GetDsServerList(pwcsServerList, MAX_REG_DSSERVER_LEN);

    if (dwLen == 0)
    {
        return MQ_ERROR;
    }

    //
    //  Write into registry, if succeeded to retrieve any servers
    //
    DWORD dwSize = dwLen * sizeof(WCHAR) ;
    DWORD dwType = REG_SZ;
    LONG rc = SetFalconKeyValue( MSMQ_DS_SERVER_REGNAME,
                                 &dwType,
                                 pwcsServerList,
                                 &dwSize) ;
    //
    // Update Site name in registry (only on client machines)
    //
    if (IsNonServer())   // [adsrv]  == SERVICE_NONE) - should it be only clients? Not FRS?
    {
        GUID guidSite = McGetSiteId();


       PROPID      aProp[1];
       PROPVARIANT aVar[1];
       aProp[0] =   PROPID_S_PATHNAME ;
       aVar[0].vt = VT_NULL ;
       HRESULT hr1 = ADGetObjectPropertiesGuid(
							eSITE,
							NULL,       // pwcsDomainCOntroller
							false,	    // fServerName
							&guidSite,
							1,
							aProp,
							aVar
							);
       if (SUCCEEDED(hr1))
       {
          ASSERT(aVar[0].vt == VT_LPWSTR) ;
          AP<WCHAR> lpwsSiteName =  aVar[0].pwszVal ;

          dwType = REG_SZ;
          dwSize = (wcslen(lpwsSiteName) + 1) * sizeof(WCHAR) ;
          rc = SetFalconKeyValue( MSMQ_SITENAME_REGNAME,
                                  &dwType,
                                  lpwsSiteName,
                                  &dwSize) ;
       }
    }

    return MQ_OK ;
}

/*======================================================

Function:         TimeToUpdateDsServerList()

Description:      This routine updates the list of ds
                  servers in the registry

========================================================*/

void
WINAPI
TimeToUpdateDsServerList(
    CTimer* pTimer
    )
{
    //
    // We check the timer at least every day. Units are miliseconds
    //
    const DWORD x_dwMaximalRefreshInterval = 60 * 60 * 24 * 1000;
    DWORD dwNextUpdateInterval = x_dwMaximalRefreshInterval;

    try
    {
        //
        //  Get the names of all the servers that
        //  belong to the site
        //
        unsigned __int64 ui64NextSiteInterval;
        if (DidRegTimeArrive( MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME,
                             &ui64NextSiteInterval))
        {

            HRESULT hr = RefreshSiteServersList();

            if SUCCEEDED(hr)
            {
                ui64NextSiteInterval = s_RefreshIntervals.GetSiteInterval();
            }
            else
            {
                ui64NextSiteInterval = s_RefreshIntervals.GetErrorRetryInterval();
            }

            WriteFutureTimeToRegistry(
                MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME,
                ui64NextSiteInterval
                );

        }
        dwNextUpdateInterval = static_cast<DWORD>
                     (min(dwNextUpdateInterval, ui64NextSiteInterval)) ;

        //
        //  Update the registry key of server cache - each Enterprise refresh
        //  interval. This is not performed by routing servers, who are not
        //  expected to change site.
        //  msmq on Domain controller always prepare this cache. Bug 6698.
        //
        if (!IsRoutingServer())
        {
            unsigned __int64 ui64NextEnterpriseInterval;
            if (DidRegTimeArrive(
                    MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME,
                    &ui64NextEnterpriseInterval)
               )
            {
                HRESULT hr = ADCreateServersCache() ;

                if SUCCEEDED(hr)
                {
                    ui64NextEnterpriseInterval = s_RefreshIntervals.GetEnterpriseInterval();
                }
                else
                {
                    ui64NextEnterpriseInterval = s_RefreshIntervals.GetErrorRetryInterval();
                }

                WriteFutureTimeToRegistry(
                    MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME,
                    ui64NextEnterpriseInterval
                    );
            }
            dwNextUpdateInterval = static_cast<DWORD>
                (min(dwNextUpdateInterval, ui64NextEnterpriseInterval));
        }
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 69);
    }

    ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwNextUpdateInterval)) ;
}


static void GetMachineDNSNames(LPWSTR** paLocalMachineNames)
/*++

  Routine Description:
	The Routine retrieves the local machine DNS names and cache them in array.

  Arguments:
	paLocalMachineNames	- pointer to that array where the data is stored

  Returned Value:
	None.

 --*/
{
    //
    // If the machine is network disconnected, don't try to resolve the DNS
    // name. On RAS enviroment it can cause auto-dialing
    //
    if(!CQueueMgr::IsConnected())
        return;

    //
    // Get the machine DNS NAME
    //
    struct hostent* pHost = gethostbyname(NULL);
    if (pHost == NULL)
    {
        TrERROR(NETWORKING, "gethostbyname failed. WSAGetLastError: %d", WSAGetLastError());
        return;
    }

    //
    // Calculate the number of DNS Names
    //
    DWORD size = 1 + sizeof(pHost->h_aliases);

    LPWSTR* aNames = NULL;
    try
    {
        //
        // copy the Names from pHost to internal data structure
        //
        aNames = new LPWSTR[size];
        memset(aNames, 0, size * sizeof(LPWSTR));

        DWORD length = strlen(pHost->h_name) +1;
        aNames[0] = new WCHAR[length];		
        ConvertToWideCharString(pHost->h_name, aNames[0], length);

        for (DWORD i = 0; (pHost->h_aliases[i] != NULL); ++i)
        {
            length = strlen(pHost->h_aliases[i])	+ 1;
            aNames[i+1] = new WCHAR[length];
            ConvertToWideCharString(pHost->h_aliases[i], aNames[i+1], length);
        }
    }
    catch(const bad_alloc&)
    {
        //
        // free all the allocated memory
        //
        if (aNames != NULL)
        {
            for (DWORD i = 0; i < size; ++i)
            {
                delete aNames[i];
            }
            delete aNames;
        }
        LogIllegalPoint(s_FN, 71);
        return;
    }

    //
    // free previous data
    //
    if (*paLocalMachineNames != NULL)
    {
        for (LPWSTR const* pName = *paLocalMachineNames; (*pName != NULL); ++pName)
        {
            delete *pName;
        }
        delete *paLocalMachineNames;
    }

    *paLocalMachineNames = aNames;
}


const DWORD DNS_REFRESH_TIME = 15 * 60 * 1000;   // 15 minutes
static LPWSTR* aLocalMachineNames = NULL;
CCriticalSection    csLocalMachineNames;


static void RefreshLocalComputerDnsCache()
/*++

  Routine Description:
        This routine refresh the computer DNS names cache.

  Arguments:
        none

  Returned value:
	none

 --*/
{
    static LastRefreshTime = 0;

    DWORD CurrntTime = GetTickCount();

    if ((aLocalMachineNames == 0) || (LastRefreshTime == 0) ||
    (CurrntTime - LastRefreshTime >= DNS_REFRESH_TIME))
    {
        //
        // refresh the internal data structure
        //
        GetMachineDNSNames(&aLocalMachineNames);
        LastRefreshTime = CurrntTime;
    }
}

BOOL
QmpIsLocalMachine(
	LPCWSTR MachineName,
	BOOL* pfDNSName
	)
/*++

  Routine Description:
	The routine checks that the given machine name is local. It comapres
	the machine name to the Local Machine NetBios name or the DNS names
	of the local machine.

	The routine uses the data-structure that contains the DNS names of the machine.
	However, when the routine retreives the information (using gethostbyname API), it doesn't
	get any indication if the data retreive from the machine internal cache (WINS) or from the
	DNS server.  Therfore, the routine try to refresh its internal data-structure every 15
	minutes

  Arguments:
	- path name that should be checked
	- pointer to BOOL varaiables, that used to return if the machine name is DNS name or not

  Returned value:
	TRUE if the machine is local machine, FALSE otherwise

 --*/
{
    *pfDNSName = FALSE;
    if (CompareStringsNoCase(MachineName, g_szMachineName) == 0)
        return TRUE;

	 if (CompareStringsNoCase(MachineName,L"localhost") == 0)
        return TRUE;


    //
    // Check if the given machine name is DNS name. If the given name isn't DNS name
    // we don't need to compare it agains the local machine dns name
    //
    if (wcschr(MachineName,L'.') == NULL)
        return FALSE;

    //
    // Check if the prefix of the DNS name is equal to NetBios name
    //
    if ((CompareSubStringsNoCase(MachineName, g_szMachineName, wcslen(g_szMachineName)) != 0) ||
        (MachineName[wcslen(g_szMachineName)] != L'.'))
        return FALSE;

	//
	// Check if the given name is the full dns name got from GetComputerNameEx call
	//
	if(g_szComputerDnsName != NULL &&  _wcsicmp(g_szComputerDnsName, MachineName) == 0)
	{
		*pfDNSName = TRUE;
		return TRUE;
	}

    CS lock( csLocalMachineNames);

    RefreshLocalComputerDnsCache();

    if (aLocalMachineNames == NULL)
    {
        //
        // We failed to retrieve the local machine DNS names.
        //
        return FALSE;
    }

    for (LPCWSTR const* pName = aLocalMachineNames; (*pName != NULL); ++pName)
    {
        if (CompareStringsNoCase(MachineName, *pName) == 0)
        {
	        *pfDNSName = TRUE;
	        return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsPathnameForLocalMachine(
	LPCWSTR PathName,
	BOOL* pfDNSName
	)
{
    AP<WCHAR> MachineName;
	FnExtractMachineNameFromPathName(
		PathName,
		MachineName
		);

	return QmpIsLocalMachine(MachineName.get(), pfDNSName);
}


void
GetDnsNameOfLocalMachine(
    WCHAR ** ppwcsDnsName
	)
/*++

  Routine Description:
	The routin returns a name from an internal data-structure that contains
    the DNS names of the machine.
	It doesn't try to refresh it.

  Arguments:
    ppwcsDnsName    - 	a pointer to the DNS name, or NULL if there isn't one

  Returned value:
    none


 --*/
{
    CS lock( csLocalMachineNames);

    RefreshLocalComputerDnsCache();

    if (aLocalMachineNames == NULL)
    {
        //
        // We failed to retrieve the local machine DNS names.
        //
        *ppwcsDnsName = NULL;
        return;
    }
    int size = wcslen(*aLocalMachineNames) +1;
    *ppwcsDnsName = new WCHAR[size];
    HRESULT hr = StringCchCopy( *ppwcsDnsName, size, *aLocalMachineNames);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);
    return;
}


static BOOL IsLocalAddress(DWORD Address)
{
	PHOSTENT phe = gethostbyname(NULL);

    if((phe == NULL) || (phe->h_addr_list == NULL))
        return FALSE;

    for(DWORD** ppAddress = (DWORD**)phe->h_addr_list; *ppAddress != NULL; ++ppAddress)
    {
    	if(**ppAddress == Address)
    		return TRUE;
    }

    return FALSE;
}


/*====================================================

IsLocalDirectQueue

Return Value:    TRUE if the direct queue is local queue

Arguments:       pQueueFormat - pointer to QUEUE_FORMAT

=====================================================*/
BOOL IsLocalDirectQueue(const QUEUE_FORMAT* pQueueFormat,
                        bool                fInReceive,
                        bool                fInSend)
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

	LPCWSTR lpwcsDirectQueuePath = pQueueFormat->DirectID();
	ASSERT((*lpwcsDirectQueuePath != L'\0') && !iswspace(*lpwcsDirectQueuePath));

	DirectQueueType QueueType;
	lpwcsDirectQueuePath = FnParseDirectQueueType(lpwcsDirectQueuePath, &QueueType);

	AP<WCHAR> MachineName;
	
	FnExtractMachineNameFromDirectPath(lpwcsDirectQueuePath, MachineName);

	switch (QueueType)
	{
		case dtOS:
		{
            if (fInReceive && CQueueMgr::IgnoreOsValidation())
			{
                //
                // Bug 8760.
                // Support direct=os with NLB
                //
				return TRUE;
			}

			BOOL temp;
			return QmpIsLocalMachine(MachineName.get(), &temp);
		}

		case dtHTTP:
		case dtHTTPS:
		{
			BOOL temp;
			if(QmpIsLocalMachine(MachineName.get(), &temp))
				return TRUE;
			//
			// else fall through to case dtTCP, and check if local ip address
			//
		}

		case dtTCP:
		{
			//
			// If we received a message in direct tcp format, it should always
			// be local. (QFE 5772, YoelA, 3-Aug-2000)
			//
			if (fInReceive)
			{
				return TRUE;
			}
            else if (fInSend)
            {
                //
                // Bug 664307.
                // Hint for GetQueueObject(), so it know to what CQueue
                // object this packet belong.
                //
                return FALSE ;
            }

			return IsLocalAddress(StIPWStringToULONG(MachineName.get()));
		}
		default:
			ASSERT(0);
			return FALSE;
	}
}


/*====================================================

CompareElements  of PQUEUE_ID

Arguments:

Return Value:


=====================================================*/

template<>
BOOL AFXAPI  CompareElements(IN const QUEUE_ID* const * pQueue1,
                             IN const QUEUE_ID* const * pQueue2)
{
    ASSERT(AfxIsValidAddress((*pQueue1)->pguidQueue, sizeof(GUID), FALSE));
    ASSERT(AfxIsValidAddress((*pQueue2)->pguidQueue, sizeof(GUID), FALSE));

    if ((*((*pQueue1)->pguidQueue) == *((*pQueue2)->pguidQueue)) &&
        ((*pQueue1)->dwPrivateQueueId == (*pQueue2)->dwPrivateQueueId))
        return TRUE;

    return FALSE;

}

/*====================================================

DestructElements of PQUEUE_ID

Arguments:

Return Value:


=====================================================*/

template<>
void AFXAPI DestructElements(IN const QUEUE_ID** /*ppNextHop */, int /*n*/)
{
}

/*====================================================

HashKey For PQUEUE_ID

Arguments:

Return Value:


=====================================================*/

template<>
UINT AFXAPI HashKey(IN const QUEUE_ID* key)
{
    ASSERT(AfxIsValidAddress(key->pguidQueue, sizeof(GUID), FALSE));

    return((UINT)((key->pguidQueue)->Data1 + key->dwPrivateQueueId));

}

/*======================================================

Function:        GetRegistryStoragePath

Description:     Get storage path for Falcon data

Arguments:       None

Return Value:    None

========================================================*/
BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, int length, PCWSTR pSuffix)
{
    DWORD dwValueType = REG_SZ ;
    DWORD dwValueSize = MAX_PATH * sizeof(WCHAR);

    LONG rc;
    rc = GetFalconKeyValue(
            pKey,
            &dwValueType,
            pPath,
            &dwValueSize
            );

    if(rc != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if(dwValueSize < (3 * sizeof(WCHAR)))
    {
        return FALSE;
    }

    //
    //  Check for absolute path, drive or UNC
    //
    if(!(
        (isalpha(pPath[0]) && (pPath[1] == L':')) ||
        ((pPath[0] == L'\\') && (pPath[1] == L'\\'))
        ))
    {
        return FALSE;
    }

    HRESULT hr = StringCchCat(pPath, length, pSuffix);
    if (FAILED(hr))
    {
    	ASSERT(0);
    	return FALSE;
    }
    return TRUE;
}

//---------------------------------------------------------
//
//  Thread Event and handle routines
//
//---------------------------------------------------------

DWORD g_dwThreadEventIndex = (DWORD)-1;
DWORD g_dwThreadHandleIndex = (DWORD)-1;

void AllocateThreadTLSs(void)
{
    ASSERT(g_dwThreadEventIndex == (DWORD)-1);
    g_dwThreadEventIndex = TlsAlloc();
    ASSERT(g_dwThreadEventIndex != (DWORD)-1);

    ASSERT(g_dwThreadHandleIndex == (DWORD)-1);
    g_dwThreadHandleIndex = TlsAlloc();
    ASSERT(g_dwThreadHandleIndex != (DWORD)-1);
}

HANDLE GetHandleForRpcCancel(void)
{
    if (g_dwThreadHandleIndex == (DWORD)-1)
    {
        ASSERT(0);
        return NULL;
    }

    HANDLE hThread = (HANDLE) TlsGetValue(g_dwThreadHandleIndex);

    if (hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        if(!DuplicateHandle(
				GetCurrentProcess(),
				hT,
				GetCurrentProcess(),
				&hThread,
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
				))
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "DuplicateHandle failed, gle = %!winerr!", gle);
	        return NULL;
		}

		//
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status = RpcMgmtSetCancelTimeout(0);
        if(status != RPC_S_OK)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "RpcMgmtSetCancelTimeout failed, gle = %!winerr!", gle);
	        CloseHandle(hThread);
			return NULL;
        }

        if(!TlsSetValue(g_dwThreadHandleIndex, hThread))
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "TlsSetValue failed, gle = %!winerr!", gle);
	        CloseHandle(hThread);
			return NULL;
		}
    }

    return hThread;
}

void  FreeHandleForRpcCancel(void)
{
    //
    //  If not TLS was allocated, the hThread returned is 0
    //
    HANDLE hThread = (HANDLE) TlsGetValue(g_dwThreadHandleIndex);
    if (hThread)
    {
        CloseHandle(hThread) ;
    }
}

HRESULT GetThreadEvent(HANDLE& hEvent)
{
    ASSERT(g_dwThreadEventIndex != (DWORD)-1);

    hEvent = (HANDLE) TlsGetValue(g_dwThreadEventIndex);
    if(hEvent != NULL)
        return MQ_OK;

	DWORD gle = GetLastError();
	if(gle != NO_ERROR)
	{
		return HRESULT_FROM_WIN32(gle);
	}

    //
    // Event was never allocated. This is the first
    // time this function has ever been called for this thread.
    //
    hEvent = CreateEvent(0, TRUE,FALSE, 0);
    if(hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    //  Set the Event first bit to disable completion port posting
    //
    hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

    BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		CloseHandle(hEvent);
		return HRESULT_FROM_WIN32(gle);
	}

    return MQ_OK;
}

void FreeThreadEvent(void)
{
    //
    //  If not TLS was allocated, the hEvent returned is 0
    //
    HANDLE hEvent = (HANDLE) TlsGetValue(g_dwThreadEventIndex);
    if(hEvent != 0)
    {
        CloseHandle(hEvent);
    }
}


void GetMachineQuotaCache(OUT DWORD* pdwQuota, OUT DWORD* pdwJournalQuota)
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD defaultValue = DEFAULT_QM_QUOTA;
    LONG rc;

    rc = GetFalconKeyValue(
            MSMQ_MACHINE_QUOTA_REGNAME,
            &dwType,
            pdwQuota,
            &dwSize,
            (LPCTSTR)&defaultValue
            );

    ASSERT(rc == ERROR_SUCCESS);

    defaultValue = DEFAULT_QM_JOURNAL_QUOTA;
    rc = GetFalconKeyValue(
            MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
            &dwType,
            pdwJournalQuota,
            &dwSize,
            (LPCTSTR)&defaultValue
            );

    ASSERT(rc == ERROR_SUCCESS);
}

void SetMachineQuotaChace(IN DWORD dwQuota)
{
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(DWORD);
    LONG rc;

    rc = SetFalconKeyValue(MSMQ_MACHINE_QUOTA_REGNAME,
                           &dwType,
                           &dwQuota,
                           &dwSize);
    ASSERT(rc == ERROR_SUCCESS);
}

void SetMachineJournalQuotaChace(IN DWORD dwJournalQuota)
{
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(DWORD);
    LONG rc;

    rc = SetFalconKeyValue(MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
                           &dwType,
                           &dwJournalQuota,
                           &dwSize);
    ASSERT(rc == ERROR_SUCCESS);

}



LPWSTR
GetReadableNextHop(
    const TA_ADDRESS* pta
    )
{
    LPCWSTR AddressType;
    switch(pta->AddressType)
    {
    case IP_ADDRESS_TYPE:
        AddressType = L"IP";
        break;

    case FOREIGN_ADDRESS_TYPE:
        AddressType =  L"FOREIGN";
        break;

    default:
        ASSERT(0);
        return NULL;
    }

    WCHAR TempBuf[100];
    TA2StringAddr(pta, TempBuf, 100);

    LPCWSTR  lpcsTemp = wcschr(TempBuf,L' ');
	if(lpcsTemp == NULL)
	{
		TrERROR(GENERAL, "Bad next hop address.  Missing space in %ls", TempBuf);
		ASSERT (("Bad next hop address.", 0));
		throw bad_hresult(MQ_ERROR);
	}

    DWORD length;
    length = wcslen(AddressType) +
             1 +                             // =
             wcslen(lpcsTemp+1) +
             1;                              // \0

    LPWSTR pNextHop = new WCHAR[length];
	HRESULT hr = StringCchPrintf(pNextHop, length, L"%s=%s", AddressType, lpcsTemp+1);
	ASSERT(SUCCEEDED(hr));
    DBG_USED(hr);
		
    return pNextHop;
}

/*====================================================
operator== for QUEUE_FORMAT
=====================================================*/
BOOL operator==(const QUEUE_FORMAT &key1, const QUEUE_FORMAT &key2)
{
    if ((key1.GetType() != key2.GetType()) ||
        (key1.Suffix() != key2.Suffix()))
    {
        return FALSE;
    }

    switch(key1.GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            return TRUE;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (key1.PublicID() == key2.PublicID());

        case QUEUE_FORMAT_TYPE_PRIVATE:
            return ((key1.PrivateID().Lineage == key2.PrivateID().Lineage) &&
                   (key1.PrivateID().Uniquifier == key2.PrivateID().Uniquifier));

        case QUEUE_FORMAT_TYPE_DIRECT:
            return (CompareStringsNoCase(key1.DirectID(), key2.DirectID()) == 0);

        case QUEUE_FORMAT_TYPE_MACHINE:
            return (key1.MachineID() == key2.MachineID());

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            return (key1.ConnectorID() == key2.ConnectorID());

    }
    return FALSE;
}

/*====================================================
Helper function for copying QueueFormat with direct name reallocation
====================================================*/
void CopyQueueFormat(QUEUE_FORMAT &qfTo, const QUEUE_FORMAT &qfFrom)
{
    qfTo.DisposeString();
    qfTo = qfFrom;

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
    	int length = wcslen(qfFrom.DirectID()) + 1;
        LPWSTR pw = new WCHAR[length];
        HRESULT hr = StringCchCopy (pw, length, qfFrom.DirectID());
        ASSERT(SUCCEEDED(hr));
        DBG_USED(hr);
        qfTo.DirectID(pw);
        //
        // BUGBUG: What about setting the suffix? See ac\acp.h (ShaiK, 18-May-2000)
        //
    }

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DL &&
        qfFrom.DlID().m_pwzDomain != NULL)
    {
        DL_ID id;
        id.m_DlGuid    = qfFrom.DlID().m_DlGuid;

        int length = wcslen(qfFrom.DlID().m_pwzDomain) + 1;
        id.m_pwzDomain = new WCHAR[length];
        HRESULT hr = StringCchCopy (id.m_pwzDomain, length, qfFrom.DlID().m_pwzDomain);
        ASSERT(SUCCEEDED(hr));
        DBG_USED(hr);
        qfTo.DlID(id);
    }
}


GUID s_EnterpriseId;
GUID s_SiteId;

void McInitialize()
{

    //
    // Read Enterprise ID from registry
    //
    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;

    LONG rc;
    rc = GetFalconKeyValue(
                MSMQ_ENTERPRISEID_REGNAME,
                &dwType,
                &s_EnterpriseId,
                &dwSize
                );

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(GENERAL, "Unable to get MSMQ_ENTERPRISEID_REGNAME registry value and rc = 0x%x", rc);
        throw exception();
    }

    ASSERT(dwSize == sizeof(GUID)) ;


    //
    // Read Site ID from registry
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;
    rc = GetFalconKeyValue(
                MSMQ_SITEID_REGNAME,
                &dwType,
                &s_SiteId,
                &dwSize
                );

    if (rc != ERROR_SUCCESS)
    {
        throw exception();
    }

    ASSERT(dwSize == sizeof(GUID)) ;
}


const GUID& McGetEnterpriseId()
{
    return s_EnterpriseId;
}


const GUID& McGetSiteId()
{
    return s_SiteId;
}


static ULONG sBindingIP = INADDR_NONE;

ULONG GetBindingIPAddress()
{
	ASSERT(sBindingIP != INADDR_NONE);
	return sBindingIP;
}

LPVOID
NetGetControlCodeOutput(
    IN HNETWORK hNetwork,
    IN DWORD dwControlCode,
    OUT LPDWORD lpcbResultSize
)
{
    DWORD  dwResult     = ERROR_SUCCESS;
    DWORD  cbBufSize    = 64;
    AP<BYTE> lpOutBuffer= new BYTE[64];

    dwResult = ClusterNetworkControl(
                   hNetwork,        // Handle to the affected network.
                   NULL,           // Optional node handle.
                   dwControlCode,   // Control code.
                   NULL,            // Input buffer. Not used.
                   0,               // Byte size of input buffer.
                   lpOutBuffer,     // Output buffer.
                   cbBufSize,       // Byte size of output buffer.
                   lpcbResultSize   // Byte size of resulting data.
                );


	//  Reallocate if necessary.

    if ( dwResult == ERROR_MORE_DATA )
    {
        lpOutBuffer.free();
        cbBufSize = *lpcbResultSize;
        lpOutBuffer = new BYTE[cbBufSize];

        dwResult =
                ClusterNetworkControl(
                   hNetwork,        // Handle to the affected network.
                   NULL,           // Optional node handle.
                   dwControlCode,   // Control code.
                   NULL,            // Input buffer. Not used.
                   0,               // Byte size of input buffer.
                   lpOutBuffer,     // Output buffer.
                   cbBufSize,       // Byte size of output buffer.
                   lpcbResultSize   // Byte size of resulting data.
                );
    }

    if( dwResult == ERROR_SUCCESS )
    {
		return lpOutBuffer.detach();
	}
	return 0;
}

LPVOID
NICGetControlCodeOutput(
    IN HNETINTERFACE hNetInterface,
    IN DWORD dwControlCode,
    OUT LPDWORD lpcbResultSize
)
{
    DWORD  dwResult     = ERROR_SUCCESS;
    DWORD  cbBufSize    = 64;
    AP<BYTE> lpOutBuffer= new BYTE[64];

    dwResult = ClusterNetInterfaceControl(
                   hNetInterface,        // Handle to the affected network.
                   NULL,           // Optional node handle.
                   dwControlCode,   // Control code.
                   NULL,            // Input buffer. Not used.
                   0,               // Byte size of input buffer.
                   lpOutBuffer,     // Output buffer.
                   cbBufSize,       // Byte size of output buffer.
                   lpcbResultSize   // Byte size of resulting data.
                );


	//  Reallocate if necessary.

    if ( dwResult == ERROR_MORE_DATA )
    {
        lpOutBuffer.free();
        cbBufSize = *lpcbResultSize;
        lpOutBuffer = new BYTE[cbBufSize];

        dwResult =
                ClusterNetInterfaceControl(
                   hNetInterface,        // Handle to the affected network.
                   NULL,           // Optional node handle.
                   dwControlCode,   // Control code.
                   NULL,            // Input buffer. Not used.
                   0,               // Byte size of input buffer.
                   lpOutBuffer,     // Output buffer.
                   cbBufSize,       // Byte size of output buffer.
                   lpcbResultSize   // Byte size of resulting data.
                );
    }

    if( dwResult == ERROR_SUCCESS )
    {
		return lpOutBuffer.detach();
	}
	return 0;
}

bool GetPrivateClusterIPs(std::list<ULONG> &ClusterPrivateIPs)
/*++

Routine Description:
	return a list of private IPs that we dont want to bind to.
	we do so by enumerating on the cluster networks & network interfaces

Arguments:
    ClusterPrivateIPs - refrence to a stil::list we will fill with IPs

Return Value:
	true - success
	false - error
	
--*/
{
	auto_hCluster hCluster(OpenCluster(NULL));
	if (!hCluster.valid())
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "failed in OpenCluster. %!winerr!", gle);
		return false;
	}

	auto_hClusterEnum hEnum(ClusterOpenEnum (hCluster.get(), CLUSTER_ENUM_INTERNAL_NETWORK));
	if (!hEnum.valid())
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "failed in ClusterOpenEnum. %!winerr!", gle);
		return false;
	}

	int NetworkCount = ClusterGetEnumCount (hEnum.get());
	if (NetworkCount == 0)
	{
		TrERROR(NETWORKING, " ClusterGetEnumCount returned zero.");
		return false;
	}

	for (int i=0; i<NetworkCount; i++)	
	{
	    AP<WCHAR> name = new WCHAR[100];
		DWORD len = 100;
		DWORD type;
		DWORD rc = ClusterEnum(hEnum.get(), i, &type, name.get(), &len);
		if (rc == ERROR_MORE_DATA)
		{
		    name.free();
		    len++;
			name = new WCHAR[len];
			rc = ClusterEnum(hEnum.get(), i, &type, name.get(), &len);
		}
		if (rc != ERROR_SUCCESS)
		{
			TrERROR(NETWORKING, "failed in ClusterEnum. %!winerr!", rc);
			return false;
		}
		ASSERT(type == CLUSTER_ENUM_INTERNAL_NETWORK);

		auto_hClusterNetwork hNet(OpenClusterNetwork(hCluster.get(), name.get()));
		if (!hNet.valid())
		{
			DWORD gle = GetLastError();
			TrERROR(NETWORKING, "failed in OpenClusterNetwork. %!winerr!", gle);
			return false;
		}

		AP<BYTE> NetBuff = (BYTE*)NetGetControlCodeOutput(hNet.get(), CLUSCTL_NETWORK_GET_COMMON_PROPERTIES, &len);
		if (NetBuff.get() == NULL)
		{
			DWORD gle = GetLastError();
			TrERROR(NETWORKING, "failed in NetGetControlCodeOutput. %!winerr!", gle);
			return false;
		}
		
		DWORD role;
		rc = ResUtilFindDwordProperty(NetBuff.get(), len, L"Role", &role);
		if (rc != ERROR_SUCCESS)
		{
			TrERROR(NETWORKING, "failed in ResUtilFindDwordProperty. %!winerr!", rc);
			return false;
		}

		auto_hClusterNetworkEnum hNetEnum(ClusterNetworkOpenEnum(hNet.get(), CLUSTER_NETWORK_ENUM_NETINTERFACES));
		if (!hNetEnum.valid())
		{
			DWORD gle = GetLastError();
			TrERROR(NETWORKING, "failed in ClusterNetworkOpenEnum. %!winerr!", gle);
			return false;
		}

		int NetInterfaceCount = ClusterNetworkGetEnumCount(hNetEnum.get());
		for (int j=0; j<NetInterfaceCount; j++)
		{
			rc = ClusterNetworkEnum(hNetEnum.get(), j, &type, name.get(), &len);
			if (rc == ERROR_MORE_DATA)
			{
			    name.free();
			    len++;
				name = new WCHAR[len];
				rc = ClusterNetworkEnum(hNetEnum.get(), j, &type, name.get(), &len);
			}
			if (rc != ERROR_SUCCESS)
			{
				TrERROR(NETWORKING, "failed in ClusterNetworkEnum. %!winerr!", rc);
				return false;
			}
			ASSERT(type == CLUSTER_NETWORK_ENUM_NETINTERFACES);

			auto_hClusterNetInterface hNetInterface(OpenClusterNetInterface(hCluster.get(), name.get()));
			if (!hNetInterface.valid())
			{
				DWORD gle = GetLastError();
				TrERROR(NETWORKING, "failed in hNetInterface. %!winerr!", gle);
				return false;
			}

			AP<BYTE> NICBuff = (BYTE*)NICGetControlCodeOutput(hNetInterface.get(), CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES, &len);
			if (NICBuff.get() == NULL)
			{
				DWORD gle = GetLastError();
				TrERROR(NETWORKING, "failed in NICGetControlCodeOutput. %!winerr!", gle);
				return false;
			}

			CAutoLocalFreePtr pNodeName;
			rc = ResUtilFindSzProperty (NICBuff.get(), len, L"Node", (LPWSTR*)&pNodeName);
			if (rc != ERROR_SUCCESS)
			{
				TrERROR(NETWORKING, "failed in ResUtilFindSzProperty. %!winerr!", rc);
				return false;
			}
			ASSERT(g_szMachineName);
			if ((_wcsicmp((LPWSTR)pNodeName.get(), g_szMachineName) == 0) && ((role == ClusterNetworkRoleInternalUse) || (i==0)))
			{
				CAutoLocalFreePtr pIPAddress;
				rc = ResUtilFindSzProperty (NICBuff.get(), len, L"Address", (LPWSTR*)&pIPAddress);
				if (rc != ERROR_SUCCESS)
				{
					TrERROR(NETWORKING, "failed in ResUtilFindSzProperty. %!winerr!", rc);
					return false;
				}
	 		  	ClusterPrivateIPs.push_back(StIPWStringToULONG((LPWSTR)pIPAddress.get()));
			}
		}
	}
	return true;
}


static void GetIPAddressAsString(PHOSTENT phe, AP<WCHAR>& wzIPString)
{
	std::string IPString;
    for (DWORD i = 0; phe->h_addr_list[i] != NULL; i++)
    {
    	in_addr TempAddr;
    	TempAddr.s_addr = *(ULONG*)phe->h_addr_list[i];
    	IPString += inet_ntoa(TempAddr);
    	IPString += ", ";
    }

    ASSERT(IPString.length()>0);
	IPString.erase(IPString.length()-2);

    int len = ConvertToWideCharString(IPString.c_str(), NULL, 0);
    wzIPString = new WCHAR[len+1];
    i = ConvertToWideCharString(IPString.c_str(), wzIPString.get(), len+1);
    ASSERT (i);
    wzIPString[len] = '\0';
}


void InitBindingIPAddress()
/*++

Routine Description:
	Get IP adress for binding.
	on NON cluster machine it return INADDR_ANY.
	on cluster machine it will:
		1. search for reg key with binding IP
		2. if it is valid IP will return it
		3. look for non priavte IP, and return it
		4. if not found will return 1st IP it find

Arguments:
    None.

Return Value:
	None.
	
--*/
{
	//
	// Get income binding IP from registry
	//
    RegEntry registry(0, MSMQ_BIND_INTERFACE_IP_STR);
    AP<WCHAR> pRetStr;
    CmQueryValue(registry, &pRetStr);

	if (!IsLocalSystemCluster() && (pRetStr.get() == NULL))
    {
    	sBindingIP = INADDR_ANY;
    	return;
	}

	//
	// Get the list of machine IPs from winsock
	//
    PHOSTENT phe = gethostbyname(NULL);
	if((phe == NULL) || (phe->h_addr_list[0] == NULL))
	{
		DWORD gle = WSAGetLastError();

		ASSERT(("must have an IP address", 0));

		TrERROR(NETWORKING, "failed to retrieve address of %ls computer. %!winerr!", g_szMachineName, gle);
		throw bad_win32_error(gle);
	}

    if(pRetStr.get() != NULL)
    {
    	ULONG RequiredIP = StIPWStringToULONG(pRetStr.get());
    	//
    	// checking if the IP from registry is ours
    	//
	    for (DWORD i = 0; phe->h_addr_list[i] != NULL; i++)
	    {
			if (RequiredIP == *(ULONG*)phe->h_addr_list[i])
			{
				sBindingIP = RequiredIP;
				TrTRACE(NETWORKING, "Cluster is listening on ip=%s found in registry", inet_ntoa(*(in_addr*)&sBindingIP));
				return;
			}
	    }

		if (!IsLocalSystemCluster())
	    {
	    	if (i != 1)
	    	{
	    		AP<WCHAR> wzIPString;
	    		GetIPAddressAsString(phe, wzIPString);
    			EvReport(EVENT_ERROR_MSMQ_CLUSTER_BIND_IP_NOT_EXIST, 4, pRetStr.get(), MSMQ_BIND_INTERFACE_IP_STR, L"INADDR_ANY", wzIPString.get());
	    	}
	    	
	    	sBindingIP = INADDR_ANY;
	    	return;
		}
    }

	
	//
	// No valid IP in registry
	// we will search for IP which is not Cluster internal use IP
	//
	std::list<ULONG> ClusterPrivateIPs;
	GetPrivateClusterIPs(ClusterPrivateIPs);
    for (DWORD i = 0; phe->h_addr_list[i] != NULL; i++)
    {
    	in_addr TempAddr;
    	TempAddr.s_addr = *(ULONG*)phe->h_addr_list[i];
    	
		bool flag = false;
    	for (std::list <ULONG>::const_iterator IPIter = ClusterPrivateIPs.begin();
    		 IPIter != ClusterPrivateIPs.end();
    		 IPIter++)
		{
			if (TempAddr.s_addr == *IPIter)
			{
				flag = true;
				break;
			}
		}
    	if (!flag)
    	{
    		sBindingIP = TempAddr.s_addr;
		}
    }
	if (sBindingIP == INADDR_NONE)
	{
		sBindingIP = *(ULONG*)phe->h_addr_list[0];
 	}

	if (i != 1)
	{
	    AP<WCHAR> wzIPString;
	    GetIPAddressAsString(phe, wzIPString);

		WCHAR wzAddressText[64];
		ConvertToWideCharString(inet_ntoa(*(in_addr*)&sBindingIP), wzAddressText, TABLE_SIZE(wzAddressText));
		wzAddressText[STRLEN(wzAddressText)] = '\0';
	
		if ((pRetStr.get() != NULL))
		{
			EvReport(EVENT_ERROR_MSMQ_CLUSTER_BIND_IP_NOT_EXIST, 4, pRetStr.get(), MSMQ_BIND_INTERFACE_IP_STR, wzAddressText, wzIPString.get());
		}
		else
		{
			EvReport(EVENT_INFO_MSMQ_CLUSTER_NO_BIND_IP_IN_REGISTRY, 3, wzAddressText, MSMQ_BIND_INTERFACE_IP_STR, wzIPString.get());
		}
	}
	
	TrTRACE(NETWORKING, "Cluster is listening on ip=%s", inet_ntoa(*(in_addr*)&sBindingIP));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmwarning.h ===
#include <warning.h>

// There is a MIDL bug #91337 that generates warnings in qm2qm_s.c.
// Until it is solved we need to ignore warning 4090 (Win64) and
// warning 4047 (Win32).
// This is done using local warning file that is included in every
// compiled .c file.   erezh 3-May-2000
#ifndef __cplusplus
    #ifdef _WIN64
        #pragma warning(disable:4090)
    #else
        #pragma warning(disable:4047)
    #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmthrd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmthrd.cpp

Abstract:


Author:

    Uri Habusha (urih)

--*/
#include "stdh.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "ac.h"
#include "qmutil.h"
#include "qal.h"
#include "session.h"
#include "xact.h"
#include "xactout.h"
#include "xactin.h"
#include "localsend.h"
#include "CDeferredExecutionList.h"
#include "qmacapi.h"
#include <xactstyl.h>
#include <Fn.h>

#include <strsafe.h>

#include "qmthrd.tmh"

extern HANDLE g_hAc;
extern CCriticalSection g_csGroupMgr;

static void WINAPI RequeueDeferredExecutionRoutine(CQmPacket* p);
CDeferredExecutionList<CQmPacket> g_RequeuePacketList(RequeueDeferredExecutionRoutine);

static WCHAR *s_FN=L"qmthrd";

#ifdef _DEBUG

static void DBG_MSGTRACK(CQmPacket* pPkt, LPCWSTR msg)
{
    OBJECTID MessageId;
    pPkt->GetMessageId(&MessageId);
    TrTRACE(GENERAL, "%ls: ID=" LOG_GUID_FMT "\\%u", msg, LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier);
}


static void DBG_CompletionKey(LPCWSTR Key, DWORD dwErrorCode)
{
    DWORD dwthreadId = GetCurrentThreadId();

    if(dwErrorCode == ERROR_SUCCESS)
    {
        TrTRACE(GENERAL, "%x: GetQueuedCompletionPort for %ls. time=%d", dwthreadId,  Key, GetTickCount());
    }
    else
    {
        TrWARNING(GENERAL, "%x: GetQueuedCompletionPort for %ls FAILED, Error=%u. time=%d", dwthreadId, Key, dwErrorCode, GetTickCount());
    }
}

#else
#define DBG_MSGTRACK(pPkt, msg)             ((void)0)
#define DBG_CompletionKey(Key, dwErrorCode) ((void)0)
#endif



/*======================================================

Function:       QMAckPacket

Description:    This packet requires acking, it could
                be that the admin queue does NOT exists

NOTE:           The packet should be copied now and canot
                be overwriten

Return Value:   VOID

========================================================*/
static
void
QMAckPacket(
    const CBaseHeader* pBase,
    CPacket* pDriverPacket,
    USHORT usClass,
    BOOL fUser,
    BOOL fOrder
    )
{
    ASSERT(fUser || fOrder);

    CQmPacket qmPacket(const_cast<CBaseHeader*>(pBase), pDriverPacket);

	//
	// Send an order ack
	// Order acks for http messages are sent through the CInSequence
	//
	try
	{
		QUEUE_FORMAT qdDestQueue;
		qmPacket.GetDestinationQueue(&qdDestQueue);
		if(fOrder)
	    {
	        OBJECTID MessageId;
	        qmPacket.GetMessageId(&MessageId);

			HRESULT hr;
			if (!FnIsDirectHttpFormatName(&qdDestQueue))
	        {
	        	hr = SendXactAck(&MessageId,
	                    	qdDestQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT ,
					    	qmPacket.GetSrcQMGuid(),
	                    	qmPacket.GetSrcQMAddress(),
							usClass,
	                    	qmPacket.GetPriority(),
	                    	qmPacket.GetSeqID(),
	                    	qmPacket.GetSeqN(),
	                    	qmPacket.GetPrevSeqN(),
	                    	&qdDestQueue);
			}
			else
			{
		        ASSERT(g_pInSeqHash);
	
				R<CInSequence> pInSeq = g_pInSeqHash->LookupCreateSequence(&qmPacket);
				ASSERT(pInSeq.get() != NULL);
				hr = pInSeq->SendSrmpXactFinalAck(qmPacket,usClass); 
			}
		
	        if (FAILED(hr))
	        {
	        	TrERROR(GENERAL, "Failed sending Xact Ack. Hresult=%!hresult!", hr);
	        }
	    }

	    // Send user ack, except the cases when .
	    // the source QM produces them based on the SeqAck.
	    if(fUser)
	    {
	        qmPacket.CreateAck(usClass);
	    }
	}
	catch (const exception&)
	{
	    QmAcAckingCompleted(
	            g_hAc,
	            pDriverPacket,
	            eDeferOnFailure
	            );
		throw;
	}

    QmAcAckingCompleted(
            g_hAc,
            pDriverPacket,
            eDeferOnFailure
            );
}

/*======================================================

Function:       QMTimeoutPacket

Description:    This packet timer has expired,
                it is an ordered packet

Return Value:   VOID

========================================================*/
static
void
QMTimeoutPacket(
    const CBaseHeader* pBase,
    CPacket * pDriverPacket,
    BOOL fTimeToBeReceived
    )
{
    SeqPktTimedOut(const_cast<CBaseHeader *>(pBase), pDriverPacket, fTimeToBeReceived);
}

/*======================================================

Function:       QMUpdateMessageID

Description:

NOTE:

Return Value:   VOID

========================================================*/
static void QMUpdateMessageID(ULONGLONG MessageId)
{
    ULONG MessageIdLow32 = static_cast<ULONG>(MessageId & 0xFFFFFFFF);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    SetFalconKeyValue(
        MSMQ_MESSAGE_ID_LOW_32_REGNAME,
        &dwType,
        &MessageIdLow32,
        &dwSize
        );

    ULONG MessageIdHigh32 = static_cast<ULONG>(MessageId >> 32);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    SetFalconKeyValue(
        MSMQ_MESSAGE_ID_HIGH_32_REGNAME,
        &dwType,
        &MessageIdHigh32,
        &dwSize
        );
}


/*======================================================

Function:       QMWriteEventLog

Description:

NOTE:

Return Value:   VOID

========================================================*/
static void QMWriteEventLog(ACPoolType pt, BOOL fSuccess, ULONG ulFileCount)
{
    WCHAR wcsFileName[MAX_PATH];
    WCHAR wcsPathName[MAX_PATH];
    LPCWSTR regname = NULL;

    HRESULT hr = StringCchPrintf(wcsFileName, TABLE_SIZE(wcsFileName), L"\\r%07x.mq", (ulFileCount & 0x0fffffff));
    if (FAILED(hr))
    {
    	TrERROR(GENERAL, "StringCchPrintf Failed. Hresult=%!hresult!", hr);
    	ASSERT(("StringCchPrintf Failed",0));
    	return;
    }

    switch(pt)
    {
        case ptReliable:
            wcsFileName[1] = L'r';
            regname = MSMQ_STORE_RELIABLE_PATH_REGNAME;
            break;

        case ptPersistent:
            wcsFileName[1] = L'p';
            regname = MSMQ_STORE_PERSISTENT_PATH_REGNAME;
            break;

        case ptJournal:
            wcsFileName[1] = L'j';
            regname = MSMQ_STORE_JOURNAL_PATH_REGNAME;
            break;

        case ptLastPool:
            wcsFileName[1] = L'l';
            regname = MSMQ_STORE_LOG_PATH_REGNAME;
            break;

        default:
            ASSERT(0);
    }

    if(!GetRegistryStoragePath(regname, wcsPathName, MAX_PATH, wcsFileName))
    {
        return;
    }

    EvReport(
        (fSuccess ? AC_CREATE_MESSAGE_FILE_SUCCEDDED : AC_CREATE_MESSAGE_FILE_FAILED),
        1,
        wcsPathName
        );
}


static const DWORD xMustSucceedTimeout = 1000;

/*======================================================

Function:       GetServiceRequestMustSucceed

Description:    Get the next service request from the AC driver
                This function MUST succeed.

Arguments:      hDrv - HANDLE to AC driver

========================================================*/
static void GetServiceRequestMustSucceed(HANDLE hDrv, QMOV_ACGetRequest* pAcRequestOv)
{
    ASSERT(hDrv != NULL);
    ASSERT(pAcRequestOv != NULL);

    for(;;)
    {
        HRESULT rc = QmAcGetServiceRequest(
                        hDrv,
                        &(pAcRequestOv->request),
                        &pAcRequestOv->qmov
                        );
        if(SUCCEEDED(rc))
            return;

        TrERROR(GENERAL, "Failed to get driver next service request, sleeping 1sec. Error: %!status!", rc);
        ::Sleep(xMustSucceedTimeout);
    }
}

/*======================================================

Function:        CreateAcPutPacketRequest

Description:     Create put packet overlapped structure

Arguments:

Return Value:    MQ_OK if the creation successeded, MQ_ERROR otherwise

Thread Context:

History Change:

========================================================*/

HRESULT CreateAcPutPacketRequest(IN CTransportBase* pSession,
                                 IN DWORD_PTR dwPktStoreAckNo,
                                 OUT QMOV_ACPut** ppAcPutov
                                )
{
    //
    // Create an overlapped for AcPutPacket
    //
    *ppAcPutov = NULL;
    try
    {
        *ppAcPutov = new QMOV_ACPut();
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 20);
    }

    (*ppAcPutov)->pSession = pSession;
    (*ppAcPutov)->dwPktStoreAckNo = dwPktStoreAckNo;

    return MQ_OK;
}

/*======================================================

Function:        CreateAcPutOrderedPacketRequest

Description:     Create put ordered packet overlapped structure

Arguments:

Return Value:    MQ_OK if the creation successeded, MQ_ERROR otherwise

Thread Context:

History Change:

========================================================*/

HRESULT CreateAcPutOrderedPacketRequest(
                                 IN  CQmPacket      *pPkt,
                                 IN  HANDLE         hQueue,
                                 IN  CTransportBase *pSession,
                                 IN  DWORD_PTR       dwPktStoreAckNo,
                                 OUT QMOV_ACPutOrdered** ppAcPutov
                                )
{
    //
    // Create an overlapped for AcPutPacket
    //
    *ppAcPutov = NULL;
    try
    {
        *ppAcPutov = new QMOV_ACPutOrdered();
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 30);
    }

    (*ppAcPutov)->pSession = pSession;
    (*ppAcPutov)->dwPktStoreAckNo = dwPktStoreAckNo;
    (*ppAcPutov)->packetPtrs.pPacket = pPkt->GetPointerToPacket();
    (*ppAcPutov)->packetPtrs.pDriverPacket = pPkt->GetPointerToDriverPacket();
    (*ppAcPutov)->hQueue      = hQueue;

    return MQ_OK;
}


void QmpGetPacketMustSucceed(HANDLE hGroup, QMOV_ACGetMsg* pGetOverlapped)
{
    pGetOverlapped->hGroup = hGroup;
    pGetOverlapped->pSession = NULL;

    for(;;)
    {
        HRESULT rc = QmAcGetPacket(
                        hGroup,
                        pGetOverlapped->packetPtrs,
                        &pGetOverlapped->qmov
                        );

        if(SUCCEEDED(rc))
            return;

        TrERROR(GENERAL, "Failed to get packet from group %p, sleeping 1sec. Error: %!status!", hGroup, rc);
        ::Sleep(xMustSucceedTimeout);
    }
}


VOID WINAPI GetServiceRequestFailed(EXOVERLAPPED* pov)
{	
	//
	// Get request failed.
	//
    ASSERT(FAILED(pov->GetStatus()));
    TrERROR(GENERAL, "Failed getting driver service request, retrying. Error: %!status!", pov->GetStatus());

	//
	// Issue a new request
	//
    QMOV_ACGetRequest* pParam = CONTAINING_RECORD (pov, QMOV_ACGetRequest, qmov);
    GetServiceRequestMustSucceed(g_hAc, pParam);
}


VOID WINAPI GetServiceRequestSucceeded(EXOVERLAPPED* pov)
{
    QMOV_ACGetRequest* pParam;
    auto_DeferredPoolReservation ReservedPoolItem(1);

    //
    // GetQueuedCompletionStatus Complete successfully but the
    // ACGetServiceRequest failed. This can happened only if the
    // the service request parameters are not correct, or the buffer
    // size is small.
    // This may also happen when service is shut down.
    //
    ASSERT(SUCCEEDED(pov->GetStatus()));
    DBG_CompletionKey(L"GetServiceRequestSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 185);

    try
    {
        pParam = CONTAINING_RECORD (pov, QMOV_ACGetRequest, qmov);

        CACRequest* pRequest = &pParam->request;
        switch(pParam->request.rf)
        {
            case CACRequest::rfAck:
            	ReservedPoolItem.detach();
                QMAckPacket(
                    pRequest->Ack.pPacket,
                    pRequest->Ack.pDriverPacket,
                    (USHORT)pRequest->Ack.ulClass,
                    pRequest->Ack.fUser,
                    pRequest->Ack.fOrder
                    );
                break;

            case CACRequest::rfStorage:
            	ReservedPoolItem.detach();
                QmpStorePacket(
                    pRequest->Storage.pPacket,
                    pRequest->Storage.pDriverPacket,
                    pRequest->Storage.pAllocator,
					pRequest->Storage.ulSize
                    );
                break;

            case CACRequest::rfCreatePacket:
            	ReservedPoolItem.detach();
                QMpCreatePacket(
                    pRequest->CreatePacket.pPacket,
                    pRequest->CreatePacket.pDriverPacket,
                    pRequest->CreatePacket.fProtocolSrmp
                    );
                break;

            case CACRequest::rfTimeout:
            	ReservedPoolItem.detach();
                QMTimeoutPacket(
                    pRequest->Timeout.pPacket,
                    pRequest->Timeout.pDriverPacket,
                    pRequest->Timeout.fTimeToBeReceived
                    );
                break;

            case CACRequest::rfMessageID:
                QMUpdateMessageID(
                    pRequest->MessageID.Value
                    );
                break;

            case CACRequest::rfEventLog:
                QMWriteEventLog(
                    pRequest->EventLog.pt,
                    pRequest->EventLog.fSuccess,
                    pRequest->EventLog.ulFileCount
                    );
                break;

            case CACRequest::rfRemoteRead:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemoteRead");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);
                   CBaseRRQueue* pRRQueue = (CBaseRRQueue *)pRequest->Remote.cli_pQMQueue;

                   pRRQueue->RemoteRead(pRequest);
                }
                break;

            case CACRequest::rfRemoteCloseQueue:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemoteCloseQueue");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);

				   //
				   // Release CBaseRRQueue - the application close the queue.
				   // This is the matching release to the AddRef when
				   // we create the queue and gave the Handle to the application.
				   //
                   R<CBaseRRQueue> pRRQueue = (CBaseRRQueue *) pRequest->Remote.cli_pQMQueue;
                }
                break;

            case CACRequest::rfRemoteCreateCursor:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemoteCreateCursor");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);
                   CBaseRRQueue* pRRQueue = (CBaseRRQueue *) pRequest->Remote.cli_pQMQueue;

                   pRRQueue->RemoteCreateCursor(pRequest);
                }
                break;

            case CACRequest::rfRemoteCloseCursor:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemoteCloseCursor");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);
                   CBaseRRQueue* pRRQueue = (CBaseRRQueue *) pRequest->Remote.cli_pQMQueue;

                   pRRQueue->RemoteCloseCursor(pRequest);
                }
                break;

            case CACRequest::rfRemoteCancelRead:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemoteCancelRead");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);
                   CBaseRRQueue* pRRQueue = (CBaseRRQueue *) pRequest->Remote.cli_pQMQueue;

                   pRRQueue->RemoteCancelRead(pRequest);
                }
                break;

            case CACRequest::rfRemotePurgeQueue:
                {
                   TrTRACE(GENERAL, "QmMainThread: rfRemotePurgeQueue");

				   //
				   // cli_pQMQueue is the real pointer to the queue.
				   //
                   ASSERT(pRequest->Remote.cli_pQMQueue);
                   CBaseRRQueue* pRRQueue = (CBaseRRQueue *) pRequest->Remote.cli_pQMQueue;

                   pRRQueue->RemotePurgeQueue();
                }
                break;

            default:
              ASSERT(0);
        }
    }
    catch(const exception&)
    {
        //
        //  No resources; Continue the Service request.
        //
        LogIllegalPoint(s_FN, 61);
    }

    GetServiceRequestMustSucceed(g_hAc, pParam);
}


static
R<CQueue>
QmpLookupQueueMustSucceed(
    QUEUE_FORMAT *pQueueFormat
    )
/*++

  Routine Description:
	The routine retrieves a queue that is expected to be in the look up map
	The routine should function in low resources situations, thus it contains
	a loop in case of bad_alloc exceptions

	NOTE:
	1. This function is called only when the queue is expected to be found
	2. The look up routine increases the queue reference count.
    3. Bug 664307. Make sure that this function is called only from
       GetMsg and GetNonActive. If it will be called from other places then
       need to check the fourth parameter of LookupQueue.

  Arguments:
	- pQueueFormat - The format by which to look up the queue

  Return:
	A pointer to the queue.

 --*/
{
    for(;;)
    {
        try
        {
            //
            // Win bug 664307.
            // This function is called only from GetMsg and GetNonActvie.
            // For these case, when we intend to send a message, the
            // fourth parameter to LookupQueue is true.
            //
        	CQueue* pQueue;
        	BOOL fSuccess = QueueMgr.LookUpQueue(
									pQueueFormat,
									&pQueue,
                                    false,
									true);
        	ASSERT(("We expect both fSuccess to be TRUE and pQueue to hold a value",fSuccess && (pQueue != NULL)));
			DBG_USED(fSuccess);

    	    return pQueue;
        }
        catch (const bad_format_name&)
        {
		    TrERROR(GENERAL, "Bad format name encountered. queue Direct name is:%ls",pQueueFormat->DirectID());
		    ASSERT(("Since the queue should already exist in the lookup map, we certainly do not expect to get a bad name exception for it",0));
        	return NULL;
        }
        catch (const exception&)
        {
	        TrERROR(GENERAL, "Failed to LookUp queue, retrying");
	        ::Sleep(xMustSucceedTimeout);
        }
    }
}


static
void
QmpPutPacketMustSucceed(
    HANDLE hQueue,
    CPacket * pDriverPacket
    )
{
    for(;;)
    {
    	try
    	{
        	QmAcPutPacket(hQueue, pDriverPacket, eDoNotDeferOnFailure);
        	return;
    	}
    	catch (const bad_hresult &)
    	{
	        ::Sleep(xMustSucceedTimeout);
    	}
    }
}


static
void
QmpRequeueInternal(
    CQmPacket *pQMPacket
    )
/*++

  Routine Description:
	The routine requeues a packet to the driver

	NOTE:
	    1. This function is called only when the packet already exists in a queue
	    2. The routine may throw an exception
	
  Arguments:
	- pQMPacket - A QM packet to requeue

  Return:
  	none

 --*/
{
	//
	// Lookup the queue
	//
    BOOL fGetRealQ = QmpIsLocalMachine(pQMPacket->GetSrcQMGuid()) ||
                     QmpIsLocalMachine(pQMPacket->GetConnectorQM());

    QUEUE_FORMAT DestinationQueue;
    pQMPacket->GetDestinationQueue(&DestinationQueue, !fGetRealQ);
		
    CQueue* pQueue;
	BOOL fSuccess = QueueMgr.LookUpQueue(
							&DestinationQueue,
							&pQueue,
                            false,
                            true
							);
	
	ASSERT(("We expect both fSuccess to be TRUE and pQueue to hold a value",fSuccess && (pQueue != NULL)));
	DBG_USED(fSuccess);
	R<CQueue> ref = pQueue;

	//
	// Requeue the packet
	//
	pQueue->Requeue(pQMPacket);
}


void
QmpRequeueAndDelete(
    CQmPacket *pQMPacket
    )
/*++

  Routine Description:
	The routine requeues a packet to the driver and releases the QM packet memory
	If the requeue operation fails, the routine deffers the requeue to a later
	stage

	NOTE:
	    This function is called only when the packet already exists in a queue
	
  Arguments:
	- pQMPacket - A QM packet to requeue

  Return:
  	none

 --*/
{
    try
    {
    	QmpRequeueInternal(pQMPacket);
    	delete pQMPacket;
    }
    catch (const exception&)
    {
    	//
    	// Deferr the requeue operation
    	//
    	g_RequeuePacketList.insert(pQMPacket);
    }
}


void
QmpRequeueMustSucceed(
    CQmPacket *pQMPacket
    )
/*++

  Routine Description:
	The routine requeues a packet to the driver. In case of failure it loops
	until success.

	NOTE:
	    1. This function is called only when the packet already exists in a queue
	    2. This function should not be called within a critical section
	
  Arguments:
	- pQMPacket - A QM packet to requeue

  Return:
  	none

 --*/
{
	for (;;)
	{
	    try
	    {
	    	QmpRequeueInternal(pQMPacket);
	    	return;
		}
	    catch (const exception&)
	    {
	    }

        TrERROR(GENERAL, "Failed to requeue packet, Looping");
        ::Sleep(xMustSucceedTimeout);
	}
}


VOID WINAPI GetMsgFailed(EXOVERLAPPED* pov)
{
    ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetMsgFailed", pov->GetStatus());

	TrERROR(GENERAL, "Failed to get message from the driver  Status returned: %!status!", pov->GetStatus());

    //
    // Decrement Session Reference count on get message from the session group.
    // the refernce count is increment when create the session ghroup or after
    // session resume.
    //
    // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
    // Decrement the refernce count only after handling of sending message
    // is completed
    //      Uri Habusha (urih), 17-6-98
    //
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);
    pParam->pSession->Release();
}


VOID WINAPI GetMsgSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    ASSERT( pov->GetStatus() != STATUS_PENDING);

    DBG_CompletionKey(L"GetMsgSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 212);

    BOOL fGetNext = FALSE;
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);

    ASSERT(pParam->packetPtrs.pPacket != NULL);


    //
    // Create CQmPacket object
    //
    CQmPacket* pPkt  = NULL;
    try
    {
        pPkt = new CQmPacket(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
    }
    catch(const bad_alloc&)
    {
        //
        // No resource. Return the packet to queue
        //
        LogIllegalPoint(s_FN, 62);
        CQmPacket QmPkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
        QmpRequeueMustSucceed(&QmPkt);

        //
        // Decrement Session Reference count on get message from the session group.
        // the refernce count is increment when create the session ghroup or after
        // session resume.
        //
        // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
        // Decrement the refernce count only after handling of sending message
        // is completed
        //      Uri Habusha (urih), 17-6-98
        //
        pParam->pSession->Release();

        return;
    }

    //
    // Check the packet sent to transacted foreign queue that was opened
    // offline. In such a case we don't know the connector QM during packet
    // generation. we need to update it now.
    //
    if (pPkt->ConnectorQMIncluded() &&
        (*(pPkt->GetConnectorQM()) == GUID_NULL))
    {
        QUEUE_FORMAT DestinationQueue;

        pPkt->GetDestinationQueue(&DestinationQueue);

        R<CQueue> Ref = QmpLookupQueueMustSucceed(&DestinationQueue);
        CQueue *pQueue = Ref.get();

        if (pQueue->IsForeign() && pQueue->IsTransactionalQueue())
        {
            ASSERT((pQueue->GetConnectorQM() != NULL) &&
                   (*(pQueue->GetConnectorQM()) != GUID_NULL));

            pPkt->SetConnectorQM(pQueue->GetConnectorQM());

            BOOL fSuccess = FlushViewOfFile(
                                pPkt->GetConnectorQM(),
                                sizeof(GUID)
                                );
            ASSERT(fSuccess);
			DBG_USED(fSuccess);

        }
    }

    HRESULT rc;

    // Do we need exactly-once receiving processing?
    if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
    {
        //
        // Ordered packet on the source node
        // Packet came out of driver
        //

        CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;

		BOOL fSend = FALSE;
		try
		{
			fSend = g_OutSeqHash.PreSendProcess(pPkt, true) || pInfo->InConnectorQueue();


			if(!fSend)
			{
			    // Not sending but keeping
			    fGetNext = TRUE;
			    // For ordered packet on the source node - inserting in ordering resend set
	
				g_OutSeqHash.PostSendProcess(pPkt);
	        }
	    }
		catch(const bad_alloc&)
	    {
	 		fSend = FALSE;
	 		fGetNext = TRUE;
	 		QmpRequeueAndDelete(pPkt);
	    }
 
		if (fSend)
	  	{
	  		DBG_MSGTRACK(pPkt, _T("GetMessage (EOD)"));
	  
			// Sending the packet really
	        rc = pParam->pSession->Send(pPkt, &fGetNext);
	  	}
	}
    else
    {
        //
        //  Non-Ordered packet or this is not a source node
        //

        // Sending the packet really
        DBG_MSGTRACK(pPkt, _T("GetMessage"));
        rc = pParam->pSession->Send(pPkt, &fGetNext);
    }

    if (fGetNext)
    {
        //
        // create new GetPacket request from Session group
        //
        pParam->pSession->GetNextSendMessage();
    }


    //
    // Decrement Session Reference count on get message from the session group.
    // the refernce count is increment when create the session ghroup or after
    // session resume.
    //
    // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
    // Decrement the refernce count only after handling of sending message
    // is completed
    //      Uri Habusha (urih), 17-6-98
    //
    pParam->pSession->Release();
}



VOID WINAPI GetNonactiveMessageFailed(EXOVERLAPPED* pov)
{
    ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetNonactiveMessageFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 211);

    //
    // create new GetPacket request from NonActive group
    //
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);
	QmpGetPacketMustSucceed(pParam->hGroup, pParam);
}


VOID WINAPI GetNonactiveMessageSucceeded(EXOVERLAPPED* pov)
{
	ASSERT(SUCCEEDED(pov->GetStatus()));

    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);

    DBG_CompletionKey(L"GetNonactiveMessageSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 210);

    try
    {
        CQmPacket QmPkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);

        ASSERT(QmPkt.GetType() == FALCON_USER_PACKET);
        //
        // Get destination queue. Using for finding the CQueue object
        //

        QUEUE_FORMAT DestinationQueue;

        BOOL fGetRealQ  = QmpIsLocalMachine(QmPkt.GetSrcQMGuid()) ||
                          QmpIsLocalMachine(QmPkt.GetConnectorQM());

        QmPkt.GetDestinationQueue(&DestinationQueue, !fGetRealQ);

        R<CQueue> Ref   = QmpLookupQueueMustSucceed(&DestinationQueue);
        CQueue*  pQueue = Ref.get();

        //
        // Return the packet to the queue. It will call immediatly
        // since there is a pending request created for that new session.
        // Please note: The non active group GetPacket request should NOT
        // be applied prior to this call.
        //
        QmpPutPacketMustSucceed(
                pQueue->GetQueueHandle(),
                pParam->packetPtrs.pDriverPacket
                );

		//
		// Execute any pending requeue requests
		//
		g_RequeuePacketList.ExecuteDefferedItems();
		if (!g_RequeuePacketList.IsExecutionDone())
		{
		    //
		    // We did not finish the deferred execution,
		    // Create new GetPacket request from NonActive group so that we will
		    // be invoked again to retry
		    //
		    QmpGetPacketMustSucceed(pParam->hGroup, pParam);
		    return;
		}

        //
        // When the queue is marked as "OnHold" or the machine is disconnected.
        // The QM move the queue from "NonActive" group to "Disconnected" group.
        // The Queue return to "NonActive" group either when the Queue resumes
        // or the machine is reconnected to the network
        //
        if (QueueMgr.IsOnHoldQueue(pQueue))
        {
            QueueMgr.MoveQueueToOnHoldGroup(pQueue);
        }
        else
        {
            //
            // Create connection
            //
            if (pQueue->IsDirectHttpQueue())
            {
                pQueue->CreateHttpConnection();
            }

			//
			// In Lockdown mode all non HTTP queues will be moved to the "Locked" group.
			//
			else if(QueueMgr.GetLockdown())
			{
				QueueMgr.MoveQueueToLockedGroup(pQueue);
			}

            else if(DestinationQueue.GetType() == QUEUE_FORMAT_TYPE_MULTICAST)
            {
                pQueue->CreateMulticastConnection(DestinationQueue.MulticastID());
            }
            else
            {
                pQueue->CreateConnection();
            }
        }
    }
    catch(const exception&)
    {
        //
        // No resources; Wait a second, before getting the  next packet from non
        // active group, so the system has a chance to free some resources.
        //
        LogIllegalPoint(s_FN, 63);
        Sleep(1000);
    }

    //
    // Create new GetPacket request from NonActive group
    //
    QmpGetPacketMustSucceed(pParam->hGroup, pParam);
}

static
void
GetInternalMessageMustSucceed(
    EXOVERLAPPED* pov,
    QMOV_ACGetInternalMsg* pParam
    )
{

    for(;;)
    {
        HRESULT rc = QmAcGetPacket(
                        pParam->hQueue,
                        pParam->packetPtrs,
                        pov
                        );

        if(SUCCEEDED(rc))
            return;
	
        TrERROR(GENERAL, "Failed to get packet request from internal queue %p, sleeping 1sec. Error: %!status!", pParam->hQueue, rc);
        ::Sleep(1000);
    }
}


VOID WINAPI GetInternalMessageFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetInternalMessageFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 215);

    QMOV_ACGetInternalMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetInternalMsg, qmov);

    GetInternalMessageMustSucceed(pov, pParam);
}


VOID WINAPI GetInternalMessageSucceeded(EXOVERLAPPED* pov)
{
	ASSERT(SUCCEEDED(pov->GetStatus()));

    DBG_CompletionKey(L"AcGetInternalMsg", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 186);

    QMOV_ACGetInternalMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetInternalMsg, qmov);
    ASSERT(pParam->lpCallbackReceiveRoutine != NULL);

    CQmPacket packet(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
    CMessageProperty mp(&packet);


    //
    // Internal message should not have response MQF.
    //
    ASSERT(packet.GetNumOfResponseMqfElements() == 0);
    QUEUE_FORMAT qfResponseQ;
    packet.GetResponseQueue(&qfResponseQ);

    try
    {
        pParam->lpCallbackReceiveRoutine(&mp, &qfResponseQ);
    }
    catch(const exception&)
    {
        //
        //  No resources; nevertheless get next packet
        //
        LogIllegalPoint(s_FN, 66);
    }

    QmAcFreePacket(
				   pParam->packetPtrs.pDriverPacket,
				   0,
		   		   eDeferOnFailure);

    GetInternalMessageMustSucceed(pov, pParam);
}


VOID WINAPI PutPacketFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 218);

    P<QMOV_ACPut> pParam = CONTAINING_RECORD (pov, QMOV_ACPut, qmov);
    ASSERT(pParam->pSession != NULL);

	//
	// Close the connection. Seesion acknowledgemnt will not sent and the message
	// will resent
	//
    Close_Connection(pParam->pSession, L"Put packet to the driver failed");
    (pParam->pSession)->Release();
}


VOID WINAPI PutPacketSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 184);

    P<QMOV_ACPut> pParam = CONTAINING_RECORD (pov, QMOV_ACPut, qmov);
    ASSERT(pParam->pSession != NULL);

    //
    // inform the session to Send stored ack
    //
    if (pParam->dwPktStoreAckNo != 0)
    {
        (pParam->pSession)->SetStoredAck(pParam->dwPktStoreAckNo);
    }

    //
    // Decrement Session refernce count
    //
    (pParam->pSession)->Release();
}


VOID WINAPI PutOrderedPacketFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 219);

    P<QMOV_ACPutOrdered> pParam = CONTAINING_RECORD (pov, QMOV_ACPutOrdered, qmov);
    ASSERT(pParam->pSession != NULL);

    CQmPacket Pkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);

	R<CInSequence> inseq = g_pInSeqHash->LookupSequence(&Pkt);
	ASSERT(inseq.get() != NULL);
	
	//
	// We need to delete all packets that started processing after this one, 
	// because order of packet in queue is determined on receival.
	//
	inseq->FreePackets(&Pkt);

	//
	// Close the connection. Seesion acknowledgemnt will not sent and the message
	// will resent
	//
    Close_Connection(pParam->pSession, L"Put packet to the driver failed");
    (pParam->pSession)->Release();
}



/*======================================================

Function:   PutOrderedPacketSucceeded

Description:  Is called via completion port when the newwly-arrived
                ordered packet is stored with a Received flag.
              Initiates registering it in InSeqHash and waits till
                flush will pass
Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/
VOID WINAPI PutOrderedPacketSucceeded(EXOVERLAPPED* pov)
{
#ifdef _DEBUG
	//
	// Simulate asynchronous failure
	//
	if(FAILED(EVALUATE_OR_INJECT_FAILURE2(MQ_OK, 10)))
	{
		pov->SetStatus(MQ_ERROR);
		PutOrderedPacketFailed(pov);
		return;
	}
#endif

    ASSERT(SUCCEEDED(pov->GetStatus()));

    P<QMOV_ACPutOrdered> pParam = CONTAINING_RECORD (pov, QMOV_ACPutOrdered, qmov);
    DBG_CompletionKey(L"PutOrderedPacketSucceeded", pov->GetStatus());

    CQmPacket Pkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);

	R<CInSequence> inseq = g_pInSeqHash->LookupSequence(&Pkt);
	ASSERT(inseq.get() != NULL);
	
	//
    // We know the packet is stored. 
    // We Need to log the sequence state change and  unfreeze the packet.
    //
	inseq->Register(&Pkt);
	
    ASSERT(pParam->pSession != NULL);
    LogHR(pov->GetStatus(), s_FN, 183);

    // Normal treatment (as in HandlePutPacket)
    if (pParam->dwPktStoreAckNo != 0)
    {
        (pParam->pSession)->SetStoredAck(pParam->dwPktStoreAckNo);
    }
    //
    // Decrement Session refernce count
    //
    (pParam->pSession)->Release();
}


static void WINAPI RequeueDeferredExecutionRoutine(CQmPacket* p)
/*++

Routine Description:
	This routine is used for deferred requeue operations of packets that their
	original requeue operation failed.

	After requeueing the packet, the packet is released

Arguments:
    p - A CQmpacket object

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for  requeue");


	QmpRequeueInternal(p);

	//
	// Delete the packet only if no exception is raised.
	//
	delete p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qos.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    QoS.cpp

Abstract:
    Support for QoS implementation for SIA

Author:
    Yoel Arnon (YoelA) 8-Nov-2000

--*/
#include "stdh.h"
#include <qossp.h>
#include <qospol.h>
#include "qmp.h"
#include "sessmgr.h"
#include "mqexception.h"

#include "QoS.tmh"

static WCHAR *s_FN=L"QoS";


/*======================================================
Function:         FindQoSProtocol

Description:      Looks for a protocol in this computer 
                  that supports QoS
========================================================*/
LPWSAPROTOCOL_INFO FindQoSProtocol(OUT UCHAR **pucBufferToFree)
{
//
// ISSUE-2000/10/22-YoelA:
//      This function is called each time a QoS socket is created. This approach is 
//      not optimized, and may cause a performance problem in case QM needs to contact with
//      a large number of direct queues on different computers. The right way to handle the protocol
//      list is by keeping a protocols cache, and update it using a callback routine. This callback
//      can be registered using WSAProviderConfigChange API.
//      For now, only SIA uses QoS, so unless they complain about performance, we can probably leave this
//      as is.
//

    *pucBufferToFree = 0;

    INT    Protocols[2];

    Protocols[0] = IPPROTO_TCP;
    Protocols[1] = 0;
    DWORD dwSize = 0;

    //
    // First call - get buffer size
    //
	int iStatus = WSAEnumProtocols(	Protocols,
		    					    0,
			                        &dwSize  );
    if (iStatus != SOCKET_ERROR)
    {
        //
        // The only legitimate reason for NOT returning an error
        // here is that there are no protocols, and therefore 
        // iStatus is 0
        //
        if (iStatus != 0)
        {
            ASSERT(0);
            TrERROR(NETWORKING, "FindQoSProtocol - WSAEnumProtocols returned %d, but did not fill the buffer", iStatus);
            LogHR(MQ_ERROR,  s_FN, 10);       
        }

        return 0;
    }

    DWORD dwErrorCode = WSAGetLastError();
    if (dwErrorCode != WSAENOBUFS)
    {
        //
        // Some undefined error happend. Return
        //
        TrERROR(NETWORKING, "FindQoSProtocol - WSAEnumProtocols Failed. Error %d", dwErrorCode);
        LogNTStatus(dwErrorCode,  s_FN, 20);
        ASSERT(0);
        return 0;
    }

    //
    // Allocate the right buffer and continue
    //
    AP<UCHAR>  pProtocolInfoBuf = new UCHAR[dwSize];

    //
    // Call to get the protocols
    //
	iStatus = WSAEnumProtocols(	Protocols,
		    					(LPWSAPROTOCOL_INFO)(UCHAR *)pProtocolInfoBuf,
			                    &dwSize  );

    if (iStatus == SOCKET_ERROR)
    {
        //
        // We should not fail here...
        //
        dwErrorCode = WSAGetLastError();
        TrERROR(NETWORKING, "FindQoSProtocol - WSAEnumProtocols Failed. Error %d", dwErrorCode);
        LogNTStatus(dwErrorCode,  s_FN, 30);
        ASSERT(0);
        return 0;
    }

    //
    // If iStatus is not SOCKET_ERROR, it will contain the number of protocols
    // returned. For readability, we will put it in another variavble named
    // dwNumProtocols
    //
    DWORD dwNumProtocols = iStatus;

    LPWSAPROTOCOL_INFO  pProtoInfo = (LPWSAPROTOCOL_INFO)(UCHAR *)pProtocolInfoBuf;

    DWORD iProtocols;
    for (iProtocols = 0; iProtocols < dwNumProtocols; iProtocols++)
    {
        if (pProtoInfo[iProtocols].dwServiceFlags1 & XP1_QOS_SUPPORTED)
        {
            *pucBufferToFree = pProtocolInfoBuf.detach();
            return &pProtoInfo[iProtocols];
        }
    }

    //
    // No QoS supporting protocol found. .
    //
    TrTRACE(NETWORKING, "FindQoSProtocol - No QoS supported protocol found.");
    LogHR(MQ_ERROR,  s_FN, 40);

    return 0;

}

/*======================================================
Function:         QmpCreateSocket

Description:      Creates a socket (using WSASocket).
                  if Using QoS:
                  Attempts to find a protocol with QoS support, and use it if possible.
                  Otherwise, creates a regular socket.
                  Returns INVALID_SOCKET if fails

========================================================*/
SOCKET QmpCreateSocket(bool fQoS)
{
    SOCKET sReturnedSocket;

    LPWSAPROTOCOL_INFO pProtoInfo = 0;
    AP<UCHAR> pucProtocolsBufferToFree;

    if (fQoS)
    {
        PUCHAR pTempBufferToFree;
        pProtoInfo = FindQoSProtocol(&pTempBufferToFree);
        pucProtocolsBufferToFree = pTempBufferToFree;
    }

    sReturnedSocket = WSASocket( AF_INET,
                        SOCK_STREAM,
                        0,
                        pProtoInfo,
                        0,
                        WSA_FLAG_OVERLAPPED ) ;

    if(sReturnedSocket == INVALID_SOCKET)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "Failed to create a socket. %!winerr!", gle);
        LogNTStatus(gle,  s_FN, 100);
		throw bad_win32_error(gle);
    }

    return sReturnedSocket;
}


//
// The following two functions (BuildPsBuf, ConstructAppIdPe) contruct 
// the provider specific buffer of QoS.
// They were copied from Ramesh Pabbati's mail, with some modifications.
// (YoelA - 12-Oct-2000)
//
const USHORT x_usPolicyInfoHeaderSize = sizeof(RSVP_POLICY_INFO) - sizeof(RSVP_POLICY);
/*======================================================
Function:         ConstructAppIdPe

Description:      
========================================================*/
USHORT 
ConstructAppIdPe(
    LPCSTR               szAppName, 
    LPCSTR               szPolicyLocator,
    ULONG               *pulAppIdPeBufLen,
    LPRSVP_POLICY_INFO  pPolicyInfo)
/*+++
 *  Description:
 *      This routine generates the application identity PE give the name
 *      and policy locator strings for the application. 
 *      	
 *      The first argument szAppName is used to construct the CREDENTIAL 
 *      attribute of the Identity PE. The subtype is set to ASCII_ID.
 *      The second argument szPolicyLocator is used to construct the
 *      POLICY_LOCATOR attribute of the Identity PE. They subtype is
 *      set to ASCII_DN.
 *
 *      For details on the Identity Policy Elements,
 *      refer to rfc2752 (http://www.ietf.org/rfc/rfc2752.txt)
 *      	
 *      For details on the App Id,
 *      refer to rfc2872 (http://www.ietf.org/rfc/rfc2872.txt)
 *      	
 *      For Microsoft implementation and the original sample, refer to
 *      http://wwd/windows/server/Technical/networking/enablingQOS.asp
 *
 *      The PE is generated in the supplied buffer. If the length of
 *      the buffer is not enough required length is returned.
 *      	
 *  Parameters:  szAppName          app name, string, caller supply
 *               szPolicyLocator    Policy Locator string, caller supply
 *               pulAppIdPeBufLen   length of caller allocated buffer
 *               pPolicyInfo        pointer to caller allocated buffer
 *      		 
 *  Return Values:
 *       0 : Fail, pulAppIdPeBufLen will hold number of bytes needed
 *      >0 : Length of the application indetity PE
--*/
{
    if ( !szAppName ||  !szPolicyLocator )
        return 0;

    USHORT usPolicyLocatorAttrLen = numeric_cast<USHORT>(IDPE_ATTR_HDR_LEN + strlen(szPolicyLocator));
    USHORT usAppIdAttrLen         = numeric_cast<USHORT>(IDPE_ATTR_HDR_LEN + strlen(szAppName));
    
    // Calculcate the length of the buffer required
    USHORT usTotalPaddedLen = RSVP_POLICY_HDR_LEN + 
                              RSVP_BYTE_MULTIPLE(usAppIdAttrLen) +
                              RSVP_BYTE_MULTIPLE(usPolicyLocatorAttrLen);
	       
    // If the supplied buffer is not long enough, return error and the
    // required buffer length
    if (*pulAppIdPeBufLen < usTotalPaddedLen) {
            *pulAppIdPeBufLen = usTotalPaddedLen;
        return 0;
    }

    ASSERT(pPolicyInfo != 0);

	RSVP_POLICY *pAppIdPe = (RSVP_POLICY *)pPolicyInfo->PolicyElement;
    memset(pAppIdPe, 0, usTotalPaddedLen);

    pPolicyInfo->NumPolicyElement = 1;
    pPolicyInfo->ObjectHdr.ObjectType = RSVP_OBJECT_POLICY_INFO;
    pPolicyInfo->ObjectHdr.ObjectLength = x_usPolicyInfoHeaderSize;    
    
    
    // Set up RSVP_POLICY header
    pAppIdPe->Len  = usTotalPaddedLen;
    pAppIdPe->Type = PE_TYPE_APPID;
    
    // Application ID Policy Element (PE) attributes follow the PE header
    
    IDPE_ATTR   *pRsvp_pe_app_attr = (IDPE_ATTR *)((char*)pAppIdPe + RSVP_POLICY_HDR_LEN);

    // Construct the POLICY_LOCATOR attribute with simple ASCII_DN 
    //  subtype using the supplied Policy Locator.  Since the RSVP service 
    //  does not look into the attributes, set the attribute length in 
    //  network order.
    pRsvp_pe_app_attr->PeAttribLength  = htons(usPolicyLocatorAttrLen);
    pRsvp_pe_app_attr->PeAttribType    = PE_ATTRIB_TYPE_POLICY_LOCATOR;
    pRsvp_pe_app_attr->PeAttribSubType = POLICY_LOCATOR_SUB_TYPE_ASCII_DN;
    strcpy((char *)pRsvp_pe_app_attr->PeAttribValue, szPolicyLocator);
    
    // Advance pRsvp_pe_app_attr 
    pRsvp_pe_app_attr = (IDPE_ATTR *)
	   ((char*)pAppIdPe + 
           RSVP_POLICY_HDR_LEN + 
	   RSVP_BYTE_MULTIPLE(usPolicyLocatorAttrLen));
		   
    // Construct the CREDENTIALS attribute with simple ASCII_ID subtype 
    //  using the supplied Application name.  Since the RSVP service does 
    //  not look into the attributes, set the attribute length in 
    //  network order.
    pRsvp_pe_app_attr->PeAttribLength   = htons(usAppIdAttrLen);
    pRsvp_pe_app_attr->PeAttribType     = PE_ATTRIB_TYPE_CREDENTIAL;
    pRsvp_pe_app_attr->PeAttribSubType  = CREDENTIAL_SUB_TYPE_ASCII_ID;
    strcpy((char *)pRsvp_pe_app_attr->PeAttribValue, szAppName);

    pPolicyInfo->ObjectHdr.ObjectLength += usTotalPaddedLen;

    return usTotalPaddedLen;
}


/*======================================================
Function:         BuildPsBuf

Description:      Build the provider specific MSMQ buffer
========================================================*/
bool
BuildPsBuf(
    IN      char    *buf, 
    IN OUT  ULONG  *pulRsvp_buf_len,
    LPCSTR  pszMsmqAppName,
    LPCSTR  pszMsmqPolicyLocator
    )
{
    ASSERT(pszMsmqAppName != 0);
    ASSERT(pszMsmqPolicyLocator != 0);

    const USHORT x_usReserveInfoHeaderSize = sizeof(RSVP_RESERVE_INFO);
    const USHORT x_usHeaderSize = x_usReserveInfoHeaderSize + x_usPolicyInfoHeaderSize;

    LPRSVP_POLICY_INFO   pPolicyInfo = 0;
    LPRSVP_RESERVE_INFO	 rsvp_reserve_info = 0;

    ULONG ulAppIdPeBufLen = 0;
    if (*pulRsvp_buf_len > x_usHeaderSize)
    {
	    rsvp_reserve_info = (LPRSVP_RESERVE_INFO)buf;
        //
        // Fill the header if there is enough space. Otherwise, continue, leave ulAppIdPeBufLen
        // as 0 and just return the size needed.
        //
        // Init RSVP_RESERVE_INFO with appropriate values
        rsvp_reserve_info->Style = RSVP_FIXED_FILTER_STYLE;
        rsvp_reserve_info->ConfirmRequest = 0;
        rsvp_reserve_info->NumFlowDesc = 0;
        rsvp_reserve_info->FlowDescList = NULL;
        pPolicyInfo = (LPRSVP_POLICY_INFO)(buf+x_usReserveInfoHeaderSize);
        rsvp_reserve_info->PolicyElementList = pPolicyInfo;
 
        // Construct the policy element that holds app id 
        //   and policy locator attributes (as per RFC 2750)
        ulAppIdPeBufLen = *pulRsvp_buf_len - x_usHeaderSize;
    }

    if (0 ==
        ConstructAppIdPe( 
            pszMsmqAppName,  
            pszMsmqPolicyLocator,
            &ulAppIdPeBufLen, 
            pPolicyInfo))
    {
        *pulRsvp_buf_len = ulAppIdPeBufLen + x_usHeaderSize;
        return false;
    }

    ASSERT(rsvp_reserve_info != 0);

	// Set the type and length of the RSVP_RESERVE_INFO finally
    rsvp_reserve_info->ObjectHdr.ObjectLength = 
	    sizeof(RSVP_RESERVE_INFO) + rsvp_reserve_info->PolicyElementList->ObjectHdr.ObjectLength;

    rsvp_reserve_info->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO; 

	*pulRsvp_buf_len = rsvp_reserve_info->ObjectHdr.ObjectLength ;

    return true;
}


/*======================================================
Function:         QmpFillQoSBuffer

Description:      Fills a QoS buffer with the correct parameters 
                  for MSMQ QoS session
========================================================*/
void QmpFillQoSBuffer(QOS  *pQos)
{
    static char *pchProviderBuf = 0;
    static ULONG ulPSBuflen = 0;
    static CCriticalSection csProviderBuf;
    memset ( pQos, QOS_NOT_SPECIFIED, sizeof(QOS) );

    //
    // First time - fill the buffer
    //
    if (pchProviderBuf == 0)
    {
        CS lock(csProviderBuf);
        //
        // Check again to avoid critical race (we did not want to enter the critical section
        // earlier for performance reasons
        //
        if (pchProviderBuf == 0)
        {

            //
            // Fill in the Provider Specific (MSMQ) buffer
            //

            //
            // First call - calculate the buffer size
            //
            BuildPsBuf(0, &ulPSBuflen, CSessionMgr::m_pszMsmqAppName, CSessionMgr::m_pszMsmqPolicyLocator);

            ASSERT(0 != ulPSBuflen);

            pchProviderBuf = new char[ulPSBuflen];

            bool fBuildSuccessful = BuildPsBuf(pchProviderBuf, &ulPSBuflen, CSessionMgr::m_pszMsmqAppName, CSessionMgr::m_pszMsmqPolicyLocator);

            ASSERT(fBuildSuccessful);

            if (!fBuildSuccessful)
            {
                delete[] pchProviderBuf;

                pchProviderBuf = 0;
                ulPSBuflen = 0;
            }
        }
    }

    if (pchProviderBuf != 0)
    {
	    pQos->ProviderSpecific.len = ulPSBuflen;
        pQos->ProviderSpecific.buf = pchProviderBuf;
    }
    else
    {
	    pQos->ProviderSpecific.len = 0;
        pQos->ProviderSpecific.buf = 0;
    }

    //
    // sending flowspec 
    //
    pQos->SendingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

    //
    // recving flowspec
    //
    pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmutil.h

Abstract:

    QM utilities interface

Author:

    Uri Habusha (urih)

--*/

#ifndef __QM_QMUTIL__
#define __QM_QMUTIL__

#include "qformat.h"

struct  QUEUE_ID {
    GUID* pguidQueue;         // Queue Guid.
    DWORD dwPrivateQueueId;   // Private Queue Id
};

extern BOOL IsPathnameForLocalMachine(LPCWSTR PathName, BOOL* pfDNSName);

extern BOOL IsLocalDirectQueue(const QUEUE_FORMAT* pQueueFormat,
                               bool                fInReceive,
                               bool                fInSend);

extern HRESULT IsValidDirectPathName(LPCWSTR lpwcsDirectQueue);

template<>
extern BOOL AFXAPI  CompareElements(IN const QUEUE_ID* const * pQueue1,
                                    IN const QUEUE_ID* const * pQueue2);
template<>
extern void AFXAPI DestructElements(IN const QUEUE_ID** ppNextHop, int n);
template<>
extern UINT AFXAPI HashKey(IN const QUEUE_ID * key);

extern void String2TA(IN LPCTSTR psz, OUT TA_ADDRESS * * ppa);
extern void TA2StringAddr(IN const TA_ADDRESS *pa, OUT LPTSTR pString, IN int length);
extern BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, int length, PCWSTR pSuffix);

extern void GetMachineQuotaCache(OUT DWORD*, OUT DWORD*);
extern void SetMachineQuotaChace(IN DWORD);
extern void SetMachineJournalQuotaChace(IN DWORD);

void AllocateThreadTLSs(void);

HRESULT GetThreadEvent(HANDLE& hEvent);
void   FreeThreadEvent(void);

HANDLE GetHandleForRpcCancel(void) ;
void   FreeHandleForRpcCancel(void) ;

#define OS_SERVER(os)	(os == MSMQ_OS_NTS || os == MSMQ_OS_NTE)

LPWSTR
GetReadableNextHop(
    const TA_ADDRESS* pAddr
    );


// Auxiliary functions for hashing
extern void CopyQueueFormat(QUEUE_FORMAT &qfTo,  const QUEUE_FORMAT &qfFrom);
extern BOOL operator==(const QUEUE_FORMAT &key1, const QUEUE_FORMAT &key2);

extern void  GetDnsNameOfLocalMachine(
    WCHAR ** ppwcsDnsName
	);

void McInitialize();
const GUID& McGetEnterpriseId();
const GUID& McGetSiteId();

LPCWSTR GetHTTPQueueName(LPCWSTR URL);

ULONG GetBindingIPAddress();
void InitBindingIPAddress();


#endif //__QM_QMUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\recovery.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    recovery.cpp

Abstract:

    Packet & Transaction Recovery

Author:

    Erez Haba (erezh) 3-Jul-96

Revision History:

--*/

#include "stdh.h"
#include <ph.h>
#include <phinfo.h>
#include <ac.h>
#include "cqueue.h"
#include "cqmgr.h"
#include "qal.h"
#include "pktlist.h"
#include "mqformat.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactout.h"
#include "proxy.h"
#include "rmdupl.h"
#include "xactmode.h"
#include <Fn.h>
#include <mqstl.h>
#include <strsafe.h>
#include "qmacapi.h"

#include "recovery.tmh"

static bool s_fQMIDChanged;

extern HANDLE g_hAc;
extern HANDLE g_hMachine;

extern LPTSTR g_szMachineName;
extern AP<WCHAR> g_szComputerDnsName;

BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT], int PointersLength);

static WCHAR *s_FN=L"recovery";

/*====================================================

CompareElements  of OBJECTID

=====================================================*/

template<>
BOOL AFXAPI  CompareElements(IN const OBJECTID* pKey1,
                             IN const OBJECTID* pKey2)
{
    return ((pKey1->Lineage == pKey2->Lineage) &&
            (pKey1->Uniquifier == pKey2->Uniquifier));
}

/*====================================================

HashKey For OBJECTID

=====================================================*/

template<>
UINT AFXAPI HashKey(IN const OBJECTID& key)
{
    return((UINT)((key.Lineage).Data1 + key.Uniquifier));

}

inline PWSTR PathSuffix(PWSTR pPath)
{
    LPWSTR ptr = wcsrchr(pPath, L'\\');
	if(ptr == NULL)
		return NULL;

	return ptr + 2;
}

static DWORD CheckFileExist(PWSTR Path, DWORD PathLength, PWSTR Suffix)
{
    PWSTR Name = PathSuffix(Path);
	ASSERT(Name != NULL);
	
	DWORD SuffixLength = PathLength - numeric_cast<DWORD>(Name-Path);
	HRESULT hr = StringCchCopy(
    					Name,
    					SuffixLength,
    					Suffix
    					);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "StringCchCopy failed. Error: %!hresult!", hr);
		return ERROR_INSUFFICIENT_BUFFER;
	}

    if(GetFileAttributes(Path) == INVALID_FILE_ATTRIBUTES)
    {
    	DWORD gle = GetLastError();
		return gle;
    }

    return ERROR_SUCCESS;
}

static DWORD GetFileID(PCWSTR pName)
{
    DWORD id = 0;
    if (swscanf(pName, L"%x", &id) != 1)
    {
		return 0;
    }
    return id;
}

static bool GetQMIDChanged(void)
{
	//
	// This flag can be set to 1 because of two reasons:
	// 1. The HandleChangeOfJoinStatus function created a new MSMQ conf. object.
	// 2. We sometime created a new MSMQ conf object but didn't finish recovery successfully since
	// 	  ( because of some error).
	//
	// This flag is set back to 0 when recovery process ends.
	//
	
	static bool s_fQMIDInitialized = false;
	
	if (!s_fQMIDInitialized)
	{
	
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwQMIDChanged = 0;
		LONG rc = GetFalconKeyValue(
					MSMQ_QM_GUID_CHANGED_REGNAME,
					&dwType,
					&dwQMIDChanged,
					&dwSize
					);

		if ((rc != ERROR_SUCCESS) && (rc != ERROR_FILE_NOT_FOUND))
		{
			TrERROR(GENERAL, "GetFalconKeyValue failed. Error: %!winerr!", rc);

			//
			// Just in case - put 1, it can't do any damage.
			//
			dwQMIDChanged = 1;
		}
		
		s_fQMIDChanged = (dwQMIDChanged == 1);
		s_fQMIDInitialized = true;
	}

	return s_fQMIDChanged;
}


static void ClearQMIDChanged(void)
{
	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwChanged = FALSE;
	LONG rc = SetFalconKeyValue(MSMQ_QM_GUID_CHANGED_REGNAME, &dwType, &dwChanged, &dwSize);
	if (rc != ERROR_SUCCESS)
	{
		TrERROR(GENERAL, "Failed to set MSMQ_QM_GUID_CHANGED_REGNAME to FALSE");
	}
}


class CPacketConverter : public CReference
{
private:
	int m_nOutstandingConverts;
	HANDLE m_hConversionCompleteEvent;
	CCriticalSection m_CriticalSection;
	HRESULT m_hr;

public:
	CPacketConverter();
	~CPacketConverter();
	HRESULT IssueConvert(CPacket * pDriverPacket, BOOL fSequentialIdMsmq3Format);
	HRESULT WaitForFinalStatus();
    void    SetStatus(HRESULT hr);

private:
	void SignalDone();
	void IssueConvertRequest(EXOVERLAPPED *pov);
	void ConvertComplete(EXOVERLAPPED *pov);
	static VOID WINAPI HandleConvertComplete(EXOVERLAPPED* pov);
};

CPacketConverter *g_pPacketConverter;

CPacketConverter::CPacketConverter()
{
	m_hr = MQ_OK;
	m_nOutstandingConverts = 0;
	m_hConversionCompleteEvent = CreateEvent(0, FALSE,TRUE, 0);
	if (m_hConversionCompleteEvent == NULL)
	{
	    TrERROR(GENERAL, "Failed to create an event for CPacketConverter object. %!winerr!", GetLastError());
		throw bad_alloc();
	}

	g_pPacketConverter = this;
}

CPacketConverter::~CPacketConverter()
{
	g_pPacketConverter = 0;
	CloseHandle(m_hConversionCompleteEvent);
}

void CPacketConverter::SignalDone()
{
	SetEvent(m_hConversionCompleteEvent);
}

void CPacketConverter::SetStatus(HRESULT hr)
{
	CS lock(m_CriticalSection);
    m_hr = hr;
}


HRESULT CPacketConverter::IssueConvert(CPacket * pDriverPacket, BOOL fSequentialIdMsmq3Format)
{
    //
    // AC need to compute checksum and store
    //
    BOOL fStore = !g_fDefaultCommit;

    //
    // AC possibly need to convert packet sequential ID to MSMQ 3.0 (Whistler) format
    //
    BOOL fConvertSequentialId = !fSequentialIdMsmq3Format;

    //
    // AC need to convert QM GUID on packet to current QM GUID
    //
    BOOL fConvertQmId = GetQMIDChanged();

    //
    // Nothing is needed from AC. This is a no-op.
    //

	if (!fStore &&
        !fConvertSequentialId &&
        !fConvertQmId)
    {
        return MQ_OK;
    }

    //
    // Call AC to do the work
    //
	CS lock(m_CriticalSection);

	P<EXOVERLAPPED> pov = new EXOVERLAPPED(HandleConvertComplete, HandleConvertComplete);

	AddRef();

	HRESULT hr = ACConvertPacket(g_hAc, pDriverPacket, fStore, pov);
	if(FAILED(hr))
	{
		Release();
		m_hr = hr;
		return LogHR(hr, s_FN, 10);
	}

	m_nOutstandingConverts++;
	ResetEvent(m_hConversionCompleteEvent);
	pov.detach();
	return MQ_OK;
}

VOID WINAPI CPacketConverter::HandleConvertComplete(EXOVERLAPPED* pov)
{
	ASSERT(g_pPacketConverter);
	R<CPacketConverter> ar = g_pPacketConverter;

	g_pPacketConverter->ConvertComplete(pov);
}


void CPacketConverter::ConvertComplete(EXOVERLAPPED* pov)
{
	CS lock(m_CriticalSection);
	HRESULT hr = pov->GetStatus();

	delete pov;
		
	if(FAILED(hr))
	{
		m_hr = hr;
	}

	if(--m_nOutstandingConverts <= 0)
	{
		SignalDone();
	}
}


HRESULT CPacketConverter::WaitForFinalStatus()
{
	DWORD dwResult = WaitForSingleObject(m_hConversionCompleteEvent, INFINITE);
	ASSERT(dwResult == WAIT_OBJECT_0);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 199);
    }

	return LogHR(m_hr, s_FN, 20);
}


static
DWORD
FindPacketFile(
	PWSTR pLPath,
    DWORD /*LPathLength*/,
    PWSTR pPPath,
    DWORD PPathLength,
    PWSTR pJPath,
    DWORD JPathLength,
    LPWSTR Suffix,
	ACPoolType* pt,
	LPWSTR* pName
	)
{
	ASSERT ((PPathLength == MAX_PATH) && (JPathLength == MAX_PATH));
	
	DWORD gle1 = CheckFileExist(pPPath, PPathLength, Suffix);
	if(gle1 == ERROR_SUCCESS)
	{
		*pName = pPPath;
        *pt = ptPersistent;
        return ERROR_SUCCESS;
	}
	
    if(gle1 != ERROR_FILE_NOT_FOUND)
    {
		//
		// We failed to verify if the file exist or not
		//
		TrERROR(GENERAL, "CheckFileExist failed for file %ls. Error: %!winerr!", pLPath, gle1);
		return gle1;
   	}

    DWORD gle2 = CheckFileExist(pJPath, JPathLength, Suffix);
	if(gle2 == ERROR_SUCCESS)
	{
		*pName = pJPath;
	    *pt = ptJournal;
		return ERROR_SUCCESS;
	}
	
    if(gle2 != ERROR_FILE_NOT_FOUND)
	{
    	//
		// We failed to verify if the file exist or not
		//
    	TrERROR(GENERAL, "CheckFileExist failed for file %ls. Error: %!winerr!", pLPath, gle2);
		return gle2;
	}

    //
    //  Error condition we got a log file with no packet file
    //	
    ASSERT((gle1 == ERROR_FILE_NOT_FOUND) && (gle2 == ERROR_FILE_NOT_FOUND));
    TrERROR(GENERAL, "Log file %ls has no packet file", pLPath);
	DeleteFile(pLPath);
	return ERROR_FILE_NOT_FOUND;
}


static
HRESULT
LoadPacketsFile(
    CPacketList* pList,
    PWSTR pLPath,
    DWORD LPathLength,
    PWSTR pPPath,
    DWORD PPathLength,
    PWSTR pJPath,
    DWORD JPathLength
    )
{
    PWSTR pName = PathSuffix(pLPath);
    ASSERT (pName != NULL);

    DWORD dwFileID = GetFileID(pName);
    if (dwFileID == 0)
    {
    	//
    	// This means that we have a file in MSMQ storage directory that doesn't have the
    	// correct pattern - just ignore this file.
    	//
        return MQ_OK;
    }

    ACPoolType pt;
    LPWSTR pMessageFilePath = NULL;

    DWORD gle = FindPacketFile(
							pLPath,
						    LPathLength,
						    pPPath,
						    PPathLength,
						    pJPath,
						    JPathLength,
						    pName,
						    &pt,
						    &pMessageFilePath
							);

	if (gle == ERROR_FILE_NOT_FOUND)
	{
		return ERROR_SUCCESS;
	}

    if (gle != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "Packet file for log %ls was not found. Error: %!winerr!", pLPath, gle);
		return HRESULT_FROM_WIN32(gle);
    }

    HRESULT rc;
    rc = ACRestorePackets(g_hAc, pLPath, pMessageFilePath, dwFileID, pt);

    if(FAILED(rc))
    {
        EvReportWithError(EVENT_ERROR_QM_FAILED_RESTORE_PACKET, rc, 2, pMessageFilePath, pLPath);
        return LogHR(rc, s_FN, 30);
    }

	R<CPacketConverter> conv = new CPacketConverter;

    BOOL fSequentialIdMsmq3Format = FALSE;
    READ_REG_DWORD(fSequentialIdMsmq3Format, MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME, &fSequentialIdMsmq3Format);
	
    //
    //  Get all packets in this pool
    //
    for(;;)
    {
        CACRestorePacketCookie PacketCookie;
        rc = ACGetRestoredPacket(g_hAc, &PacketCookie);
        if (FAILED(rc))
        {
            conv->SetStatus(rc);
            return rc;
        }
		
        if(PacketCookie.pDriverPacket == 0)
        {
			//
            //  no more packets
            //
			break;
        }

		rc = conv->IssueConvert(PacketCookie.pDriverPacket, fSequentialIdMsmq3Format);
		if(FAILED(rc))
		{
			//
			// Failed to issue  convert
			//
			return rc;
		}

        pList->insert(PacketCookie.SeqId, PacketCookie.pDriverPacket);
    }

	return LogHR(conv->WaitForFinalStatus(), s_FN, 40);
}


static void DeleteExpressFiles(PWSTR pEPath, DWORD EPathLength)
{	
	ASSERT(EPathLength == MAX_PATH);
	
    PWSTR pEName = PathSuffix(pEPath);
    ASSERT (pEName != NULL);
    DWORD SuffixLength = EPathLength - numeric_cast<DWORD>(pEName-pEPath);

    HRESULT rc = StringCchCopy(
    				pEName,
    				SuffixLength,
    				L"*.mq"
    				);
    ASSERT(SUCCEEDED(rc));

    --pEName;

    HANDLE hEnum;
    WIN32_FIND_DATA ExpressFileData;
    hEnum = FindFirstFile(
                pEPath,
                &ExpressFileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
        return;

    do
    {
        rc = StringCchCopy(
        			pEName,
        			SuffixLength,
        			ExpressFileData.cFileName
        			);
        ASSERT(SUCCEEDED(rc));

        if(!DeleteFile(pEPath))
            break;

    } while(FindNextFile(hEnum, &ExpressFileData));

    FindClose(hEnum);
}


static HRESULT LoadPersistentPackets(CPacketList* pList)
{
    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    if (!GetStoragePath(StoragePathPointers, MAX_PATH))
    {
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "GetStoragePath failed. Error: %!winerr!", gle);
		return (HRESULT_FROM_WIN32(gle));
    }

    DeleteExpressFiles(StoragePath[0], TABLE_SIZE(StoragePath[0]));

    PWSTR pPPath = StoragePath[1];
    PWSTR pJPath = StoragePath[2];
    PWSTR pLPath = StoragePath[3];

    PWSTR pLogName = PathSuffix(pLPath);
    ASSERT(pLogName != NULL);
    DWORD SuffixLength = MAX_PATH - numeric_cast<DWORD>(pLogName-pLPath);

    HRESULT rc = StringCchCopy(
    					pLogName,
    					SuffixLength,
    					L"*.mq"
    					);
    ASSERT (SUCCEEDED(rc));

    --pLogName;

    //
    //  Ok now we are ready with the log path template
    //
    HANDLE hLogEnum;
    WIN32_FIND_DATA LogFileData;
    hLogEnum = FindFirstFile(
                pLPath,
                &LogFileData
                );

    if(hLogEnum == INVALID_HANDLE_VALUE)
    {
        //
        //  need to do something, check what happen if no file in directory
        //
        return MQ_OK;
    }

    do
    {
        QmpReportServiceProgress();

        rc = StringCchCopy(
        				pLogName,
        				SuffixLength,
        				LogFileData.cFileName
        				);
        ASSERT (SUCCEEDED(rc));

        rc = LoadPacketsFile(pList, pLPath, MAX_PATH, pPPath, MAX_PATH, pJPath, MAX_PATH);
        if (FAILED(rc))
        {
            break;
        }

    } while(FindNextFile(hLogEnum, &LogFileData));

    FindClose(hLogEnum);
    return LogHR(rc, s_FN, 50);
}

inline NTSTATUS PutRestoredPacket(CPacket* p, CQueue* pQueue)
{
	HANDLE hQueue = g_hMachine;
	if(pQueue != 0)
	{
		hQueue = pQueue->GetQueueHandle();
	}

	try
	{
    	QmAcPutRestoredPacket(hQueue, p, eDoNotDeferOnFailure);
	}
	catch (const bad_hresult &e)
	{
		return e.error();
	}
	
	return MQ_OK;
}

inline BOOL ValidUow(const XACTUOW *pUow)
{
	for(int i = 0; i < 16; i++)
	{
		if(pUow->rgb[i] != 0)
			return(TRUE);
	}

	return(FALSE);
}


static 
void 
GetLocalDirectFormatName(
	LPCWSTR DirectID, 
	AP<WCHAR>& pLocalDirectQueueFormat
	)
{
    AP<WCHAR> pLocalPathName = NULL;
    
	FnDirectIDToLocalPathName(
		DirectID, 
		((g_szComputerDnsName == NULL) ? g_szMachineName : g_szComputerDnsName), 
		pLocalPathName
		);

    DWORD size = FN_DIRECT_OS_TOKEN_LEN + wcslen(pLocalPathName) + 1;
    pLocalDirectQueueFormat = new WCHAR[size];
	HRESULT rc = StringCchPrintf(pLocalDirectQueueFormat, size, L"%s%s", FN_DIRECT_OS_TOKEN, pLocalPathName);
	DBG_USED(rc);
	ASSERT(SUCCEEDED(rc));
}


inline HRESULT GetQueue(CQmPacket& QmPkt, LPVOID p, CQueue **ppQueue)
{
    CPacketInfo* ppi = static_cast<CPacketInfo*>(p) - 1;

    if(ppi->InDeadletterQueue() || ppi->InMachineJournal())
	{
		*ppQueue = 0;
		return MQ_OK;
	}

    QUEUE_FORMAT DestinationQueue;

	if (ppi->InConnectorQueue())
	{
        //
        // This code added as part of QFE 2738 that fixed connector
		// recovery problem (urih, 3-Feb-98)
		//
		GetConnectorQueue(QmPkt, DestinationQueue);
	}
	else
	{
		BOOL fGetRealQ = ppi->InSourceMachine() || QmpIsLocalMachine(QmPkt.GetConnectorQM());
		//
		// If FRS retreive the destination according to the destination queue;
		// otherwise, retrive the real detination queue and update the Connector QM
		// accordingly
		//
		QmPkt.GetDestinationQueue(&DestinationQueue, !fGetRealQ);
	}

    //
    // If the destination queue format name is direct with TCP or IPX type,
    // and we are in the Target queue we lookup/open the queue with ANY direct type.
    // We do it from 2 reasons:
    //       - on RAS the TCP/IPX address can be changed between one conection
    //         to another. However if the message was arrived to destination we
    //         want to pass to the queue.
    //       - On this stage we don't have the machine IP/IPX address list. Therefor
    //         all the queue is opened as non local queue.
    //

	bool fInReceive = false;
	bool fInSend = false;
    AP<WCHAR> lpwsDirectFormatName = NULL;

    if (DestinationQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        if (ppi->InTargetQueue() || ppi->InJournalQueue())
        {
        	//
        	// bug# 720121 - Regression: Data lost in computer rename or join to domain
        	// During the recovery we try to open a queue for direct format name. Since 
        	// the machine name was changed the QM identifies the queue as outgoing queue
        	// and try to deliver the messages. The message is delivered but rejected since
        	// it reach to incorrect machine or to non FRS machine. 
        	// For this case, the recovery knows that the queue is local queue (the "InTarget" 
        	// flag or "InJournalQueue" flag is set). To overcome the rename scenario the code
        	// replaces the format name with local format name. 
        	// We can think about better design, like passing the information that the queue 
        	// is local queue to lower level, but in this stage it is too risk.
        	//										Uri Habusha, 17-Oct-2002
        	//
        	if (!IsLocalDirectQueue(&DestinationQueue, true, false))
        	{
        		GetLocalDirectFormatName(DestinationQueue.DirectID(), lpwsDirectFormatName);
        		DestinationQueue.DirectID(lpwsDirectFormatName.get());
        	}      
        	
		    fInReceive = true;
        }
        else
        {
            //
            // Bug 664307.
            // Hint for GetQueueObject(), so it know to what CQueue object
            // this packet belong.
            //
	        fInSend = true ;
        }
	}

	BOOL fOutgoingOrdered;

	fOutgoingOrdered =  QmPkt.IsOrdered() &&       // ordered packet
                        ppi->InSourceMachine() &&  // sent from here
                        !ppi->InConnectorQueue();


	//
    // Retreive the Connector QM ID
    //
    const GUID* pgConnectorQM = (fOutgoingOrdered) ? QmPkt.GetConnectorQM() : NULL;
    if (pgConnectorQM && *pgConnectorQM == GUID_NULL)
    {
        //
        // The message was generated for offline DS queue. As a result we didn't know
        // if the queue is foreign transacted queue. In such a case we have place
        // holder on the packet, but it doesn't mean that the queue is real
        // foreign transacted queue
        //
        pgConnectorQM = NULL;
    }



	CQueue* pQueue;
	CSenderStream EmptyStream;
	HRESULT rc = QueueMgr.GetQueueObject(
								 &DestinationQueue,
                                 &pQueue,
                                 pgConnectorQM,
                                 fInReceive,
                                 fInSend,
								 QmPkt.IsSenderStreamIncluded() ? QmPkt.GetSenderStream() : &EmptyStream	
								 );
	
	if(rc == MQ_ERROR_QUEUE_NOT_FOUND)
	{
        WCHAR QueueFormatName[128] = L"";
        DWORD FormatNameLength;

        //
		// We don't care if MQpQueueFormatToFormatName failed because the buffer
		// was too small. we'll fill the buffer to it's end.
		//
		
        NTSTATUS rc2 = MQpQueueFormatToFormatName(
            &DestinationQueue,
            QueueFormatName,
            TABLE_SIZE(QueueFormatName),
            &FormatNameLength,
            false
            );

        ASSERT (SUCCEEDED(rc2) || (rc2 == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL));

        OBJECTID MessageId;
        QmPkt.GetMessageId(&MessageId);

        WCHAR MessageIdText[GUID_STR_LENGTH + 20];
        rc2 = StringCchPrintf(
        			MessageIdText,
        			TABLE_SIZE(MessageIdText),
        			GUID_FORMAT L"\\%u",
        			GUID_ELEMENTS(&MessageId.Lineage),
        			MessageId.Uniquifier
        			);

        ASSERT (SUCCEEDED(rc2));

        EvReport(EVENT_WARN_RESTORE_FAILED_QUEUE_NOT_FOUND, 2, MessageIdText, QueueFormatName);
	}

    if (FAILED(rc))
		return LogHR(rc, s_FN, 80);

	*ppQueue = pQueue;

	return(MQ_OK);
}


inline
HRESULT
ProcessPacket(
	CTransaction*& pCurrentXact,
	CQmPacket& QmPkt,
	CBaseHeader* p,
	CQueue* pQueue
	)
{
	CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(p) - 1;
	
	//
	// Treat non-fully-processed ordered incomimg messages
	//
	
	if(pQueue != 0)
	{
		if (
			QmPkt.IsOrdered()     &&           // ordered
			(pQueue->IsLocalQueue() || ppi->InConnectorQueue()) &&           // message is incoming
			!ppi->InSourceMachine())  // sent from other machine
		{	
			//
			// Insert packet information back into the insequence hash structure.
			//
			R<CInSequence> pInSeq = g_pInSeqHash->LookupCreateSequence(&QmPkt);
			
			if(!pInSeq->WasPacketLogged(&QmPkt))
		    {
		    	QmAcFreePacket(QmPkt.GetPointerToDriverPacket(), 0, eDoNotDeferOnFailure);
		    	TrWARNING(XACT_RCV, "Exactly1 receive: thrown unlogged packet on recovery: SeqID=%x / %x, SeqN=%d .", HighSeqID(QmPkt.GetSeqID()), LowSeqID(QmPkt.GetSeqID()), QmPkt.GetSeqN());
		    	return MQ_OK;
			}
		}
	}

	//
    // Add the message ID to the Message map to eliminate duplicates. If the
    // message was sent from the local machine, ignore it.
    //
    if (!ppi->InSourceMachine()  && !QmPkt.IsOrdered())
    {
        DpInsertMessage(QmPkt);
    }

	//
	// We recover transactions one by one.  If the transaction contains at least
	// one sent packet, we recover (complete) the tranasction after we see the
	// last packet (it is always a sent packet). If the transaction cotains no sent
	// packets, we recover it after we read all packets.
	//


	//
	// Check if we need to recover the previous transaction
	//
	if(pCurrentXact != 0)
	{
		if(*pCurrentXact->GetUow() != *ppi->Uow())
		{
			//
			// We have seen the last packet for the current transaction
			// We must recover it now to restore messages to the
			// right order in the queue
			//
			HRESULT hr = pCurrentXact->Recover();
			if(FAILED(hr))
				return LogHR(hr, s_FN, 90);

			pCurrentXact->Release();
			pCurrentXact = 0;
		}
	}

	//
	// Is this message not a part of a transaction?
	//
	if((!g_fDefaultCommit && !ppi->InTransaction()) || !ValidUow(ppi->Uow()))
	{
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 100);
	}

	//
	// Handle the current packet
	//

	if(pCurrentXact != 0)
	{
		//
		// This send packet is part of the current transaction
		// Put packet back on it's queue. It's transaction will take care of it
		//
		ASSERT(pCurrentXact->ValidTransQueue());
		ASSERT(ppi->TransactSend());
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 110);
	}

	//
	// Find the transaction this packet belongs to.
	//
	CTransaction *pTrans = g_pRM->FindTransaction(ppi->Uow());

	if(pTrans == 0)
	{
		//
		// There is no transaction it belongs to.
		//
		if(!g_fDefaultCommit && ppi->TransactSend())
		{
			//
			// Throw it away - we are not in DefaultCommit mode
			// and this is a sent packet.
			//
			try
			{
				QmAcFreePacket(QmPkt.GetPointerToDriverPacket(), 0, eDoNotDeferOnFailure);
			}
			catch (const bad_hresult &e)
			{
				return e.error();
			}
			
			return MQ_OK;
		}

		//
		// Put packet back on it's queue.
		// This packet does not belong to an
		// active transaction.
		//
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 130);
	}

	//
	// The packet belongs to a transaction
	//

	if(!pTrans->ValidTransQueue())
	{
		//
		// Make sure we create a tranasction
		// before we add packets to it
		//
		HRESULT rc;
		HANDLE hQueueTrans;
		rc = XactCreateQueue(&hQueueTrans, ppi->Uow());
		if (FAILED(rc))
			return LogHR(rc, s_FN, 140);

		pTrans->SetTransQueue(hQueueTrans);
	}
				
	if(ppi->TransactSend())
	{
		//
		// This is a new unit of work
		//
		pCurrentXact = pTrans;
	}
									
	//
	// Put packet back on it's queue.  It's tranasction will take care of it.
	//
	return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 150);
}

static HRESULT RestorePackets(CPacketList* pList)
{
    HRESULT rc = MQ_OK;
	CTransaction *pCurrentXact = 0;

	//
	// Release all complete trasnactions
	//
	g_pRM->ReleaseAllCompleteTransactions();

	bool fEventIssued = false;

    // Cycle by all restored packets
    for(int n = 0; !pList->isempty(); pList->pop(), ++n)
    {
        if((n % 1024) == 0)
        {
            QmpReportServiceProgress();
        }

        //
        // Get the first packet cookie from the list
        //
        CPacket* pDriverPacket = pList->first();

        //
        // Translate the cookie to pointer in QM address space
        //
        CACPacketPtrs PacketPtrs = {0, pDriverPacket};
        rc = QmAcGetPacketByCookie(g_hAc, &PacketPtrs);
        if(FAILED(rc))
        {
            return LogHR(rc, s_FN, 158);
        }

		CBaseHeader* pBaseHeader = PacketPtrs.pPacket;
		CQmPacket QmPkt(pBaseHeader, pDriverPacket);
		CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(pBaseHeader) - 1;

		if (s_fQMIDChanged && ppi->InSourceMachine() && (*QmPkt.GetSrcQMGuid() != *CQueueMgr::GetQMGuid()))
		{
			OBJECTID TraceMessageId;
			QmPkt.GetMessageId(&TraceMessageId);
			TrERROR(GENERAL, "Throwing away message - ID:%!guid!\\%u",&TraceMessageId.Lineage,TraceMessageId.Uniquifier);
			
			QmAcFreePacket(pDriverPacket, MQMSG_CLASS_NACK_SOURCE_COMPUTER_GUID_CHANGED, eDoNotDeferOnFailure);
			if (!fEventIssued)
			{
				EvReport(EVENT_WARN_NEW_QM_GUID);
				fEventIssued = true;
			}
			//
			// Packet was thrown, move to next packet in list.
			//
			continue;
		}
		

        CQueue* pQueue;
		rc = GetQueue(QmPkt, pBaseHeader, &pQueue);

		if(rc == MQ_ERROR_QUEUE_NOT_FOUND)
		{
			
			USHORT usClass = ppi->InTargetQueue() ?
                        MQMSG_CLASS_NACK_Q_DELETED :
                        MQMSG_CLASS_NACK_BAD_DST_Q;

			QmAcFreePacket(pDriverPacket, usClass, eDoNotDeferOnFailure);
            continue;
		}

		if(FAILED(rc))
			return LogHR(rc, s_FN, 159);

		rc = ProcessPacket(pCurrentXact, QmPkt, pBaseHeader, pQueue);
		if(pQueue != 0)
		{
			pQueue->Release();
		}

		if(FAILED(rc))
			return LogHR(rc, s_FN, 160);
	}

	if (s_fQMIDChanged)
	{
		//
		// If we failed to clear this reg key, we fail recovery. Next time we'll try to clear it again.
		// The important thing here that no new messages should be sent if this flag if not cleared.
		//
		ClearQMIDChanged();
	}
	
	//
	// The transactions left all either contain no messages or recieved only
	// messages.  We need to recover them as well.
	//
	// N.B.  There  might be still one transaction with a sent message. The
	//       current transaction.  It will be recovered with the rest.
	//
    QmpReportServiceProgress();
	rc = g_pRM->RecoverAllTransactions();
	return LogHR(rc, s_FN, 170);
}

static void WINAPI ReleaseMessageFile(CTimer *pTimer);
static CTimer s_ReleaseMessageFileTimer(ReleaseMessageFile);
static CTimeDuration s_ReleaseMessageFilePeriod;

static void WINAPI ReleaseMessageFile(CTimer *pTimer)
{
    ASSERT(pTimer == &s_ReleaseMessageFileTimer);
    HRESULT rc = ACReleaseResources(g_hAc);
    LogHR(rc, s_FN, 124);
    ExSetTimer(pTimer, s_ReleaseMessageFilePeriod);
}


static void InitializeMessageFileRelease(void)
{
    DWORD Duration = MSMQ_DEFAULT_MESSAGE_CLEANUP;
    READ_REG_DWORD(
        Duration,
        MSMQ_MESSAGE_CLEANUP_INTERVAL_REGNAME,
        &Duration
        );

    s_ReleaseMessageFilePeriod = CTimeDuration::FromMilliSeconds(Duration);
    ReleaseMessageFile(&s_ReleaseMessageFileTimer);
}

static void SetMappedLimit(bool fLimitNeeded)
{

	ULONG MaxMappedFiles;
	if(fLimitNeeded)
	{
        ULONG ulDefaultMaxMappedFiles = MSMQ_DEFAULT_MAPPED_LIMIT;

        READ_REG_DWORD(
			MaxMappedFiles,
			MSMQ_MAPPED_LIMIT_REGNAME,
			&ulDefaultMaxMappedFiles
            );

		if (MaxMappedFiles < 1)
		{
			MaxMappedFiles = ulDefaultMaxMappedFiles ;
		}
	}
	else
	{
		MaxMappedFiles = 0xffffffff;
	}
	
	ACSetMappedLimit(g_hAc, MaxMappedFiles);
}

HRESULT RecoverPackets()
{	
    HRESULT rc;
    CPacketList packet_list;

    //
    // Performance feauture: to avoid paging
    // limit the max number of MMFs to fetch in RAM
    //
    SetMappedLimit(true);

    rc = LoadPersistentPackets(&packet_list);
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 180);
    }
	

    rc = RestorePackets(&packet_list);
    InitializeMessageFileRelease();

    //
    // Remove the limit on the number of mapped files
    //
    SetMappedLimit(false);
    return LogHR(rc, s_FN, 190);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\remotereadcli.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    RemoteReadCli.h

Abstract:

    Remote read client

Author:

    Ilan Herbst (ilanh) 27-Dec-2001

--*/

#ifndef _REMOTEREADCLI_H_
#define _REMOTEREADCLI_H_

void
RemoteQueueNameToMachineName(
	LPCWSTR RemoteQueueName,
	AP<WCHAR>& MachineName
	);

DWORD RpcCancelTimeout();

#endif // _REMOTEREADCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\regqueue.h ===
/*+++

Copyright (c) 1995-1996  Microsoft Corporation

File Name:

    regqueue.h

Abstract:

Author:

    Doron Juster  (DoronJ)

--*/

HRESULT GetCachedQueueProperties( IN DWORD       cpObject,
                                  IN PROPID      aProp[],
                                  IN PROPVARIANT apVar[],
                                  IN const GUID* pQueueGuid,
                                  IN LPWSTR      lpPath = NULL ) ;

void  WINAPI TimeToPublicCacheUpdate(CTimer* pTimer) ;
HRESULT UpdateAllPublicQueuesInCache() ;

HRESULT DeleteCachedQueueOnTimeStamp(const GUID *pGuid, time_t TimeStamp);

HRESULT DeleteCachedQueue(IN const GUID* pQueueGuid);

HRESULT SetCachedQueueProp(IN const GUID* pQueueGuid,
                           IN DWORD       cpObject,
                           IN PROPID      pPropObject[],
                           IN PROPVARIANT pVarObject[],
                           IN BOOL        fCreatedQueue,
                           IN BOOL        fAddTimeSec,
                           IN time_t      TimeStamp) ;

HRESULT UpdateCachedQueueProp( IN const GUID* pQueueGuid,
                               IN DWORD       cpObject,
                               IN PROPID      pPropObject[],
                               IN PROPVARIANT pVarObject[],
                               IN time_t      TimeStamp);

#define PPROPID_Q_TIMESTAMP     5000
#define PPROPID_Q_SYSTEMQUEUE   5001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\regqueue.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    regqueue.cpp

Abstract:

    This module implements function to write/read queue properties
    from local registry.
    Used for private queues and for cache of public queues, when working
    wihtout MQIS.

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include <Msm.h>
#include <mqexception.h>
#include "cqmgr.h"
#include "regqueue.h"
#include "lqs.h"
#include "mqaddef.h"

#include "regqueue.tmh"

static WCHAR *s_FN=L"regqueue";


/*============================================================
*
*  HRESULT GetCachedQueueProperties()
*
=============================================================*/

HRESULT GetCachedQueueProperties( IN DWORD       cpObject,
                                  IN PROPID      aProp[],
                                  IN PROPVARIANT apVar[],
                                  IN const GUID* pQueueGuid,
                                  IN LPWSTR      lpPathIn )
{
    HRESULT hr;
    CHLQS hLQS;

    if (pQueueGuid)
    {
        ASSERT(!lpPathIn) ;
        hr = LQSOpen(pQueueGuid, &hLQS, NULL);
    }
    else
    {
        ASSERT(!pQueueGuid) ;
        hr = LQSOpen(lpPathIn, &hLQS, NULL);
    }

    if (FAILED(hr))
    {
        //
        // This particular error code is important to the functions
        // that calls this function.
        //
        LogHR(hr, s_FN, 10);
        return MQ_ERROR_NO_DS;
    }

    //
    // Get the properties.
    //
    return LogHR(LQSGetProperties( hLQS, cpObject, aProp, apVar), s_FN, 20);
}

HRESULT DeleteCachedQueueOnTimeStamp(const GUID* pGuid, time_t TimeStamp)
/*++
Routine Description:
	This Routine deletes the cached queue if its time stamp property value does not 
	match the 'TimeStamp' argument.

Arguments:

Return Value:

--*/
{
    ASSERT(pGuid) ;

    CHLQS hLQS;
    HRESULT hr = LQSOpen(pGuid, &hLQS, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    PROPID Prop = PPROPID_Q_TIMESTAMP;
    PROPVARIANT Var;

    Var.vt = VT_NULL;

    hr = LQSGetProperties(hLQS, 1, &Prop, &Var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    ASSERT(Var.blob.cbSize == sizeof(time_t)) ;

	time_t& QueriedTimeStamp = *reinterpret_cast<time_t*>(Var.blob.pBlobData);

    if (QueriedTimeStamp < TimeStamp)
    {
        //
        // The file is older than the last update, delete the queue.
        // It can happen that the file is newer in a scenario were an additional update
        // occurs when a message arrives while updating public queues cache; that is,
        // right after the update but before looking for queues to delete.
        // See  #8316; erezh 4-Jul-2001
        //
        hr = DeleteCachedQueue(pGuid);
    }

    delete Var.blob.pBlobData ;

	return LogHR(hr, s_FN, 50);
}

/*============================================================
*
*  HRESULT DeleteCachedQueue()
*
=============================================================*/
HRESULT DeleteCachedQueue(IN const GUID* pQueueGuid)
{
    TrTRACE(GENERAL, "DS NOTIFICATION: Queue: %!guid! was deleted", pQueueGuid);

    HRESULT hr = LQSDelete(pQueueGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    //
    // Try to remove from queue manager, also.
    //
	QUEUE_FORMAT qf(*pQueueGuid);

    QueueMgr.NotifyQueueDeleted(qf);
    MsmUnbind(qf);
	
	return hr;
}


//******************************************************************
//
//
//******************************************************************

HRESULT SetCachedQueueProp(IN const GUID* pQueueGuid,
                           IN DWORD       cpObject,
                           IN PROPID      pPropObject[],
                           IN PROPVARIANT pVarObject[],
                           IN BOOL        fCreatedQueue,
                           IN BOOL        fAddTimeSec,
                           IN time_t      TimeStamp )
{
extern BOOL              g_fWorkGroupInstallation;
	ASSERT( !g_fWorkGroupInstallation);
    HRESULT hr;
    ASSERT(pQueueGuid) ;
    CHLQS hLQS;

    if (fCreatedQueue)
    {
        //
        // Create the queue.
        //
        hr = LQSCreate(NULL,
                       pQueueGuid,
                       cpObject,
                       pPropObject,
                       pVarObject,
                       &hLQS);
        if (hr == MQ_ERROR_QUEUE_EXISTS)
        {
            //
            // If the queue aready exists, ust set it's properties.
            //
            hr = LQSSetProperties(hLQS, cpObject, pPropObject, pVarObject);
        }
    }
    else
    {
        //
        // Open the queue and set it's properties.
        //
        hr = LQSOpen(pQueueGuid, &hLQS, NULL);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 70);
        }
        hr = LQSSetProperties(hLQS, cpObject, pPropObject, pVarObject);
    }

    if (fAddTimeSec && SUCCEEDED(hr))
    {
       ASSERT(hLQS) ;

       //
       // Now handle security.
       // also, add the time stamp for cleanup.
       //
       // If this routine is called as result of a received notification,
       // the queue security is included in the property array.
       // And it was already written into registry, when all the rest
       // of the properties were written.
       //
       // If this routine is called from TimeToPublicCacheUpdate, queue
       // security property is not included ( because the queue
       // properties were retrieved using lookup, which doesn't return
       // queue security
       //
       PROPID         propsecid[2] ;
       PROPVARIANT    secresult[2] ;
       PROPVARIANT*   psecvar;
       PROPVARIANT*   ptimevar;
       BOOL fFoundSecurity = FALSE;
	   R<CQueueSecurityDescriptor> pcSD;

       for ( DWORD i = 0; i < cpObject; i++)
       {
           if (pPropObject[i] == PROPID_Q_SECURITY)
           {
               fFoundSecurity = TRUE;
               break;
           }
       }

       DWORD dwNumProps = fFoundSecurity ? 1 : 2;

       propsecid[0] = PPROPID_Q_TIMESTAMP ;
       ptimevar = &secresult[0] ;
       ptimevar->blob.pBlobData = reinterpret_cast<BYTE*>(&TimeStamp);
       ptimevar->blob.cbSize = sizeof(time_t) ;
       ptimevar->vt = VT_BLOB;

       if (!fFoundSecurity)
       {
			CQMDSSecureableObject DsSec(eQUEUE, pQueueGuid, TRUE, TRUE, NULL);
			pcSD = new CQueueSecurityDescriptor((const PSECURITY_DESCRIPTOR)(DsSec.GetSDPtr()));

			propsecid[1] = PROPID_Q_SECURITY;
			psecvar = &secresult[1] ;
			psecvar->blob.pBlobData = (BYTE *) pcSD->GetSD();
			psecvar->blob.cbSize = ((pcSD->GetSD()) ? GetSecurityDescriptorLength(pcSD->GetSD()) : 0);
			psecvar->vt = VT_BLOB;
			if (pcSD->GetSD() == NULL)
			{
			   //
			   //	We failed to retrieve the security descriptor ( i.e no
			   //   access to DS server and the security attribute is not
			   //   in the cache (LQS file))
			   //	If this is the case, then delete the LQS file ( otherwise further
			   //   access check will come out with wrong results)
			   //
			   hr = LQSDelete( hLQS);
			}
       }

	   if (SUCCEEDED(hr))
	   {
			hr = LQSSetProperties( hLQS, dwNumProps, propsecid, secresult);
	   }
    }

    return LogHR(hr, s_FN, 80);
}

/*======================================================

Function:      UpdateCachedQueueProp

Description:   public Queue was created. The function add the queue to
               public queue cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
HRESULT UpdateCachedQueueProp(IN const GUID* pQueueGuid,
                              IN DWORD       cpObject,
                              IN PROPID      pPropObject[],
                              IN PROPVARIANT pVarObject[],
                              IN time_t		 TimeStamp)
{
	//
	// Crete the key in registry.
	//
	HRESULT hr = SetCachedQueueProp(  
					pQueueGuid,
					cpObject,
					pPropObject,
					pVarObject,
					FALSE,
					TRUE,
					TimeStamp 
					);
	if(FAILED(hr))
	{
		//
		// Maybe file was corrupted and deleted.
		// Try to create a new one.
		//
		hr = SetCachedQueueProp(  
				pQueueGuid,
				cpObject,
				pPropObject,
				pVarObject,
				TRUE,
				TRUE,
				TimeStamp 
				);
	}

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }

    //
    // Try to update queue properties in the queue manager.
    // Build the queue format as public queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT QueueFormat(*pQueueGuid);
    QueueMgr.UpdateQueueProperties(&QueueFormat, cpObject, pPropObject, pVarObject);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\remotereadcli.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    RemoteReadCli.cpp

Abstract:

    Remove Read client side.

Author:

    Ilan Herbst (ilanh) 3-Mar-2002

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "cqueue.h"
#include "qm2qm.h"
#include "_mqrpc.h"
#include <Fn.h>
#include "RemoteReadCli.h"
#include "rrcontext.h"
#include <cm.h>

#include "RemoteReadCli.tmh"

static WCHAR *s_FN=L"RemoteReadCli";

extern CQueueMgr   QueueMgr;


static
bool
QMpIsLatestRemoteReadInterfaceSupported(
    UCHAR  Major,
    UCHAR  Minor,
    USHORT BuildNumber
    )
/*++

Routine Description:

    Check if the specified MSMQ version supports the latest RPC remote read interface.

Arguments:

    Major       - Major MSMQ version.

    Minor       - Minor MSMQ version.

    BuildNumber - MSMQ build number.

Return Value:

    true -  The specified MSMQ version supports latest interface.
    false - The specified MSMQ version doesn't support latest interface.

--*/
{
    //
    // Latest remote read RPC interface is supported from version 5.1.951
    //

    if (Major > 5)
    {
        return true;
    }

    if (Major < 5)
    {
        return false;
    }

    if (Minor > 1)
    {
        return true;
    }

    if (Minor < 1)
    {
        return false;
    }

    return (BuildNumber >= 951);

} // QMpIsLatestRemoteReadInterfaceSupported


static void SetBindNonCausal(handle_t hBind)
{
	RPC_STATUS rc = RpcBindingSetOption(
						hBind, 
						RPC_C_OPT_BINDING_NONCAUSAL, 
						TRUE
						);
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to set NonCausal, gle = %!winerr!", rc);
	}
}


DWORD RpcCancelTimeout()
{
	static DWORD s_TimeoutInMillisec = 0;

	if(s_TimeoutInMillisec != 0)
	{
		return s_TimeoutInMillisec;
	}

	const RegEntry xRegEntry(NULL, FALCON_RPC_CANCEL_TIMEOUT_REGNAME, FALCON_DEFAULT_RPC_CANCEL_TIMEOUT);
	DWORD TimeoutInMinutes = 0;
	CmQueryValue(xRegEntry, &TimeoutInMinutes);

	if(TimeoutInMinutes == 0)
    {
        //
        // This value must not be 0, even if user add a registry value
        // with 0. With a 0 value, rpc calls will  be cancelled
        // immediately and sporadically before being copmleted.
        //
        ASSERT(("RpcCancelTimeout must not be 0", (TimeoutInMinutes != 0)));
	    TimeoutInMinutes = FALCON_DEFAULT_RPC_CANCEL_TIMEOUT;
    }
		
	s_TimeoutInMillisec = TimeoutInMinutes * 60 * 1000;    // in millisec
	TrTRACE(RPC, "RpcCancelTimeout = %d", s_TimeoutInMillisec);
	return s_TimeoutInMillisec;
}


void SetBindTimeout(handle_t hBind)
{
	RPC_STATUS rc = RpcBindingSetOption(
						hBind, 
						RPC_C_OPT_CALL_TIMEOUT, 
						RpcCancelTimeout()
						);
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to set Timeout, gle = %!winerr!", rc);
	}
}


static void SetBindKeepAlive(handle_t hBind)
{
	RPC_STATUS rc = RpcMgmtSetComTimeout(
						hBind, 
						RPC_C_BINDING_DEFAULT_TIMEOUT	// default start keep alive 720 sec = 12 min
						);
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to set keepAlive, gle = %!winerr!", rc);
	}
}


//********************************************************************
//
//  Methods of CRRQueue.
//
//  This is a special "proxy" queue object on client side of
//  remote-read.
//
//********************************************************************

//---------------------------------------------------------
//
// Function:         CBaseRRQueue::CBaseRRQueue
//
// Description:      Constructor
//
//---------------------------------------------------------

CBaseRRQueue::CBaseRRQueue(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN PQueueProps         pQueueProp,
    IN handle_t		hBind
    ) :
    m_hRemoteBind(hBind),
    m_hRemoteBind2(NULL)
{
    m_dwSignature = QUEUE_SIGNATURE;
    m_fRemoteProxy = TRUE;

    ASSERT(pQueueFormat != NULL);

    TrTRACE(GENERAL, "CQueue Constructor for queue: %ls", pQueueProp->lpwsQueuePathName);

    ASSERT(!pQueueProp->fIsLocalQueue);

    m_fLocalQueue  = FALSE;

    InitNameAndGuid(pQueueFormat, pQueueProp);
}


CRRQueue::CRRQueue(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN PQueueProps         pQueueProp,
    IN handle_t		hBind
    ) :
    CBaseRRQueue(pQueueFormat, pQueueProp, hBind),
    m_pRRContext(NULL),
	m_srv_pQMQueue(0),
	m_srv_hACQueue(0),
    m_RemoteQmMajorVersion(0),
    m_RemoteQmMinorVersion(0),
    m_RemoteQmBuildNumber(0),
    m_EndReceiveCnt(0),
    m_fHandleValidForReceive(true)
{
}
    
CNewRRQueue::CNewRRQueue(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN PQueueProps         pQueueProp,
    IN handle_t		hBind,
    IN RemoteReadContextHandleExclusive pNewRemoteReadContext
    ) :
    CBaseRRQueue(pQueueFormat, pQueueProp, hBind),
    m_pNewRemoteReadContext(pNewRemoteReadContext)
{
	ASSERT(hBind != NULL);
	ASSERT(pNewRemoteReadContext != NULL);

	//
	// Set Noncausal, timeout, KeepAlive on the binding handle
	//
	SetBindNonCausal(GetBind());
	SetBindTimeout(GetBind());
	SetBindKeepAlive(GetBind());
}

//---------------------------------------------------------
//
//  Function:      CRRQueue::~CRRQueue
//
//  Description:   destructor
//
//---------------------------------------------------------

CBaseRRQueue::~CBaseRRQueue()
{
	m_dwSignature = 0;

    if (m_qName)
    {
       delete [] m_qName;
    }
    if (m_qid.pguidQueue)
    {
       delete m_qid.pguidQueue;
    }
}


CRRQueue::~CRRQueue()
{
	if(m_pRRContext != NULL)
	{
		CloseRRContext();
	}
}


CNewRRQueue::~CNewRRQueue()
{
	if(m_pNewRemoteReadContext != NULL)
	{
		CloseRRContext();
	}
}


void
RemoteQueueNameToMachineName(
	LPCWSTR RemoteQueueName,
	AP<WCHAR>& MachineName
	)
/*++
Routine description:
    RemoteQueueName as returned by QMGetRemoteQueueName() and R_QMOpenQueue()
	functions from the QM, has a varying format. this function extracts the
	Machine name from that string

Arguments:
	MachineName - Allocated string holding the machine name.
 --*/
{
	LPCWSTR RestOfNodeName;

	try
	{
		//
		// Skip direct token type if it exists (like "OS:" or "HTTP://"...)
		//
		DirectQueueType Dummy;
		RestOfNodeName = FnParseDirectQueueType(RemoteQueueName, &Dummy);
	}
	catch(const exception&)
	{
		RestOfNodeName = RemoteQueueName;
		TrERROR(GENERAL, "Failed to parse direct queue type for %ls.", RemoteQueueName);
	}

	try
	{
		//
		// Extracts machine name until seperator (one of "/" "\" ":")
		//
		FnExtractMachineNameFromDirectPath(
			RestOfNodeName,
			MachineName
			);
	}
	catch(const exception&)
	{
		//
		// No seperator found, so assume whole string is machine name
		//
		MachineName = newwcs(RestOfNodeName);
		LogIllegalPoint(s_FN, 315);
	}
}


static
VOID
QMpGetRemoteQmVersion(
    handle_t   hBind,
    UCHAR *    pMajor,
    UCHAR *    pMinor,
    USHORT *   pBuildNumber
    )
    throw()
/*++

Routine Description:

    Query remote QM for its version. RPC client side.
    This RPC call was added in MSMQ 3.0 so querying an older QM will raise
    RPC exception and this routine will return 0 as the version (major=0,
    minor=0, BuildNumber=0).

Arguments:

    hBind        - Binding handle.

    pMajor       - Points to output buffer to receive remote QM major version. May be NULL.

    pMinor       - Points to output buffer to receive remote QM minor version. May be NULL.

    pBuildNumber - Points to output buffer to receive remote QM build number. May be NULL.

Return Value:

    None.

--*/
{
    RpcTryExcept
    {
        R_RemoteQmGetVersion(hBind, pMajor, pMinor, pBuildNumber);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        (*pMajor) = 0;
        (*pMinor) = 0;
        (*pBuildNumber) = 0;
		LogIllegalPoint(s_FN, 325);
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

} // QMpGetRemoteQmVersion


ULONG 
CBaseRRQueue::BindInqRpcAuthnLevel(
		handle_t hBind
		)
/*++
Routine Description:
	Inquire the bindibg handle for the Authentication level.

Arguments:
	hBind - binding handle to inquire.

Returned Value:
	ULONG - RpcAuthnLevel used in the binding handle.

--*/
{
	ASSERT(hBind != NULL);
	
	ULONG RpcAuthnLevel;
	RPC_STATUS rc = RpcBindingInqAuthInfo(hBind, NULL, &RpcAuthnLevel, NULL, NULL, NULL); 
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to inquire Binding handle for the Auhtentication level, rc = %d", rc);
		return RPC_C_AUTHN_LEVEL_NONE;
	}
	
	TrTRACE(RPC, "RpcBindingInqAuthInfo, RpcAuthnLevel = %d", RpcAuthnLevel);

	return RpcAuthnLevel;
}


//---------------------------------------------------------
//
//  HRESULT  CRRQueue::BindRemoteQMService
//
//  Utility function to connect to a remote RPC QM.
//  This function creates the binding handle.
//
//---------------------------------------------------------

HRESULT  CRRQueue::BindRemoteQMService()
{
	ASSERT(GetBind2() == NULL);

    HRESULT hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;

    AP<WCHAR> MachineName;
	RemoteQueueNameToMachineName(GetQueueName(), MachineName);

    GetPort_ROUTINE pfnGetPort = R_RemoteQMGetQMQMServerPort;
    //
    // Using dynamic endpoints.
    //

	//
	// ISSUE-2002/01/06-ilanh RPC_C_AUTHN_LEVEL_PKT_INTEGRITY breaks workgroup
	//
	ULONG _eAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;

	//
	// m_hRemoteBind can be initialize by the constructor
	//
	if(GetBind() != NULL)
	{
		//
		// Use the same AuthnLevel that is used by the given binding handle	m_hRemoteBind
		//
		_eAuthnLevel = BindInqRpcAuthnLevel(GetBind());
	}

	
	if(GetBind() == NULL)
	{
		hr = CreateBind(
				MachineName.get(),
				&_eAuthnLevel,
				pfnGetPort
				);

		if (FAILED(hr))
		{
			TrERROR(RPC, "Failed bind remote QM (IP_HANDSHAKE), RemoteQm = %ls, _eAuthnLevel = %d, hr = %!HRESULT!", MachineName.get(), _eAuthnLevel, hr);
			return LogHR(hr, s_FN, 340);
		}
	}
	
	//
	// Set Noncausal, timeout, KeepAlive on the binding handle
	//
	SetBindNonCausal(GetBind());
	SetBindTimeout(GetBind());
	SetBindKeepAlive(GetBind());

	hr = CreateBind2(
			MachineName.get(),
			&_eAuthnLevel,
			IP_READ,
			pfnGetPort
			);

	TrTRACE(RPC, "_eAuthnLevel = %d", _eAuthnLevel);

	if (FAILED(hr))
	{
		TrERROR(RPC, "Failed bind remote QM (IP_READ), RemoteQm = %ls, _eAuthnLevel = %d, hr = %!HRESULT!", MachineName.get(), _eAuthnLevel, hr);
		return LogHR(hr, s_FN, 350);
	}

	//
	// Set Noncausal, timeout, KeepAlive on the binding handle
	// we don't set timeout on the second bind that use only for reads
	//
	SetBindNonCausal(GetBind2());
	SetBindKeepAlive(GetBind2());

	QMpGetRemoteQmVersion(GetBind(), &m_RemoteQmMajorVersion, &m_RemoteQmMinorVersion, &m_RemoteQmBuildNumber);

	return RPC_S_OK;
}


HRESULT 
CBaseRRQueue::CreateBind(
	LPWSTR MachineName,
	ULONG* peAuthnLevel,
	GetPort_ROUTINE pfnGetPort
	)
{
	return mqrpcBindQMService(
				MachineName,
				NULL,
				peAuthnLevel,
				&m_hRemoteBind,
				IP_HANDSHAKE,
				pfnGetPort,
				RPC_C_AUTHN_WINNT
				);
}


HRESULT 
CBaseRRQueue::CreateBind2(
	LPWSTR MachineName,
	ULONG* peAuthnLevel,
	PORTTYPE PortType,
	GetPort_ROUTINE pfnGetPort
	)
{
	return mqrpcBindQMService(
				MachineName,
				NULL,
				peAuthnLevel,
				&m_hRemoteBind2,
				PortType,
				pfnGetPort,
				RPC_C_AUTHN_WINNT
				);
}


//---------------------------------------------------------
//
//  CNewRRQueue::CreateReadBind
//
//  Create Read bind.
//  This function creates Read bind (bind2) if not already created.
//
//---------------------------------------------------------

void CNewRRQueue::CreateReadBind()
{
	ASSERT(GetBind() != NULL);

	if(GetBind2() != NULL)
		return;

    AP<WCHAR> MachineName;
	RemoteQueueNameToMachineName(GetQueueName(), MachineName);

	//
	// RemoteReadGetServerPort function ignore PortType and always use hardcoded IP_HANDSHAKE
	// so the parameter to CreateBind2 is not relevant
	//
    GetPort_ROUTINE pfnGetPort = RemoteReadGetServerPort;

	//
	// Use the same AuthnLevel that is used by the given binding handle	m_hRemoteBind
	//
	ULONG _eAuthnLevel = BindInqRpcAuthnLevel(GetBind());
	HRESULT hr = CreateBind2(
					MachineName.get(),
					&_eAuthnLevel,
					IP_HANDSHAKE,
					pfnGetPort
					);

	if (FAILED(hr))
	{
		TrERROR(RPC, "Failed SetBind2, RemoteQm = %ls, _eAuthnLevel = %d, hr = %!HRESULT!", MachineName.get(), _eAuthnLevel, hr);
		throw bad_hresult(hr);
	}

	TrTRACE(RPC, "_eAuthnLevel = %d", _eAuthnLevel);

	//
	// Set Noncausal, KeepAlive on the binding handle
	// we don't set timeout on the second bind that use only for reads
	//
	SetBindNonCausal(GetBind2());
	SetBindKeepAlive(GetBind2());
}


void CRRQueue::IncrementEndReceiveCnt()
{
    CS lock(m_PendingEndReceiveCS);

    m_EndReceiveCnt++;
	ASSERT(m_EndReceiveCnt >= 1);
    TrTRACE(RPC, "queue = %ls, EndReceiveCnt = %d", GetQueueName(), m_EndReceiveCnt);
}


void CRRQueue::DecrementEndReceiveCnt()
{
    CS lock(m_PendingEndReceiveCS);

    m_EndReceiveCnt--;
	ASSERT(m_EndReceiveCnt >= 0);
    TrTRACE(RPC, "queue = %ls, EndReceiveCnt = %d", GetQueueName(), m_EndReceiveCnt);

    if(m_EndReceiveCnt > 0)
    	return;

	//
	// Issue all StartReceive request that were pending for EndReceive complete
	//
	for(std::vector<COldRemoteRead*>::iterator it = m_PendingEndReceive.begin(); 
		it != m_PendingEndReceive.end();)
	{
		COldRemoteRead* pRemoteReadRequest = *it;
		it = m_PendingEndReceive.erase(it);
		pRemoteReadRequest->IssuePendingRemoteRead();
	}
}


bool 
CRRQueue::QueueStartReceiveRequestIfPendingForEndReceive(
	COldRemoteRead* pRemoteReadRequest
	)
/*++
Routine Description:
	If we are in the middle of EndReceive, Add the remote read request (old interface) to the PendingEndReceiveStart vector.

Arguments:
	pRemoteReadRequest - remote read request- old interface

Returned Value:
	true - the request was queued in the vector, false if not

--*/
{
    CS lock(m_PendingEndReceiveCS);

	ASSERT(m_EndReceiveCnt >= 0);

    if(m_EndReceiveCnt == 0)
    {
		ASSERT(m_PendingEndReceive.empty());
    	return false;
    }
    
	m_PendingEndReceive.push_back(pRemoteReadRequest);
	return true;    
}


void
CRRQueue::CancelPendingStartReceiveRequest(
	CACRequest *pRequest
	)
/*++
Routine Description:
	Check if the Cancel remote read request was not yet issued and is pending to start.
	In this case, remove the pending request from the vector and throw exception.
	In case the request already issued the function return normaly.

Arguments:
	pRequest - driver request data.

Returned Value:
	None.
	Normal execution - the remote read request already issued.
	exception - the remote read request was not issued and found in the pending vector.

--*/
{
    CS lock(m_PendingEndReceiveCS);

	ASSERT(m_EndReceiveCnt >= 0);

    if(m_EndReceiveCnt == 0)
    {
		ASSERT(m_PendingEndReceive.empty());
    	return;
    }
    
	if(m_PendingEndReceive.empty())
	{
    	return;
	}
	
	//
	// Search all pending StartReceive request for matching Tag
	//
	ULONG ulTag = pRequest->Remote.Read.ulTag;
	for(std::vector<COldRemoteRead*>::iterator it = m_PendingEndReceive.begin(); 
		it != m_PendingEndReceive.end(); it++)
	{
		COldRemoteRead* pRemoteReadRequest = *it;
		if(pRemoteReadRequest->GetTag() == ulTag)
		{
		    TrTRACE(RPC, "queue = %ls, Tag = %d", GetQueueName(), ulTag);
			m_PendingEndReceive.erase(it);

			//
			// Same delete for not issuing "original" IssueRemoteRead.
			//
			delete pRemoteReadRequest;

			//
			// We throw here, so we will not continue in the normal CancelReceive path
			// and issue cancel receive request.
			//
			throw bad_hresult(MQ_ERROR_OPERATION_CANCELLED);
		}
	}
}


COldRemoteRead* CRRQueue::CreateRemoteReadRequest(CACRequest *pRequest)
{
	bool fRemoteQmSupportsLatest = QMpIsLatestRemoteReadInterfaceSupported(
										m_RemoteQmMajorVersion,
										m_RemoteQmMinorVersion,
										m_RemoteQmBuildNumber
										);

	TrTRACE(RPC, "fRemoteQmSupportsLatest = %d, RemoteQmVersion = %d.%d.%d", fRemoteQmSupportsLatest, m_RemoteQmMajorVersion, m_RemoteQmMinorVersion, m_RemoteQmBuildNumber);

    return new COldRemoteRead(
				    pRequest, 
				    GetBind2(),
				    this,
				    fRemoteQmSupportsLatest
				    );
}


CNewRemoteRead* CNewRRQueue::CreateRemoteReadRequest(CACRequest *pRequest)
{
	CreateReadBind();
	return new CNewRemoteRead(
				    pRequest, 
				    GetBind2(),
				    this
				    );
}


void CBaseRRQueue::RemoteRead(CACRequest *pRequest)
{
	HRESULT hr = MQ_OK;
	try
	{
	    //
	    // Initialize the EXOVERLAPPED with RemoteRead callback routines
	    // And issue the remote read async rpc call.
		//
	    P<CRemoteReadBase> pRequestRemoteReadOv = CreateRemoteReadRequest(pRequest);
	    
		pRequestRemoteReadOv->IssueRemoteRead();

	    pRequestRemoteReadOv.detach();
	    return;
	}
	catch(const bad_hresult& e)
	{
    	hr = e.error();
    }
	catch(const exception&)
	{
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	TrERROR(RPC, "Failed to issue RemoteRead for queue = %ls, hr = %!hresult!", GetQueueName(), hr);

    hr =  ACCancelRequest(
                m_cli_hACQueue,
                hr,
                pRequest->Remote.Read.ulTag
                );
    
	if(FAILED(hr))
	{
        TrERROR(RPC, "ACCancelRequest failed, hr = %!hresult!", hr);
	}
}


COldRemoteCloseQueue* CRRQueue::CreateCloseRRContextRequest()
{
	ASSERT(m_pRRContext != NULL);
    COldRemoteCloseQueue* pOldRemoteCloseQueue = new COldRemoteCloseQueue(
														    GetBind(),
														    m_pRRContext
														    );

	//
	// Ownership to free the binding handle was transfered to COldRemoteCloseQueue class
	//
	DetachBind();
	return pOldRemoteCloseQueue; 
}


CNewRemoteCloseQueue* CNewRRQueue::CreateCloseRRContextRequest()
{
	ASSERT(m_pNewRemoteReadContext != NULL);
	CNewRemoteCloseQueue* pNewRemoteCloseQueue = new CNewRemoteCloseQueue(
													    GetBind(),
													    m_pNewRemoteReadContext
													    );

	//
	// Ownership to free the binding handle was transfered to CNewRemoteCloseQueue class
	//
	DetachBind();
	return pNewRemoteCloseQueue;
}


void CBaseRRQueue::CloseRRContext()
/*++
Routine Description:
	Close the Session context (PCTX_RRSESSION_HANDLE or RemoteReadContextHandle) on the server.
	This function is called from the CRRQueue or CNewRRQueue dtor only.
	It close the session context in the server in case of normal operation 
	or failure during the open operations after we open the SESSION with the server and create the queue object.

Arguments:
	None.

Returned Value:
	None.

--*/
{
	
	try
	{
	    //
	    // Initialize the EXOVERLAPPED with RemoteCloseQueue callback routines
	    // And issue the close Remote queue async rpc call.
		//
	    P<CRemoteCloseQueueBase> pRequestRemoteCloseQueueOv = CreateCloseRRContextRequest();
		
		pRequestRemoteCloseQueueOv->IssueCloseQueue();

		//
		// RemoteCloseQueue request will free RRContext. 
		//
	    ResetRRContext();

	    pRequestRemoteCloseQueueOv.detach();
	    return;
	}
	catch(const exception&)
	{
		//
		// Failed to close the handle with the server.
		// Destroy the local handle.
		//
		DestroyClientRRContext();
		
		//
		// Note that we don't propagate exceptions from this function.
		// this is not a request from the driver. 
		// it is context cleanup during a failure in the open operation.
		//
		TrERROR(RPC, "Failed to issue RemoteCloseQueue for queue = %ls", GetQueueName());
	}
}


COldRemoteCreateCursor* CRRQueue::CreateRemoteCreateCursorRequest(CACRequest* pRequest)
{
	return new COldRemoteCreateCursor(
				    pRequest, 
				    GetBind(),
				    this
				    );
}


CNewRemoteCreateCursor* CNewRRQueue::CreateRemoteCreateCursorRequest(CACRequest* pRequest)
{
    return new CNewRemoteCreateCursor(
				    pRequest, 
				    GetBind(),
				    this
				    );
}


void CBaseRRQueue::RemoteCreateCursor(CACRequest *pRequest)
{
	HRESULT hr = MQ_OK;
	try
	{
	    //
	    // Initialize the EXOVERLAPPED with RemoteCreateCursor callback routines
	    // And issue the create cursor async rpc call.
		//
	    P<CRemoteCreateCursorBase> pRequestRemoteCreateCursorOv = CreateRemoteCreateCursorRequest(pRequest);

	    pRequestRemoteCreateCursorOv->IssueCreateCursor();

	    pRequestRemoteCreateCursorOv.detach();
	    return;
	}
	catch(const bad_hresult& e)
	{
    	hr = e.error();
    }
	catch(const exception&)
	{
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	TrERROR(RPC, "Failed to issue RemoteCreateCursor for queue = %ls, hr = %!hresult!", GetQueueName(), hr);

    hr =  ACCancelRequest(
                m_cli_hACQueue,
                hr,
                pRequest->Remote.CreateCursor.ulTag
                );
    
	if(FAILED(hr))
	{
        TrERROR(RPC, "ACCancelRequest failed, hr = %!hresult!", hr);
	}
	
}


COldRemoteCloseCursor* CRRQueue::CreateRemoteCloseCursorRequest(CACRequest* pRequest)
{
    return new COldRemoteCloseCursor(
				    pRequest, 
				    GetBind(),
				    this
				    );
}


CNewRemoteCloseCursor* CNewRRQueue::CreateRemoteCloseCursorRequest(CACRequest* pRequest)
{
    return new CNewRemoteCloseCursor(
				    pRequest, 
				    GetBind(),
				    this
				    );
}


void CBaseRRQueue::RemoteCloseCursor(CACRequest *pRequest)
{
    //
    // Initialize the EXOVERLAPPED with RemoteCloseCursor callback routines
    // And issue the close cursor async rpc call.
	//
    P<CRemoteCloseCursorBase> pRequestRemoteCloseCursorOv = CreateRemoteCloseCursorRequest(pRequest);

	pRequestRemoteCloseCursorOv->IssueCloseCursor();

    pRequestRemoteCloseCursorOv.detach();
}


COldRemotePurgeQueue* CRRQueue::CreateRemotePurgeQueueRequest()
{
    return new COldRemotePurgeQueue(
				    GetBind(),
				    this
				    );
}


CNewRemotePurgeQueue* CNewRRQueue::CreateRemotePurgeQueueRequest()
{
    return new CNewRemotePurgeQueue(
				    GetBind(),
				    this
				    );
}


void CBaseRRQueue::RemotePurgeQueue()
{
    //
    // Initialize the EXOVERLAPPED with RemotePurgeQueue callback routines
    // And issue the purge queue async rpc call.
	//
    P<CRemotePurgeQueueBase> pRequestRemotePurgeQueueOv = CreateRemotePurgeQueueRequest();

	pRequestRemotePurgeQueueOv->IssuePurgeQueue();

    pRequestRemotePurgeQueueOv.detach();
}


COldRemoteCancelRead* CRRQueue::CreateRemoteCancelReadRequest(CACRequest* pRequest)
{
	//
	// If the read call is pending to start, we removed it from the vector
	// no need to issue the cancel call.
	// In this case CancelPendingStartReceiveRequest throw exception that will be caught in GetServiceRequestSucceeded.
	//
	CancelPendingStartReceiveRequest(pRequest);

	//
	// The cancel request was already issued, continue in the normal path
	// of creating the request class 
	//
    return new COldRemoteCancelRead(
				    pRequest, 
				    GetBind(),
				    this
				    );
}


CNewRemoteCancelRead* CNewRRQueue::CreateRemoteCancelReadRequest(CACRequest* pRequest)
{
    return new CNewRemoteCancelRead(
				    pRequest, 
				    GetBind(),
				    this
				    );
}

void CBaseRRQueue::RemoteCancelRead(CACRequest *pRequest)
{
    //
    // Initialize the EXOVERLAPPED with RemoteCancelRead callback routines
    // And issue the purge queue async rpc call.
	//
    P<CRemoteCancelReadBase> pRequestRemoteCancelReadOv = CreateRemoteCancelReadRequest(pRequest);

	pRequestRemoteCancelReadOv->IssueRemoteCancelRead();

    pRequestRemoteCancelReadOv.detach();
}


//---------------------------------------------------------
//
//  HRESULT CRRQueue::OpenRRSession()
//
//  Open remote session with the server. pass the server the
//  handle and queue pointer
//
//---------------------------------------------------------

HRESULT 
CRRQueue::OpenRRSession( 
		ULONG srv_hACQueue,
		ULONG srv_pQMQueue,
		PCTX_RRSESSION_HANDLE_TYPE *ppRRContext,
		DWORD  dwpContext 
		)
{
    HRESULT hrpc =  BindRemoteQMService();
    if (FAILED(hrpc))
    {
        LogHR(hrpc, s_FN, 120);
        return MQ_ERROR;
    }

    RpcTryExcept
    {
        HRESULT hr = R_RemoteQMOpenQueue(
		                GetBind(),
		                ppRRContext,
		                (GUID *) QueueMgr.GetQMGuid(),
		                (IsNonServer() ? SERVICE_NONE : SERVICE_SRV),  // [adsrv] QueueMgr.GetMQS(),  We simulate old?
		                srv_hACQueue,
		                srv_pQMQueue,
		                dwpContext 
		                );
        return hr;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		HRESULT hr = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "R_RemoteQMOpenQueue Failed, %!hresult!", hr);
	        return hr;
		}

        TrERROR(RPC, "R_RemoteQMOpenQueue Failed, gle = %!winerr!", hr);
        return HRESULT_FROM_WIN32(hr);
    }
	RpcEndExcept
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\remoteread_c_.c ===
#pragma warning(push, 3)
#include <RemoteRead_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\remoteread_s_.c ===
#pragma warning(push, 3)
#include <RemoteRead_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rmdupl.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    rmdupl.cpp

Abstract:
    Remove Duplicate implementation

Author:
    Uri Habusha (urih)   18-Oct-98

Enviroment:
    Pltform-independent 

--*/

#include "stdh.h"
#include <qmpkt.h>
#include "list.h"
#include "rmdupl.h"
#include <Tr.h>
#include <Ex.h>

#include "rmdupl.tmh"

static WCHAR *s_FN=L"rmdupl";

using namespace std;


struct CMsgEntry;

struct msg_entry_less : public std::binary_function<const CMsgEntry*, const CMsgEntry*, bool> 
{
    bool operator()(const CMsgEntry* k1, const CMsgEntry* k2) const;
};


typedef set<CMsgEntry*, msg_entry_less> SET_MSG_ID;
typedef map<GUID, SET_MSG_ID> MAP_SOURCE;

struct CMsgEntry
{
public:
    CMsgEntry(
        DWORD id, 
        MAP_SOURCE::iterator it
        );

    void UpdateTimeStamp(void);

public:
    LIST_ENTRY  m_link;

    DWORD m_MsgId;
    DWORD m_TimeStamp;
    MAP_SOURCE::iterator m_it;
};

bool msg_entry_less::operator()(const CMsgEntry* k1, const CMsgEntry* k2) const
{
    return (k1->m_MsgId < k2->m_MsgId);
}

inline bool operator < (const GUID& k1, const GUID& k2)
{
    return (memcmp(&k1, &k2, sizeof(GUID)) < 0);
}


inline
CMsgEntry::CMsgEntry(
    DWORD id, 
    MAP_SOURCE::iterator it
    ) :
    m_MsgId(id),
    m_it(it),
    m_TimeStamp(GetTickCount())
{
    m_link.Flink = NULL;
    m_link.Blink = NULL;
}

inline
void 
CMsgEntry::UpdateTimeStamp(
    void
    )
{
    m_TimeStamp = GetTickCount();
}


class CMessageMap
{
public:
    CMessageMap();
    ~CMessageMap();

    BOOL InsertMessage(const OBJECTID& MsgId);
    void RemoveMessage(const OBJECTID& MsgId);

    static void WINAPI TimeToCleanup(CTimer* pTimer);

private:
    CMsgEntry* GetNewMessageEntry(DWORD MessageID, MAP_SOURCE::iterator it);

    void HandelCleanupSchedule(void);
    void CleanUp(DWORD CleanUpInterval);

#ifdef _DEBUG
    void DebugMsg(LPCWSTR msg, const GUID& MachineId, DWORD MsgId) const;
#else
    #define DebugMsg(msg, MachineId, MsgId) ((void) 0 )
#endif

    
private:
    CCriticalSection m_cs;

    List<CMsgEntry> m_OrderedList;
    MAP_SOURCE m_ReceivedMsgMap;
    CTimer m_CleanupTimer;
    BOOL m_fCleanupScheduled;

    DWORD m_CleanUpInterval;
    DWORD m_MaxSize;

    DWORD m_DuplicateStatics;
    DWORD m_ListCount;
};


CMessageMap::CMessageMap() :
    m_fCleanupScheduled(FALSE),
    m_CleanupTimer(TimeToCleanup),
    m_CleanUpInterval(MSMQ_DEFAULT_REMOVE_DUPLICATE_CLEANUP),
    m_MaxSize(MSMQ_DEFAULT_REMOVE_DUPLICATE_SIZE),
    m_DuplicateStatics(0),
    m_ListCount(0)
{
    //
    // Get the tabel size
    //
    DWORD size = sizeof(DWORD);
    DWORD type = REG_DWORD;
    GetFalconKeyValue(
        MSMQ_REMOVE_DUPLICATE_SIZE_REGNAME,
        &type,
        &m_MaxSize,
        &size
        );

    //
    // Get the Cleanup Interval
    //
    size = sizeof(DWORD);
    type = REG_DWORD;
    GetFalconKeyValue(
        MSMQ_REMOVE_DUPLICATE_CLEANUP_REGNAME,
        &type,
        &m_CleanUpInterval,
        &size
        );
}


CMessageMap::~CMessageMap()
{
    CS lock(m_cs);

    //
    // remove all the entries from the map and free the memory
    //
    CleanUp(0);
    ASSERT(m_ReceivedMsgMap.empty());
    ASSERT(m_OrderedList.empty());
    ASSERT(m_ListCount == 0);
}


CMsgEntry* 
CMessageMap::GetNewMessageEntry(
    DWORD MessageID, 
    MAP_SOURCE::iterator it
    )
/*++

  Routine Description:
    The routine returns Message Entry for the new messge. If the tabel size reach the 
    limitation the routine removes the oldest entry and reuse it for the new one

  Parameters:
    MessageID - the message Id of the stored message
    it - iterator to the source map.

  Return value:
    pointer to the new message entry. If the new failed due lack of resources an
    exception is raised and handel at the API level

 --*/
{
    if(m_ListCount < m_MaxSize)
    {
        return new CMsgEntry(MessageID, it);
    }

    //
    // We reach the size limitation. Remove the oldest message
    // Id and use its structure for saving the new message
    //
	ASSERT(!m_OrderedList.empty());
    CMsgEntry* pMsgEntry = &m_OrderedList.front();
    m_OrderedList.pop_front();
    --m_ListCount;


    SET_MSG_ID& MsgMap = pMsgEntry->m_it->second;

    //
    // remove the entry from the source machine message ID
    //
    MsgMap.erase(pMsgEntry);

    //
    // if it was the last message in the map and it is not the entry
    // where the new one should be entered, remove it 
    //
    if (MsgMap.empty() && (pMsgEntry->m_it != it))
    {
        m_ReceivedMsgMap.erase(pMsgEntry->m_it);
    }

    #pragma PUSH_NEW
    #undef new

    return new (pMsgEntry) CMsgEntry(MessageID, it);

    #pragma POP_NEW
}

BOOL
CMessageMap::InsertMessage(
    const OBJECTID& MsgId
    )
/*++

  Routine Description:
    The routine insert a message to the remove duplicate tabel if 
    it doesn't exist

  Parameter:
    MsgId - a message ID that consist from GUID that specify the source machine
            and unique ID

  Returned Value:
    TRUE - if it is a new message ( the message inserted). FALSE otherwise.

 --*/
{
    //
    // MaxSize = 0 indicates not using the remove duplicate mechanism.
    // Don't try to enter the message, return immidietly.
    //
    if (m_MaxSize == 0)
        return TRUE;

    CS lock(m_cs);

    MAP_SOURCE::iterator it;

    //
    // Check if the source is already isn the map. If no, insert the source to the map. 
    // Generaly, the source will be in the map, therfore call find before insert
    // insert returnes the iterator. 
    //
    it = m_ReceivedMsgMap.find(MsgId.Lineage);
    if (it == m_ReceivedMsgMap.end())
    {
        pair<MAP_SOURCE::iterator, bool> p;
        p = m_ReceivedMsgMap.insert(MAP_SOURCE::value_type(MsgId.Lineage, SET_MSG_ID()));
        it = p.first;
    }
    
    //
    // Create message entry to add to the map
    //
    CMsgEntry* pMsgEntry = GetNewMessageEntry(MsgId.Uniquifier, it);

    //
    // Insert the message entry to the map. If it already exist, the inset fails
    // and it the returns FALSE (in pair.second)
    //
    SET_MSG_ID& MsgMap = it->second;
    pair<SET_MSG_ID::iterator, bool> MsgPair = MsgMap.insert(pMsgEntry);
    if (!MsgPair.second)
    {
        DebugMsg(L"Insert - DUPLICATE message", MsgId.Lineage, MsgId.Uniquifier);

        //
        // already exist. Get the existing entry and move it to the end of the 
        // racent use list
        //
        CMsgEntry* pExist = *(MsgPair.first);
        m_OrderedList.remove(*pExist);
        m_OrderedList.push_back(*pExist);
        pExist->UpdateTimeStamp();

        delete pMsgEntry;

        //
        // Update duplicate statics
        //
        ++m_DuplicateStatics;

        return FALSE;
    }

    //
    // A new entry. Add it to the last recent use list
    //
    DebugMsg(L"Insert", MsgId.Lineage, MsgId.Uniquifier);
    m_OrderedList.push_back(*pMsgEntry);
    ++m_ListCount;

    //
    // Check if the cleanup secduler already set.
    //
    if (!m_fCleanupScheduled)
    {
        //
        // The scheduler was not set. Begin the cleanup scheduler
        //
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_CleanUpInterval));
        m_fCleanupScheduled = TRUE;
    }

    return TRUE;
}


void 
CMessageMap::RemoveMessage(
    const OBJECTID& MsgId
    )
/*++

  Routine Description:
    The routine remove a message from the remove duplicate tabel if 
    it exist

  Parameter:
    MsgId - a message ID that consist from GUID that specify the source machine
            and unique ID

  Returned Value:
    None

 --*/
{
    CS lock(m_cs);

    //
    // Look if the source machine exist in map. If no the message doesn't exist
    //
    MAP_SOURCE::iterator it;
    it = m_ReceivedMsgMap.find(MsgId.Lineage);
    if (it == m_ReceivedMsgMap.end())
        return;

    //
    // Look for the message ID in the message Id map
    //
    SET_MSG_ID& MsgMap = it->second;
    SET_MSG_ID::iterator it1;
	CMsgEntry MsgEntry(MsgId.Uniquifier, NULL);
    it1 = MsgMap.find(&MsgEntry);
    if (it1 == MsgMap.end())
        return;

    CMsgEntry* pMsgEntry = *it1;
    
    //
    // Remove the message from the recent use list
    //
    m_OrderedList.remove(*pMsgEntry);
    --m_ListCount;

    //
    // remove the message from the map
    //
    MsgMap.erase(it1);
    delete pMsgEntry;

    //
    // if it was the last message in the source map. remove the source from the map.
    //
    if (MsgMap.empty())
    {
        m_ReceivedMsgMap.erase(it);
    }
}


void 
CMessageMap::CleanUp(
    DWORD CleanUpInterval
    )
/*++

  Routine Description:
    the routine called periodically ( default each 30 minutes) and uses to clean
    the remove duplicate tabel. All the messages that are before the cleanup 
    interval are removed

  Parameters:
    fCleanAll - TRUE, indicates to remove all the elements from the tabel. 
                FALSE, using the cleanup interval
                    
  Returned Value:
    None.
 --*/
{
    DWORD CurrentTime = GetTickCount();

    //
    // Get the oldest message from the "recent use" list
    //
    for(;;)
    {
    	if(m_OrderedList.empty())
    		return;
    	
        CMsgEntry* pMsg = &m_OrderedList.front();

        if (CleanUpInterval > (CurrentTime - pMsg->m_TimeStamp))
        {
            //
            // the message are ordered accoring the receiving time. If this
            // message received after the cleanup interval, it means that 
            // the rest of the message also. 
            //
            return;
        }

        //
        // Remove the message from the list and from the tabel
        //
        m_OrderedList.pop_front();
        --m_ListCount;
        SET_MSG_ID& MsgMap = pMsg->m_it->second;

        MsgMap.erase(pMsg);
        if (MsgMap.empty())
        {
            m_ReceivedMsgMap.erase(pMsg->m_it);
        }
        delete pMsg;
    }
}


inline 
void
CMessageMap::HandelCleanupSchedule(
    void
    )
{
    CS lock(m_cs);

    CleanUp(m_CleanUpInterval);

    //
    // If the map isn't empty, begin the cleanup scheduler
    //
    if (!m_ReceivedMsgMap.empty())
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_CleanUpInterval));
    }
    else
    {
        m_fCleanupScheduled = FALSE;
    }

}


#ifdef _DEBUG

inline
void 
CMessageMap::DebugMsg(
    LPCWSTR msg, 
    const GUID& MachineId,
    DWORD MsgId
    ) const
{
    TrTRACE(NETWORKING, "CMessageMap %ls: " LOG_GUID_FMT "\\%d", msg, &MachineId, MsgId); 
}

#endif


void 
WINAPI 
CMessageMap::TimeToCleanup(
    CTimer* pTimer
    )
{
    CMessageMap* pMsgMap = CONTAINING_RECORD(pTimer, CMessageMap, m_CleanupTimer);
    pMsgMap->HandelCleanupSchedule();

}



static CMessageMap s_DuplicateMessageMap;

BOOL 
DpInsertMessage(
    const CQmPacket& QmPkt
    )
{
    //
    // Packets sent to multiple destination queues have several copies with same msgid
    // so we do not insert them to the dup removal database.
    //
    if (QmPkt.GetNumOfDestinationMqfElements() != 0)
    {
        return TRUE;
    }

	OBJECTID MsgId;
    QmPkt.GetMessageId(&MsgId);
	
    //
    // All non MSMQ SRMP messages get the same message Id. so we do not insert them 
    // to the dup removal database.
    //
    if (MsgId.Lineage == GUID_NULL)
    {
        ASSERT(MsgId.Uniquifier == 1);
        return TRUE;
    }

    try
    {
        return s_DuplicateMessageMap.InsertMessage(MsgId);
    }
    catch(const ::bad_alloc&)
    {
        //
        // Continue. If insert failed due to recource limitation, we don't care. The 
        // worst thing that can cause is duplicate message
        // 
        TrWARNING(NETWORKING, "Insert Message to Remove Duplicate Data structure failed due recource limitation"); 

        LogIllegalPoint(s_FN, 73);
    }
    
    return TRUE;
}


void 
DpRemoveMessage(
    const CQmPacket& QmPkt
    )
{
    //
    // Packets sent to multiple destination queues have several copies with same msgid
    // so we do not insert them to the dup removal database.
    //
    if (QmPkt.GetNumOfDestinationMqfElements() != 0)
    {
        return;
    }

	OBJECTID MsgId;
    QmPkt.GetMessageId(&MsgId);

    s_DuplicateMessageMap.RemoveMessage(MsgId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rmdupl.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rmdupl.h

Abstract:
    Remove Duplicate function decleration

Author:
    Uri Habusha (urih), 1-Oct-98

Revision History:

--*/

#ifndef __RMDUPL_H__
#define __RMDUPL_H__

BOOL DpInsertMessage(const CQmPacket& QmPkt);
void DpRemoveMessage(const CQmPacket& QmPkt);

///////////////////////////////////////////////////////////////////////////
//
// Class that clean given packet from the remove duplicate map
// Used  to clean packet that were rejected from the duplicate map
//
///////////////////////////////////////////////////////////////////////////
class CAutoDeletePacketFromDuplicateMap
{
public:
	CAutoDeletePacketFromDuplicateMap(
		const CQmPacket* packet
		):
		m_packet(packet)
	{
	}

	~CAutoDeletePacketFromDuplicateMap()
	{
		if(m_packet != NULL)
		{
			DpRemoveMessage(*m_packet);			
		}
	}

	void detach()
	{
		m_packet = NULL;		
	}

private:
	const CQmPacket* m_packet;
};



#endif //__RMDUPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\remotereadsrv.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    RemoteReadSrv.cpp

Abstract:

    Remove Read interface server side.

Author:

    Ilan Herbst (ilanh) 28-Jan-2002

--*/


#include "stdh.h"
#include "RemoteRead.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "phinfo.h"
#include "qmrpcsrv.h"
#include "license.h"
#include <Fn.h>
#include <version.h>
#include "rpcsrv.h"
#include "qmcommnd.h"
#include "rrSrvCommon.h"
#include "mqexception.h"
#include <mqsec.h>
#include <cm.h>
#include "RemoteReadCli.h"

#include "qmacapi.h"

#include "RemoteReadSrv.tmh"


extern BOOL g_fPureWorkGroupMachine;

enum SectionType
{
    stFullPacket,
    stTillEndOfPropertyHeader,
    stAfterPropertyHeader,
    stTillEndOfCompoundMessageHeader,
    stAfterCompoundMessageHeader
};

class CEndReceiveCtx;
class CGetPacket2RemoteOv;

//---------------------------------------
//
//  CRemoteReadCtx - Remote Read context
//
//---------------------------------------
class CRemoteReadCtx : public CTX_OPENREMOTE_BASE
{
public:

    static const DWORD xEndReceiveTimerDeltaInterval = 10 * 1000;	// 10 sec
    static const DWORD xClientDisconnectedTimerInterval = 60 * 1000 * 10;	// 10 minutes
    static const DWORD xMinTimeoutForSettingClientDisconnectedTimer = 60 * 1000 * 15;	// 15 minutes

public:
	CRemoteReadCtx(
		HANDLE hLocalQueue,
		CQueue* pLocalQueue,
		GUID* pLicGuid,
		BOOL fLicensed,
	    UCHAR Major,
	    UCHAR Minor,
	    USHORT BuildNumber,
		BOOL fWorkgroup
		) :
		CTX_OPENREMOTE_BASE(hLocalQueue, pLocalQueue),
		m_ClientQMGuid(*pLicGuid),
		m_fLicensed(fLicensed),
    	m_Major(Major),
	 	m_Minor(Minor),
    	m_BuildNumber(BuildNumber),
		m_fWorkgroupClient(fWorkgroup),
		m_fClientDisconnectedTimerScheduled(false),
		m_ClientDisconnectedTimer(ClientDisconnectedTimerRoutine),
		m_fEndReceiveTimerScheduled(false),
		m_EndReceiveTimer(EndReceiveTimerRoutine)
	{
		m_eType = CBaseContextType::eNewRemoteReadCtx;
	}


	bool IsClientRC1()
	{
		if((m_Major == 5) && (m_Minor == 2) && (m_BuildNumber == 1660))
			return true;

		return false;
	}

	void SetEndReceiveTimerIfNeeded();
	
	static void WINAPI EndReceiveTimerRoutine(CTimer* pTimer);

	void CancelExpiredEndReceives();

	void SetClientDisconnectedTimerIfNeeded(ULONG ulTimeout);
	
	static void WINAPI ClientDisconnectedTimerRoutine(CTimer* pTimer);

	void CheckClientDisconnected();

	void CancelAllPendingRemoteReads();

	void StartAllPendingForEndReceive();
	
	HRESULT 
	CancelPendingRemoteRead(
		DWORD cli_tag
		);

	void 
	RegisterReadRequest(
		ULONG cli_tag, 
		R<CGetPacket2RemoteOv>& pCGetPacket2RemoteOv
		);

	void 
	UnregisterReadRequest(
		DWORD cli_tag
		);

	bool 
	FindReadRequest(
		ULONG cli_tag
		);

	bool IsWaitingForEndReceive();

	void CancelAllEndReceiveInMap();

	void CancelAllExpiredEndReceiveInMap();

	void 
	AddEndReceiveToMap(
		ULONG cli_tag,
		P<CEndReceiveCtx>& pEndReceiveCtx
		);

	void 
	RemoveEndReceiveFromMap(
		ULONG cli_tag,
		P<CEndReceiveCtx>& pEndReceiveCtx
		);

private:
	~CRemoteReadCtx()
	{
		ASSERT(!IsWaitingForEndReceive());
	    TrTRACE(RPC, "Cleaning RemoteRead context, pctx = 0x%p, Queue = %ls, hQueue = 0x%p", this, m_pLocalQueue->GetQueueName(), m_hQueue);
	}

public:
	GUID     m_ClientQMGuid;
	BOOL     m_fLicensed;
	BOOL     m_fWorkgroupClient;
    UCHAR 	 m_Major;
    UCHAR 	 m_Minor;
    USHORT 	 m_BuildNumber;

    //
    // EndReceiveCtx map.
    //
	bool m_fEndReceiveTimerScheduled;
	CTimer m_EndReceiveTimer;
    CCriticalSection m_EndReceiveMapCS;
    std::map<ULONG, CEndReceiveCtx*> m_EndReceiveCtxMap;

    //
    // Pending RemoteReads map.
    //
	bool m_fClientDisconnectedTimerScheduled;
	CTimer m_ClientDisconnectedTimer;
    CCriticalSection m_PendingRemoteReadsCS;
    std::map<ULONG, R<CGetPacket2RemoteOv> > m_PendingRemoteReads;
};



//---------------------------------------
//
//  CEndReceiveCtx - end receive context
//
//---------------------------------------
class CEndReceiveCtx
{
public:
	CEndReceiveCtx(
		CRemoteReadCtx* pOpenRemoteCtx,
		DWORD hCursor,
		CBaseHeader* lpPacket,
		CPacket* lpDriverPacket,
		ULONG ulTimeout,
		ULONG ulAction,
		ULONG CliTag
		) :
		m_pOpenRemoteCtx(SafeAddRef(pOpenRemoteCtx)),
		m_hQueue(pOpenRemoteCtx->m_hQueue),
		m_lpPacket(lpPacket),
		m_lpDriverPacket(lpDriverPacket),
		m_ulTimeout(ulTimeout),
		m_ulAction(ulAction),
		m_CliTag(CliTag),
		m_TimeIssued(time(NULL))
	{
		if(hCursor != 0)
		{
			//
			// Take reference on Cursor object
			//
			m_pCursor = pOpenRemoteCtx->GetCursorFromMap(hCursor);
		}
	}


	HRESULT EndReceive(REMOTEREADACK eRRAck)
	{
	    TrTRACE(RPC, "EndReceive, hQueue = 0x%p, CliTag = %d", m_hQueue, m_CliTag);

		HRESULT hr = QMRemoteEndReceiveInternal( 
							m_hQueue,
							GetCursor(),
							m_ulTimeout,
							m_ulAction,
							eRRAck,
							m_lpPacket,
							m_lpDriverPacket
							);
		if(FAILED(hr))
		{
			TrERROR(RPC, "Failed to End Receive, %!hresult!", hr);		
		}
		return hr;
	}

	~CEndReceiveCtx()
	{
	    TrTRACE(RPC, "Cleaning EndReceive context, hQueue = 0x%p", m_hQueue);
	}

	HACCursor32 GetCursor()
	{
		if(m_pCursor.get() == NULL)
		{ 
			return 0;
		}

		return m_pCursor->GetCursor();
	}


public:
	R<CRemoteReadCtx> m_pOpenRemoteCtx;
	HANDLE m_hQueue;
	R<CRRCursor> m_pCursor;
	ULONG    m_ulTimeout;
	ULONG    m_ulAction;
	ULONG    m_CliTag;
	CBaseHeader*  m_lpPacket;
	CPacket* m_lpDriverPacket;
	time_t m_TimeIssued;
};


static bool s_fInitialized = false;
static bool s_fServerDenyWorkgroupClients = false;

static bool ServerDenyWorkgroupClients()
/*++

Routine Description:
    Read ServerDenyWorkgroupClients flag from registry

Arguments:
	None

Return Value:
	ServerDenyWorkgroupClients flag from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	if(s_fInitialized)
	{
		return s_fServerDenyWorkgroupClients;
	}

	const RegEntry xRegEntry(MSMQ_SECURITY_REGKEY, MSMQ_NEW_REMOTE_READ_SERVER_DENY_WORKGROUP_CLIENT_REGVALUE, MSMQ_NEW_REMOTE_READ_SERVER_DENY_WORKGROUP_CLIENT_DEFAULT);
	DWORD dwServerDenyWorkgroupClients = 0;
	CmQueryValue(xRegEntry, &dwServerDenyWorkgroupClients);
	s_fServerDenyWorkgroupClients = (dwServerDenyWorkgroupClients != 0);

	s_fInitialized = true;

	return s_fServerDenyWorkgroupClients;
}


static bool s_fInitializedNoneSec = false;
static bool s_fServerAllowNoneSecurityClients = false;

static bool ServerAllowNoneSecurityClients()
/*++

Routine Description:
    Read ServerAllowNoneSecurityClient flag from registry

Arguments:
	None

Return Value:
	ServerAllowNoneSecurityClient flag from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	if(s_fInitializedNoneSec)
	{
		return s_fServerAllowNoneSecurityClients;
	}

	const RegEntry xRegEntry(
						MSMQ_SECURITY_REGKEY, 
						MSMQ_NEW_REMOTE_READ_SERVER_ALLOW_NONE_SECURITY_CLIENT_REGVALUE, 
						MSMQ_NEW_REMOTE_READ_SERVER_ALLOW_NONE_SECURITY_CLIENT_DEFAULT
						);
	
	DWORD dwServerAllowNoneSecurityClients = 0;
	CmQueryValue(xRegEntry, &dwServerAllowNoneSecurityClients);
	s_fServerAllowNoneSecurityClients = (dwServerAllowNoneSecurityClients != 0);

	s_fInitializedNoneSec = true;

	return s_fServerAllowNoneSecurityClients;
}


static ULONG GetMinRpcAuthnLevel(BOOL fWorkgroupClient)
{
	if(g_fPureWorkGroupMachine)
		return RPC_C_AUTHN_LEVEL_NONE;

	if((fWorkgroupClient) && (!ServerDenyWorkgroupClients())) 		
		return RPC_C_AUTHN_LEVEL_NONE;

	if(ServerAllowNoneSecurityClients()) 		
		return RPC_C_AUTHN_LEVEL_NONE;

	return MQSec_RpcAuthnLevel();
}


VOID
RemoteRead_v1_0_S_GetVersion(
    handle_t           /*hBind*/,
    UCHAR  __RPC_FAR * pMajor,
    UCHAR  __RPC_FAR * pMinor,
    USHORT __RPC_FAR * pBuildNumber,
    ULONG  __RPC_FAR * pMinRpcAuthnLevel
    )
/*++

Routine Description:
    Return version of this QM. RPC server side.
    Return also the min RpcAuthnLevel the server is willing to accept.

Arguments:
    hBind        - Binding handle.
    pMajor       - Points to output buffer to receive major version. May be NULL.
    pMinor       - Points to output buffer to receive minor version. May be NULL.
    pBuildNumber - Points to output buffer to receive build number. May be NULL.
    pMinRpcAuthnLevel - Points to output buffer to receive min RpcAuthnLevel the server is willing to acceptL. May be NULL.

Return Value:
    None.

--*/
{
    if (pMajor != NULL)
    {
        (*pMajor) = rmj;
    }

    if (pMinor != NULL)
    {
        (*pMinor) = rmm;
    }

    if (pBuildNumber != NULL)
    {
        (*pBuildNumber) = rup;
    }

    if (pMinRpcAuthnLevel != NULL)
    {
	    *pMinRpcAuthnLevel = GetMinRpcAuthnLevel(true);
    }
    
}


static
ULONG 
BindInqClientRpcAuthnLevel(
	handle_t hBind
	)
/*++
Routine Description:
	Inquire the bindibg handle for the Authentication level.

Arguments:
    hBind - binding handle to inquire.

Returned Value:
	ULONG - RpcAuthnLevel used in the binding handle.

--*/
{
	ULONG RpcAuthnLevel;
	RPC_STATUS rc = RpcBindingInqAuthClient(hBind, NULL, NULL, &RpcAuthnLevel, NULL, NULL); 
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to inquire client Binding handle for the Auhtentication level, rc = %d", rc);
		return RPC_C_AUTHN_LEVEL_NONE;
	}
	
	TrTRACE(RPC, "RpcBindingInqAuthClient, RpcAuthnLevel = %d", RpcAuthnLevel);

	return RpcAuthnLevel;
}


//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT RemoteRead_v1_0_S_OpenQueue
//
//  Server side of RPC call. Server side of remote-reader.
//  Open a queue for remote-read on behalf of a client machine.
//
//---------------------------------------------------------------

/* [call_as] */ 
void
RemoteRead_v1_0_S_OpenQueue(
    handle_t hBind,
    QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    DWORD dwShareMode,
    GUID* pLicGuid,
    BOOL fLicense,
    UCHAR Major,
    UCHAR Minor,
    USHORT BuildNumber,
    BOOL fWorkgroup,
    RemoteReadContextHandleExclusive* pphContext
	)
{
	TrTRACE(RPC, "ClientVersion %d.%d.%d, fWorkgroup = %d, Access = %d, ShareMode = %d ", Major, Minor, BuildNumber, fWorkgroup, dwAccess, dwShareMode);

	ULONG BindRpcAuthnLevel = BindInqClientRpcAuthnLevel(hBind);
	if(BindRpcAuthnLevel < GetMinRpcAuthnLevel(fWorkgroup))
	{
		TrERROR(RPC, "Client binding RpcAuthnLevel = %d, server MinRpcAuthnLevel = %d", BindRpcAuthnLevel, GetMinRpcAuthnLevel(fWorkgroup));
		RpcRaiseException(MQ_ERROR_INVALID_HANDLE);
	}

	if ((pLicGuid == NULL) || (*pLicGuid == GUID_NULL))
	{
		TrERROR(RPC, "License Guid was not supplied");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
    if(!FnIsValidQueueFormat(pQueueFormat))
    {
		TrERROR(RPC, "QueueFormat is not valid");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
    }

	TrTRACE(RPC, "pLicGuid = %!guid!, fLicense = %d", pLicGuid, fLicense);

    if (!g_QMLicense.NewConnectionAllowed(fLicense, pLicGuid))
    {
		TrERROR(RPC, "New connection is not allowed");
		RpcRaiseException(MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW);
    }

	if (!IsValidAccessMode(pQueueFormat, dwAccess, dwShareMode))
	{
		TrERROR(RPC, "Ilegal access mode bits are turned on.");
		RpcRaiseException(MQ_ERROR_UNSUPPORTED_ACCESS_MODE);
	}
	
	SetRpcServerKeepAlive(hBind);

    CQueue* pLocalQueue = NULL;
	HANDLE hQueue = NULL;
    HRESULT hr = OpenQueueInternal(
                        pQueueFormat,
                        GetCurrentProcessId(),
                        dwAccess,
                        dwShareMode,
                        NULL,	// lplpRemoteQueueName
                        &hQueue,
						false,	// fFromDepClient
                        &pLocalQueue
                        );

	if(FAILED(hr) || (hQueue == NULL))
	{
		TrERROR(RPC, "Failed to open queue, hr = %!hresult!", hr);
		RpcRaiseException(hr);
	}

	//
	// Attach the queue handle to the completion port.
	//
	ExAttachHandle(hQueue);

    //
    // Create OPENRR context.
    //
    R<CRemoteReadCtx> pctx = new CRemoteReadCtx(
											hQueue,
											pLocalQueue,
											pLicGuid,
											fLicense,
											Major,
											Minor,
											BuildNumber,
											fWorkgroup
											);

	TrTRACE(RPC, "New CRemoteReadCtx: hQueue = 0x%p, QueueName = %ls, pctx = 0x%p", hQueue, pLocalQueue->GetQueueName(), pctx.get());

    *pphContext = (RemoteReadContextHandleExclusive) pctx.detach();

	if(fLicense)
	{
		g_QMLicense.IncrementActiveConnections(pLicGuid, NULL);
	}
}


//
// Server ASYNC rpc calls
//

static
bool 
VerifyBindAndContext(
	handle_t  hBind,
	RemoteReadContextHandleShared phContext 
	)
{
    if(phContext == NULL)
    {
		TrERROR(RPC, "Invalid OPENRR_CTX handle");
		return false;
    }
    
	CRemoteReadCtx* pctx = (CRemoteReadCtx*)phContext;

	if (pctx->m_eType != CBaseContextType::eNewRemoteReadCtx)
	{
		TrERROR(RPC, "incorrect Context Type");
		return false;
	}
	
	ULONG BindRpcAuthnLevel = BindInqClientRpcAuthnLevel(hBind);
	if(BindRpcAuthnLevel >= GetMinRpcAuthnLevel(pctx->m_fWorkgroupClient))
		return true;

	TrERROR(RPC, "Client binding RpcAuthnLevel = %d < %d (MinRpcAuthnLevel)", BindRpcAuthnLevel, GetMinRpcAuthnLevel(pctx->m_fWorkgroupClient));
    return false;
}


//---------------------------------------------------------------
//
//   QMCloseQueueInternal
//
//  Server side of RPC. Close the queue and free the rpc context.
//
//---------------------------------------------------------------
static
HRESULT 
QMCloseQueueInternal(
     IN RemoteReadContextHandleExclusive phContext,
     bool fRunDown
     )
{
    TrTRACE(RPC, "In QMCloseQueueInternal");

    if(phContext == NULL)
    {
		TrERROR(RPC, "Invalid handle");
        return MQ_ERROR_INVALID_HANDLE;
    }
    
	CRemoteReadCtx* pctx = (CRemoteReadCtx*) phContext;

	if (pctx->m_eType != CBaseContextType::eNewRemoteReadCtx)
	{
		TrERROR(RPC, "Received invalid handle");
		return MQ_ERROR_INVALID_HANDLE;
	}

    if (pctx->m_fLicensed)
    {
        g_QMLicense.DecrementActiveConnections(&(pctx->m_ClientQMGuid));
    }

    TrTRACE(RPC, "Release CRemoteReadCtx = 0x%p, Ref = %d, hQueue = 0x%p, QueueName = %ls", pctx, pctx->GetRef(), pctx->m_hQueue, pctx->m_pLocalQueue->GetQueueName());

	//
	// Cancel all pending remote reads in this session.
	//
	pctx->CancelAllPendingRemoteReads();

	if(fRunDown)
	{
		//
		// Complete pending EndReceive.
		//
		pctx->CancelAllEndReceiveInMap();
	}

	//
	// new RemoteRead client take care that the close call is after all other calls (including EndReceive) were finished.
	// This is correct for post .NET RC1 clients
	//
	ASSERT_BENIGN(!pctx->IsWaitingForEndReceive() || pctx->IsClientRC1());
	
	pctx->Release();
	return MQ_OK;
}

	
//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT RemoteRead_v1_0_S_CloseQueue
//
//  Server side of RPC. Close the queue and free the rpc context.
//
//---------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_CloseQueue(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
	/* [in] */ handle_t hBind,
	/* [in, out] */ RemoteReadContextHandleExclusive __RPC_FAR *pphContext 
	)
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, *pphContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

    SetRpcServerKeepAlive(hBind);

    HRESULT hr = QMCloseQueueInternal(
    				*pphContext,
    				false 	// fRunDown
    				);

	*pphContext = NULL;
	
	AsyncComplete.SetHr(hr);		
}


//-------------------------------------------------------------------
//
//  HRESULT RemoteRead_v1_0_S_CreateCursor
//
//  Server side of RPC call. Server side of remote-reader.
//  Create a cursor for remote-read, on behalf of a client reader.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_CreateCursor( 
	/* [in] */ PRPC_ASYNC_STATE   pAsync,
    /* [in] */  handle_t          hBind,
    /* [in] */  RemoteReadContextHandleShared phContext,	
    /* [out] */ DWORD __RPC_FAR *phCursor
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, phContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

	SetRpcServerKeepAlive(hBind);

	try
	{
		R<CRRCursor> pCursor = new CRRCursor;

		CRemoteReadCtx* pctx = (CRemoteReadCtx*)phContext;
	    HACCursor32 hCursor = 0;
		HRESULT hr = ACCreateCursor(pctx->m_hQueue, &hCursor);
	    ASSERT(hr != STATUS_PENDING);
		*phCursor = (DWORD) hCursor;

		if(SUCCEEDED(hr))
		{
		    TrTRACE(RPC, "Cursor created: hCursor = %d, pctx = 0x%p, hQueue = 0x%p, QueueName = %ls", (DWORD) hCursor, pctx, pctx->m_hQueue, pctx->m_pLocalQueue->GetQueueName());

			pCursor->SetCursor(pctx->m_hQueue, hCursor);
			pctx->AddCursorToMap(
					(ULONG) hCursor,
					pCursor
					);
		}

		AsyncComplete.SetHr(hr);		
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
	}
		
}


//-------------------------------------------------------------------
//
// HRESULT RemoteRead_v1_0_S_CloseCursor
//
//  Server side of RPC call. Server side of remote-reader.
//  Close a remote cursor in local driver.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_CloseCursor(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t hBind,
    /* [in] */ RemoteReadContextHandleShared phContext,	
    /* [in] */ DWORD hCursor
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, phContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

	SetRpcServerKeepAlive(hBind);

	CRemoteReadCtx* pctx = (CRemoteReadCtx*)phContext;

    TrTRACE(RPC, "Closing cursor: hCursor = %d, pctx = 0x%p, hQueue = 0x%p, QueueName = %ls", (DWORD) hCursor, pctx, pctx->m_hQueue, pctx->m_pLocalQueue->GetQueueName());

	HRESULT hr = pctx->RemoveCursorFromMap(hCursor);
	AsyncComplete.SetHr(hr);		
}


//-------------------------------------------------------------------
//
// HRESULT RemoteRead_v1_0_S_PurgeQueue(
//
//  Server side of RPC call. Server side of remote-reader.
//  Purge local queue.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_PurgeQueue(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t hBind,
    /* [in] */ RemoteReadContextHandleShared phContext
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, phContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

	SetRpcServerKeepAlive(hBind);

    CRemoteReadCtx* pctx = (CRemoteReadCtx*) phContext;

    TrTRACE(RPC, "PurgeQueue %ls, pctx = 0x%p, hQueue = 0x%p", pctx->m_pLocalQueue->GetQueueName(), pctx, pctx->m_hQueue);

	HRESULT hr = ACPurgeQueue(pctx->m_hQueue);

	AsyncComplete.SetHr(hr);		
}


//---------------------------------------------------
//
//  CGetPacket2RemoteOv - handle Async StartReceive
//
//---------------------------------------------------
class CGetPacket2RemoteOv : public CReference
{
public:
    CGetPacket2RemoteOv(
		PRPC_ASYNC_STATE pAsync,
	    CRemoteReadCtx* pctx,
	    bool fReceiveByLookupId,
	    ULONGLONG LookupId,
	    DWORD hCursor,
	    DWORD ulAction,
	    DWORD ulTimeout,
		DWORD MaxBodySize,    
		DWORD MaxCompoundMessageSize,
		DWORD dwRequestID,
	    DWORD* pdwArriveTime,
	    ULONGLONG* pSequentialId,
	    DWORD* pdwNumberOfSection,
	    SectionBuffer** ppPacketSections
        ) :
        m_GetPacketOv(GetPacket2RemoteSucceeded, GetPacket2RemoteFailed),
       	m_pAsync(pAsync),
       	m_pOpenRemoteCtx(SafeAddRef(pctx)),
		m_dwRequestID(dwRequestID),
		m_ulTag(ULONG_MAX),
		m_hCursor(hCursor),
		m_ulAction(ulAction),
		m_ulTimeout(ulTimeout),
		m_MaxBodySize(MaxBodySize),
		m_MaxCompoundMessageSize(MaxCompoundMessageSize),
		m_pdwArriveTime(pdwArriveTime),
		m_pSequentialId(pSequentialId),
		m_pdwNumberOfSection(pdwNumberOfSection),
		m_ppPacketSections(ppPacketSections),
		m_fPendingForEndReceive(true)
    {
        m_packetPtrs.pPacket = NULL;
        m_packetPtrs.pDriverPacket = NULL;

		m_g2r.Cursor = (HACCursor32) hCursor;
		m_g2r.Action = ulAction;
		m_g2r.RequestTimeout = ulTimeout;
		m_g2r.pTag = &m_ulTag;
		m_g2r.fReceiveByLookupId = fReceiveByLookupId;
		m_g2r.LookupId = LookupId;
    }

	void CompleteStartReceive();

	ULONG GetTag()
	{
		return m_ulTag;
	}

	void MoveFromPendingToStartReceive();

	void CancelPendingForEndReceive();	

	HRESULT BeginGetPacket2Remote();	

	void AbortRpcAsyncCall(HRESULT hr)
	{
		ASSERT(FAILED(hr));

	    PRPC_ASYNC_STATE pAsync = reinterpret_cast<PRPC_ASYNC_STATE>(InterlockedExchangePointer((PVOID*)&m_pAsync, NULL));

	    if (pAsync == NULL)
	        return;
	    
		RPC_STATUS rc = RpcAsyncAbortCall(pAsync, hr);
		if(rc != RPC_S_OK)
		{
			TrERROR(RPC, "RpcAsyncAbortCall failed, rc = %!winerr!", rc);
		}
	}
	
private:
    ~CGetPacket2RemoteOv() {}

	void UnregisterReadRequest()
	{
		m_pOpenRemoteCtx->UnregisterReadRequest(m_dwRequestID);
	}

	void 
	InitSection(
		SectionBuffer* pSection, 
		SectionType SecType, 
		BYTE* pBuffer, 
		DWORD BufferSizeAlloc,
		DWORD BufferSize
		);

	void FullPacketSection(DWORD* pNumberOfSection, AP<SectionBuffer>& pSections);

	void 
	CreatePacketSections(
		CQmPacket& Qmpkt, 
		SectionType FirstSectionType,
		DWORD FirstSectionSizeAlloc,
		DWORD FirstSectionSize,
		char* pEndOfFirstSection,
		SectionType SecondSectionType,
		DWORD SecondSectionSize,
		DWORD* pNumberOfSection, 
		AP<SectionBuffer>& pSections
		);

	void 
	NativePacketSections(
		CQmPacket& Qmpkt, 
		DWORD* pNumberOfSection, 
		AP<SectionBuffer>& pSections
		);

	void 
	SrmpPacketSections(
		CQmPacket& Qmpkt, 
		DWORD* pNumberOfSection, 
		AP<SectionBuffer>& pSections
		);

	void PreparePacketSections(DWORD* pNumberOfSection, AP<SectionBuffer>& pSections);
	
	static void WINAPI GetPacket2RemoteSucceeded(EXOVERLAPPED* pov);
	static void WINAPI GetPacket2RemoteFailed(EXOVERLAPPED* pov);
	
public:
    EXOVERLAPPED m_GetPacketOv;
    PRPC_ASYNC_STATE m_pAsync;
	R<CRemoteReadCtx> m_pOpenRemoteCtx;
    CACPacketPtrs m_packetPtrs;		
	ULONG m_ulTag;
	CACGet2Remote m_g2r;
    DWORD m_hCursor;
    DWORD m_ulAction;
    DWORD m_ulTimeout;
	DWORD m_MaxBodySize;
	DWORD m_MaxCompoundMessageSize;
    DWORD m_dwRequestID;
    DWORD* m_pdwArriveTime;
    ULONGLONG* m_pSequentialId;
 	DWORD* m_pdwNumberOfSection;
	SectionBuffer** m_ppPacketSections;
	bool m_fPendingForEndReceive;
};


static DWORD DiffPointers(const void* end, const void* start)
{
	ptrdiff_t diff = (UCHAR*)end - (UCHAR*)start;
	return numeric_cast<DWORD>(diff);	
}



void 
CGetPacket2RemoteOv::InitSection(
	SectionBuffer* pSection, 
	SectionType SecType, 
	BYTE* pBuffer, 
	DWORD BufferSizeAlloc,
	DWORD BufferSize
	)
{
	ASSERT(pBuffer != NULL);
	ASSERT(BufferSize > 0);
	ASSERT(BufferSizeAlloc >= BufferSize);
	
	pSection->SectionBufferType = SecType;
	pSection->pSectionBuffer = pBuffer;
	pSection->SectionSizeAlloc = BufferSizeAlloc;
	pSection->SectionSize = BufferSize;
}


void CGetPacket2RemoteOv::FullPacketSection(DWORD* pNumberOfSection, AP<SectionBuffer>& pSections)
{
	//
	// We will return full packet, no need to optimize the packet.
	//
	
	DWORD dwSize = PACKETSIZE(m_packetPtrs.pPacket);
	AP<BYTE> pFullPacketBuffer = new BYTE[dwSize];

	MoveMemory(pFullPacketBuffer.get(), m_packetPtrs.pPacket, dwSize);

	pSections = new SectionBuffer[1];

	InitSection(
		pSections, 
		stFullPacket, 
		pFullPacketBuffer.detach(), 
		dwSize,
		dwSize
		);

	*pNumberOfSection = 1;

	TrTRACE(RPC, "PacketSize = %d, FullPacket section", dwSize);
}


void 
CGetPacket2RemoteOv::CreatePacketSections(
	CQmPacket& Qmpkt, 
	SectionType FirstSectionType,
	DWORD FirstSectionSizeAlloc,
	DWORD FirstSectionSize,
	char* pEndOfFirstSection,
	SectionType SecondSectionType,
	DWORD SecondSectionSize,
	DWORD* pNumberOfSection, 
	AP<SectionBuffer>& pSections
	)
/*++
Routine Description:
	Create packet sections: 
	First section is always optimized.  
	the second section is not optimized.

Arguments:
	Qmpkt - packet.
	FirstSectionType - type of first section.
	FirstSectionSizeAlloc - First section original size.
	FirstSectionSize - First section size (shrinked).
	char* pEndOfFirstSection - pointer on the packet to the end of first section.
	SecondSectionType - type of second section.
	SecondSectionSize - First section original size (this is also the SizeAlloc).
	pNumberOfSection - [out] pointer to number of sections.
	pSections - [out] pointer to section buffer.

Returned Value:
	None

--*/
{
	//
	// FirstSection must exist and be optimized
	//
	ASSERT(FirstSectionSize > 0);
	ASSERT(FirstSectionSizeAlloc > FirstSectionSize);
	ASSERT(DiffPointers(pEndOfFirstSection, Qmpkt.GetPointerToPacket()) == FirstSectionSizeAlloc);

	//
	// Allocate SectionBuffer
	//
	DWORD NumberOfSection = (SecondSectionSize > 0) ? 2 : 1;
	pSections = new SectionBuffer[NumberOfSection];
	SectionBuffer* pTmpSectionBuffer = pSections;

	//
	// Prepare First section.
	// This section is optimized.
	//
	AP<BYTE> pFirstSectionBuffer = new BYTE[FirstSectionSize];
	MoveMemory(pFirstSectionBuffer.get(), Qmpkt.GetPointerToPacket(), FirstSectionSize);

	InitSection(
		pTmpSectionBuffer, 
		FirstSectionType, 
		pFirstSectionBuffer, 
		FirstSectionSizeAlloc,
		FirstSectionSize
		);

	pTmpSectionBuffer++;

	//
	// Prepare Second section.
	// This section is not optimized.
	//

	AP<BYTE> pSecondSectionBuffer;
	if(SecondSectionSize > 0)
	{
		pSecondSectionBuffer = new BYTE[SecondSectionSize];
		MoveMemory(pSecondSectionBuffer.get(), pEndOfFirstSection, SecondSectionSize);

		InitSection(
			pTmpSectionBuffer, 
			SecondSectionType, 
			pSecondSectionBuffer, 
			SecondSectionSize,
			SecondSectionSize
			);

		pTmpSectionBuffer++;
	}

	pFirstSectionBuffer.detach(); 
	pSecondSectionBuffer.detach(); 

	*pNumberOfSection = NumberOfSection;
}


void 
CGetPacket2RemoteOv::NativePacketSections(
	CQmPacket& Qmpkt, 
	DWORD* pNumberOfSection, 
	AP<SectionBuffer>& pSections
	)
{
	//
	// Native message - optimize the body size if needed.
	//

	ASSERT(!Qmpkt.IsSrmpIncluded());

	if(m_MaxBodySize >= Qmpkt.GetBodySize())
	{
		//
		// No need for Body optimization.
		//
		FullPacketSection(pNumberOfSection, pSections);
		return;
	}

	//
	// We need to optimize the body size, must have PropertyHeader
	// BodySize > 0 and RequestedBodySize < BodySize
	//
	ASSERT(Qmpkt.IsPropertyInc());
	ASSERT(Qmpkt.GetBodySize() > 0);
	ASSERT(m_MaxBodySize < Qmpkt.GetBodySize());

	TrTRACE(RPC, "PacketSize = %d, BodySize = %d, MaxBodySize = %d", Qmpkt.GetSize(), Qmpkt.GetBodySize(), m_MaxBodySize);

	//
	// Calc sections sizes
	//

	//
	// Packet Till End Of Property Header section sizes.
	//
	const UCHAR* pBodyEnd = Qmpkt.GetPointerToPacketBody() + m_MaxBodySize;
    char* pEndOfPropSection = reinterpret_cast<CPropertyHeader*>(Qmpkt.GetPointerToPropertySection())->GetNextSection();

	ASSERT(pBodyEnd <= (UCHAR*)pEndOfPropSection);

	DWORD TillEndOfPropertyHeaderSize = DiffPointers(pBodyEnd, Qmpkt.GetPointerToPacket());
	DWORD TillEndOfPropertyHeaderSizeAlloc = DiffPointers(pEndOfPropSection, Qmpkt.GetPointerToPacket());
	TrTRACE(RPC, "TillEndOfPropertyHeaderSize = %d, TillEndOfPropertyHeaderSizeAlloc = %d", TillEndOfPropertyHeaderSize, TillEndOfPropertyHeaderSizeAlloc);
	
	//
	// After Property Header section sizes.
	//
	ASSERT(Qmpkt.GetSize() >= TillEndOfPropertyHeaderSizeAlloc);
	DWORD AfterPropertyHeaderBufferSize = Qmpkt.GetSize() - TillEndOfPropertyHeaderSizeAlloc;
	TrTRACE(RPC, "AfterPropertyHeader Size = %d", AfterPropertyHeaderBufferSize);

	CreatePacketSections(
		Qmpkt, 
		stTillEndOfPropertyHeader,
		TillEndOfPropertyHeaderSizeAlloc,
		TillEndOfPropertyHeaderSize,
		pEndOfPropSection,
		stAfterPropertyHeader,
		AfterPropertyHeaderBufferSize,
		pNumberOfSection, 
		pSections
		);
}


void 
CGetPacket2RemoteOv::SrmpPacketSections(
	CQmPacket& Qmpkt, 
	DWORD* pNumberOfSection, 
	AP<SectionBuffer>& pSections
	)
{
	//
	// Srmp message - optimize compound message if needed
	//
	ASSERT(Qmpkt.IsSrmpIncluded());

	if(m_MaxCompoundMessageSize >= Qmpkt.GetCompoundMessageSizeInBytes())
	{
		//
		// No need for CompoundMessage optimization.
		//
		FullPacketSection(pNumberOfSection, pSections);
		return;
	}

	//
	// We need to optimize CompoundMessage
	// must have CompoundMessageHeader
	//
	ASSERT(Qmpkt.GetCompoundMessageSizeInBytes() > 0);

	TrTRACE(RPC, "PacketSize = %d, BodySize = %d, CompoundMessageSize = %d, MaxBodySize = %d, MaxCompoundMessageSize = %d", Qmpkt.GetSize(), Qmpkt.GetBodySize(), Qmpkt.GetCompoundMessageSizeInBytes(), m_MaxBodySize, m_MaxCompoundMessageSize);

	//
	// Calc sections sizes
	//

	//
	// Packet Till End Of CompoundMessage Header section sizes.
	//
	const UCHAR* pBodyEnd = NULL;
	if((m_MaxBodySize > 0) && (Qmpkt.GetBodySize() > 0))
	{
		//
		// Only if Body was requested and we have Body on the packet 
		// body is taking into consideration.
		//
		pBodyEnd = Qmpkt.GetPointerToPacketBody() + min(m_MaxBodySize, Qmpkt.GetBodySize());
	}

	//
	// In case m_MaxCompoundMessageSize == 0, 
	// pCompoundMessageEnd point to the CompoundMessage start 
	// after the Header part of CompoundMessageSection.
	//
	const UCHAR* pCompoundMessageEnd = Qmpkt.GetPointerToCompoundMessage() + min(m_MaxCompoundMessageSize, Qmpkt.GetCompoundMessageSizeInBytes());

    char* pEndOfCompoundMessageSection = reinterpret_cast<CCompoundMessageHeader*>(Qmpkt.GetPointerToCompoundMessageSection())->GetNextSection();

	ASSERT(pBodyEnd <= (UCHAR*)pEndOfCompoundMessageSection);
	ASSERT(pCompoundMessageEnd <= (UCHAR*)pEndOfCompoundMessageSection);

	DWORD TillEndOfCompoundMessageHeaderSize = DiffPointers(max(pCompoundMessageEnd, pBodyEnd), Qmpkt.GetPointerToPacket());
	DWORD TillEndOfCompoundMessageHeaderSizeAlloc = DiffPointers(pEndOfCompoundMessageSection, Qmpkt.GetPointerToPacket());
	TrTRACE(RPC, "TillEndOfCompoundMessageHeaderSize = %d, TillEndOfCompoundMessageHeaderSizeAlloc = %d", TillEndOfCompoundMessageHeaderSize, TillEndOfCompoundMessageHeaderSizeAlloc);
	
	//
	// After CompoundMessage Header section sizes.
	//
	ASSERT(Qmpkt.GetSize() >= TillEndOfCompoundMessageHeaderSizeAlloc);
	DWORD AfterCompoundMessageHeaderBufferSize = Qmpkt.GetSize() - TillEndOfCompoundMessageHeaderSizeAlloc;
	TrTRACE(RPC, "AfterCompoundMessageHeader Size = %d", AfterCompoundMessageHeaderBufferSize);

	CreatePacketSections(
		Qmpkt, 
		stTillEndOfCompoundMessageHeader,
		TillEndOfCompoundMessageHeaderSizeAlloc,
		TillEndOfCompoundMessageHeaderSize,
		pEndOfCompoundMessageSection,
		stAfterCompoundMessageHeader,
		AfterCompoundMessageHeaderBufferSize,
		pNumberOfSection, 
		pSections
		);
}


void CGetPacket2RemoteOv::PreparePacketSections(DWORD* pNumberOfSection, AP<SectionBuffer>& pSections)
{
	CQmPacket Qmpkt(m_packetPtrs.pPacket, m_packetPtrs.pDriverPacket);

	if(Qmpkt.IsSrmpIncluded())
	{
		//
		// Srmp message - optimize compound message.
		//
		SrmpPacketSections(Qmpkt, pNumberOfSection, pSections);
		return;
	}

	//
	// Native message - optimize body.
	//
	NativePacketSections(Qmpkt, pNumberOfSection, pSections);
}


void CGetPacket2RemoteOv::CompleteStartReceive()
{
	CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(m_packetPtrs.pPacket) - 1;
	*m_pdwArriveTime = pInfo->ArrivalTime();
	*m_pSequentialId = pInfo->SequentialId();

	AP<SectionBuffer> pSections;
	DWORD NumberOfSection = 0;
	PreparePacketSections(&NumberOfSection, pSections);

    //
    // Set the packet signature
    //
	CBaseHeader* pBase = reinterpret_cast<CBaseHeader*>(pSections->pSectionBuffer);
	pBase->SetSignature();

	*m_pdwNumberOfSection = NumberOfSection;
	*m_ppPacketSections = pSections.detach();

	if ((m_ulAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
		(m_ulAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK)
	{
		//
		// For PEEK we don't need any ack/nack from client side because
		// packet remain in queue anyway.
		// Neverthless we need to free the clone packet we've got.
		//
	    QmAcFreePacket( 
		   	   m_packetPtrs.pDriverPacket, 
		   	   0, 
   		       eDeferOnFailure
   		       );
		return;
	}

	//
	//  Prepare a rpc context, in case that EndRecieve will not
	//  be called because of client side crash or net problems.
	//
	P<CEndReceiveCtx> pEndReceiveCtx = new CEndReceiveCtx(
												m_pOpenRemoteCtx.get(),
												m_hCursor,
												m_packetPtrs.pPacket,
												m_packetPtrs.pDriverPacket,
												m_ulTimeout,
												m_ulAction,
												m_dwRequestID
												);

	m_pOpenRemoteCtx->AddEndReceiveToMap(m_dwRequestID, pEndReceiveCtx);

	m_pOpenRemoteCtx->SetEndReceiveTimerIfNeeded();

	TrTRACE(RPC, "New CEndReceiveCtx: pctx = 0x%p, Queue = %ls, hQueue = 0x%p, CliTag = %d, hCursor = %d, Action = 0x%x", m_pOpenRemoteCtx.get(), m_pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), m_pOpenRemoteCtx->m_hQueue, m_dwRequestID, m_hCursor, m_ulAction);
}


void CGetPacket2RemoteOv::MoveFromPendingToStartReceive()
{
	ASSERT(m_fPendingForEndReceive);
	HRESULT hr = BeginGetPacket2Remote();
	if(FAILED(hr))
	{	
		UnregisterReadRequest();

		ASSERT(m_packetPtrs.pPacket == NULL);
		TrERROR(RPC, "ACBeginGetPacket2Remote Failed, Tag = %d, %!hresult!", m_dwRequestID, hr);		
		AbortRpcAsyncCall(hr);
		Release();
		return;
	}
	
    TrTRACE(RPC, "StartReceive request Moved from Pending for EndReceive to StartReceive: pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", m_pOpenRemoteCtx.get(), m_pOpenRemoteCtx->m_hQueue, m_pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), m_dwRequestID);
}


void CGetPacket2RemoteOv::CancelPendingForEndReceive()
{
	ASSERT(m_fPendingForEndReceive);
	UnregisterReadRequest();

    TrTRACE(RPC, "Cancel Receive: pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", m_pOpenRemoteCtx.get(), m_pOpenRemoteCtx->m_hQueue, m_pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), m_dwRequestID);

	AbortRpcAsyncCall(MQ_ERROR_OPERATION_CANCELLED);
	Release();
}


void WINAPI CGetPacket2RemoteOv::GetPacket2RemoteFailed(EXOVERLAPPED* pov)
{
    ASSERT(FAILED(pov->GetStatus()));

    R<CGetPacket2RemoteOv> pGetPacket2RemoteOv = CONTAINING_RECORD (pov, CGetPacket2RemoteOv, m_GetPacketOv);
	pGetPacket2RemoteOv->UnregisterReadRequest();

    TrERROR(RPC, "Failed to received packet: Status = 0x%x, pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", pov->GetStatus(), pGetPacket2RemoteOv->m_pOpenRemoteCtx.get(), pGetPacket2RemoteOv->m_pOpenRemoteCtx->m_hQueue, pGetPacket2RemoteOv->m_pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), pGetPacket2RemoteOv->m_dwRequestID);

	ASSERT(pGetPacket2RemoteOv->m_packetPtrs.pPacket == NULL);

	pGetPacket2RemoteOv->AbortRpcAsyncCall(pov->GetStatus());
}


void WINAPI CGetPacket2RemoteOv::GetPacket2RemoteSucceeded(EXOVERLAPPED* pov)
{
	ASSERT(SUCCEEDED(pov->GetStatus()));
    
    R<CGetPacket2RemoteOv> pGetPacket2RemoteOv = CONTAINING_RECORD(pov, CGetPacket2RemoteOv, m_GetPacketOv);
	pGetPacket2RemoteOv->UnregisterReadRequest();

    TrTRACE(RPC, "Received packet: pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", pGetPacket2RemoteOv->m_pOpenRemoteCtx.get(), pGetPacket2RemoteOv->m_pOpenRemoteCtx->m_hQueue, pGetPacket2RemoteOv->m_pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), pGetPacket2RemoteOv->m_dwRequestID);

    PRPC_ASYNC_STATE pAsync = reinterpret_cast<PRPC_ASYNC_STATE>(InterlockedExchangePointer((PVOID*)&pGetPacket2RemoteOv->m_pAsync, NULL));

    if (pAsync == NULL)
        return;

	//
	// pAsync != NULL, the async call is still alive, we can completes it safely.
	//
	
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	try
	{
		//
		// Possible change of EndReceive status - WaitingFor EndReceive
		//
	    CS lock(pGetPacket2RemoteOv->m_pOpenRemoteCtx->m_PendingRemoteReadsCS);

		pGetPacket2RemoteOv->CompleteStartReceive();
	
		AsyncComplete.SetHr(pov->GetStatus());
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//

		if(pGetPacket2RemoteOv->m_packetPtrs.pDriverPacket != NULL)
		{
		    QmAcFreePacket( 
			   	   pGetPacket2RemoteOv->m_packetPtrs.pDriverPacket, 
			   	   0, 
	   		       eDeferOnFailure
	   		       );
		}
	}
}


HRESULT CGetPacket2RemoteOv::BeginGetPacket2Remote()
{
	m_fPendingForEndReceive = false;

	return QmAcBeginGetPacket2Remote(
				m_pOpenRemoteCtx->m_hQueue,
				m_g2r,
				m_packetPtrs,
				&m_GetPacketOv
				);
}


void
WINAPI
CRemoteReadCtx::EndReceiveTimerRoutine(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler for testing EndReceive status.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the CRemoteReadCtx
             object and it use to retrive the CRemoteReadCtx object.

Return Value:
    None

--*/
{
	//
	// Release the matching ExSetTimer Addref.
	//
    R<CRemoteReadCtx> pRemoteReadCtx = CONTAINING_RECORD(pTimer, CRemoteReadCtx, m_EndReceiveTimer);
	pRemoteReadCtx->CancelExpiredEndReceives();
	pRemoteReadCtx->StartAllPendingForEndReceive();

}


void CRemoteReadCtx::CancelExpiredEndReceives()
/*++
Routine Description:
	Cancel (NACK) every Expired EndReceive (client didn't ack\nack within the Timeout interval). 
	This prevent the StartReceives to get stuck when the client failed to EndReceive.

Arguments:
    None.

Return Value:
    None

--*/
{
    CS lock(m_EndReceiveMapCS);

	ASSERT(m_fEndReceiveTimerScheduled);
	m_fEndReceiveTimerScheduled = false;

	CancelAllExpiredEndReceiveInMap();

	if(m_EndReceiveCtxMap.empty())
	{
		return;
	}
	
	//
	// Reschedule the Timer if EndReceiveCtxMap is not empty.
	//
	AddRef();
	m_fEndReceiveTimerScheduled = true;
	ExSetTimer(&m_EndReceiveTimer, CTimeDuration::FromMilliSeconds(RpcCancelTimeout() + xEndReceiveTimerDeltaInterval));
}


void
WINAPI
CRemoteReadCtx::ClientDisconnectedTimerRoutine(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler for testing client connection status.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the CRemoteReadCtx
             object and it use to retrive the CRemoteReadCtx object.

Return Value:
    None

--*/
{
	//
	// Release the matching ExSetTimer Addref.
	//
    R<CRemoteReadCtx> pRemoteReadCtx = CONTAINING_RECORD(pTimer, CRemoteReadCtx, m_ClientDisconnectedTimer);
	pRemoteReadCtx->CheckClientDisconnected();
}


void CRemoteReadCtx::CheckClientDisconnected()
/*++
Routine Description:
    Test client connection status.
    this is a workaround for RPC bug: not getting rundown while async call is pending.
    this function test the client connection status.
	If client was disconnected we cancel all pending calls.

Arguments:
	None

Return Value:
    None

--*/
{
    CS lock(m_PendingRemoteReadsCS);

	ASSERT(m_fClientDisconnectedTimerScheduled);
	m_fClientDisconnectedTimerScheduled = false;
	
	//
	// Find first async call that is still served (m_pAsync != NULL)
	//
	std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it = m_PendingRemoteReads.begin(); 
	while((it != m_PendingRemoteReads.end()) && (it->second->m_pAsync == NULL))
	{
		it++;
	}

	if(it == m_PendingRemoteReads.end())
	{
		//
		// map is empty or there are no active pending remote reads.
		//
		return;
	}

	if(IsClientDisconnected(RpcAsyncGetCallHandle(it->second->m_pAsync)))
	{
		//
		// Client is disconnected, cancel all pending calls to enable rundown.
		//
	    TrWARNING(RPC, "Client is disconnected, CancelAllPendingRemoteReads");
		CancelAllPendingRemoteReads();
		return;
	}

	//
	// There are pending receive calls and client is still connected, reschedule timer
	//
    TrTRACE(RPC, "Client connection is still alive");
	AddRef();
	m_fClientDisconnectedTimerScheduled = true;
	ExSetTimer(&m_ClientDisconnectedTimer, CTimeDuration::FromMilliSeconds(xClientDisconnectedTimerInterval));
}


void CRemoteReadCtx::StartAllPendingForEndReceive()
/*++
Routine Description:
	Start all pending requests that wait for EndReceive.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

	if(IsWaitingForEndReceive())
		return;

	//
	// We are not taking the EndReceive map lock since we don't care if EndReceive status is changed
	// after we sample it.
	// This mechanism protects that we don't start new receives before previous EndReceives ends.
	// We don't mind that there will be new end receives.
	//
	
	for(std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it = m_PendingRemoteReads.begin(); 
		it != m_PendingRemoteReads.end();
		)
    {
		//
		// MoveFromPendingToStartReceive might delete the iterator.
		// we must advance the iterator before it is deleted otherwise we will AV.
		//
		std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it1 = it;
		++it;
		
		if(it1->second->m_fPendingForEndReceive)
		{
			//
			// Dispatch the call to the driver.
			//
		    it1->second->MoveFromPendingToStartReceive();
		}
    }
}


	
HRESULT 
CRemoteReadCtx::CancelPendingRemoteRead(
	ULONG cli_tag
	)
/*++
Routine Description:
	Cancel specific pending remote reads on the CRemoteReadCtx.

	This method is called on the server side to cancel a pending remote
	read request. It is the responsibility of the client side to request
	this cancelation.
	The client side supply its own irp and the server side uses it to
	retreive the server side irp.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	HRESULT.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

    std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it = m_PendingRemoteReads.find(cli_tag);
   	if(it == m_PendingRemoteReads.end())
    {
		TrERROR(RPC, "Pending Remote Read was not found in the map, cli_tag = %d", cli_tag);
        return MQ_ERROR_OPERATION_CANCELLED;
    }

	if(it->second->m_fPendingForEndReceive)
	{
		//
		// The request was not yet dispatch to the driver.
		// Just abort the call and remove it from the map.
		//
		it->second->CancelPendingForEndReceive();
		return MQ_OK;
	}

	HRESULT hr = ACCancelRequest(
			            m_hQueue,
			            MQ_ERROR_OPERATION_CANCELLED,
			            it->second->GetTag()
			            );
	if(FAILED(hr))
	{
		TrERROR(RPC, "ACCancelRequest failed, cli_tag = %d, %!hresult!", cli_tag, hr);
		it->second->AbortRpcAsyncCall(MQ_ERROR_OPERATION_CANCELLED);
	}

    return hr;
}


void CRemoteReadCtx::CancelAllPendingRemoteReads()
/*++
Routine Description:
	Cancel all pending remote reads on the CRemoteReadCtx.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

	for(std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it = m_PendingRemoteReads.begin(); 
		it != m_PendingRemoteReads.end();
		)
    {
		R<CGetPacket2RemoteOv> pGetPacket2RemoteOv = it->second;
		++it;
		
		if(pGetPacket2RemoteOv->m_fPendingForEndReceive)
		{
			//
			// The request was not yet dispatch to the driver.
			// Just abort the call and remove it from the map.
			//
			pGetPacket2RemoteOv->CancelPendingForEndReceive();
			continue;
		}

	    HRESULT hr = ACCancelRequest(
				            m_hQueue,
				            MQ_ERROR_OPERATION_CANCELLED,
				            pGetPacket2RemoteOv->GetTag()
				            );

		if(FAILED(hr))
		{
			TrERROR(RPC, "Cancel Pending Remote Read failed, cli_tag = %d, %!hresult!", it->first, hr);
			pGetPacket2RemoteOv->AbortRpcAsyncCall(MQ_ERROR_OPERATION_CANCELLED);
		}
    }
}


void 
CRemoteReadCtx::RegisterReadRequest(
	ULONG cli_tag, 
	R<CGetPacket2RemoteOv>& pCGetPacket2RemoteOv
	)
/*++
Routine Description:
	Register Read Request in the pending remote reads on the CRemoteReadCtx.

Arguments:
	cli_tag - Client irp tag.
	pCGetPacket2RemoteOv - Pointer to the class that handle the async receive.

Returned Value:
	None.

--*/
{
	CS lock(m_PendingRemoteReadsCS);

	ASSERT(!FindReadRequest(cli_tag));

    m_PendingRemoteReads[cli_tag] = pCGetPacket2RemoteOv;
}


void 
CRemoteReadCtx::UnregisterReadRequest(
	ULONG cli_tag
	)
/*++
Routine Description:
	UnRegister Read Request in the pending remote reads on the CRemoteReadCtx.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	None.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

	ASSERT(!m_PendingRemoteReads.empty());

    m_PendingRemoteReads.erase(cli_tag);
}


bool 
CRemoteReadCtx::FindReadRequest(
	ULONG cli_tag
	)
/*++
Routine Description:
	Check if cli_tag is found in Pending Remote read maps.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	true if cli_tag was found in the map, false if not.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

    std::map<ULONG, R<CGetPacket2RemoteOv> >::iterator it = m_PendingRemoteReads.find(cli_tag);
   	if(it == m_PendingRemoteReads.end())
    {
        return false;
    }

	return true;
}


bool CRemoteReadCtx::IsWaitingForEndReceive()
{
    CS lock(m_EndReceiveMapCS);

	return !m_EndReceiveCtxMap.empty();
}


void CRemoteReadCtx::CancelAllEndReceiveInMap()
/*++
Routine Description:
	This function is called on rundown for cleaning all EndReceive in map.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_EndReceiveMapCS);

	for(std::map<ULONG, CEndReceiveCtx*>::iterator it = m_EndReceiveCtxMap.begin(); 
		it != m_EndReceiveCtxMap.end();
		)
    {
		//
		// This function is called on rundown for cleaning all EndReceive in map.
		// We want that CEndReceiveCtx will always be deleted since it takes ref on CRemoteReadCtx.
		// Even if exception is thrown latter (although those operation don't suppose to throw)
		//
		P<CEndReceiveCtx> pEndReceiveCtx = it->second;
		pEndReceiveCtx->EndReceive(RR_NACK);
        it = m_EndReceiveCtxMap.erase(it);
    }
}


void CRemoteReadCtx::CancelAllExpiredEndReceiveInMap()
/*++
Routine Description:
	This function is called for cleaning all expired EndReceive in map.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_EndReceiveMapCS);

	if(m_EndReceiveCtxMap.empty())
		return;

	//
	// TimeIssueExpired = CurrentTime - RpcCancelTimeout
	//
    DWORD RpcCancelTimeoutInSec = RpcCancelTimeout()/1000;
    time_t TimeIssueExpired = time(NULL) - RpcCancelTimeoutInSec;

	//
	// NACK all expired EndReceiveCtx in the map.
	// expired EndReceiveCtx = EndReceiveCtx that was issued before TimeIssueExpired.
	//
	for(std::map<ULONG, CEndReceiveCtx*>::iterator it = m_EndReceiveCtxMap.begin(); 
		it != m_EndReceiveCtxMap.end();
		)
    {
		if(it->second->m_TimeIssued <= TimeIssueExpired)
		{
			TrERROR(RPC, "EndReceive expired for %d sec: Queue = %ls, hQueue = 0x%p, CliTag = %d, Action = 0x%x", (TimeIssueExpired - it->second->m_TimeIssued), m_pLocalQueue->GetQueueName(), m_hQueue, it->second->m_CliTag, it->second->m_ulAction); 

			P<CEndReceiveCtx> pEndReceiveCtx = it->second;
			pEndReceiveCtx->EndReceive(RR_NACK);
	        it = m_EndReceiveCtxMap.erase(it);
		}
		else
		{
			TrTRACE(RPC, "EndReceive not yet expired: %d sec remaining, Tag = %d", (it->second->m_TimeIssued - TimeIssueExpired), it->second->m_CliTag); 
			++it;
		}
    }
}


void 
CRemoteReadCtx::AddEndReceiveToMap(
	ULONG cli_tag,
	P<CEndReceiveCtx>& pEndReceiveCtx
	)
/*++
Routine Description:
	Add EndReceiveCtx to map.

Arguments:
	cli_tag - Client irp tag.
	pEndReceiveCtx - Pointer to EndReceiveCtx.

Returned Value:
	None.

--*/
{
	CS lock(m_EndReceiveMapCS);

    m_EndReceiveCtxMap[cli_tag] = pEndReceiveCtx;
    pEndReceiveCtx.detach();

	TrTRACE(RPC, "EndReceive %d was added to the map, map size = %d", cli_tag, numeric_cast<DWORD>(m_EndReceiveCtxMap.size()));
}


void 
CRemoteReadCtx::RemoveEndReceiveFromMap(
	ULONG cli_tag,
	P<CEndReceiveCtx>& pEndReceiveCtx
	)
/*++
Routine Description:
	UnRegister Read Request in the pending remote reads on the CRemoteReadCtx.

Arguments:
	cli_tag - Client irp tag.
	pEndReceiveCtx

Returned Value:
	None.

--*/
{
    CS lock(m_EndReceiveMapCS);

	ASSERT_BENIGN(!m_EndReceiveCtxMap.empty());

    std::map<ULONG, CEndReceiveCtx*>::iterator it = m_EndReceiveCtxMap.find(cli_tag);
   	if(it == m_EndReceiveCtxMap.end())
    {
    	ASSERT_BENIGN(("EndReceive was not found in map", 0));
    	TrERROR(RPC, "EndReceive %d was not found in map", cli_tag);
		pEndReceiveCtx = NULL;
        return;
    }

	CEndReceiveCtx* pTmpEndReceiveCtx = it->second;
    m_EndReceiveCtxMap.erase(cli_tag);

	TrTRACE(RPC, "EndReceive %d was removed from map, map size = %d", cli_tag, numeric_cast<DWORD>(m_EndReceiveCtxMap.size()));

	pEndReceiveCtx = pTmpEndReceiveCtx;

	return;
}


void CRemoteReadCtx::SetEndReceiveTimerIfNeeded()
/*++
Routine Description:
	Set EndReceiveTimer If Needed.
	This function set the timer if not already set.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_EndReceiveMapCS);

	if (!m_fEndReceiveTimerScheduled)
	{
		AddRef();
		m_fEndReceiveTimerScheduled = true;
		ExSetTimer(&m_EndReceiveTimer, CTimeDuration::FromMilliSeconds(RpcCancelTimeout() + xEndReceiveTimerDeltaInterval));
	}
}


void 
CRemoteReadCtx::SetClientDisconnectedTimerIfNeeded(
	ULONG ulTimeout
	)
/*++
Routine Description:
	Set ClientDisconnectedTimer If Needed.
	This function set the timer if not already set and Timeout >= 15 min.

Arguments:
	ulTimeout - Timeout in milisec.

Returned Value:
	None.

--*/
{
    CS lock(m_PendingRemoteReadsCS);

	if (!m_fClientDisconnectedTimerScheduled && (ulTimeout > xMinTimeoutForSettingClientDisconnectedTimer))
	{
		AddRef();
		m_fClientDisconnectedTimerScheduled = true;
		ExSetTimer(&m_ClientDisconnectedTimer, CTimeDuration::FromMilliSeconds(xClientDisconnectedTimerInterval));
	}
}


//-------------------------------------------------------------------------
//
//  HRESULT RemoteRead_v1_0_S_StartReceive
//
//  Server side of RPC for remote reading.
//  Handle MSMQ 3.0 (Whistler) or higher clients.
//
//-------------------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_StartReceive(
	PRPC_ASYNC_STATE pAsync,
    handle_t hBind,
    RemoteReadContextHandleShared phOpenContext,	
    ULONGLONG LookupId,
    DWORD hCursor,
    DWORD ulAction,
    DWORD ulTimeout,
    DWORD dwRequestID,
    DWORD dwMaxBodySize,
    DWORD dwMaxCompoundMessageSize,
    DWORD* pdwArriveTime,
    ULONGLONG* pSequentialId,
    DWORD* pdwNumberOfSection,
	SectionBuffer** ppPacketSections
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

    //
    // Validate network incomming parameters
    //

	if(!VerifyBindAndContext(hBind, phOpenContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

	bool fReceiveByLookupId = ((ulAction & MQ_LOOKUP_MASK) == MQ_LOOKUP_MASK);

    if(fReceiveByLookupId && (ulTimeout != 0))
    {
		ASSERT_BENIGN(("Invalid input parameters: ReceiveByLookupId with timeout", 0));
        TrERROR(RPC, "invalid input parameters, fReceiveByLookupId = true, TimeOut != 0");
		AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
		return;
    }

    if(fReceiveByLookupId && (hCursor != 0))
    {
		ASSERT_BENIGN(("Invalid input parameters: ReceiveByLookupId with cursor", 0));
        TrERROR(RPC, "invalid input parameters, fReceiveByLookupId = true, hCursor != 0");
		AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
		return;
    }

    if((pdwArriveTime == NULL) || (pSequentialId == NULL) || (pdwNumberOfSection == NULL) || (ppPacketSections == NULL))
    {
		ASSERT_BENIGN(("Invalid input pointers", 0));
        TrERROR(RPC, "invalid input pointers");
		AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
		return;
    }
	
	SetRpcServerKeepAlive(hBind);

    CRemoteReadCtx* pctx = (CRemoteReadCtx*) phOpenContext;

	if(pctx->FindReadRequest(dwRequestID))
	{
		ASSERT_BENIGN(("Client Tag already exist in the map", 0));
		TrERROR(RPC, "Duplicate dwRequestID = %d", dwRequestID);
		AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
		return;
	}

	TrTRACE(RPC, "StartReceive: Queue = %ls, hQueue = 0x%p, Action = 0x%x, Timeout = %d, MaxBodySize = %d, MaxCompoundMessageSize = %d, LookupId = %I64d, hCursor = %d, dwRequestID = %d", pctx->m_pLocalQueue->GetQueueName(), pctx->m_hQueue, ulAction, ulTimeout, dwMaxBodySize, dwMaxCompoundMessageSize, LookupId, hCursor, dwRequestID);

	try
	{
		*pdwNumberOfSection = 0;
		*ppPacketSections = NULL;
		R<CGetPacket2RemoteOv> pGetPacket2RemoteOv = new CGetPacket2RemoteOv(
																pAsync,
																pctx,
																fReceiveByLookupId,
																LookupId,
															    hCursor,
															    ulAction,
															    ulTimeout,
															    dwMaxBodySize,
																dwMaxCompoundMessageSize,
																dwRequestID,
															    pdwArriveTime,
															    pSequentialId,
															    pdwNumberOfSection,
															    ppPacketSections
															    );
															

		HRESULT hr = MQ_OK;
		{
			//
			// Make sure that ReadRequest that was register has valid Server Tag
			// ACBeginGetPacket2Remote call create a valid Server Tag
			// So the PendingRemoteReadsCS lock is over the register of pGetPacket2RemoteOv
			// and the call to ACBeginGetPacket2Remote that update the server Tag
			// to valid value in pGetPacket2RemoteOv
			//
			CS lock(pctx->m_PendingRemoteReadsCS);

			if(pctx->FindReadRequest(dwRequestID))
			{
				ASSERT_BENIGN(("Client Tag already exist in the map", 0));
				TrERROR(RPC, "Duplicate dwRequestID = %d", dwRequestID);
				AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
				return;
			}

			pctx->RegisterReadRequest(dwRequestID, pGetPacket2RemoteOv);

			pctx->SetClientDisconnectedTimerIfNeeded(ulTimeout);

			bool fPeekAction = (((ulAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK) ||
								((ulAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK));

			if(pctx->IsWaitingForEndReceive() && !fPeekAction)
			{
				TrWARNING(RPC, "Server is waiting for EndReceive completion, Queue = %ls, hQueue = 0x%p, Action = 0x%x, Timeout = %d, LookupId = %I64d, hCursor = %d, dwRequestID = %d", pctx->m_pLocalQueue->GetQueueName(), pctx->m_hQueue, ulAction, ulTimeout, LookupId, hCursor, dwRequestID);

				//
				// Async completion
				//
				pGetPacket2RemoteOv.detach();
				AsyncComplete.detach();
				return;
			}

			//
			// Start Receive packet
			//
			hr = pGetPacket2RemoteOv->BeginGetPacket2Remote();

			if(FAILED(hr))
			{	
				pctx->UnregisterReadRequest(dwRequestID);

				ASSERT(pGetPacket2RemoteOv->m_packetPtrs.pPacket == NULL);
				TrERROR(RPC, "ACBeginGetPacket2Remote Failed, Tag = %d, %!hresult!", dwRequestID, hr);		
				AsyncComplete.SetHr(hr);		
				return;
			}
		}

		//
		// Async completion
		//
		pGetPacket2RemoteOv.detach();
		AsyncComplete.detach();

		//
		// Receive by lookup ID should never return status pending
		//
		ASSERT(hr != STATUS_PENDING || !fReceiveByLookupId);
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
	}
}


//---------------------------------------------------------------
//
//  /* [call_as] */ HRESULT RemoteRead_v1_0_S_CancelReceive
//
//  Server side of RPC. Cancel a pending read request
//
//---------------------------------------------------------------

/* [async][call_as] */ 
void
RemoteRead_v1_0_S_CancelReceive(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
	/* [in] */ handle_t hBind,
    /* [in] */ RemoteReadContextHandleShared phContext,	
	/* [in] */ DWORD Tag
	)
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, phContext))
	{
		AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		
		return;
	}

    SetRpcServerKeepAlive(hBind);

    CRemoteReadCtx* pctx = (CRemoteReadCtx*) phContext;

    TrTRACE(RPC, "Cancel pending receive: pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", pctx, pctx->m_hQueue, pctx->m_pLocalQueue->GetQueueName(), Tag);

    HRESULT hr = pctx->CancelPendingRemoteRead(Tag);

	AsyncComplete.SetHr(hr);		
}


/* [async][call_as] */ 
void
RemoteRead_v1_0_S_EndReceive(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t  hBind,
    /* [in] */ RemoteReadContextHandleShared phContext,	
    /* [in] */ DWORD  dwAck, 
    /* [in] */ DWORD Tag 
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_HANDLE, __FUNCTION__);

	if(!VerifyBindAndContext(hBind, phContext))
	{
		return;
	}

    SetRpcServerKeepAlive(hBind);

    CRemoteReadCtx* pctx = (CRemoteReadCtx*) phContext;

    TrTRACE(RPC, "EndReceive: pctx = 0x%p, hQueue = 0x%p, QueueName = %ls, CliTag = %d", pctx, pctx->m_hQueue, pctx->m_pLocalQueue->GetQueueName(), Tag);

	if(!pctx->IsWaitingForEndReceive())
	{
		ASSERT_BENIGN(("No pending end receive", 0));
		TrERROR(RPC, "No pending EndReceive on this session");
		return;
	}

	P<CEndReceiveCtx> pEndReceiveCtx;
	pctx->RemoveEndReceiveFromMap(Tag, pEndReceiveCtx);
	if(pEndReceiveCtx == NULL)
	{
		ASSERT_BENIGN(("Mismatch client tag in waiting EndReceiveCtx", 0));
		TrERROR(RPC, "Mismatch client tag in waiting EndReceiveCtx, Tag = %d", Tag);
		AsyncComplete.SetHr(MQ_ERROR_INVALID_PARAMETER);		
		return;
	}

	//
	// Complete the end receive and free the EndReceive context
	// QMRemoteEndReceiveInternal is call in EndReceive
	//
	HRESULT hr = pEndReceiveCtx->EndReceive((REMOTEREADACK)dwAck);

	pctx->StartAllPendingForEndReceive();
	
	AsyncComplete.SetHr(hr);		
}


//---------------------------------------------------------------
//
//  RunDown functions to handle cleanup in case of RPC failure.
//  Calls from client QM to remote QM
//
//---------------------------------------------------------------

void __RPC_USER
RemoteReadContextHandleShared_rundown(RemoteReadContextHandleShared phContext)
{
    TrWARNING(RPC,"rundown RemoteReadContextHandleShared 0x%p", phContext);

    QMCloseQueueInternal(
    	phContext, 
    	true	// fRunDown
    	);
}

void __RPC_USER
RemoteReadContextHandleExclusive_rundown(RemoteReadContextHandleExclusive phContext)
{
	RemoteReadContextHandleShared_rundown(phContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rrcontext.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rrcontext.cpp

Abstract:

    Remove Read overlapp classes.

Author:

    Ilan Herbst (ilanh) 20-Jan-2002

--*/


#include "stdh.h"
#include "cqueue.h"
#include <mqexception.h>
#include "rrcontext.h"

#include "qmacapi.h"

#include "rrcontext.tmh"

static WCHAR *s_FN=L"rrcontext";


extern HANDLE      g_hAc;

static
HRESULT
QmpClientRpcAsyncCompleteCall(	
	PRPC_ASYNC_STATE pAsync
	)
/*++
Routine Description:
	Client side complete async call.

Arguments:
	pAsync - pointer to RPC async statse structure.
	
Returned Value:
	HRESULT

--*/
{
	RpcTryExcept
	{
		HRESULT hr = MQ_OK;
		RPC_STATUS rc = RpcAsyncCompleteCall(pAsync, &hr);
	    if(rc == RPC_S_OK)
		{
			//
			// Async call completes, we got server returned value.
			//
			if(FAILED(hr))
			{
				TrWARNING(RPC, "Server RPC function failed, hr = %!hresult!", hr);
			}

		    return hr;
		}

		//
		// Failed to get returned value from server - Server Abort the call
		// The server function can Abort the call with MQ_ERROR could
		// or it can be some win32 error code RPC_S_*
		//
		if(FAILED(rc))
		{		
			TrERROR(RPC, "RpcAsyncCompleteCall failed, Server Call was aborted, %!hresult!", rc);
			return rc;
		}
		
		//
		// We don't expect server to Abort with MQ_INFORMATION_*
		//
		ASSERT((rc & MQ_I_BASE) != MQ_I_BASE);
		
		TrERROR(RPC, "RpcAsyncCompleteCall failed, gle = %!winerr!", rc);
	    return HRESULT_FROM_WIN32(rc);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		HRESULT hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "RpcAsyncCompleteCall throw exception, hr = %!hresult!", hr);
	        return hr;
		}
		
        TrERROR(RPC, "RpcAsyncCompleteCall throw exception, gle = %!winerr!", hr);
    	return HRESULT_FROM_WIN32(hr);

	}
	RpcEndExcept
}


//
// CRemoteOv
// Base class for async rpc with completion ports
//

void	
CRemoteOv::InitAsyncHandle(
	PRPC_ASYNC_STATE pAsync,
    EXOVERLAPPED* pov
	)
/*++
Routine Description:
	Initialize RPC async statse structure.
	Use overlapp as sync mechanism.
	The function throws bad_hresult in case of failure.

Arguments:
	pAsync - pointer to RPC async statse structure.
	pov - pointer to overlapped.
	
Returned Value:
	None
	
--*/
{
	RPC_STATUS rc = RpcAsyncInitializeHandle(pAsync, sizeof(RPC_ASYNC_STATE));
	if (rc != RPC_S_OK)
	{
		TrERROR(RPC, "RpcAsyncInitializeHandle failed, gle = %!winerr!", rc);
		throw bad_hresult(HRESULT_FROM_WIN32(rc));
	}

	pAsync->UserInfo = NULL;
	pAsync->NotificationType = RpcNotificationTypeIoc;
	pAsync->u.IOC.hIOPort = ExIOCPort();
	pAsync->u.IOC.dwNumberOfBytesTransferred = 0;
    pAsync->u.IOC.dwCompletionKey = 0;
    pAsync->u.IOC.lpOverlapped = pov;
}


CRemoteOv::CRemoteOv(
	handle_t hBind,
	COMPLETION_ROUTINE pSuccess,
	COMPLETION_ROUTINE pFailure
	):
    EXOVERLAPPED(pSuccess, pFailure),
    m_hBind(hBind)
{
    ASSERT(m_hBind != NULL);

	//
	// Initialize async rpc handle with overlapp
	//
	InitAsyncHandle(&m_Async, this);
}


//
// CRemoteReadBase
// Base class for Remote read request
//

CRemoteReadBase::CRemoteReadBase(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteOv(hBind, RemoteReadSucceeded, RemoteReadFailed),
	m_pLocalQueue(SafeAddRef(pLocalQueue)),
    m_fReceiveByLookupId(pRequest->Remote.Read.fReceiveByLookupId),
    m_LookupId(pRequest->Remote.Read.LookupId),
	m_ulTag(pRequest->Remote.Read.ulTag),
	m_hCursor(pRequest->Remote.Read.hRemoteCursor),
	m_ulAction(pRequest->Remote.Read.ulAction),
	m_ulTimeout(pRequest->Remote.Read.ulTimeout)
{
    //
    // Increment reference count of pLocalQueue.
    // will be released in the dtor when read request terminate.
    // This ensure that queue won't be deleted while remote read is in progress.
    //

	ASSERT(m_pLocalQueue->GetRRContext() != NULL);

    m_fSendEnd = (m_ulAction & MQ_ACTION_PEEK_MASK) != MQ_ACTION_PEEK_MASK &&
                 (m_ulAction & MQ_LOOKUP_PEEK_MASK) != MQ_LOOKUP_PEEK_MASK;

}


void WINAPI CRemoteReadBase::RemoteReadSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteRead Succeeded.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	P<CRemoteReadBase> pRemoteRequest = static_cast<CRemoteReadBase*>(pov);

	TrTRACE(RPC, "Tag = %d, LookupId = (%d, %I64d), RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", pRemoteRequest->GetTag(), pRemoteRequest->IsReceiveByLookupId(), pRemoteRequest->GetLookupId(), pRemoteRequest->GetLocalQueue()->GetQueueName(), pRemoteRequest->GetLocalQueue()->GetRef(), pRemoteRequest->GetLocalQueue()->GetRRContext());

	//
	// Complete the Async call
	//
	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
    if(hr != MQ_OK)
    {
		TrWARNING(RPC, "Remote Read failed, hr = %!hresult!", hr);
		pRemoteRequest->Cleanup(hr);
		return;
    }

	pRemoteRequest->CompleteRemoteRead();
}


void WINAPI CRemoteReadBase::RemoteReadFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteRead failed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrERROR(RPC, "RemoteReadFailed, Status = 0x%x", pov->GetStatus());
    ASSERT(FAILED(pov->GetStatus()));

	P<CRemoteReadBase> pRemoteRequest = static_cast<CRemoteReadBase*>(pov);

	TrTRACE(RPC, "Tag = %d, LookupId = (%d, %I64d), RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", pRemoteRequest->GetTag(), pRemoteRequest->IsReceiveByLookupId(), pRemoteRequest->GetLookupId(), pRemoteRequest->GetLocalQueue()->GetQueueName(), pRemoteRequest->GetLocalQueue()->GetRef(), pRemoteRequest->GetLocalQueue()->GetRRContext());

	QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	pRemoteRequest->Cleanup(pov->GetStatus());
}


void CRemoteReadBase::EndReceiveIfNeeded(HRESULT hr)
{
	//
	// notify server side about success/failure of the "put".
	// Only for GET. No need to ack/nack for PEEK.
	//
	if (m_fSendEnd)
	{
		DWORD dwAck = RR_ACK;
	    if (FAILED(hr))
	    {
	        dwAck = RR_NACK;
	    }

		try
		{
			EndReceive(dwAck);
		}
		catch(const exception&)
		{
		    m_pLocalQueue->DecrementEndReceiveCnt();
			TrERROR(RPC, "Failed to start Remote End Receive, queue = %ls, Tag = %d", m_pLocalQueue->GetQueueName(), m_ulTag);

			if(dwAck == RR_ACK)
			{
				//
				// Fail to issue EndReceive for Ack, Invalidate the handle for further receives
				// in the Old Remote Read interface only.
				// This is better than accumulating the messages in the server side without
				// the application noticing it.
				//
			    m_pLocalQueue->InvalidateHandleForReceive();
			}
		}
	}
}


void CRemoteReadBase::CompleteRemoteRead()
{
	//
	// Message received ok from remote QM. Try to insert it into
	// local "proxy" queue.
	//
	if (m_fSendEnd)
	{
	    m_pLocalQueue->IncrementEndReceiveCnt();
 	}

	CACPacketPtrs packetPtrs = {NULL, NULL};
	HRESULT hr = MQ_OK;

	try
	{
		ValidateNetworkInput();
	
		hr = QmAcAllocatePacket(
					g_hAc,
					ptReliable,
					GetPacketSize(),
					packetPtrs,
					FALSE
					);
		if(FAILED(hr))
		{
			ASSERT(packetPtrs.pDriverPacket == NULL);
	        TrERROR(RPC, "ACAllocatePacket failed, Tag = %d, hr = %!hresult!", m_ulTag, hr);
			throw bad_hresult(hr);
		}

	    ASSERT(packetPtrs.pPacket);

		MovePacketToPacketPtrs(packetPtrs.pPacket);
		FreePacketBuffer();
		ValidatePacket(packetPtrs.pPacket);

	    CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(packetPtrs.pPacket) - 1;
	    ppi->ArrivalTime(GetArriveTime());
	    ppi->SequentialID(GetSequentialId());

        QmAcPutRemotePacket(
                m_pLocalQueue->GetCli_hACQueue(),
                m_ulTag,
                packetPtrs.pDriverPacket,
                eDoNotDeferOnFailure
                );

		EndReceiveIfNeeded(hr);
		return;
    }
	catch(const bad_hresult& e)
	{
		hr = e.error();
	}
	catch(const exception&)
	{
    	TrERROR(RPC, "Remote read packet is not valid, Tag = %d", m_ulTag);
		hr = MQ_ERROR_INVALID_PARAMETER;
	}

	//
	// Free Packet if needed
	//
	if(packetPtrs.pDriverPacket != NULL)
	{
		QmAcFreePacket(packetPtrs.pDriverPacket, 0, eDeferOnFailure);
	}

	//
	// Nack and cleanup
	//
	EndReceiveIfNeeded(hr);
	Cleanup(hr);
}


void CRemoteReadBase::Cleanup(HRESULT hr)
{
    if (hr != MQ_OK)
    {
        if (hr != MQ_INFORMATION_REMOTE_CANCELED_BY_CLIENT)
        {
			//
	        // Error on remote QM. Notify local driver so it terminte the
	        // read request.
	        //
            TrERROR(RPC, "RemoteRead error on remote qm, hr = %!hresult!", hr);
			CancelRequest(hr);
        }
        else
        {
            TrTRACE(RPC, "Remote read was Cancelled by client, hr = %!hresult!", hr);
        }
    }

	FreePacketBuffer();
}


void CRemoteReadBase::CancelRequest(HRESULT hr)
{
    HRESULT hr1 =  ACCancelRequest(
			            m_pLocalQueue->GetCli_hACQueue(),
	                    hr,
	                    m_ulTag
	                    );
	if(FAILED(hr1))
	{
        TrERROR(RPC, "Failed to cancel RemoteRead request, hr = %!hresult!", hr1);
	}
}


//
// COldRemoteRead
// Remote read request, old interface
//

COldRemoteRead::COldRemoteRead(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue,
	bool fRemoteQmSupportsLatest
	):
	CRemoteReadBase(pRequest, hBind, pLocalQueue),
	m_fRemoteQmSupportsLatest(fRemoteQmSupportsLatest),
	m_pRRContext(NULL)
{
	ASSERT(static_cast<CRRQueue*>(pLocalQueue)->GetSrv_pQMQueue() != 0);
	InitRemoteReadDesc();
}


void COldRemoteRead::InitRemoteReadDesc()
{
	CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue().get());

    m_stRemoteReadDesc2.pRemoteReadDesc = &m_stRemoteReadDesc;
    m_stRemoteReadDesc2.SequentialId = 0;

    m_stRemoteReadDesc.hRemoteQueue = pCRRQueue->GetSrv_hACQueue();
    m_stRemoteReadDesc.hCursor      = GetCursor();
    m_stRemoteReadDesc.ulAction     = GetAction();
    m_stRemoteReadDesc.ulTimeout    = GetTimeout();
    m_stRemoteReadDesc.dwSize       = 0;
    m_stRemoteReadDesc.lpBuffer     = NULL;
    m_stRemoteReadDesc.dwpQueue     = pCRRQueue->GetSrv_pQMQueue();
    m_stRemoteReadDesc.dwRequestID  = GetTag();
    m_stRemoteReadDesc.Reserved     = 0;
    m_stRemoteReadDesc.eAckNack     = RR_UNKNOWN;
    m_stRemoteReadDesc.dwArriveTime = 0;
}


void COldRemoteRead::IssueRemoteRead()
/*++
Routine Description:

    Issue the RPC call on the client side remote read.
    The call may be queued if we are in a middle of completing EndReceive call for previous receive.

Arguments:
	None.

Return Value:
	None.
	
--*/
{
    if (IsReceiveByLookupId() && !m_fRemoteQmSupportsLatest)
    {
        TrERROR(RPC, "LookupId is not supported by remote computer");
		throw bad_hresult(MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER);
    }

	//
    // We guard against the possibility that an
    // "end" message of operation #N will arrive the server machine
    // after a new "start" of operation #(N+1). If this happen, and
    // the reader use cursor, then on operation #(N+1) he'll get the
    // error ALREADY_RECEIVED. This is because message from operation
    // #N is still marked as received and the cursor move only when
    // it is unmarked.
    // During handling the received message of operation #N,
    // we call ACPutRemotePacket, the application receive the message and trigger
    // start of operation #N+1 before we complete EndRecive,
    // even if we send the EndReceive#N response before StartReceive#N+1
    // The network order might be reversed and StartReceive#N+1 might arrive the server before EndReceive#N.
    // We don't mind sending a lot of StartReceives to the server,
    // We only guard that StartReceive that was triggered when the application got the message (ACPutRemotePacket)
    // will arrive to the server after the EndReceive.
	//
	CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue().get());
	if(pCRRQueue->QueueStartReceiveRequestIfPendingForEndReceive(this))
	{
		//
		// EndReceive is currently executing.
		// The StartReceive request was added to the Vector for waiting for EndReceive to complete.
		//
		TrTRACE(RPC, "Queue StartReceive request: LookupId = %I64d, RRQueue = %ls, ref = %d", GetLookupId(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef());
		return;
	}

	IssueRemoteReadInternal();
}


void COldRemoteRead::IssueRemoteReadInternal()
/*++
Routine Description:

    Issue the RPC call on the client side remote read.
    Translate RPC exception to error codes.

Arguments:
	None.

Return Value:
	None.
	
--*/
{
	CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue().get());
	if(IsReceiveOperation() && !pCRRQueue->HandleValidForReceive())
	{
        TrERROR(RPC, "The handle was invalidate for receive, Tag = %d, Action = 0x%x, RRQueue = %ls", GetTag(), GetAction(), GetLocalQueue()->GetQueueName());
    	throw bad_hresult(MQ_ERROR_STALE_HANDLE);
	}

    RpcTryExcept
    {
        if (IsReceiveByLookupId())
        {
            ASSERT(m_fRemoteQmSupportsLatest);

			TrTRACE(RPC, "R_RemoteQMStartReceiveByLookupId, Tag = %d, hCursor = %d, Action = 0x%x, Timeout = %d, LookupId = %I64d, RRQueue = %ls, ref = %d", GetTag(), GetCursor(), GetAction(), GetTimeout(), GetLookupId(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef());
            R_RemoteQMStartReceiveByLookupId(
				GetRpcAsync(),
				GethBind(),
				GetLookupId(),
				&m_pRRContext,
				&m_stRemoteReadDesc2
				);
            return;
        }

        if (m_fRemoteQmSupportsLatest)
        {
			TrTRACE(RPC, "R_RemoteQMStartReceive2, Tag = %d, hCursor = %d, Action = 0x%x, Timeout = %d, RRQueue = %ls, ref = %d", GetTag(), GetCursor(), GetAction(), GetTimeout(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef());
        	R_RemoteQMStartReceive2(
				GetRpcAsync(),
				GethBind(),
				&m_pRRContext,
				&m_stRemoteReadDesc2
				);
            return;

        }

		TrTRACE(RPC, "R_RemoteQMStartReceive, Tag = %d, hCursor = %d, Action = 0x%x, Timeout = %d, RRQueue = %ls, ref = %d", GetTag(), GetCursor(), GetAction(), GetTimeout(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef());
		R_RemoteQMStartReceive(
			GetRpcAsync(),
			GethBind(),
			&m_pRRContext,
			m_stRemoteReadDesc2.pRemoteReadDesc
			);
        return;
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		HRESULT hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "Fail to start Remote Receive, %!hresult!", hr);
			throw bad_hresult(hr);
		}
		
        TrERROR(RPC, "Fail to start Remote Receive, gle = %!winerr!", hr);
    	throw bad_hresult(HRESULT_FROM_WIN32(hr));
    }
	RpcEndExcept
	
}


void COldRemoteRead::IssuePendingRemoteRead()
{
	try
	{
		IssueRemoteReadInternal();
	    return;
	}
	catch(const bad_hresult& e)
	{
    	HRESULT hr = e.error();

		TrERROR(RPC, "Failed to issue RemoteRead for queue = %ls, hr = %!hresult!", GetLocalQueue()->GetQueueName(), hr);

	    hr =  ACCancelRequest(
	                GetLocalQueue()->GetCli_hACQueue(),
	                hr,
	                GetTag()
	                );
	
		if(FAILED(hr))
		{
	        TrERROR(RPC, "ACCancelRequest failed, hr = %!hresult!", hr);
		}

		//
		// Same delete for the "original" IssueRemoteRead exception.
		//
		delete this;
	}
}


void COldRemoteRead::ValidateNetworkInput()
{
    if(m_stRemoteReadDesc.lpBuffer == NULL)
    {
		ASSERT_BENIGN(("NULL Packet buffer", 0));
		TrERROR(RPC, "NULL packet buffer");
		throw exception();
    }

}


void COldRemoteRead::MovePacketToPacketPtrs(CBaseHeader* pPacket)
{
	ASSERT(m_stRemoteReadDesc.lpBuffer != NULL);
	
	MoveMemory(
		pPacket,
		m_stRemoteReadDesc.lpBuffer,
		m_stRemoteReadDesc.dwSize
		);
}


void COldRemoteRead::EndReceive(DWORD dwAck)
{
	ASSERT(m_pRRContext != NULL);
	
    //
    // Initialize the EXOVERLAPPED with RemoteEndReceive callback routines
    // And issue the End receive async rpc call.
	//
    P<CRemoteEndReceiveBase> pRequestRemoteEndReceiveOv = new COldRemoteEndReceive(
																    GethBind(),
																    GetLocalQueue(),
																    m_pRRContext,
																    dwAck
																    );

    pRequestRemoteEndReceiveOv->IssueEndReceive();

    pRequestRemoteEndReceiveOv.detach();
}


//
// CNewRemoteRead
// Remote read request, new interface
//

CNewRemoteRead::CNewRemoteRead(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteReadBase(pRequest, hBind, pLocalQueue),
	m_MaxBodySize(pRequest->Remote.Read.MaxBodySize),
	m_MaxCompoundMessageSize(pRequest->Remote.Read.MaxCompoundMessageSize),
	m_dwArriveTime(0),
	m_SequentialId(0),
	m_dwNumberOfSection(0),
	m_pPacketSections(NULL)
{
}


void CNewRemoteRead::IssueRemoteRead()
/*++
Routine Description:

    Issue the RPC call on the client side remote read.
    Translate RPC exception to error codes.

Arguments:
	None.

Return Value:
	None.
	
--*/
{
    RpcTryExcept
    {
		TrTRACE(RPC, "R_StartReceive, Tag = %d, hCursor = %d, Action = 0x%x, Timeout = %d, LookupId = (%d, %I64d), RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", GetTag(), GetCursor(), GetAction(), GetTimeout(), IsReceiveByLookupId(), GetLookupId(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetLocalQueue()->GetRRContext());
        R_StartReceive(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext(),
			GetLookupId(),
			GetCursor(),
			GetAction(),
			GetTimeout(),
			GetTag(),
			m_MaxBodySize,
			m_MaxCompoundMessageSize,
			&m_dwArriveTime,
			&m_SequentialId,
			&m_dwNumberOfSection,
			&m_pPacketSections
			);
        return;
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		HRESULT hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "Fail to start Remote Receive, %!hresult!", hr);
			throw bad_hresult(hr);
		}
		
        TrERROR(RPC, "Fail to start Remote Receive, gle = %!winerr!", hr);
    	throw bad_hresult(HRESULT_FROM_WIN32(hr));
    }
	RpcEndExcept
}


void CNewRemoteRead::ValidateNetworkInput()
{
    if((m_pPacketSections == NULL) || (m_dwNumberOfSection == 0))
    {
		ASSERT_BENIGN(("Invalid Packet Sections", 0));
		TrERROR(RPC, "Invalid Packet sections");
		throw exception();
    }

	for(DWORD i = 0; i < m_dwNumberOfSection; i++)
	{
		if(m_pPacketSections[i].SectionSizeAlloc < m_pPacketSections[i].SectionSize)
		{
			ASSERT_BENIGN(("Invalid section", 0));
			TrERROR(RPC, "Invalid section: SectionType = %d, SizeAlloc = %d < Size = %d", m_pPacketSections[i].SectionBufferType, m_pPacketSections[i].SectionSizeAlloc, m_pPacketSections[i].SectionSize);
			throw exception();
		}

		if(m_pPacketSections[i].SectionSize == 0)
		{
			ASSERT_BENIGN(("Section size zero", 0));
			TrERROR(RPC, "Invalid section: section size is zero");
			throw exception();
		}
	}
}


void CNewRemoteRead::MovePacketToPacketPtrs(CBaseHeader* pPacket)
{
	byte* pTemp = reinterpret_cast<byte*>(pPacket);
	for(DWORD i = 0; i < m_dwNumberOfSection; i++)
	{
		ASSERT(m_pPacketSections[i].SectionSize > 0);
		ASSERT(m_pPacketSections[i].SectionSizeAlloc >= m_pPacketSections[i].SectionSize);
		ASSERT(m_pPacketSections[i].pSectionBuffer != NULL);

		//
		// For each section copy the filled data part (SectionSize)
		// And advance to next section (SectionSizeAlloc)
		//
		TrTRACE(RPC, "SectionType = %d, SectionSize = %d, SectionSizeAlloc = %d", m_pPacketSections[i].SectionBufferType, m_pPacketSections[i].SectionSize, m_pPacketSections[i].SectionSizeAlloc);
		MoveMemory(
			pTemp,
			m_pPacketSections[i].pSectionBuffer,
			m_pPacketSections[i].SectionSize
			);

		if(m_pPacketSections[i].SectionSizeAlloc > m_pPacketSections[i].SectionSize)
		{
			//
			// Fill the gap between SectionSize and SectionSizeAlloc
			//
			const unsigned char xUnusedSectionFill = 0xFD;
			DWORD FillSize = m_pPacketSections[i].SectionSizeAlloc - m_pPacketSections[i].SectionSize;
			memset(pTemp + m_pPacketSections[i].SectionSize, xUnusedSectionFill, FillSize);		
		}

		pTemp += m_pPacketSections[i].SectionSizeAlloc;
	}
}


void CNewRemoteRead::EndReceive(DWORD dwAck)
{
    //
    // Initialize the EXOVERLAPPED with RemoteEndReceive callback routines
    // And issue the End receive async rpc call.
	//
    P<CRemoteEndReceiveBase> pRequestRemoteEndReceiveOv = new CNewRemoteEndReceive(
																    GetLocalQueue()->GetBind(),
																    GetLocalQueue(),
																    dwAck,
																    GetTag()
																    );

    pRequestRemoteEndReceiveOv->IssueEndReceive();

    pRequestRemoteEndReceiveOv.detach();
}


//
// CRemoteEndReceiveBase
// Base class for Remote read End Receive request
//

CRemoteEndReceiveBase::CRemoteEndReceiveBase(
	handle_t hBind,
	R<CBaseRRQueue>& pLocalQueue,
	DWORD dwAck
	):
	CRemoteOv(hBind, RemoteEndReceiveCompleted, RemoteEndReceiveCompleted),
	m_pLocalQueue(pLocalQueue),
	m_dwAck(dwAck)
{
    //
    // The assigment of m_pLocalQueue, Increments ref count of pLocalQueue.
    // It we be realeased in the dtor.
    //
}


void WINAPI CRemoteEndReceiveBase::RemoteEndReceiveCompleted(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when EndReceive Completed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "Status = 0x%x", pov->GetStatus());

	P<CRemoteEndReceiveBase> pRemoteRequest = static_cast<CRemoteEndReceiveBase*>(pov);

    pRemoteRequest->GetLocalQueue()->DecrementEndReceiveCnt();

	TrTRACE(RPC, "RRQueue = %ls, ref = %d, dwAck = %d, Tag = %d, OpenRRContext = 0x%p", pRemoteRequest->GetLocalQueue()->GetQueueName(), pRemoteRequest->GetLocalQueue()->GetRef(), pRemoteRequest->GetAck(), pRemoteRequest->GetTag(), pRemoteRequest->GetLocalQueue()->GetRRContext());

	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	if(FAILED(hr))
	{
		TrERROR(RPC, "Remote End Receive failed, hr = %!hresult!", hr);

		if(pRemoteRequest->GetAck() == RR_ACK)
		{
			//
			// EndReceive failed for Ack, Invalidate the handle for further receives
			// in the Old Remote Read interface only.
			// This is better than accumulating the messages in the server side without
			// the application noticing it.
			//
		    pRemoteRequest->GetLocalQueue()->InvalidateHandleForReceive();
		}
	}
}


//
// COldRemoteEndReceive
// Remote read End Receive request, old interface
//

COldRemoteEndReceive::COldRemoteEndReceive(
	handle_t hBind,
	R<CBaseRRQueue>& pLocalQueue,
	PCTX_REMOTEREAD_HANDLE_TYPE pRRContext,
	DWORD dwAck
	):
	CRemoteEndReceiveBase(hBind, pLocalQueue, dwAck),
	m_pRRContext(pRRContext)
{
}


void COldRemoteEndReceive::IssueEndReceive()
{
    RpcTryExcept
    {
		TrTRACE(RPC, "R_RemoteQMEndReceive, RRQueue = %ls, ref = %d, dwAck = %d", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetAck());
		R_RemoteQMEndReceive(
			GetRpcAsync(),
			GethBind(),
		    &m_pRRContext,
		    GetAck()
            );
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue End Receive, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
    }
	RpcEndExcept
}


//
// CNewRemoteEndReceive
// Remote read End Receive request, new interface
//

CNewRemoteEndReceive::CNewRemoteEndReceive(
	handle_t hBind,
	R<CBaseRRQueue>& pLocalQueue,
	DWORD dwAck,
	ULONG Tag
	):
	CRemoteEndReceiveBase(hBind, pLocalQueue, dwAck),
	m_ulTag(Tag)
{
}

void CNewRemoteEndReceive::IssueEndReceive()
{
    RpcTryExcept
    {
		TrTRACE(RPC, "R_EndReceive, RRQueue = %ls, ref = %d, dwAck = %d, Tag = %d, OpenRRContext = 0x%p", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetAck(), m_ulTag, GetLocalQueue()->GetRRContext());
		R_EndReceive(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext(),
		    GetAck(),
		    m_ulTag
            );
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue End Receive, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
    }
	RpcEndExcept
}

//
// CRemoteCloseQueueBase
// Base class for Remote close queue request
//

CRemoteCloseQueueBase::CRemoteCloseQueueBase(
	handle_t hBind
	):
	CRemoteOv(hBind, RemoteCloseQueueCompleted, RemoteCloseQueueCompleted),
	m_hBindToFree(hBind)
{
}


void WINAPI CRemoteCloseQueueBase::RemoteCloseQueueCompleted(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteCloseQueue Completed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "Status = 0x%x", pov->GetStatus());

	P<CRemoteCloseQueueBase> pRemoteRequest = static_cast<CRemoteCloseQueueBase*>(pov);

	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	if(FAILED(hr))
	{
		TrERROR(RPC, "Failed to Close Remote Queue, hr = %!hresult!", hr);
	}
}


//
// COldRemoteCloseQueue
// Remote close queue request, old interface
//

COldRemoteCloseQueue::COldRemoteCloseQueue(
	handle_t hBind,
	PCTX_RRSESSION_HANDLE_TYPE pRRContext
	):
	CRemoteCloseQueueBase(hBind),
	m_pRRContext(pRRContext)
{
	ASSERT(m_pRRContext != NULL);
}

void COldRemoteCloseQueue::IssueCloseQueue()
{
    RpcTryExcept
    {
		TrTRACE(RPC, "R_RemoteQMCloseQueue, pRRContext = 0x%p", m_pRRContext);
        R_RemoteQMCloseQueue(
			GetRpcAsync(),
			GethBind(),
		    &m_pRRContext
            );
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Close Queue, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
    }
	RpcEndExcept
}


//
// CNewRemoteCloseQueue
// Remote close queue request, new interface
//

CNewRemoteCloseQueue::CNewRemoteCloseQueue(
	handle_t hBind,
	RemoteReadContextHandleExclusive pNewRemoteReadContext
	):
	CRemoteCloseQueueBase(hBind),
	m_pNewRemoteReadContext(pNewRemoteReadContext)
{
	ASSERT(m_pNewRemoteReadContext != NULL);
}


void CNewRemoteCloseQueue::IssueCloseQueue()
{
    RpcTryExcept
    {
		TrTRACE(RPC, "R_CloseQueue, pNewRemoteReadContext = 0x%p", m_pNewRemoteReadContext);
        R_CloseQueue(
			GetRpcAsync(),
			GethBind(),
		    &m_pNewRemoteReadContext
            );
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Close Queue, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
    }
	RpcEndExcept
}


//
// CRemoteCreateCursorBase
// Base class for Remote create cursor request
//

CRemoteCreateCursorBase::CRemoteCreateCursorBase(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteOv(hBind, RemoteCreateCursorSucceeded, RemoteCreateCursorFailed),
	m_pLocalQueue(SafeAddRef(pLocalQueue)),
    m_hRCursor(0),
    m_ulTag(pRequest->Remote.CreateCursor.ulTag)
{
}


void WINAPI CRemoteCreateCursorBase::RemoteCreateCursorSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteCreateCursor Succeeded.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "In RemoteCreateCursorSucceeded");
    ASSERT(SUCCEEDED(pov->GetStatus()));

	P<CRemoteCreateCursorBase> pRemoteRequest = static_cast<CRemoteCreateCursorBase*>(pov);

	//
	// Complete the Async call
	//
	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());

	if(SUCCEEDED(hr))
	{
		hr = pRemoteRequest->CompleteRemoteCreateCursor();
	}

	if(FAILED(hr))
	{
		//
		// this is a failure of either QmpClientRpcAsyncCompleteCall() or CompleteRemoteCreateCursor()
		//
		TrERROR(RPC, "Failed to create Remote Cursor, hr = %!hresult!", hr);
		pRemoteRequest->CancelRequest(hr);
	}
	
}


void WINAPI CRemoteCreateCursorBase::RemoteCreateCursorFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteCreateCursor failed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrERROR(RPC, "RemoteCreateCursorFailed, Status = 0x%x", pov->GetStatus());
    ASSERT(FAILED(pov->GetStatus()));

	P<CRemoteCreateCursorBase> pRemoteRequest = static_cast<CRemoteCreateCursorBase*>(pov);

	QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	pRemoteRequest->CancelRequest(pov->GetStatus());
}


HRESULT CRemoteCreateCursorBase::CompleteRemoteCreateCursor()
{
	
	//
	// first, check if the m_hRCursor != 0
	//
	if(m_hRCursor == 0)
	{	
		ASSERT_BENIGN(("Invalid remote cursor", 0));
        TrERROR(RPC, "Invalid remote cursor was returned by the server");
		return MQ_ERROR_INVALID_HANDLE;
	}	
	
	HRESULT hr = ACCreateRemoteCursor(
		            m_pLocalQueue->GetCli_hACQueue(),
					m_hRCursor,
					m_ulTag
					);

	if(FAILED(hr))
	{
		//
		// ACCreateRemoteCursor failed, when the queue handle will be closed
		// all cursors will be cleaned up.
		//
		TrERROR(RPC, "ACSetCursorProperties failed, hr = %!hresult!", hr);
	}
	return hr;
}


void CRemoteCreateCursorBase::CancelRequest(HRESULT hr)
{
    HRESULT hr1 =  ACCancelRequest(
			            m_pLocalQueue->GetCli_hACQueue(),
	                    hr,
	                    m_ulTag
	                    );
	if(FAILED(hr1))
	{
        TrERROR(RPC, "Failed to cancel Remote create cursor, hr = %!hresult!", hr1);
	}
}


//
// COldRemoteCreateCursor
// Remote create cursor request, old interface
//

COldRemoteCreateCursor::COldRemoteCreateCursor(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCreateCursorBase(pRequest, hBind, pLocalQueue)
{
}

	
void COldRemoteCreateCursor::IssueCreateCursor()
{
    //
    // Pass the old TransferBuffer to Create Remote Cursor
    // for MSMQ 1.0 compatibility.
    //
	CACTransferBufferV1 tb;
    ZeroMemory(&tb, sizeof(tb));
    tb.uTransferType = CACTB_CREATECURSOR;

	RpcTryExcept
	{
		CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue());
		TrTRACE(RPC, "R_QMCreateRemoteCursor, RRQueue = %ls, ref = %d, srv_hACQueue = %d", pCRRQueue->GetQueueName(), pCRRQueue->GetRef(), pCRRQueue->GetSrv_hACQueue());
		R_QMCreateRemoteCursor(
			GetRpcAsync(),
			GethBind(),
			&tb,
			pCRRQueue->GetSrv_hACQueue(),
			GetphRCursor()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		HRESULT hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "Failed to issue Create Remote Cursor, hr = %!hresult!", hr);
			throw bad_hresult(hr);
		}
		
        TrERROR(RPC, "Failed to issue Create Remote Cursor, gle = %!winerr!", hr);
    	throw bad_hresult(HRESULT_FROM_WIN32(hr));
	}
	RpcEndExcept
}


//
// CNewRemoteCreateCursor
// Remote create cursor request, new interface
//

CNewRemoteCreateCursor::CNewRemoteCreateCursor(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCreateCursorBase(pRequest, hBind, pLocalQueue)
{
}


void CNewRemoteCreateCursor::IssueCreateCursor()
{
	RpcTryExcept
	{
		TrTRACE(RPC, "R_CreateCursor, RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetLocalQueue()->GetRRContext());
		R_CreateCursor(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext(),
			GetphRCursor()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		HRESULT hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "Failed to issue Create Remote Cursor, hr = %!hresult!", hr);
			throw bad_hresult(hr);
		}
		
        TrERROR(RPC, "Failed to issue Create Remote Cursor, gle = %!winerr!", hr);
    	throw bad_hresult(HRESULT_FROM_WIN32(hr));
	}
	RpcEndExcept
}


//
// CRemoteCloseCursorBase
// Base class for Remote close cursor request
//

CRemoteCloseCursorBase::CRemoteCloseCursorBase(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteOv(hBind, RemoteCloseCursorCompleted, RemoteCloseCursorCompleted),
	m_pLocalQueue(SafeAddRef(pLocalQueue)),
	m_hRemoteCursor(pRequest->Remote.CloseCursor.hRemoteCursor)
{
}


void WINAPI CRemoteCloseCursorBase::RemoteCloseCursorCompleted(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteCloseCursor Completed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "Status = 0x%x", pov->GetStatus());

	P<CRemoteCloseCursorBase> pRemoteRequest = static_cast<CRemoteCloseCursorBase*>(pov);

	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	if(FAILED(hr))
	{
		TrWARNING(RPC, "Remote Close Cursor failed, hr = %!hresult!", hr);
	}

}


//
// COldRemoteCloseCursor
// Remote create cursor request, old interface
//

COldRemoteCloseCursor::COldRemoteCloseCursor(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCloseCursorBase(pRequest, hBind, pLocalQueue)
{
}

void COldRemoteCloseCursor::IssueCloseCursor()
{
	RpcTryExcept
	{
		CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue());
		TrTRACE(RPC, "R_RemoteQMCloseCursor, srv_hACQueue = %d, hRemoteCursor = %d, RRQueue = %ls, ref = %d", pCRRQueue->GetSrv_hACQueue(), GetRemoteCursor(), pCRRQueue->GetQueueName(), pCRRQueue->GetRef());
		R_RemoteQMCloseCursor(
			GetRpcAsync(),
			GethBind(),
			pCRRQueue->GetSrv_hACQueue(),
			GetRemoteCursor()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Failed to issue Remote Close Cursor, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}


//
// CNewRemoteCloseCursor
// Remote create cursor request, new interface
//

CNewRemoteCloseCursor::CNewRemoteCloseCursor(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCloseCursorBase(pRequest, hBind, pLocalQueue)
{
}

void CNewRemoteCloseCursor::IssueCloseCursor()
{
	RpcTryExcept
	{
		TrTRACE(RPC, "R_CloseCursor, hRemoteCursor = %d, RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", GetRemoteCursor(), GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetLocalQueue()->GetRRContext());
		R_CloseCursor(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext(),
			GetRemoteCursor()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Failed to issue Remote Close Cursor, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}


//
// CRemotePurgeQueueBase
// Base class for Remote purge queue request
//

CRemotePurgeQueueBase::CRemotePurgeQueueBase(
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteOv(hBind, RemotePurgeQueueCompleted, RemotePurgeQueueCompleted),
	m_pLocalQueue(SafeAddRef(pLocalQueue))
{
}


void WINAPI CRemotePurgeQueueBase::RemotePurgeQueueCompleted(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemotePurgeQueue Completed.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "Status = 0x%x", pov->GetStatus());

	P<CRemotePurgeQueueBase> pRemoteRequest = static_cast<CRemotePurgeQueueBase*>(pov);

	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	if(FAILED(hr))
	{
		TrWARNING(RPC, "Remote Purge Queue failed, hr = %!hresult!", hr);
	}

}


//
// COldRemotePurgeQueue
// Remote purge queue request, old interface
//

COldRemotePurgeQueue::COldRemotePurgeQueue(
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemotePurgeQueueBase(hBind, pLocalQueue)
{
}


void COldRemotePurgeQueue::IssuePurgeQueue()
{
	RpcTryExcept
	{
		CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue());
		TrTRACE(RPC, "R_RemoteQMPurgeQueue, srv_hACQueue = %d, RRQueue = %ls, ref = %d", pCRRQueue->GetSrv_hACQueue(), pCRRQueue->GetQueueName(), pCRRQueue->GetRef());
		R_RemoteQMPurgeQueue(
			GetRpcAsync(),
			GethBind(),
			pCRRQueue->GetSrv_hACQueue()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Purge Queue, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}


//
// CNewRemotePurgeQueue
// Remote purge queue request, new interface
//

CNewRemotePurgeQueue::CNewRemotePurgeQueue(
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemotePurgeQueueBase(hBind, pLocalQueue)
{
}

void CNewRemotePurgeQueue::IssuePurgeQueue()
{
	RpcTryExcept
	{
		TrTRACE(RPC, "R_PurgeQueue, RRQueue = %ls, ref = %d, OpenRRContext = 0x%p", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetLocalQueue()->GetRRContext());
		R_PurgeQueue(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Purge Queue, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}


//
// CRemoteCancelReadBase
// Base class for Remote cancel receive request
//

CRemoteCancelReadBase::CRemoteCancelReadBase(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteOv(hBind, RemoteCancelReadCompleted, RemoteCancelReadCompleted),
	m_pLocalQueue(SafeAddRef(pLocalQueue)),
	m_ulTag(pRequest->Remote.Read.ulTag)
{
}


void WINAPI CRemoteCancelReadBase::RemoteCancelReadCompleted(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when RemoteCancelRead Completed (success, failure).

Arguments:
    None.

Returned Value:
    None.

--*/
{
    TrTRACE(RPC, "Status = 0x%x", pov->GetStatus());

	P<CRemoteCancelReadBase> pRemoteRequest = static_cast<CRemoteCancelReadBase*>(pov);

	HRESULT hr = QmpClientRpcAsyncCompleteCall(pRemoteRequest->GetRpcAsync());
	if(FAILED(hr))
	{
		TrWARNING(RPC, "Remote Cancel Read failed, hr = %!hresult!", hr);
	}

}


//
// COldRemoteCancelRead
// Remote cancel receive request, old interface
//

COldRemoteCancelRead::COldRemoteCancelRead(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCancelReadBase(pRequest, hBind, pLocalQueue)
{
}

void COldRemoteCancelRead::IssueRemoteCancelRead()
{
	CRRQueue* pCRRQueue = static_cast<CRRQueue*>(GetLocalQueue());
	ASSERT(pCRRQueue->GetSrv_hACQueue() != 0);
	ASSERT(pCRRQueue->GetSrv_pQMQueue() != 0);

	RpcTryExcept
	{
		TrTRACE(RPC, "R_RemoteQMCancelReceive, RRQueue = %ls, ref = %d, srv_hACQueue = %d, srv_pQMQueue = %d, ulTag = %d", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), pCRRQueue->GetSrv_hACQueue(), pCRRQueue->GetSrv_pQMQueue(), GetTag());
		R_RemoteQMCancelReceive(
			GetRpcAsync(),
			GethBind(),
			pCRRQueue->GetSrv_hACQueue(),
			pCRRQueue->GetSrv_pQMQueue(),
			GetTag()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Cancel Receive, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}


//
// CNewRemoteCancelRead
// Remote cancel receive request, new interface
//

CNewRemoteCancelRead::CNewRemoteCancelRead(
	const CACRequest* pRequest,
	handle_t hBind,
	CBaseRRQueue* pLocalQueue
	):
	CRemoteCancelReadBase(pRequest, hBind, pLocalQueue)
{
}


void CNewRemoteCancelRead::IssueRemoteCancelRead()
{
	RpcTryExcept
	{
		TrTRACE(RPC, "R_CancelReceive, RRQueue = %ls, ref = %d, ulTag = %d, RRContext = 0x%p", GetLocalQueue()->GetQueueName(), GetLocalQueue()->GetRef(), GetTag(), GetLocalQueue()->GetRRContext());
		R_CancelReceive(
			GetRpcAsync(),
			GethBind(),
            GetLocalQueue()->GetRRContext(),
			GetTag()
			);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		//
		// client side failure
		//
		DWORD gle = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		
        TrERROR(RPC, "Fail to issue Remote Cancel Receive, gle = %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	RpcEndExcept
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rrsrvcommon.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rrSrvCommon.cpp

Abstract:

    Remove Read server side common code for old and new interface.

Author:

    Ilan Herbst		(ilanh) 3-Mar-2002

--*/

#include "stdh.h"
#include "cqueue.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "rrSrvCommon.h"
#include "qmacapi.h"

#include "rrSrvCommon.tmh"

static WCHAR *s_FN=L"rrSrvCommon";


//-------------------------------------------------------------
//
//  class CRpcServerFinishCall implementation
//
//-------------------------------------------------------------

CRpcAsyncServerFinishCall::CRpcAsyncServerFinishCall(
	PRPC_ASYNC_STATE pAsync,
    HRESULT DefaultAbortHr,
    LPCSTR FuncName
	):
	m_pAsync(pAsync),
	m_hr(DefaultAbortHr),
	m_FuncName(FuncName),
	m_fCompleteCall(false)
{
	ASSERT(FAILED(DefaultAbortHr));
	TrTRACE(RPC, "In %s", m_FuncName);
}


CRpcAsyncServerFinishCall::~CRpcAsyncServerFinishCall()                       
{ 
	ASSERT(m_hr != STATUS_PENDING);

	if(m_pAsync == NULL)
		return;

	if(SUCCEEDED(m_hr) || m_fCompleteCall)
	{
		CompleteCall();
		return;
	}

	AbortCall();
}


void CRpcAsyncServerFinishCall::CompleteCall()
{
	ASSERT(SUCCEEDED(m_hr) || m_fCompleteCall);
	if(FAILED(m_hr))
	{
		TrERROR(RPC, "Complete %s, %!hresult!", m_FuncName, m_hr);
	}
	
	RPC_STATUS rc = RpcAsyncCompleteCall(m_pAsync, &m_hr);
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "%s: RpcAsyncCompleteCall failed, rc = %!winerr!", m_FuncName, rc);
	}
}

	
void CRpcAsyncServerFinishCall::AbortCall()
{
	ASSERT(FAILED(m_hr));

	RPC_STATUS rc = RpcAsyncAbortCall(m_pAsync, m_hr);
	if(rc != RPC_S_OK)
	{
		TrERROR(RPC, "%s: RpcAsyncAbortCall failed, rc = %!winerr!", m_FuncName, rc);
	}

	TrERROR(RPC, "Abort %s, %!hresult!", m_FuncName, m_hr);
}


CRRCursor::~CRRCursor()
{
	if(m_hCursor == NULL)
		return;

	ASSERT(m_hQueue != NULL);

	HRESULT hr = ACCloseCursor(m_hQueue, m_hCursor);
	if(FAILED(hr))
	{
	    TrERROR(RPC, "Failed to close cursor: hCursor = %d, hQueue = 0x%p, %!HRESULT!", (ULONG)m_hCursor, m_hQueue, hr);
		return;
	}

    TrTRACE(RPC, "hCursor = %d, hQueue = 0x%p", (ULONG)m_hCursor, m_hQueue);
}


CTX_OPENREMOTE_BASE::~CTX_OPENREMOTE_BASE()
{
	//
	// Cursors that are still in the map were not closed by the application. 
	// ACCloseHandle(m_hQueue) will close all cursors opened on that queue.
	// That is the reason for the Reset - ownership for closing the cursors
	// is transfered to ACCloseHandle.
	//
	ResetAllCursorsInMap();
	
	ASSERT(m_hQueue != NULL);
    ACCloseHandle(m_hQueue);
}


void CTX_OPENREMOTE_BASE::ResetAllCursorsInMap()
/*++
Routine Description:
	Reset all cursors in open cursors map.
	This function is called when the remote session is ended.
	In this case reset all cursors, the ownership for closing all cursors is
	transfered to ACCloseHandle(hQueue).

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_OpenCursorsCS);

	for(std::map<ULONG, R<CRRCursor> >::iterator it = m_OpenCursors.begin(); 
		it != m_OpenCursors.end();
		++it
		)
    {
		//
		// Must Release the Ref we just got from the map.
		//
		R<CRRCursor> pCursor = it->second;

		//
		// Validate we don't have a leak.
		// RefCnt must be 2
		// one ref for the iterator we just got from the map.
		// one ref for initial AddCursorToMap. 
		//
		ASSERT(pCursor->GetRef() == 2);

		pCursor->Reset();
    }
}


void 
CTX_OPENREMOTE_BASE::AddCursorToMap(
	ULONG hCursor,
	R<CRRCursor>& pCursor
	)
/*++
Routine Description:
	Add cursor to open cursors map.

Arguments:
	hCursor - Cursor handle.
	pCursor - CRRCursor object.
 
Returned Value:
	None.

--*/
{
	CS lock(m_OpenCursorsCS);

#ifdef _DEBUG
	//
	// Validate no duplicate cursor already in the map.
	//
    std::map<ULONG, R<CRRCursor> >::iterator it = m_OpenCursors.find(hCursor);
   	ASSERT(it == m_OpenCursors.end());
#endif

    TrTRACE(RPC, "Adding Cursor %d to open cursors map", hCursor);

    m_OpenCursors[hCursor] = pCursor;
}


HRESULT
CTX_OPENREMOTE_BASE::RemoveCursorFromMap(
	ULONG hCursor
	)
/*++
Routine Description:
	Remove cursor from open cursors map.

Arguments:
	hCursor - Cursor handle.

Returned Value:
	None.

--*/
{
    CS lock(m_OpenCursorsCS);

	ASSERT_BENIGN(!m_OpenCursors.empty());

    std::map<ULONG, R<CRRCursor> >::iterator it = m_OpenCursors.find(hCursor);

   	if(it == m_OpenCursors.end())
    {
    	ASSERT_BENIGN(("Cursor was not found in open cursors map", 0));
    	TrERROR(RPC, "Cursor %d was not found in cursor map", hCursor);
        return MQ_ERROR_INVALID_HANDLE;
    }

    TrTRACE(RPC, "Removing Cursor %d from open cursors map", hCursor);

    m_OpenCursors.erase(hCursor);
	return MQ_OK;
}


R<CRRCursor> 
CTX_OPENREMOTE_BASE::GetCursorFromMap(
	ULONG hCursor
	)
/*++
Routine Description:
	Get cursor from open cursors map.

Arguments:
	hCursor - Cursor handle.

Returned Value:
	CRRCursor*.

--*/
{
	ASSERT(hCursor != 0);

    CS lock(m_OpenCursorsCS);

	ASSERT_BENIGN(!m_OpenCursors.empty());

    std::map<ULONG, R<CRRCursor> >::iterator it = m_OpenCursors.find(hCursor);
   	if(it == m_OpenCursors.end())
    {
    	ASSERT_BENIGN(("Cursor was not found in open cursors map", 0));
    	TrERROR(RPC, "Cursor %d was not found in cursor map", hCursor);
        return NULL;
    }

	return it->second;
}


//---------------------------------------------------------
//
// /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteStartReceive
// /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteEndReceive
//
//  Server side of RPC for remote reading.
//  This function read from local queue and transfers the
//  packet to the client QM, on which MQReceive() was called.
//
//  Reading from driver is done in two phases:
//  1. Client side call R_QMRemoteStartReceive. Server side get a packet
//     from queue, mark it as received and returned it to client.
//     Marking the packet as received (in the driver) prevent other receive
//     requests from getting this packet.
//  2. Client side put the packet in the temporary queue it created and the
//     driver will return it to the caller. If driver successfully delivered
//     it then client send an ACK to server and server delete the packet
//     (for GET). if the driver can't deliver it then client send a NACK
//     to server and server re-insert the packet in its original place
//     in queue.
//
//---------------------------------------------------------

HRESULT   
QMRemoteEndReceiveInternal( 
	HANDLE        hQueue,
	HACCursor32   hCursor,
	ULONG         ulTimeout,
	ULONG         ulAction,
	REMOTEREADACK eRRAck,
	CBaseHeader*  lpPacket,
	CPacket*      pDriverPacket
	)
{
	if((lpPacket == NULL) || (pDriverPacket == NULL))
	{
		ASSERT_BENIGN(lpPacket != NULL);
		ASSERT_BENIGN(pDriverPacket != NULL);
		TrERROR(RPC, "Invalid packet pointers input");
        return MQ_ERROR_INVALID_PARAMETER;
	}

	CACGet2Remote g2r;
	g2r.Cursor = hCursor;
	g2r.Action = ulAction;
	g2r.RequestTimeout = ulTimeout;
	g2r.fReceiveByLookupId = false;

	if (eRRAck == RR_NACK)
	{
		//
		// To keep the packet in queue we replace the "GET" action
		// with "PEEK_CURRENT", so the packet remain in queue and
		// cursor is not moved.
		//
		g2r.Action = MQ_ACTION_PEEK_CURRENT;
	}
	else
	{
		ASSERT(eRRAck == RR_ACK);
	}

	g2r.lpPacket = lpPacket;
	g2r.lpDriverPacket = pDriverPacket;
	QmAcEndGetPacket2Remote(hQueue, g2r, eDeferOnFailure);
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rrcontext.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rrcontext.h

Abstract:

    Remove Read overlapp classes.

Author:

    Ilan Herbst (ilanh) 20-Jan-2002

--*/

#ifndef _RRCONTEXT_H_
#define _RRCONTEXT_H_

#include "qmrt.h"
#include "qmrtopen.h"

//---------------------------------------------------------
//
//  CRemoteOv - base class for async rpc with completion ports
//
//---------------------------------------------------------

class CRemoteOv : public EXOVERLAPPED
{
public:
    CRemoteOv( 
		handle_t hBind,
        COMPLETION_ROUTINE pSuccess,
        COMPLETION_ROUTINE pFailure
    	);

    PRPC_ASYNC_STATE GetRpcAsync(void)
    {
        return &m_Async;
    }
	
    handle_t GethBind(void)
    {
        return m_hBind;
    }

private:
	void	
	InitAsyncHandle(
		PRPC_ASYNC_STATE pAsync,
	    EXOVERLAPPED* pov
		);

private:
	RPC_ASYNC_STATE m_Async;
	handle_t m_hBind;
};

class CBaseRRQueue;
	
//---------------------------------------------------------
//
//  CRemoteReadBase - Base class for Remote read request
//
//---------------------------------------------------------
class CRemoteReadBase : public CRemoteOv
{
public:
    CRemoteReadBase( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueRemoteRead() = 0;

    ULONG GetTag()
    {
    	return m_ulTag;
    }

protected:
	R<CBaseRRQueue>& GetLocalQueue()
	{
		return m_pLocalQueue;
	}

	bool IsReceiveByLookupId()
	{
		return m_fReceiveByLookupId;
	}

	ULONGLONG GetLookupId()
	{
		return m_LookupId;
	}

    ULONG GetCursor()
    {
    	return m_hCursor;
    }

    ULONG GetAction()
    {
    	return m_ulAction;
    }

    ULONG GetTimeout()
    {
    	return m_ulTimeout;
    }

    bool IsReceiveOperation()
    {
    	return m_fSendEnd;
    }

	virtual void ValidateNetworkInput() = 0;

	virtual void MovePacketToPacketPtrs(CBaseHeader* pPacket) = 0;

	virtual void FreePacketBuffer() = 0;

	virtual void ValidatePacket(CBaseHeader* pPacket) = 0;

    virtual DWORD GetPacketSize() = 0;

    virtual DWORD GetArriveTime() = 0;

    virtual ULONGLONG GetSequentialId() = 0;

	void Cleanup(HRESULT hr);

private:
	void CompleteRemoteRead();

	void EndReceiveIfNeeded(HRESULT hr);

	void CancelRequest(HRESULT hr);

	virtual void EndReceive(DWORD dwAck) = 0;

	static void WINAPI RemoteReadSucceeded(EXOVERLAPPED* pov);
	static void WINAPI RemoteReadFailed(EXOVERLAPPED* pov);

private:
	R<CBaseRRQueue> m_pLocalQueue;	
	bool m_fSendEnd;
    bool m_fReceiveByLookupId;
    ULONGLONG m_LookupId;
    ULONG m_ulTag;
    ULONG m_hCursor;
    ULONG m_ulAction;
    ULONG m_ulTimeout;
};


//---------------------------------------------------------
//
//  COldRemoteRead - Remote read request, old interface
//
//---------------------------------------------------------
class COldRemoteRead : public CRemoteReadBase
{
public:
    COldRemoteRead( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue,
		bool fRemoteQmSupportsLatest
    	);

    virtual void IssueRemoteRead();

	void IssuePendingRemoteRead();

	virtual void ValidateNetworkInput();

	virtual void MovePacketToPacketPtrs(CBaseHeader* pPacket);

    virtual void FreePacketBuffer()
    {
	    if (m_stRemoteReadDesc.lpBuffer != NULL)
	    {
	        delete[] m_stRemoteReadDesc.lpBuffer;
	        m_stRemoteReadDesc.lpBuffer = NULL;
	    }
	}

	virtual void ValidatePacket(CBaseHeader* pPacket)
	{
		CQmPacket thePacket(pPacket, NULL, true, false);
	}
	
    virtual DWORD GetPacketSize()
    {
		return m_stRemoteReadDesc.dwSize;
    }

    virtual DWORD GetArriveTime()
    {
    	return m_stRemoteReadDesc.dwArriveTime;
    }

    virtual ULONGLONG GetSequentialId()
    {
    	return m_stRemoteReadDesc2.SequentialId;
    }

private:
    void IssueRemoteReadInternal();

	void InitRemoteReadDesc();

	virtual void EndReceive(DWORD dwAck);

private:
	bool m_fRemoteQmSupportsLatest;
	REMOTEREADDESC m_stRemoteReadDesc;
	REMOTEREADDESC2 m_stRemoteReadDesc2;
    PCTX_REMOTEREAD_HANDLE_TYPE m_pRRContext;
};


//---------------------------------------------------------
//
//  CNewRemoteRead - Remote read request, new interface
//
//---------------------------------------------------------
class CNewRemoteRead : public CRemoteReadBase
{
public:
    CNewRemoteRead( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueRemoteRead();

	virtual void ValidateNetworkInput();

	virtual void MovePacketToPacketPtrs(CBaseHeader* pPacket);

    virtual void FreePacketBuffer()
    {
	    if (m_pPacketSections == NULL)
	    	return;

		for(DWORD i = 0; i < m_dwNumberOfSection; i++) 
		{
			delete [] m_pPacketSections[i].pSectionBuffer;
			m_pPacketSections[i].pSectionBuffer = NULL;
		}
		delete [] m_pPacketSections;
		m_pPacketSections = NULL;
		m_dwNumberOfSection = 0;
	}

	virtual void ValidatePacket(CBaseHeader* pPacket)
	{
		CQmPacket thePacket(pPacket, NULL, true);
	}

    virtual DWORD GetPacketSize()
    {
		//
		// Calc Packet size from the sections info
		// 
		DWORD dwPacketSize = 0;
		for(DWORD i = 0; i < m_dwNumberOfSection; i++) 
		{
			dwPacketSize += m_pPacketSections[i].SectionSizeAlloc;
		}
		return dwPacketSize;
    }

    virtual DWORD GetArriveTime()
    {
    	return m_dwArriveTime;
    }

    virtual ULONGLONG GetSequentialId()
    {
    	return m_SequentialId;
    }
    
private:
	virtual void EndReceive(DWORD dwAck);

private:
    DWORD m_dwArriveTime;
    ULONGLONG m_SequentialId;
	ULONG m_MaxBodySize;
	ULONG m_MaxCompoundMessageSize;
    DWORD m_dwNumberOfSection;
    SectionBuffer* m_pPacketSections;
};


//-----------------------------------------------------------------------
//
//  CRemoteEndReceiveBase - Base class for Remote read End Receive request
//
//-----------------------------------------------------------------------
class CRemoteEndReceiveBase : public CRemoteOv
{
public:
    CRemoteEndReceiveBase( 
		handle_t hBind,
		R<CBaseRRQueue>& pLocalQueue,
		DWORD dwAck
    	);

    virtual void IssueEndReceive() = 0;

protected:
	CBaseRRQueue* GetLocalQueue()
	{
		return m_pLocalQueue.get();
	}

	DWORD GetAck()
	{
		return m_dwAck;
	}

	virtual DWORD GetTag() = 0;
	
private:
	static void WINAPI RemoteEndReceiveCompleted(EXOVERLAPPED* pov);

private:
	R<CBaseRRQueue> m_pLocalQueue;	
	DWORD m_dwAck;
};


//-----------------------------------------------------------------------
//
//  COldRemoteEndReceive - Remote read End Receive request, old interface
//
//-----------------------------------------------------------------------
class COldRemoteEndReceive : public CRemoteEndReceiveBase
{
public:
    COldRemoteEndReceive( 
		handle_t hBind,
		R<CBaseRRQueue>& pLocalQueue,
		PCTX_REMOTEREAD_HANDLE_TYPE pRRContext,
		DWORD dwAck
    	);

    virtual void IssueEndReceive();

	virtual DWORD GetTag() 
	{
		return 0;
	}

private:
    PCTX_REMOTEREAD_HANDLE_TYPE m_pRRContext;
};


//-----------------------------------------------------------------------
//
//  CNewRemoteEndReceive - Remote read End Receive request, new interface
//
//-----------------------------------------------------------------------
class CNewRemoteEndReceive : public CRemoteEndReceiveBase
{
public:
    CNewRemoteEndReceive( 
		handle_t hBind,
		R<CBaseRRQueue>& pLocalQueue,
		DWORD dwAck,
		ULONG ulTag
    	);

    virtual void IssueEndReceive();

	virtual DWORD GetTag() 
	{
		return m_ulTag;
	}

private:
	ULONG m_ulTag;	
};


//-----------------------------------------------------------------------
//
//  CRemoteCloseQueueBase - Base class for Remote close queue request
//
//-----------------------------------------------------------------------
class CRemoteCloseQueueBase : public CRemoteOv
{
public:
    CRemoteCloseQueueBase( 
		handle_t hBind
    	);

    virtual void IssueCloseQueue() = 0;

private:
	static void WINAPI RemoteCloseQueueCompleted(EXOVERLAPPED* pov);

private:
	CBindHandle m_hBindToFree;
};


//-----------------------------------------------------------------------
//
//  COldRemoteCloseQueue - Remote close queue request, old interface
//
//-----------------------------------------------------------------------
class COldRemoteCloseQueue : public CRemoteCloseQueueBase
{
public:
    COldRemoteCloseQueue( 
		handle_t hBind,
		PCTX_RRSESSION_HANDLE_TYPE pRRContext
    	);

    virtual void IssueCloseQueue();

private:
	PCTX_RRSESSION_HANDLE_TYPE m_pRRContext;
};


//-----------------------------------------------------------------------
//
//  CNewRemoteCloseQueue - Remote close queue request, new interface
//
//-----------------------------------------------------------------------
class CNewRemoteCloseQueue : public CRemoteCloseQueueBase
{
public:
    CNewRemoteCloseQueue( 
		handle_t hBind,
		RemoteReadContextHandleExclusive pNewRemoteReadContext
    	);

    virtual void IssueCloseQueue();

private:
	RemoteReadContextHandleExclusive m_pNewRemoteReadContext;
};


//-----------------------------------------------------------------------
//
//  CRemoteCreateCursorBase - Base class for Remote create cursor request
//
//-----------------------------------------------------------------------
class CRemoteCreateCursorBase : public CRemoteOv
{
public:
    CRemoteCreateCursorBase( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCreateCursor() = 0;

protected:
	CBaseRRQueue* GetLocalQueue()
	{
		return m_pLocalQueue.get();
	}

	DWORD* GetphRCursor()
	{
		return &m_hRCursor;
	}

	DWORD GetTag()
	{
		return m_ulTag;
	}

	
private:
    HRESULT CompleteRemoteCreateCursor();

	void CancelRequest(HRESULT hr);

	static void WINAPI RemoteCreateCursorSucceeded(EXOVERLAPPED* pov);
	static void WINAPI RemoteCreateCursorFailed(EXOVERLAPPED* pov);

private:
    DWORD m_hRCursor;
    ULONG m_ulTag;
	R<CBaseRRQueue> m_pLocalQueue;
};


//-----------------------------------------------------------------------
//
//  COldRemoteCreateCursor - Remote create cursor request, old interface
//
//-----------------------------------------------------------------------
class COldRemoteCreateCursor : public CRemoteCreateCursorBase
{
public:
    COldRemoteCreateCursor( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCreateCursor();
};


//-----------------------------------------------------------------------
//
//  CNewRemoteCreateCursor - Remote create cursor request, new interface
//
//-----------------------------------------------------------------------
class CNewRemoteCreateCursor : public CRemoteCreateCursorBase
{
public:
    CNewRemoteCreateCursor( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCreateCursor();
};


//-----------------------------------------------------------------------
//
//  CRemoteCloseCursorBase - Base class for Remote close cursor request
//
//-----------------------------------------------------------------------
class CRemoteCloseCursorBase : public CRemoteOv
{
public:
    CRemoteCloseCursorBase( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCloseCursor() = 0;

protected:
	CBaseRRQueue* GetLocalQueue()
	{
		return m_pLocalQueue.get();
	}

	DWORD GetRemoteCursor()
	{
		return m_hRemoteCursor;
	}

	
private:
	static void WINAPI RemoteCloseCursorCompleted(EXOVERLAPPED* pov);

private:
	R<CBaseRRQueue> m_pLocalQueue;
	DWORD m_hRemoteCursor;
};


//-----------------------------------------------------------------------
//
//  COldRemoteCloseCursor - Remote create cursor request, old interface
//
//-----------------------------------------------------------------------
class COldRemoteCloseCursor : public CRemoteCloseCursorBase
{
public:
    COldRemoteCloseCursor( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCloseCursor();
};


//-----------------------------------------------------------------------
//
//  CNewRemoteCloseCursor - Remote create cursor request, new interface
//
//-----------------------------------------------------------------------
class CNewRemoteCloseCursor : public CRemoteCloseCursorBase
{
public:
    CNewRemoteCloseCursor( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueCloseCursor();
};


//-----------------------------------------------------------------------
//
//  CRemotePurgeQueueBase - Base class for Remote purge queue request
//
//-----------------------------------------------------------------------
class CRemotePurgeQueueBase : public CRemoteOv
{
public:
    CRemotePurgeQueueBase( 
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssuePurgeQueue() = 0;

protected:
	CBaseRRQueue* GetLocalQueue()
	{
		return m_pLocalQueue.get();
	}
	
private:
	static void WINAPI RemotePurgeQueueCompleted(EXOVERLAPPED* pov);

private:
	R<CBaseRRQueue> m_pLocalQueue;
};


//-----------------------------------------------------------------------
//
//  COldRemotePurgeQueue - Remote purge queue request, old interface
//
//-----------------------------------------------------------------------
class COldRemotePurgeQueue : public CRemotePurgeQueueBase
{
public:
    COldRemotePurgeQueue( 
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssuePurgeQueue();
};


//-----------------------------------------------------------------------
//
//  COldRemotePurgeQueue - Remote purge queue request, new interface
//
//-----------------------------------------------------------------------
class CNewRemotePurgeQueue : public CRemotePurgeQueueBase
{
public:
    CNewRemotePurgeQueue( 
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssuePurgeQueue();
};


//-----------------------------------------------------------------------
//
//  CRemoteCancelReadBase - Base class for Remote cancel receive request
//
//-----------------------------------------------------------------------
class CRemoteCancelReadBase : public CRemoteOv
{
public:
    CRemoteCancelReadBase( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueRemoteCancelRead() = 0;

protected:
	CBaseRRQueue* GetLocalQueue()
	{
		return m_pLocalQueue.get();
	}

	ULONG GetTag()
	{
		return m_ulTag;
	}
	
private:
	static void WINAPI RemoteCancelReadCompleted(EXOVERLAPPED* pov);

private:
	R<CBaseRRQueue> m_pLocalQueue;
    ULONG m_ulTag;

};


//-----------------------------------------------------------------------
//
//  COldRemoteCancelRead - Remote cancel receive request, old interface
//
//-----------------------------------------------------------------------
class COldRemoteCancelRead : public CRemoteCancelReadBase
{
public:
    COldRemoteCancelRead( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueRemoteCancelRead();
};


//-----------------------------------------------------------------------
//
//  CNewRemoteCancelRead - Remote cancel receive request, new interface
//
//-----------------------------------------------------------------------
class CNewRemoteCancelRead : public CRemoteCancelReadBase
{
public:
    CNewRemoteCancelRead( 
    	const CACRequest* pRequest,
		handle_t hBind,
		CBaseRRQueue* pLocalQueue
    	);

    virtual void IssueRemoteCancelRead();
};

#endif	// _RRCONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\sessmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sessionMgr.cpp

Abstract:

    Implementation of Network session mennager class.

Author:

    Uri Habusha (urih)
--*/


#include "stdh.h"
#include "uniansi.h"
#include <malloc.h>
#include "qmp.h"
#include "sessmgr.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "CDeferredExecutionList.h"
#include "cgroup.h"
#include "admin.h"
#include "qmutil.h"
#include "proxy.h"
#include "ping.h"
#include <Fn.h>
#include "qmta.h"
#include "autohandle.h"
#include <mqstl.h>
#include <No.h>

#include "sessmgr.tmh"

extern CQueueMgr QueueMgr;
extern CQGroup* g_pgroupNonactive;
extern CQGroup* g_pgroupWaiting;

extern CDeferredExecutionList<CQmPacket> g_RequeuePacketList;

extern UINT  g_dwIPPort ;
extern DWORD g_dwThreadsNo ;

static WCHAR *s_FN=L"sessmgr";

//
// Extern variables
//
extern CSessionMgr SessionMgr;
extern CAdmin      Admin;


DWORD CSessionMgr::m_dwSessionCleanTimeout  = MSMQ_DEFAULT_CLIENT_CLEANUP;
DWORD CSessionMgr::m_dwQoSSessionCleanTimeoutMultiplier  = MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER;
DWORD CSessionMgr::m_dwSessionAckTimeout = INFINITE;
DWORD CSessionMgr::m_dwSessionStoreAckTimeout = INFINITE;
DWORD CSessionMgr::m_dwIdleAckDelay = MSMQ_DEFAULT_IDLE_ACK_DELAY;
BOOL  CSessionMgr::m_fUsePing = TRUE;
HANDLE CSessionMgr::m_hAcceptAllowed = NULL;
bool  CSessionMgr::m_fUseQoS = false;
AP<char> CSessionMgr::m_pszMsmqAppName;       // = 0 - initialized by AP<> constructor
AP<char> CSessionMgr::m_pszMsmqPolicyLocator; //                    "
bool  CSessionMgr::m_fAllocateMore = false;
DWORD CSessionMgr::m_DeliveryRetryTimeOutScale = DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE;



BOOL g_fTcpNoDelay = FALSE;

#define MAX_ADDRESS_SIZE 16


struct CWaitingQueue
{
    CWaitingQueue(CQueue* pQueue, CTimer::CALLBACK_ROUTINE pfnCallback);

    CTimer m_Timer;
    CQueue* m_pQueue;
};

inline
CWaitingQueue::CWaitingQueue(
    CQueue* pQueue,
    CTimer::CALLBACK_ROUTINE pfnCallback
    ) :
    m_Timer(pfnCallback),
    m_pQueue(pQueue)
{
}
    
/*====================================================

CompareElements  of WAIT_INFO

Arguments:

Return Value:


=====================================================*/

template<>
BOOL AFXAPI  CompareElements(IN WAIT_INFO* const * pElem1,
                             IN WAIT_INFO* const * pElem2)
{
    const WAIT_INFO* pInfo1 = *pElem1;
    const WAIT_INFO* pInfo2 = *pElem2;

    const TA_ADDRESS* pAddr1 = pInfo1->pAddr;
    const TA_ADDRESS* pAddr2 = pInfo2->pAddr;

    if(pAddr1->AddressType != pAddr2->AddressType)
        return FALSE;

    if(memcmp(pAddr1->Address, pAddr2->Address, pAddr1->AddressLength) != 0)
        return FALSE;

    if (pInfo1->fQoS != pInfo2->fQoS)
        return FALSE;

    if(pInfo1->guidQMId == GUID_NULL)
        return TRUE;

    if(pInfo2->guidQMId == GUID_NULL)
        return TRUE;

    if(pInfo1->guidQMId == pInfo2->guidQMId)
        return TRUE;

    return FALSE;
}

/*====================================================

DestructElements of WAIT_INFO

Arguments:

Return Value:


=====================================================*/

template<>
void AFXAPI DestructElements(IN WAIT_INFO** ppNextHop, int n)
{
    for (int i=0; i<n ; i++)
    {
        delete (*ppNextHop)->pAddr;
        delete *ppNextHop;
        ppNextHop++;
    }
}

/*====================================================

HashKey For WAIT_INFO

Arguments:

Return Value:


=====================================================*/

template<>
UINT AFXAPI HashKey(IN WAIT_INFO* key)
{
    TA_ADDRESS* pAddr = key->pAddr;
    UINT nHash = 0;
    PUCHAR  p = pAddr->Address;

    for (int i = 0; i < pAddr->AddressLength; i++)
        nHash = (nHash<<5) + *p++;

    return nHash;
}

/********************************************************************************/
/*           I P     H E L P E R     R O U T I N E S                            */
/********************************************************************************/
SOCKET g_sockListen;

static DWORD WINAPI AcceptIPThread(PVOID /*pParam*/)
{

    SOCKADDR_IN acc_sin;
    int acc_sin_len = sizeof(acc_sin);

    char buff[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    TA_ADDRESS* pa = (TA_ADDRESS*)&buff[0];

    for(;;)
    {
        try
        {
            CSocketHandle RcvSock = WSAAccept(
										g_sockListen,
										(struct sockaddr FAR *)&acc_sin,
										(int FAR *) &acc_sin_len,
										0,
										0
										);

            ASSERT(RcvSock != NULL);
            if (RcvSock == INVALID_SOCKET)
            {
                DWORD rc = WSAGetLastError();
                TrERROR(NETWORKING, "IP accept failed, error = %d", rc);
                DBG_USED(rc);
                continue;
            }

			TrTRACE(NETWORKING, "Socket accept() successfully and Client IP address is [%hs]\n",
                       inet_ntoa(*((in_addr *)&acc_sin.sin_addr.S_un.S_addr)));


            if (CSessionMgr::m_fUseQoS)
            {
                QOS  Qos;
                memset ( &Qos, QOS_NOT_SPECIFIED, sizeof(QOS) );

                //
                // ps buf is not required
                //
                Qos.ProviderSpecific.len = 0;
                Qos.ProviderSpecific.buf = NULL;

                //
                // sending flowspec
                //
                Qos.SendingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

                //
                // receiving flowspec
                //
                Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

                DWORD  dwBytesRet ;

                int rc = WSAIoctl( RcvSock,
                                   SIO_SET_QOS,
                                  &Qos,
                                   sizeof(QOS),
                                   NULL,
                                   0,
                                  &dwBytesRet,
                                   NULL,
                                   NULL ) ;
                if (rc != 0)
                {
                    DWORD dwErrorCode = WSAGetLastError();
                    TrWARNING(NETWORKING, "AcceptIPThread - WSAIoctl() failed, Error %d", dwErrorCode);
                    LogNTStatus(dwErrorCode,  s_FN, 110);

                    //
                    // Continue anyway...
                    //
                }
            }

            //
            // If the machine is in disconnected state, don't accept the incoming
            // connection.
            //
			ASSERT(("m_hAcceptAllowed should initialize before use", CSessionMgr::m_hAcceptAllowed != NULL));
            DWORD dwResult = WaitForSingleObject(CSessionMgr::m_hAcceptAllowed, INFINITE);
            if (dwResult != WAIT_OBJECT_0)
            {
                LogNTStatus(GetLastError(), s_FN, 201);
            }

            //
            // Build a TA format address
            //
            pa->AddressLength = IP_ADDRESS_LEN;
            pa->AddressType =  IP_ADDRESS_TYPE;
            * ((DWORD *)&(pa->Address)) = acc_sin.sin_addr.S_un.S_addr;

            //
            // Tell the session manager to create an Sock sesion object
            //
            SessionMgr.AcceptSockSession(pa, RcvSock);
        }
        catch(const exception&)
        {
            //
            //  No resources; accept next
            //
            LogIllegalPoint(s_FN, 76);
        }
    }
}

/*====================================================

CSessionMgr::CSessionMgr  - Constructor

Arguments:

Return Value:

=====================================================*/
CSessionMgr::CSessionMgr() :
    m_fCleanupTimerScheduled(FALSE),
    m_CleanupTimer(TimeToSessionCleanup),
    m_fUpdateWinSizeTimerScheduled(FALSE),
    m_wCurrentWinSize(MSMQ_DEFAULT_WINDOW_SIZE_PACKET),
    m_wMaxWinSize(MSMQ_DEFAULT_WINDOW_SIZE_PACKET),
    m_UpdateWinSizeTimer(TimeToUpdateWindowSize),
    m_fTryConnectTimerScheduled(FALSE),
    m_TryConnectTimer(TimeToTryConnect)
{
}


/*====================================================

CSessionMgr::Init

Arguments:

Return Value:

Thread Context: Main

=====================================================*/

HRESULT CSessionMgr::Init()
{
    m_hAcceptAllowed = CreateEvent(NULL, TRUE, TRUE, NULL);
	if (m_hAcceptAllowed == NULL)
	{
		TrERROR(NETWORKING, "Failed to create event for Session Manager uses. %!winerr!", GetLastError());
		throw bad_alloc();
	}

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD dwDefaultVal;
    HRESULT rc;
    //
    // Set Session clean-up timeout
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    if (!IsRoutingServer())   //[adsrv] CQueueMgr::GetMQS() == SERVICE_NONE)
    {
        //
        // In Client the default Release session timeout is 5 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_CLIENT_CLEANUP;
    }
    else
    {
        //
        // In FRS the default Release session timeout is 2 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_SERVER_CLEANUP;
    }

    rc = GetFalconKeyValue(
            MSMQ_CLEANUP_INTERVAL_REGNAME,
            &dwType,
            &m_dwSessionCleanTimeout,
            &dwSize,
            (LPCTSTR)&dwDefaultVal
            );

    if (rc != ERROR_SUCCESS)
    {
        m_dwSessionCleanTimeout = dwDefaultVal;
    }

    //
    // Get Cleanup interval multiplier for QoS sessions
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    rc = GetFalconKeyValue(MSMQ_QOS_CLEANUP_INTERVAL_MULTIPLIER_REGNAME,
                           &dwType,
                           &m_dwQoSSessionCleanTimeoutMultiplier,
                           &dwSize
                          );

    if (rc != ERROR_SUCCESS)
    {
        m_dwQoSSessionCleanTimeoutMultiplier = MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER;
    }

    //
    // Get Max Unacked packet number
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwWindowSize;

    rc = GetFalconKeyValue(MSMQ_MAX_WINDOW_SIZE_REGNAME,
                           &dwType,
                           &dwWindowSize,
                           &dwSize
                          );

    if (rc != ERROR_SUCCESS)
    {
        m_wMaxWinSize = MSMQ_DEFAULT_WINDOW_SIZE_PACKET;
    }
    else
    {
        m_wMaxWinSize = (WORD) dwWindowSize;
    }

    m_wCurrentWinSize = m_wMaxWinSize;

    //
    // Get session Storage ack timeout
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_ACKTIMEOUT_REGNAME,
                           &dwType,
                           &m_dwSessionAckTimeout,
                           &dwSize
                          );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwSessionAckTimeout = INFINITE;
    }


    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_STORE_ACKTIMEOUT_REGNAME,
                           &dwType,
                           &m_dwSessionStoreAckTimeout,
                           &dwSize
                          );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwSessionStoreAckTimeout = INFINITE;
    }


    //
    // Get session Maximum acknowledge delay
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_IDLE_ACK_DELAY_REGNAME,
                           &dwType,
                           &m_dwIdleAckDelay,
                           &dwSize
                          );

    //
    // Get Max wait time
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    rc = GetFalconKeyValue(FALCON_WAIT_TIMEOUT_REGNAME,
                           &dwType,
                           &m_dwMaxWaitTime,
                           &dwSize
                           );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwMaxWaitTime = 0;
    }

    //
    // use ping mechanism
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwUsePing;

    rc = GetFalconKeyValue(FALCON_USING_PING_REGNAME,
                           &dwType,
                           &dwUsePing,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwUsePing != 0))
    {
        m_fUsePing = TRUE;
    }
    else
    {
        m_fUsePing = FALSE;
    }

    //
    // Use TCP_NODELAY socket option flag
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwNoDelay = 0;

    rc = GetFalconKeyValue(
            MSMQ_TCP_NODELAY_REGNAME,
            &dwType,
            &dwNoDelay,
            &dwSize
            );

    if((rc == ERROR_SUCCESS) && (dwNoDelay != 0))
    {
        g_fTcpNoDelay = TRUE;
    }
    else
    {
        g_fTcpNoDelay = FALSE;
    }

    //
    // use Quality Of Service (QoS)
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwUseQoS;

    rc = GetFalconKeyValue(MSMQ_USING_QOS_REGNAME,
                           &dwType,
                           &dwUseQoS,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwUseQoS == 0))
    {
        m_fUseQoS = false;
    }
    else
    {
        m_fUseQoS = true;
    }

    if (m_fUseQoS)
    {
        //
        // Application name and policy locator name - used for the header of a QoS session
        //
        GetAndAllocateCharKeyValue(
            MSMQ_QOS_SESSIONAPP_REGNAME,
            &m_pszMsmqAppName,
            DEFAULT_MSMQ_QOS_SESSION_APP_NAME
            );

        GetAndAllocateCharKeyValue(
            MSMQ_QOS_POLICYLOCATOR_REGNAME,
            &m_pszMsmqPolicyLocator,
            DEFAULT_MSMQ_QOS_POLICY_LOCATOR
            );
    }

    //
    // Allocate More (for connector)
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwAllocateMore;

    rc = GetFalconKeyValue(MSMQ_ALLOCATE_MORE_REGNAME,
                           &dwType,
                           &dwAllocateMore,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwAllocateMore == 0))
    {
        m_fAllocateMore = false;
    }
    else
    {
        m_fAllocateMore = true;
    }

	//
	// Read from registry flag that scales the retry timeout  on delivery error
	// by a factor
	//
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
	rc = GetFalconKeyValue(
					MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE_REGNAME,
					&dwType,
                    &m_DeliveryRetryTimeOutScale,
                    &dwSize
					);

	if(rc != ERROR_SUCCESS)
	{
		m_DeliveryRetryTimeOutScale = DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE;		
	}
	m_DeliveryRetryTimeOutScale = min(m_DeliveryRetryTimeOutScale, 10);
	

    return(MQ_OK);
}

/*====================================================

CSessionMgr::GetAndAllocateCharKeyValue
Utility private function (used by Init()) to get a char
value out of the MSMQ registry
Two versions: With default and without default.
=====================================================*/
void  CSessionMgr::GetAndAllocateCharKeyValue(
        LPCTSTR pszValueName,
        char  **ppchResult,
        const char *pchDefault
        )
{
    if (GetAndAllocateCharKeyValue(pszValueName, ppchResult))
    {
        return;
    }

    //
    // Either there is no reg. key, or some error happend during read.
    // Get the default.
    //
    *ppchResult = new char[strlen(pchDefault) + 1];
    strcpy(*ppchResult, pchDefault);
}

//
// GetAndAllocateCharKeyValue without default (used by the version with default)
// Returns true if the key was found, false otherwise.
//
bool CSessionMgr::GetAndAllocateCharKeyValue(
        LPCTSTR pszValueName,
        char  **ppchResult
        )
{
    DWORD dwSize = 0;
    DWORD dwType = REG_SZ;

    //
    // First call - get the size
    //
    HRESULT rc =
        GetFalconKeyValue(
            pszValueName,
            &dwType,
            0,
            &dwSize
            );

    if (rc != ERROR_SUCCESS)
    {
        //
        // Probably there is no key
        //
        return false;
    }

    //
    // There is a reg key - we did not supply buffer, but we have the
    // right size (note - size is in bytes)
    //

    AP<WCHAR> pwstrBuf = new WCHAR[dwSize / sizeof(WCHAR)];
    rc = GetFalconKeyValue(
            pszValueName,
            &dwType,
            pwstrBuf,
            &dwSize
            );

    if (rc != ERROR_SUCCESS)
    {
        //
        // We got the size allright. We should not fail here
        //
        ASSERT(0);
        LogHR(MQ_ERROR, s_FN, 150);
        return false;
    }

    //
    // We got the UNICODE value OK. Convert it to ANSI
    //
    DWORD dwMultibyteBufferSize = dwSize;
    *ppchResult = new char[dwMultibyteBufferSize];
    DWORD dwBytesCopied =
        ConvertToMultiByteString(pwstrBuf, *ppchResult, dwMultibyteBufferSize);

    if (dwBytesCopied == 0)
    {
        ASSERT(0); // Should not fail....
        delete [] *ppchResult;
        LogHR(MQ_ERROR, s_FN, 155);

        return false;
    }

    //
    // Success - got the value from the registry
    //
    return true;
}






/*====================================================

CSessionMgr::BeginAccept

Arguments:

Return Value:

Thread Context: Main

=====================================================*/
void CSessionMgr::BeginAccept()
{
	try
	{
		StartPingServer();
		StartPingClient();
	}
	catch(const bad_win32_error&)
	{
		//
		// Ignore failures in ping port initialization
		//
	}

	
    //
    // In WIN95/SP4 RAS, it is possible that the list is empty
    // if we are currently offline, and the IP RAS addresses are released.
    // However later we may dial.
    // We want to have an accept thread on IP even if the list is empty.
    //
    IPInit();
}


bool
CSessionMgr::IsReusedSession(
    const CTransportBase* pSession,
    DWORD noOfAddress,
    const CAddress* pAddress,
    const GUID** pGuid,
    bool         fQoS
    )
{
    //
    // If the connection is closed
    //
    if((pSession->GetSessionStatus() == ssNotConnect) || pSession->IsDisconnected())
        return false;

    const TA_ADDRESS* pa = pSession->GetSessionAddress();

    for(DWORD i = 0; i < noOfAddress; ++i)
    {
        if (memcmp(&pAddress[i], pa, (TA_ADDRESS_SIZE + pa->AddressLength)) != 0)
            continue;

        //
        // Check that destination QM guid is identical
        //

        //
        // If we do not use QoS, We would like to use the session if either:
        // 1. We opened a session to a private or public queue, and the other QM's
        //    GUID match the GUID of the QM, on which the queue resides (This check
        //    will catch multiple QM and change of address).
        // 2. We opened a session for a direct queue (we don't know the QMID
        //    anyway, so address match is good enough for us).
        //
        // However, if we use QoS, we want to use one session for public or
        // private queues (no QoS), and one session for direct queues (with QoS).
        //

        if (m_fUseQoS)
        {
            if (!fQoS && !pSession->IsQoS())
            {
                ASSERT(*pGuid[i] != GUID_NULL);

                if (*pSession->GetQMId() == *pGuid[i])
                    return true;

                continue;
            }

            if (fQoS && pSession->IsQoS())
            {
                ASSERT(*pGuid[i] == GUID_NULL);

                return true;
            }

            continue;
        }

        //
        // !m_fUseQoS
        //
        ASSERT(!fQoS);
        if (*pSession->GetQMId() == *pGuid[i])
            return true;

        if(*pGuid[i] == GUID_NULL)
            return true;
    }

    return false;
}


/*====================================================

CSessionMgr::GetSessionForDirectQueue

Arguments:

Return Value:

Thread Context:

=====================================================*/
HRESULT
CSessionMgr::GetSessionForDirectQueue(IN  CQueue*     pQueue,
                                      OUT CTransportBase**  ppSession)
{
    HRESULT rc;

    DirectQueueType dqt;
    AP<WCHAR> MachineName;

    try
    {
        LPCWSTR lpwsDirectQueuePath = FnParseDirectQueueType(pQueue->GetQueueName(), &dqt);
        FnExtractMachineNameFromPathName(
            lpwsDirectQueuePath,
            MachineName
            );
    }
    catch(const exception&)
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 10);
    }

    DWORD dwMachineNameLen = wcslen(MachineName.get()) + 1;

    SP<CAddress> apTaAddr;
    DWORD dwAddressNo = 0;

    TrTRACE(NETWORKING, "Try to create direct connection with %ls", MachineName.get());

    switch (dqt)
    {
        case dtTCP:
        {
            SP<char> cTCPAddress;
            StackAllocSP(cTCPAddress, sizeof(char) * dwMachineNameLen);

            wcstombs(cTCPAddress.get(), MachineName.get(), dwMachineNameLen);
            cTCPAddress[dwMachineNameLen-1] = '\0';

            //
            // Check if TCP/IP is installed and enabled
            //
            ULONG Address = inet_addr(cTCPAddress.get());
            if (Address == INADDR_NONE)
            {
                return LogHR(MQ_ERROR, s_FN, 30);
            }


            StackAllocSP(apTaAddr, sizeof(CAddress));
            apTaAddr[0].AddressType = IP_ADDRESS_TYPE;
            apTaAddr[0].AddressLength = IP_ADDRESS_LEN;
            *reinterpret_cast<ULONG*>(&(apTaAddr[0].Address)) = Address;

            dwAddressNo++;

            break;
        }

        case dtOS:
        {
            bool fUseCache = (pQueue->GetRoutingRetry() % 16) != 15;
            std::vector<SOCKADDR_IN> Addresses;
			bool fSucc = NoGetHostByName(MachineName, &Addresses, fUseCache);
			if(!fSucc)
			{
				TrERROR(NETWORKING, "Failed to get host by name for %ls.", MachineName);
				return MQ_ERROR;
			}
			size_t nAddresses = Addresses.size();

            if(nAddresses == 0)
                return LogHR(MQ_ERROR, s_FN, 40);

            StackAllocSP(apTaAddr, sizeof(CAddress) * nAddresses);

			for (DWORD i = 0; i < nAddresses; ++i)
			{
				apTaAddr[i].AddressType = IP_ADDRESS_TYPE;
				apTaAddr[i].AddressLength = IP_ADDRESS_LEN;
				*(reinterpret_cast<ULONG*>(&(apTaAddr[i].Address))) = Addresses[i].sin_addr.s_addr;
				dwAddressNo++;
			}

            break;
        }

        default:
            return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 50);
    }

    SP<const GUID*> paQmId;
    StackAllocSP(paQmId, sizeof(GUID*) * dwAddressNo);

    for (DWORD i=0; i < dwAddressNo; i++)
    {
        paQmId[i] = &GUID_NULL;
    }

    //
    // Get session. If we use QoS, we ask for a session with QoS
    // flag set for direct queue
    //
    rc = GetSession(SESSION_RETRY,
                    pQueue,
                    dwAddressNo,
                    apTaAddr.get(),
                    paQmId.get(),
                    m_fUseQoS,
                    ppSession
                    );

    return LogHR(rc, s_FN, 70);
}


/*====================================================

CSessionMgr::GetSession

Arguments:

Return Value:

Called by the routing component to get a session
pointer for  a specific GUID.

=====================================================*/
HRESULT  CSessionMgr::GetSession(
                IN DWORD            dwFlag,
                IN const CQueue*    pDstQ,
                IN DWORD            dwNo,
                IN const CAddress*  apTaAddr,
                IN const GUID*      apQMId[],
                IN bool             fQoS,
                OUT CTransportBase** ppSession)
{
    DWORD            i;
    POSITION         pos;
    HRESULT          rc;

    *ppSession = NULL;

    {
        //
        //Scan the list to see if there is already a opened session
        //Dont have to make it under critical section, because no other
        //thread is supposed to change that list
        //Scan the map of queue handles
        // We use all addresses, it's a fast operation, not blocking, can save sessions
        //
        CTransportBase* pSess;

        CS lock(m_csListSess);

        pos = m_listSess.GetHeadPosition();
        while(pos != NULL)
        {
            pSess = m_listSess.GetNext(pos);
            if(IsReusedSession(pSess, dwNo, apTaAddr, apQMId, fQoS))
            {
                *ppSession = pSess;
                return(MQ_OK);
            }
        }
    }

    if(dwFlag == SESSION_CHECK_EXIST)
    {
        //
        // We just wanted to see
        // if we had such a session, and we
        // did not find such.
        //
        return LogHR(MQ_ERROR, s_FN, 80);
    }

    //
    //  No Open sessions, so try to open one. First check if this machine
    // can create a new session according to its license
    //

    //
    // This is a blocking path. Do not try on too many addresses if all fail
    // This is important for example if trying to connect to a site with many
    // FRSs when line is down
    // In case that we fail, we will try later with all the list
    //
    #define MAX_ADDRESSES_SINGLE_TRY    5
    DWORD dwLimit = (dwNo > MAX_ADDRESSES_SINGLE_TRY) ? MAX_ADDRESSES_SINGLE_TRY : dwNo;
    for(i = 0; i < dwLimit; i++)
    {

        P<CTransportBase> pSess;

        switch (apTaAddr[i].AddressType)
        {
            case IP_ADDRESS_TYPE:
                pSess = (CTransportBase *)new CSockTransport();
                break;

            case FOREIGN_ADDRESS_TYPE:
                pSess = (CTransportBase *)new CProxyTransport();
                break;

            default:
                ASSERT(0);
                continue;
        }

        //
        // Notify of a newly created session
        //
        rc = pSess->CreateConnection(reinterpret_cast<const TA_ADDRESS*>(&apTaAddr[i]), apQMId[i]);
        if(SUCCEEDED(rc))
        {
            NewSession(pSess);
            *ppSession = pSess.detach();
            return(MQ_OK);
        }

    }

    //
    //What to do next? We cant find a session, we cant create
    //a new one. The flag will tell us if to retry or to give up
    //
    if(dwFlag == SESSION_ONE_TRY)
    {
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    ASSERT(dwFlag == SESSION_RETRY);

    //
    // use all addresses, it is not blocking
    //
    AddWaitingSessions(dwNo, apTaAddr, apQMId, fQoS, const_cast<CQueue*>(pDstQ));

    return(MQ_OK);
}

//+---------------------------------------------------------------------
//
// CSessionMgr::NotifyWaitingQueue()
//
//  This function is called from the session object, after session is
//  successfully established with remote side.
//
//+----------------------------------------------------------------------

void
CSessionMgr::NotifyWaitingQueue(
    IN const TA_ADDRESS* pa,
    IN CTransportBase * pSess
    )
    throw()
{
	try
	{
		//
		// In case we have deferred requeues, we do not want to move a queue
		// from the waiting group directly to the session. we want it to move
		// to the non active group first so that to make sure that all the
		// requeue operations are done prior to the queue moving to the active
		// session.
		//
		if (!g_RequeuePacketList.IsExecutionDone())
			return;
		
	    //
	    // Connect succeeded
	    //
	    CS lock(m_csMapWaiting);

	    CList <const CQueue *, const CQueue *&>* plist;
	    WAIT_INFO WaitInfo(const_cast<TA_ADDRESS*>(pa), *pSess->GetQMId(), pSess->IsQoS());

	    //
	    // Connect succeeded, check that no one remove the entry from the map
	    //
	    if (m_mapWaiting.Lookup(&WaitInfo, plist))
	    {
	        //
	        // A queue might be waiting for multiple
	        // sessions. So delete the queue from all other
	        // sessions that the queue was waiting for.
	        //
	        POSITION pos = plist->GetHeadPosition();
	        while (pos != NULL)
	        {
	        	CQueue* pQueue = const_cast<CQueue*>(plist->GetNext(pos));
	        	
	            if (pQueue->IsOnHold())
			    {
			    	CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
			    	plist->GetNext(pos);
			    	continue;
			    }

	            pQueue->Connect(pSess);
	
	            //
	            // Scan the map of all the waiting sessions
	            //
	            RemoveWaitingQueue(pQueue);
	        }
	    }
	}
	catch(const exception&)
	{
		//
		// The QM failed to connect the queue to the session. However the code handle
		// it later. When the timer is expired, the queue will be moved to non-active
		// group for creating a connection
		//
	}
}


DWORD CSessionMgr::GetWaitingTimeForQueue(const CQueue* pQueue)
{
	static DWORD RequeueWaitTimeOut[] = {
         4 * 1000,
         8 * 1000,
         12 * 1000,
         16 * 1000,
         24  * 1000,
		 32 * 1000,
		 42 * 1000,
		 54 * 1000,
		 64 * 1000
    };
	const int  MaxTimeOutIndex = TABLE_SIZE(RequeueWaitTimeOut);

    ASSERT(pQueue->GetRoutingRetry() > 0);

    if (m_dwMaxWaitTime == 0)
    {
        if (pQueue->GetRoutingRetry() > MaxTimeOutIndex)
        {
            return RequeueWaitTimeOut[MaxTimeOutIndex -1];
        }

        return RequeueWaitTimeOut[pQueue->GetRoutingRetry() -1];
    }

    //
    // take the waiting time from the registery
    //
    return m_dwMaxWaitTime;
}


/*======================================================

Function:      CSessionMgr::AddWaitingQueue

Description:   add queue to waiting queue list

========================================================*/
void
CSessionMgr::AddWaitingQueue(CQueue* pQueue)
{
    CS lock(m_csMapWaiting);

    //
    // Increment the refernce count. We do it to promise that the queue object doen't remove
    // during the cleaning-up, while we continue to wait for conection. (can happen when the
    // message is expired and the application close the handle to it
    //
    R<CQueue> pRefQueue = SafeAddRef(pQueue);

	P<CWaitingQueue> p = new CWaitingQueue(pQueue, TimeToRemoveFromWaitingGroup);

	m_listWaitToConnect.AddTail(pQueue);

	try
	{
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupWaiting);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to move queue: %ls to waiting group", pQueue->GetQueueName());
		m_listWaitToConnect.RemoveTail();
		throw;
	}
	
	//
	// Schedule a retry sometimes in the near future
	//
	DWORD dwTime = GetWaitingTimeForQueue(pQueue);
	ExSetTimer(&p->m_Timer, CTimeDuration::FromMilliSeconds(dwTime * m_DeliveryRetryTimeOutScale));

	pRefQueue.detach();
	p.detach();

	#ifdef _DEBUG
    	AP<WCHAR> lpcsQueueName;

    	pQueue->GetQueue(&lpcsQueueName);
    	TrTRACE(NETWORKING, "Add queue: %ls to m_listWaitToConnect (AddWaitingQueue)", lpcsQueueName);
	#endif
}

/*======================================================

Function:      CQueueMgr::MoveQueueFromWaitingToNonActiveGroup

Description:   Move queue from waiting to Nonactive Group

Arguments:

Return Value:  None

Thread Context:

History Change:

========================================================*/
void
CSessionMgr::MoveQueueFromWaitingToNonActiveGroup(
    CQueue* pQueue
    )
{
    POSITION poslist;

    CS lock(m_csMapWaiting);

    if (m_listWaitToConnect.IsEmpty() ||
        ((poslist = m_listWaitToConnect.Find(pQueue, NULL)) == NULL))
    {
        return;
    }
    //
    // Move the queue to NON-active group
    //
    CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
   	RemoveWaitingQueue(pQueue);
    //
    // The queue is removed from the list in SessionMgr.RemoveWaitingQueue
    //
}


void CSessionMgr::MoveAllQueuesFromWaitingToNonActiveGroup(void)
{
    CS lock(m_csMapWaiting);

    POSITION pos = m_listWaitToConnect.GetHeadPosition();
    while (pos)
    {
        CQueue* pQueue = const_cast<CQueue*>(m_listWaitToConnect.GetNext(pos));

		//
		// Move the queue to NON-active group
		//
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
		RemoveWaitingQueue(pQueue);
		//
		// The queue is removed from the list in SessionMgr.RemoveWaitingQueue
		//
    }
}


void
WINAPI
CSessionMgr::TimeToRemoveFromWaitingGroup(
    CTimer* pTimer
    )
{
       P<CWaitingQueue> p = CONTAINING_RECORD(pTimer, CWaitingQueue, m_Timer);

	bool fRemoved = p->m_pQueue->TimeToRemoveFromWaitingGroup(pTimer, m_DeliveryRetryTimeOutScale);
	if(!fRemoved)
	{
		p.detach();
	}
}


static BOOL IsDuplicateAddress(const CAddress* apTaAddr, DWORD i)
{
    for (DWORD j = 0; j < i; j++)
    {
        if ((apTaAddr[i].AddressType == apTaAddr[j].AddressType) &&
            !(memcmp(apTaAddr[i].Address, apTaAddr[j].Address, apTaAddr[i].AddressLength)))
        {
            //
            // Identical address skip it.
            //
            return TRUE;
        }
    }

    return FALSE;
}

/*====================================================

CSessionMgr::AddWaitingSessions

Arguments:

Return Value:

=====================================================*/
void CSessionMgr::AddWaitingSessions(IN DWORD dwNo,
                                     IN const CAddress* apTaAddr,
                                     IN const GUID* aQMId[],
                                     IN bool        fQoS,
                                     IN CQueue *pDstQ)
{
    CS lock(m_csMapWaiting);

    for(DWORD i = 0; i < dwNo; i++)
    {
        if(IsDuplicateAddress(apTaAddr, i))
            continue;


        CList<const CQueue*, const CQueue*&>* plist;
        TA_ADDRESS *pa = reinterpret_cast<TA_ADDRESS*>(const_cast<CAddress*>(&apTaAddr[i]));
        P<WAIT_INFO> pWaitRouteInfo = new WAIT_INFO(pa, *aQMId[i], fQoS);
        if(m_mapWaiting.Lookup(pWaitRouteInfo, plist) == FALSE)
        {
            //
            // copy the TA address, only if the entry was not found (performance)
            //
            pWaitRouteInfo->pAddr = (TA_ADDRESS*) new UCHAR[TA_ADDRESS_SIZE + pa->AddressLength];
            memcpy(pWaitRouteInfo->pAddr, pa, TA_ADDRESS_SIZE+pa->AddressLength);

            plist = new CList<const CQueue*, const CQueue*&>;
            m_mapWaiting[pWaitRouteInfo] = plist;

            pWaitRouteInfo.detach();
        }

        TCHAR szAddr[30];
        TA2StringAddr(pa, szAddr, 30);
        TrTRACE(NETWORKING, "Add queue %ls to Waiting map for address %ls", pDstQ->GetQueueName(), szAddr);

        plist->AddTail(pDstQ);
    }

    SessionMgr.AddWaitingQueue(pDstQ);

    if (! m_fTryConnectTimerScheduled)
    {
        //
        // The try connect scheduler wasn't set yet. Set it now
        //
        ExSetTimer(&m_TryConnectTimer, CTimeDuration::FromMilliSeconds(5000));
        m_fTryConnectTimerScheduled = TRUE;
    }
}

/*====================================================

CSessionMgr::ReleaseSession

Arguments:

Return Value:

Some queue wants to release the use of a session.

Thread Context:

=====================================================*/
inline void CSessionMgr::ReleaseSession(void)
{
    POSITION pos,  prevpos;
    CTransportBase* pSession;

    CS lock(m_csListSess);

    static DWORD dwReleaseSessionCounter = 0;
    dwReleaseSessionCounter++;

    ASSERT(m_fCleanupTimerScheduled);

    pos = m_listSess.GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pSession = m_listSess.GetNext(pos);

        //
        // For QoS (direct) sessions, execute cleanup only once each
        // m_dwQoSSessionCleanTimeoutMultiplier times
        //

        if (m_fUseQoS && pSession->IsQoS())
        {
            if ((dwReleaseSessionCounter % m_dwQoSSessionCleanTimeoutMultiplier) != 0)
            {
                continue;
            }
        }

        if(! pSession->IsUsedSession())
        {
            //
            // If no one is waiting on the session or it is
            // not used in last period, remove it from
            // the session manager and delete it
            //
            Close_ConnectionNoError(pSession, L"Release Unused session");
            if (pSession->GetRef() == 0)
            {
                m_listSess.RemoveAt(prevpos);
                delete pSession;
            }
        }
        else
        {
            pSession->SetUsedFlag(FALSE);
        }

    }

    if (m_listSess.IsEmpty())
    {
        m_fCleanupTimerScheduled = FALSE;
        return;
    }

    //
    // Still active session. Set a new timer for Session cleaning
    //
    ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_dwSessionCleanTimeout));
}


void
WINAPI
CSessionMgr::TimeToSessionCleanup(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when fast session cleanup
    timeout is expired. The routine retrive the session manager
    object and calls the ReleaseSession function member.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the CSessionMgr
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_CleanupTimer);

    TrTRACE(NETWORKING, "Call Session Cleanup");
    pSessMgr->ReleaseSession();
}


/*====================================================

CSessionMgr::RemoveWaitingQueue

Arguments:

Return Value:

  remove queue from waiting list. It should be done in following cases:
     - when a connection is established
     - when a queue is closed/deleted
     - when queue is moved from waiting group to nonactive group.

=====================================================*/
void
CSessionMgr::RemoveWaitingQueue(CQueue* pQueue)
{
    CS lock(m_csMapWaiting);

    //
    // Scan the map of all the waiting sessions
    //
    POSITION posmap;
    POSITION poslist;
    posmap = m_mapWaiting.GetStartPosition();
    while(posmap != NULL)
    {
        WAIT_INFO* pWaitRouteInfo;
        CList <const CQueue *, const CQueue *&>* plist;

        m_mapWaiting.GetNextAssoc(posmap, pWaitRouteInfo, plist);

        //
        // Get the list of queue waiting for
        // a specific session
        //
        poslist = plist->Find(pQueue, NULL);
        if (poslist != NULL)
        {
            plist->RemoveAt(poslist);
        }

        //
        // Even if the list of queues  waiting for session is empty,
        // do not delete it, and leave the entry in the map. This is
        // in order to fix Windows bug 612988.
        // Before fix, we had the following code:
        //
        // if (plist->IsEmpty())
        // {
        //     m_mapWaiting.RemoveKey(pWaitRouteInfo);
        //     delete plist;
        // }
        //
        // Code moved to ::TryConnect() below.
    }

    //
    // Remove the queue from waiting queue list.
    //
    poslist = m_listWaitToConnect.Find(pQueue, NULL);
    if (poslist != NULL)
    {
 #ifdef _DEBUG
        AP<WCHAR> lpcsQueueName;

        pQueue->GetQueue(&lpcsQueueName);
        TrTRACE(NETWORKING, "Remove queue: %ls from m_listWaitToConnect (RemoveWaitingQueue)", lpcsQueueName.get());
#endif
        m_listWaitToConnect.RemoveAt(poslist);
        pQueue->Release();
    }
}


/*====================================================

CSessionMgr::ListPossibleNextHops
    The routine is used for administration purpose. The routine returnes a
    list of addresses that can be the next hop for a waiting queue

Arguments:
    pQueue - pointer to the queue object
    pNextHopAddress - pointer to array of strings in which the routine
                      returnes the next hops.
    pNoOfNextHops - pointer to DWORD in which the routine returnes the
                    number of next hops

Return Value:
    HRESULT: MQ_ERROR is returned when the queue isn't in waiting state; MQ_OK otherwise.

=====================================================*/
HRESULT
CSessionMgr::ListPossibleNextHops(
    const CQueue* pQueue,
    LPWSTR** pNextHopAddress,
    DWORD* pNoOfNextHops
    )
{
    *pNoOfNextHops = 0;
    *pNextHopAddress = NULL;

    CS lock(m_csMapWaiting);

    if (m_listWaitToConnect.IsEmpty() ||
         ((m_listWaitToConnect.Find(pQueue, NULL)) == NULL))
    {
        return LogHR(MQ_ERROR, s_FN, 100);
    }


    CList <const TA_ADDRESS*, const TA_ADDRESS*> NextHopAddressList;

    //
    // Scan the map of all the waiting sessions
    //
    POSITION pos = m_mapWaiting.GetStartPosition();
    while(pos != NULL)
    {
        WAIT_INFO* pWaitRouteInfo;
        CList <const CQueue *, const CQueue *&>* plist;
        m_mapWaiting.GetNextAssoc(pos, pWaitRouteInfo, plist);

        //
        // Get the list of queue waiting for
        // a specific session
        //
        POSITION poslist = plist->Find(pQueue, NULL);
        if (poslist != NULL)
        {
            NextHopAddressList.AddTail(pWaitRouteInfo->pAddr);
        }
    }

    //
    // In some cases the queue can be in waiting state and don't have
    // next waiting hop. It can happened when the queue is a direct queue
    // and getHostByName failed
    //
    if (NextHopAddressList.IsEmpty())
    {
        return MQ_OK;
    }

    int Index = 0;
    AP<LPWSTR> pNext = new LPWSTR[NextHopAddressList.GetCount()];

    try
    {
        pos = NextHopAddressList.GetHeadPosition();
        while(pos != NULL)
        {
            const TA_ADDRESS* pAddr = NextHopAddressList.GetNext(pos);

            pNext[Index] = GetReadableNextHop(pAddr);
            ++Index;
        }
    }
    catch(const bad_alloc&)
    {
        while(Index)
        {
            delete [] pNext[--Index];
        }

        LogIllegalPoint(s_FN, 79);
        throw;
    }

    ASSERT(Index == NextHopAddressList.GetCount());

    *pNoOfNextHops = NextHopAddressList.GetCount();
    *pNextHopAddress = pNext.detach();

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  CSessionMgr::MarkAddressAsNotConnecting()
//
//  Windows bug 61298.
//  this function reset the "fInConnectionProcess" flag to FALSE.
//
//+-----------------------------------------------------------------------

void  CSessionMgr::MarkAddressAsNotConnecting(const TA_ADDRESS *pAddr,
                                              const GUID&       guidQMId,
                                              BOOL              fQoS )
{
    CS lock(m_csMapWaiting);

    CList <const CQueue *, const CQueue *&>* plist;
    WAIT_INFO WaitInfo(const_cast<TA_ADDRESS*> (pAddr), guidQMId, fQoS) ;

    if (m_mapWaiting.Lookup(&WaitInfo, plist))
    {
        POSITION pos = m_mapWaiting.GetStartPosition();

        while(pos != NULL)
        {
            WAIT_INFO *pWaitInfo ;
            CList<const CQueue*, const CQueue*&>* plistTmp ;

            m_mapWaiting.GetNextAssoc(pos, pWaitInfo, plistTmp);

            if (plistTmp == plist)
            {
                //
                // entry found. reset the flag.
                // Can it already be false ? yes:
                //
                // 1. You send a message. It reach target computer.
                // 2. network fail, so session ack does not arrive.
                // 3. CSockTransport::CheckForAck() wake up, and close the
                //    connection.
                // 4. CSockTransport::CloseConnection() move queue to the
                //    nonactive group. The reference count on the Transport
                //    object is 3 or greater. So it's still alive and used.
                // 5. This queue is now rescheduled for  a new session.
                // 6. CSessionMgr::AddWaitingSessions() is called, and create
                //    a WAIT_INFO structure.
                // 7. CSockTransport::CloseConnection() is called again (on
                //    old connection) from failing socket operations.
                // 8. so we reach here again from 7, and flag can be TRUE or
                //    FALSE, sporadically. It depend on the status of the new
                //    connection that is now established.
                //
                // Setting it to FALSE doesn't do any harm, it just make the
                // fix to Windows bug 612988 less than optimal.
                //
                pWaitInfo->fInConnectionProcess = FALSE ;
                return ;
            }
        }
    }
}

//+-----------------------------------------------------------------------
//
//  BOOL  CSessionMgr::GetAddressToTryConnect()
//
// Get an address of remote computer so we can try to connect to.
// Do not return addresses that are now used by other threads.
// Fix for Windows bug 612988, where multiple worker threads tried to
// connect to same address.
//
//+-----------------------------------------------------------------------

BOOL  CSessionMgr::GetAddressToTryConnect( OUT WAIT_INFO **ppWaitConnectInfo )
{
    static int s_iteration = 0;

    CS lock(m_csMapWaiting);

    //
    // Check which session to try
    //
    int iMaxIteration = m_mapWaiting.GetCount() ;

    s_iteration++;
    if (s_iteration > iMaxIteration)
    {
        s_iteration = 1;
    }

    //
    // And get to it
    //
    int i = 0 ;
    CList<const CQueue*, const CQueue*&>* plist;
    POSITION pos = m_mapWaiting.GetStartPosition();

    for ( ; i < s_iteration; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);
    }

    //
    // Check if no other thread is trying to connect to this address.
    //
    if (!((*ppWaitConnectInfo)->fInConnectionProcess))
    {
        return TRUE ;
    }

    //
    // Try other addresses, from present position to end of map.
    //
    for ( ; i < iMaxIteration ; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);

        if (!((*ppWaitConnectInfo)->fInConnectionProcess))
        {
            return TRUE ;
        }
    }

    //
    // Address not found. Try to find one in the first entries of the map.
    //
    pos = m_mapWaiting.GetStartPosition();
    for ( i = 0 ; i < (s_iteration-1) ; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);

        if (!((*ppWaitConnectInfo)->fInConnectionProcess))
        {
            return TRUE ;
        }
    }

    //
    // didn't find a suitable address.
    //
    return FALSE ;
}

/*====================================================

CSessionMgr::TryConnect

Arguments:

Return Value:

Check if there are some waiting sessions, and try to connect
to them

Thread Context: Scheduler

=====================================================*/

inline void CSessionMgr::TryConnect()
{
    static DWORD s_dwConnectingThreads = 0 ;
    //
    // This count the number of threads that call CreateConnection().
    // We want that at any givem time, at least one worker thread will
    // be availalbe for other operations and won't be blocked on
    // CreateConnection(). Fix for bug 6375.
    //

    GUID gQMId;
    BOOL fQoS;
    P<TA_ADDRESS> pa;

    {
        CS lock(m_csMapWaiting);

        ASSERT(m_fTryConnectTimerScheduled);

        //
        // First, cleanup entries that need to be removed.
        //
        POSITION posmap;
        posmap = m_mapWaiting.GetStartPosition();
        while(posmap != NULL)
        {
            WAIT_INFO* pWaitRouteInfo;
            CList <const CQueue *, const CQueue *&>* plist;

            m_mapWaiting.GetNextAssoc(posmap, pWaitRouteInfo, plist);

            //
            // If the list of queues waiting for session is empty,
            // delete it, and delete the entry from the map.
            // If we're trying now to connect to this address, then
            // leave entry in map. It will be removed later.
            //
            if ( plist->IsEmpty()                        &&
                !(pWaitRouteInfo->fInConnectionProcess) )
            {
                m_mapWaiting.RemoveKey(pWaitRouteInfo);
                delete plist;
            }
        }

        //
        // If no waiting sessions, return
        //
        if(m_mapWaiting.IsEmpty())
        {
            m_fTryConnectTimerScheduled = FALSE;
            return;
        }

        //
        // Reschedule the timer. The address is removed from the map only when the
        // connection is completed successfully, therfore we need to reschedule the time
        // even if it is the last address in the map. However if the connection was successed,
        // next time the scheduler is called, the map will be empty and the scheduler doesn't
        // set anymore
        //
        ExSetTimer(&m_TryConnectTimer, CTimeDuration::FromMilliSeconds(5000));

        if (s_dwConnectingThreads >= (g_dwThreadsNo - 1))
        {
            //
            // enough threads are trying to connect. Leave this one
            // free for other operations.
            //
            return ;
        }

        WAIT_INFO* pWaitRouteInfo;
        BOOL f = GetAddressToTryConnect( &pWaitRouteInfo) ;
        if (!f)
        {
            //
            // Didn't find any address.
            //
            return ;
        }
        pWaitRouteInfo->fInConnectionProcess = TRUE ;

        //
        // since the key can be destruct during the Network connect, we copy the address
        // and the QM guid. We can use a CriticalSection to avoid this situation, but the
        // the NetworkConnect function can take lot of time (access to DNS) and try to avoid
        // the case that all the threads are waiting for this critical section.
        //
        pa = (TA_ADDRESS*) new UCHAR[sizeof(TA_ADDRESS)+ (pWaitRouteInfo->pAddr)->AddressLength];
        memcpy(pa,pWaitRouteInfo->pAddr, TA_ADDRESS_SIZE+(pWaitRouteInfo->pAddr)->AddressLength);
        gQMId = pWaitRouteInfo->guidQMId;
        fQoS = pWaitRouteInfo->fQoS ;

        s_dwConnectingThreads++ ;
    }

    //
    // And try to open a session with it.
    //
    P<CTransportBase> pSess = new CSockTransport();
    HRESULT rcCreate = pSess->CreateConnection(pa, &gQMId, FALSE);
    if(SUCCEEDED(rcCreate))
    {
        //
        // Notify the Session Manager of a newly created session
        //
        NewSession(pSess);
        pSess.detach();
    }

    {
        CS lock(m_csMapWaiting);

        if (FAILED(rcCreate))
        {
            MarkAddressAsNotConnecting( pa, gQMId, fQoS ) ;
        }

        s_dwConnectingThreads-- ;
        ASSERT(((LONG)s_dwConnectingThreads) >= 0) ;
    }
}


void
WINAPI
CSessionMgr::TimeToTryConnect(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler to try connecton to next address,
    when timeout is expired. The routine retrive the session manager
    object and calls the TryConnect memeber function

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the SessionMgr
             object and it use to retrive it.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_TryConnectTimer);

    TrTRACE(NETWORKING, "Call Try Connect");
    pSessMgr->TryConnect();
}


/*====================================================

CSessionMgr::AcceptSockSession

Arguments:

Return Value:

Called when a Sock connection was accepted.

=====================================================*/
void CSessionMgr::AcceptSockSession(IN TA_ADDRESS *pa,
                                    IN CSocketHandle& pSocketHandle)
{
    ASSERT(pa != NULL);

    //
    // Create a new session
    //
    P<CSockTransport> pSess = new CSockTransport;

    //
    // And pass to the session object
    //
    pSess->Connect(pa, pSocketHandle);

    //
    // Notify of a newly created session
    //
    NewSession(pSess);
	pSess.detach();
}


void
CSessionMgr::IPInit(void)
{
    g_sockListen = QmpCreateSocket(m_fUseQoS);

    ASSERT(g_dwIPPort);

    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    local_sin.sin_family = AF_INET;
    local_sin.sin_port = htons(DWORD_TO_WORD(g_dwIPPort));        /* Convert to network ordering */
    local_sin.sin_addr.s_addr = GetBindingIPAddress();

    // to make sure that we open the port exclusivly
    BOOL exclusive = TRUE;
    int rc = setsockopt( g_sockListen, SOL_SOCKET, SO_EXCLUSIVEADDRUSE , (char *)&exclusive, sizeof(exclusive));
    if (rc != 0)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "failed to set SO_EXCLUSIVEADDRUSE option to listening socket, %!winerr!, QM Terminates", gle);
        throw bad_win32_error(gle);
    }

    rc = bind( g_sockListen, (struct sockaddr FAR *) &local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "bind to port %d failed. %!winerr!", g_dwIPPort, gle);

		if((gle == WSAEADDRINUSE) && IsLocalSystemCluster())
		{
			//
			// This is the case when msmq service was started on the physical node
			// before the machine was clusterized.
			// As a result msmq on the physical node is not cluster aware and listen on all ip addresses
			// including cluster ip.
			// This prevents msmq resource to listen on cluster IP, fails with WSAEADDRINUSE.
			// The user need to restart msmq service on the physical node
			// so it will be cluster aware.
			//
			EvReportWithError(EVENT_ERROR_QM_NOT_CLUSTER_AWARE, gle);
		}

		EvReportWithError(EVENT_ERROR_IP_BIND_FAILED, gle);
        throw bad_win32_error(gle);
    }

    rc = listen( g_sockListen, 5 ); // 5 is the maximum allowed length the queue of pending connections may grow
    if (rc != 0)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "Listen failed, %!winerr!", gle);
        throw bad_win32_error(gle);
    }

	DWORD dwThreadId;
    HANDLE hThread = CreateThread(
							NULL,
							0,
							AcceptIPThread,
							NULL,
							0,
							&dwThreadId
							);

    if(hThread == NULL)
    {
        DWORD gle = GetLastError();
        TrERROR(NETWORKING, "Creation of listening thread failed , %!winerr!", gle);
        LogHR(gle, s_FN, 160);
        throw bad_alloc();
    }
    CloseHandle(hThread);
}





/*====================================================

CSessionMgr::SetWindowSize

Arguments: Window size

Return Value:  None

Called when the write to socket failed .

=====================================================*/
void CSessionMgr::SetWindowSize(WORD wWinSize)
{
    CS lock(m_csWinSize);

    m_wCurrentWinSize = wWinSize;

    //
    // The routine can calls multiple times. If the timer already set, try to cancel
    // it. If the cancel failed, don't care, it means there is another timer that already
    // expired but doesn't execute yet. This timer will update the window size and reschedule
    // the timer
    //
    if (!m_fUpdateWinSizeTimerScheduled || ExCancelTimer(&m_UpdateWinSizeTimer))
    {
        ExSetTimer(&m_UpdateWinSizeTimer, CTimeDuration::FromMilliSeconds(90*1000));
        m_fUpdateWinSizeTimerScheduled = TRUE;
    }

    TrTRACE(NETWORKING, "QM window size set to: %d", m_wCurrentWinSize);
}

/*====================================================

CSessionMgr::UpdateWindowSize

Arguments: None

Return Value:  None

Called from the scheduler to update the window size.

=====================================================*/
inline void CSessionMgr::UpdateWindowSize()
{
    CS lock(m_csWinSize);

    //
    // Update the window size until it reach the max size
    //
    m_wCurrentWinSize = (WORD)min((m_wCurrentWinSize * 2), m_wMaxWinSize);

    TrTRACE(NETWORKING, "QM window size set to: %d", m_wCurrentWinSize);

    if (m_wCurrentWinSize != m_wMaxWinSize)
    {
        //
        // Doesn't reach the maximum, reschedule for update
        //
        ExSetTimer(&m_UpdateWinSizeTimer, CTimeDuration::FromMilliSeconds(30*1000));
        return;
    }

    m_fUpdateWinSizeTimerScheduled = FALSE;
}


void
WINAPI
CSessionMgr::TimeToUpdateWindowSize(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler to update the machine window size,
    when timeout is expired. The routine retrive the session manager
    object and calls the UpdateWindowSize function member.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the SessionMgr
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_UpdateWinSizeTimer);

    TrTRACE(NETWORKING, "Call window update size");
    pSessMgr->UpdateWindowSize();
}


void
CSessionMgr::ConnectNetwork(
    void
    )
//
// Routine Description:
//      The routine move the network from disconnected state to connected. The
// routine, resume the accept threads to allow acception of new session.
//
// Arguments:
//      None.
//
// Returned Value:
//		None.
//
{
    //
    // Allow accept of incoming connection
    //                                    '
	ASSERT(("m_hAcceptAllowed should initialize before use", m_hAcceptAllowed != NULL));
    SetEvent(m_hAcceptAllowed);
}


void
CSessionMgr::DisconnectNetwork(
    void
    )
//
// Routine Description:
//      The routine move the network from connected state to disconnected. The
// routine, suspend the accept threads to disallow acception of new session,
// and inform all the active session about the new state
//
// Arguments:
//      None.
//
// Returned Value:
//		None.
//
// Note:
//     The routine can throw an exception
//
{
   //
    // Don't allow accept of incoming connection
    //
	ASSERT(("m_hAcceptAllowed should initialize before use", m_hAcceptAllowed != NULL));
    ResetEvent(m_hAcceptAllowed);

	try
	{
	    //
	    // move all the waiting queues to nonactive group for re-routing
	    //
		MoveAllQueuesFromWaitingToNonActiveGroup();

	    //
	    // scan the open session and return them to connected state
	    //
        CS lock(m_csListSess);

	    POSITION pos = m_listSess.GetHeadPosition();
	    while(pos != NULL)
	    {
	        CTransportBase* pSess = m_listSess.GetNext(pos);
	        pSess->Disconnect();
	    }
	}
	catch(const exception&)
	{
	    SetEvent(m_hAcceptAllowed);
	    throw;
	}
		
}


void
CSessionMgr::NewSession(
    CTransportBase *pSession
    )
{
    CS lock(m_csListSess);

    //
    // Add the session to the list of sessions
    //
    m_listSess.AddTail(pSession);

    //
    // Set the cleanup timer, if it was not set yet
    //
    if (!m_fCleanupTimerScheduled)
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_dwSessionCleanTimeout));
        m_fCleanupTimerScheduled = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\rrsrvcommon.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rrSrvCommon.h

Abstract:

    Remove Read server side common code for old and new interface.

Author:

    Ilan Herbst		(ilanh) 3-Mar-2002

--*/

#ifndef _RRSRVCOMMON_H_
#define _RRSRVCOMMON_H_

#include "phinfo.h"
#include "rpcsrv.h"


#define PACKETSIZE(pMsg) \
   (((struct CBaseHeader *) pMsg)->GetPacketSize())


//-------------------------------------------------------------
//
//  class CRpcServerFinishCall - Auto complete or Abort async rpc call
//
//-------------------------------------------------------------
class CRpcAsyncServerFinishCall {
public:
    CRpcAsyncServerFinishCall(
		PRPC_ASYNC_STATE pAsync,
	    HRESULT DefaultAbortHr,
	    LPCSTR FuncName
		);

   	~CRpcAsyncServerFinishCall();

	void SetHr(HRESULT hr)
	{
		m_hr = hr;
	}

	void SetHrForCompleteCall(HRESULT hr)
	{
		m_hr = hr;
		m_fCompleteCall = true;
	}

	void detach()
	{
		m_pAsync = NULL;
	}

private:

	void CompleteCall();
	
	void AbortCall();
	
private:
	PRPC_ASYNC_STATE m_pAsync;
    HRESULT m_hr;
    LPCSTR m_FuncName;
    bool m_fCompleteCall;
};



//---------------------------------------------------------
//
//  class CRRCursor - RemoteRead cursor on the server
//  the cursor is closed in the class dtor.
//
//---------------------------------------------------------
class CRRCursor : public CReference
{
public:
	CRRCursor( 
		) :
		m_hQueue(NULL),
		m_hCursor(NULL)
	{
	}

	void SetCursor(
		HANDLE hQueue,
		HACCursor32 hCursor
		)
	{
		ASSERT(hQueue != NULL);
		ASSERT(hCursor != NULL);

		m_hQueue = hQueue;
		m_hCursor = hCursor;
	}


	HACCursor32 GetCursor()
	{
		return m_hCursor;
	}
	
	void Reset()
	{
		m_hQueue = NULL;
		m_hCursor = NULL;
	}

private:
	~CRRCursor();

private:
	HANDLE m_hQueue;
	HACCursor32 m_hCursor;
};


struct CTX_OPENREMOTE_BASE : public CBaseContextType, public CReference
{
public:
	CTX_OPENREMOTE_BASE(
		HANDLE hLocalQueue,
		CQueue* pLocalQueue
		) :
		m_hQueue(hLocalQueue),
		m_pLocalQueue(SafeAddRef(pLocalQueue))
	{
	}


	void ResetAllCursorsInMap();

	void 
	AddCursorToMap(
		ULONG hCursor,
		R<CRRCursor>& pCursor
		);

	HRESULT 
	RemoveCursorFromMap(
		ULONG hCursor
		);

	R<CRRCursor> 
	GetCursorFromMap(
		ULONG hCursor
		);


protected:
	~CTX_OPENREMOTE_BASE();

public:
	HANDLE m_hQueue;            // srv_hACQueue
	R<CQueue> m_pLocalQueue;	// srv_pQMQueue
	
	//
	// Map and CS for Open Cursors in this Remote read Session
	// 
    CCriticalSection m_OpenCursorsCS;
    std::map<ULONG, R<CRRCursor> > m_OpenCursors;
};


HRESULT   
QMRemoteEndReceiveInternal( 
	HANDLE        hQueue,
	HACCursor32   hCursor,
	ULONG         ulTimeout,
	ULONG         ulAction,
	REMOTEREADACK eRRAck,
	CBaseHeader*  lpPacket,
	CPacket*      pDriverPacket
	);

#endif // _RRSRVCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\session.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    session.h

Abstract:
    Network session definition

Author:
    RaphiR

--*/
#ifndef __SESSION_H__
#define __SESSION_H__

#include <winsock.h>
#include "qmpkt.h"
#include "factory.h"
#include "qmperf.h"
#include "cgroup.h"
#include "qmutil.h"
#include "qmthrd.h"
#include "st.h"
#include "autohandle.h"

#define SESSION_CHECK_EXIST     0x00000001
#define SESSION_ONE_TRY         0x00000002
#define SESSION_RETRY           0x00000004

class CQueue;           //forward reference


#define Close_Connection(pSession, msg) pSession->CloseConnection(msg, true)
#define Close_ConnectionNoError(pSession, msg) 	pSession->CloseConnection(msg, false)



typedef enum _SessionStatus
{
    ssNotConnect   = 0,    //  0 - Session not connected yet
    ssConnect      = 1,    //  1 - session is connected
    ssEstablish    = 2,    //  2 - Falcon Establish connection completed
    ssActive       = 3     //  3 - Falcon Connection parameter was exchange
} SessionStatus;

class CTransportBase : public CInterlockedSharedObject
{
    public:
        CTransportBase();
        ~CTransportBase();

        void SetUsedFlag(BOOLEAN f);
        BOOL GetUsedFlag(void) const;

        void  SetQMId(const GUID* pguidQMID);
        const GUID* GetQMId(void) const;

        void SetSessionAddress(const TA_ADDRESS*);
        const TA_ADDRESS* GetSessionAddress(void) const;
        LPCWSTR GetStrAddr(void) const;

        HANDLE GetGroupHandle(void) const;
        CQGroup* GetGroup(void) const;
        void SetGroup(CQGroup*);

        void SetSessionStatus(SessionStatus);
        SessionStatus GetSessionStatus(void) const;

        void SetClientConnect(BOOL);
        BOOL IsClient(void) const;

        static void RequeuePacket(IN CQmPacket *pPkt);

        HRESULT GetNextSendMessage(void);
        void AddQueueToSessionGroup(CQueue* pQueue) throw(std::bad_alloc);

        void EstablishConnectionNotCompleted(void);

        virtual void CloseConnection(LPCWSTR, bool fClosedOnError) = 0;
        virtual HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                         IN const GUID* pguidQMId,
                                         IN BOOL fQuick = TRUE
                                         ) = 0;
        virtual HRESULT Send(IN CQmPacket* pPkt,
                             OUT BOOL* pfGetNext) = 0;

        virtual void SetStoredAck(IN DWORD_PTR wStoredAckNo) = 0;
        virtual void HandleAckPacket(CSessionSection * pcSessionSection) = 0;
        virtual BOOL IsUsedSession(void) const;

        virtual void Disconnect(void) = 0;
        BOOL IsDisconnected(void) const;
        void SetDisconnected(void);

        BOOL IsQoS(void) const;

    protected:
        CCriticalSection    m_cs;                   // Critical section
        GUID                m_guidDstQM;            // Next side QM GUID
        bool                m_fQoS;                 // Session for Direct queues (In QoS)



    private:
        CQGroup *           m_SessGroup;            // Group info
        QMOV_ACGetMsg m_GetSendOV;
        SessionStatus       m_SessionStatus;        // Transfer status
        BOOL                m_fClient;              // Is client side. Craete the connection
        long                m_fUsed;                // Used flag
        TA_ADDRESS*         m_pAddr;                // TA_ADDRESS format address
        BOOL                m_fDisconnect;



#ifdef _DEBUG
        WCHAR               m_lpcsStrAddr[50];
#endif
};


/*======================================================

   FUNCTION: CTransportBase::SetUsedFlag

========================================================*/
inline void
CTransportBase::SetUsedFlag(BOOLEAN f)
{
    InterlockedExchange(&m_fUsed,  f);
}

/*======================================================

   FUNCTION: CTransportBase::GetUsedFlag

========================================================*/
inline BOOL
CTransportBase::GetUsedFlag(void) const
{
    return m_fUsed;
}

/*======================================================

   FUNCTION: CTransportBase::SetSessionAddress

========================================================*/
inline void
CTransportBase::SetSessionAddress(const TA_ADDRESS* pa)
{
    //Keep the TA_ADDRESS format
    m_pAddr = (TA_ADDRESS*) new char [pa->AddressLength + TA_ADDRESS_SIZE];
    memcpy(m_pAddr, pa, pa->AddressLength + TA_ADDRESS_SIZE);
#ifdef _DEBUG
    TA2StringAddr(pa, m_lpcsStrAddr, 50);
#endif
}

/*======================================================

   FUNCTION: CTransportBase::GetSessionAddress

========================================================*/
inline const TA_ADDRESS*
CTransportBase::GetSessionAddress(void) const
{
    return m_pAddr;
}

/*======================================================

  FUNCTION: CTransportBase::SetQMId

========================================================*/
inline LPCWSTR
CTransportBase::GetStrAddr(void) const
{
#ifdef _DEBUG
    return m_lpcsStrAddr;
#else
    return NULL;
#endif
}

/*======================================================

  FUNCTION: CTransportBase::SetQMId

========================================================*/
inline void
CTransportBase::SetQMId(const GUID* pguidQMId)
{
    m_guidDstQM = *pguidQMId;
}

/*======================================================

  FUNCTION: CTransportBase::GetQMId

========================================================*/
inline const GUID*
CTransportBase::GetQMId(void) const
{
    return &m_guidDstQM;
}

/*======================================================

  FUNCTION: CTransportBase::SetSessionStatus

========================================================*/
inline void
CTransportBase::SetSessionStatus(SessionStatus sStatus)
{
    m_SessionStatus = sStatus;
}

/*======================================================

  FUNCTION: CTransportBase::GetSessionStatus

========================================================*/
inline SessionStatus
CTransportBase::GetSessionStatus(void) const
{
    return m_SessionStatus;
}

/*======================================================

   FUNCTION:CTransportBase::GetGroupHandle

========================================================*/
inline HANDLE
CTransportBase::GetGroupHandle(void) const
{
    return((m_SessGroup != NULL) ? m_SessGroup->GetGroupHandle() : NULL);
}

/*======================================================

   FUNCTION:CTransportBase::SetClientConnect

========================================================*/
inline void
CTransportBase::SetClientConnect(BOOL f)
{
    m_fClient = f;
}

/*======================================================

   FUNCTION:CTransportBase::IsClient

========================================================*/
inline BOOL
CTransportBase::IsClient(void) const
{
    return m_fClient;
}

/*======================================================

   FUNCTION:CTransportBase::GetGroup

========================================================*/
inline CQGroup*
CTransportBase::GetGroup(void) const
{
    return m_SessGroup;
}
/*======================================================

   FUNCTION:CTransportBase::SetGroup

========================================================*/
inline void
CTransportBase::SetGroup(CQGroup* pGroup)
{
    m_SessGroup = pGroup;
}

/*======================================================

   FUNCTION:CTransportBase::IsUsedSession

========================================================*/
inline BOOL
CTransportBase::IsUsedSession(void) const
{
    return GetUsedFlag();
}

inline
BOOL 
CTransportBase::IsDisconnected(
    void
    ) const
{
    return m_fDisconnect;
}

inline
void
CTransportBase::SetDisconnected(
    void
    )
{
    m_fDisconnect = TRUE;
}

inline
BOOL 
CTransportBase::IsQoS(
    void
    ) const
{
    return m_fQoS;
}

//
// SP4 - Bug 3380 (closing a session while sending a messge)
//
// ReportMsgInfo structure is used to hold messgae information 
// for sending a report message. Due the bug fix the message can
// be freed before the report message is sent, As a result we need
// to save the message information for later use
//              Uri Habusha (urih), 11-Aug-98
//
class ReportMsgInfo
{
    public:
        void SetReportMsgInfo(CQmPacket* pPkt);
        void SendReportMessage(LPCWSTR pcsNextHope);

    private:
        USHORT m_msgClass;
        USHORT m_msgTrace;
        QUEUE_FORMAT m_OriginalReportQueue;
        QUEUE_FORMAT m_TargetQueue;
        OBJECTID m_MessageId;
        DWORD m_msgHopCount;
};

class CSockTransport : public CTransportBase
{
    public:

        CSockTransport();
        ~CSockTransport();

        HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                 IN const GUID* pguidQMId,
                                 IN BOOL fQuick = TRUE
                                 );
        void CloseConnection(LPCWSTR,bool fClosedOnError);
        void HandleAckPacket(CSessionSection * pcSessionSection);

        void SendPendingReadAck();

        void CheckForAck();
        void SetStoredAck(IN DWORD_PTR wStoredAckNo);

        void Connect(IN TA_ADDRESS *pAddr, IN CSocketHandle& pSocketHandle);
        void HandleReceiveInternalMsg(CBaseHeader* pBaseHeader);
        void HandleReceiveUserMsg(CBaseHeader* pBaseHeader, CPacket* pDriverPacket);
        BOOL IsUsedSession(void) const;

        void Disconnect(void);

        void CloseDisconnectedSession(void);

	private:
		struct QMOV_ReadSession;
		typedef HRESULT (WINAPI *LPREAD_COMPLETION_ROUTINE)(QMOV_ReadSession* po);

		static VOID WINAPI SendDataFailed(EXOVERLAPPED* pov);
		static VOID WINAPI SendDataSucceeded(EXOVERLAPPED* pov);

		static VOID WINAPI ReceiveDataFailed(EXOVERLAPPED* pov);
		static VOID WINAPI ReceiveDataSucceeded(EXOVERLAPPED* pov);

		static HRESULT WINAPI ReadHeaderCompleted(QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadAckCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadUsrHeaderCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadInternalPacketCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadUserMsgCompleted(IN QMOV_ReadSession*  pov);

	private:
		//
		// Overlapped strcucture for asynchronous operatios
		//
		class QMOV_WriteSession
		{
            public:
                QMOV_WriteSession(CSockTransport* pSession, BOOL fUserMsg) :
				    m_qmov(SendDataSucceeded, SendDataFailed), 
                    m_pSession(pSession),
                    m_fUserMsg(fUserMsg),
                    m_dwWriteSize(0)
			    {
                    m_Buffers.reserve(4);
                    m_ReleaseBuffers.reserve(4);
			    }

                ~QMOV_WriteSession()
                {
                    for (std::vector<PCHAR>::iterator it = m_ReleaseBuffers.begin(); it != m_ReleaseBuffers.end(); it++)
                    {
                        PCHAR buf = *it;
                        delete[] buf;
                    }
                }

                CSockTransport* Session() const
                { 
                    return m_pSession;
                }

                WSABUF *Buffers() 
                { 
                    return m_Buffers.begin();
                }

                void AppendSendBuffer(PVOID Buffer, DWORD dwWriteSize, BOOL fRelease)
                {
		            WSABUF sendBuff;
                    PCHAR buf =  static_cast<char*>(Buffer);
    		        sendBuff.buf = buf;
    		        sendBuff.len = dwWriteSize;
                    m_Buffers.push_back(sendBuff);
                    m_dwWriteSize += dwWriteSize;
                    if(fRelease)
                    {
                        m_ReleaseBuffers.push_back(buf);
                    }
                }

                size_t NumberOfBuffers() const 
                { 
                    return m_Buffers.size();
                }

                DWORD WriteSize() const 
                { 
                    return m_dwWriteSize;
                }
                
                BOOL UserMsg() const 
                { 
                    return m_fUserMsg; 
                }

            public:
                EXOVERLAPPED               m_qmov;

            private:
			    CSockTransport*            m_pSession;
                BOOL                       m_fUserMsg;
   			    DWORD                      m_dwWriteSize;    // How many bytes should be writen
                std::vector<PCHAR>         m_ReleaseBuffers;       //  Release Buffers for send session
                std::vector<WSABUF>        m_Buffers;  // Write buffers for send session
		};



		struct QMOV_ReadSession
		{
			EXOVERLAPPED    qmov;
			CSockTransport*   pSession;  // Pointer to session object
			union {
				UCHAR *       pbuf;
				CBaseHeader * pPacket;
				CSessionSection * pSessionSection;
			};
			CPacket *  pDriverPacket;
			DWORD            dwReadSize; // Size of buffer
			DWORD            read;       // How many bytes already read
			LPREAD_COMPLETION_ROUTINE  lpReadCompletionRoutine;

			QMOV_ReadSession() :
				qmov(ReceiveDataSucceeded, ReceiveDataFailed)
			{
			}
		};

     private:
		void ReportErrorToGroup();
        void WriteCompleted(QMOV_WriteSession*  po);  
        void ReadCompleted(QMOV_ReadSession*  po);  

        HRESULT ResumeSendSession(void);

        HRESULT SendInternalPacket(PVOID     lpWriteBuffer,
                                  DWORD     dwWriteSize
                                  );

        void    CreateConnectionParameterPacket(IN DWORD dwSendTime,
                                                OUT CBaseHeader** ppPkt,
                                                OUT DWORD* pdwPacketSize);

        void SendEstablishConnectionPacket(const GUID* pDstQMId,
                                              BOOL fCheckNewSession)throw();
        void BeginReceive();
        void NewSession(IN CSocketHandle& pSocketHandle);

        HRESULT WriteToSocket(QMOV_WriteSession*  po);

        void PrepareBaseHeader(IN const CQmPacket *pPkt,
                                 IN BOOL fSendAck,
                                 IN DWORD dwDbgSectionSize,
                                 IN QMOV_WriteSession *po
                                );
        HRESULT PrepareExpressEncryptPacket(IN CQmPacket* pPkt,
                                   IN HCRYPTKEY hKey,
                                   IN BYTE *pbSymmKey,
                                   IN DWORD dwSymmKeyLen,
                                   IN QMOV_WriteSession *po
                                  );

        HRESULT PrepareRecoverEncryptPacket(IN const CQmPacket *pPkt,
                                          IN HCRYPTKEY hKey,
                                          IN BYTE *pbSymmKey,
                                          IN DWORD dwSymmKeyLen,
                                          IN QMOV_WriteSession*  po
                                          );
        void PrepareDebugSection(IN QUEUE_FORMAT* pReportQueue, 
                                 IN DWORD dwDbgSectionSize, 
                                 IN QMOV_WriteSession* po);

        void PrepareIncDebugAndMqfSections(IN CQmPacket* pPkt,
                                           IN QMOV_WriteSession* po);

        void PrepareAckSection(OUT WORD* pStorageAckNo, 
                               OUT DWORD* pStorageAckBitField, 
                               IN QMOV_WriteSession* po);


        void WriteUserMsgCompleted(IN QMOV_WriteSession*  po);
       
		
        HRESULT Send(IN CQmPacket* pPkt,
                     OUT BOOL* pfGetNext);
        void IncReadAck(CQmPacket*);
        void UpdateAcknowledgeNo(IN CQmPacket* pPkt);
        void ClearRecvUnAckPacketNo(void);
        void IncRecvUnAckPacketNo(void);
        WORD GetRecvUnAckPacketNo(void) const;
        void NetworkSend(IN CQmPacket *pPkt);
        void RcvStats(DWORD size);
        void NeedAck(IN CQmPacket *pInfo);

        void HandleEstablishConnectionPacket(CBaseHeader*);
        void HandleConnectionParameterPacket(CBaseHeader*) throw(std::bad_alloc);
        void ReceiveOrderedMsg(
                CQmPacket *pPkt, 
                CQueue* pQueue, 
                BOOL fDuplicate
                );

        WORD GetSendUnAckPacketNo(void) const;
        void UpdateRecvAcknowledgeNo(CQmPacket*);

        BOOL IsSusspendSession();
        DWORD GetSendAckTimeout(void) const;
        void RejectPacket(CQmPacket* pPkt, USHORT usClass);

        void OtherSideIsServer(BOOL);
        BOOL IsOtherSideServer(void) const;

      
        void
        UpdateNumberOfStorageUnacked(
            WORD BaseNo,
            DWORD BitField
            );

       
        void CancelAckTimers();
        void FinishSendingAck(WORD StorageAckNo, DWORD StorageAckBitField);
        void SendReadAck();

        void SetFastAcknowledgeTimer(void);
        void SendFastAckPacket(void);
        void SendAckPacket(void);
        void SetAckInfo(CSessionSection* pAckSection);


        void 
        CreateAckPacket(
            PVOID* ppSendPacket,
            CSessionSection** ppAckSection,
            DWORD* pSize
            );
     
        HRESULT
        CSockTransport::ConnectSocket(
			SOCKET s,
            SOCKADDR_IN const *pdest_in,
            bool              fUseQoS
            );


		bool IsConnectionClosed(void) const
		{
			ASSERT((GetSessionStatus() == ssNotConnect) || (m_connection.get() != NULL));
			return (GetSessionStatus() == ssNotConnect); 
		}


#ifdef _DEBUG
        void DisplayAcnowledgeInformation(CSessionSection* pAck);
#else
        #define DisplayAcnowledgeInformation(pAck) ((void) 0)
#endif

        static void WINAPI SendFastAcknowledge(CTimer* pTimer);
        static void WINAPI TimeToCheckAckReceived(CTimer* pTimer);
        static void WINAPI TimeToSendAck(CTimer* pTimer);
        static void WINAPI TimeToCancelConnection(CTimer* pTimer);
        static void WINAPI TimeToCloseDisconnectedSession(CTimer* pTimer);

    private:
        WORD                m_wUnAckRcvPktNo;
        BOOL                m_fSendAck;
        BOOL                m_fRecvAck;
        DWORD               m_dwLastTimeRcvPktAck;
        WORD                m_wSendPktCounter;
        WORD                m_wPrevUnackedSendPkt;

        CList<CQmPacket *, CQmPacket *&> m_listUnackedPkts;
        //
        // Store Acking
        //
        WORD                m_wStoredPktCounter;
        WORD                m_wUnackStoredPktNo;      // Index of the last stored packet that
                                                       // received
        WORD                m_wAckRecoverNo;
        DWORD               m_dwAckRecoverBitField;

        LONG                m_lStoredPktReceivedNoAckedCount;
        //
        //
        //
        WORD                m_wRecvUnAckPacketNo;

        CList<CQmPacket *, CQmPacket *&> m_listStoredUnackedPkts;


        DWORD m_dwAckTimeout;
        DWORD m_dwSendAckTimeout;
        DWORD m_dwSendStoreAckTimeout;
        WORD  m_wRecvWindowSize;
        BOOL  m_fSessionSusspended;

		R<IConnection> m_connection;

        BOOL    m_fOtherSideServer;     // True if the other side of the connection
                                        // is MSMQ server


        ReportMsgInfo m_MsgInfo;

        R<CSessionPerfmon> m_pStats; //Statistics

        CTimer m_FastAckTimer;

        BOOL m_fCheckAckReceivedScheduled;
        CTimer m_CheckAckReceivedTimer;

        DWORD m_nSendAckSchedules;
        CTimer m_SendAckTimer;

        BOOL m_fCloseDisconnectedScheduled;
        CTimer m_CloseDisconnectedTimer;

        CTimer m_CancelConnectionTimer;
       
};

/*======================================================

   FUNCTION: CSockTransport::GetSendUnAckPacketNo

========================================================*/
inline WORD
CSockTransport::GetSendUnAckPacketNo(void) const
{
    return DWORD_TO_WORD(m_listUnackedPkts.GetCount());
}

/*======================================================

   FUNCTION: CSockTransport::ClearRecvUnAckPacketNo

========================================================*/
inline void
CSockTransport::ClearRecvUnAckPacketNo(void)
{
    m_wRecvUnAckPacketNo = 0;
}

/*======================================================

   FUNCTION: CSockTransport::IncRecvUnAckPacketNo

========================================================*/
inline void
CSockTransport::IncRecvUnAckPacketNo(void)
{
    m_wRecvUnAckPacketNo++;
}

/*======================================================

   FUNCTION: CSockTransport::GetRecvUnAckPacketNo

========================================================*/
inline WORD
CSockTransport::GetRecvUnAckPacketNo(void) const
{
    return m_wRecvUnAckPacketNo;
}

/*======================================================

   FUNCTION: CSockTransport::GetSendAckTimeout

========================================================*/
inline DWORD
CSockTransport::GetSendAckTimeout(void) const
{
    return m_dwSendAckTimeout;
}

/*======================================================

   FUNCTION: CSockTransport::OtherSideIsServer

========================================================*/
inline void
CSockTransport::OtherSideIsServer(BOOL f)
{
    m_fOtherSideServer = f;
}

/*======================================================

   FUNCTION: CSockTransport::IsOtherSideServer

========================================================*/
inline BOOL
CSockTransport::IsOtherSideServer(void) const
{
    return m_fOtherSideServer;
}


#endif // __SESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\session.cpp ===
/*++

    Copyright (c) 1995  Microsoft Corporation

    Module Name:
        session.cpp

    Abstract:
        Implementation of Network session class.

    Author:
        Uri Habusha (urih) 1-Jan-96

    --*/

    #include "stdh.h"

    #include "session.h"
    #include "sessmgr.h"
    #include "cqmgr.h"
    #include "qmp.h"
    #include "perf.h"
    #include "qmthrd.h"
    #include "cgroup.h"
    #include "admin.h"
    #include "qmutil.h"
    #include "xact.h"
    #include "xactrm.h"
    #include "xactout.h"
    #include "xactin.h"
    #include "ping.h"
    #include "rmdupl.h"
    #include <uniansi.h>
    #include <privque.h>
    #include "mqexception.h"
    #include "autohandle.h"
    #include <singelton.h>
    #include <strsafe.h>
    #include <xstr.h>
    #include "qmacapi.h"
    #include "session.tmh"

    extern DWORD g_dwOperatingSystem;

    extern HANDLE g_hAc;
    extern CQueueMgr QueueMgr;
    extern CSessionMgr SessionMgr;
    extern CQGroup* g_pgroupNonactive;
    extern CQGroup* g_pgroupWaiting;
    extern BOOL  g_bCluster_IP_BindAll;

    UINT  g_dwIPPort;


    static WCHAR *s_FN=L"session";

    //
    // Extern variables
    //
    extern CAdmin      Admin;

    TCHAR tempBuf[100];

    //
    // Define decleration
    //
    #define INIT_UNACKED_PACKET_NO 0
    #define HOP_COUNT_RETRY 15
    #define HOP_COUNT_EXPIRATION (HOP_COUNT_RETRY*2) //must be < 32 (only 5 bits)
    #define ESTABLISH_CONNECTION_TIMEOUT 60*1000
    #define MSMQ_MIN_ACKTIMEOUT          1000*20     // define minimum ack timeout to 20 seconds
    #define MSMQ_MAX_ACKTIMEOUT          1000*60*2   // define maximum ack timeout to 2 minutes
    #define MSMQ_MIN_STORE_ACKTIMEOUT    500         // define minimum ack timeout to 0.5 second

    #define PING_TIMEOUT 1000


    inline DWORD GetBytesTransfered(EXOVERLAPPED* pov)
    {
        return numeric_cast<DWORD>(pov->InternalHigh);
    }

    //
    // Description:
    //      the function stores in the class message property that
    //      is required for sending a report message
    //
    // Arguments:
    //      pointer to the packet
    //
    // Returned Value:
    //      None.
    //
    void
    ReportMsgInfo::SetReportMsgInfo(
        CQmPacket* pPkt
        )
    {
        m_msgClass = pPkt->GetClass();
        m_msgTrace = pPkt->GetTrace();
        m_msgHopCount = pPkt->GetHopCount();

        pPkt->GetMessageId(&m_MessageId);
        pPkt->GetDestinationQueue(&m_TargetQueue);
        if (pPkt->IsDbgIncluded())
        {
            BOOL rc = pPkt->GetReportQueue(&m_OriginalReportQueue);
            ASSERT(rc);
            DBG_USED(rc);
        }
        else
        {
            m_OriginalReportQueue.UnknownID(0);
        }
    }


    //
    // Description:
    //      the function send a report message according to the message
    //      properties that were stored in the class
    //
    // Arguments:
    //      pcsNextHope - The name of the next hope
    //
    // Returned Value:
    //      None.
    //
    void
    ReportMsgInfo::SendReportMessage(
        LPCWSTR pcsNextHope
        )
    {

        if (QueueMgr.GetEnableReportMessages()== 0)
        {
            //
            // If we are not allowed to send report messages.
            //
            return;
        }

    	if (m_msgClass == MQMSG_CLASS_REPORT)
        {
            //
            // If the message is report mesaage ignore it.
            //
            return;
        }

        QUEUE_FORMAT QmReportQueue;
        if (
            //
            // Packet should be traced.
            //
            (m_msgTrace == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE) &&

            //
            // Valid report queue is on packet.
            //
            // Note that invalid (unknown) report queue may be on packet,
            // for example when MQF header is included, so that reporting
            // QMs 1.0/2.0 will not append their Debug header to packet.
            //
            (m_OriginalReportQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN)
            )
        {
            //
            // Send report to the report queue that is on packet.
            //
            Admin.SendReport(&m_OriginalReportQueue,
                             &m_MessageId,
                             &m_TargetQueue,
                             pcsNextHope,
                             m_msgHopCount);


            //
            // This is a reporting QM with valid report queue by itself.
            // BUGBUG: Conflict message should be sent only if report queue
            // of this QM is not the one on packet. (ShaiK, 18-May-2000)
            //
            //
            if (SUCCEEDED(Admin.GetReportQueue(&QmReportQueue)))
            {

                Admin.SendReportConflict(&QmReportQueue,
                                         &m_OriginalReportQueue,
                                         &m_MessageId,
                                         &m_TargetQueue,
                                         pcsNextHope);
            }

            return;
        }

        if (
            //
            // This is a reporting QM, or packet should be traced.
            //
            (CQueueMgr::IsReportQM() ||(m_msgTrace == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE)) &&

            //
            // There is a valid report queue for this QM.
            //
            (SUCCEEDED(Admin.GetReportQueue(&QmReportQueue))))

        {
            //
            // Send report to the report queue of this QM.
            //
            Admin.SendReport(&QmReportQueue,
                      &m_MessageId,
                      &m_TargetQueue,
                      pcsNextHope,
                      m_msgHopCount);
        }
    } // ReportMsgInfo::SendReportMessage


    /*====================================================

    GetDstQueueObject

    Arguments:

    Return Value:

    =====================================================*/
    HRESULT GetDstQueueObject(IN  CQmPacket* pPkt,
                              OUT CQueue** ppQueue,
                              IN  bool     fInReceive)
    {
        HRESULT  rc;
        QUEUE_FORMAT DestinationQueue;
        BOOL fGetRealQueue = QmpIsLocalMachine(pPkt->GetSrcQMGuid()) ||
                             (pPkt->ConnectorQMIncluded() && QmpIsLocalMachine(pPkt->GetConnectorQM()));

        pPkt->GetDestinationQueue(&DestinationQueue, !fGetRealQueue);
        rc = QueueMgr.GetQueueObject(&DestinationQueue, ppQueue, 0, fInReceive, false);

        return LogHR(rc, s_FN, 10);
    }

    /*====================================================

    CTransportBase::GetNextSendMessage

    Arguments: None

    Return Value: None

    =====================================================*/
    HRESULT CTransportBase::GetNextSendMessage(void)
    {
        HRESULT hr = MQ_ERROR;
        CS lock(m_cs);


        if ((GetGroupHandle() != NULL) && (GetSessionStatus() != ssNotConnect))
        {
            //
            // Increament Session refence count. This refernce count is for get message
            // request from the session group. The refernce conunt is decremented when
            // the session is closed or when the session is suspended.
            //
            // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
            // Fix: Increment the refernce count before trying to get new message
            //                           Uri Habusha (urih), 17-6-98
            //
            AddRef();

            m_GetSendOV.hGroup = GetGroupHandle();
            m_GetSendOV.pSession = this;

            hr = QmAcGetPacket(
                    GetGroupHandle(),
                    m_GetSendOV.packetPtrs,
                    &m_GetSendOV.qmov
                    );

            if (FAILED(hr))
            {
                Release();
                Close_Connection(this, L"Get next send message Request is failed");
            }
        }

        return LogHR(hr, s_FN, 30);
    }

    /*====================================================

    CTransportBase::RequeuePacket
  		Requeues the packet and delete the QMPacket memory


    Arguments:
  	pPkt - The QM packet to requeue

    Return Value:
  	None

    =====================================================*/
    void CTransportBase::RequeuePacket(CQmPacket* pPkt)
    {
  	QmpRequeueAndDelete(pPkt);

    }

    /*======================================================

    Function:      VerifyTransactRights

    Description:  Checks that the packet and queue are appropriate for transaction
                  If the packet is transacted,     then the queue must be transactional
                  If the packet is not transacted, then the queue must be non-transactional

    Return value:
        The acknowledgment class.
        if packet is OK, MQMSG_CLASS_NORMAL is returned
    ========================================================*/
    USHORT VerifyTransactRights(CQmPacket* pPkt, CQueue* pQ)
    {
        if(pPkt->IsOrdered() == pQ->IsTransactionalQueue())
        {
            return(MQMSG_CLASS_NORMAL);
        }

        return (pPkt->IsOrdered() ?
                    MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q :
                    MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG
                );
    }

    /*====================================================

    VerifyRecvMsg

    Arguments:

    Return Value:
        The acknowledgment class.
        if packet is OK, MQMSG_CLASS_NORMAL is returned

    =====================================================*/
    USHORT VerifyRecvMsg(CQmPacket* pPkt, CQueue* pQueue)
    {
        if(!pQueue->IsLocalQueue())
        {
            //
            // Not Local Machine (FRS)
            //
            if (!IsRoutingServer())   // [adsrv] CQueueMgr::GetMQS() < SERVICE_SRV
            {
                //
                // Can't handle the packet. return NACK if needed
                //
                return(MQMSG_CLASS_NACK_BAD_DST_Q);
            }
        }
        else
        {
            //
            // Verify the the sender has write access permission on the queue.
            //
            WORD wSenderIdLen;
            HRESULT hr = VerifySendAccessRights(
                           pQueue,
                           (PSID)pPkt->GetSenderID(&wSenderIdLen),
                           pPkt->GetSenderIDType()
                           );

            if (FAILED(hr))
            {
                //
                // Access was denied, send NACK.
                //
                return(MQMSG_CLASS_NACK_ACCESS_DENIED);
            }

            //
            // Destination machine, check queue permission and privacy
            //
            switch(pQueue->GetPrivLevel())
            {
            case MQ_PRIV_LEVEL_BODY:
                if (!pPkt->IsEncrypted() && pPkt->IsBodyInc())
                {
                    //
                    // The queue enforces that any message sent to it sohlud be
                    // enctrpted. The message is not encrypted so NACK it.
                    //
                    return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
                }
                break;
            case MQ_PRIV_LEVEL_NONE:
                if (pPkt->IsEncrypted())
                {
                    //
                    // The queue enforces that any message sent to it sohlud not be
                    // enctrpted. The message is encrypted so NACK it.
                    //
                    return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
                }
                break;

            case MQ_PRIV_LEVEL_OPTIONAL:
                break;

            default:
                ASSERT(0);
                break;
            }

            hr = pPkt->Decrypt() ;
            if (FAILED(hr))
            {
                if (hr == MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED)
                {
                    return(MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER);
                }
                else
                {
                    return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
                }
            }

            if (FAILED(VerifySignature(pPkt)))
            {
                //
                // Bad signature, send NACK.
                //
                return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
            }

            if (pQueue->ShouldMessagesBeSigned() && !pPkt->IsAuthenticated())
            {
                //
                // The queue enforces that any message sent to it should be signed.
                // But the message does not contain a signature, send NACK.
                //
                return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
            }
        }

        return(MQMSG_CLASS_NORMAL);
    }

    /********************************************************************************/
    /*                   C S e s s i o n                                            */
    /********************************************************************************/
    CTransportBase::CTransportBase() :
        m_GetSendOV(GetMsgSucceeded, GetMsgFailed)
    {
        m_SessGroup     = NULL;             // Initialize group
        m_SessionStatus = ssNotConnect;     // Session not connect status
        m_guidDstQM     = GUID_NULL;        // null QM guid
        m_pAddr         = 0;                // Null Address
        m_fClient       = FALSE;            // not client
        m_fUsed         = TRUE;             // used
        m_fDisconnect   = FALSE;
        m_fQoS          = false;            // Not QoS
    }

    CTransportBase::~CTransportBase()
    {

    #ifdef _DEBUG
        if (m_pAddr != NULL)
        {
            TrTRACE(NETWORKING, "~CTransportBase: Delete Session Object with %ls", GetStrAddr());
        }
    #endif
        delete m_pAddr;
    }

    /*======================================================

       FUNCTION: CSockTransport::ResumeSendSession

    ========================================================*/
    HRESULT
    CSockTransport::ResumeSendSession(void)
    {
        HRESULT rc;

        TrTRACE(NETWORKING, "ResumeSendSession- Resume session to %ls. (Window size, My = %d, Other = %d)",
                                   GetStrAddr(), SessionMgr.GetWindowSize(),m_wRecvWindowSize);
        //
        // Create a get request from session group
        //
        rc = GetNextSendMessage();
        if (SUCCEEDED(rc))
        {
            m_fSessionSusspended = FALSE;
        }

        return LogHR(rc, s_FN, 50);
    }

    /*======================================================

       FUNCTION: CSockTransport::IsSusspendSession

    ========================================================*/
    BOOL
    CSockTransport::IsSusspendSession(void)
    {
        BOOL   f = FALSE;
        if (GetSendUnAckPacketNo() >= SessionMgr.GetWindowSize())
        {
            f = TRUE;
            m_fSessionSusspended = TRUE;
        }
        return (f);
    }


    /*====================================================

    CSockTransport::Send

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/
    HRESULT CSockTransport::Send(CQmPacket* pPkt, BOOL* /*pfGetNext*/)
    {
        //
        // Send the packet
        //

        if (IsDisconnected())
        {
            TrTRACE(NETWORKING, "Session %ls is disconnected. Reque the packet and don't send any more message on this session", GetStrAddr());

            //
            // The session is disconnected. return the packet to the driver
            // and don't get a new packet for sending on this session. All
            // the queues move latter to nonactive group and rerouted using
            // a new session.
            //
        	// This deletes pPkt
        	//
            RequeuePacket(pPkt);
            return MQ_OK;
        }

        if (pPkt->GetHopCount() >= HOP_COUNT_EXPIRATION &&
           !(pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid())))
        {
            ASSERT(pPkt->GetHopCount() == HOP_COUNT_EXPIRATION);

		    QmAcFreePacket(
					   	   pPkt->GetPointerToDriverPacket(),
			   			   MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED,
		   			       eDeferOnFailure);
            delete pPkt;

            //
            // Get the next message for sending on the session. Generally, MSMQ requests the
            // next message for sending only after completed the sending of current message.
            // In this case the message isn't sent, therefor the next message for sending
            // requested now
            //
            GetNextSendMessage();
            return MQ_OK;
        }

        try
        {
            BOOL fHopCountRetry = (pPkt->GetHopCount() >= HOP_COUNT_RETRY);
            CQueue* pQueue = NULL;

            //
            // Handle Hop count retry in two steps. First we found the relevant
            // queue object, and second after sending the packet we mark the queue
            // and move it to waiting state. We do in this way since the packet can be
            // deleted during the sending or after when getting the acknowledge. In such
            // a case we got GF when trying to retreive the queue object
            //

            if (fHopCountRetry)
            {
                //
                // Find the queue object
                //
    			BOOL fGetRealQ = QmpIsLocalMachine(pPkt->GetSrcQMGuid()) ||
    							 QmpIsLocalMachine(pPkt->GetConnectorQM());

                QUEUE_FORMAT DestinationQueue;
                pPkt->GetDestinationQueue(&DestinationQueue, !fGetRealQ);
                BOOL fSuccess = QueueMgr.LookUpQueue(&DestinationQueue,
                                                     &pQueue,
                                                      false,
                                                      false);
                ASSERT(fSuccess);
    			DBG_USED(fSuccess);
            }

            SetUsedFlag(TRUE);
            NetworkSend(pPkt);

            //
            // when NetworkSend does not throw we should not requeue the packet
            // even if we have exceptions later
            //
            pPkt = NULL;

            if (fHopCountRetry)
            {
                ASSERT(pQueue);

                pQueue->SetHopCountFailure(TRUE);
                //
                // Move queue from session group to Non active group. If moving fails
                // the queue still in the session group. However, later MSMQ tries to
                // deliver this message again ans as a result tries to move the queue
                // to non-active group.
                //
                CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);

                //
                // Decrement the reference count
                //
                pQueue->Release();
            }
        }

        catch(const exception&)
        {
            //
            // only if the pPkt is not NULL We could not send the packet
            // return the packet to the sender
            //
            // This deletes pPkt
            //
            if (pPkt != NULL)
            {
            	RequeuePacket(pPkt);
            }
            Close_Connection(this, L"Exception in CSockTransport::Send");
            return LogHR(MQ_ERROR, s_FN, 60);
        }

        return MQ_OK;

    }

    /*====================================================

    CSockTransport::NeedAck

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/
    void CSockTransport::NeedAck(CQmPacket* pPkt)
    {
        CS lock(m_cs);

        if (IsConnectionClosed())
        {
            //
            // The session close. MSMQ doesn't get an acknowledge for the
            // message. return it to the queue
            //
            // This deletes pPkt
            //
            RequeuePacket(pPkt);
            return;
        }

        //
        // Add the packet to the list of unacknowledged packets
        //
        m_listUnackedPkts.AddTail(pPkt);
        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);
        TrTRACE(NETWORKING, "READACK: Added message to list in NeedAck: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());
        TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);

        if (!m_fCheckAckReceivedScheduled)
        {
            //
            // Increment Session referance count for the CheckForAck. we don't want to free the
            // session while all the scheduling routines are not completed.
            //
            AddRef();

            ExSetTimer(&m_CheckAckReceivedTimer, CTimeDuration::FromMilliSeconds(m_dwAckTimeout));
            m_fCheckAckReceivedScheduled = TRUE;
        }
    }

    /*====================================================

    CSockTransport::IncReadAck

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/
    void CSockTransport::IncReadAck(CQmPacket* pPkt)
    {
        //
        // Mark the session as alive.
        //
        m_fRecvAck = TRUE;
        //
        // Increment the number of packet on session
        //
        WORD wAckNo = m_wUnAckRcvPktNo + 1;
        if (wAckNo == 0)
        {
            wAckNo++;
        }
        pPkt->SetAcknowldgeNo(wAckNo);

        //
        // Increment storage packet number
        //
        if (pPkt->IsRecoverable())
        {
            m_wUnackStoredPktNo++;
            if (m_wUnackStoredPktNo == 0)
            {
                m_wUnackStoredPktNo++;
            }

            //
            // We keep the number on the packet such when the storage is completed we
            // can return storage ack to the sender
            //
            pPkt->SetStoreAcknowldgeNo(m_wUnackStoredPktNo);

            //
            // Increement the number of recoverable packet that were received but
            // didn't ack yet
            //

            LONG PrevVal = InterlockedIncrement(&m_lStoredPktReceivedNoAckedCount);
            ASSERT(PrevVal >= 0);
            DBG_USED(PrevVal);

            TrTRACE(NETWORKING,"(0x%p %ls) Storage Ack 0x%x. No of Recover receove packet: %d",
                        this, this->GetStrAddr(), m_wUnackStoredPktNo, m_lStoredPktReceivedNoAckedCount);
        }
        else
        {
            pPkt->SetStoreAcknowldgeNo(0);
        }

        #ifdef _DEBUG
        {
            OBJECTID MessageId;
            pPkt->GetMessageId(&MessageId);

            TrTRACE(
                NETWORKING,
                "Acknowledge Number for  packet " LOG_GUID_FMT "\\%u are: Session Ack %u, StorageAck %u",
                LOG_GUID(&MessageId.Lineage),
                MessageId.Uniquifier,
                wAckNo,
                m_wUnackStoredPktNo
                );

        }
        #endif

        TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);

        //
        //  if we return back to zero or Window limit has reached,
        //  send the session acks now
        //
        if (GetRecvUnAckPacketNo() >= (m_wRecvWindowSize/2))
        {
            TrWARNING(NETWORKING,"Unacked packet no. reach the limitation (%d). ACK packet was sent", m_wRecvWindowSize);
            TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);
            SendReadAck();
        }
    }

    /*====================================================

    CSockTransport::SetStoredAck

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void CSockTransport::SetStoredAck(DWORD_PTR wStoredAckNo)
    {
        CS lock(m_cs);
        TrTRACE(NETWORKING, "SetStoreAck - Enter: param wStoredAckNo=0x%Ix, data m_wAckRecoverNo=%u", wStoredAckNo, (DWORD)m_wAckRecoverNo);

        if (IsConnectionClosed())
            return;

        //
        // Indicates that need to send an  acknowledge
        //
        m_fSendAck = TRUE;

        if ((m_wAckRecoverNo != 0) &&
            ((wStoredAckNo - m_wAckRecoverNo) > STORED_ACK_BITFIELD_SIZE))
        {
            //
            // There is no place in storage bit field to set acknowledge information.
            // Previous Stored Ack should be sent before the new value can be set
            //
            TrTRACE(NETWORKING, "SetStoreAck- No place in storage bitfield");

            SendReadAck();
            ASSERT(m_wAckRecoverNo == 0);
        }

        if (m_wAckRecoverNo == 0)
        {
            //
            // Bit field must be zero if the base naumber is not set
            //
            ASSERT(m_dwAckRecoverBitField == 0);

            m_wAckRecoverNo = DWORD_TO_WORD(DWORD_PTR_TO_DWORD(wStoredAckNo));
            TrTRACE(NETWORKING, "SetStoreAck- Set Recover base number m_wAckRecoverNo = %ut", (DWORD)m_wAckRecoverNo);

            //
            // try to cancel send acknowledge timer, and set a new one with shorter period.
            // If cancel failed, it means that the scheduler is already expired. In such a case
            // only set a new timer
            //
            if (!ExCancelTimer(&m_SendAckTimer))
            {
                ++m_nSendAckSchedules;
                AddRef();
            }

            m_fSendAck = TRUE;

            ExSetTimer(&m_SendAckTimer, CTimeDuration::FromMilliSeconds(m_dwSendStoreAckTimeout));
            return;
        }

        ASSERT(STORED_ACK_BITFIELD_SIZE >= (wStoredAckNo - m_wAckRecoverNo));

        m_dwAckRecoverBitField |= (1 << (wStoredAckNo - m_wAckRecoverNo -1));
        TrTRACE(NETWORKING, "SetStoreAck- Storage ack. Base %ut, BitField %xh", m_wAckRecoverNo, m_dwAckRecoverBitField);
    }

    /*====================================================

    CSockTransport::UpdateAcknowledgeNo

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/
    void
    CSockTransport::UpdateAcknowledgeNo(IN CQmPacket* pPkt)
    {
        //
        // Increment the packet no. on the session
        //
        m_wSendPktCounter++;
        if (m_wSendPktCounter == 0)
        {
            m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;
            m_wSendPktCounter++;
        }
        pPkt->SetAcknowldgeNo(m_wSendPktCounter);

        if (pPkt->IsRecoverable())
        {
            m_wStoredPktCounter++;
            if (m_wStoredPktCounter == 0)
            {
                ++m_wStoredPktCounter;
            }
            pPkt->SetStoreAcknowldgeNo(m_wStoredPktCounter);
        }

        TrTRACE(NETWORKING, "Update Acknowledge Numbers. m_wSendPktCounter %d , m_wStoredPktCounter %d", m_wSendPktCounter,m_wStoredPktCounter);

    }

    /*====================================================

    IsValidAcknowledge

        The function returnes TRUE if the received acknowledge number
        is valid. FALSE otherwise.

    Arguments:
        listUnackedPkts - list of un-acked packets
        wAckNumber - Received acknowledge number

    Return Value: TRUE is valid, FALSE otherwise

    =====================================================*/
    BOOL IsValidAcknowledge(CList<CQmPacket *, CQmPacket *&> & listUnackedPkts,
                            WORD wAckNumber)
    {
        BOOL fRet = FALSE;

        if (!listUnackedPkts.IsEmpty())
        {
            //
            // Get the Acknowledge number of the first packet and of the last
            // packet.
            //
            WORD wStartAck = (listUnackedPkts.GetHead())->GetAcknowladgeNo();
            WORD wEndAck = (listUnackedPkts.GetTail())->GetAcknowladgeNo();

            if (wEndAck >= wStartAck)
            {
                fRet = (wAckNumber >= wStartAck) && (wEndAck >= wAckNumber);
            }
            else
            {
                fRet = (wAckNumber >= wStartAck) || (wEndAck >= wAckNumber);
            }

            TrTRACE(NETWORKING, "IsValidAcknowledge:: Start %d, End %d, Ack No. %d, IsValid %d", wStartAck, wEndAck, wAckNumber, fRet);
        }
        return fRet;
    }

    /*====================================================

    CSockTransport::HandleAckPacket

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void CSockTransport::HandleAckPacket(CSessionSection * pcSessionSection)
    {
        CQmPacket* pPkt;
        POSITION  posInList;
        POSITION  posCurrent;

        CS lock(m_cs);

        //
        // if session sending was susspended utill
        // receiving an ack, resume it.
        //
        if (m_fSessionSusspended)
        {
            HRESULT rc;

            rc = ResumeSendSession();
            if (FAILED(rc))
            {
                return;
            }
        }

        //
        // Get Synchronization Numbers
        //
        WORD wSyncAckSequenceNo, wSyncAckRecoverNo;

        pcSessionSection->GetSyncNo(&wSyncAckSequenceNo,
                                    &wSyncAckRecoverNo);
        //
        // Print debug information
        //
        TrWARNING(NETWORKING,
                 "ACKINFO: Get Acknowledge packet from %ls. (time %d) \
                   \n\t\tm_wAckSequenceNo %d\n\t\tm_wAckRecoverNo %d\n\t\tm_wAckRecoverBitField 0x%x\n\t\tm_wSyncAckSequenceNo %d\n\t\tm_wSyncAckRecoverNo %d\n\t\tm_wWinSize %d\n\t\t",
                  GetStrAddr(),
                  GetTickCount(),
                  pcSessionSection->GetAcknowledgeNo(),
                  pcSessionSection->GetStorageAckNo(),
                  pcSessionSection->GetStorageAckBitField(),
                  wSyncAckSequenceNo,
                  wSyncAckRecoverNo,
                  pcSessionSection->GetWindowSize());

        TrTRACE(NETWORKING, "Get Acknowledge packet from %ls", GetStrAddr());

        //
        // Synchronization check
        //
        if (!IsDisconnected())
        {
            if ((wSyncAckSequenceNo != m_wUnAckRcvPktNo) ||
                (wSyncAckRecoverNo != m_wUnackStoredPktNo))
            {
                TrERROR(NETWORKING, "SyncAckSequenceNo: Expected - %u Received - %u",m_wUnAckRcvPktNo,wSyncAckSequenceNo);
                TrERROR(NETWORKING, "SyncAckRecoverNo: Expected - %u Received - %u", m_wUnackStoredPktNo,wSyncAckRecoverNo);
                Close_Connection(this, L"Un-synchronized Acknowledge number");
                return;
            }
        }
        //
        // Update the other side window size
        //
    #ifdef _DEBUG
        if (m_wRecvWindowSize != pcSessionSection->GetWindowSize())
        {
            TrTRACE(NETWORKING, "Update SenderWindowSize. The new Window Size: %d", pcSessionSection->GetWindowSize());

        }
    #endif

    	if (pcSessionSection->GetWindowSize() == 0)
    	{
			TrERROR(NETWORKING, "Ack Packet is not valid");
			ASSERT_BENIGN(("Ack Packet is not valid",0));
            Close_Connection(this, L"Ack Packet is not valid");
            return;
		}
        m_wRecvWindowSize = pcSessionSection->GetWindowSize();

        //
        // Look for the packet in the list of unacknowledged packets
        //
        TrWARNING(NETWORKING, "READACK: Looking for %u in Express unAcked packet list", pcSessionSection->GetAcknowledgeNo());

        if (IsValidAcknowledge(m_listUnackedPkts, pcSessionSection->GetAcknowledgeNo()))
        {
            WORD wPktAckNo;

            posInList = m_listUnackedPkts.GetHeadPosition();
            do
            {
                if (posInList == NULL)
                {
                    //
                    // BUGBUG: after RTM it should be removed
                    //
                    ASSERT(posInList);
                    break;
                }

                posCurrent = posInList;
                pPkt = m_listUnackedPkts.GetNext(posInList);
                wPktAckNo = pPkt->GetAcknowladgeNo();
                

                OBJECTID MessageId;
                pPkt->GetMessageId(&MessageId);
                TrTRACE(NETWORKING, "READACK: Removed message in PktAcked: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());
                TrTRACE(NETWORKING, "READACK: %d Packet have not been acked yet", GetSendUnAckPacketNo());
                TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);

                if (pPkt->IsRecoverable())
                {
                    if ( pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
                    {
                        //
                        // Ordered packet on the sender node: resides in a separate list in COutSeq
                        //
                        TrTRACE(NETWORKING, "READACK: Added message in NeedAck to Transaction list waiting to order ack: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());
                        g_OutSeqHash.PostSendProcess(pPkt);
                    }
                    else
                    {
                        TrTRACE(NETWORKING, "READACK: Added message to Storage list in NeedAck: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());
                        m_listStoredUnackedPkts.AddTail(pPkt);
                    }
                }
                else
                {
      		     //
                    // Update the duplicate message map. For FRS, we want to allow getting
                    // a duplicate message in order to try alternative route
                    //
                    DpRemoveMessage(*pPkt);

				    QmAcFreePacket(
							   	   pPkt->GetPointerToDriverPacket(),
					   			   0,
				   			       eDeferOnFailure);
                    delete pPkt;
                }

	     		//
				// Remove the packet from the list
				//
				m_listUnackedPkts.RemoveAt(posCurrent);

            }
            while (wPktAckNo != pcSessionSection->GetAcknowledgeNo());
        }
        else
        {
            TrTRACE(NETWORKING, "READACK: Out of order Ack Packet - O.K");
        }
        //
        // Handle Storage Ack
        //
        WORD wBaseAckNo = pcSessionSection->GetStorageAckNo();
        if ( wBaseAckNo != 0)
        {
            TrWARNING(NETWORKING, "READACK: Looking for  Storage Ack. Base %u,  BitField %x",pcSessionSection->GetStorageAckNo(), pcSessionSection->GetStorageAckBitField());

            posInList = m_listStoredUnackedPkts.GetHeadPosition();
            int  i = 0;

            while (posInList != NULL)
            {
                posCurrent = posInList;
                pPkt = m_listStoredUnackedPkts.GetNext(posInList);

                OBJECTID MessageId;
                pPkt->GetMessageId(&MessageId);
                TrTRACE(NETWORKING, "HandleAckPacket: Next packet to analyze: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());

    			//
    			// Here we treat the case when wBaseAckNo is less than pPkt->GetStoreAcknowledgeNo()
    			// It can happen if there was transacted message not entering the list of waiters for the storage ack
    			//
                // Calculate the next Acking Packet number
                //
                while (wBaseAckNo < pPkt->GetStoreAcknowledgeNo() && (i < STORED_ACK_BITFIELD_SIZE))
                {
                    if (pcSessionSection->GetStorageAckBitField() & (1 << i))
                    {
                        wBaseAckNo = numeric_cast<WORD>
                                    (pcSessionSection->GetStorageAckNo()+i+1) ;

    				    if (wBaseAckNo >= pPkt->GetStoreAcknowledgeNo())
    				    {
    				 	   break;
    				    }
                    }
    			    i++;
                }

                TrTRACE(NETWORKING, "HandleAckPacket: next storage ack to analyze: %u (i=%d) in Storage PktAcked", wBaseAckNo, i);

                if (wBaseAckNo == pPkt->GetStoreAcknowledgeNo())
                {
                    TrTRACE(NETWORKING, "READACK: Removed message in Storage PktAcked: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());

                    m_listStoredUnackedPkts.RemoveAt(posCurrent);

                    //
                    // Packet was sent successfully to the next hop
                    // Deleting packet, except of the ordered packet on the source node
                    //

                    if ( !(pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid())))
                    {
                        TrTRACE(NETWORKING, "HandleAckPacket: ACFreePacket: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());

                        //
                        // Update the duplicate message map. For FRS, we want to allow getting
                        // a duplicate message in order to try alternative route
                        //
                        DpRemoveMessage(*pPkt);

					    QmAcFreePacket(
								   	   pPkt->GetPointerToDriverPacket(),
						   			   0,
					   			       eDeferOnFailure);
                        delete pPkt;
                    }
                }
            }
        }
    }

    /*====================================================

    CSockTransport::CheckForAck

    Arguments:

    Return Value:

    Thread Context: Scheduler

    =====================================================*/
    void CSockTransport::CheckForAck()
    {
        POSITION  posInList;
        CQmPacket* pPkt;

        CS lock(m_cs);

        ASSERT(m_fCheckAckReceivedScheduled);
        m_fCheckAckReceivedScheduled = FALSE;

        if (IsConnectionClosed())
        {
            //
            // Connection already closed. Decrement Session refernce count
            //
            Release();
            return;
        }

        TrTRACE(NETWORKING, "CHECKFORACK: m_fRecvAck = %d (time %ls, %d)", m_fRecvAck, _tstrtime(tempBuf), GetTickCount());
        //
        // Check if there are any packets waiting for acknowledgment
        //
        posInList = m_listUnackedPkts.GetHeadPosition();
        if (posInList != NULL)
        {
            //
            // If no sent packets have been acknowledged during the lifespan
            // of the timer, the session is no longer valid
            //
            pPkt = m_listUnackedPkts.GetNext(posInList);
            //
            // Ack number cant be zero. We take to it when the the Acknowledge number is round.
            //
            ASSERT(pPkt->GetAcknowladgeNo());
            if ((m_wPrevUnackedSendPkt == pPkt->GetAcknowladgeNo()) && !m_fRecvAck)
            {
                TrTRACE(NETWORKING, "CHECKFORACK: Packet on session %ls have not been acknowledged. \n\t \
                             Last Unacked %u. Current Packet number %u (time %ls)",GetStrAddr(), m_wPrevUnackedSendPkt, pPkt->GetAcknowladgeNo(), _tstrtime(tempBuf));
                TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);

                Close_Connection(this, L"Packet have not been acknowledged");
                Release();

                return;
            }
        }

        //
        // Mark the session as non receive ack
        //
        m_fRecvAck = FALSE;

        //
        // Store the ID of the first unacknowledged packet in the list
        //
        if (!m_listUnackedPkts.IsEmpty())
        {
            posInList = m_listUnackedPkts.GetHeadPosition();
            pPkt = m_listUnackedPkts.GetNext(posInList);
            m_wPrevUnackedSendPkt = pPkt->GetAcknowladgeNo();

            //
            // There is another message that wait for acknowledge. Restart the timer to check for
            // acknowledgments
            //
            ExSetTimer(&m_CheckAckReceivedTimer, CTimeDuration::FromMilliSeconds(m_dwAckTimeout));
            m_fCheckAckReceivedScheduled = TRUE;
        }
        else
        {
            m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;

            //
            // There is no more messages that wait for ack. Don't reschedule checkAck
            //
            Release();
        }

        TrWARNING(NETWORKING, "ACKINFO: Set the m_wPrevUnackedSendPkt on session %ls to  %d. (time %d)",GetStrAddr(), m_wPrevUnackedSendPkt, GetTickCount());

    }

    /*====================================================

    CTransportBase::AddQueueToSessionGroup

    Arguments: pQueue - Pointer to queue object

    Return Value: None. Throws an exception.

    Thread Context:

    =====================================================*/
    void CTransportBase::AddQueueToSessionGroup(CQueue* pQueue) throw(bad_alloc)
    {
        CS lock(m_cs);


	    if (m_SessGroup == NULL)
	    {
			try
			{
				//
    	        // Create a new group
    	        //
    	        m_SessGroup = new CQGroup;
                m_SessGroup->InitGroup(this, TRUE);
			}
			catch (const exception&)
  	        {
  	            //
  	            // Close the session
  	            //
  	            Close_Connection(this, L"Creation of new group failed");
  	            LogIllegalPoint(s_FN, 780);
  
  	     		//
  	            // Creation of new group for the session failed. Move the queue
  	            // to waiting group, such the QM doesn't try immediately to create
  	            // a new session and close the connection
  	            //
  	            pQueue->SetSessionPtr(NULL);
  				SessionMgr.AddWaitingQueue(pQueue);
  	            throw;
  	        }
    

			//
	        // If the session is not active yet, don't create a get request. We do it
	        // later when the session establishment connection is completed
	        //
	        if (GetSessionStatus() == ssActive)
	        {
	            //
	            // Create a get request from new group. It will decrement on qmthrd
	            // when the session is closed, or the session is suspended. (no new
	            // get request is produced)
	            //
	            HRESULT hr = GetNextSendMessage();
	            if (FAILED(hr))
	            {
		            LogHR(hr, s_FN, 182);
		            throw bad_hresult(hr);
	            }
	        }
		}

	    CQGroup::MoveQueueToGroup(pQueue, m_SessGroup);

		//
	    // If the seeion is active we succeeded to get a session to the queue
	    // and therfore we clear the rety index. If the session has not been established
	    // don't clear it until the session becomes active
	    //
	    if (GetSessionStatus() == ssActive)
	    {
	         pQueue->ClearRoutingRetry();
	    }
	}
    	      
    /*====================================================
    =====================================================*/

    #define HDR_READ_STATE              1
    #define USER_HEADER_MSG_READ_STATE  2
    #define USER_MSG_READ_STATE         3
    #define READ_ACK_READ_STATE         4

    #define BASE_PACKET_SIZE 1024
    #define MAX_WRITE_SIZE  (16*1024)


    VOID WINAPI CSockTransport::SendDataFailed(EXOVERLAPPED* pov)
    {
        P<QMOV_WriteSession> po = CONTAINING_RECORD (pov, QMOV_WriteSession, m_qmov);

        DWORD rc = pov->GetStatus();
    	UNREFERENCED_PARAMETER(rc);


        Close_Connection(po->Session(), L"Write packet to socket Failed");

        //
        // decrement session refernce count
        //
        (po->Session())->Release();
    }


    VOID WINAPI CSockTransport::SendDataSucceeded(EXOVERLAPPED* pov)
    {
        ASSERT(SUCCEEDED(pov->GetStatus()));

        TrTRACE(NETWORKING, "%x: SendData Succeeded. time %d", GetCurrentThreadId(), GetTickCount());

        P<QMOV_WriteSession> po = CONTAINING_RECORD (pov, QMOV_WriteSession, m_qmov);

        (po->Session())->WriteCompleted(po);
    }



      /*====================================================

    CSockTransport::WriteCompleted()

    Arguments:

    Return Value:

    Thread Context: Session

    Asynchronous write completion routine.
    Called when some bytes are written into a socket. This routine
    is actually a state machine. Waiting for all the bytes from a
    certain state to be written, and then upon the current state deciding
    what to do next.

    =====================================================*/

    void
    CSockTransport::WriteCompleted(
        QMOV_WriteSession* po
        )
    {
        ASSERT(po != NULL);
        ASSERT(po->Session() == this);

        R<CSockTransport> pSess = this;

        TrTRACE(NETWORKING, "Write to socket %ls Completed. Wrote %d bytes", GetStrAddr(), po->WriteSize());

        //
        //  we've Written to the socket. Mark the session in use
        //
        SetUsedFlag(TRUE);

        //
        // Call write completion routine
        //
        if(po->UserMsg())
        {
            WriteUserMsgCompleted(po);
        }
    }


    /*====================================================

    CSockTransport::WriteUserMsgCompleted

    Arguments:
        po - address of structure with I/O information

    Return Value: none

    Thread Context: Session

    Asynchronous completion routine. Called when Send is completed.

    =====================================================*/
    void CSockTransport::WriteUserMsgCompleted(IN QMOV_WriteSession* po)
    {
        CS lock(m_cs);

        //
        // Send Report message if needed. First check that the session
        // wasn't closed.
        //
        if (GetSessionStatus() == ssActive)
        {
            TCHAR szAddr[30];

            TA2StringAddr(GetSessionAddress(), szAddr, 30);
            m_MsgInfo.SendReportMessage(szAddr);
        }

        //
        // Update performance counters
        //
        if (m_pStats.get() != NULL)
        {
            m_pStats->UpdateMessagesSent();
            m_pStats->UpdateBytesSent(po->WriteSize());
        }

        if (!IsSusspendSession())
        {
            //
            // Create a get request from group
            //
            TrTRACE(NETWORKING, "Session Get new message from group 0x%p. (time %ls)", GetGroupHandle(),  _tstrtime(tempBuf));
            GetNextSendMessage();
        }
        else
        {
            TrWARNING(NETWORKING, "Session to %ls was suspended due max unacked packet. (time %ls)", GetStrAddr(),  _tstrtime(tempBuf));
        }
     }


    void CSockTransport::ReportErrorToGroup()
    {
    	CS lock(m_cs);

        CQGroup* pGroup = GetGroup();
    	if(pGroup == NULL)
    		return;

    	pGroup->OnRetryableDeliveryError();
    }

    /*====================================================

    CSockTransport::WriteToSocket

    Arguments:
        po - address of structure with I/O information

    Return Value: none

    Thread Context: Session


    =====================================================*/

    HRESULT CSockTransport::WriteToSocket(QMOV_WriteSession* po)
    {
    	DWORD dwErrorCode;

        AddRef();

        SetUsedFlag(TRUE);

    	try
    	{
    		DWORD writeSize = po->WriteSize();
    		m_connection->Send(po->Buffers(), numeric_cast<DWORD>(po->NumberOfBuffers()), &po->m_qmov);
    		TrTRACE(NETWORKING, "Write %d bytes to Session %ls", writeSize, GetStrAddr());
    		return MQ_OK;
    	}
    	catch(const bad_alloc&)
    	{
    		dwErrorCode = ERROR_NO_SYSTEM_RESOURCES;
    	}
    	catch(const bad_win32_error& e)
    	{
    		dwErrorCode = e.error();
    	}
	    catch (const exception&)
    	{
    		dwErrorCode = ERROR_NOT_READY;
    	}

       	LogNTStatus(dwErrorCode, s_FN, 71);
    	TrTRACE(NETWORKING, "Failed to write to session %ls. %!winerr!", GetStrAddr(), dwErrorCode);

        //
        // Decrement the window size
        //
        if (dwErrorCode == ERROR_NO_SYSTEM_RESOURCES || dwErrorCode == ERROR_WORKING_SET_QUOTA )
    	{
            SessionMgr.SetWindowSize(1);
    	}

        //
        // Close the connection and move the queues to non-active state.
        //
        Close_Connection(this, L"Write on socket failed.");
        //
        // Decrement reference count. the reference count is increment before
        // writing to the socket. since the write failed we decrement the
        // refernce count here.
        //
        Release();
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    /*====================================================

    CSockTransport::SendInternalPacket

    Arguments:
        lpWriteBuffer - pointer to buffer to be sent
        dwWriteSize  - size of buffer

    Return Value: none

    Thread Context: Session


    =====================================================*/

    HRESULT
    CSockTransport::SendInternalPacket(PVOID    lpWriteBuffer,
                                       DWORD    dwWriteSize
                                      )
    {
        P<QMOV_WriteSession> po = NULL;
        P<VOID>  lpBuf = lpWriteBuffer;
        HRESULT hr;

        try
        {
            po = new QMOV_WriteSession(this, FALSE);
            ASSERT(po != NULL);
            po->AppendSendBuffer(lpBuf, dwWriteSize, TRUE);
            //
            // In case of send failure QMOV_WriteSession destrutor will free the buffer
            //
            lpBuf.detach();
        }
        catch(const bad_alloc&)
        {
            SessionMgr.SetWindowSize(1);
            Close_Connection(this, L"Insufficent resources. Can't issue send request");

            LogIllegalPoint(s_FN, 790);
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 80);
        }

        hr = WriteToSocket(po);

        if (SUCCEEDED(hr))
        {
    	    po.detach();
        }

        return LogHR(hr, s_FN, 100);
    }
    /*====================================================

      ReadHeaderCompleted

    Arguments:     po - pointer to Read Session operation overlapped structure

    Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

    ======================================================*/
    HRESULT WINAPI CSockTransport::ReadHeaderCompleted(IN QMOV_ReadSession*  po)
    {
        CBaseHeader *       pcBaseHeader;
        //
        // We just read the header.
        //
        pcBaseHeader = po->pPacket;

        //
        // Check if packet signature is correct
        //
        try
        {
		    pcBaseHeader->SectionIsValid(CSingelton<CMessageSizeLimit>::get().Limit());
        }
	    catch (const exception&)
	    {
    		//
    		// Close the session & decrement session refernce count
    		//
    		Close_Connection(po->pSession, L"Base Header is not valid");
    		(po->pSession)->Release();
    		return LogHR(MQ_ERROR, s_FN, 110);
    	}


        TrTRACE(NETWORKING, "Begin read packet from %ls. Packet Type %d, Packet Size %d",
                (po->pSession)->GetStrAddr(), pcBaseHeader->GetType(), pcBaseHeader->GetPacketSize());
        //
        // Check if the packet is a read acknowledgment
        //
        if (pcBaseHeader->GetType() == FALCON_INTERNAL_PACKET)
        {

            //
            // set the packet size should be read
            //
            po->dwReadSize  = pcBaseHeader->GetPacketSize();

            //
            // Check if the current buffer big enough to hold the whole packet
            // If no, allocate a new buffer, copy the packet base header and free
            // the previous buffer
            //
            if  (pcBaseHeader->GetPacketSize() > BASE_PACKET_SIZE)
            {
                po->pbuf = new UCHAR[pcBaseHeader->GetPacketSize()];
                ASSERT(pcBaseHeader->GetPacketSize() >= po->read);
                memcpy(po->pbuf,pcBaseHeader,po->read);
                delete [] (UCHAR*)pcBaseHeader;
            }
            //
            // Set the next state to be Read Internal Packet Is completed
            //
            po->lpReadCompletionRoutine = ReadInternalPacketCompleted;
        }
        //
        // Otherwise, the packet contains a user message
        //
        else
        {
            po->dwReadSize = min(BASE_PACKET_SIZE,pcBaseHeader->GetPacketSize());
            po->lpReadCompletionRoutine = ReadUsrHeaderCompleted;
        }

        return MQ_OK;
    }

    /*====================================================

      ReadInternalPacketCompleted

      Arguments:     po - pointer to Read Session operation overlapped structure

      Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

    ======================================================*/

    HRESULT WINAPI CSockTransport::ReadInternalPacketCompleted(IN QMOV_ReadSession*  po)
    {

        AP<UCHAR> pReadBuff = po->pbuf;

        //
        //  very important - we should set buffer to NULL to make sure it will not
        //  be freed twice by the caller  if ACAllocatePacket fails.
        //
        po->pbuf = NULL;

        //
        // Process the internal message
        //
        (po->pSession)->HandleReceiveInternalMsg(reinterpret_cast<CBaseHeader*>(pReadBuff.get()));

        //
        // Begin to read next packet
        //
        po->lpReadCompletionRoutine = ReadHeaderCompleted;
        po->pbuf = new UCHAR[BASE_PACKET_SIZE];

        po->dwReadSize = sizeof(CBaseHeader);
        po->read = 0;

        return MQ_OK;
    }

    /*====================================================

      ReadAckCompleted

      Arguments:     po - pointer to Read Session operation overlapped structure

      Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

    ======================================================*/

    HRESULT WINAPI CSockTransport::ReadAckCompleted(IN QMOV_ReadSession*  po)
    {
        //
        // Process the acknowledgment
        //
        po->pSession->HandleAckPacket( po->pSessionSection);
        delete[] po->pPacket;
        po->pPacket = NULL;

        //
        // Begin to read next packet
        //
        po->lpReadCompletionRoutine = ReadHeaderCompleted;
        po->pbuf = new UCHAR[BASE_PACKET_SIZE];

        po->dwReadSize = sizeof(CBaseHeader);
        po->read = 0;

        return MQ_OK;
    }

    /*====================================================

      ReadUserMsgCompleted

      Arguments:     po - pointer to Read Session operation overlapped structure

      Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

    ======================================================*/
    HRESULT WINAPI CSockTransport::ReadUserMsgCompleted(IN QMOV_ReadSession*  po)
    {
        CBaseHeader* pBaseHeader = po->pPacket;
        ASSERT(po->dwReadSize == pBaseHeader->GetPacketSize());

        CUserHeader* pUserHeader = pBaseHeader->section_cast<CUserHeader*>(pBaseHeader->GetNextSection());
        QUEUE_FORMAT DestinationQueue;

        pUserHeader->GetDestinationQueue(&DestinationQueue);

        //
        //  If this packet arrived into the direct destination queue,
        //
        if (DestinationQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
        {
            // Keep sender's address in DestGUID field
            const TA_ADDRESS *pa = (po->pSession)->GetSessionAddress();
            ASSERT(pa->AddressType != FOREIGN_ADDRESS_TYPE &&
                  (pa->AddressLength <= sizeof(GUID) - 2*sizeof(USHORT)));

            pUserHeader->SetAddressSourceQM(pa);
        }

        //
        // Check If session section included
        //
        BOOL fSessionIncluded = pBaseHeader->SessionIsIncluded();
        //
        // Clear session included bit. We need it for FRS, since
        // packet is re-sent
        //
        pBaseHeader->IncludeSession(FALSE);

        //
        // Put Packet in AC driver
        //
        try
        {
	        (po->pSession)->HandleReceiveUserMsg(pBaseHeader, po->pDriverPacket);
        }
        catch (const exception&)
        {
        	TrERROR(NETWORKING, "Packet is not valid");
  	 		ASSERT_BENIGN(0);
	  		Close_Connection(po->pSession, L"Packet is not valid");
	  		(po->pSession)->Release();
	  		return LogHR(MQ_ERROR, s_FN, 320);
  		}

        if (fSessionIncluded)
        {
            //
            // Begin to read the Session Section
            //
            po->lpReadCompletionRoutine = ReadAckCompleted;
            po->pbuf  = new UCHAR[sizeof(CSessionSection)];
            po->dwReadSize  = sizeof(CSessionSection);
            po->read  = 0;
        }
        else
        {
            //
            // Begin to read next packet
            //
            po->lpReadCompletionRoutine = ReadHeaderCompleted;
            po->pbuf = new UCHAR[BASE_PACKET_SIZE];
            po->dwReadSize = sizeof(CBaseHeader);
            po->read = 0;
        }

        return MQ_OK;
    }


    /*====================================================

      SetAbsoluteTimeToQueue

      Arguments:     pcBaseHeader - pointer to Read BaseHeader section

     The function replace the relative time that send with the packet on the net
     with absolute time.

    ======================================================*/

    void SetAbsoluteTimeToQueue(IN CBaseHeader* pcBaseHeader)
    {
        //
        // Set Absolute timeout. Change the relative time to absolute
        //
        DWORD dwTimeout = pcBaseHeader->GetAbsoluteTimeToQueue();

        if(dwTimeout != INFINITE)
        {
            DWORD ulAbsoluteTimeToQueue = MqSysTime() + dwTimeout;
            if(ulAbsoluteTimeToQueue < dwTimeout)
            {
                //
                // Overflow, timeout too large.
                //
                ulAbsoluteTimeToQueue = LONG_MAX;
            }
            ulAbsoluteTimeToQueue = min(ulAbsoluteTimeToQueue,  LONG_MAX);
            pcBaseHeader->SetAbsoluteTimeToQueue(ulAbsoluteTimeToQueue);
        }
    }


    /*====================================================

      ReadUsrHeaderCompleted

      Arguments:     po - pointer to Read Session operation overlapped structure

      Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

    ======================================================*/
    HRESULT WINAPI CSockTransport::ReadUsrHeaderCompleted(IN QMOV_ReadSession*  po)
    {
        AP<UCHAR> pReadBuff = po->pbuf;
        CBaseHeader* pcBaseHeader = po->pPacket;

        //
        //  very important - we should set buffer to NULL to make sure it will not
        //  be freed twice by the caller  if ACAllocatePacket fails.
        //
        //
        po->pPacket = NULL;

        CUserHeader* pcUserHeader = NULL;
    	try
    	{
       		pcUserHeader = pcBaseHeader->section_cast<CUserHeader*>(pcBaseHeader->GetNextSection());
       		pcUserHeader->SectionIsValid((PCHAR)pcBaseHeader + po->read);
    	}
    	catch (const exception&)
    	{
            TrERROR(NETWORKING, "Base Header is not valid");

    		ASSERT_BENIGN(0);
    		//
    		// Close the session & decrement session refernce count
    		//
    		Close_Connection(po->pSession, L"Base Header is not valid");
    		(po->pSession)->Release();
    		return LogHR(MQ_ERROR, s_FN, 310);
    	}

        //
        // Allocate a shared memory, and copy the fist bytes in it
        //

        ACPoolType acPoolType = ptReliable;
        if(pcUserHeader->GetDelivery() == MQMSG_DELIVERY_RECOVERABLE)
        {
            acPoolType = ptPersistent;
        }

        //
        // Check if target queue is the notification queue (private$\notify_queue$).
        //

        QUEUE_FORMAT DestinationQueue;

        pcUserHeader->GetDestinationQueue(&DestinationQueue);

        BOOL fCheckMachineQuota = !QmpIsDestinationSystemQueue(DestinationQueue);

        CACPacketPtrs packetPtrs = {NULL, NULL};

        DWORD dwPktSize = pcBaseHeader->GetPacketSize() ;
        if (CSessionMgr::m_fAllocateMore)
        {
            dwPktSize = ALIGNUP4_ULONG(ALIGNUP4_ULONG(dwPktSize) + sizeof(GUID));
        }

        HRESULT hr = QmAcAllocatePacket(
                        g_hAc,
                        acPoolType,
                        dwPktSize,
                        packetPtrs,
                        fCheckMachineQuota
                        );

        if (FAILED(hr))
        {

            TrERROR(NETWORKING, "No more resources in AC driver. Error %xh", hr);
            //
            // No more resources in AC driver.
            // Decrease the session window size. This caused the sender to slow down the
            // packet sending and allow the driver to overcome this situation.
            //
            SessionMgr.SetWindowSize(1);
            // We do not allow more read on this session. The client side
            // continue to write to the session but doesn't get an acknowledge.
            // After ACK timeout the client closes the session and try to open
            // it again. If sources are freed the Server side is ready to get packets
            // otherwise they refused.
            //
            (po->pSession)->Release();
            return LogHR(hr, s_FN, 120);
        }
        po->pPacket = packetPtrs.pPacket;
        po->pDriverPacket = packetPtrs.pDriverPacket;

        //
	  	// Need to set the completion routine anyway so if something fail laiter
  		// the ReadCompleated func will know to call ACFreePacket instead of
	  	// delete after this point
  		//
        po->lpReadCompletionRoutine = ReadUserMsgCompleted;

        //
        // Set Absolute timeout. Change the relative time to absolute
        //
        SetAbsoluteTimeToQueue(pcBaseHeader);
        //
        // Copy the packet and update the QM_OVERLAPPED structure for
        // reading the rest of the packet
        //
        memcpy(po->pPacket,pcBaseHeader,po->read);

        if (po->read == pcBaseHeader->GetPacketSize())
        {
            //
            // Whole packet was read. Go To USER_MSG_READ_STATE
            //
            hr = ReadUserMsgCompleted(po);
            return LogHR(hr, s_FN, 130);
        }

        ASSERT((LONG)(po->read) < (LONG) (pcBaseHeader->GetPacketSize())) ;
        //
        // Read the whole packet
        //
        po->dwReadSize = pcBaseHeader->GetPacketSize();

        return MQ_OK;
    }


    VOID WINAPI CSockTransport::ReceiveDataFailed(EXOVERLAPPED* pov)
    {
        long rc = pov->GetStatus();
        DBG_USED(rc);

        ASSERT((rc == STATUS_CANCELLED) ||
               (rc ==  STATUS_NETWORK_NAME_DELETED)  ||
               (rc ==  STATUS_LOCAL_DISCONNECT)      ||
               (rc ==  STATUS_REMOTE_DISCONNECT)     ||
               (rc ==  STATUS_ADDRESS_CLOSED)        ||
               (rc ==  STATUS_CONNECTION_DISCONNECTED) ||
               (rc ==  STATUS_CONNECTION_RESET)      ||
               (GetBytesTransfered(pov) == 0));

        TrWARNING(NETWORKING, "%x: ReceiveData FAILED, Error %ut. time %d",GetCurrentThreadId(), rc, GetTickCount());

        P<QMOV_ReadSession> pr = CONTAINING_RECORD (pov, QMOV_ReadSession, qmov);

        Close_Connection(pr->pSession, L"Read packet from socket Failed");
        (pr->pSession)->Release();

        //
        // If we arrive here the read failed from any reason.
        // delete the temporary buffer that is used for read
        //
        if (pr->lpReadCompletionRoutine == ReadUserMsgCompleted)
        {
            //
            // free the AC buffer
            //
		    QmAcFreePacket(
					   	   pr->pDriverPacket,
			   			   0,
		   			       eDeferOnFailure);
        }
        else
        {
            delete[] pr->pbuf;
        }
    }


    VOID WINAPI CSockTransport::ReceiveDataSucceeded(EXOVERLAPPED* pov)
    {
        ASSERT(SUCCEEDED(pov->GetStatus()));
        if (GetBytesTransfered(pov) == 0)
        {
            ReceiveDataFailed(pov);
            return;
        }

        TrTRACE(NETWORKING, "%x: ReceiveData Succeeded. time %d", GetCurrentThreadId(), GetTickCount());

        QMOV_ReadSession* pr = CONTAINING_RECORD (pov, QMOV_ReadSession, qmov);

        (pr->pSession)->ReadCompleted(pr);
    }

    /*====================================================

    CSockTransport::ReadCompleted()

    Arguments:

    Return Value:

    Thread Context: Session

    Asynchronous read completion routine.
    Called when some bytes are read into a buffer. This routine
    is actually a state machine. Waiting for all the bytes from a
    certain state to be read, and then upon the current state deciding
    what to do next.

    =====================================================*/

    void
    CSockTransport::ReadCompleted(
        QMOV_ReadSession*  po
        )
    {
        ASSERT(po != NULL);
        ASSERT(po->pbuf != NULL);


        HRESULT hr = MQ_OK;

        DWORD cbTransferred = GetBytesTransfered(&po->qmov);

        //
        //  we've received a packet, i.e., the session is in use
        //
        SetUsedFlag(TRUE);
        m_fRecvAck = TRUE;
        //
        // If we read user packet set the send ack flag. We need it to handle big
        // messages (3 MG) their read can take more than Ack timeout.
        //
        if (po->lpReadCompletionRoutine == ReadUserMsgCompleted)
        {
            m_fSendAck = TRUE;
        }


        po->read += cbTransferred;
        ASSERT(po->read <=  po->dwReadSize);
        //
        // Check if we read all the expected data
        //
        TrTRACE(NETWORKING, "Read Compled from session %ls,. Read %d. m_fRecvAck = %d", GetStrAddr(), po->read, m_fRecvAck);
        if(po->read == po->dwReadSize)
        {
            //
            // A buffer was completely read. Call the completed function
            // to handle the current state
            //
            TrTRACE(NETWORKING, "Read from socket Completed. Read %d bytes", po->dwReadSize);


            hr = po->lpReadCompletionRoutine(po);
        }

        //
        // Re-arm the fast acknowledge timer, since the session is active.
        // Do it at this point to insure that for the user message the acknowledge
        // number is already set. Otherwise, doing it before handling the message
        // can expire the timer before setting the acknowledge number. As a result
        // the acknowledgment will not be sent.
        //
        SetFastAcknowledgeTimer();


        if (SUCCEEDED(hr))
        {
    		
            //
            // Reissue a read until all data is received
            //
    		try
    		{
    	        DWORD ReadSize = po->dwReadSize - po->read;
    		    m_connection->ReceivePartialBuffer(po->pbuf + po->read,	ReadSize, &po->qmov);

                TrTRACE(NETWORKING, "Begin new Read phase from session %ls,. Read %d. (time %d)", GetStrAddr(), ReadSize, GetTickCount());

    			return;
    		}
    		catch(const exception&)
    		{
    			TrWARNING(NETWORKING, L"Failed to read from session %ls.", GetStrAddr());

    			Close_Connection(this, L"Read from socket Failed");
    			//
    			// decrement session refernce count
    			//
    			Release();
    		}
        }

        //
        // If we arrive here the read failed from any reason.
        // delete the temporary buffer that is used for read
        //
        if (po->lpReadCompletionRoutine == ReadUserMsgCompleted)
        {
            //
            // free the AC buffer
            //
		    QmAcFreePacket(
					   	   po->pDriverPacket,
			   			   0,
		   			       eDeferOnFailure);
        }
        else
        {
            delete[] po->pbuf;
        }
        delete po;
    }


    /********************************************************************************/
    /*                   C S o c k S e s s i o n                                    */
    /********************************************************************************/
    /*====================================================

    CSockTransport::CSockTransport

    Arguments:

    Return Value:

    Thread Context: Scheduler

    =====================================================*/
    CSockTransport::CSockTransport() :
        m_pStats(new CSessionPerfmon),
        m_FastAckTimer(SendFastAcknowledge),
        m_fCheckAckReceivedScheduled(FALSE),
        m_CheckAckReceivedTimer(TimeToCheckAckReceived),
        m_nSendAckSchedules(0),
        m_SendAckTimer(TimeToSendAck),
        m_CancelConnectionTimer(TimeToCancelConnection),
        m_fCloseDisconnectedScheduled(FALSE),
        m_CloseDisconnectedTimer(TimeToCloseDisconnectedSession)
    {
        //
        //
        //
        ClearRecvUnAckPacketNo();
        m_wUnAckRcvPktNo = 0;
        m_fSendAck = FALSE;
        m_fRecvAck = FALSE;
        m_dwLastTimeRcvPktAck = GetTickCount();
        //
        // Initialize the data write acknoledgments
        //
        m_wSendPktCounter     = 0;
        m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;
        //
        // initialize the data read Stored acknowledgments
        //
        m_wUnackStoredPktNo = 0;
        //
        // Initialize Data write stored acknowledge
        //
        TrTRACE(NETWORKING, "New CSockSession Object, m_wAckRecoverNo = 0");

        m_wStoredPktCounter = 0;
        m_wAckRecoverNo = 0;
        m_dwAckRecoverBitField = 0;
        m_lStoredPktReceivedNoAckedCount = 0;

        m_fSessionSusspended = FALSE;

    }

    /*====================================================

    CSockTransport::~CSockTransport

    Arguments:

    Return Value:

    =====================================================*/

    CSockTransport::~CSockTransport()
    {
        ASSERT(!m_FastAckTimer.InUse());
        ASSERT(!m_CheckAckReceivedTimer.InUse());
        ASSERT(!m_SendAckTimer.InUse());
        ASSERT(!m_CancelConnectionTimer.InUse());
        ASSERT(!m_CloseDisconnectedTimer.InUse());

    }

    /*====================================================

    CSockTransport::BeginReceive

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void CSockTransport::BeginReceive()
    {
        ASSERT(!IsConnectionClosed());

        //
        // Increment the Session refence count. We don't delete the
        // session object before the read operation completed.
        // The refernce is decrement on qmthrd when the session is closed
        // (read operation is cancled).
        //
        R<CSockTransport> ar = SafeAddRef(this);

        //
        // Begin to read next packet
        //
        P<QMOV_ReadSession> lpQmOv;
        P<UCHAR> bufautorel;
        try
        {
            lpQmOv = new QMOV_ReadSession;
            lpQmOv->pbuf = bufautorel = new UCHAR[BASE_PACKET_SIZE];

            lpQmOv->pSession =  this;
            lpQmOv->dwReadSize =sizeof(CBaseHeader);
            lpQmOv->read =      0;
            lpQmOv->lpReadCompletionRoutine =     ReadHeaderCompleted;
            //
            // Issue a read until all data is received
            //
            TrTRACE(NETWORKING, "Begin receive from socket- %ls", GetStrAddr());

            m_connection->ReceivePartialBuffer(lpQmOv->pbuf, lpQmOv->dwReadSize, &lpQmOv->qmov);

            ar.detach();
            lpQmOv.detach();
            bufautorel.detach();
        }
        catch(const exception&)
        {
            TrWARNING(NETWORKING, L"Failed to read from socket: %ls.", GetStrAddr());

            Close_Connection(this, L"Read from socket failed");

            LogIllegalPoint(s_FN, 75);
            throw;
        }
    }

    /*====================================================

    CSockTransport::NewSession


    Arguments:

    Return Value:

    Called when a new session was created

    Thread Context: Scheduler

    =====================================================*/

    void CSockTransport::NewSession(IN CSocketHandle& pSocketHandle)
    {
        TCHAR szAddr[256];
        StringCchPrintf(szAddr, TABLE_SIZE(szAddr), L"TCP: %S", inet_ntoa(*(struct in_addr *)(GetSessionAddress()->Address)));

        //
        // Create Stats structure
        //
        m_pStats->CreateInstance(szAddr);

        //
        // Optimize buffer size
        //
        int opt = 18 * 1024;
        setsockopt(pSocketHandle, SOL_SOCKET, SO_SNDBUF, (const char *)&opt, sizeof(opt));

        //
        // Optimize to no Nagling (based on registry)
        //
        extern BOOL g_fTcpNoDelay;
        setsockopt(pSocketHandle, IPPROTO_TCP, TCP_NODELAY, (const char *)&g_fTcpNoDelay, sizeof(g_fTcpNoDelay));

        //
        // Connect the socket to completion port
        //
        ExAttachHandle((HANDLE)(SOCKET)pSocketHandle);


    	ASSERT(("Connection already exist", m_connection.get() == NULL));
		m_connection = StCreateSimpleWisockConnection(pSocketHandle);
		pSocketHandle.detach();

        // set session status to connect
        SetSessionStatus(ssConnect);


        //
        // Begin read from a session
        //
        BeginReceive();
    }

    /*====================================================

    CSockTransport::NetworkConnect

    Arguments:

    Return Value:

    Thread Context: Scheduler

    =====================================================*/
    HRESULT
    CSockTransport::CreateConnection(
        IN const TA_ADDRESS* pa,
        IN const GUID* pguidQMId,
        BOOL fQuick /* = TRUE*/
        )
    {
        ASSERT(("Connection already exist", m_connection.get() == NULL));

        if (CSessionMgr::m_fUseQoS)
        {
            if (*pguidQMId == GUID_NULL)
            {
                m_fQoS = true;
            }
        }

        //
        // Keep the TA_ADDRESS format
        //
        SetSessionAddress(pa);

        ASSERT(pa->AddressType == IP_ADDRESS_TYPE);

        SOCKADDR_IN dest_in;    //Destination Address
        DWORD dwAddress;

        dwAddress = * ((DWORD *) &(pa->Address));
        ASSERT(g_dwIPPort) ;

        dest_in.sin_family = AF_INET;
        dest_in.sin_addr.S_un.S_addr = dwAddress;
        dest_in.sin_port = htons(DWORD_TO_WORD(g_dwIPPort));

        if(fQuick)
        {
            BOOL f = FALSE;

            if (CSessionMgr::m_fUsePing)
            {
                f = ping((SOCKADDR*)&dest_in, PING_TIMEOUT);
            }

            if (!f)
            {
                TrWARNING(NETWORKING, "::CreateConnection- ping to %ls Failed.", GetStrAddr());
    			
    		    return LogHR(MQ_ERROR, s_FN, 140);
            }
        }

    	SOCKET socket;
    	try
    	{
    		socket = QmpCreateSocket(m_fQoS);
    	}
    	catch(const bad_win32_error&)
    	{
    		return MQ_ERROR;
        }

        CSocketHandle s = socket;
        //
        // On a cluster system, use GetBindingIPAddress() to get the binding IP
        // this is done so the connection will be made from the choosen IP & not
        // from randomaly IP choosen one by winsock, we need it for the transaction
        // mechanizm to work.
        //
        if (IsLocalSystemCluster())
        {
	        sockaddr_in local;
	        local.sin_family = AF_INET;
	        local.sin_port   = 0;
	        local.sin_addr.s_addr = GetBindingIPAddress();
	        if(bind(s, (const sockaddr *)&local, sizeof(local)) == SOCKET_ERROR)
	        {
	            DWORD gle = WSAGetLastError();
	            TrERROR(NETWORKING, "bind Error: %x", gle);
   				return LogHR(MQ_ERROR, s_FN, 152);
	        }
        }

        //
        // Connect to socket
        //
        HRESULT hr = ConnectSocket(s, &dest_in, m_fQoS);
        if (FAILED(hr))
        {
    		return LogHR(hr, s_FN, 160);
        }

        //
        // Increament Session refence count. This refernce count is used for complete
        // the session establish phase. we don't want that the session is free while we
        // wait to establish connection
        //
        try
        {
            R<CSockTransport> ar = SafeAddRef(this);

            // store that this is the client side
            SetClientConnect(TRUE);

            // keep the destination QM ID
            if (!pguidQMId)
            {
                pguidQMId = &GUID_NULL;
            }

            SetQMId(pguidQMId);
            TrTRACE(NETWORKING, "::CreateConnection- Session created with %ls", GetStrAddr());

            //
            // connect the session to complition port and begin read on the socket
            //
            NewSession(s);
            ar.detach();

            //
            // Send Establish connection packet - at this stage we can't fail because ther
            // is receiver on this connection.
            //
            SendEstablishConnectionPacket(pguidQMId, !fQuick);

            return LogHR(MQ_OK, s_FN, 220);
        }
    	catch(const exception&)
        {
            TrWARNING(NETWORKING, "Insufficent resources. ::CreateConnection with %ls Failed",  GetStrAddr());
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 221);
        }


    }

    /*====================================================
    CSockTransport::ConnectSocket

    Arguments:

    Return Value:
    =====================================================*/
    HRESULT
    CSockTransport::ConnectSocket(
    	SOCKET s,
        SOCKADDR_IN const *pdest_in,
        bool              fUseQoS)
    {
        QOS Qos;
        QOS *pQoS = 0;
        if (fUseQoS)
        {
            pQoS = &Qos;
            QmpFillQoSBuffer(pQoS);
        }

        int ret = WSAConnect(s,
                             (PSOCKADDR)pdest_in,
                             sizeof(SOCKADDR),
                             0,
                             0,
                             pQoS,
                             0
                             );

        if(ret == SOCKET_ERROR)
        {
            DWORD dwErrorCode = WSAGetLastError();

            TrERROR(NETWORKING, "CSockTransport::ConnectSocket - connect to %ls Failed. Error=0x%x",GetStrAddr(), dwErrorCode);
            LogNTStatus(dwErrorCode,  s_FN, 340);

            if (fUseQoS)
            {
                //
                // Try again - no QoS this time
                //
                return LogHR(ConnectSocket(s, pdest_in, false), s_FN, 342);
            }

            return LogHR(MQ_ERROR, s_FN, 344);
        }

        return MQ_OK;
    }

    /*====================================================

    CSockTransport::Connect

    Arguments:

    Return Value:

    Thread Context: Scheduler

    =====================================================*/
    void CSockTransport::Connect(IN TA_ADDRESS *pa,
                                 IN CSocketHandle& pSocketHandle)
    {
        SetSessionAddress(pa);

        //
        // Increament Session refence count. This refernce count is used for complete
        // the session establish phase. we don't want that the session is free while we
        // wait to establish connection
        //
        R<CSockTransport> ar = SafeAddRef(this);

        // store that this is the client side
        SetClientConnect(FALSE);

        // connect the session to complition port and begin read on the socket
        NewSession(pSocketHandle);
        ar.detach();

        //
        // Set timer to check that the connection completed successfully. If yes, the function
        // is removed from the scheduler wakeup list and never is called. Otherwise, the function
        // close the session and move all the associated queues to non-active group.
        //
        ExSetTimer(&m_CancelConnectionTimer, CTimeDuration::FromMilliSeconds(ESTABLISH_CONNECTION_TIMEOUT));

    }

/*====================================================

CSockTransport::CloseConnection

Arguments:

Return Value:

Thread Context:

=====================================================*/

void CSockTransport::CloseConnection(
                                     LPCWSTR lpcwsDbgMsg,
									 bool fClosedOnError
                                     )
{
    CS lock(m_cs);

    //
    // Windows bug 612988
    // We can reach here from the timeout that cancel the connection
    // establish process, if we didn't get a reply for "estalbish" packet.
    // In that case, a WAIT_INFO structure is still in the waiting list,
    // see sessmgr.cpp.  Reset it's "connect" flag, so we try again to
    // connect to this address.
    //
    SessionMgr.MarkAddressAsNotConnecting( GetSessionAddress(),
                                           m_guidDstQM,
                                           m_fQoS ) ;

	//
	// If we got delivery error - we report it to the group
	// so all it's queues will be moved to the wating group when
	// the session group is closed.
	//
	if(fClosedOnError)
	{
		ReportErrorToGroup();
	}

    //
    // Requeue all the unacknowledged packets
    //
    POSITION posInList = m_listUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        CQmPacket* pPkt;

        pPkt = m_listUnackedPkts.GetNext(posInList);

    	//
    	// Requeue the packet - This deletes pPkt
    	//
        RequeuePacket(pPkt);
    }
    m_listUnackedPkts.RemoveAll();

    //
    // Requeue all the unacknowledged Storage packets
    //
    posInList = m_listStoredUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        CQmPacket* pPkt;

        pPkt = m_listStoredUnackedPkts.GetNext(posInList);

 	    //
 	    // Requeue the packet - This deletes pPkt
  	    //
        RequeuePacket(pPkt);
    }
    m_listStoredUnackedPkts.RemoveAll();

    //
    // Delete the group. move all the queues that associated
    // to this session to non-active group.
    // This is done after requeing the messages to avoid messing with the order of the packets
    //
    CQGroup*pGroup = GetGroup();
    if (pGroup != NULL)
    {
        pGroup->Close();

        pGroup->Release();
        SetGroup(NULL);
    }

    //
    // Check if the connection has already been closed
    //
    if (IsConnectionClosed())
    {
        return;
    }

    TrERROR(NETWORKING, "Close Connection with %ls at %ls. %ls (Session id: %p), (tick=%u)", GetStrAddr(),  _tstrtime(tempBuf), lpcwsDbgMsg, this, GetTickCount());
    //
    // Close the socket handle and set the flags appropriately
    //
    if (!IsOtherSideServer() && GetSessionStatus() == ssActive)
    {
        //
        // Decrement the number of active session
        //
        g_QMLicense.DecrementActiveConnections(&m_guidDstQM);
    }

    // set session status to connect
    //
    SetSessionStatus(ssNotConnect);
    m_connection->Close();

    //
    // Remove performance counters
    //
    SafeRelease(m_pStats.detach());
}


void
CSockTransport::PrepareBaseHeader(IN const CQmPacket *pPkt,
                                 IN BOOL fSendAck,
                                 IN DWORD dwDbgSectionSize,
                                 QMOV_WriteSession *po
                                )
{
    //
    // Copy base header, and changed the relevant flags
    //
    P<VOID> pv = new UCHAR[sizeof(CBaseHeader)];
    #ifdef _DEBUG
    #undef new
    #endif
    CBaseHeader* pBaseHeader = new(pv) CBaseHeader(*(CBaseHeader*)pPkt->GetPointerToPacket());
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif

    //
    // Update timeout field. On network we send relative timeout.
    //
    pBaseHeader->SetAbsoluteTimeToQueue(pPkt->GetRelativeTimeToQueue());
    //
    // Check if linking Acknwoldge information
    //
    if (fSendAck)
    {
        pBaseHeader->IncludeSession(TRUE);
    }
    //
    // Debug section included
    //
    if (dwDbgSectionSize != 0)
    {
        pBaseHeader->IncludeDebug(TRUE);
        pBaseHeader->SetTrace(MQMSG_SEND_ROUTE_TO_REPORT_QUEUE);
        pBaseHeader->SetPacketSize(pPkt->GetSize()+dwDbgSectionSize);
    }

    //
    // Set the packet signature
    //
    pBaseHeader->ClearOnDiskSignature();
    pBaseHeader->SetSignature();
    po->AppendSendBuffer(pBaseHeader, CBaseHeader::CalcSectionSize(), TRUE);
    pv.detach();
}

/*====================================================

  CSockTransport::PrepareRecoverEncryptPacket

  Arguments:

  Return Value:

  Thread Context: Session

  =====================================================*/


HRESULT
CSockTransport::PrepareRecoverEncryptPacket(IN const CQmPacket *pPkt,
                                              IN HCRYPTKEY hKey,
                                              IN BYTE *pbSymmKey,
                                              IN DWORD dwSymmKeyLen,
                                              QMOV_WriteSession *po
                                              )
{
    ASSERT(hKey != NULL);
    ASSERT(pPkt->GetPointerToSecurHeader());
    const UCHAR* pBody;
    DWORD dwBodySize;
    BOOL fSucc;
    DWORD dwWriteSize;

    //
    // write User and XACT sections
    //
    pBody = pPkt->GetPacketBody(&dwBodySize);
    ASSERT(dwBodySize);
    DWORD dwEncryptBodySize = dwBodySize;
    //
    // Get the encrypted message size inorder to set the packet size on the packet
    //
    fSucc = CryptEncrypt(hKey,
                         NULL,
                         TRUE,
                         0,
                         NULL,
                         &dwEncryptBodySize,
                         pPkt->GetAllocBodySize());
    ASSERT(fSucc);
    ASSERT(pPkt->GetAllocBodySize() >= dwEncryptBodySize);

    //
    // Calculate the size of the rest of the packet that should be sent. Don't use
    // the allocatedBodySize since when the property section isn't aligned, the QM padding it
    // with unused bytes
    //

    char* pEndOfPropSection = reinterpret_cast<CPropertyHeader*>(pPkt->GetPointerToPropertySection())->GetNextSection();
    dwWriteSize = DWORD_PTR_TO_DWORD(reinterpret_cast<UCHAR*>(pEndOfPropSection) - pPkt->GetPointerToUserHeader());

    P<UCHAR> pBuff = new UCHAR[dwWriteSize];
    memcpy(pBuff, pPkt->GetPointerToUserHeader(), dwWriteSize);

    //
    // set the symmetric key in the message packet.
    //
    CSecurityHeader* pSecur = (CSecurityHeader*)(pBuff + (pPkt->GetPointerToSecurHeader() - pPkt->GetPointerToUserHeader()));
    CPropertyHeader* pProp = (CPropertyHeader*)(pSecur->GetNextSection());
	

    pSecur->SetEncryptedSymmetricKey(pbSymmKey, (USHORT)dwSymmKeyLen);
    pSecur->SetEncrypted(TRUE);
    //
    // set the encrypted message size
    //
    pProp->SetBodySize(dwEncryptBodySize);

    TrTRACE(NETWORKING,"Write to socket %ls All the packet headers of recoverable encrypted message. Write %d bytes", GetStrAddr(), dwWriteSize);

    UCHAR *pBodyBuf =(UCHAR *)(pBuff + DWORD_PTR_TO_DWORD(pBody-(pPkt->GetPointerToUserHeader())));
    //
    // Encrypt the message body.
    //
    fSucc = CryptEncrypt(hKey,
                         NULL,
                         TRUE,
                         0,
                         pBodyBuf,
                         &dwBodySize,
                         dwEncryptBodySize);
    if (!fSucc)
    {
        DWORD gle = GetLastError();
        TrERROR(NETWORKING, "Encryption Failed. Error %d ", gle);
        LogNTStatus(gle, s_FN, 224);

        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 225);
    }

    po->AppendSendBuffer(pBuff, dwWriteSize, TRUE);
    pBuff.detach();
    return MQ_OK;
}




  /*====================================================

  CSockTransport::PrepareExpressEncryptPacket

  Arguments:

  Return Value:

  Thread Context: Session

  =====================================================*/

    HRESULT
    CSockTransport::PrepareExpressEncryptPacket(IN CQmPacket* pPkt,
                                       IN HCRYPTKEY hKey,
                                       IN BYTE *pbSymmKey,
                                       IN DWORD dwSymmKeyLen,
                                       IN QMOV_WriteSession*  po
                                      )
    {
        HRESULT hr=MQ_OK;

        ASSERT (hKey != 0);
        if (FAILED(pPkt->EncryptExpressPkt(hKey, pbSymmKey, dwSymmKeyLen)))
        {
            return LogHR(hr, s_FN, 260);
        }

        DWORD dwWriteSize = pPkt->GetSize() - sizeof(CBaseHeader);
        po->AppendSendBuffer(pPkt->GetPointerToUserHeader(), dwWriteSize , FALSE);
        return MQ_OK;
    }




    /*====================================================

    CSockTransport::NetworkSend

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void CSockTransport::NetworkSend(IN CQmPacket* pPkt)
    {
        HRESULT hr = MQ_OK;
        QUEUE_FORMAT ReportQueue;
        BOOL fSendAck = FALSE;
        DWORD dwDbgSectionSize = 0;

        WORD StorageAckNo=0;
        DWORD StorageAckBitField=0;

        HCRYPTKEY hSymmKey = NULL;
        BYTE *pbSymmKey = 0;
        DWORD dwSymmKeyLen = 0;

        ASSERT(pPkt->IsSessionIncluded() == FALSE);

        R<CCacheValue> pCacheValue;

        if (pPkt->IsBodyInc() &&
            !pPkt->IsEncrypted() &&
            (pPkt->GetPrivLevel() != MQMSG_PRIV_LEVEL_NONE))
        {
            //
            // Get the symmetric key of the destination. In order to avoid the case that we
            // begin to send the packet and than find that Symmetric key can't be obtain, we do
            // now.
            //
            hr = pPkt->GetDestSymmKey( &hSymmKey,
                                       &pbSymmKey,
                                       &dwSymmKeyLen,
                                      (PVOID *)&pCacheValue );
            if (FAILED(hr))
            {
                if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
                {
                    // Special case. Send couldn't encrypt, so send is - and will remain - impossible
                    // We must treat it as timeout: delete packet, keep the number in time-out block
                    //
                    if(MQCLASS_MATCH_ACKNOWLEDGMENT(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, pPkt->GetAckType()))
                    {
                        pPkt->CreateAck(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT);
                    }

                    // NonSendProcess free the packet internally.
                    g_OutSeqHash.NonSendProcess(pPkt, MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT);
                }
                else
                {
                    //
                    // Sorry, the destination QM doesn't support encryption. Create ack and free
                    // the packet
                    //
				    QmAcFreePacket(
							   	   pPkt->GetPointerToDriverPacket(),
					   			   MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT,
				   			       eDeferOnFailure);
                    delete pPkt;
                }

                //
                // Get the next message for sending now
                //
                GetNextSendMessage();
                return;
            }
        }


        {
            //
            // Before sending message get the critical section. We need it since
            // at the same time the SendReadAck timeout can be expired and ack
            // packet can be send
            //
            CS lock(m_cs);

            //
            // Check if linking Acknwoldge information
            // We linking Acknowledge section only if 75% of the SendAcknowldge
            // timeout is passed
            //
            if ((((GetTickCount() - m_dwLastTimeRcvPktAck)> ((3*m_dwSendAckTimeout)/4)) ||
                (GetRecvUnAckPacketNo() >= (m_wRecvWindowSize/4))) && (m_fSendAck || (m_wAckRecoverNo != 0)))
            {
                fSendAck = TRUE;
            }

            TrTRACE(NETWORKING, "NetworkSend - linking Acknowledge information: decided %d, m_wAckRecoverNo=%d", fSendAck,(DWORD)m_wAckRecoverNo);

        }

        //
        // Check if debug information should be sent. If yes create the debug
        // section such we will be sure we can send it.
        //
        if (
            //
            // Verify that Debug header not already included.
            // Debug header may be included for example when the MQF header is
            // included, to prevent reporting QMs 1.0/2.0 to append their Debug
            // header to the packet.
            //
            (!pPkt->IsDbgIncluded()) &&

            //
            // Verify this is not a report message by itself.
            //
            (pPkt->GetClass() != MQMSG_CLASS_REPORT) &&

            //
            // This is a reporting QM, or packet should be traced.
            //
            (QueueMgr.IsReportQM() || (pPkt->GetTrace() == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE)) &&

            //
            // There is a valid report queue.
            //
            SUCCEEDED(Admin.GetReportQueue(&ReportQueue))
            )
        {
            dwDbgSectionSize = CDebugSection::CalcSectionSize(&ReportQueue);
        }



        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);
        TrTRACE(GENERAL, "SEND message: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());

        #ifdef _DEBUG

            TrWARNING(NETWORKING,"Send packet to %ls. Packet ID = " LOG_GUID_FMT "\\%u",
                    GetStrAddr(), LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier);
        #endif


        TrTRACE(NETWORKING, "::NetworkSend. Packet Size %d, Send Ack section %d, Send debug Section %d",  pPkt->GetSize(),  fSendAck, dwDbgSectionSize);

        //
        // Set The acnowledge number of the packet
        //
        UpdateAcknowledgeNo(pPkt);

        //
        // Save the packet info for later use when sending the report message
        //
        m_MsgInfo.SetReportMsgInfo(pPkt);

		//
		// Log to tracing that a message was sent.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			OBJECTID TraceMessageId;
			pPkt->GetMessageId(&TraceMessageId);

	        CQueue* pQueue = NULL;
	        HRESULT rc = GetDstQueueObject(pPkt, &pQueue, true);
	        DBG_USED(rc);
	        R<CQueue> Ref = pQueue;
	        ASSERT_BENIGN(("We expect to find the destination queue",SUCCEEDED(rc)));

			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"Native Message being sent on wire",
				pQueue->GetQueueName(),
				&TraceMessageId.Lineage,
				TraceMessageId.Uniquifier,
				pPkt->GetDeliveryMode(),
				pPkt->GetClass(),
				xwcs_t(pPkt->GetTitlePtr(), pPkt->GetTitleLength()));


			
		}

        //
        // Prepare base header
        //

        P<QMOV_WriteSession> po = new QMOV_WriteSession(this, TRUE);
        PrepareBaseHeader(pPkt, fSendAck, dwDbgSectionSize, po);

        if (hSymmKey == NULL)
        {
            DWORD dwWriteSize = pPkt->GetSize() - sizeof(CBaseHeader);
            po->AppendSendBuffer(pPkt->GetPointerToUserHeader(), dwWriteSize , FALSE);
        }
        else
        {
            //
            // Handle Encrypted Messages
            //
            if(pPkt->GetDeliveryMode() == MQMSG_DELIVERY_EXPRESS)
            {
                hr = PrepareExpressEncryptPacket(pPkt, hSymmKey, pbSymmKey, dwSymmKeyLen, po);
            }
            else
            {
                hr = PrepareRecoverEncryptPacket(pPkt, hSymmKey, pbSymmKey, dwSymmKeyLen, po);

                if(SUCCEEDED(hr) && pPkt->IsDbgIncluded())
                {
		            ASSERT(("Debug section is already included", (dwDbgSectionSize == 0)));
                    PrepareIncDebugAndMqfSections(pPkt, po);
                }
            }

            if (FAILED(hr))
            {
	            TrERROR(NETWORKING,"Failed encryption: Result: %!hresult!",hr);

			    QmAcFreePacket(
						   	   pPkt->GetPointerToDriverPacket(),
				   			   MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT,
			   			       eDeferOnFailure);
                delete pPkt;

                //
                // Get the next message for sending now
                //
                GetNextSendMessage();
                return;
            }
        }

        if(dwDbgSectionSize)
        {
            PrepareDebugSection(&ReportQueue, dwDbgSectionSize, po);
        }

        if(fSendAck)
        {
            PrepareAckSection(&StorageAckNo, &StorageAckBitField, po);
        }

        CS lock(m_cs);

        hr = WriteToSocket(po);
		if (FAILED(hr))
		{
            TrERROR(NETWORKING,"WriteToSocket failed: %!hresult!",hr);
		}

        if (SUCCEEDED(hr))
        {

            po.detach();

            //
            // SP4 - Bug# 3380. (closing a session while sending a messge)
            //
            // Add the packet to the list of unacknowledged packets before
            // the sending is completed. If the send is failed the session will
            // be closed and the message is returned to the Queue. Otherwise,
            // when a acknowledge is received the message will free
            //              Uri Habusha (urih), 11-Aug-98
            //
            NeedAck(pPkt);

            if(fSendAck)
            {
                FinishSendingAck(StorageAckNo, StorageAckBitField);
            }
            return;
        }

        //
        // sending of packet failed, the session should be closed
        //
        ASSERT(IsConnectionClosed());

        //
        // return the message to queue and delete the internal structures
        //
        // This deletes pPkt
       //
        RequeuePacket(pPkt);

    }





/*====================================================

    CSockTransport::PrepareIncDebugAndMqfSections

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/


    void
    CSockTransport::PrepareIncDebugAndMqfSections(CQmPacket* pPkt, QMOV_WriteSession* po)
    {

        ASSERT(pPkt->IsDbgIncluded());

        //
        // Get pointer to debug section
        //
        UCHAR* pDebug = pPkt->GetPointerToDebugSection();
        ASSERT(("Debug section must exist", pDebug != NULL));

        DWORD dwSize = pPkt->GetSize() - DWORD_PTR_TO_DWORD(pDebug - (const UCHAR*)pPkt->GetPointerToPacket());
        po->AppendSendBuffer(pDebug, dwSize, FALSE);
    }

   /*====================================================

    CSockTransport::PrepareDebugSection

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/


    void
    CSockTransport::PrepareDebugSection(QUEUE_FORMAT* pReportQueue, DWORD dwDbgSectionSize, QMOV_WriteSession* po)
    {
        PVOID pv = new UCHAR[dwDbgSectionSize];
        #ifdef _DEBUG
        #undef new
        #endif

        P<CDebugSection> pDbgSection = new(pv) CDebugSection(pReportQueue);

        #ifdef _DEBUG
        #define new DEBUG_NEW
        #endif

        po->AppendSendBuffer(pDbgSection, dwDbgSectionSize, TRUE);
        pDbgSection.detach();
    }


      /*====================================================

    CSockTransport::PrepareAckSection

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void
    CSockTransport::PrepareAckSection(WORD* pStorageAckNo, DWORD* pStorageAckBitField, QMOV_WriteSession* po)
    {
        CS lock(m_cs);

        DWORD dwSize = sizeof(CSessionSection);
        PVOID pv = new UCHAR[dwSize];
        P<CSessionSection> pAckSection = static_cast<CSessionSection*>(pv);

        CancelAckTimers();
        SetAckInfo(pAckSection);
        DisplayAcnowledgeInformation(pAckSection);
    //
    // Store the number for later used. The numbers on the object have been set to
    // zero and the packet can be released before calling UpdateNumberOfStorageUnacked.
    //
        *pStorageAckNo = pAckSection->GetStorageAckNo();
        *pStorageAckBitField = pAckSection->GetStorageAckBitField();

        po->AppendSendBuffer(pAckSection, dwSize , TRUE);
        pAckSection.detach();
    }


    void
    CSockTransport::SendAckPacket(
        void
        )
    {
        CS lock(m_cs);

        ASSERT(m_nSendAckSchedules > 0);
        --m_nSendAckSchedules;

        if (m_fSendAck)
        {
            SendReadAck();
        }
        Release();
    }

    void
    CSockTransport::SetAckInfo(
        CSessionSection* pAckSection
        )
    /*++

      Routine description:
        the routine gets a pointer to the session section and it set the session
        acknowledge information on it.

      Parameters:
        pointer to the session acknowledge section.

      Returned value:
        None

     --*/
    {
        //
        // Set the ackconweledge section
        //
        WORD WinSize = (WORD)(IsDisconnected() ? 1 : SessionMgr.GetWindowSize());

    #ifdef _DEBUG
    #undef new
    #endif

        TrTRACE(NETWORKING, D"new CSessionSection: m_wAckRecoverNo=%d", (DWORD)m_wAckRecoverNo);

        new(pAckSection) CSessionSection(
                                    m_wUnAckRcvPktNo,
                                    m_wAckRecoverNo,
                                    m_dwAckRecoverBitField,
                                    m_wSendPktCounter,
                                    m_wStoredPktCounter,
                                    WinSize
                                    );

    #ifdef _DEBUG
        #define new DEBUG_NEW
    #endif

        //
        // Initialize m_wAckRecoverNo
        //
        m_wAckRecoverNo = 0;
        m_dwAckRecoverBitField = 0;

        TrTRACE(NETWORKING, "SetAckInfo: m_wAckRecoverNo=0");
    }


    void
    CSockTransport::CreateAckPacket(
        PVOID* ppSendPacket,
        CSessionSection** ppAckSection,
        DWORD* pSize
        )
    /*++

      Routine Description:
        The routine creates an acknowledge packet for sending

      Argumets:
        All the arguments are out arguments and uses to return information to the caller:
            - pointer to the acknowledge packet
            - pointer to the session acknowledgment section
            - packet size

      Returned value:
        None
     --*/
    {
        DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CSessionSection);
        PVOID pAckPacket = new UCHAR[dwPacketSize];

        *ppSendPacket = pAckPacket;
        *pSize = dwPacketSize;

    #ifdef _DEBUG
    #undef new
    #endif
        //
        // Set Falcon Packet Header
        //
        CBaseHeader* pBase = new(pAckPacket) CBaseHeader(dwPacketSize);
        pBase->SetType(FALCON_INTERNAL_PACKET);
        pBase->IncludeSession(TRUE);

        //
        // Set the Internal packet header
        //
        PVOID pSect = (PVOID) pBase->GetNextSection();
        CInternalSection* pInternalSect = new(pSect) CInternalSection(INTERNAL_SESSION_PACKET);

    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif

        *ppAckSection = reinterpret_cast<CSessionSection*>(pInternalSect->GetNextSection());
        SetAckInfo(*ppAckSection);
    }




    #ifdef _DEBUG
    void
    CSockTransport::DisplayAcnowledgeInformation(
        CSessionSection* pAck
        )
    {
        //
        // Get Synchronization Numbers
        //
        WORD wSyncAckSequenceNo, wSyncAckRecoverNo;
        pAck->GetSyncNo(&wSyncAckSequenceNo, &wSyncAckRecoverNo);

        //
        // Print debug information
        //
        TrWARNING(NETWORKING,
                  "ACKINFO: Send Acknowledge packet to %ls. (time %d) \
                   \n\t\tm_wAckSequenceNo %d\n\t\tm_wAckRecoverNo %d\n\t\tm_wAckRecoverBitField 0x%x\n\t\tm_wSyncAckSequenceNo %d\n\t\tm_wSyncAckRecoverNo %d\n\t\tm_wWinSize %d\n\t\t",
                  GetStrAddr(),
                  GetTickCount(),
                  pAck->GetAcknowledgeNo(),
                  pAck->GetStorageAckNo(),
                  pAck->GetStorageAckBitField(),
                  wSyncAckSequenceNo,
                  wSyncAckRecoverNo,
                  pAck->GetWindowSize());
    }
    #endif



    /*====================================================

    CSockTransport::SendReadAck

    Arguments:

    Return Value:

    Thread Context: Session
    =====================================================*/

    void
    CSockTransport::SendReadAck()
    {
        CS lock(m_cs);
        if (IsConnectionClosed())
        {
            return;
        }

        CancelAckTimers();

        TrTRACE(NETWORKING,
                "READACK: Send Read Acknowledge for session %ls\n\tTime passed from last Ack Sending - %d. Send Packet: %ls)",
                GetStrAddr(),
                (GetTickCount() - m_dwLastTimeRcvPktAck),
                L"TRUE"
                );

        //
        // Create a packet containing the read acknowledgment
        //
        PVOID   pAckPacket;
        DWORD   dwWriteSize;
        CSessionSection* pAckSection;


        CreateAckPacket(&pAckPacket, &pAckSection, &dwWriteSize);


        DisplayAcnowledgeInformation(pAckSection);

        //
        // Store the number for later used. The numbers on the object have been set to
        // zero and the packet can be released before calling UpdateNumberOfStorageUnackedand.
        //
        WORD StorageAckNo = pAckSection->GetStorageAckNo();
        DWORD StorageAckBitField = pAckSection->GetStorageAckBitField();

        HRESULT hr = SendInternalPacket(pAckPacket, dwWriteSize);

        if(SUCCEEDED(hr))
        {
            FinishSendingAck(StorageAckNo, StorageAckBitField);
        }
        return;
    }

    /*====================================================

    CSockTransport::CancelAckTimers

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/
    void
    CSockTransport::CancelAckTimers()
    {
        //
        // Cancel the sending acknowledge timer & Fast acknowledge timer
        //
        if (ExCancelTimer(&m_SendAckTimer))
        {
            --m_nSendAckSchedules;
            Release();
        }

        if (ExCancelTimer(&m_FastAckTimer))
        {
            Release();
        }
    }


    /*====================================================

    CSockTransport::FinishSendingAck

    Arguments:

    Return Value:

    Thread Context: Session

    =====================================================*/

    void CSockTransport::FinishSendingAck(WORD StorageAckNo,
                                     DWORD StorageAckBitField)
    {
        //
        // Update the number of recoverable messages that were received but
        // didn't ack
        //
        UpdateNumberOfStorageUnacked(StorageAckNo, StorageAckBitField);

        //
        // Clear the Recveive Un-acknowledge counter. Begin a new phase
        //
        m_fSendAck = FALSE;
        ClearRecvUnAckPacketNo();

        //
        // Set The last time acknowledge was sent
        //
        m_dwLastTimeRcvPktAck = GetTickCount();
    }



    /*====================================================

    CSockTransport::RcvStats

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/
    void CSockTransport::RcvStats(DWORD size)
    {
        //
        // use critical section to insure that the session will not close while
        // we update the parameters. (CloseConnection function delete the m_pStats structure).
        //
        CS lock(m_cs);

        if (m_pStats.get() != NULL)
        {
            m_pStats->UpdateBytesReceived(size);
            m_pStats->UpdateMessagesReceived();
        }
    }


    /*====================================================

    CSockTransport::HandleReceiveInternalMsg

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/
    void CSockTransport::HandleReceiveInternalMsg(CBaseHeader* pBaseHeader)
    {
    	try
    	{
    		CInternalSection* pInternal = pBaseHeader->section_cast<CInternalSection*>(pBaseHeader->GetNextSection());
    		pInternal->SectionIsValid(pBaseHeader->GetPacketEnd());

    		switch (pInternal->GetPacketType())
    		{
    		    case INTERNAL_SESSION_PACKET:
    		        HandleAckPacket(pBaseHeader->section_cast<CSessionSection*>(pInternal->GetNextSection()));
    		        break;

    		    case INTERNAL_ESTABLISH_CONNECTION_PACKET:
    		        HandleEstablishConnectionPacket(pBaseHeader);
    		        break;

    		    case INTERNAL_CONNECTION_PARAMETER_PACKET:
    		        HandleConnectionParameterPacket(pBaseHeader);
    		        break;

    		    default:
    				ASSERT(0);
    		}
    	}
	catch(const bad_alloc&)
      	{
  		TrERROR(NETWORKING, "Got bad_alloc");
		Close_Connection(this, L"Insufficient resources");
  		return;
      	}
    	catch (const exception&)
    	{
            TrERROR(NETWORKING, "Internal Header is not valid");
		ASSERT_BENIGN(0);
    		//
    		// Close the session, we dont decrease the ref count so it will be released when ReadComplited
    		// will try to continue reading from the close socket and will fire exception
    		//
    		Close_Connection(this, L"Internal Header is not valid");
    		LogHR(MQ_ERROR, s_FN, 350);
    		return;
    	}
    	
    }


    /*====================================================

    CSockTransport::UpdateRecvAcknowledgeNo

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/
    void CSockTransport::UpdateRecvAcknowledgeNo(CQmPacket* pPkt)
    {
        CS lock(m_cs);

        //
        // Set the acknowledge number such the sender
        // get indication it was received and will not send it again.
        //
        m_wUnAckRcvPktNo = pPkt->GetAcknowladgeNo();
        //
        // Send read ack to source machine
        //
        m_fSendAck = TRUE;

        //
        // Increament the number of unacked packet
        //
        IncRecvUnAckPacketNo();
        //
        //  if the Window limit has reached, send the session acks now
        //
        if (GetRecvUnAckPacketNo() >= (m_wRecvWindowSize/2))
        {
            TrWARNING(NETWORKING, "Unacked packet no. reach the limitation (%d). ACK packet was sent", m_wRecvWindowSize);
            TrTRACE(NETWORKING, "Window size, My = %d, Other = %d", SessionMgr.GetWindowSize(),m_wRecvWindowSize);

            SendReadAck();
            return;
        }

        if (m_nSendAckSchedules == 0)
        {
            //
            // Increment Session referance count for the SendReadAck. The refernce is decremented
            // when the session is closed.
            //
            AddRef();

            ++m_nSendAckSchedules;
            ExSetTimer(&m_SendAckTimer, CTimeDuration::FromMilliSeconds(m_dwSendAckTimeout));
        }
    }

    /*====================================================

    CSockTransport::RejectPacket

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/
    void CSockTransport::RejectPacket(CQmPacket* pPkt, USHORT usClass)
    {
        //
        // Update the receive packet nomber such we can send a session acknowledge
        // for it.
        //
        UpdateRecvAcknowledgeNo(pPkt);
        //
        // Update the session storage acknowledge no.
        //
        if (pPkt->GetStoreAcknowledgeNo() != 0)
        {
            SetStoredAck(pPkt->GetStoreAcknowledgeNo());
        }

	    QmAcFreePacket(
				   	   pPkt->GetPointerToDriverPacket(),
		   			   usClass,
	   			       eDeferOnFailure);
    }


    /*====================================================

    CSockTransport::ReceiveOrderedMsg

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/
    void CSockTransport::ReceiveOrderedMsg(CQmPacket *pPkt,
                                           CQueue* pQueue,
                                           BOOL fDuplicate
                                           )
    {
        ASSERT(g_pInSeqHash);

		R<CInSequence> pInSeq = g_pInSeqHash->LookupCreateSequence(pPkt);

		CS lock(pInSeq->GetCriticalSection());

        if(!pInSeq->VerifyAndPrepare(pPkt, pQueue->GetQueueHandle()))
        {
            // Packet has a wrong seq number. Send back Seq Ack with last good number.
            // g_pInSeqHash->SendSeqAckForPacket(pPkt);
            RejectPacket(pPkt, 0);
            return;
        }

        USHORT usClass = VerifyRecvMsg(pPkt, pQueue);
        if(MQCLASS_NACK(usClass))
        {
        	pInSeq->AdvanceNACK(pPkt);
            RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : usClass));
            return;
        }

        //
        // Accepted. Mark as received (to be invisible to readers yet) and store in the queue.
        //
        HRESULT rc = pQueue->PutOrderedPkt(pPkt, FALSE, this);
        if (FAILED(rc))
        {
		    QmAcFreePacket(
					   	   pPkt->GetPointerToDriverPacket(),
			   			   0,
		   			       eDeferOnFailure);
            LogIllegalPoint(s_FN, 774);
            Close_Connection(this, L"Allocation Failure in receive packet procedure");

            return;
        }

        pInSeq->Advance(pPkt);
    }

    /*====================================================

    CSockTransport::HandleReceiveUserMsg

    Arguments:

    Return Value:

    Thread Context:
    =====================================================*/

    void CSockTransport::HandleReceiveUserMsg(CBaseHeader* pBaseHeader,
                                              CPacket * pDriverPacket)
    {
        //
        // The whole packet is read. the constractor of CQmPacket can throw exception
        // if bad formated packet was received
        // the exceptions is catched by the caller of this function and the packet get
        // freed
        //
        CQmPacket thePacket(pBaseHeader, pDriverPacket, true);
        CQmPacket* pPkt = &thePacket;

		//
		// Log to tracing that a message was Received.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			OBJECTID TraceMessageId;
			pPkt->GetMessageId(&TraceMessageId);
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"Native Message arrived in QM - Before insertion into queue",
				L"Unresolved yet",
				&TraceMessageId.Lineage,
				TraceMessageId.Uniquifier,
				pPkt->GetDeliveryMode(),
				pPkt->GetClass(),
				xwcs_t(pPkt->GetTitlePtr(), pPkt->GetTitleLength()));

            //
            // The following is to display the first 3 DWORD in the extension property and the
            // application tag value.
            // The Redmond stress client heartbeats has application tag value of 21(0x15) and the
            // extension field and the first three DWORD are as follow:
            //
            //    DWORD dwVersion
            //    DWORD dwSenderID
            //    DWORD dwStressID
            //
            //

            DWORD dwMsgExtensionSize= pPkt->GetMsgExtensionSize();
            const DWORD *pMsgExtension=reinterpret_cast<const DWORD *>(pPkt->GetMsgExtensionPtr());
			
            if(pMsgExtension && dwMsgExtensionSize >= 3*sizeof(DWORD) )
            {
                TrTRACE(
                    PROFILING,
                    "Message Extension size = %d, first three DWORD = 0x%x, 0x%x, 0x%x, Application Tag = 0x%x",
                    dwMsgExtensionSize,
                    *(pMsgExtension),
                    *(pMsgExtension+1),
                    *(pMsgExtension+2),
                    pPkt->GetApplicationTag()
                    );
            }

		}

        if (IsDisconnected())
        {
            TrTRACE(NETWORKING, "Discard received user message. The session %ls is disconnected", GetStrAddr());

            //
            // If the network is disconnected, MSMQ doesn't ready to
            // get a new user packet. The QM discard the incoming
            // user packet. Only the internal packet is handled
            //
		    QmAcFreePacket(
					   	   pPkt->GetPointerToDriverPacket(),
			   			   0,
		   			       eDeferOnFailure);
            return;
        }

        //
        // Update statistics
        //
        RcvStats(pPkt->GetSize());

    	

        //
        // Send Report message if needed
        //
        ReportMsgInfo MsgInfo;
        MsgInfo.SetReportMsgInfo(pPkt);
        MsgInfo.SendReportMessage(NULL);

        //
        // Increment read and store acknowledgment No.
        //
        IncReadAck(pPkt);

        //
        // Increment Hop Count
        //
        pPkt->IncHopCount();

        #ifdef _DEBUG
        {
            OBJECTID MessageId;
            pPkt->GetMessageId(&MessageId);

            TrWARNING(NETWORKING,"Receive packet from %ls, Packet ID = %!guid!\\%u", GetStrAddr(), &MessageId.Lineage, MessageId.Uniquifier);

        }
        #endif

        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);
        TrTRACE(GENERAL, "RECEIVE message: ID=" LOG_GUID_FMT "\\%u (ackno=%u)", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo());

        TrTRACE(NETWORKING, "::HandleReceiveUserMsg. for session %ls Packet Size %d, Include Ack section %d, Include debug Section %d",
                    GetStrAddr(), pPkt->GetSize(),  pPkt->IsSessionIncluded(), pPkt->IsDbgIncluded());

        //
        // Get the packet destination queue object, checking the result only
        // after finding if the message is duplicated
        //
        CQueue* pQueue = NULL;
        HRESULT GetDstQueueObjectRes = GetDstQueueObject(pPkt, &pQueue, true);
        R<CQueue> Ref = pQueue;

        //
        // Insert the message to remove duplicate tabel. If the message already exist,
        // the insertion failed and the routine returns FALSE.
        // Don't throw the packet here, give the transactional mechanism chance to look at it.
        //
        OBJECTID MsgIdDup;
        BOOL fDuplicate = FALSE;
        BOOL fToDupInserted = FALSE;
        if (!pPkt->IsOrdered() || ((pQueue != NULL) && (!pQueue->IsLocalQueue())))
        {
            pPkt->GetMessageId(&MsgIdDup);
            fDuplicate = !DpInsertMessage(thePacket);
            fToDupInserted = !fDuplicate;

            if (fDuplicate)
            {
                TrERROR(NETWORKING, "RECEIVE DUPLICATE %ls MESSAGE: %!guid!\\%d",
                        (pPkt->IsOrdered() ? L"xact" : L""), &MsgIdDup.Lineage, MsgIdDup.Uniquifier);
            }

        }

        //
        // In any case of packet rejection we delete it from the remove duplicate map
        //
        CAutoDeletePacketFromDuplicateMap AutoDeletePacketFromDuplicateMap(fToDupInserted ? pPkt : NULL);

        if(FAILED(GetDstQueueObjectRes))
        {
            RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : MQMSG_CLASS_NACK_BAD_DST_Q));
            return;
        }
		//
		// Log to tracing that a message was Received.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			OBJECTID TraceMessageId;
			pPkt->GetMessageId(&TraceMessageId);
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"Native Message arrived in QM - After insertion into queue",
				pQueue->GetQueueName(),
				&TraceMessageId.Lineage,
				TraceMessageId.Uniquifier,
				pPkt->GetDeliveryMode(),
				pPkt->GetClass(),
				xwcs_t(pPkt->GetTitlePtr(), pPkt->GetTitleLength()));
		}


        //
        //  Handle local queue cases
        //
        USHORT usClass;
        if(pQueue->IsLocalQueue())
        {
            //
            //  Match ordered packets with transactional queue
            //
            usClass = VerifyTransactRights(pPkt, pQueue);
            if(MQCLASS_NACK(usClass))
            {
                RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : usClass));
                return;
            }

            //
            //  Verify packet is not a duplicate ordered packet
            //
            if(pPkt->IsOrdered())
            {
                // Process ordered incoming message
                ReceiveOrderedMsg(pPkt, pQueue, fDuplicate);

                //
                // packet handling completed successfully. Set the packet acknowledge number
                // 
                //
                // bug# 727435 - Assert received during the Stress running while the Free Packet was used twice by the QM.
				// Since the packet successfully put in the queue the QM isn't allowed to free
				// the packet any more. If the exception isn't caught locally, it will catch
				// in upper level that free the message. Since the message isn't in QM responsiblity 
				// this can cause a blue screen or data lost.
				//								     Uri Habusha, 22-Oct-2002
                //
		        try
		        {
			        UpdateRecvAcknowledgeNo(pPkt);
		        }
		        catch(const exception&)
		        {
					TrERROR(NETWORKING, "UpdateRecvAcknowledgeNo threw an exception");
					Close_Connection(this, L"UpdateRecvAcknowledgeNo threw an exception");
		        }
                return;
            }
        }

        if (fDuplicate)
        {
            //
            // Duplicate message. Update the acknowledge numbers and
            // throw the packet
            //
            RejectPacket(pPkt, 0);
            return;
        }

        // From here on we deal only with non-ordered message

        usClass = VerifyRecvMsg(pPkt, pQueue);
        if(MQCLASS_NACK(usClass))
        {
            RejectPacket(pPkt, usClass);
            return;
        }

        //
        // We get the crtical section here in order to elimante the case that
        // storage ack is updated before the Sync ack. In such a case the
        // storage ack is ignored by the sender.
        //
        CS lock(m_cs);

        HRESULT rc = pQueue->PutPkt(pPkt, FALSE, this);

        if (FAILED(rc))
        {
		    QmAcFreePacket(
					   	   pDriverPacket,
			   			   0,
		   			       eDeferOnFailure);
            LogIllegalPoint(s_FN, 775);
            Close_Connection(this, L"Allocation Failure in receive packet procedure");
            return;
        }
        //
        // packet handling completed successfully. Set the packet acknowledge number
        //
        try
        {
	        UpdateRecvAcknowledgeNo(pPkt);
        }
        catch(const exception&)
        {
			TrERROR(NETWORKING, "UpdateRecvAcknowledgeNo threw an exception");
			Close_Connection(this, L"UpdateRecvAcknowledgeNo threw an exception");
        }

        //
        // The packet was accepted so we keep it in the duplicate map
        //
        AutoDeletePacketFromDuplicateMap.detach();
    }


    /*====================================================

      CSockTransport::HandleEstablishConnectionPacket

      Arguments:    pcPacket - pointer to Establish  Connection Packet

      Return Value: none

    =====================================================*/
    void CSockTransport::HandleEstablishConnectionPacket(CBaseHeader* pBase)
    {
        PVOID pPkt = NULL;
        DWORD dwPacketSize;
        {
            PVOID pSect = NULL;
            CS lock(m_cs);

            if (GetSessionStatus() >= ssEstablish)
            {
            	//
            	// this can not be unless someone is hacking us
            	//
		    	TrERROR(NETWORKING, "Recieved Establish Connection Packet twice");
	            ASSERT_BENIGN(0);
				throw exception();
            }

            CInternalSection* pInternal = pBase->section_cast<CInternalSection*>(pBase->GetNextSection());
            CECSection* pECP = pBase->section_cast<CECSection*>(pInternal->GetNextSection());

            ASSERT(pInternal->GetPacketType() == INTERNAL_ESTABLISH_CONNECTION_PACKET);

            TrTRACE(NETWORKING, "ESTABLISH CONNECTION: Get Establish connection packet (client=%d). Client Id %!guid!, Server Id %!guid!", IsClient(), pECP->GetClientQMGuid(), pECP->GetServerQMGuid());

            if (IsConnectionClosed())
            {
                // the session was closed.
                return;
            }

            SetSessionStatus(ssEstablish);
            //
            // Set the other side type. we need it inorder to update the number
            // of active session later
            //
            OtherSideIsServer(pECP->IsOtherSideServer());

            GUID * pOtherQMGuid ;
            if (IsClient())
            {
                pOtherQMGuid = const_cast<GUID*>(pECP->GetServerQMGuid()) ;
            }
            else
            {
                pOtherQMGuid = const_cast<GUID*>(pECP->GetClientQMGuid()) ;
            }

            BOOL fAllowNewSession = !pECP->CheckAllowNewSession() ||
                                     g_QMLicense.NewConnectionAllowed(!pECP->IsOtherSideServer(), pOtherQMGuid);

            if (IsClient())
            {
            	if ((!QmpIsLocalMachine(pECP->GetClientQMGuid())) || (pECP->GetVersion() != FALCON_PACKET_VERSION))
            	{
    		    	TrERROR(NETWORKING, "Establish Connection Packet is not valid");
    	            ASSERT_BENIGN(QmpIsLocalMachine(pECP->GetClientQMGuid()));
        	        ASSERT_BENIGN(pECP->GetVersion() == FALCON_PACKET_VERSION);
    				throw exception();
            	}

                if (pInternal->GetRefuseConnectionFlag() || (! fAllowNewSession))
                {
                    if (!fAllowNewSession)
                    {
                        TrWARNING(NETWORKING, "create a new session with %ls Failed, due session limitation", GetStrAddr());
                    }
                    else
                    {
                        TrWARNING(NETWORKING, "create a new session with %ls Failed. Other side refude to create the connection", GetStrAddr());
                    }

                    CQGroup* pGroup = GetGroup();
                    if (pGroup)
                    {
                        //
                        // Move all the queues in the session to the waiting group. otherwise
                        // the Qm try immidiatly to create a session again this session will be refused
                        // and so on and so on.
                        //
                    	pGroup->OnRetryableDeliveryError();
                    }

                    //
                    // connection refused. Close the session
                    //
                    Close_Connection(this, L"Connection refused");

    				//
                    // Decrement reference count
                    //
    				if(ExCancelTimer(&m_CancelConnectionTimer))
    				{
    					Release();  // Release Establish connection reference count
    				}

                    return;
                }
                else
                {
                    //
                    // Either the server ID matches expected ID or this is
                    // a DIRECT connection
                    //
                    if ((*GetQMId() != *pECP->GetServerQMGuid()) && (*GetQMId() != GUID_NULL))
                    {
  			    	    TrERROR(NETWORKING, "Establish Connection Packet is not valid phase 2");
  		                ASSERT_BENIGN(*GetQMId() == *pECP->GetServerQMGuid());
  	    	            ASSERT_BENIGN(*GetQMId() == GUID_NULL);
 					    throw exception();
                    }
                    SetQMId(pECP->GetServerQMGuid());

                    // Get time
                    DWORD dwECTime = GetTickCount() - pECP->GetTimeStamp();
                    // Create CP Packet
                    CreateConnectionParameterPacket(dwECTime, (CBaseHeader**)&pPkt, &dwPacketSize);
                }
            }
            else
            {
                // Create Return Packet
                dwPacketSize = pBase->GetPacketSize();
                pPkt = new UCHAR[dwPacketSize];
                memset(pPkt, 0x5a, dwPacketSize) ; // bug 5483

                if (CSessionMgr::m_fUseQoS)
                {
                    m_fQoS = pECP->IsOtherSideQoS();
                }

        #ifdef _DEBUG
        #undef new
        #endif
                CBaseHeader* pBaseNew = new(pPkt) CBaseHeader(dwPacketSize);
                pBaseNew->SetType(FALCON_INTERNAL_PACKET);
                pSect = (PVOID) pBaseNew->GetNextSection();

                CInternalSection* pInternalSect = new(pSect) CInternalSection(INTERNAL_ESTABLISH_CONNECTION_PACKET);
                pSect = pInternalSect->GetNextSection();

                CECSection* pECSection = new(pSect) CECSection(pECP->GetClientQMGuid(),
                                                               CQueueMgr::GetQMGuid(),
                                                               pECP->GetTimeStamp(),
                                                               OS_SERVER(g_dwOperatingSystem),
                                                               m_fQoS);
                pECSection->CheckAllowNewSession(pECP->CheckAllowNewSession());

        #ifdef _DEBUG
        #define new DEBUG_NEW
        #endif
                //
                // server side. check if there is a free session on the macine and
                // if the DestGuid is me and the supported packet version
                //
                // we arrive here only if the another machine
                // We don't check the number of active session in accept since we want to limited
                // the situation that the other side try to create a new session immidiatly.
                // If we use the refuse mechanism the queue move to waiting group only after some
                // time, we try to create connection again. This come to limit unnecessary network
                // traffic
                //
                if (((*(pECP->GetServerQMGuid()) != GUID_NULL) && (! QmpIsLocalMachine(pECP->GetServerQMGuid()))) ||
                    (pECP->GetVersion() != FALCON_PACKET_VERSION) ||
                    (!fAllowNewSession))
                {
                    pInternalSect->SetRefuseConnectionFlag();
                }
                else
                {
                    SetQMId(pECP->GetClientQMGuid());
                }
            }
        }

        TrTRACE(NETWORKING, "Write to socket %ls Handle establish. Write %d bytes",  GetStrAddr(), dwPacketSize);
        HRESULT hr = SendInternalPacket(pPkt, dwPacketSize);
        UNREFERENCED_PARAMETER(hr);
    }

/*====================================================

  CSockTransport::HandleConnectionParameterPacket

  Arguments:    pcPacket - pointer to Connection Parameter Packet

  Return Value: None. Throws an exception.

=====================================================*/

void
CSockTransport::HandleConnectionParameterPacket(
    CBaseHeader* pBase
    )
    throw(bad_alloc)
{
    CS lock(m_cs);

    if (GetSessionStatus() != ssEstablish)
    {
    	//
    	// this can not be unless someone is hacking us
    	//
    	TrERROR(NETWORKING, "Recieved Connection Parameter Packet twice");
        ASSERT_BENIGN(0);
		throw exception();
    }

    HRESULT hr;
    CInternalSection* pInternal = pBase->section_cast<CInternalSection*>(pBase->GetNextSection());
    CCPSection* pCP = pBase->section_cast<CCPSection*>(pInternal->GetNextSection());

    ASSERT(pInternal->GetPacketType() == INTERNAL_CONNECTION_PARAMETER_PACKET);

    TrTRACE(NETWORKING, "Get connection Parameter packet from: %ls (Client = %d)\n\t\tAckTimeout %d, Recover  %d, window size %d",
                GetStrAddr(), IsClient(),pCP->GetAckTimeout(), pCP->GetRecoverAckTimeout(), pCP->GetWindowSize());

    if (IsConnectionClosed())
    {
        //The session was closed
        return;
    }

    if (!IsClient())
    {
        //
        // Set the connection parameters
        //
        m_dwAckTimeout =          pCP->GetAckTimeout();
        m_dwSendAckTimeout =      m_dwAckTimeout/2;
        m_dwSendStoreAckTimeout = pCP->GetRecoverAckTimeout();
        //
        // Set Server window size. And send CP Packet to the client
        //
        m_wRecvWindowSize = pCP->GetWindowSize();

        DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CCPSection);
        PVOID pPkt = new UCHAR[dwPacketSize];
        CCPSection* pCPSection;
#ifdef _DEBUG
#undef new
#endif
        CBaseHeader* pBaseSend = new(pPkt) CBaseHeader(dwPacketSize);
        pBaseSend->SetType(FALCON_INTERNAL_PACKET);
        PVOID pSect = (PVOID) pBaseSend->GetNextSection();

        CInternalSection* pInternalSend = new(pSect) CInternalSection(INTERNAL_CONNECTION_PARAMETER_PACKET);
        pSect = (PVOID) pInternalSend->GetNextSection();

        pCPSection = new(pSect) CCPSection(SessionMgr.GetWindowSize(),
                                           m_dwSendStoreAckTimeout,
                                           m_dwAckTimeout,
                                           0);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
        //
        // In this stage no one else can catch the m_csSend since the
        // SendAck wasn't set yet and user messages are not send
        //
        TrTRACE(NETWORKING, "Write to socket %ls Create Connection Packet. Write %d bytes", GetStrAddr(),  dwPacketSize);
        hr = SendInternalPacket(pPkt, dwPacketSize);

        //
        // Check if the connection has been closed
        //
        if (FAILED(hr))
        {
            return;
        }
    }
    else
    {
        // client side
        if ((m_dwAckTimeout != pCP->GetAckTimeout()) || (m_dwSendStoreAckTimeout != pCP->GetRecoverAckTimeout()))
        	{
		    	TrERROR(NETWORKING, "Connection Parameter Packet is not valid");
			    ASSERT_BENIGN(m_dwAckTimeout == pCP->GetAckTimeout());
			    ASSERT_BENIGN(m_dwSendStoreAckTimeout == pCP->GetRecoverAckTimeout());
				throw exception();
        	}
        m_wRecvWindowSize = pCP->GetWindowSize();
    }

    SessionMgr.NotifyWaitingQueue(GetSessionAddress(), this);

#ifdef _DEBUG
    TrTRACE(NETWORKING, "Session created with %ls", GetStrAddr());
    TrTRACE(NETWORKING, "\tAckTimeout value: %d", m_dwAckTimeout);
    TrTRACE(NETWORKING, "\tSend Storage AckTimeout value: %d", m_dwSendStoreAckTimeout);
    TrTRACE(NETWORKING, "\tSend window size: %d", SessionMgr.GetWindowSize());
    TrTRACE(NETWORKING, "\tReceive window size: %d", m_wRecvWindowSize);
#endif



    if (GetGroup() != NULL)
    {
        //
        // Set all the queues in group as active
        //
        GetGroup()->EstablishConnectionCompleted();
        //
        // Create a get request from new group
        //
        hr = GetNextSendMessage();
    }

    //
    // The establish connection completed successfully. Remove the callinig to failure
    // handling function
    //
    SetSessionStatus(ssActive);
    if(ExCancelTimer(&m_CancelConnectionTimer))
    {
        Release();  // Release Establish connection reference count
    }

    //
    // Windows bug 612988
    // We have a session. connection completed successfully.
    // mark it as "not in connection process".
    //
    SessionMgr.MarkAddressAsNotConnecting( GetSessionAddress(),
                                           m_guidDstQM,
                                           m_fQoS ) ;

    if (!IsOtherSideServer())
    {
        //
        // Increment the number of active session
        //
        g_QMLicense.IncrementActiveConnections(&m_guidDstQM, NULL);
    }

    if (IsDisconnected())
    {
        Disconnect();
    }

}

    /*====================================================

      CSockTransport::CreateConnectionParameterPacket

      Arguments:

      Return Value:

    =====================================================*/
    void
    CSockTransport::CreateConnectionParameterPacket(IN DWORD dwSendTime,
                                                   OUT CBaseHeader** ppPkt,
                                                   OUT DWORD* pdwPacketSize)
    {

        //
        // Set session acking timeout
        //
        if (CSessionMgr::m_dwSessionAckTimeout != INFINITE)
        {
            m_dwAckTimeout = CSessionMgr::m_dwSessionAckTimeout;
        }
        else
        {
            //
            // ACK Timeout
            //
            m_dwAckTimeout = dwSendTime * 80 * 10;
            //
            // Check if less than the minimume or grater than the maximume
            //
            if (MSMQ_MIN_ACKTIMEOUT > m_dwAckTimeout)
            {
                m_dwAckTimeout = MSMQ_MIN_ACKTIMEOUT;
            }
            if (m_dwAckTimeout > MSMQ_MAX_ACKTIMEOUT)
            {
                m_dwAckTimeout  = MSMQ_MAX_ACKTIMEOUT;
            }
        }

        //
        // Set send ack timeout
        //
        m_dwSendAckTimeout = m_dwAckTimeout / 4;

        //
        // Set storage ack timeout
        //
        if (CSessionMgr::m_dwSessionStoreAckTimeout != INFINITE)
        {
            m_dwSendStoreAckTimeout = CSessionMgr::m_dwSessionStoreAckTimeout;
        }
        else
        {
            //
            // ACK Timeout
            //
            m_dwSendStoreAckTimeout = dwSendTime * 8;

            //
            // Check if greater than the minimume value
            //
            if (MSMQ_MIN_STORE_ACKTIMEOUT > m_dwSendStoreAckTimeout)
            {
                m_dwSendStoreAckTimeout = MSMQ_MIN_STORE_ACKTIMEOUT;
            }
            //
            // Set storage ack sending timeout
            //
            if (m_dwSendStoreAckTimeout > m_dwSendAckTimeout)
            {
                m_dwSendStoreAckTimeout = m_dwSendAckTimeout;
            }
        }

        DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CCPSection);
        PVOID pPkt = new UCHAR[dwPacketSize];
    #ifdef _DEBUG
    #undef new
    #endif
        CBaseHeader* pBase = new(pPkt) CBaseHeader(dwPacketSize);
        pBase->SetType(FALCON_INTERNAL_PACKET);
        PVOID pSect = (PVOID) pBase->GetNextSection();

        CInternalSection* pInternal = new(pSect) CInternalSection(INTERNAL_CONNECTION_PARAMETER_PACKET);
        pSect = pInternal->GetNextSection();

        CCPSection* pCPSection = new(pSect) CCPSection((WORD)SessionMgr.GetWindowSize(),
                                                       m_dwSendStoreAckTimeout,
                                                       m_dwAckTimeout,
                                                       0);
        UNREFERENCED_PARAMETER(pCPSection);

        TrTRACE(NETWORKING, "ESTABLISH CONNECTION (client): Send Connection Parameter packet: AckTimeout %d, Recover  %d, window size %d",
                                                   m_dwAckTimeout, m_dwSendStoreAckTimeout, SessionMgr.GetWindowSize());
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif

        *ppPkt = pBase;
        *pdwPacketSize = dwPacketSize;
    }



    /*====================================================

    SendEstablishConnectionPacket

    Arguments:

    Return Value:

    Note : This function cant throw   exception because receiver already listen on the connection
    =====================================================*/
    void
    CSockTransport::SendEstablishConnectionPacket(
        const GUID* pDstQMId,
        BOOL fCheckNewSession
        ) throw()
    {

        try
        {
            //
            // Set timer to check that the connection completed successfully. If yes, the function
            // is removed from the scheduler wakeup list and never is called. Otherwise, the function
            // close the session and move all the associated queues to non-active group.
            //
            ExSetTimer(&m_CancelConnectionTimer, CTimeDuration::FromMilliSeconds(ESTABLISH_CONNECTION_TIMEOUT));


            DWORD dwPacketSize;
            PVOID pPacket;
            HRESULT hr;
            CECSection* pECSession;


            dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CECSection);
            pPacket = new UCHAR[dwPacketSize];

        #ifdef _DEBUG
        #undef new
        #endif
            CBaseHeader* pBase = new(pPacket) CBaseHeader(dwPacketSize);
            pBase->SetType(FALCON_INTERNAL_PACKET);
            PVOID pSect = (PVOID) pBase->GetNextSection();

            CInternalSection* pInternal = new(pSect) CInternalSection(INTERNAL_ESTABLISH_CONNECTION_PACKET);
            pSect = pInternal->GetNextSection();

            pECSession = new(pSect) CECSection(CQueueMgr::GetQMGuid(),
                                               pDstQMId,
                                               OS_SERVER(g_dwOperatingSystem),
                                               m_fQoS
                                               );
            pECSession->CheckAllowNewSession(fCheckNewSession);
        #ifdef _DEBUG
        #define new DEBUG_NEW
        #endif

            TrTRACE(NETWORKING, "Write to socket %ls Establish Connection Packet. Write %d bytes", GetStrAddr(),  dwPacketSize);
            hr = SendInternalPacket(pPacket, dwPacketSize);

            //
            // Check if the connection has been closed
            //
            if (FAILED(hr))
            {
                return;
            }

            TrTRACE(NETWORKING, "ESTABLISH CONNECTION (client): Send Establish connection packet to " LOG_GUID_FMT, LOG_GUID(pDstQMId));

        }

        catch(const std::exception&)
        {
            TrERROR(NETWORKING,  "Unexpected error in function CSockTransport::SendEstablishConnectionPacket");
            LogIllegalPoint(s_FN, 800);
        }
    }





    void
    CTransportBase::EstablishConnectionNotCompleted(void)
    {
        CS lock(m_cs);


        //
        // Close connection. If this function is called the establish
        // connection not completed from any reason.
        //
        Close_Connection(this, L"EstablishConnectionNotCompleted");
        //
        // Decrement reference count
        //
        Release();

    }


    void
    CSockTransport::CloseDisconnectedSession(
        void
        )
    {
        ASSERT(IsDisconnected());
        ASSERT(m_fCloseDisconnectedScheduled);

        if (!IsUsedSession())
        {
            Close_Connection(this, L"Disconnect network");
            Release();

            return;
        }

        SetUsedFlag(FALSE);
        ExSetTimer(&m_CloseDisconnectedTimer, CTimeDuration::FromMilliSeconds(1000));
    }


    void
    CSockTransport::Disconnect(
        void
        )
    {
        CS lock(m_cs);

        SetDisconnected();
        if ((GetSessionStatus() == ssActive) && !m_fCloseDisconnectedScheduled)
        {
            TrTRACE(NETWORKING, "Disconnect ssesion with %ls", GetStrAddr());

            SendReadAck();

            m_fCloseDisconnectedScheduled = TRUE;
            AddRef();
            ExSetTimer(&m_CloseDisconnectedTimer, CTimeDuration::FromMilliSeconds(1000));
        }
    }

    void
    CSockTransport::UpdateNumberOfStorageUnacked(
        WORD BaseNo,
        DWORD BitField
        )
    {
        if (BaseNo == 0)
            return;

        TrTRACE(NETWORKING, "(0x%p %ls) UpdateNumberOfStorageUnacked. \n\tBaseNo: %d, \n\tBitField: 0x%x \n\tm_lStoredPktReceivedNoAckedCount %d",
                this, this->GetStrAddr(), BaseNo, BitField, m_lStoredPktReceivedNoAckedCount);

        LONG RetVal = InterlockedDecrement(&m_lStoredPktReceivedNoAckedCount);

        ASSERT(RetVal >= 0);

        for (DWORD i = 0; i < STORED_ACK_BITFIELD_SIZE; ++i)
        {
           if (BitField & (1 << i))
           {
                RetVal = InterlockedDecrement(&m_lStoredPktReceivedNoAckedCount);
                ASSERT(RetVal >= 0);
                DBG_USED(RetVal);
           }
        }
    }

    /*======================================================

       FUNCTION: CSockTransport::IsUsedSession

    ========================================================*/
    inline BOOL
    CSockTransport::IsUsedSession(void) const
    {
        //
        // The session already closed, it Is n't used any more
        //
        if (IsConnectionClosed())
            return FALSE;

        //
        // The session was used for receive or send from the last check point
        //
        if (GetUsedFlag())
            return TRUE;

        //
        // There is pending message that waiting for acknowledgment
        //
        if (!(m_listUnackedPkts.IsEmpty() && m_listStoredUnackedPkts.IsEmpty()))
            return TRUE;

        //
        // Acknowledge message must be sent
        //
        if (m_fSendAck || (m_lStoredPktReceivedNoAckedCount != 0))
            return TRUE;

        return FALSE;
    }

    void
    WINAPI
    CSockTransport::SendFastAcknowledge(
        CTimer* pTimer
        )
    /*++
    Routine Description:
        The function is called from scheduler when fast sending acknowledge
        timeout is expired.

    Arguments:
        pTimer - Pointer to Timer structure. pTimer is part of the sock transport
                 object and it use to retrive the transport object.

    Return Value:
        None

    --*/
    {
        CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_FastAckTimer);

        TrTRACE(NETWORKING, "Send Fast acknowledge for session %ls", pSock->GetStrAddr());
        pSock->SendFastAckPacket();
    }


    void
    CSockTransport::SetFastAcknowledgeTimer(
        void
        )
    {
        //
        // try to cancel the previous sceduling
        //
        if (!ExCancelTimer(&m_FastAckTimer))
        {
            //
            // cancel failed. It means that there is no pending timer.
            // As a result begin a new timer and increment the sock transport
            // reference count
            //
            AddRef();
        }
        else
        {
            TrTRACE(NETWORKING, "Cancel Fast acknowledge for session %ls", GetStrAddr());
        }

        //
        // Set a new timer for sending fast acknowledge
        //
        ExSetTimer(&m_FastAckTimer, CTimeDuration::FromMilliSeconds(CSessionMgr::m_dwIdleAckDelay));

        TrTRACE(NETWORKING, "Set Fast acknowledge for session %ls, Max Delay %d ms", GetStrAddr(), CSessionMgr::m_dwIdleAckDelay);

    }


    inline
    void
    CSockTransport::SendFastAckPacket(
        void
        )
    {
        //
        // when the session is in disconnected mode, MSMQ doesn't return an acknowledge
        // for receiving messages.
        // An acknowledge for recoverable messages are handled using the SendAck mechanism
        //
        if (m_fSendAck && !IsDisconnected())
        {
            SendReadAck();
        }

        Release();
    }


    void
    WINAPI
    CSockTransport::TimeToCheckAckReceived(
        CTimer* pTimer
        )
    /*++
    Routine Description:
        The function is called from scheduler when Check for ack
        timeout is expired.

    Arguments:
        pTimer - Pointer to Timer structure. pTimer is part of the sock transport
                 object and it use to retrive the transport object.

    Return Value:
        None

    --*/
    {
        CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CheckAckReceivedTimer);
        pSock->CheckForAck();
    }


    void
    WINAPI
    CSockTransport::TimeToSendAck(
        CTimer* pTimer
        )
    /*++
    Routine Description:
        The function is called from scheduler when need to send an acknowledge

    Arguments:
        pTimer - Pointer to Timer structure. pTimer is part of the sock transport
                 object and it use to retrive the transport object.

    Return Value:
        None

    --*/
    {
        CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_SendAckTimer);
        pSock->SendAckPacket();
    }



    void
    WINAPI
    CSockTransport::TimeToCancelConnection(
        CTimer* pTimer
        )
    {
        CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CancelConnectionTimer);
        pSock->EstablishConnectionNotCompleted();
    }


    void
    WINAPI
    CSockTransport::TimeToCloseDisconnectedSession(
        CTimer* pTimer
        )
    {
        CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CloseDisconnectedTimer);
        pSock->CloseDisconnectedSession();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard include file for QM componenet

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include "transact.h"

#include <mqsymbls.h>
#include <mqprops.h>
#include <mqtypes.h>
#include <_mqdef.h>
#include <mqutil.h>
#include <cs.h>
#include <mqlog.h>
#include <ev.h>

bool IsRoutingServer(void);
bool IsDepClientsServer(void);
bool IsNonServer(void);

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\sessmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    sessmgr.h

Abstract:
    Network session Menager definition

Author:
    Uri Habusha (urih)

--*/
#ifndef __SESSIONMGR_H__
#define __SESSIONMGR_H__

#include <winsock.h>
#include "qmpkt.h"
#include "factory.h"
#include "qmperf.h"
#include "cgroup.h"
#include "session.h"
#include "license.h"


//
// struct WAIT_INFO represent addresses of remote comptuers that wait to
// be connected, i.e., local QM need to establish a session with each of
// these addresses.
//

struct WAIT_INFO
{
    WAIT_INFO(TA_ADDRESS* _pAddr, const GUID& _guidQMId, BOOL _fQoS);

    TA_ADDRESS* pAddr;
    GUID guidQMId;
    BOOL fQoS;

     //
     // fInConnectionProcess is set to TRUE when and while trying to connect
     // to this address. It's FALSE in all other timers. See Winows bug 612988.
     // This flag is needed to prevent the scenario where multiple worker
     // threads try to connect to same address and so pool of worker threads
     // is exhausted.
     //
    BOOL fInConnectionProcess ;
};

//
// CMap helper function decleration
//
template<>
void AFXAPI DestructElements(IN WAIT_INFO** ppNextHop, int n);
template<>
UINT AFXAPI HashKey(IN WAIT_INFO* key);
template<>
BOOL AFXAPI CompareElements(IN WAIT_INFO* const * pElem1,
                            IN WAIT_INFO* const * pElem2);


class CQueue;
class CTransportBase;
class CAddress;


class CSessionMgr
{
public:

    CSessionMgr();

    HRESULT Init();
    void    BeginAccept();

    HRESULT GetSession(IN DWORD             dwFlag,
                       IN const CQueue *    hDstQ,
                       IN DWORD             dwNoOfTargets,
                       IN const CAddress* apTaAddr,
                       IN const GUID*       aQMId[],
                       IN bool              fQoS,
                       OUT CTransportBase**  ppSession);

    HRESULT GetSessionForDirectQueue(IN  CQueue*     pQueue,
                                     OUT CTransportBase**  ppSession);

    void    RemoveWaitingQueue(CQueue* pQueue);
    void    AddWaitingQueue(CQueue* pQueue);
    void    MoveQueueFromWaitingToNonActiveGroup(CQueue* pQueue);

    void
    NotifyWaitingQueue(
        IN const TA_ADDRESS* pa,
        IN CTransportBase * pSess
        )
        throw(std::bad_alloc);


    void    TryConnect();

    void    ReleaseSession(void);

    void    AcceptSockSession(IN TA_ADDRESS *pa, IN CSocketHandle& CSocketHandle);

    //
    // Administration routines
    //
    HRESULT
    ListPossibleNextHops(
        const CQueue* pQueue,
        LPWSTR** pNextHopAddress,
        DWORD* pNoOfNextHops
        );

    void ConnectNetwork(void);
    void DisconnectNetwork(void);

    WORD    GetWindowSize() const;
    void    SetWindowSize(WORD);
    void    UpdateWindowSize(void);

    static DWORD m_dwSessionAckTimeout;
    static DWORD m_dwSessionStoreAckTimeout;
    static BOOL  m_fUsePing;
    static HANDLE m_hAcceptAllowed;
    static DWORD m_dwIdleAckDelay;
    static bool  m_fUseQoS;
    static AP<char> m_pszMsmqAppName;
    static AP<char> m_pszMsmqPolicyLocator;
    static bool  m_fAllocateMore;
	static DWORD m_DeliveryRetryTimeOutScale;

    static void WINAPI TimeToSessionCleanup(CTimer* pTimer);
    static void WINAPI TimeToUpdateWindowSize(CTimer* pTimer);
    static void WINAPI TimeToTryConnect(CTimer* pTimer);
    static void WINAPI TimeToRemoveFromWaitingGroup(CTimer* pTimer);

    void  MarkAddressAsNotConnecting(const TA_ADDRESS  *pAddr,
                                     const GUID&        guidQMId,
                                     BOOL               fQoS) ;

	DWORD GetWaitingTimeForQueue(const CQueue* pQueue);


private:           //Private Methods

    void AddWaitingSessions(IN DWORD dwNo,
                            IN const CAddress* apTaAddr,
                            IN const GUID* aQMId[],
                            bool           fQoS,
                            CQueue *pDstQ);

    void NewSession(IN CTransportBase *pSession);

    BOOL GetAddressToTryConnect( OUT WAIT_INFO **ppWaitConnectInfo ) ;

    bool
    IsReusedSession(
        const CTransportBase* pSession,
        DWORD noOdAddress,
        const CAddress* pAddress,
        const GUID** pGuid,
        bool         fQoS
        );

    void MoveAllQueuesFromWaitingToNonActiveGroup(void);

    static void IPInit(void);

    static void
    GetAndAllocateCharKeyValue(
        LPCTSTR     pszValueName,
        char      **ppchResult,
        const char *pchDefault
    );

    static bool
    GetAndAllocateCharKeyValue(
        LPCTSTR     pszValueName,
        char      **ppchResult
    );
	
private:         // Private Data Member

    CCriticalSection    m_csListSess;       // Critical section protect m_listSess
    CCriticalSection    m_csMapWaiting;     // Critical section protect m_mapWaiting, m_listWaitToConnect
    //
    // List of opened sessions
    //
    CList<CTransportBase*, CTransportBase*&>         m_listSess;

    //
    // Map of list of queues waiting for a specific session
    //
    CMap<WAIT_INFO*,
         WAIT_INFO*,
         CList<const CQueue*, const CQueue*&>*,
         CList<const CQueue*, const CQueue*&>*& > m_mapWaiting;

    CList <const CQueue *, const CQueue *&> m_listWaitToConnect;

    static DWORD m_dwSessionCleanTimeout;
    static DWORD m_dwQoSSessionCleanTimeoutMultiplier;

    //
    // Handle dynamic window size
    //

    CCriticalSection m_csWinSize;       // Critical section protect Dynamic Window size
    WORD m_wCurrentWinSize;
    WORD m_wMaxWinSize;
    DWORD m_dwMaxWaitTime;

    BOOL m_fUpdateWinSizeTimerScheduled;
    CTimer m_UpdateWinSizeTimer;

    //
    // Clean Up member variables
    //
    BOOL m_fCleanupTimerScheduled;
    CTimer m_CleanupTimer;

    //
    // Try Connect
    //
    BOOL m_fTryConnectTimerScheduled;
    CTimer m_TryConnectTimer;
};


inline WORD
CSessionMgr::GetWindowSize() const
{
    return m_wCurrentWinSize;
}

/*======================================================

   WAIT_INFO implementation

========================================================*/
inline WAIT_INFO::WAIT_INFO(TA_ADDRESS* _pAddr, const GUID& _guidQMId, BOOL _fQoS) :
    pAddr(_pAddr),
    guidQMId(_guidQMId),
    fInConnectionProcess(FALSE),
    fQoS(_fQoS)
    {}

#endif          // __SESSIONMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\setup.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    setup.cpp

Abstract:

    Auto configuration of QM

Author:

    Shai Kariv (shaik) Mar 18, 1999

Revision History:

--*/

#include "stdh.h"
#include "setup.h"
#include "cqpriv.h"
#include <mqupgrd.h>
#include <mqsec.h>
#include "cqmgr.h"
#include <mqnames.h>
#include "joinstat.h"
#include <ad.h>
#include <autohandle.h>
#include <mqmaps.h>
#include <lqs.h>
#include <strsafe.h>
  
#include "setup.tmh"

extern LPTSTR       g_szMachineName;
extern DWORD g_dwOperatingSystem;

static WCHAR *s_FN=L"setup";

//+---------------------------------------
//
//  CreateDirectoryIdempotent()
//
//+---------------------------------------

VOID
CreateDirectoryIdempotent(
    LPCWSTR pwzFolder
    )
{
    ASSERT(("must get a valid directory name", NULL != pwzFolder));

    if (CreateDirectory(pwzFolder, 0) ||
        ERROR_ALREADY_EXISTS == GetLastError())
    {
        return;
    }

    DWORD gle = GetLastError();
    TrERROR(GENERAL, "failed to create directory %ls", pwzFolder);
    ASSERT(("Failed to create directory!", 0));
    LogNTStatus(gle, s_FN, 166);
    throw CSelfSetupException(CreateDirectory_ERR);

} //CreateDirectoryIdempotent


bool
SetDirectorySecurity(
	LPCWSTR pwzFolder
    )
/*++

Routine Description:

    Sets the security of the given directory such that any file that is created
    in the directory will have full control for  the local administrators group
    and no access at all to anybody else.

    Idempotent.

Arguments:

    pwzFolder - the folder to set the security for

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/
{
    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    P<ACL> pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = (WORD)(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    P<ACCESS_ALLOWED_ACE> pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = OBJECT_INHERIT_ACE;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    bool fRet = true;

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(pwzFolder, DACL_SECURITY_INFORMATION, &SD))
    {
        fRet = false;
    }

    LogBOOL((fRet?TRUE:FALSE), s_FN, 222);
    return fRet;

} //SetDirectorySecurity


VOID
CreateStorageDirectories(
    LPCWSTR MsmqRootDir
    )
{
	TrTRACE(GENERAL, "Creating Storage Directories");

    WCHAR MsmqStorageDir[MAX_PATH];

    HRESULT hr = StringCchCopy(MsmqStorageDir, MAX_PATH, MsmqRootDir);
	ASSERT(SUCCEEDED(hr));
    hr = StringCchCat(MsmqStorageDir, MAX_PATH, DIR_MSMQ_STORAGE);
	ASSERT(SUCCEEDED(hr));

    CreateDirectoryIdempotent(MsmqStorageDir);
    SetDirectorySecurity(MsmqStorageDir);

    WCHAR MsmqLqsDir[MAX_PATH];
    hr = StringCchCopy(MsmqLqsDir, MAX_PATH, MsmqRootDir);
	ASSERT(SUCCEEDED(hr));
    hr = StringCchCat(MsmqLqsDir, MAX_PATH, DIR_MSMQ_LQS);
	ASSERT(SUCCEEDED(hr));

    CreateDirectoryIdempotent(MsmqLqsDir);
    SetDirectorySecurity(MsmqLqsDir);

    DWORD dwType = REG_SZ;
    DWORD dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    LONG rc = SetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

} // CreateStorageDirectories


static 
void
CreateSampleFile(
	LPCWSTR mappingDir,
	LPCWSTR fileName,
	LPCSTR sample,
	DWORD sampleSize
	)
{
    WCHAR MappingFile[MAX_PATH];
    HRESULT hr = StringCchPrintf(MappingFile, MAX_PATH, L"%s\\%s", mappingDir, fileName);
	if(FAILED(hr))
	{
		ASSERT(("MappingFile buffer to small", 0));
		TrERROR(GENERAL, "MappingFile buffer to small, %ls\\%ls", mappingDir, fileName);
		return;
	}

    CHandle hMapFile = CreateFile(
                          MappingFile, 
                          GENERIC_WRITE, 
                          FILE_SHARE_READ, 
                          NULL, 
                          CREATE_ALWAYS,    //overwrite the file if it already exists
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL
                          );
    
	if(hMapFile == INVALID_HANDLE_VALUE)
	{
        DWORD gle = GetLastError();
		TrERROR(GENERAL, "failed to create %ls file, gle = %!winerr!", MappingFile, gle);
		return;
	}

    SetFilePointer(hMapFile, 0, NULL, FILE_END);

    DWORD dwNumBytes = sampleSize;
    BOOL fSucc = WriteFile(hMapFile, sample, sampleSize, &dwNumBytes, NULL);
	if (!fSucc)
	{
		DWORD gle = GetLastError();
        TrERROR(GENERAL, "failed to write sample to %ls file, gle = %!winerr!", MappingFile, gle);
	}
}


VOID
CreateMappingDirectory(
    LPCWSTR MsmqRootDir
    )
{
	TrTRACE(GENERAL, "Creating Mapping Directory");
    
	WCHAR MsmqMapppingDir[MAX_PATH];

    HRESULT hr = StringCchCopy(MsmqMapppingDir, MAX_PATH, MsmqRootDir);
	ASSERT(SUCCEEDED(hr));
    hr = StringCchCat(MsmqMapppingDir, MAX_PATH, DIR_MSMQ_MAPPING);
	ASSERT(SUCCEEDED(hr));
    
    CreateDirectoryIdempotent(MsmqMapppingDir);
    SetDirectorySecurity(MsmqMapppingDir);

	CreateSampleFile(MsmqMapppingDir, MAPPING_FILE, xMappingSample, STRLEN(xMappingSample));
	CreateSampleFile(MsmqMapppingDir, STREAM_RECEIPT_FILE, xStreamReceiptSample, STRLEN(xStreamReceiptSample));
        CreateSampleFile(MsmqMapppingDir, OUTBOUNT_MAPPING_FILE, xOutboundMappingSample, STRLEN(xOutboundMappingSample));
	
} 


VOID
CreateMsmqDirectories(
    VOID
    )
{
	TrTRACE(GENERAL, "Creating Msmq Directories");

    //
    // Keep this routine idempotent !
    //

    WCHAR MsmqRootDir[MAX_PATH];
    DWORD dwType = REG_SZ ;
    DWORD dwSize = MAX_PATH;
    LONG rc = GetFalconKeyValue(
                  MSMQ_ROOT_PATH,
                  &dwType,
                  MsmqRootDir,
                  &dwSize
                  );

    if (ERROR_SUCCESS != rc)
    {
        TrERROR(GENERAL, "failed to read msmq root path from registry");
        ASSERT(("failed to get msmq root path from registry", 0));
        LogNTStatus(rc, s_FN, 167);
        throw CSelfSetupException(ReadRegistry_ERR);
    }

	CreateDirectoryIdempotent(MsmqRootDir);
    SetDirectorySecurity(MsmqRootDir);

	CreateStorageDirectories(MsmqRootDir);

	CreateMappingDirectory(MsmqRootDir);

}  // CreateMsmqDirectories


void
DeleteObsoleteMachineQueues(
	void
	)
{
    HRESULT hr = LQSDelete(REPLICATION_QUEUE_ID);
    if (FAILED(hr))
    {
    	TrERROR(GENERAL, "Failed to delete obsolete internal queue, mqis_queue$. %!hresult!", hr);
    }

    hr = LQSDelete(NT5PEC_REPLICATION_QUEUE_ID);
    if (FAILED(hr))
    {
    	TrERROR(GENERAL, "Failed to delete obsolete internal queue, nt5pec_mqis_queue$. %!hresult!", hr);
    }
}


VOID
CreateMachineQueues(
    VOID
    )
{
    //
    // Keep this routine idempotent !
    //

    WCHAR wzQueuePath[MAX_PATH] = {0};

    HRESULT hr = StringCchPrintf(wzQueuePath, MAX_PATH, L"%s\\private$\\%s", g_szMachineName, ADMINISTRATION_QUEUE_NAME);
    ASSERT(SUCCEEDED(hr));
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, ADMINISTRATION_QUEUE_ID);
    ASSERT(("failed to create admin_queue$", MQ_OK == hr));

    hr = StringCchPrintf(wzQueuePath, MAX_PATH, L"%s\\private$\\%s", g_szMachineName, NOTIFICATION_QUEUE_NAME);
    ASSERT(SUCCEEDED(hr));
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, NOTIFICATION_QUEUE_ID);
    ASSERT(("failed to create notify_queue$", MQ_OK == hr));

    hr = StringCchPrintf(wzQueuePath, MAX_PATH, L"%s\\private$\\%s", g_szMachineName, ORDERING_QUEUE_NAME);
    ASSERT(SUCCEEDED(hr));
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, ORDERING_QUEUE_ID);
    ASSERT(("failed to create order_queue$", MQ_OK == hr));

    hr = StringCchPrintf(wzQueuePath, MAX_PATH, L"%s\\private$\\%s", g_szMachineName, TRIGGERS_QUEUE_NAME);
    ASSERT(SUCCEEDED(hr));
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, TRIGGERS_QUEUE_ID, true);
    ASSERT(("failed to create triggers_queue$", MQ_OK == hr));

    DWORD dwValue = 0x0f;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    LONG rc = SetFalconKeyValue(
                  L"LastPrivateQueueId",
                  &dwType,
                  &dwValue,
                  &dwSize
                  );
    ASSERT(("failed to write LastPrivateQueueId to registry", ERROR_SUCCESS == rc));

    	
	LogNTStatus(rc, s_FN, 223);

} //CreateMachineQueues



static void SetQmQuotaToDs()
/*++

Routine Description:

	sets the PROPID_QM_QUOTA property in the DS to the value from the registry key MSMQ_MACHINE_QUOTA_REGNAME.
Arguments:

    None
	
Return Value:

    None

--*/
{
	TrTRACE(GENERAL, "Setting the computer quota in the directory service");

	PROPID paPropid[] = { PROPID_QM_QUOTA };
	PROPVARIANT apVar[TABLE_SIZE(paPropid)];

	DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;		
	DWORD dwQuotaValue = DEFAULT_QM_QUOTA;

	DWORD dwErr = GetFalconKeyValue(
						MSMQ_MACHINE_QUOTA_REGNAME, 
						&dwType, 
						&dwQuotaValue, 
						&dwSize
						);

    if(dwErr != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "MSMQ_MACHINE_QUOTA_REGNAME could not be obtained from the registry. Err- %lut", dwErr);
		return ;
	}

    apVar[0].vt = VT_UI4;
    apVar[0].ulVal = dwQuotaValue ;
   	
	HRESULT hr = ADSetObjectPropertiesGuid(
                        eMACHINE,
                        NULL,
						false,	// fServerName
                        QueueMgr.GetQMGuid(),
                        TABLE_SIZE(paPropid), 
                        paPropid, 
                        apVar
                        );
	if (FAILED(hr))
    {
		TrERROR(GENERAL, "ADSetObjectPropertiesGuid failed. PROPID = %d, %!hresult!", paPropid[0], hr); 
		return;
	}
}


VOID UpgradeMsmqSetupInAds()
/*++

Routine Description:
	Update msmq properties in AD on upgrade.
	1) update msmq configuration properties.
	2) Add enhanced encryption support - create MSMQ_128 container in doesn't exist.
	3) update the qm quota property.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    //
    // Update msmq configuration object properties in the DS
    //
    PROPID aProp[] = {PROPID_QM_OS};
    PROPVARIANT aVar[TABLE_SIZE(aProp)];

    aVar[0].vt = VT_UI4;
    aVar[0].ulVal = g_dwOperatingSystem;

    HRESULT hr = ADSetObjectPropertiesGuid(
					eMACHINE,
					NULL,		// pwcsDomainController
					false,		// fServerName
					QueueMgr.GetQMGuid(),
                    TABLE_SIZE(aProp),
                    aProp,
                    aVar
					);

    if (FAILED(hr))
    {
	    TrERROR(GENERAL, "Failed to update PROPID_QM_OS in AD on upgrade, %!hresult!", hr);
    }

	//
	// Add enhanced encryption support if doesn't exist.
	// Create MSMQ_128 container and enhanced encryption keys if needed (fRegenerate = false).
	//
    hr = MQSec_StorePubKeysInDS(
                false, // fRegenerate 
                NULL,
                MQDS_MACHINE
                );

    if (FAILED(hr))
    {
	    TrERROR(GENERAL, "MQSec_StorePubKeysInDS failed, %!hresult!", hr);
    }
		
	//
	// Write the qm quota property to the DS according to the value in the MSMQ_MACHINE_QUOTA_REGNAME
	//
	SetQmQuotaToDs();
}


//+------------------------------------------------------------------------
//
//  HRESULT  CreateTheConfigObj()
//
//  Create the msmqConfiguration object in the Active Directory.
//
//+------------------------------------------------------------------------

HRESULT  CreateTheConfigObj()
{
    CAutoFreeLibrary hLib = LoadLibrary(MQUPGRD_DLL_NAME);

    if (hLib == NULL)
    {
        DWORD gle = GetLastError();
        TrERROR(GENERAL, "Failed to load mqupgrd.dll. Error: %!winerr!", gle);
        EvReportWithError(LoadMqupgrd_ERR, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    pfCreateMsmqObj_ROUTINE pfCreateMsmqObj = (pfCreateMsmqObj_ROUTINE)
                                   GetProcAddress(hLib, "MqCreateMsmqObj") ;
    if (NULL == pfCreateMsmqObj)
    {
        DWORD gle = GetLastError();
        TrERROR(GENERAL, "Failed to get MqCreateMsmqObj function address from mqupgrd.dll. Error: %!winerr!", gle);
        EvReportWithError(GetAdrsCreateObj_ERR, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    HRESULT hr = pfCreateMsmqObj();

    if (SUCCEEDED(hr))
    {                
        //
        // We successfully created the object in active directory.
        // Store distinguished name of computer in registry. This will
        // be used later if machine move between domains.
        //
        SetMachineForDomain() ;
	}

    return LogHR(hr, s_FN, 30);
}

//+------------------------------------------------------------------------
//
//  VOID  CompleteMsmqSetupInAds()
//
//  Create the msmqConfiguration object in the Active Directory. that's
//  part of setup, and it's actually complete setup of msmq client on
//  machine that's part of Win2000 domain.
//
//+------------------------------------------------------------------------

VOID  CompleteMsmqSetupInAds()
{
    HRESULT hr = MQ_ERROR ;

    try
    {
        //
        // Guarantee that the code below never generate an unexpected
        // exception. The "throw" below notify any error to the msmq service.
        //
        DWORD dwType = REG_DWORD ;
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwCreate = 0 ;

        LONG rc = GetFalconKeyValue( MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                                    &dwType,
                                    &dwCreate,
                                    &dwSize ) ;
        if ((rc != ERROR_SUCCESS) || (dwCreate == 0))
        {
            //
            // No need to create the msmq configuration object.
            //
            return ;
        }

        hr = CreateTheConfigObj();

        QmpReportServiceProgress();

        //
        // Write hr to registry. Setup is waiting for it, to terminate.
        //
        dwType = REG_DWORD ;
        dwSize = sizeof(DWORD) ;

        rc = SetFalconKeyValue( MSMQ_CONFIG_OBJ_RESULT_REGNAME,
                               &dwType,
                               &hr,
                               &dwSize ) ;
        ASSERT(rc == ERROR_SUCCESS) ;

        if (SUCCEEDED(hr))
        {
            //
            // Reset the create flag in registry.
            //
            dwType = REG_DWORD ;
            dwSize = sizeof(DWORD) ;
            dwCreate = 0 ;

            rc = SetFalconKeyValue( MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                                   &dwType,
                                   &dwCreate,
                                   &dwSize ) ;
            ASSERT(rc == ERROR_SUCCESS) ;

            //
            // write successful join status. Needed for code that test
            // for join/leave transitions.
            //
            DWORD dwJoinStatus = MSMQ_JOIN_STATUS_JOINED_SUCCESSFULLY ;
            dwSize = sizeof(DWORD) ;
            dwType = REG_DWORD ;

            rc = SetFalconKeyValue( MSMQ_JOIN_STATUS_REGNAME,
                                   &dwType,
                                   &dwJoinStatus,
                                   &dwSize ) ;
            ASSERT(rc == ERROR_SUCCESS) ;
        }
    }
    catch(const exception&)
    {
         LogIllegalPoint(s_FN, 81);
    }

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 168);
        throw CSelfSetupException(CreateMsmqObj_ERR);
    }
}

//+------------------------------------------------------------------
//
//  void   AddMachineSecurity()
//
//  Save cached default machine security descriptor in registry.
//  This descriptor grant full control to everyone.
//
//+------------------------------------------------------------------

void   AddMachineSecurity()
{
    PSECURITY_DESCRIPTOR pDescriptor = NULL ;
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
                                  MQDS_MACHINE,
                                 &pDescriptor,
                                  FALSE,  // fImpersonate
                                  NULL,
                                  0,      // seInfoToRemove
                                  e_GrantFullControlToEveryone ) ;
    if (FAILED(hr))
    {
        return ;
    }

    P<BYTE> pBuf = (BYTE*) pDescriptor ;

    DWORD dwSize = GetSecurityDescriptorLength(pDescriptor) ;

    hr = SetMachineSecurityCache(pDescriptor, dwSize) ;
    LogHR(hr, s_FN, 226);
}

//+------------------------------------------------------------------------
//
//  VOID  CompleteServerUpgrade()
//
//  This function only update the MSMQ_MQS_ROUTING_REGNAME
//  for server upgrade.
//	All other Ds related updates are done in mqdssvc (mqds service)
//
//+------------------------------------------------------------------------

VOID  CompleteServerUpgrade()
{
    //
    // get MQS value from registry to know what service type was before upgrade
    // don't change this flag in registry: we need it after QmpInitializeInternal
    // (in order to change machine setting) !!!
    //
    DWORD dwDef = 0xfffe ;
    DWORD dwMQS;
    READ_REG_DWORD(dwMQS, MSMQ_MQS_REGNAME, &dwDef);

    if (dwMQS == dwDef)
    {
       TrWARNING(GENERAL, "QMInit :: Could not retrieve data for value MQS in registry");
	      return ;
    }

    if (dwMQS < SERVICE_BSC || dwMQS > SERVICE_PSC)
    {
        //
        // this machine was neither BSC nor PSC. do nothing
        //
        return;
    }

    //
    // We are here iff this computer was either BSC or PSC 
    // In whistler terms: routing or down level client was installed.
	//

    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;		
	DWORD  dwValue;

    DWORD dwErr = GetFalconKeyValue( 
						MSMQ_MQS_ROUTING_REGNAME,
						&dwType,
						&dwValue,
						&dwSize 
						);

	if (dwErr != ERROR_SUCCESS)
    {
        //
        // Set routing flag to 1 only if not set at all.
        // If it's 0, then keep it 0. We're only concerned here with upgrade
        // of nt4 BSC and we don't want to change functionality of win2k
        // server after dcunpromo.
        //
       	// change MQS_Routing value to 1. this server is routing server
    	//

        dwValue = 1;
        dwErr = SetFalconKeyValue( 
					MSMQ_MQS_ROUTING_REGNAME,
					&dwType,
					&dwValue,
					&dwSize 
					);

        if (dwErr != ERROR_SUCCESS)
        {
            TrWARNING(GENERAL, "CompleteServerUpgrade()- Could not set MQS_Routing. Err- %lut", dwErr);
        }
    }

    //
    // Update Queue Manager
    //
    dwErr = QueueMgr.SetMQSRouting();
    if(FAILED(dwErr))
    {
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\setup.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    setup.h

Abstract:

    Header for auto configuration of QM

Author:

    Shai Kariv (shaik) Mar 18, 1999

Revision History:

--*/

#ifndef _MQQM_SETUP_H_
#define _MQQM_SETUP_H_

#include "stdh.h"
#include "mqreport.h"


struct CSelfSetupException : public std::exception
{
    CSelfSetupException(EVENTLOGID id):m_id(id) {};
    ~CSelfSetupException() {};

    EVENTLOGID m_id;
};


VOID
CreateMsmqDirectories(
    VOID
    );


void
DeleteObsoleteMachineQueues(
	void
	);


VOID
CreateMachineQueues(
    VOID
    );


VOID
UpgradeMsmqSetupInAds(
    VOID
    );


VOID
CompleteMsmqSetupInAds(
    VOID
    );

HRESULT
CreateTheConfigObj(
    VOID
	);


void   AddMachineSecurity();

VOID  CompleteServerUpgrade();

#endif //_MQQM_SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\verifysignmqf.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    VerifySignMqf.h

Abstract:
    functions to verify mqf signature 

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#ifndef _VERIFYSIGNMQF_H_
#define _VERIFYSIGNMQF_H_


void
VerifySignatureMqf(
	CQmPacket *PktPtrs, 
	HCRYPTPROV hProv, 
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	);


#endif // _VERIFYSIGNMQF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\usermap.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usermap.cpp

Abstract:

    Maps a users to the global groups that they belongs to.

Author:

    Boaz Feldbaum 	(BoazF) 2-May-1996
    Ilan Herbst 	(Ilanh) 13-Mar-2002

--*/

#include "stdh.h"
#include "qmsecutl.h"
#include "cache.h"
#include "mqsec.h"
#include "Authz.h"
#include "autoauthz.h"
#include "mqexception.h"
#include "cm.h"

#include "usermap.tmh"

static WCHAR *s_FN=L"usermap";

extern BOOL g_fWorkGroupInstallation;


class CUserSid
{
public:
    CUserSid(); // Constructor.
    ~CUserSid(); // Destractor.

public:
    void SetSid(const void *PSID); // Set the SID.
    const void *GetSid() const; // Get the SID.
    CUserSid& operator=(const CUserSid &UserSid); // Copy the SID when assigning.

private:
    CUserSid(const CUserSid &);

private:
    PSID m_pSid;
};

/***************************************************************************

Function:
    CUserSid::CUserSid

Description:
    Constructor. The CUserSid class is used for holding the SID of a user
    in a CMap.

***************************************************************************/
CUserSid::CUserSid()
{
    m_pSid = NULL;
}


/***************************************************************************

Function:
    CUserSid::CUserSid

Description:
    Destractor.

***************************************************************************/
CUserSid::~CUserSid()
{
    delete[] (char*)m_pSid;
}

/***************************************************************************

Function:
    CUserSid::SetSid

Description:
    Set the SID of the object. Allocate memory for the SID and copy the SID
    into the object.

***************************************************************************/
inline
void CUserSid::SetSid(const void *pSid)
{
    DWORD n = GetLengthSid(const_cast<PSID>(pSid));

    delete[] (char*)m_pSid;

    m_pSid = (PSID)new char[n];
    CopySid(n, m_pSid, const_cast<PSID>(pSid));
}

/***************************************************************************

Function:
    CUserSid::GetSid

Description:
    Get the SID from the object.

***************************************************************************/
inline
const void *CUserSid::GetSid() const
{
    return m_pSid;
}

/***************************************************************************

Function:
    CUserSid::operator=

Description:
    Copy the SID when assigning value from one CUserSid object to another.

***************************************************************************/
inline CUserSid& CUserSid::operator=(const CUserSid &UserSid)
{
    SetSid(UserSid.GetSid());

    return *this;
}

// Calculate the CRC value of a buffer.
inline UINT Crc(BYTE *pBuff, DWORD n)
{
    DWORD i;
    UINT nHash = 0;

    for (i = 0; i < n; i++, pBuff++)
    {
        nHash = (nHash<<5) + nHash + *pBuff;
    }

    return nHash;
}

// Helper function for the CMap.
template<>
inline UINT AFXAPI HashKey(const CUserSid &UserSid)
{
    DWORD n = GetLengthSid(const_cast<PSID>(UserSid.GetSid()));

    return Crc((BYTE*)UserSid.GetSid(), n);
}

// Helper function for the CMap.
template<>
inline BOOL AFXAPI CompareElements(const CUserSid *pSid1, const CUserSid *pSid2)
{
    return EqualSid(const_cast<PSID>((*pSid1).GetSid()),
                    const_cast<PSID>((*pSid2).GetSid()));
}


static
DWORD 
GetAuthzFlags()
/*++

Routine Description:
    Read Authz flags from registry

Arguments:
	None

Return Value:
	Authz flags from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static DWORD s_fAuthzFlags = 0;

	if(s_fInitialized)
	{
		return s_fAuthzFlags;
	}

	const RegEntry xRegEntry(MSMQ_SECURITY_REGKEY, MSMQ_AUTHZ_FLAGS_REGVALUE, 0);
	CmQueryValue(xRegEntry, &s_fAuthzFlags);

	s_fInitialized = true;

	return s_fAuthzFlags;
}


static CAUTHZ_RESOURCE_MANAGER_HANDLE s_ResourceManager;


static 
AUTHZ_RESOURCE_MANAGER_HANDLE 
GetResourceManager()
/*++

Routine Description:
	Get Resource Manager for authz.
	can throw bad_win32_error() if AuthzInitializeResourceManager() fails.

Arguments:
	None.

Returned Value:
	AUTHZ_RESOURCE_MANAGER_HANDLE	
	
--*/
{
    if(s_ResourceManager != NULL)
	{
		return s_ResourceManager;
	}

	//
    // Initilize RM for Access check
	//
	CAUTHZ_RESOURCE_MANAGER_HANDLE ResourceManager;
	if(!AuthzInitializeResourceManager(
			0,
			NULL,
			NULL,
			NULL,
			0,
			&ResourceManager 
			))
	{
		DWORD gle = GetLastError();
	    TrERROR(SECURITY, "AuthzInitializeResourceManager() failed, gle = 0x%x", gle);
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 90);
		throw bad_win32_error(gle);
	}

	if(NULL == InterlockedCompareExchangePointer(
					reinterpret_cast<PVOID*>(&s_ResourceManager), 
					ResourceManager, 
					NULL
					))
	{
		//
		// The exchange was done
		//
		ASSERT(s_ResourceManager == ResourceManager);
		ResourceManager.detach();

	}

	ASSERT(s_ResourceManager != NULL);
	return s_ResourceManager;
}

//
// A cache object that maps from a user SID to AUTHZ_CLIENT_CONTEXT_HANDLE
//
static CCache <CUserSid, const CUserSid&, PCAuthzClientContext, PCAuthzClientContext> g_UserAuthzContextMap;

void
GetClientContext(
	PSID pSenderSid,
    USHORT uSenderIdType,
	PCAuthzClientContext* ppAuthzClientContext
	)
/*++

Routine Description:
	Get Client context from sid.
	can throw bad_win32_error() if AuthzInitializeContextFromSid() fails.

Arguments:
	pSenderSid - pointer to the sender sid 
	uSenderIdType - sender sid type
	ppAuthzClientContext - pointer to authz client context cache value

Returned Value:
	AUTHZ_CLIENT_CONTEXT_HANDLE	
	
--*/
{
	bool fAnonymous = false;
	PSID pSid = NULL;
	
	//
	// For MQMSG_SENDERID_TYPE_SID, MQMSG_SENDERID_TYPE_QM
	// if the message is not signed we trust the information that
	// is in the packet regarding the sid.
	// this is a security hole.
	// this is true for msmq messages (not http messages).
	// In order to solve this security hole, we can reverse the order of receiving
	// msmq messages in session.cpp\VerifyRecvMsg() 
	// first check the signature, if the message is not signed replace the 
	// pSenderSid to NULL, and uSenderIdType to MQMSG_SENDERID_TYPE_NONE.
	//

	DWORD Flags = GetAuthzFlags();
	switch (uSenderIdType)
	{
		case MQMSG_SENDERID_TYPE_NONE:
			fAnonymous = true;
			pSid = MQSec_GetAnonymousSid();
			break;

		case MQMSG_SENDERID_TYPE_SID:
			pSid = pSenderSid;
			break;

		case MQMSG_SENDERID_TYPE_QM:
			//
			// QM is considered as Everyone
			// pSenderSid in this case will be the sending QM guid.
			// which is meaningless as a sid
			//
			pSid = MQSec_GetWorldSid();

			//
			// ISSUE-2001/06/12-ilanh Temporary workaround
			// for Authz failure for everyone sid.
			// need to specify AUTHZ_SKIP_TOKEN_GROUPS 
			// till Authz will fixed the bug regarding well known sids.
			// bug 8190
			//
			Flags |= AUTHZ_SKIP_TOKEN_GROUPS;

			break;

		default:
		    TrERROR(SECURITY, "illegal SenderIdType %d", uSenderIdType);
			ASSERT_BENIGN(("illegal SenderIdType", 0));
			throw bad_win32_error(ERROR_INVALID_SID);
	}

	ASSERT((pSid != NULL) && IsValidSid(pSid));

	TrTRACE(SECURITY, "SenderIdType = %d, Sender sid = %!sid!", uSenderIdType, pSid);

	CUserSid UserSid;
	UserSid.SetSid(pSid);

    CS lock(g_UserAuthzContextMap.m_cs);

	if (g_UserAuthzContextMap.Lookup(UserSid, *ppAuthzClientContext))
	{
		return;
	}

	LUID luid = {0};
	R<CAuthzClientContext> pAuthzClientContext = new CAuthzClientContext;

	if(!AuthzInitializeContextFromSid(
			Flags,
			pSid,
			GetResourceManager(),
			NULL,
			luid,
			NULL,
			&pAuthzClientContext->m_hAuthzClientContext
			))
	{
		DWORD gle = GetLastError();
	    TrERROR(SECURITY, "AuthzInitializeContextFromSid() failed, sid = %!sid!, gle = %!winerr!", pSid, gle);
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 10);
		throw bad_win32_error(gle);
	}

	g_UserAuthzContextMap.SetAt(UserSid, pAuthzClientContext.get());
	*ppAuthzClientContext = pAuthzClientContext.detach();
}


//
// Initialize the cache parameters for the users map.
//
void
InitUserMap(
    CTimeDuration CacheLifetime,
    DWORD dwUserCacheSize
    )
{
    g_UserAuthzContextMap.m_CacheLifetime = CacheLifetime;
    g_UserAuthzContextMap.InitHashTable(dwUserCacheSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xact.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    QmXact.cpp

Abstract:
    This module implements QM transaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactStyl.h"
#include "Xactlog.h"
#include "QmThrd.h"
#include "acapi.h"
#include "acdef.h"
#include "cqmgr.h"
#include "xactmode.h"
#include "mqexception.h"
#include "SmartHandleImpl.h"

#include "xact.tmh"

static WCHAR *s_FN=L"xact";

// Defines how many msec to wait between Commit/Abort retrials (set from the registry).
static DWORD s_dwRetryInterval = 1500;
static volatile LONG s_nTransactionsPendingLogging = 0;

extern LONG g_ActiveCommitThreads;
extern bool g_QmGoingDown;


void ReportWriteFailure(DWORD gle)
{
    LogHR(HRESULT_FROM_WIN32(gle), s_FN, 123); 
    TrERROR(XACT_GENERAL, "Failed to write to transactional logger. %!winerr!", gle);
    ASSERT(0);
}


//
// Restriction for commit/abort processing: 6 hours.
// No special reason for this number, but Infinity is too risky.
// It seems no stress can cause so big delay inside one xact's Commit or Abort.
//
#define MAX_COMMIT_ABORT_WAIT_TIME (1000 * 60 * 60 * 6)

#ifdef _DEBUG

static void PrintPI(int cb, BYTE *pb)
{
    WCHAR str[1000];
    WCHAR digits[17]=L"0123456789ABCDEF";
    for (int i=0; i<cb; i++)
    {
        str[2*i]     = digits[pb[i]>>4];
        str[2*i + 1] = digits[pb[i] & 0x0F];
    }
    str[2*cb] = L'\0';

    TrTRACE(XACT_GENERAL, "Recovery: PI=%ls", str);  
}

static void PrintUOW(LPWSTR wszText1, LPWSTR wszText2, XACTUOW *puow, ULONG ind)
{
    BYTE *pb = (BYTE *)puow;
    WCHAR str[1000];
    WCHAR digits[17]=L"0123456789ABCDEF";
    for (int i=0; i<sizeof(XACTUOW); i++)
    {
        str[2*i]     = digits[pb[i]>>4];
        str[2*i + 1] = digits[pb[i] & 0x0F];
    }
    str[2*sizeof(XACTUOW)] = L'\0';

    TrTRACE(XACT_GENERAL, "%ls in %ls: UOW=%ls, p=1, index=%d", wszText1, wszText2, str,ind); 
}


#else

#define PrintUOW(wszText1, wszText2, puow, ind)
#define PrintPI(cb, pb)

#endif

//---------------------------------------------------------------------
// CTransaction::CTransaction
//---------------------------------------------------------------------
CTransaction::CTransaction(CResourceManager *pRM, ULONG ulIndex, BOOL fUncoordinated) :
	m_hDoneEvent(CreateEvent(0, FALSE, FALSE, 0)),
    m_qmov(HandleTransaction, HandleTransaction), 
    m_RetryAbort1Timer(TimeToRetryAbort1), 
    m_RetryAbort2Timer(TimeToRetryAbort2),
	m_RetrySortedCommitTimer(TimeToRetrySortedCommit),
    m_RetryCommit2Timer(TimeToRetryCommit2),
    m_RetryCommit3Timer(TimeToRetryCommit3),
	m_RetryCommitLoggingTimer(TimeToRetryCommitLogging)
{
    ASSERT(pRM);

    ZeroMemory(&m_Entry, sizeof(m_Entry));
    m_cRefs       = 1;                      // We are creating the first reference right now
    m_pRM         = pRM;                    // Keep RM pointer
    m_hTransQueue = INVALID_HANDLE_VALUE;   // No trans queue yet
    m_cbCookie    = 0;
	m_fDoneHrIsValid = false;
    m_DoneHr	  = S_OK;
	m_fReadyForCheckpoint = false;			

    if (m_hDoneEvent == NULL)
    {
		DWORD gle = GetLastError();
		TrERROR(XACT_GENERAL, "Failed to create event hDoneEvent. %!winerr!", gle);
        throw bad_alloc();
    }

    // Set initial state
    SetState(TX_UNINITIALIZED);             
    
    // Set discriminative index    
    m_Entry.m_ulIndex = (ulIndex==0 ? m_pRM->Index() : ulIndex);     

    // Set Uncoordinated state
    if (fUncoordinated)
    {
        SetInternal();
        SetSinglePhase();
    }
     
    TrTRACE(XACT_GENERAL, "XactConstructor, %ls, p=2,  index=%d", (fUncoordinated ? L"Single" : L"Double"), GetIndex());  

    #ifdef _DEBUG
    m_pRM->IncXactCount();
    #endif
}

//---------------------------------------------------------------------
// CTransaction::~CTransaction
//---------------------------------------------------------------------
CTransaction::~CTransaction(void)
{
    TrTRACE(XACT_GENERAL, "XactDestructor, p=3, index=%d", GetIndex());

    m_pRM->ForgetTransaction(this);
    
	if (m_Entry.m_pbPrepareInfo)
    {
        delete []m_Entry.m_pbPrepareInfo;
        m_Entry.m_pbPrepareInfo = NULL;
    }

    // release trans queue
    if (m_hTransQueue!=INVALID_HANDLE_VALUE)
    {
        ACCloseHandle(m_hTransQueue);
        m_hTransQueue = INVALID_HANDLE_VALUE;
    }

    #ifdef _DEBUG
    m_pRM->DecXactCount();
    #endif
}

//---------------------------------------------------------------------
// CTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {                      
        *ppv = (IUnknown *)this;
    } 
    else if (IID_ITransactionResourceAsync == i_iid)
    {                      
        *ppv = (ITransactionResourceAsync *)this;
    } 
    
    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return LogHR(E_NOINTERFACE, s_FN, 10); 
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CTransaction::AddRef(void)
{
	return InterlockedIncrement(&m_cRefs);
}

//---------------------------------------------------------------------
// CTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CTransaction::Release(void)
{
	ULONG cRefs = InterlockedDecrement(&m_cRefs);    // Decrement usage reference count.

    if (0 != cRefs)               // Is anyone using the interface?
    {                             // The interface is in use.
        return cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}

//---------------------------------------------------------------------
// CTransaction::InternalCommit
//---------------------------------------------------------------------
HRESULT CTransaction::InternalCommit()
{
    TrTRACE(XACT_GENERAL, "InternalCommit, p=4, index=%d", GetIndex());  

    ASSERT(m_pEnlist.get() == NULL);
    ASSERT(Internal());
	
	R<CTransaction> pXact = SafeAddRef(this);

	//
	// Call normal SINGLE-PHASE StartPrepareRequest
	//
	StartPrepareRequest(TRUE /*fSinglePhase*/);

	//
	// CRASH_POINT 1
	//
	//	Internal, Abort
	//
    CRASH_POINT(1);   // BUG: if MQSentMsg returned OK, but msg was not sent

	//
    // Wait until commit completes
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0 && !m_fDoneHrIsValid)
    {
        LogNTStatus(GetLastError(), s_FN, 203);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
		pXact.detach();
        return LogHR(E_UNEXPECTED, s_FN, 192);   // we have no idea why Wait failed, so keeping the xact 
    }

	ASSERT(m_fDoneHrIsValid);

    HRESULT  hr = m_DoneHr;    // to save over release

	//
	// CRASH_POINT 2
	//
	//	Internal, Commit
	//
	CRASH_POINT(2);

    return LogHR(hr, s_FN, 20);
}


//---------------------------------------------------------------------
// CTransaction::InternalAbort
//---------------------------------------------------------------------
HRESULT CTransaction::InternalAbort()
{
    TrTRACE(XACT_GENERAL, "InternalAbort, p=5, index=%d", GetIndex()); 
    ASSERT(m_pEnlist.get() == NULL);
    ASSERT(Internal());
    
	R<CTransaction> pXact = SafeAddRef(this);

    //
    // Abort this transaction, do all logging neccessary
    //
	StartAbortRequest();

	//
    // Wait until abort completes
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0 && !m_fDoneHrIsValid)
    {
        LogNTStatus(GetLastError(), s_FN, 204);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
		pXact.detach();
        return LogHR(E_UNEXPECTED, s_FN, 191);   // we have no idea why Wait failed, so keeping the xact 
    }

	ASSERT(m_fDoneHrIsValid);

    return S_OK;
}

inline void CTransaction::ACAbort1(ContinueFunction cf)
{
    TrTRACE(XACT_GENERAL, "ACAbort1, p=6, index=%d", GetIndex());
    PrintUOW(L"Abort1", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
    
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);

	m_funCont = cf;
    DoAbort1();
}

void WINAPI  CTransaction::DoAbort1()
{
    AddRef();
    HRESULT hr;

    //  
    // In release mode, just calls ACXactAbort1. In debug mode, may inject failure instead, if asked from registry
    //
    hr = EVALUATE_OR_INJECT_FAILURE(ACXactAbort1(m_hTransQueue, &m_qmov));

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 991);
        // Release() for the async xact abort 1 that failed           
        // AddRef()  for the timer that starts now
        ExSetTimer(&m_RetryAbort1Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
    }
}


void WINAPI  CTransaction::TimeToRetryAbort1(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryAbort1Timer);
    pTrans->DoAbort1();
    pTrans->Release();
}


inline void CTransaction::ACAbort2(ContinueFunction cf)
{
    TrTRACE(XACT_GENERAL, "ACAbort2, p=7, index=%d", GetIndex()); 
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Abort2", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoAbort2();
}

void WINAPI  CTransaction::DoAbort2()
{
    HRESULT hr;
    
    //  
    // In release mode, just calls ACXactAbort2. In debug mode, may inject failure instead, if asked from registry
    //
    hr = EVALUATE_OR_INJECT_FAILURE(ACXactAbort2(m_hTransQueue));
    
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 992);

        AddRef();       // to keep alive over scheduler waiting
        ExSetTimer(&m_RetryAbort2Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
        return;
    }

    ASSERT(hr != STATUS_PENDING);
    Continuation(MQ_OK);
}

void WINAPI  CTransaction::TimeToRetryAbort2  (CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryAbort2Timer);
    pTrans->DoAbort2();
    pTrans->Release();
}


inline HRESULT CTransaction::ACPrepare(ContinueFunction cf)
{
    TrTRACE(XACT_GENERAL, "ACPrepare, p=8, index=%d", GetIndex());  
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Prepare", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
    
	m_funCont = cf;
	
	AddRef();       // to keep alive over waiting for the async ACXactPrepare
	HRESULT hr = EVALUATE_OR_INJECT_FAILURE(ACXactPrepare(m_hTransQueue, &m_qmov));
	if(FAILED(hr))
	{
		Release();  // for ACXactPrepare waiting 
	}

	return LogHR(hr, s_FN, 40);
}


inline HRESULT CTransaction::ACPrepareDefaultCommit(ContinueFunction cf)
{
	HRESULT hr;
	
    TrTRACE(XACT_GENERAL, "ACPrepareDefaultCommit, p=L, index=%d", GetIndex());  
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"PrepareDefaultCommit", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

    m_funCont = cf;

	AddRef();       // To keep alive over waiting for async ACXactPrepareDefaultCommit
	
    //  
    // In release mode, just calls ACXactPrepareDefaultCommit. In debug mode, may inject failure instead, if asked from registry
    //
    hr = EVALUATE_OR_INJECT_FAILURE(ACXactPrepareDefaultCommit(m_hTransQueue, &m_qmov));
    
	if(FAILED(hr))
		Release();  // Not waiting for async ACXactPrepareDefaultCommit 

	return LogHR(hr, s_FN, 50);
}

inline HRESULT CTransaction::ACCommit1(ContinueFunction cf)
{
	HRESULT hr;
	
    TrTRACE(XACT_GENERAL, "ACCommit1, p=9, index=%d", GetIndex());  
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit1", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;

	AddRef();       // To keep over wait for async ACXactCommit1
	
    //  
    // In release mode, just calls ACXactCommit1. In debug mode, may inject failure instead, if asked from registry
    //
    hr = ACXactCommit1(m_hTransQueue, &m_qmov);
    
	if(FAILED(hr))
		Release();  // No wayting for async ACXactCommit1

	return LogHR(hr, s_FN, 60);
}


void WINAPI  CTransaction::TimeToRetrySortedCommit(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetrySortedCommitTimer);
    pTrans->StartCommitRequest();
    pTrans->Release();
}


inline void CTransaction::ACCommit2(ContinueFunction cf)
{
    TrTRACE(XACT_GENERAL, "ACCommit2, p=a, index=%d", GetIndex());  
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit2", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoCommit2();
}

void WINAPI  CTransaction::DoCommit2()
{
    HRESULT hr;
    
    AddRef();

    //  
    // In release mode, just calls ACXactCommit2. In debug mode, may inject failure instead, if asked from registry
    //
    hr = EVALUATE_OR_INJECT_FAILURE(ACXactCommit2(m_hTransQueue, &m_qmov));

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 994);
        // Release() for the commit 2 that failed
        // AddRef()  for the timer that starts now
        ExSetTimer(&m_RetryCommit2Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
    }
}

void WINAPI  CTransaction::TimeToRetryCommit2(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryCommit2Timer);
    pTrans->DoCommit2();
    pTrans->Release();
}


inline void CTransaction::ACCommit3(ContinueFunction cf)
{
    TrTRACE(XACT_GENERAL, "ACCommit3, p=b, index=%d", GetIndex());  
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit3", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoCommit3();
}

void WINAPI  CTransaction::DoCommit3()
{
    HRESULT hr;
    
    //  
    // In release mode, just calls ACXactCommit3. In debug mode, may inject failure instead, if asked from registry
    //
    hr = EVALUATE_OR_INJECT_FAILURE(ACXactCommit3(m_hTransQueue));
    
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 995);

        AddRef();   // to keep alive over waiting for scheduler
        ExSetTimer(&m_RetryCommit3Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
        return;
    }

    ASSERT(hr != STATUS_PENDING);
    Continuation(MQ_OK);
}

void WINAPI  CTransaction::TimeToRetryCommit3(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryCommit3Timer);
    pTrans->DoCommit3();
    pTrans->Release();
}


void WINAPI CTransaction::TimeToRetryCommitLogging(CTimer* pTimer)
{
	InterlockedDecrement(&s_nTransactionsPendingLogging);

    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryCommitLoggingTimer);
    pTrans->FinishCommitRequest3();
    pTrans->Release();
}


//---------------------------------------------------------------------
// CTransaction::DirtyFailPrepare
//
//  One of the prepare steps has failed.  Unfortunately, we might have
//  already written some messages to disk.  We need to Abort.
//
//---------------------------------------------------------------------
void CTransaction::DirtyFailPrepare()
{
    TrTRACE(XACT_GENERAL, "DirtyFailPrepare, p=c, index=%d", GetIndex());  
	SetState(TX_ABORTING);

    // Remove transaction from the list of prepared - otherwise sorter will be blocked
    g_pRM->RemoveAborted(this);

	ACAbort1(cfDirtyFailPrepare2);
}


//---------------------------------------------------------------------
// CTransaction::DirtyFailPrepare2
//
//  Storage associated with the transaction has been removed.
//  Go ahead and tell drivers to update queue data structures.
//
//---------------------------------------------------------------------
void CTransaction::DirtyFailPrepare2()
{
    TrTRACE(XACT_GENERAL, "DirtyFailPrepare2, p=d, index=%d", GetIndex());  

	ACAbort2(cfCleanFailPrepare);
}


//---------------------------------------------------------------------
// CTransaction::CleanFailPrepare
//
//  One of the prepare steps has failed.  Report the failure to DTC if
//  neeed.
//
//---------------------------------------------------------------------
void CTransaction::CleanFailPrepare()
{
    TrTRACE(XACT_GENERAL, "CleanFailPrepare, p=e, index=%d", GetIndex());  

	//
	// Will release reference as function ends.
	//
	if(m_pEnlist.get() == NULL)
	{
		// Internal transaction
		ASSERT(SinglePhase());

		//
		// Return error to internal transaction Commit
		//
		SignalDone(E_FAIL);
		Release();
		return;
	}

	//
	// We do nothing on failure. DTC will abort after a timeout.
	//
	HRESULT hr = m_pEnlist->PrepareRequestDone(E_FAIL, NULL, NULL);
	ASSERT_BENIGN(SUCCEEDED(hr));
	Release();
    LogHR(hr, s_FN, 171);
}

//---------------------------------------------------------------------
// CTransaction::LogGenericInfo
//
//	Log generic information about the transaction.  This needs to be
//	called before we write the first log record describing the transaction.
//
//---------------------------------------------------------------------
void CTransaction::LogGenericInfo()
{
    TrTRACE(XACT_GENERAL, "LogGenericInfo, p=f, index=%d", GetIndex());  

	//
	// The transaction is ready for a checkpoint. We allow checkpoint to occur before 
	// writing to the log because otherwise the log might be flushed and we'll lose the 
	// transaction data.
	//
	SetReadyForCheckpoint();

	// 
	// Tranasction data
	//
	g_Logger.LogXactData(
				GetIndex(),               
				GetSeqNumber(),
				SinglePhase(),
				GetUow());

	//
	// Prepare info
	//
	if (!SinglePhase())
	{
		GetPrepareInfoAndLog();
		
		//
		// CRASH_POINT 3
		//
		// 2 Phase, Abort
		//
		CRASH_POINT(3);
	}
}

//---------------------------------------------------------------------
// CTransaction::Continuation: activated after wait finished
//---------------------------------------------------------------------
void CTransaction::Continuation(HRESULT  hr)
{
    TrTRACE(XACT_GENERAL, "Continuation, p=g, index=%d", GetIndex());

	switch (m_funCont)
    {
    case cfPrepareRequest1:
    	LogHR(hr, s_FN, 916);
        PrepareRequest1(hr);
        break;

    case cfCommitRequest1:
    	LogHR(hr, s_FN, 917);
        CommitRequest1(hr);
        break;

	case cfCommitRequest2:
    	LogHR(hr, s_FN, 918);
    	if (FAILED(hr))
    	{
    	    // 
    	    // We retry the originating operation. No sleep since it is asynchronous
    	    //
            CommitRequest1(S_OK);    
    	}
    	else
    	{
	    	CommitRequest2();
    	}
		break;

    case cfFinishCommitRequest3:
    	ASSERT(SUCCEEDED(hr));
        FinishCommitRequest3();
        break;

    case cfCommitRestore1:
    	LogHR(hr, s_FN, 919);
        CommitRestore1(hr);
        break;

	case cfCommitRestore2:
    	LogHR(hr, s_FN, 920);
    	if (FAILED(hr))
    	{
    	    // 
    	    // We retry the originating operation. No sleep since it is asynchronous. 
    	    // May hang recovery... then SCM kills the service. Still right to refuse starting.
    	    //
            CommitRestore1(S_OK);    
    	}
    	else
    	{
	    	CommitRestore2(hr);
    	}
		break;

	case cfCommitRestore3:
    	ASSERT(SUCCEEDED(hr));
    	CommitRestore3();
    	break;

	case cfAbortRestore1:
    	LogHR(hr, s_FN, 921);
		AbortRestore1(hr);
		break;

	case cfAbortRestore2:
    	LogHR(hr, s_FN, 931);
		AbortRestore2();
		break;

	case cfDirtyFailPrepare2:
    	LogHR(hr, s_FN, 922);
        if(FAILED(hr))
        {
            ACAbort1(cfDirtyFailPrepare2);
        }
        else
        {
		    DirtyFailPrepare2();
        }
		break;

	case cfCleanFailPrepare:
    	ASSERT(SUCCEEDED(hr));
		CleanFailPrepare();
		break;

	case cfAbortRequest2:
    	LogHR(hr, s_FN, 923);
    	if (FAILED(hr))
    	{
    	    // 
    	    // We retry the originating operation. No sleep since it is asynchronous. 
    	    //
            AbortRequest1();    
    	}
    	else
    	{
	    	AbortRequest2();
    	}
		break;

    case cfAbortRequest3:
    	ASSERT(SUCCEEDED(hr));
    	AbortRequest3();
		break;
        
	default:
    	LogHR(hr, s_FN, 924);
		ASSERT(0);
    }
}

//---------------------------------------------------------------------
// CTransaction::LogFlushed: activated after log was flushed
//---------------------------------------------------------------------
void CTransaction::LogFlushed(TXFLUSHCONTEXT tcContext, HRESULT hr)
{
	TrTRACE(XACT_GENERAL, "LogFlushed, p=h, index=%d", GetIndex());
	switch (tcContext)
	{
	case TC_PREPARE0:
    	LogHR(hr, s_FN, 901);
		PrepareRequest0(hr);
		break;

	case TC_PREPARE2:
		LogHR(hr, s_FN, 902);
	    PrepareRequest2(hr);
		break;

	case TC_COMMIT4:
    	LogHR(hr, s_FN, 904);
		CommitRequest4(hr);
		break;
	}
}

void CTransaction::GetInformation()
{
    TrTRACE(XACT_GENERAL, "GetInformation, p=i, index=%d", GetIndex());  
    ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);

    PrintUOW(L"GetInformation", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
    HRESULT hr = EVALUATE_OR_INJECT_FAILURE(ACXactGetInformation(m_hTransQueue, &m_info));
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 926);
    	
    	//
		// Don't optimize, treat as multi messages with many sends and recieves
		//
		m_info.nSends = 0xFFFFFFFF;
        m_info.nReceives = 0xFFFFFFFF;
	}

    if((m_info.nSends + m_info.nReceives) == 1)
    {
        SetSingleMessage();		// We won't need to log a prepared record
    }

    

	//
	// CRASH_POINT 6
	//
	// 1 Msg DefaultCommit, Abort
	//
	CRASH_POINT(6);
}


//---------------------------------------------------------------------
// CTransaction::StartPrepareRequest
//
//		Activated:
//				from DTC when a Commit is requested
//				from an RPC call, when InternalCommit is requested		
//
//	State Transitions:
//
//				SingleMessage()=TRUE && SinglePhase()=TRUE:
//					// we do not need to log anything for this xaction
//					goto PrepareRequest0
//
//				SingleMessage()=FALSE || SinglePhase()=FALSE:
//					// Two phase needs the prepare info logged
//					SetState(TX_PREPARING, SingleMessage())
//					Log transaction data
//					On completion goto PrepareRequest0
//					
//---------------------------------------------------------------------
void CTransaction::StartPrepareRequest(BOOL fSinglePhase)
{
	try
	{
		TrTRACE(XACT_GENERAL, "StartPrepareRequest, p=%p, index=%d", this, GetIndex());

		ASSERT(GetState() == TX_ENLISTED);

		//
		// CRASH_POINT 4
		//
		//	All, Abort
		//
		CRASH_POINT(4);

		if (fSinglePhase)
		{
			SetSinglePhase();
		}

		// Transaction was in correct state -- indicate preparing
		SetState(TX_PREPARING);

		//
		// CRASH_POINT 5
		//
		//	All, Abort
		//
		CRASH_POINT(5);

		//
		// Assign sequential number for the transaction
		// this is used for Prepare/Commit order matching
		//
		AssignSeqNumber();		// only used on NT4-NT5 cluster rolling upgrade
		
		//
		// Figure out how many messages in this transaction
		//
		
		GetInformation();

 		if(SinglePhase() && SingleMessage())
		{
			//
			// We don't need to log anything for this xaction
			//
			PrepareRequest0(S_OK);
			return;
		}

		//
		// First time we write a log record for this transaction
		//
		LogGenericInfo();

		//
		// CRASH_POINT 7
		//
		//	2 Phase DefaultCommit, Abort
		//	1 Phase Multi Message DefaultCommit, Abort
		//
		CRASH_POINT(7);
		
		// Log the new state; on flush, go to PrepareRequest0
		g_Logger.LogXactFlagsAndWait(TC_PREPARE0, this, TRUE); 
	}
	catch(const exception&)
	{
		DirtyFailPrepare();
	}
}

STDMETHODIMP
CTransaction::PrepareRequest(
    BOOL /*fRetaining*/,
    DWORD /*grfRM*/,
    BOOL /*fWantMoniker*/,
    BOOL fSinglePhase
    )
/*++

Routine Description:
    The first phase of a commit request comming from DTC

Parameters:
    fRetaining - unused 
	grfRM - unused
	fWantMoniker - unused
    fSinglePhase - indicates that the RM is the only resource manager enlisted on the transaction
 
Returned Value:
    Always S_OK

--*/
{

	StartPrepareRequest(fSinglePhase);
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest0
//
//		Activated:
//				When the log has completed writing a TX_PREPARING 
//				record for the transaction
//				Directly from PrepareRequest
//
//	State Transitions:
//
//				ACXactPrepareDefaultCommit
//				On completion goto PrepareRequest1
//					
//---------------------------------------------------------------------
void CTransaction::PrepareRequest0(HRESULT  hr)
{
	try
	{
		LogHR(hr, s_FN, 905);
		TrTRACE(XACT_GENERAL, "PrepareRequest0, p=k, index=%d", GetIndex());

		//
		// CRASH_POINT 9
		//
		CRASH_POINT(9);

		//
		// Check for log success
		//
		if(FAILED(hr))
		{
			TrERROR(XACT_GENERAL, "Failed asynchronous operation to prepare request 0. %!hresult!", hr);
			DirtyFailPrepare();
			return;
		}

		if(SinglePhase() && SingleMessage() && m_info.nReceives == 1)
		{
			//
			// Single message recieves in a single message
			// transaction are implictly prepared.
			//

			// Insert the prepared transaction into the list for commit
			g_pRM->InsertPrepared(this);
       
			PrepareRequest1(MQ_OK);
			return;
		}


		{
			CS lock(g_pRM->SorterCritSection());

			//
			// Insert the prepared transaction into the list for commit
			//
			g_pRM->InsertPrepared(this);

			//
			// Call driver to write messages to be prepared
			//
			hr = ACPrepareDefaultCommit(cfPrepareRequest1);
		}
        if (FAILED(hr))
        {
			TrERROR(XACT_GENERAL, "Failed to call driver in prepare request 0. %!hresult!", hr);
			DirtyFailPrepare();
			return;
        }
	}
	catch(const exception&)
	{
		DirtyFailPrepare();
	}
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest1
//
//		Activated:
//				When the driver has completed ACXactPrepare 
//				When the driver has completed ACXactPrepareDefaultCommit
//
//		State Transitions:
//
//				SingleMessage()=TRUE && SinlgePhase()=TRUE:
//					// on disk.  If this state is recoverd through a checkpoint, we know in
//					// recovery that this is a SingleMessage SinglePhase and can recover
//					// appropriately.
//					SetState(TX_PREPARED);
//					Goto PrepareRequest2
//
//				SinlgeMessage()=TRUE && SinglePhase()=FALSE:
//					SetState(TX_PREPARED);
//					Goto PrepareRequest2		(Single message, implicitly prepared)
//
//				SingleMessage()=FALSE:
//					SetState(TX_PREPARED)
//					Log transaction data
//					On completion goto PrepareRequest2
//				
//---------------------------------------------------------------------
void CTransaction::PrepareRequest1(HRESULT  hr)
{
	TrTRACE(XACT_GENERAL, "PrepareRequest1, p=l, index=%d", GetIndex());

	if (FAILED(hr))
	{
    	LogHR(hr, s_FN, 908);
		DirtyFailPrepare();
		return;
	}

	if(SingleMessage() && SinglePhase())
	{
		//
		// CRASH_POINT 10
		//
		//	1 Phase 1 Msg, Commit
		//
		CRASH_POINT(10);

		SetState(TX_PREPARED);

		//
		// CRASH_POINT 11
		//
		//	1 Phase 1 Msg, Commit
		//
		CRASH_POINT(11);

		PrepareRequest2(S_OK);
		return;
	}

	if(SingleMessage() && !SinglePhase())
	{
		//
		// On two phase, we are implicitly prepared by the 
		// fact that the message exists.
		//
		SetState(TX_PREPARED);
		PrepareRequest2(S_OK);
		return;
	}
	
	try
	{
		//
		// Log the new state; on flush, go to Prepare2
		//
		SetState(TX_PREPARED);

		g_Logger.LogXactFlagsAndWait(TC_PREPARE2, this, TRUE); 
	}
	catch(const exception&)
	{
		DirtyFailPrepare();
	}
  		
	//
	// CRASH_POINT 12
	//
	//	All, Abort
	//
	CRASH_POINT(12);
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest2
//
//		Activated:
//				When the log has completed writing TX_PREPARED state
//				for the transaction.
//				Directly from PrepareRequest1 for single message 
//				tranasctions.
//
//		State Transitions:
//
//			SinglePhase()=TRUE:
//					Goto CommitRequest
//
//			SinlgePhase()=FALSE:
//					return to DTC
//
//---------------------------------------------------------------------
void CTransaction::PrepareRequest2(HRESULT  hr)
{
    TrTRACE(XACT_GENERAL, "PrepareRequest2, p=m, index=%d", GetIndex());

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 910);
		DirtyFailPrepare();
		return;
	}

	//
	// CRASH_POINT 13
	//
	//	1 Phase, Commit
	//	2 Phase, Abort
	//
	CRASH_POINT(13);

    if (SinglePhase()) 
    {
		StartCommitRequest();
		return;
    }

	//
	// Two phase
	//
	ASSERT(m_pEnlist.get() != NULL);

	//
	// Transaction will stay up. We can not do DirtyFailPrepare() since DTC may get the notification even it
	// returned a failure, and call us with AbortRequest() causing us reference counting problems.
	//
	hr = m_pEnlist->PrepareRequestDone(S_OK, NULL, NULL);
	ASSERT_BENIGN(SUCCEEDED(hr));

	//
	// CRASH_POINT 14
	//
	//	All, Commit
	//
}

//---------------------------------------------------------------------
// CTransaction::StartCommitRequest
//
//		Activated:
//			From PrepareRequest2 on a single phase transaction
//			From DTC on a two phase transaction
//
//		State Transitions:
//
//			Call SortedCommit to pass on calls to CommitRequest0 in 
//			sorted order
//
//---------------------------------------------------------------------
void CTransaction::StartCommitRequest()
{
    TrTRACE(XACT_GENERAL, "StartCommitRequest, this=%p, index=%d", this, GetIndex());  
    
	try
	{
		m_pRM->SortedCommit(this);     
	}
	catch(const exception&)
	{
		AddRef();
		ExSetTimer(&m_RetrySortedCommitTimer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
	}
}


void CTransaction::JumpStartCommitRequest()
{
	StartCommitRequest();
}


STDMETHODIMP
CTransaction::CommitRequest(
    DWORD /*grfRM*/,
    XACTUOW* /*pNewUOW*/
    )
/*++

Routine Description:
    The second phase of a commit request comming from DTC

Parameters:
	grfRM - unused
	pNewUOW - unused
 
Returned Value:
    Always S_OK

--*/
{
    InterlockedIncrement(&g_ActiveCommitThreads);
	auto_InterlockedDecrement AutoDec(&g_ActiveCommitThreads);
	if (g_QmGoingDown)
	{
		TrERROR(XACT_GENERAL, "Failing DTC CommitRequest because QM is going down");
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

    TrTRACE(XACT_GENERAL, "DTC CommitRequest, this=%p, index=%d", this, GetIndex());  

	StartCommitRequest();
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest0
//
//		The transaction is prepared.
//
//		Activated:
//			From PrepareRequest2 through SortedCommit on a single
//			phase transaction.
//			From DTC through SortedCommit on a two 
//			phase transaction.
//	
//		State Transitions:
//
//				SetState(TX_COMITTING)
//				// we do not need to mark any sent message and
//				// can threfore skip ACCommit1
//				Goto CommitRequest1
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest0()
{
	TrTRACE(XACT_GENERAL, "CommitRequest0, p=o, index=%d", GetIndex());

	ASSERT(GetState() == TX_PREPARED || GetState() == TX_COMMITTING);
	SetState(TX_COMMITTING);

	//
	// CRASH_POINT 15
	//
	//	All, Commit
	//
	CRASH_POINT(15);

	//
    // We put the transaction in the list of committed to tie sorting.
    //
	m_pRM->InsertCommitted(this);
		
	CommitRequest1(S_OK);
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest1
//
//		Activated:
//				After the call to ACXactCommit1 has completed.
//				Directly from CommitRequest0.
//	
//		State Transitions:
//
//			Check for failure and call ACCommit2
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest1(HRESULT  hr)
{
    TrTRACE(XACT_GENERAL, "CommitRequest1, p=p, index=%d", GetIndex());
    
    if (FAILED(hr))
    {
    	LogHR(hr, s_FN, 932);
    	
        //
        // Treatment of ACCommit1 failures (definitely possible for Uncoordinated messages)
        //

        ASSERT(hr == STATUS_CANCELLED);    // We see no possible reason for failure here
        ASSERT(Internal());
        m_DoneHr = hr;

        // We don't want Abort or reporting in this case; let next recovery finish it
        return;
    }
    
	//
	// Call Commit2 to issue DeleteStorage for recieved messages
	//
	ACCommit2(cfCommitRequest2);

}

//---------------------------------------------------------------------
// CTransaction::CommitRequest2
//
//		Activated:
//			After the call to ACXactCommit2 has completed
//	
//		State Transitions:
//
//			Goto CommitRequest3 through SortedCommit3
//	
//---------------------------------------------------------------------
void CTransaction::CommitRequest2()
{
    TrTRACE(XACT_GENERAL, "CommitRequest2, p=q, index=%d", GetIndex());

	//
	// We now must go through the sorter, since we are
	// going to call Commit3. We need to call Commit3 anyway
	// so we pass hr.
	//

	m_DoneHr = MQ_OK;
	m_pRM->SortedCommit3(this);
}


//---------------------------------------------------------------------
// CTransaction::CommitRequest3
//
//		Activated:
//			Through SortedCommit3 when to call to ACCommit2 has
//			completed
//	
//		State Transitions:
//
//				SinglePhase()=TRUE && SingleMessage()=TRUE:
//					// Sent messages are in effect committed to disk
//					// and will be in recovery.  For recieved message, we will be
//					// removing the message and
//					// also update the queue data strutures.
//					ACCommit3
//					Goto CommitRequest4
//				
//				SinglePhase()=TRUE && SingleMessage()=FALSE:
//					// We have already logged the fact that we are prepared. 
//					// We are single phase therefore, we will be committed on recovery.
//					// We can go ahead complete the commit and report completion to the caller.
//					ACCommit3
//					Goto CommitRequest4
//
//				SinglePhase()=FALSE:
//					// We have already logged (implicitly or explicitly) the fact
//					// that we are prepared.   We are two phase, therefore we must
//					// not report completion to DTC before a commit record is logged
//					ACCommit3
//					SetState(TX_COMMITTED)
//					Lazily log transaction data
//					On completion, go to CommitRequest4
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest3()
{
    TrTRACE(XACT_GENERAL, "CommitRequest3, p=r, index=%d", GetIndex());

    ASSERT(SUCCEEDED(m_DoneHr));

	ACCommit3(cfFinishCommitRequest3);
}

//---------------------------------------------------------------------
// CTransaction::FinishCommitRequest3
//
//	Activated:
//		When CommitRequest3 succeeded with ACCommit3 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::FinishCommitRequest3()
{
    TrTRACE(XACT_GENERAL, "CommitRequest3, p=M, index=%d", GetIndex());

	SetState(TX_COMMITTED);

	if(!SinglePhase())
	{
		//
		// We cannot call CommitRequest4 until we have logged the fact that
		// the transaction was committed.
		//

		//
		// Log the new state; on flush, go to CommitRequest4
		//
		try
		{
			g_Logger.LogXactFlagsAndWait(TC_COMMIT4, this, FALSE); 
			return;
		}
		catch(const exception&)
		{
			CommitRequest4(MQ_ERROR_INSUFFICIENT_RESOURCES);
			return;
		}
	}

	//
	// Single phase
	//
	if(!SingleMessage())
	{
		//
		// We must not log anything unless we have allready logged something.
		//
		// It helps recovery to know the transaction was committed.  The transaction
		// will go away in the next checkpoint.
		//
		// This logging function ignores any logging failures errors and it is ok since we 
		// have done all commiting work, and on recovery this xaction
		// will be considered commited anyway.
		//
	
		LogFlags();
	}

	CommitRequest4(MQ_OK);
}


//---------------------------------------------------------------------
// CTransaction::CommitRequest4
//
//	Activated:
//			When a two phase tranasction has been logged as committed.
//			On a single phase transaction directly from CommitRequest3
//
//		Everything has completed, report result to DTC
//		or unblock waiting RPC call for internal transaction
//
//		When we report results back to DTC it is allowed to forget about
//	    a 2 phase transaction.
//
//		On a 2 phase transaction we can only report CommitRequestDone when
//		the commit record was written to disk or if we are using DefaultAbort
//		semantics and have already removed the UOW from the msgs.
//
//		We need to add another phase here if we need to write to Commit record.
//		also, we need to add Wait without flush.
//
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest4(HRESULT hr)
{
    TrTRACE(XACT_GENERAL, "CommitRequest4, p=s, index=%d", GetIndex());
    CRASH_POINT(18);    //* Send/Rcv;  internal N-msg or single or DTC or SQL+DTC;  Commit [for single may be abort]

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 943);
    	
		//
		// We only get here on two phase
		//
		ASSERT(!SinglePhase()); 

		//
		// We can't tell DTC to forget about the transaction.  
		// Either retry will succeed or recovery will deal with it the next time we come up
		//
		AddRef();
		//
		// Timeout computation ensures that no more than 10 retries per second will be tried.
		//
		DWORD RetryCommitLoggingInterval = s_dwRetryInterval + 100 * InterlockedIncrement(&s_nTransactionsPendingLogging);
		ExSetTimer(&m_RetryCommitLoggingTimer, CTimeDuration::FromMilliSeconds(RetryCommitLoggingInterval));
		
		TrERROR(XACT_GENERAL, "Setting up a retry for commit logging. with %d milliseconds timeout", RetryCommitLoggingInterval); 
		
		return;
	}

	//
    // report commit finish to the TM
	//
    if (m_pEnlist.get() == NULL)
	{
        // Internal transaction
        ASSERT(SinglePhase());
		
		//
		// Return okay to internal transaction Commit
		//
		SignalDone(S_OK);       // propagate hr to Commit

		Release();
		return;
	}

	// What should we report to DTC?
    if (SinglePhase())
    {
		m_pEnlist->PrepareRequestDone(XACT_S_SINGLEPHASE,  NULL, NULL);
    }
    else
    {
        m_pEnlist->CommitRequestDone(S_OK);
    }

    //
    // Destroy transaction
	//
    Release();      // to kill
}


//---------------------------------------------------------------------
// CTransaction::AbortRestore
//
//	Activated:
//		From Recover
//	
//		We need to tell Recover what the status of recovering the
//		transction is.
//
//---------------------------------------------------------------------

HRESULT CTransaction::AbortRestore()
{
    TrTRACE(XACT_GENERAL, "AbortRestore, p=t, index=%d", GetIndex());

	AddRef();   // to keep alive over wait for wait for ACAbort1 results
	ACAbort1(cfAbortRestore1);

	DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0 && !m_fDoneHrIsValid)
    {
        LogNTStatus(GetLastError(), s_FN, 205);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
        // No Release here: we have no idea why Wait failed, so keeping the xact to hang till recovery
        return LogHR(E_UNEXPECTED, s_FN, 193);   
    }

	ASSERT(m_fDoneHrIsValid);

    HRESULT hr = m_DoneHr;    // to save over release
    Release();      // Done with this transaction
	return LogHR(hr, s_FN, 100);
}

//---------------------------------------------------------------------
// CTransaction::AbortRestore1
//
//	Activated:
//		When ACXActAbort1 completes
//
//	State Transitions:
//
//		report completion status to caller.
//
//---------------------------------------------------------------------
void CTransaction::AbortRestore1(HRESULT hr)
{
    TrTRACE(XACT_GENERAL, "AbortRestore1, p=u, index=%d", GetIndex());  

   	LogHR(hr, s_FN, 946);
    m_DoneHr = hr;
   	
	ACAbort2(cfAbortRestore2);
}

void CTransaction::AbortRestore2()
{
    TrTRACE(XACT_GENERAL, "AbortRestore1, p=O, index=%d", GetIndex());  
	SignalDone(m_DoneHr);
}


//---------------------------------------------------------------------
// CTransaction::CommitRestore
//
//	Activated:
//		From Recover
//	
//		We need to tell Recover what the status of recovering the
//		transction is.
//
//		We arrive here on recovery when a transaction is in either in 
//		the TX_PREPARED state and DTC has told us to commit the
//		transaction or we are in the TX_COMMITTING state
//
//		Goto CommitRestore0 through SortedCommit
//---------------------------------------------------------------------
HRESULT CTransaction::CommitRestore()
{
    TrTRACE(XACT_GENERAL, "CommitRestore, p=v, index=%d", GetIndex());  

	//
	// We recover transactions in order, therefore we no longer
	// need to sort.  Call directly.
	//
    AddRef();   // during waiting
	CommitRestore0();

	//
	// We use this event to wait the restore completion. This is 
	// actually needed when g_fDefaultCommit == FALSE, otherwise
	// all calls are synchronous.
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0 && !m_fDoneHrIsValid)
    {
        LogNTStatus(GetLastError(), s_FN, 206);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);

        return LogHR(E_UNEXPECTED, s_FN, 194);   // we have no idea why Wait failed, so keeping the xact 
    }

	ASSERT(m_fDoneHrIsValid);

    HRESULT  hr = m_DoneHr;    // to save over release
    Release();                   // done with the transaction

	return LogHR(hr, s_FN, 105);
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore0
//
//	Activated:
//		From CommitRestore through SortedCommit
//		Directly from CommitRestore
//
//
//	State Transitions:
//
//		g_fDefaultCommit=FALSE:
//			Call ACXactCommit1
//			On completion goto CommitRestore1
//
//		g_fDefaultCommit=TRUE:
//			Goto CommitRestore1
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore0()
{
    TrTRACE(XACT_GENERAL, "CommitRestore0, p=w, index=%d", GetIndex());  
	if(g_fDefaultCommit)
	{
		CommitRestore1(S_OK);
		return;
	}

    CRASH_POINT(22);    //* Recovery for all commiting cases;  Commit 
    HRESULT hr;

	hr = ACCommit1(cfCommitRestore1);

    CRASH_POINT(23);    //* Recovery for all commiting cases;  Commit 
    if (FAILED(hr))
    {
    	LogHR(hr, s_FN, 950);
        SignalDone(hr);
    }
}		


//---------------------------------------------------------------------
// CTransaction::CommitRestore1
//
//	Activated:
//		When ACXActCommit1 completes
//		Directly from CommitRestore1
//
//	State Transitions:
//
//		We never log anything during recovery. All we need to do
//		is call ACXactCommit2.
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore1(HRESULT hr)
{
    TrTRACE(XACT_GENERAL, "CommitRestore1, p=x, index=%d", GetIndex());
    CRASH_POINT(24);    //* Recovery for all commiting cases;  Commit 

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 951);
		SignalDone(hr);
		return;
	}

    ACCommit2(cfCommitRestore2);

    CRASH_POINT(25);    //* Recovery for all commiting cases;  Commit 
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore2
//
//	Activated:
//		When ACXActCommit2 completes
//
//	State Transitions:
//
//		report completion status to caller.
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore2(HRESULT hr)
{
   	TrTRACE(XACT_GENERAL, "CommitRestore2, p=y, index=%d", GetIndex());

   	LogHR(hr, s_FN, 953);
   	m_DoneHr = hr; 
   	    
	ACCommit3(cfCommitRestore3);
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore3
//
//	Activated:
//		When CommitRestore2 succeeded with ACCommit3 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore3()
{
    TrTRACE(XACT_GENERAL, "CommitRestore2, p=N, index=%d", GetIndex());
	SignalDone(m_DoneHr);
}


//---------------------------------------------------------------------
// CTransaction::StartAbortRequest
//---------------------------------------------------------------------
void CTransaction::StartAbortRequest()
{
	ASSERT(GetState() != TX_COMMITTING && GetState() != TX_COMMITTED);

    TrTRACE(XACT_GENERAL, "StartAbortRequest, p=z, index=%d, this=%p", GetIndex(), this);

	//
    // Remove the xact from the sorter's list of prepared
	//
    m_pRM->RemoveAborted(this);

	SetState(TX_ABORTING);

	AbortRequest1();
}


STDMETHODIMP
CTransaction::AbortRequest(
    BOID* /*pboidReason*/,
    BOOL /*fRetaining*/,
    XACTUOW* /*pNewUOW*/
    )
/*++

Routine Description:
    The MS DTC proxy calls this method to abort a transaction.

Parameters:
	pboidReason - unused
	fRetaining - unused
	pNewUOW - unused
 
Returned Value:
    Always S_OK

--*/
{
    TrTRACE(XACT_GENERAL, "DTC AbortRequest, this=%p, index=%d", this, GetIndex());
    
	StartAbortRequest();
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest1
//
// Activated:
//		When an abort record was written to the log
//		Directly from AbortRequest
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest1()
{
    TrTRACE(XACT_GENERAL, "AbortRequest1, p=A, index=%d", GetIndex());

	ACAbort1(cfAbortRequest2);	
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest2
//
// Activated:
//		When the driver has completed deleting storage
//		associatde with the transaction.
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest2()
{
    TrTRACE(XACT_GENERAL, "AbortRequest2, p=B, index=%d", GetIndex());

	ACAbort2(cfAbortRequest3);
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest3
//
// Activated:
//		When AbortRequest2 succeeded with ACAbort2 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest3()
{
    TrTRACE(XACT_GENERAL, "AbortRequest2, p=P, index=%d", GetIndex());

    // report abort finish to TM
    if (m_pEnlist.get() != NULL)
    {
        m_pEnlist->AbortRequestDone(S_OK);
    }
	else
	{
		SignalDone(S_OK);
	}

    CRASH_POINT(28);    //* Any abort case;  Abort
    // Destroy transaction
    Release();      // to kill
}

//---------------------------------------------------------------------
// CTransaction::TMDown
//
// The MS DTC proxy calls this method if connection to the transaction
// manager goes down and the resource manager's transaction object is
// prepared (after the resource manager has called the 
// ITransactionEnlistmentAsync::PrepareRequestDone method).
//
//
//---------------------------------------------------------------------
STDMETHODIMP CTransaction::TMDown(void)
{
    TrTRACE(XACT_GENERAL, "TMDown, p=C, index=%d", GetIndex());

	//
	// We don't have to do anything.   We are in doubt and we are going
	// to stay in doubt apparently.  Next recover is going to tell us what
	// to do with this transaction.
	//

    // We must remove xact from the sorter list - to avoid sorter blocking
    g_pRM->RemoveAborted(this);


    //
    // If there are prepared xacts when DTC dies, QM has to die as well - 
    //    otherwise we risk data loss and order violation
    // Here is the scenario: 
    //    xacts T1, T2 and T3 are prepared, and CommitRequest has been called for T1 and T3
    //    DTC dies, CommitRequest for T2 did not come yet (quite possible)
    //    Sent messages from T1,T3 had gone to the net; T2 is hung in doubt till next recovery
    //    On the next recovery T2 will be committed and messages will be sent,
    //       but they may be rejected or come in a wrong order 
    //         because T3 msgs could have been accepted already due to relinking 
    //
    if (GetState() == TX_PREPARED && !SinglePhase())
    {
        //
        // MSDTC failed, we don't have warm recovery, cannot continue.
        // Shutting down
        //
        EvReport(FAIL_MSDTC_TMDOWN);
        LogIllegalPoint(s_FN, 135);
        
        exit(EXIT_FAILURE); 
    }

    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::GetPrepareInfoAndLog
//---------------------------------------------------------------------
void CTransaction::GetPrepareInfoAndLog()
{
    R<IPrepareInfo> pIPrepareInfo = NULL;

    TrTRACE(XACT_GENERAL, "GetPrepareInfoAndLog, p=D, index=%d", GetIndex());

    // Get the IPrepareInfo interface of the Enlistment object
    HRESULT hr = m_pEnlist->QueryInterface (IID_IPrepareInfo,(LPVOID *) &pIPrepareInfo);
    if (FAILED(hr))
    {
		TrERROR(XACT_GENERAL, "Failed query interface to ITransactionEnlistmentAsync.");
        throw bad_hresult(MQ_ERROR_TRANSACTION_PREPAREINFO);
    }

    // Get PrepareInfo size
    ULONG  ul = 0;
    pIPrepareInfo->GetPrepareInfoSize(&ul);
    if (ul == 0)
    {
		TrERROR(XACT_GENERAL, "Failed to get prepare info size.");
        throw bad_hresult(MQ_ERROR_TRANSACTION_PREPAREINFO);
    }
    
	m_Entry.m_pbPrepareInfo = new UCHAR[ul];

    // get prepare info
    hr = EVALUATE_OR_INJECT_FAILURE(pIPrepareInfo->GetPrepareInfo(m_Entry.m_pbPrepareInfo));
    if (FAILED(hr))
    {
		delete [] m_Entry.m_pbPrepareInfo;
		TrERROR(XACT_GENERAL, "Failed to get prepare info.");
        throw bad_hresult(MQ_ERROR_TRANSACTION_PREPAREINFO);
    }

	//
	// The update of m_cbPrepareInfo is done only here, when m_pbPrepareInfo
	// is allocated and valid. If we update m_cbPrepareInfo before m_pbPrepareInfo
	// and a context switch happens, another thread will think that m_Entry is 
	// valid, because m_cbPrepareInfo != 0.
	//
    m_Entry.m_cbPrepareInfo = (USHORT)ul;

    // Log down the prepare info
    g_Logger.LogXactPrepareInfo(
                m_Entry.m_ulIndex, 
                m_Entry.m_cbPrepareInfo, 
                m_Entry.m_pbPrepareInfo);
}


//---------------------------------------------------------------------
// CTransaction::CreateTransQueue(void)
//---------------------------------------------------------------------
HRESULT CTransaction::CreateTransQueue(void)
{
    HRESULT  hr;

    // Create the transaction Queue
    hr = XactCreateQueue(&m_hTransQueue, &m_Entry.m_uow );

    return LogHR(hr, s_FN, 140);
}

//---------------------------------------------------------------------
// CTransaction::AssignSeqNumber
//---------------------------------------------------------------------
void CTransaction::AssignSeqNumber()
{
    m_Entry.m_ulSeqNum = m_pRM->AssignSeqNumber();
}

//---------------------------------------------------------------------
// CTransaction::GetSeqNumber
//---------------------------------------------------------------------
ULONG CTransaction::GetSeqNumber() const
{
    return m_Entry.m_ulSeqNum; 
}

//---------------------------------------------------------------------
// CTransaction::SetState
//---------------------------------------------------------------------
void CTransaction::SetState(TXSTATE state)
{
    m_Entry.m_ulFlags = (m_Entry.m_ulFlags & ~XACTION_MASK_STATE) | state;
}

//---------------------------------------------------------------------
// CTransaction::LogFlags
//---------------------------------------------------------------------
void CTransaction::LogFlags()
{
	try
	{
		g_Logger.LogXactFlags(this);
	}
	catch(const bad_hresult& e)
	{
		TrERROR(XACT_GENERAL, "Ignoring exception while logging flags. %!hresult!", e.error());
	}
	catch(const exception&)
	{
		TrERROR(XACT_GENERAL, "Ignoring exception while logging flags.");
	}
}

//---------------------------------------------------------------------
// CTransaction::SinglePhase
//---------------------------------------------------------------------
inline BOOL CTransaction::SinglePhase(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_SINGLE_PHASE;
}

//---------------------------------------------------------------------
// CTransaction::SetSinglePhase
//---------------------------------------------------------------------
inline void CTransaction::SetSinglePhase()
{
    m_Entry.m_ulFlags |= XACTION_MASK_SINGLE_PHASE;
}

//---------------------------------------------------------------------
// CTransaction::SingleMessage
//---------------------------------------------------------------------
inline BOOL CTransaction::SingleMessage(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_SINGLE_MESSAGE;
}

//---------------------------------------------------------------------
// CTransaction::SetSingleMessage
//---------------------------------------------------------------------
inline void CTransaction::SetSingleMessage()
{
    m_Entry.m_ulFlags |= XACTION_MASK_SINGLE_MESSAGE;
}

//---------------------------------------------------------------------
// CTransaction::Internal
//---------------------------------------------------------------------
inline BOOL CTransaction::Internal(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_UNCOORD;
}

//---------------------------------------------------------------------
// CTransaction::SetInternal
//---------------------------------------------------------------------
inline void CTransaction::SetInternal()
{
    m_Entry.m_ulFlags |= XACTION_MASK_UNCOORD;
}

//---------------------------------------------------------------------
// CTransaction::SetUow
//---------------------------------------------------------------------
void CTransaction::SetUow(const XACTUOW *pUOW)
{
    CopyMemory(&m_Entry.m_uow, pUOW, sizeof(XACTUOW));
}

void CTransaction::SetEnlist(ITransactionEnlistmentAsync *pEnlist) 
{
	m_pEnlist = SafeAddRef(pEnlist); 
}

//---------------------------------------------------------------------
// CTransaction::SetCookie
//---------------------------------------------------------------------
void CTransaction::SetCookie(DWORD cbCookie, unsigned char *pbCookie)
{
	ASSERT(m_pbCookie.get() == NULL);

    m_cbCookie = cbCookie;
    if (cbCookie)
    {
        m_pbCookie = new unsigned char[cbCookie];
        CopyMemory(m_pbCookie, pbCookie, cbCookie);
    }
}

//---------------------------------------------------------------------
// CTransaction::IsComplete - check if transaction is complete
//
//---------------------------------------------------------------------
BOOL CTransaction::IsComplete()
{
	if(g_fDefaultCommit && SinglePhase() && SingleMessage())
	{
		if(GetState() == TX_ABORTING)
		{
			
			//
			// This is a single phase single message transaction that
			// has failed in the prepare process.  We need to abort it.
			//
			
			return(FALSE);
		}

		return(TRUE);
	}

	switch(GetState())
	{
		case TX_COMMITTED:
        case TX_ABORTED:
			return(TRUE);
	}

	return(FALSE);
}

//---------------------------------------------------------------------
// CTransaction::Recover - Recover one transaction
//
//    Called from CResourceManager::Init()
//
//
//		TX_UNINITIALIZED - Clean Abort, nothing done yet
//		TX_INITIALIZED   - Clean Abort, nothing done yet.
//		TX_ENLISTED      - Clean Abort, nothing done yet.
//		TX_PREPARING	 - Dirty abort, we could possibly have 
//						   msgs marked with a UOW
//		TX_PREPARED		 - In doubt. Dirty abort or commit
//						   based on TM decision.
//		TX_COMMITTING	 - Commit
//		TX_ABORTING		 - Dirty abort, we could possibly have
//						   msgs marked with a UOW to clean
//
//   If not succefull, then the transaction could not be recovered.
//
//---------------------------------------------------------------------
HRESULT CTransaction::Recover()
{
    HRESULT         hr = MQ_OK;
    XACTSTAT        xactOutcome;

	m_pRM->ForgetTransaction(this);

	//
	// We never recover single phase single message transactions
	//
	ASSERT(!(SinglePhase() && SingleMessage()));

    if(m_hTransQueue == INVALID_HANDLE_VALUE)
	{
        //
        // There are no messages with the UOW 
        // for this transaction.
        // we can safely ignore it.
        //
        return(MQ_OK);
    }
	
	try
    {
        CRASH_POINT(31);    //* Recovery;  Commit/Abort as was before crash

        // Process non-finished transaction
        // NB: not all states are persistent; only some may be mentioned in the file

		//
		// Patch up state for implicitly prepared transactions (TwoPhase, SingleMessage)
		//
		if(g_fDefaultCommit && (GetState() == TX_PREPARING) && SingleMessage())
		{
			SetState(TX_PREPARED);
#ifdef _DEBUG
			//
			// We never get here with no messages in the transaction
			//
            CACXactInformation info;
            PrintUOW(L"GetInformation", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
            HRESULT hr2 = ACXactGetInformation(m_hTransQueue, &info);
            ASSERT(SUCCEEDED(hr2));
            LogHR(hr2, s_FN, 172);
			ASSERT((info.nSends + info.nReceives) == 1);
#endif
		}

        switch (GetState())
        {
        case TX_ABORTING:
            // aborting state:  we were in the process of aborting
            // We are going to finish it now
            // falling down...

        case TX_COMMITTING:
            // committing state:  we were in the process of committing
            // We are going to finish it now

        case TX_PREPARED:
            // in-doubt state:  we voted Yes, but don't know what other RMs did
            // reeenlist, then follow the TM's decision

            // Get PrepareInfo from the transaction
            if (!SinglePhase())
            {
				if (GetState() == TX_COMMITTING)
                {
                    xactOutcome = XACTSTAT_COMMITTED;
                }
                else if (GetState() == TX_ABORTING)
                {
                    xactOutcome = XACTSTAT_ABORTED;
                }
				else if (m_Entry.m_cbPrepareInfo > 0)
                {
					hr = g_pRM->ProvideDtcConnection();
					if(FAILED(hr))
						return LogHR(hr, s_FN, 150);
					
                    // Reenlist with MS DTC to determine the outcome of the in-doubt transaction
                    hr = m_pRM->ReenlistTransaction(
                            m_Entry.m_pbPrepareInfo,
                            m_Entry.m_cbPrepareInfo,
                            XACTCONST_TIMEOUTINFINITE,          // Is it always OK???
                            &xactOutcome);

	                PrintPI(m_Entry.m_cbPrepareInfo, m_Entry.m_pbPrepareInfo);
    				if(FAILED(hr))
					{
						LogHR(hr, s_FN, 160);
                        return MQ_ERROR_RECOVER_TRANSACTIONS;
					}
                }
                else 
                {
					//
					// We cannot be prepared and not have PrepareInfo
					//
                    ASSERT(GetState() == TX_PREPARED);
                    return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 170);
                }
            }
            else
            {
				if(GetState() == TX_COMMITTING || GetState() == TX_PREPARED)
				{
					xactOutcome = XACTSTAT_COMMITTED;
				}
				else
				{
					xactOutcome = XACTSTAT_ABORTED;
				}
			}
            
            // Reenlistment is successful -- act on transaction outcome.
            switch(xactOutcome)
            {
            case XACTSTAT_ABORTED :
                TrTRACE(XACT_GENERAL, "RecoveryAbort, p=E, index=%d", GetIndex());
                hr = AbortRestore();
				return LogHR(hr, s_FN, 180);

            case XACTSTAT_COMMITTED :
                TrTRACE(XACT_GENERAL, "RecoveryCommit, p=F, index=%d", GetIndex());
                hr = CommitRestore();
				return LogHR(hr, s_FN, 190);
    
            default:
                // we shouldn't get anything else
                TrTRACE(XACT_GENERAL, "RecoveryError, p=G, index=%d", GetIndex());
                ASSERT(FALSE);
                return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 200);
            }


        case TX_ENLISTED:
            // active state:  we were in the process of getting send/receive orders
            // Abort: presumed abort
		       // falling down...

        case TX_PREPARING:
            // preparing state:  we started preparing but not reported it yet
            // Abort: presumed abort
            // falling down...

            //
            //  Abort without calling DTC, we don't have the prepare info for
            //  that transaction.
            //

        case TX_INITIALIZED:
        case TX_UNINITIALIZED:
            // we did nothing revertable yet, so taking it easy


        case TX_INVALID_STATE:

            // In all these cases we clean up (== Abort)
            
            TrTRACE(XACT_GENERAL, "RecoveryAbort2, p=H, index=%d", GetIndex());
            hr = AbortRestore();
			return LogHR(hr, s_FN, 210);

		case TX_COMMITTED:
        case TX_ABORTED:
			//
			// Internal Error, recovering complete transaction.
			// These transactions were handled before in ReleaseAllCompleteTransactions()
			//
			ASSERT(FALSE);
            //
            // Fall through
            //

        default:
            // These states should not become persistent at all
            ASSERT(FALSE);
            TrTRACE(XACT_GENERAL, "RecoveryError2, p=I, index=%d", GetIndex());
            return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 220);
        }
    }
    catch(const exception&)
    {
        LogIllegalPoint(s_FN, 215);
        if (SUCCEEDED(hr))
        {
            hr = MQ_ERROR_RECOVER_TRANSACTIONS;
        }
        TrERROR(XACT_GENERAL, "Error -  EXCEPTION in CTransaction::Recover");
    }

    return LogHR(hr, s_FN, 230);
}

/*====================================================
CTransaction::Save
    Saves transaction persistent data
=====================================================*/
BOOL CTransaction::Save(HANDLE hFile)
{
    PERSIST_DATA;
	XACTION_ENTRY     EntryToSave = m_Entry;
	if (!IsReadyForCheckpoint())
	{
		//
		// The transaction is not ready for checkpoint. Save a dummy record instead.
		// Since we set the flags to TX_ABORTED, the transaction will be ignored
		// in recovery.
		//
		EntryToSave.m_ulFlags = TX_ABORTED;
		EntryToSave.m_cbPrepareInfo = 0;
		EntryToSave.m_pbPrepareInfo = NULL;
	}

	SAVE_DATA(&EntryToSave, (sizeof(XACTION_ENTRY)-sizeof(UCHAR *)));
	if (EntryToSave.m_cbPrepareInfo)
	{
	    SAVE_DATA(EntryToSave.m_pbPrepareInfo, m_Entry.m_cbPrepareInfo);
	}

    return TRUE;
}

/*====================================================
CTransaction::Load
    Loads transaction persistent data 
=====================================================*/
BOOL CTransaction::Load(HANDLE hFile)
{
    PERSIST_DATA;

    LOAD_DATA(m_Entry, (sizeof(XACTION_ENTRY)-sizeof(UCHAR *)));
    if (m_Entry.m_cbPrepareInfo)
    {
		AP<UCHAR> str;
        LOAD_ALLOCATE_DATA(str, m_Entry.m_cbPrepareInfo, PUCHAR);
		m_Entry.m_pbPrepareInfo = str.detach();
    }
    else
    {
        m_Entry.m_pbPrepareInfo = NULL;
    }

    return TRUE;
}


/*====================================================
CTransaction::PrepInfoRecovery
    Recovers xact PrepareInfo from the log record  
=====================================================*/
void CTransaction::PrepInfoRecovery(ULONG cbPrepInfo, UCHAR *pbPrepInfo)
{
    if(m_Entry.m_pbPrepareInfo != NULL)
	{
		//
		// This can happen if prep info for this transaction existed also in the check point file 
		// (saved image of the recource manager object)
		//
		return;
	}

    TrTRACE(XACT_LOG, "PrepInfo Recovery: p=J, index=%d",GetIndex());

    m_Entry.m_cbPrepareInfo = (USHORT)cbPrepInfo;
    m_Entry.m_pbPrepareInfo = new UCHAR[cbPrepInfo];
    ASSERT(m_Entry.m_pbPrepareInfo);
    CopyMemory(m_Entry.m_pbPrepareInfo, pbPrepInfo, cbPrepInfo);
}


/*====================================================
CTransaction::XactDataRecovery
    Recovers xact data (uow, seqnum) from the log record  
=====================================================*/
void CTransaction::XactDataRecovery(ULONG ulSeqNum, BOOL fSinglePhase, const XACTUOW *puow)
{
    //ASSERT(m_Entry.m_ulSeqNum == 0);  

    TrTRACE(XACT_LOG, "XatData Recovery: p=K, index=%d",GetIndex());

    m_Entry.m_ulSeqNum = ulSeqNum;
    CopyMemory(&m_Entry.m_uow, puow, sizeof(XACTUOW));
    if (fSinglePhase)
    {
        SetSinglePhase();
    }
}

//---------------------------------------------------------------------
// XactCreateQueue: creation of the transaction queue
//---------------------------------------------------------------------
HRESULT XactCreateQueue(HANDLE* phTransQueue, const XACTUOW* puow)
{
    HRESULT hr;
    hr = ACCreateTransaction(puow, phTransQueue);

    if (SUCCEEDED(hr))
    {

        //
        // Attach the transaction handle to the completion port
        //
        ExAttachHandle(*phTransQueue);
    }

    return LogHR(hr, s_FN, 240);
}


/*====================================================
CTransaction::HandleTransaction
    Handle overlapped operation asynchronous completion
=====================================================*/
VOID WINAPI CTransaction::HandleTransaction(EXOVERLAPPED* pov)
{
	//
	// Will release reference when function returns.
	//
    R<CTransaction> pXact = CONTAINING_RECORD (pov, CTransaction, m_qmov);

    ASSERT(pXact.get() != NULL);
    
    if(pov->GetStatus() == STATUS_CANCELLED)
    {   
        //
        // We assume that STATUS_CANCELLED is obtained on MSMQ shutdown
        // We don't want Abort or reporting in this case; let next recovery finish it
        //
        pXact->SetDoneHr(STATUS_CANCELLED);
        return;
    }

	pXact->Continuation(pov->GetStatus());
}


/*====================================================
QMPreInitResourceManager
    Pre-initialization of the xact mechanism
=====================================================*/
void QMPreInitXact()
{
    //
    // Get fine-tuning  parameters from registry
    //

    DWORD dwDef = FALCON_DEFAULT_XACT_RETRY_INTERVAL;
    READ_REG_DWORD(s_dwRetryInterval,
                   FALCON_XACT_RETRY_REGNAME,
                   &dwDef ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\verifypacket.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    VerifyPacket.cpp

Abstract:

    Native Packet Verify Routines

Author:

    Tomer Weisberg (t-tomerw) 21-Jan-02

--*/
#include "stdh.h"
#include "ph.h"
#include "fn.h"
#include "phintr.h"
#include "qmpkt.h"

#include "VerifyPacket.tmh"


/*======================================================================

 Function:     CBaseHeader::SectionIsValid

 Description:  Checks the header signature

 =======================================================================*/


void CBaseHeader::SectionIsValid(DWORD MessageSizeLimit, bool ValidateSig /*= TRUE*/) const
{
	if (GetPacketSize() > MessageSizeLimit)
	{
		TrERROR(NETWORKING, "size mismach");
		ASSERT_BENIGN(0);
		throw exception();
	}
	
    PCHAR pSection = GetNextSection();
    if (pSection > GetPacketEnd())
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

    if (ValidateSig && (!SignatureIsValid()))
    {
		TrERROR(NETWORKING, "Signature is not valid");
		ASSERT_BENIGN(0);
		throw exception();
    }

    if (!VersionIsValid())
    {
		TrERROR(NETWORKING, "Base section is not valid: Version is not valid");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CUserHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CUserHeader::SectionIsValid(PCHAR PacketEnd) const
{
	//
	// this function is called only from native protocol
	// which can not be multicast
	//
    if (m_bfPgm)
    {
		TrERROR(NETWORKING, "can not be multicast");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_bfDQT != qtGUID) && (m_bfDQT != qtPrivate) && (m_bfDQT != qtDirect) && (m_bfDQT != qtDestQM))
	{
		TrERROR(NETWORKING, "Destination queue type (%d) is not valid", m_bfDQT);
		ASSERT_BENIGN(0);
		throw exception();
	}

	if ((qtAdminQ == m_bfAQT) || (qtAdminQM == m_bfAQT))
	{
		TrERROR(NETWORKING, "Admin queue type (%d) is not valid", m_bfAQT);
		ASSERT_BENIGN(0);
		throw exception();
	}

	if ((qtNone == m_bfAQT) && (qtAdminQM == m_bfRQT))
	{
		TrERROR(NETWORKING, "Response queue type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

	if (!m_bfProperties)
	{
		TrERROR(NETWORKING, "Properties section flag must be set");
		ASSERT_BENIGN(0);
		throw exception();
	}

	//
	// this flag can be only 0 or 1 (but it is 2 bits length)
	//
	if (m_bfDelivery >= 2)
	{
		TrERROR(NETWORKING, "Delivery type (%d) not supported", m_bfDelivery);
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection;
   	pSection = GetNextSection((PUCHAR)PacketEnd);
    if (pSection > PacketEnd)
  	{
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	QUEUE_FORMAT qf;
	if (!GetDestinationQueue(&qf))
	{
		TrERROR(NETWORKING, "Destination queue is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

    if(!FnIsValidQueueFormat(&qf))
    {
        TrERROR(NETWORKING, "Destination queue format is not valid");
        ASSERT_BENIGN(0);
        throw exception();
    }

}


/*======================================================================

 Function:     CXactHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CXactHeader::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if (GetPrevSeqN() >= GetSeqN())
	{
		TrERROR(NETWORKING, "PrevSeqN >= GetSeqN");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CSecurityHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CSecurityHeader::SectionIsValid(PCHAR PacketEnd) const
{
	if((0 == m_wSenderIDSize) && (0 == m_wEncryptedKeySize) && (0 == m_wSignatureSize) &&
       (0 == m_ulSenderCertSize) && (0 == m_ulProvInfoSize))
	{
		TrERROR(NETWORKING, "No data");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_wSignatureSize != 0) && (!m_bfDefProv) && (m_ulProvInfoSize < 6))
	{
		TrERROR(NETWORKING, "Default provider is not set but provider size is smaller than 6");
		ASSERT_BENIGN(0);
		throw exception();
	}

    const UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;
    if (pProvInfo)
    {
    	pGetSubSectionEx( e_SecInfo_Test, pProvInfo, const_cast<const UCHAR *>((UCHAR*)PacketEnd));
    }

    if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_QM) && (m_wSenderIDSize != sizeof(GUID)))
    {
		TrERROR(NETWORKING, "MQMSG_SENDERID_TYPE_QM: SenderID size (%d) is not GUID size", m_wSenderIDSize);
		ASSERT_BENIGN(0);
		throw exception();
    }

    if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_SID) && (m_wSenderIDSize == 0))
    {
		TrERROR(NETWORKING, "MQMSG_SENDERID_TYPE_SID: SenderID size is zero");
		ASSERT_BENIGN(0);
		throw exception();
    }

	USHORT Size;
	if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_SID) && (!IsValidSid((PSID)GetSenderID(&Size))))
	{
		TrERROR(NETWORKING, "SenderID SID is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CPropertyHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CPropertyHeader::SectionIsValid(PCHAR PacketEnd) const
{
    if (GetTitleLength() > MQ_MAX_MSG_LABEL_LEN)
    {
		TrERROR(NETWORKING, "label length too long");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if (m_ulBodySize > m_ulAllocBodySize)
	{
		TrERROR(NETWORKING, "body size is bigger than Alloc body size");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CDebugSection::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CDebugSection::SectionIsValid(PCHAR PacketEnd) const
{
	if ((qtNone != m_bfRQT) && (qtGUID != m_bfRQT))
	{
		TrERROR(NETWORKING, "Report Queue type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CBaseMqfHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CBaseMqfHeader::SectionIsValid(PCHAR PacketEnd)
{
	if (!ISALIGN4_ULONG(m_cbSize))
	{
		TrERROR(NETWORKING, "Size is not aligned");
		ASSERT_BENIGN(0);
		throw exception();
	}
	
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

    UCHAR * pMqfBuffer = GetSerializationBuffer();
    if ((m_nMqf!=0) && (pMqfBuffer == (UCHAR *)pSection))
    {
		TrERROR(NETWORKING, "No MQF buffer");
		ASSERT_BENIGN(0);
		throw exception();
    }

    QUEUE_FORMAT qf;
    for (ULONG i=0; i<m_nMqf; i++)
    {
    	if (pSection < (PCHAR)pMqfBuffer)
    	{
			TrERROR(NETWORKING, "MQF buffer is not valid");
			ASSERT_BENIGN(0);
			throw exception();
    	}
    	pMqfBuffer = GetQueueFormat(pMqfBuffer, &qf, (UCHAR *)pSection);
    }
}


/*======================================================================

 Function:     CMqfSignatureHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CMqfSignatureHeader::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CInternalSection::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CInternalSection::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_bfType != INTERNAL_SESSION_PACKET) &&
		(m_bfType != INTERNAL_ESTABLISH_CONNECTION_PACKET) &&
		(m_bfType != INTERNAL_CONNECTION_PARAMETER_PACKET))
	{
		TrERROR(NETWORKING, "Internal packet type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CQmPacket::PacketIsValid

 Description:  Checks cross section information

 =======================================================================*/

void CQmPacket::PacketIsValid() const
{
	if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
	{
		if ((m_pcUserMsg->IsOrdered()) && (m_pBasicHeader->GetPriority() != 0))
		{
			TrERROR(NETWORKING, "xact packet has to have priority = 0");
			ASSERT_BENIGN(0);
			throw exception();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\symmkey.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    symmkey.cpp

Abstract:

    Encryption/Decryption symmetric key caching and handling.

Author:

    Boaz Feldbaum (BoazF) 30-Oct-1996.

--*/

#include "stdh.h"
#include <ds.h>
#include "qmsecutl.h"
#include "cache.h"
#include <mqsec.h>

#include "symmkey.tmh"

extern BOOL g_fSendEnhRC2WithLen40 ;

#define QMCRYPTINFO_KEYXPBK_EXIST   1
#define QMCRYPTINFO_HKEYXPBK_EXIST  2
#define QMCRYPTINFO_RC4_EXIST       4
#define QMCRYPTINFO_RC2_EXIST       8

static WCHAR *s_FN=L"symmkey";

//
// This is the structure where we store the cached symmetric keys.
// It used for both sender and receiver side.
//
class QMCRYPTINFO : public CCacheValue
{
public:
    QMCRYPTINFO();

    CHCryptKey hKeyxPbKey;      // A handle to the QM key exchange public key.
    AP<BYTE> pbPbKeyxKey;       // The QM key exchange public key blob.
    DWORD dwPbKeyxKeyLen;       // The QM key exchange public key blob length.

    CHCryptKey hRC4Key;         // A handle to the RC4 symmetric key.
    AP<BYTE> pbRC4EncSymmKey;   // The RC4 symmetric key blob.
    DWORD dwRC4EncSymmKeyLen;   // The RC4 symmetric key blob length.

    CHCryptKey hRC2Key;         // A handle to the RC2 symmetric key.
    AP<BYTE> pbRC2EncSymmKey;   // The RC2 symmetric key blob.
    DWORD dwRC2EncSymmKeyLen;   // The RC2 symmetric key blob length.

    DWORD dwFlags;              // Flags that indicates which of the fields are valid.
    enum enumProvider eProvider;
    HCRYPTPROV        hProv;
    HRESULT           hr;

private:
    ~QMCRYPTINFO() {}
};

typedef QMCRYPTINFO *PQMCRYPTINFO;

QMCRYPTINFO::QMCRYPTINFO() :
    dwPbKeyxKeyLen(0),
    dwRC4EncSymmKeyLen(0),
    dwRC2EncSymmKeyLen(0),
    eProvider(eBaseProvider),
    dwFlags(0),
    hProv(NULL)
{
}

template<>
inline void AFXAPI DestructElements(PQMCRYPTINFO *ppQmCryptInfo, int nCount)
{
    for (; nCount--; ppQmCryptInfo++)
    {
        (*ppQmCryptInfo)->Release();
    }
}

//
// Make two partitions of the time array. Return an index into
// the array from which. All the elements before the returned
// index are smaller than all the elements after the returned
// index.
//
// This is the partition function of qsort.
//
int PartitionTime(ULONGLONG* t, int p, int r)
{
    ULONGLONG x = t[p];
    int i = p - 1;
    int j = r + 1;

    while (1)
    {
        while (t[--j] > x)
        {
            NULL;
        }

        while (t[++i] < x)
        {
            NULL;
        }

        if (i < j)
        {
            ULONGLONG ti = t[i];
            t[i] = t[j];
            t[j] = ti;
        }
        else
        {
            return j;
        }
    }
}

//
// Find the median time of the time array.
//
ULONGLONG FindMedianTime(ULONGLONG * t, int p, int r, int i)
{
    if (p == r)
    {
        return t[p];
    }

    int q = PartitionTime(t, p, r);
    int k = q - p + 1;

    if (i <= k)
    {
        return FindMedianTime(t, p, q, i);
    }
    else
    {
        return FindMedianTime(t, q + 1, r, i - k);
    }
}

//
// Mapping from a QM GUID to QM crypto info.
//
typedef CCache
   <GUID, const GUID&, PQMCRYPTINFO, PQMCRYPTINFO> GUID_TO_CRYPTINFO_MAP;

//
// Sender side maps - The cached symmetric keys for the destination QMs (receivers).
//
static GUID_TO_CRYPTINFO_MAP g_MapSendQMGuidToBaseCryptInfo;
static GUID_TO_CRYPTINFO_MAP g_MapSendQMGuidToEnhCryptInfo;

#define SET_SEND_CRYPTINFO_MAP(eprovider, pMap)     \
    if (eProvider == eEnhancedProvider)             \
    {                                               \
        pMap = &g_MapSendQMGuidToEnhCryptInfo;      \
    }                                               \
    else                                            \
    {                                               \
        pMap = &g_MapSendQMGuidToBaseCryptInfo;     \
    }


static
PQMCRYPTINFO
GetSendQMCryptInfo(
	const GUID *pguidQM,
	enum enumProvider eProvider
	)
/*++
Routine Description:
	Sender side.
	Get the cached CryptInfo of the receiver (destination QM) from the map
	or create new entry for the receiver in the map.

Arguments:
	pguidQM - pointer to the receiver qm guid.
	eProvider - crypto provider type (base, enhanced)

Returned Value:
	pointer to the cached data QMCRYPTINFO for the receiver (destination QM).

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap);

    PQMCRYPTINFO pQMCryptInfo;

    if (!pMap->Lookup(*pguidQM, pQMCryptInfo))
    {
        //
        // No cached data so far, allocate the structure and store it in
        // the map.
        //
        pQMCryptInfo = new QMCRYPTINFO;
        pQMCryptInfo->eProvider = eProvider;

        HRESULT hr = MQSec_AcquireCryptoProvider(eProvider, &(pQMCryptInfo->hProv));
        if(FAILED(hr))
        {
			TrERROR(SECURITY, "Failed to acquire crypto provider, eProvider = %d, %!hresult!", eProvider, hr);
        }

        pQMCryptInfo->hr = hr;

        pMap->SetAt(*pguidQM, pQMCryptInfo);
    }

    return(pQMCryptInfo);
}


static
HRESULT
GetSendQMKeyxPbKey(
    const GUID *pguidQM,
    PQMCRYPTINFO pQMCryptInfo
    )
/*++
Routine Description:
	Sender side.
	Get the exchange public key blob of the receiver (destination QM).
	either from the cached data, or from the DS.

Arguments:
	pguidQM - pointer to the receiver qm guid.
	pQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).

Returned Value:
	HRESULT

--*/
{
    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_KEYXPBK_EXIST))
    {
		//
        // No cached data, Get the exchange public key of the receiver from the DS
		//
        AP<BYTE> abPbKey;
        DWORD dwReqLen = 0;

        HRESULT rc = MQSec_GetPubKeysFromDS(
						pguidQM,
						NULL,
						pQMCryptInfo->eProvider,
						PROPID_QM_ENCRYPT_PKS,
						&abPbKey,
						&dwReqLen
						);

        if (FAILED(rc))
        {
			TrERROR(SECURITY, "Failed to get destination exchange public key from the DS, DestinationQm = %!guid!, eProvider = %d, %!hresult!", pguidQM, pQMCryptInfo->eProvider, rc);
            return rc;
        }

        ASSERT(abPbKey);

		//
        // Store the exchange public key in the cached data.
		//
        pQMCryptInfo->dwFlags |= QMCRYPTINFO_KEYXPBK_EXIST;

        if (dwReqLen)
        {
			TrTRACE(SECURITY, "Got destination exchange public key from the DS, DestinationQm = %!guid!, eProvider = %d", pguidQM, pQMCryptInfo->eProvider);
            pQMCryptInfo->pbPbKeyxKey = abPbKey.detach();
        }
        pQMCryptInfo->dwPbKeyxKeyLen = dwReqLen;
    }

    if (!pQMCryptInfo->dwPbKeyxKeyLen)
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 20);
    }

    return(MQ_OK);
}


HRESULT
GetSendQMKeyxPbKey(
	IN const GUID *pguidQM,
	enum enumProvider eProvider
	)
/*++
Routine Description:
	Sender side.
	Get the exchange public key blob of the receiver (destination QM).

Arguments:
	pguidQM - pointer to the receiver qm guid.
	eProvider - crypto provider type (base, enhanced)

Returned Value:
	HRESULT

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap);

    CS lock(pMap->m_cs);

    R<QMCRYPTINFO> pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider);

    if (pQMCryptInfo->hProv == NULL)
    {
        return pQMCryptInfo->hr;
    }

    return LogHR(GetSendQMKeyxPbKey(pguidQM, pQMCryptInfo.get()), s_FN, 30);
}


static
HRESULT
GetSendQMKeyxPbKeyHandle(
    const GUID *pguidQM,
    PQMCRYPTINFO pQMCryptInfo
    )
/*++
Routine Description:
	Sender side.
	Get handle to the exchange public key blob of the receiver (destination QM).
	If the handle doesn't exist in the cached info, import the exchange public key blob to get the handle.

Arguments:
	pguidQM - pointer to the receiver qm guid.
	pQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).

Returned Value:
	HRESULT

--*/
{
    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_HKEYXPBK_EXIST))
    {
		//
        // Get the key blob into the cache.
		//
        HRESULT rc = GetSendQMKeyxPbKey(pguidQM, pQMCryptInfo);

        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 40);
        }

		//
        // Get the handle, Import the exchange public key blob.
		//
        ASSERT(pQMCryptInfo->hProv);
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pQMCryptInfo->pbPbKeyxKey,
                pQMCryptInfo->dwPbKeyxKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hKeyxPbKey
                ))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CryptImportKey() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_HKEYXPBK_EXIST;
    }

    return (MQ_OK);
}


static
HRESULT
_ExportSymmKey(
	IN  HCRYPTKEY   hSymmKey,
	IN  HCRYPTKEY   hPubKey,
	OUT BYTE      **ppKeyBlob,
	OUT DWORD      *pdwBlobSize
	)
/*++
Routine Description:
	Sender side.
	Export the session key with the receiver exchange public key.

Arguments:
	hSymmKey - Handle to the symmetric key to export.
	hPubKey - Handle to the receiver exchange public key.
	ppKeyBlob - pointer to the exported symmetric key (session key) blob.
	pdwBlobSize - exported symmetric key (session key) blob size.
	
Returned Value:
	HRESULT

--*/
{

	//
	// Get required size
	//
    DWORD dwSize = 0;

    BOOL bRet = CryptExportKey(
						hSymmKey,
						hPubKey,
						SIMPLEBLOB,
						0,
						NULL,
						&dwSize
						);
    ASSERT(bRet && (dwSize > 0));
    if (!bRet || (dwSize == 0))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptExportKey() failed, gle = %!winerr!", gle);
        return MQ_ERROR_CANNOT_EXPORT_KEY;
    }

    *ppKeyBlob = new BYTE[dwSize];
    if (!CryptExportKey(
				hSymmKey,
				hPubKey,
				SIMPLEBLOB,
				0,
				*ppKeyBlob,
				&dwSize
				))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptExportKey() failed, gle = %!winerr!", gle);
        return MQ_ERROR_CANNOT_EXPORT_KEY;
    }

    *pdwBlobSize = dwSize;
    return MQ_OK;
}


HRESULT
GetSendQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY      *phSymmKey,
    BYTE          **ppEncSymmKey,
    DWORD          *pdwEncSymmKeyLen,
    CCacheValue   **ppQMCryptInfo
    )
/*++
Routine Description:
	Sender side.
	Get handle to RC4 symmetric key for the destination QM.
	and export (encrypt) the RC4 key with the destination QM exchange public key.

Arguments:
	pguidQM - pointer to the receiver qm guid.
	eProvider - crypto provider type (base, enhanced).
	phSymmKey - RC4 Symmetric key handle
	ppEncSymmKey - Exported (enctrypted) Symmetric key blob.
	pdwEncSymmKeyLen - Exported (enctrypted) Symmetric key blob size.
	ppQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).

Returned Value:
	HRESULT

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap);

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST))
    {
		//
        // Get the handle of the receiver exchange public key into the cache.
		//
        HRESULT rc = GetSendQMKeyxPbKeyHandle(pguidQM, pQMCryptInfo);
        if (FAILED(rc))
        {
			TrERROR(SECURITY, "Failed to get handle to the receiver exchange public key, DestinationQm = %!guid!, %!hresult!", pguidQM, rc);
            return rc;
        }

		//
        // Generate an RC4 symmetric key,
		//
        ASSERT(pQMCryptInfo->hProv);
        if (!CryptGenKey(
				pQMCryptInfo->hProv,
				CALG_RC4,
				CRYPT_EXPORTABLE,
				&pQMCryptInfo->hRC4Key
				))
        {
        	DWORD gle = GetLastError();
			TrERROR(SECURITY, "Failed to generate RC4 symmetric key, gle = %!winerr!", gle);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        AP<BYTE> abSymmKey;
        DWORD dwSymmKeyLen = 0;

        rc = _ExportSymmKey(
					pQMCryptInfo->hRC4Key,
					pQMCryptInfo->hKeyxPbKey,
					&abSymmKey,
					&dwSymmKeyLen
					);
        if (FAILED(rc))
        {
            CryptDestroyKey(pQMCryptInfo->hRC4Key);
            pQMCryptInfo->hRC4Key = NULL;

			TrERROR(SECURITY, "Failed to export RC4 symmetric key, %!hresult!", rc);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

		//
        // Store the key in the cache.
		//
        pQMCryptInfo->dwRC4EncSymmKeyLen = dwSymmKeyLen;
        pQMCryptInfo->pbRC4EncSymmKey = abSymmKey.detach();

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC4_EXIST;
    }

    if (phSymmKey)
    {
        *phSymmKey = pQMCryptInfo->hRC4Key;
    }

    if (ppEncSymmKey)
    {
        *ppEncSymmKey = pQMCryptInfo->pbRC4EncSymmKey;
    }

    if (pdwEncSymmKeyLen)
    {
        *pdwEncSymmKeyLen = pQMCryptInfo->dwRC4EncSymmKeyLen;
    }

    return(MQ_OK);
}


HRESULT
GetSendQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    )
/*++
Routine Description:
	Sender side.
	Get handle to RC2 symmetric key for the destination QM.
	and export (encrypt) the RC2 key with the destination QM exchange public key.

Arguments:
	pguidQM - pointer to the receiver qm guid.
	eProvider - crypto provider type (base, enhanced).
	phSymmKey - RC2 Symmetric key handle
	ppEncSymmKey - Exported (enctrypted) Symmetric key blob.
	pdwEncSymmKeyLen - Exported (enctrypted) Symmetric key blob size.
	ppQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).

Returned Value:
	HRESULT

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap);

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST))
    {
		//
        // Get the handle to the key exchange key into the cache.
		//
        HRESULT rc = GetSendQMKeyxPbKeyHandle(pguidQM, pQMCryptInfo);
        if (FAILED(rc))
        {
			TrERROR(SECURITY, "Failed to get handle to the receiver exchange public key, DestinationQm = %!guid!, %!hresult!", pguidQM, rc);
            return rc;
        }

		//
        // Generate an RC2 symmetric key,
		//
        ASSERT(pQMCryptInfo->hProv);
        if (!CryptGenKey(
					pQMCryptInfo->hProv,
					CALG_RC2,
					CRYPT_EXPORTABLE,
					&pQMCryptInfo->hRC2Key
					))
        {
        	DWORD gle = GetLastError();
			TrERROR(SECURITY, "Failed to generate RC2 symmetric key, gle = %!winerr!", gle);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        if ((eProvider == eEnhancedProvider) && g_fSendEnhRC2WithLen40)
        {
            //
            // Windows bug 562586.
            // For backward compatibility, send RC2 with effective key
            // length of 40 bits.
            //
            const DWORD x_dwEffectiveLength = 40 ;

            if (!CryptSetKeyParam( pQMCryptInfo->hRC2Key,
                                   KP_EFFECTIVE_KEYLEN,
                                   (BYTE*) &x_dwEffectiveLength,
                                   0 ))
            {
        	    DWORD gle = GetLastError();
			    TrERROR(SECURITY, "Failed to set enhanced RC2 key len to 40 bits, gle = %!winerr!", gle);
                return MQ_ERROR_CANNOT_SET_RC2_TO40 ;
            }
        }

        AP<BYTE> abSymmKey;
        DWORD dwSymmKeyLen = 0;

        rc = _ExportSymmKey(
					pQMCryptInfo->hRC2Key,
					pQMCryptInfo->hKeyxPbKey,
					&abSymmKey,
					&dwSymmKeyLen
					);
        if (FAILED(rc))
        {
            CryptDestroyKey(pQMCryptInfo->hRC2Key);
            pQMCryptInfo->hRC2Key = NULL;

			TrERROR(SECURITY, "Failed to export RC2 symmetric key, %!hresult!", rc);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

		//
        // Store the key in the cache.
		//
        pQMCryptInfo->dwRC2EncSymmKeyLen = dwSymmKeyLen;
        pQMCryptInfo->pbRC2EncSymmKey = abSymmKey.detach();

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC2_EXIST;
    }

    if (phSymmKey)
    {
        *phSymmKey = pQMCryptInfo->hRC2Key;
    }

    if (ppEncSymmKey)
    {
        *ppEncSymmKey = pQMCryptInfo->pbRC2EncSymmKey;
    }

    if (pdwEncSymmKeyLen)
    {
        *pdwEncSymmKeyLen = pQMCryptInfo->dwRC2EncSymmKeyLen;
    }

    return(MQ_OK);
}

//
// Receiver side maps - The cached symmetric keys for source QMs.
//
static GUID_TO_CRYPTINFO_MAP g_MapRecQMGuidToBaseCryptInfo;
static GUID_TO_CRYPTINFO_MAP g_MapRecQMGuidToEnhCryptInfo;

#define SET_REC_CRYPTINFO_MAP(eProvider, pMap)      \
    if (eProvider == eEnhancedProvider)             \
    {                                               \
        pMap = &g_MapRecQMGuidToEnhCryptInfo;       \
    }                                               \
    else                                            \
    {                                               \
        pMap = &g_MapRecQMGuidToBaseCryptInfo;      \
    }


static
PQMCRYPTINFO
GetRecQMCryptInfo(
	IN  const GUID *pguidQM,
	IN  enum enumProvider eProvider
	)
/*++
Routine Description:
	Receiver side.
	Get the cached CryptInfo of the sender (source QM) from the map
	or create new entry for the sender in the map.

Arguments:
	pguidQM - pointer to the sender qm guid.
	eProvider - crypto provider type (base, enhanced)

Returned Value:
	pointer to the cached data QMCRYPTINFO for the sender (source QM).

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap);

    PQMCRYPTINFO pQMCryptInfo;

    if (!pMap->Lookup(*pguidQM, pQMCryptInfo))
    {
        //
        // No cached data so far, allocate the structure and store it in
        // the map.
        //
        pQMCryptInfo = new QMCRYPTINFO;
        pQMCryptInfo->eProvider = eProvider;

        HRESULT hr = MQSec_AcquireCryptoProvider(eProvider, &(pQMCryptInfo->hProv));
        if(FAILED(hr))
        {
			TrERROR(SECURITY, "Failed to acquire crypto provider, eProvider = %d, %!hresult!", eProvider, hr);
        }

        pQMCryptInfo->hr = hr;

        pMap->SetAt(*pguidQM, pQMCryptInfo);
    }

    return(pQMCryptInfo);
}


HRESULT
GetRecQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo,
    OUT BOOL  *pfNewKey
    )
/*++
Routine Description:
	Receiver side.
	Get the RC2 symmetric key handle that should be used for decrypting the message.

Arguments:
	pguidQM - pointer to the sender qm guid.
	eProvider - crypto provider type (base, enhanced)
	phSymmKey - Handle to the RC2 symmetric key.
	pbEncSymmKey - Encrypted Symmetric (session) key for decrypting the message.
	dwEncSymmKeyLen - Encrypted Symmetric (session) key size.
	ppQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).
	
Returned Value:
	HRESULT

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap);

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetRecQMCryptInfo(pguidQM, eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (pQMCryptInfo->hProv == NULL)
    {
        return pQMCryptInfo->hr;
    }

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST) ||
        (pQMCryptInfo->dwRC2EncSymmKeyLen != dwEncSymmKeyLen) ||
        (memcmp(pQMCryptInfo->pbRC2EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen) != 0))
    {
		//
        // We either do not have a cached symmetric key,
        // or the symmetric key was modified.
		//
		
        if (pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST)
        {
			//
            // The symmetric key was modified. Free the previous one.
			//
            ASSERT(pQMCryptInfo->hRC2Key);
            ASSERT(pQMCryptInfo->dwRC2EncSymmKeyLen);

			TrTRACE(SECURITY, "RC2 symmetric key was modified, SourceQm = %!guid!", pguidQM);

            CryptDestroyKey(pQMCryptInfo->hRC2Key);
            pQMCryptInfo->hRC2Key = NULL;
            pQMCryptInfo->pbRC2EncSymmKey.free();
            pQMCryptInfo->dwFlags &= ~QMCRYPTINFO_RC2_EXIST;
        }

		//
        // Import the new key.
		//
        ASSERT(pQMCryptInfo->hProv);
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pbEncSymmKey,
                dwEncSymmKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hRC2Key
                ))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CryptImportKey() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

		//
        // Store the new key in the cache.
		//
        pQMCryptInfo->pbRC2EncSymmKey = new BYTE[dwEncSymmKeyLen];
        pQMCryptInfo->dwRC2EncSymmKeyLen = dwEncSymmKeyLen;
        memcpy(pQMCryptInfo->pbRC2EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen);

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC2_EXIST;
        *pfNewKey = TRUE ;
    }

    *phSymmKey = pQMCryptInfo->hRC2Key;

    return(MQ_OK);
}


HRESULT
GetRecQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY  *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    )
/*++
Routine Description:
	Receiver side.
	Get the RC4 symmetric key handle that should be used for decrypting the message.

Arguments:
	pguidQM - pointer to the sender qm guid.
	eProvider - crypto provider type (base, enhanced)
	phSymmKey - Handle to the RC4 symmetric key.
	pbEncSymmKey - Encrypted Symmetric (session) key for decrypting the message.
	dwEncSymmKeyLen - Encrypted Symmetric (session) key size.
	ppQMCryptInfo - pointer to the cached data QMCRYPTINFO for the receiver (destination QM).
	
Returned Value:
	HRESULT

--*/
{
	//
	// Get map pointer according to provider type.
	//
    GUID_TO_CRYPTINFO_MAP  *pMap;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap);

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetRecQMCryptInfo(pguidQM, eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (pQMCryptInfo->hProv == NULL)
    {
        return pQMCryptInfo->hr;
    }

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST) ||
        (pQMCryptInfo->dwRC4EncSymmKeyLen != dwEncSymmKeyLen) ||
        (memcmp(pQMCryptInfo->pbRC4EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen) != 0))
    {
		//
        // We either do not have a cached symmetric key,
        // or the symmetric key was modified.
		//
		
        if (pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST)
        {
			//
            // The symmetric key was modified. Free the previous one.
			//
            ASSERT(pQMCryptInfo->hRC4Key);
            ASSERT(pQMCryptInfo->dwRC4EncSymmKeyLen);

			TrTRACE(SECURITY, "RC4 symmetric key was modified, SourceQm = %!guid!", pguidQM);

            CryptDestroyKey(pQMCryptInfo->hRC4Key);
            pQMCryptInfo->hRC4Key = NULL;
            pQMCryptInfo->pbRC4EncSymmKey.free();
            pQMCryptInfo->dwFlags &= ~QMCRYPTINFO_RC4_EXIST;
        }

		//
        // Import the new key.
		//
        ASSERT(pQMCryptInfo->hProv);
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pbEncSymmKey,
                dwEncSymmKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hRC4Key
                ))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CryptImportKey() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

		//
        // Store the new key in the cache.
		//
        pQMCryptInfo->pbRC4EncSymmKey = new BYTE[dwEncSymmKeyLen];
        pQMCryptInfo->dwRC4EncSymmKeyLen = dwEncSymmKeyLen;
        memcpy(pQMCryptInfo->pbRC4EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen);

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC4_EXIST;
    }

    *phSymmKey = pQMCryptInfo->hRC4Key;

    return(MQ_OK);
}

void
InitSymmKeys(
    const CTimeDuration& CacheBaseLifetime,
    const CTimeDuration& CacheEnhLifetime,
    DWORD dwSendCacheSize,
    DWORD dwReceiveCacheSize
    )
{
    g_MapSendQMGuidToBaseCryptInfo.m_CacheLifetime = CacheBaseLifetime;
    g_MapSendQMGuidToBaseCryptInfo.InitHashTable(dwSendCacheSize);

    g_MapSendQMGuidToEnhCryptInfo.m_CacheLifetime = CacheEnhLifetime;
    g_MapSendQMGuidToEnhCryptInfo.InitHashTable(dwSendCacheSize);

    g_MapRecQMGuidToEnhCryptInfo.InitHashTable(dwReceiveCacheSize);
    g_MapRecQMGuidToBaseCryptInfo.InitHashTable(dwReceiveCacheSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdh.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
	ASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
	ASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(numeric_cast<int>(_tcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(numeric_cast<int>(_tcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
	ASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
	#define TCHAR_ARG   int
	#define WCHAR_ARG   unsigned
	#define CHAR_ARG    int
#else
	#define TCHAR_ARG   TCHAR
	#define WCHAR_ARG   WCHAR
	#define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	INT_PTR nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		INT_PTR nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			nItemLen = lstrlen(va_arg(argList, LPCTSTR));
			nItemLen = max(1, nItemLen);
			break;

		case 'S':
#ifndef _UNICODE
			nItemLen = wcslen(va_arg(argList, LPWSTR));
#else
			nItemLen = lstrlenA(va_arg(argList, LPCSTR));
#endif
			nItemLen = max(1, nItemLen);
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			nItemLen = lstrlenA(va_arg(argList, LPCSTR));
			nItemLen = max(1, nItemLen);
			break;
#ifndef _MAC
		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			nItemLen = wcslen(va_arg(argList, LPWSTR));
			nItemLen = max(1, nItemLen);
			break;
#endif
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(INT_PTR_TO_INT(nMaxLen));
	VERIFY(_vsntprintf(m_pchData, GetAllocLength(), lpszFormat, argListSave) <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}


void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = INT_PTR_TO_INT(lpszLast - m_pchData);
	}
}

void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - INT_PTR_TO_INT(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

template<>
void AFXAPI ConstructElements(CString* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(CString)));

	for (; nCount--; ++pElements)
		memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

template<>
void AFXAPI DestructElements(CString* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(CString)));

	for (; nCount--; ++pElements)
		pElements->~CString();
}

template<>
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(CString)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(CString)));

	for (; nCount--; ++pDest, ++pSrc)
		*pDest = *pSrc;
}

template<>
UINT AFXAPI HashKey(LPCTSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\verifysignmqf.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    VerifySignMqf.cpp

Abstract:
    functions to verify mqf signature 

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "session.h"
#include "qmsecutl.h"
#include <mqsec.h>
#include <mqformat.h>
#include <mqf2format.h>
#include "tr.h"
#include "cry.h"
#include "mqexception.h"

#include "VerifySignMqf.tmh"

static WCHAR *s_FN=L"VerifySignMqf";


static
void 
MsgBodyHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Message Body hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Body
	//
	ULONG dwBodySize;
	const UCHAR* pBody = PktPtrs->GetPacketBody(&dwBodySize);
	if(pBody != NULL)
	{
		CryHashData(
			pBody, 
			dwBodySize,
			hHash
			);

		TrTRACE(SECURITY, "Hash, BodySize = %d", dwBodySize);
	}
}


static
void 
CorrelationIdHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	CorrelationId hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// CorrelationID
	//
	CryHashData(
		reinterpret_cast<const BYTE*>(PktPtrs->GetCorrelation()), 
		PROPID_M_CORRELATIONID_SIZE,
		hHash
		);

	TrTRACE(SECURITY, "Hash, CorrelationSize = %d", PROPID_M_CORRELATIONID_SIZE);
}


static
void 
ApplicationTagHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Application Tag hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Application tag
	//
	ULONG ApplicationTag = PktPtrs->GetApplicationTag();

	CryHashData(
		reinterpret_cast<const BYTE*>(&ApplicationTag), 
		sizeof(DWORD),
		hHash
		);

	TrTRACE(SECURITY, "Hash, ApplicationTag = %d", ApplicationTag);
}


static
void 
TitleHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Title hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Title
	//
	if(PktPtrs->GetTitlePtr() != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(PktPtrs->GetTitlePtr()), 
			PktPtrs->GetTitleLength() * sizeof(WCHAR),
			hHash
			);

		TrTRACE(SECURITY, "Hash, TitleSize = %d", PktPtrs->GetTitleLength());
		TrTRACE(SECURITY, "Hash, Title = %ls", PktPtrs->GetTitlePtr());
	}
}


static
void 
MqfHash(
	IN HCRYPTHASH			hHash, 	
    IN const QUEUE_FORMAT*	pqf,
	IN ULONG				nMqf
	)
/*++
Routine Description:
	Mqf hash.

Arguments:
	hHash - hash object.
	pqf - pointer to QUEUE_FORMAT array.
	nMqf - pqf array size.

Returned Value:
	none.

--*/
{
	ULONG FormatNameLength = 0;
	AP<WCHAR> pFormatName = MQpMqfToFormatName(
								pqf, 
								nMqf, 
								&FormatNameLength 
								);

	ASSERT(("Failed to get Mqf format name", pFormatName != NULL)); 

	CryHashData(
		reinterpret_cast<const BYTE*>(pFormatName.get()), 
		FormatNameLength * sizeof(WCHAR),
		hHash
		);

	TrTRACE(SECURITY, "Hash, nMqf = %d", nMqf);
	TrTRACE(SECURITY, "Hash, FormatNameLen(mqf) = %d", FormatNameLength);
	TrTRACE(SECURITY, "Hash, FormatName(mqf) = %ls", pFormatName.get());
}


static
void 
ResponseMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	ResponseMqf hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Get Response FormatName. 
    //
    ULONG nResponseMqf = PktPtrs->GetNumOfResponseMqfElements();

	QUEUE_FORMAT *   pResponseMqf = NULL;
	AP<QUEUE_FORMAT> pResponseMqfAutoCleanup;
    if(nResponseMqf > 0)
	{
		pResponseMqf = pResponseMqfAutoCleanup = new QUEUE_FORMAT[nResponseMqf];
		PktPtrs->GetResponseMqf(pResponseMqf, nResponseMqf);

		TrTRACE(SECURITY, "Hash, ResponseMqf:");
	}

	//
	// We might have the Response queue only in the old Response queue property
	// This is true if we have only 1 queue compatible to msmq2.0 format.
	// In this case we will not have the Mqf headers
	//
	QUEUE_FORMAT RespQueueformat;
	if((nResponseMqf == 0) && (PktPtrs->GetResponseQueue(&RespQueueformat)))
	{
		pResponseMqf = &RespQueueformat;
		nResponseMqf = 1;

		TrTRACE(SECURITY, "Hash, ResponseQueue (old property):");
	}

    if(nResponseMqf > 0)
	{
		MqfHash(
			hHash,
			pResponseMqf, 
			nResponseMqf
			);
	}
}


static
void 
AdminMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	AdminMqf hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
    //
    // Get the string representation for the admin Format Name.
    //
    ULONG nAdminMqf = PktPtrs->GetNumOfAdminMqfElements();

	QUEUE_FORMAT *   pAdminMqf = NULL;
	AP<QUEUE_FORMAT> pAdminMqfAutoCleanup;
    if(nAdminMqf > 0)
	{
		pAdminMqf = pAdminMqfAutoCleanup = new QUEUE_FORMAT[nAdminMqf];
		PktPtrs->GetAdminMqf(pAdminMqf, nAdminMqf);

		TrTRACE(SECURITY, "Hash, AdminMqf:");
	}

	//
	// We might have the Admin queue only in the old Admin queue property
	// This is true if we have only 1 queue compatible to msmq2.0 format.
	// In this case we will not have the Mqf headers
	//
	QUEUE_FORMAT AdminQueueformat;
	if((nAdminMqf == 0)	&& (PktPtrs->GetAdminQueue(&AdminQueueformat)))
	{
		pAdminMqf = &AdminQueueformat;
		nAdminMqf = 1;

		TrTRACE(SECURITY, "Hash, AdminQueue (old property):");
	}

    if(nAdminMqf > 0)
	{
		MqfHash(
			hHash,
			pAdminMqf, 
			nAdminMqf
			);
	}
}


static
void 
ExtensionHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Extension hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Extension
	//
	if(PktPtrs->GetMsgExtensionPtr() != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(PktPtrs->GetMsgExtensionPtr()), 
			PktPtrs->GetMsgExtensionSize(),
			hHash
			);

		TrTRACE(SECURITY, "Hash, ExtensionLen = %d", PktPtrs->GetMsgExtensionSize());
	}
}


static
void 
TargetFormatNameHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	TargetFormatName hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Get Destination FormatName. 
	// This is the exactly FormatName that was used in the send (different from the Destination Queue)
    //
    ULONG nDestinationMqf = PktPtrs->GetNumOfDestinationMqfElements();

	QUEUE_FORMAT *   pDestinationMqf = NULL;
	AP<QUEUE_FORMAT> pDestinationMqfAutoCleanup;
    if(nDestinationMqf > 0)
	{
		pDestinationMqf = pDestinationMqfAutoCleanup = new QUEUE_FORMAT[nDestinationMqf];
		PktPtrs->GetDestinationMqf(pDestinationMqf, nDestinationMqf);

		TrTRACE(SECURITY, "Hash, DestinationMqf:");

	}

	QUEUE_FORMAT DestinationQueueformat;
	if((nDestinationMqf == 0) && (PktPtrs->GetDestinationQueue(&DestinationQueueformat)))
	{
		//
		// We have the Destination queue only in the old Destination queue property
		//

		pDestinationMqf = &DestinationQueueformat;
		nDestinationMqf = 1;

		TrTRACE(SECURITY, "Hash, DestinationQueue (old property):");
	}

	ASSERT(nDestinationMqf >= 1);
	
	if(nDestinationMqf > 0)
	{
		MqfHash(
			hHash,
			pDestinationMqf, 
			nDestinationMqf
			);
	}
}


static
void 
SourceQmHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Source Qm hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Guid of source qm.
    //
	CryHashData(
		reinterpret_cast<const BYTE*>(PktPtrs->GetSrcQMGuid()), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(SECURITY, "Hash, SourceGuid = %!guid!", PktPtrs->GetSrcQMGuid());
}


static
void 
MsgFlagsInit(
	IN const CQmPacket* PktPtrs,
	OUT struct _MsgFlags& sUserFlags
	)
/*++
Routine Description:
	Prepare Message Flags.

Arguments:
	PktPtrs - pointer to the packet
	sUserFlags - structure of user flags

Returned Value:
	none.

--*/
{
    sUserFlags.bDelivery  = (UCHAR)  PktPtrs->GetDeliveryMode();
    sUserFlags.bPriority  = (UCHAR)  PktPtrs->GetPriority();
    sUserFlags.bAuditing  = (UCHAR)  PktPtrs->GetAuditingMode();
    sUserFlags.bAck       = (UCHAR)  PktPtrs->GetAckType();
    sUserFlags.usClass    = (USHORT) PktPtrs->GetClass();
    sUserFlags.ulBodyType = (ULONG)  PktPtrs->GetBodyType();
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const struct _MsgFlags& sUserFlags
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	sUserFlags - structure of user flags

Returned Value:
	none.

--*/
{
	CryHashData(
		reinterpret_cast<const BYTE*>(&sUserFlags), 
		sizeof(sUserFlags),
		hHash
		);

	TrTRACE(SECURITY, "Hash, bDelivery = %d", sUserFlags.bDelivery);
	TrTRACE(SECURITY, "Hash, bPriority = %d", sUserFlags.bPriority);
	TrTRACE(SECURITY, "Hash, bAuditing = %d", sUserFlags.bAuditing);
	TrTRACE(SECURITY, "Hash, bAck = %d", sUserFlags.bAck);
	TrTRACE(SECURITY, "Hash, usClass = %d", sUserFlags.usClass);
	TrTRACE(SECURITY, "Hash, ulBodyType = %d", sUserFlags.ulBodyType);
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // user flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

	MsgFlagsInit(PktPtrs, sUserFlags);
	MsgFlagsHash(hHash, sUserFlags);
}


static
void 
ConnectorHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Connector hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Connector Type
	//
    GUID guidConnector = GUID_NULL ;
    const GUID *pConnectorGuid = &guidConnector ;

    const GUID *pGuid = PktPtrs->GetConnectorType() ;
    if (pGuid)
    {
        pConnectorGuid = pGuid ;
    }

	CryHashData(
		reinterpret_cast<const BYTE*>(pConnectorGuid), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(SECURITY, "Hash, ConnectorGuid = %!guid!", pConnectorGuid);
}


static
void 
CalcPropHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Calc the hash value of Qm Packet Message property

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	MsgBodyHash(hHash, PktPtrs); 

	CorrelationIdHash(hHash, PktPtrs);
	ApplicationTagHash(hHash, PktPtrs);
	TitleHash(hHash, PktPtrs);
	ResponseMqfHash(hHash, PktPtrs);
	AdminMqfHash(hHash, PktPtrs);
	ExtensionHash(hHash, PktPtrs);
	TargetFormatNameHash(hHash, PktPtrs);
	SourceQmHash(hHash, PktPtrs);
	MsgFlagsHash(hHash, PktPtrs);
	ConnectorHash(hHash, PktPtrs);
}


void
VerifySignatureMqf(
	CQmPacket *PktPtrs, 
	HCRYPTPROV hProv, 
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	)
/*++
Routine Description:
	Verify mqf signature.
	this function verify that the signature in the packet fits the message body
	and other references that were signed with the public key of the certificate

Arguments:
	PktPtrs - pointer to the packet
	hProv - handle of the provider
	hPbKey - handle of the sender public key
	fMarkAuth - indicate if the packet will be marked as authenticated after verifying the signature.

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
	ASSERT(!PktPtrs->IsAuthenticated());
	ASSERT(PktPtrs->GetLevelOfAuthentication() == 0);

    //
    // Get the signature from the packet.
	//

	ASSERT(PktPtrs->GetSignatureMqfSize() > 0);

	ULONG SignatureMqfSize;
	const UCHAR* pSignatureMqf = PktPtrs->GetPointerToSignatureMqf(&SignatureMqfSize);

	TrTRACE(SECURITY, "SignatureMqfSize = %d", SignatureMqfSize);

	ASSERT(SignatureMqfSize > 0);
	ASSERT(hProv != NULL);
	ASSERT(hPbKey != NULL);

	CHashHandle hHash = CryCreateHash(
							hProv, 
							PktPtrs->GetHashAlg()
							);

	CalcPropHash(
		hHash, 
		PktPtrs
		);

	//
	// Validate signature
	//
	if (!CryptVerifySignature(
			hHash, 
			pSignatureMqf, 
			SignatureMqfSize, 
			hPbKey,
			NULL, 
			0
			)) 
	{
		DWORD dwErr = GetLastError();
		TrERROR(SECURITY, "fail at CryptVerifySignature(), err = %!winerr!", dwErr);

		ASSERT_BENIGN(("VerifySignatureMqf: Failed to verify signature", 0));
		throw bad_hresult(MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX);
	}

	TrTRACE(SECURITY, "Verify SignatureMqf completed ok");

	//
	// mark the message as authenticated only when needed. 
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
		TrTRACE(SECURITY, "The message will not mark as autheticated");
		return;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// We mark the authentication flag and the level of authentication as SIG30
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG30);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdh.h"
#include <winnls.h>

#define SafeStrlen(lpsz) (((lpsz) == 0) ? 0 : lstrlen(lpsz))

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
AFX_DATADEF TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static AFX_DATADEF CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
	Init();
}

CString::CString(const CString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData =
			(CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}
}

void CString::Release()
{
	if (GetData() != afxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CString::Empty()
{
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
	     ASSERT(0);
#if 0
		if (!LoadString(nID))
			TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
            */
#endif

	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        SafeStrlen(lpsz), lpsz);
	return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != afxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

void CString::MakeUpper()
{
	CopyBeforeWrite();
	::_wcsupr(m_pchData);
}

void CString::MakeLower()
{
	CopyBeforeWrite();
	::_wcslwr(m_pchData);
}

void CString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, numeric_cast<int>(count), NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if ( result <= (int)count && result > 0)
		mbstr[result-1] = 0;
	return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, numeric_cast<int>(count));
	ASSERT(wcstr == NULL || result <= (int)count);
	if ( result <= (int)count && result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
	return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
	return lpa;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include <stdh.h>

#define   INITGUID	
#include "initguid.h"			   
#include "TXDTC.H"
#include "Xact.h"    
#include "logmgrgu.h"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xact.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    Xact.h

Abstract:
    Transaction object definition

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACT_H__
#define __XACT_H__

#include "txdtc.h"
#include "xactping.h"
#include "xactrm.h"
#include "acdef.h"
#include "qmthrd.h"
#include "rpcsrv.h"
#include "autohandle.h"

// forward declaration
class CResourceManager;

//
// TXSTATE:  Transaction states
//
typedef enum
{
	//
	// The following three states are equaivalent and should be merged into one
	//
	TX_UNINITIALIZED,
	TX_INITIALIZED,
	TX_ENLISTED,

	TX_PREPARING,
	TX_PREPARED,
	TX_COMMITTING,
	TX_COMMITTED,
	TX_ABORTING,
	TX_ABORTED,
	TX_DONE,			// obsolete
	TX_TMDOWN,			// obsolete 
	TX_INVALID_STATE	// obsolete
} TXSTATE;


//
// TXACTION:  Actions upon transaction
//
typedef enum
{
	TA_CREATED,
	TA_STATUS_CHANGE,
	TA_DELETED
} TXACTION;

//
// TXFLUSHCONTEXT:  Context of waiting for log flush
//
typedef enum
{
	TC_PREPARE2,
	TC_PREPARE0,
	TC_COMMIT4
} TXFLUSHCONTEXT;

//
// TXSORTERTYPE:  type of sorter usage
//
typedef enum
{
	TS_PREPARE,
    TS_COMMIT
} TXSORTERTYPE;

//
// Masks for flag keeping
//
#define XACTION_MASK_UNCOORD        0x0040
#define XACTION_MASK_SINGLE_PHASE   0x0020
#define XACTION_MASK_FAILURE        0x0010	/* obsolete */
#define XACTION_MASK_STATE          0x000F
#define XACTION_MASK_SINGLE_MESSAGE 0x0080

//---------------------------------------------------------------------
// Transaction Persistent Entry (resides in a persistent Transaction File)
//---------------------------------------------------------------------
typedef struct XACTION_ENTRY {

    ULONG   m_ulIndex;                      //Xact discriminative index 
    ULONG   m_ulFlags;                      //Flags
    ULONG   m_ulSeqNum;                     //Seq Number of the prepared transaction
    XACTUOW m_uow;			                //Transaction ID  (16b.)
    USHORT  m_cbPrepareInfo;                //PrepareInfo length 
    UCHAR  *m_pbPrepareInfo;                //PrepareInfo address
            // This pointer must be last!
} XACTION_ENTRY;


//---------------------------------------------------------------------
// CTransaction: Transaction Object in Falcon RM
//---------------------------------------------------------------------
class CTransaction: public ITransactionResourceAsync, public CBaseContextType
{
    friend HRESULT CResourceManager::EnlistTransaction(
            const XACTUOW* pUow,
            DWORD cbCookie,
            unsigned char *pbCookie);

    friend HRESULT CResourceManager::EnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact);

    friend void CResourceManager::Destroy();

public:

	// Current data
	enum ContinueFunction {
      cfPrepareRequest1,
      cfCommitRequest1,
	  cfCommitRequest2,
	  cfFinishCommitRequest3,
      cfCommitRestore1,
	  cfCommitRestore2,
	  cfCommitRestore3,
	  cfAbortRestore1,
	  cfAbortRestore2, 
	  cfDirtyFailPrepare2,
	  cfCleanFailPrepare,
	  cfAbortRequest2,
	  cfAbortRequest3,
	};


    // Construction and COM
    //
    CTransaction(CResourceManager *pRM, ULONG ulIndex=0, BOOL fUncoordinated=FALSE);
    ~CTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    // ITransactionResourceAsync interface
    // Interfaces implementing ITransactionResourceAsync interface.
    //      PrepareRequest  -- Phase 1 notification from TM.
    //      CommitRequest   -- Phase 2 commit decision from TM.
    //      AbortRequest    -- Phase 2 abort decision from TM.
    //      TMDown          -- callback received when the TM goes down
    //
    STDMETHODIMP    PrepareRequest(BOOL fRetaining,
                                   DWORD grfRM,
                                   BOOL fWantMoniker,
                                   BOOL fSinglePhase);
    STDMETHODIMP    CommitRequest (DWORD grfRM,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    AbortRequest  (BOID *pboidReason,
                                   BOOL fRetaining,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    TMDown        (void);

    HRESULT		    InternalCommit();
	HRESULT			InternalAbort();

    // Recovery
    //
    void            PrepInfoRecovery(ULONG cbPrepInfo, 
                                     UCHAR *pbPrepInfo);
    void            XactDataRecovery(ULONG ulSeqNum, 
                                     BOOL fSinglePhase, 
                                     const XACTUOW *puow);
    HRESULT         Recover();
    HRESULT	        CommitRestore(void);
    void	        CommitRestore0(void);
    void            CommitRestore1(HRESULT hr);
	void			CommitRestore2(HRESULT hr);
    void             CommitRestore3();
	HRESULT			AbortRestore();
	void			AbortRestore1(HRESULT hr);
    void             AbortRestore2();
    void             AbortRequest3();

    // asynchronous completion routines
	void			PrepareRequest0(HRESULT  hr);
    void            PrepareRequest2(HRESULT hr);
    void            PrepareRequest1(HRESULT hr);
	void			DirtyFailPrepare2();

	void			JumpStartCommitRequest();
    void            CommitRequest0();
    void            CommitRequest1(HRESULT hr);
    void            CommitRequest2();
    void            CommitRequest3();
    void            FinishCommitRequest3();
	void			CommitRequest4(HRESULT hr);

	void			AbortRequest1();
	void			AbortRequest2();
 
	void            Continuation(HRESULT hr);
    void            LogFlushed(TXFLUSHCONTEXT tcContext, HRESULT hr);
    

    // Persistency
    BOOL            Save(HANDLE hFile);
    BOOL            Load(HANDLE hFile);
    
    //
    // Auxiliary methods
    //
    TXSTATE         GetState(void) const;           // gets transaction state
    ULONG           GetFlags(void) const;           // gets transaction flags
    void            SetFlags(ULONG ulFlags);        // sets transaction flags
    void            SetState(TXSTATE state);        // sets transaction state
    void            LogFlags();                     // logs transaction flags


    BOOL            SinglePhase(void) const;        // gets SinglePhase status
    void            SetSinglePhase();               // sets SinglePhase status

	BOOL            SingleMessage(void) const;      // gets SingleMessage status
    void            SetSingleMessage();             // sets SingleMessage status

    BOOL            Internal(void) const;           // gets Internal status
    void            SetInternal();                  // sets Internal status

    const XACTUOW*  GetUow() const;                 // gets UOW pointer

    ULONG           GetIndex(void) const;           // gets discriminative index 

                                                    // Sets the Enlist ponter
    void            SetEnlist(ITransactionEnlistmentAsync *pEnlist);
                                                    // Sets the Cookie
    void            SetCookie(DWORD cbCookie, unsigned char *pbCookie);

    ULONG           GetSeqNumber() const;           // Provides the Prepare seq.number

    void            SetUow(const XACTUOW *pUOW);    // sets UOW value

 	void            SetDoneHr(HRESULT hr);             // sets result of async completion
    void			SignalDone(HRESULT hr);				// Report async completion

	void            SetTransQueue(HANDLE hQueue);
	BOOL			ValidTransQueue();
	BOOL			IsComplete();
    void            GetInformation();

	//
	// Driver interface functions
	//
	void			ACAbort1(ContinueFunction cf);
	void			ACAbort2(ContinueFunction cf);
	HRESULT			ACPrepare(ContinueFunction cf);
	HRESULT			ACPrepareDefaultCommit(ContinueFunction cf);
	HRESULT			ACCommit1(ContinueFunction cf);
	void			ACCommit2(ContinueFunction cf);
	void			ACCommit3(ContinueFunction cf);

	bool			IsReadyForCheckpoint(void) const;
	void			SetReadyForCheckpoint(void);
 
private:

    void            GetPrepareInfoAndLog(void);     // sets prepare info members
    void            AssignSeqNumber();              // Assigns sequential number for the prepared transaction

    // AC driver transaction queue operations
    HRESULT         CreateTransQueue(void);       // persistent queue control
    HRESULT         OpenTransQueue(void);
    void            CloseTransQueue(void);

    void			DirtyFailPrepare();
    void			CleanFailPrepare();
	void			LogGenericInfo();

    void StartPrepareRequest(BOOL fSinglePhase);
    void StartCommitRequest();
    void StartAbortRequest();

    void WINAPI DoAbort1  ();
    void WINAPI DoAbort2  ();
    void WINAPI DoCommit2();
    void WINAPI DoCommit3();

    static void WINAPI TimeToRetryAbort1(CTimer* pTimer);
    static void WINAPI TimeToRetryAbort2(CTimer* pTimer);
    static void WINAPI TimeToRetrySortedCommit(CTimer* pTimer);
    static void WINAPI TimeToRetryCommit2(CTimer* pTimer);
    static void WINAPI TimeToRetryCommit3(CTimer* pTimer);
    static void WINAPI TimeToRetryCommitLogging(CTimer* pTimer);
    static void WINAPI TimeToRetryCommitRequest4(CTimer* pTimer);

	static VOID WINAPI HandleTransaction(EXOVERLAPPED* pov);

    // Data
    //
private:

    LONG              m_cRefs;          // IUnknown reference count - for self-destruction
    XACTION_ENTRY     m_Entry;          // Transaction Entry: all transaction's persistent data
    HANDLE            m_hTransQueue;    // Transaction queue handle
    CResourceManager *m_pRM;            // Back pointer to the parent RM object

    R<ITransactionEnlistmentAsync> m_pEnlist; // Pointer to an MS DTC enlistment object
                                             //  with methods [Prepare/Commit/Abort]RequestDone

    DWORD             m_cbCookie;       // Cookie for enlistment
    AP<unsigned char> m_pbCookie;

	ContinueFunction  m_funCont;

    CHandle           m_hDoneEvent;
    bool			  m_fDoneHrIsValid;
    HRESULT           m_DoneHr;

    CACXactInformation m_info;

	//
	// Driver transaction request
	//
    EXOVERLAPPED m_qmov;

	//
	// Timers for retry of routines that should always succeed before continuation
	//
    CTimer  m_RetryAbort1Timer;
    CTimer  m_RetryAbort2Timer;
    CTimer  m_RetrySortedCommitTimer;
    CTimer  m_RetryCommit2Timer;
    CTimer  m_RetryCommit3Timer;
    CTimer  m_RetryCommitLoggingTimer;

	bool m_fReadyForCheckpoint;		// Should the transaction be written to checkpoint?

};


//---------------------------------------------------------------------
// CTransaction::ValidTransQueue
//---------------------------------------------------------------------
inline BOOL CTransaction::ValidTransQueue()
{
	return(m_hTransQueue != INVALID_HANDLE_VALUE);
}

//---------------------------------------------------------------------
// CTransaction::SetTransQueue
//---------------------------------------------------------------------
inline void CTransaction::SetTransQueue(HANDLE hQueue)
{
    m_hTransQueue = hQueue;
}


//---------------------------------------------------------------------
// CTransaction::SetDoneHr
//---------------------------------------------------------------------
inline void CTransaction::SetDoneHr(HRESULT hr)
{
    m_DoneHr = hr;
}

//---------------------------------------------------------------------
// CTransaction::SignalDone
//---------------------------------------------------------------------
inline void CTransaction::SignalDone(HRESULT hr)
{
	m_DoneHr = hr;
	m_fDoneHrIsValid = true;

	//
	// We don't care if SetEvent fails (e.g. low resources) since anyone waiting on the event will
	// timeout and then check the m_fDoneHrIsValid flag.
	//
	ASSERT(m_hDoneEvent != NULL);
	SetEvent(m_hDoneEvent);
}

// trans queue creation
extern HRESULT XactCreateQueue(HANDLE *phTransQueue, const XACTUOW *puow );


//---------------------------------------------------------------------
// CTransaction::GetUow
//---------------------------------------------------------------------
inline const XACTUOW* CTransaction::GetUow() const
{
    return &m_Entry.m_uow;
}

//---------------------------------------------------------------------
// CTransaction::GetIndex
//---------------------------------------------------------------------
inline ULONG CTransaction::GetIndex(void) const
{
    return m_Entry.m_ulIndex;
}

//---------------------------------------------------------------------
// CTransaction::GetState
//---------------------------------------------------------------------
inline TXSTATE CTransaction::GetState(void) const
{
    return (TXSTATE)(m_Entry.m_ulFlags & XACTION_MASK_STATE);
}

//---------------------------------------------------------------------
// CTransaction::GetFlags
//---------------------------------------------------------------------
inline ULONG CTransaction::GetFlags(void) const
{
    return m_Entry.m_ulFlags;
}

//---------------------------------------------------------------------
// CTransaction::SetFlags
//---------------------------------------------------------------------
inline void CTransaction::SetFlags(ULONG ulFlags)
{
    m_Entry.m_ulFlags = ulFlags;
}

//---------------------------------------------------------------------
// CTransaction::IsReadyForCheckpoint
//---------------------------------------------------------------------
inline bool CTransaction::IsReadyForCheckpoint(void) const
{
    return m_fReadyForCheckpoint;
}

//---------------------------------------------------------------------
// CTransaction::SetReadyForCheckpoint
//---------------------------------------------------------------------
inline void CTransaction::SetReadyForCheckpoint(void)
{
    m_fReadyForCheckpoint = true;
}

extern void QMPreInitXact();

#endif __XACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactin.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactIn.cpp

Abstract:
    Incoming Sequences objects implementation

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactStyl.h"
#include "QmThrd.h"
#include "acapi.h"
#include "qmpkt.h"
#include "qmutil.h"
#include "qformat.h"
#include "cqmgr.h"
#include "privque.h"
#include "xactstyl.h"
#include "xactping.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactin.h"
#include "xactlog.h"
#include "fntoken.h"
#include "mqformat.h"
#include "uniansi.h"
#include "mqstl.h"
#include "mp.h"
#include "fn.h"
#include <autohandle.h>
#include "qmacapi.h"

#include "xactin.tmh"

VOID
ExPostRequestMustSucceeded(
    EXOVERLAPPED* pov
    );


#define INSEQS_SIGNATURE         0x1234
const GUID xSrmpKeyGuidFlag = {0xd6f92979,0x16af,0x4d87,0xb3,0x57,0x62,0x3e,0xae,0xd6,0x3e,0x7f};
const char xXactIn[] = "XactIn"; 


// Default value for the order ack delay
DWORD CInSeqHash::m_dwIdleAckDelay = MSMQ_DEFAULT_IDLE_ACK_DELAY;
DWORD CInSeqHash::m_dwMaxAckDelay  = FALCON_MAX_SEQ_ACK_DELAY;

static WCHAR *s_FN=L"xactin";

//
// Time to wait (in milliseconds) before retry of a failed operation.
//
const int xRetryFailureTimeout = 1000;

static XactDirectType GetDirectType(const QUEUE_FORMAT *pqf)
{
	if(FnIsDirectHttpFormatName(pqf))
	{
		return dtxHttpDirectFlag;	
	}
	if(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
	{
		return dtxDirectFlag;		
	}
	return 	dtxNoDirectFlag;
}

static R<CWcsRef> SafeGetStreamId(const CQmPacket& Pkt)
{
	if(!Pkt.IsEodIncluded())
		return R<CWcsRef>(NULL);

	const WCHAR* pStreamId = reinterpret_cast<const WCHAR*>(Pkt.GetPointerToEodStreamId());
	ASSERT(pStreamId != NULL);
	ASSERT(ISALIGN2_PTR(pStreamId));
	ASSERT(Pkt.GetEodStreamIdSizeInBytes() == (wcslen(pStreamId) + 1)*sizeof(WCHAR));

	return 	R<CWcsRef>(new CWcsRef(pStreamId));
}


static R<CWcsRef> SafeGetOrderQueue(const CQmPacket& Pkt)
{
	if(!Pkt.IsEodIncluded())
		return R<CWcsRef>(NULL);

	if(Pkt.GetEodOrderQueueSizeInBytes() == 0)
		return R<CWcsRef>(NULL);

	const WCHAR* pOrderQueue = reinterpret_cast<const WCHAR*>(Pkt.GetPointerToEodOrderQueue());
	ASSERT(pOrderQueue != NULL);
	ASSERT(ISALIGN2_PTR(pOrderQueue));
	ASSERT(Pkt.GetEodOrderQueueSizeInBytes() == (wcslen(pOrderQueue) + 1)*sizeof(WCHAR));

	return 	R<CWcsRef>(new CWcsRef(pOrderQueue));
}





//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------
CInSeqHash *g_pInSeqHash = NULL;

//--------------------------------------
//
// Class  CKeyInSeq
//
//--------------------------------------
CKeyInSeq::CKeyInSeq(const GUID *pGuid,
                     QUEUE_FORMAT *pqf,
					 const R<CWcsRef>& StreamId)
{
    CopyMemory(&m_Guid, pGuid, sizeof(GUID));
    CopyQueueFormat(m_QueueFormat, *pqf);
	m_StreamId = StreamId;
}


CKeyInSeq::CKeyInSeq()
{
    ZeroMemory(&m_Guid, sizeof(GUID));
    m_QueueFormat.UnknownID(NULL);
}




CKeyInSeq::~CKeyInSeq()
{
    m_QueueFormat.DisposeString();
}


const GUID  *CKeyInSeq::GetQMID()  const
{
    return &m_Guid;
}


const QUEUE_FORMAT  *CKeyInSeq::GetQueueFormat() const
{
    return &m_QueueFormat;
}


const WCHAR* CKeyInSeq::GetStreamId() const 
{
	if(m_StreamId.get() == NULL)
		return NULL;

	ASSERT(m_StreamId->getstr() != NULL);
	return m_StreamId->getstr();
}


R<CWcsRef> CKeyInSeq::GetRefStreamId() const
{
	return m_StreamId;
}


static BOOL SaveQueueFormat(const QUEUE_FORMAT& qf, HANDLE hFile)
{
	PERSIST_DATA;
	SAVE_FIELD(qf);
    if (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        LPCWSTR pw = qf.DirectID();
        ULONG  ul = (wcslen(pw) + 1) * sizeof(WCHAR);

        SAVE_FIELD(ul);
        SAVE_DATA(pw, ul);
    }
	return TRUE;
}



BOOL CKeyInSeq::SaveSrmp(HANDLE hFile)
{
	//
	// Any field saved here should be checked that it is not changed by another thread while in this routine,
	// or verify that it does not make any harm.
	//

	PERSIST_DATA;
	SAVE_FIELD(xSrmpKeyGuidFlag);
	if (!SaveQueueFormat(m_QueueFormat, hFile))
        return FALSE;

	ASSERT(m_StreamId->getstr() != NULL);
	ULONG  ul = (wcslen(m_StreamId->getstr()) + 1) * sizeof(WCHAR);
	ASSERT(ul > sizeof(WCHAR));
	SAVE_FIELD(ul);
    SAVE_DATA(m_StreamId->getstr(), ul);
	return TRUE;
}




BOOL CKeyInSeq::SaveNonSrmp(HANDLE hFile)
{
	//
	// Any field saved here should be checked that it is not changed by another thread while in this routine,
	// or verify that it does not make any harm.
	//

	PERSIST_DATA;
	SAVE_FIELD(m_Guid);
	return SaveQueueFormat(m_QueueFormat, hFile);
}


BOOL CKeyInSeq::Save(HANDLE hFile)
{
    if(m_StreamId.get() != NULL)
	{
		return SaveSrmp(hFile);
	}
	return SaveNonSrmp(hFile);
	
}

BOOL CKeyInSeq::LoadSrmpStream(HANDLE hFile)
{
	PERSIST_DATA;
	ULONG ul;
    LOAD_FIELD(ul);
	ASSERT(ul > sizeof(WCHAR));

    AP<WCHAR> pw;
    LOAD_ALLOCATE_DATA(pw,ul,PWCHAR);
	m_StreamId = R<CWcsRef>(new CWcsRef(pw, 0));
	pw.detach();
	ASSERT(ul > sizeof(WCHAR));

	return TRUE;
}

BOOL CKeyInSeq::LoadSrmp(HANDLE hFile)
{
	if(!LoadQueueFormat(hFile))
		return FALSE;


	LoadSrmpStream(hFile);
	return TRUE;
}



static bool IsValidKeyQueueFormatType(QUEUE_FORMAT_TYPE QueueType)
{
	if(QueueType !=  QUEUE_FORMAT_TYPE_DIRECT  && 
	   QueueType !=  QUEUE_FORMAT_TYPE_PRIVATE &&
	   QueueType !=  QUEUE_FORMAT_TYPE_PUBLIC)
	{
		return false;
	}

	return true;
}



BOOL CKeyInSeq::LoadQueueFormat(HANDLE hFile)
{
	PERSIST_DATA;
	LOAD_FIELD(m_QueueFormat);

	if(!IsValidKeyQueueFormatType(m_QueueFormat.GetType()))
	{
		TrERROR(XACT_GENERAL, "invalid queue format type %d found in check point file", m_QueueFormat.GetType());
		return FALSE;
	}

    if (m_QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        ULONG ul;
        LOAD_FIELD(ul);

        AP<WCHAR> pw;
        LOAD_ALLOCATE_DATA(pw,ul,PWCHAR);

        m_QueueFormat.DirectID(pw);
		pw.detach();
    }
	return TRUE;

}


BOOL CKeyInSeq::LoadNonSrmp(HANDLE hFile)
{
	return LoadQueueFormat(hFile);
}



BOOL CKeyInSeq::Load(HANDLE hFile)
{
    PERSIST_DATA;
    LOAD_FIELD(m_Guid);
	if(m_Guid ==  xSrmpKeyGuidFlag)
	{
		return LoadSrmp(hFile);
	}
	return LoadNonSrmp(hFile);
}

/*====================================================
HashGUID::
    Makes ^ of subsequent double words
=====================================================*/
DWORD HashGUID(const GUID &guid)
{
    return((UINT)guid.Data1);
}


/*====================================================
Hash QUEUE_FROMAT to integer
=====================================================*/
static UINT AFXAPI HashFormatName(const QUEUE_FORMAT* qf)
{
	DWORD dw1 = 0;
	DWORD dw2 = 0;

	switch(qf->GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            dw1 = HashGUID(qf->PublicID());
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            dw1 = HashGUID(qf->PrivateID().Lineage);
            dw2 = qf->PrivateID().Uniquifier;
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            dw1 = HashKey(qf->DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            dw1 = HashGUID(qf->MachineID());
            break;
    }
	return dw1 ^ dw2;
}

/*====================================================
Hash srmp key(Streamid, destination queue format)
=====================================================*/
static UINT AFXAPI SrmpHashKey(CKeyInSeq& key)
{
	ASSERT(QUEUE_FORMAT_TYPE_DIRECT == key.GetQueueFormat()->GetType());
	DWORD dw1 = key.GetQueueFormat()->GetType();		
	DWORD dw2 = HashFormatName(key.GetQueueFormat());
	DWORD dw3 = HashKey(key.GetStreamId());

	return dw1 ^ dw2 ^ dw3;
}

/*====================================================
Hash non srmp key(guid, destination queue format)
=====================================================*/
static UINT AFXAPI NonSrmpHashKey(CKeyInSeq& key)
{
    DWORD dw1 = HashGUID(*(key.GetQMID()));
    DWORD dw2 = key.GetQueueFormat()->GetType();
    DWORD dw3 = HashFormatName(key.GetQueueFormat());

    return dw1 ^ dw2 ^ dw3;
}



/*====================================================
HashKey for CKeyInSeq
    Makes ^ of subsequent double words
=====================================================*/
template<>
UINT AFXAPI HashKey(CKeyInSeq& key)
{
	if(key.GetStreamId() != NULL)
	{
		return SrmpHashKey(key);
	}
	return NonSrmpHashKey(key);
}


/*====================================================
operator== for CKeyInSeq
=====================================================*/
BOOL operator==(const CKeyInSeq  &key1, const CKeyInSeq &key2)
{
	if(key1.GetStreamId() == NULL &&  key2.GetStreamId() == NULL)
	{
		return ((*key1.GetQMID()        == *key2.GetQMID()) &&
                (*key1.GetQueueFormat() == *key2.GetQueueFormat()));
	}

	if(key1.GetStreamId() == NULL && key2.GetStreamId() != NULL)
		return FALSE;


	if(key2.GetStreamId() == NULL && key1.GetStreamId() != NULL)
		return FALSE;

	return (wcscmp(key1.GetStreamId(), key2.GetStreamId()) == 0 &&
		    *key1.GetQueueFormat() == *key2.GetQueueFormat());
}

/*====================================================												
operator= for CKeyInSeq
    Reallocates direct id string
=====================================================*/
CKeyInSeq &CKeyInSeq::operator=(const CKeyInSeq &key2 )
{
	m_StreamId = key2.m_StreamId;
    m_Guid = key2.m_Guid;
    CopyQueueFormat(m_QueueFormat, key2.m_QueueFormat);
	return *this;
}


//
// ------------------------ class CInSeqPacketEntry ----------------------
//
CInSeqPacketEntry::CInSeqPacketEntry()
	:
		m_fPutPacket1Issued(false),
		m_fPutPacket1Done(false),
		m_fLogIssued(false),
		m_fMarkedForDelete(false),
		m_pBasicHeader(NULL),
		m_pDriverPacket(NULL),
		m_hQueue(NULL),
		m_SeqID(0),
		m_SeqN(0),
		m_fOrderQueueUpdated(false)
{
}

CInSeqPacketEntry::CInSeqPacketEntry(
	CQmPacket *pPkt,
	HANDLE hQueue
	)
	:
		m_fPutPacket1Issued(false),
		m_fPutPacket1Done(false),
		m_fLogIssued(false),
		m_fMarkedForDelete(false),
		m_pBasicHeader(pPkt->GetPointerToPacket()), 									
		m_pDriverPacket(pPkt->GetPointerToDriverPacket()),
		m_hQueue(hQueue),
		m_SeqID(pPkt->GetSeqID()),
		m_SeqN(pPkt->GetSeqN())
{
	m_fOrderQueueUpdated = pPkt->IsEodIncluded() && pPkt->GetEodOrderQueueSizeInBytes() != 0;
}


CInSeqLogContext::CInSeqLogContext(
	CInSequence *inseq,
	LONGLONG seqID,
    ULONG seqN
	)
	:
	m_inseq(SafeAddRef(inseq)),
	m_SeqID(seqID),
	m_SeqN(seqN)
{
}


VOID CInSeqLogContext::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
    TrTRACE(XACT_LOG, "CInSeqLogContext::AppendCallback : lrp=%I64x, hr=%x", lrpAppendLRP.QuadPart, hr);

	//
	// EVALUATE_OR_INJECT_FAILURE used to simulate asynchronous failures in logger.
	// Tests logger retry.
	//
	hr = EVALUATE_OR_INJECT_FAILURE2(hr, 1);
	
	m_inseq->AsyncLogDone(this, hr);
}


//---------------------------------------------------------
//
//  class CInSequence
//
//---------------------------------------------------------


#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CInSequence::CInSequence
    Constructs In Sequence
=====================================================*/
CInSequence::CInSequence(const CKeyInSeq &key,
                         const LONGLONG liSeqID,
                         const ULONG ulSeqN,
                         XactDirectType  DirectType,
                         const GUID  *pgTaSrcQm,
						 const R<CWcsRef>&  HttpOrderAckQueue) :
    m_fSendOrderAckScheduled(FALSE),
    m_SendOrderAckTimer(TimeToSendOrderAck),
	m_HttpOrderAckQueue(HttpOrderAckQueue),
	m_fDeletePending(0),
    m_DeleteEntries_ov(OverlappedDeleteEntries, OverlappedDeleteEntries),
	m_fLogPending(0),
    m_LogSequenceTimer(TimeToLogSequence),
	m_fUnfreezePending(0),
    m_UnfreezeEntries_ov(OverlappedUnfreezeEntries, OverlappedUnfreezeEntries)
{
    m_SeqIDVerify   = liSeqID;
    m_SeqNVerify    = ulSeqN;
    m_SeqIDLogged	= 0;
    m_SeqNLogged	= 0;
    m_DirectType    = DirectType;
    m_key           = key;

    if (DirectType == dtxDirectFlag)
    {
        CopyMemory(&m_gDestQmOrTaSrcQm, pgTaSrcQm, sizeof(GUID));
    }

    time(&m_timeLastAccess);
    time(&m_timeLastAck);

    m_AdminRejectCount = 0;
}



/*====================================================
CInSequence::CInSequence
    Empty Constructor with a key
=====================================================*/
CInSequence::CInSequence(const CKeyInSeq &key)
  : m_fSendOrderAckScheduled(FALSE),
    m_SendOrderAckTimer(TimeToSendOrderAck),
    m_fDeletePending(0),
    m_DeleteEntries_ov(OverlappedDeleteEntries, OverlappedDeleteEntries),
	m_fLogPending(0),
    m_LogSequenceTimer(TimeToLogSequence),
	m_fUnfreezePending(0),
    m_UnfreezeEntries_ov(OverlappedUnfreezeEntries, OverlappedUnfreezeEntries)
{
    m_SeqIDVerify   = 0;
    m_SeqNVerify 	= 0;
    m_SeqIDLogged	= 0;
    m_SeqNLogged	= 0;
    time(&m_timeLastAccess);
    m_timeLastAck   = 0;
    m_DirectType    = dtxNoDirectFlag;
    m_key           = key;
	m_AdminRejectCount = 0;
}
#pragma warning(default: 4355)  // 'this' : used in base member initializer list

/*====================================================
CInSequence::~CInSequence
    Destructs In Sequence
=====================================================*/
CInSequence::~CInSequence()
{
}


void CInSequence::UpdateOrderQueueAndDstQueue(const GUID  *pgTaSrcQm, R<CWcsRef> OrderAckQueue)	
{
    if (m_DirectType == dtxDirectFlag)
    {
		//
	    // Renew the source TA_ADDRESS (it could change from previous message)
		//
		// This call changes persisted data while the structure might be in the process of saving to disk.
		// But we don't care in this case. ...review relevant?
		//
        SetSourceQM(pgTaSrcQm);   // DestID union keeps the source QM TA_Address
		return;
    }

	//
	//On http - Renew order queue if we have new one on the packet
	//

	if(m_DirectType !=  dtxHttpDirectFlag)
		return;

  	if (OrderAckQueue.get() == NULL)
  		return;
  	
	RenewHttpOrderAckQueue(OrderAckQueue);
}

bool CInSequence::VerifyAndPrepare(CQmPacket *pPkt, HANDLE hQueue)
{
	if(!Verify(pPkt))
		return false;

	Prepare(pPkt, hQueue);

	//
	// The thrown exception here simulates synchronous failure of ACPutPacket1.
	//
	PROBABILITY_THROW_EXCEPTION(100, L"To simulate synchronous failure of ACPutPacket1.");
	
	return true;
}

bool CInSequence::Verify(CQmPacket* pPkt)
/*++

Routine Description:
	Verifies that packet is in correct order in the sequence.
	
--*/
{
#ifdef _DEBUG
	QUEUE_FORMAT qf;
    pPkt->GetDestinationQueue(&qf);

	ASSERT(("Stream with mixed format-name types.", GetDirectType(&qf) == m_DirectType));
#endif

    //
    // Plan sending order ack (delayed properly)
    // we should send it even after reject, otherwise lost ack will
    //  cause a problem.
    //
    PlanOrderAck();
    
    SetLastAccessed();
    
    ULONG SeqN = pPkt->GetSeqN();
    ULONG PrevSeqN = pPkt->GetPrevSeqN();
    LONGLONG SeqID = pPkt->GetSeqID();
	
    CS lock(m_critInSeq);

	//
	// Packet is in place if it is either the 
	// next packet in the existing stream id or 
	// the first packet of a new stream id.
	//
    bool fPacketVerified = 
    	(SeqID == m_SeqIDVerify && 
    	 SeqN > m_SeqNVerify && 
    	 PrevSeqN <= m_SeqNVerify) || 
		(SeqID > m_SeqIDVerify && PrevSeqN == 0);

	if(!fPacketVerified)
	{
		//
	    // Update reject statistics
	    //
		m_AdminRejectCount++;

	    TrWARNING(XACT_RCV, "Exactly1 receive: Verify packet: SeqID=%x / %x, SeqN=%d, Prev=%d. %ls", HighSeqID(SeqID), LowSeqID(SeqID), SeqN, PrevSeqN, _TEXT("REJECT"));

		return false;
	}

	//
	// Warn if number of entries handled is larger than 10000.
	//
	ASSERT_BENIGN(("Too many entries in insequence object!", m_PacketEntryList.GetCount() < m_xMaxEntriesAllowed));
		
    TrTRACE(XACT_RCV, "Exactly1 receive: Verify packet: SeqID=%x / %x, SeqN=%d, Prev=%d. %ls", HighSeqID(SeqID), LowSeqID(SeqID), SeqN, PrevSeqN, _TEXT("PASS"));

    return true;
}

void CInSequence::CleanupUnissuedEntries()
/*++

Routine Description:
	If an unused entry is found at the end of the list it is removed.
	It may be found there if the previous call to VerifyAndPrepare() was not followed 
	by a call to Advance() because of any kind of failures.
	
--*/
{
    CS lock(m_critInSeq);

	if(m_PacketEntryList.GetCount() == 0)
		return;
	
	CInSeqPacketEntry* entry = m_PacketEntryList.GetTail();

	if(entry->m_fPutPacket1Issued)
		return;

	m_PacketEntryList.RemoveTail();
	delete entry;
}

void CInSequence::Prepare(CQmPacket *pPkt, HANDLE hQueue)
/*++

Routine Description:
	Creates the list-entry that will be used to keep this packet in its 
	correct order.
	
--*/
{
	UpdateOrderQueueAndDstQueue(pPkt->GetDstQMGuid(), SafeGetOrderQueue(*pPkt));
	
	CleanupUnissuedEntries(); 
	
	P<CInSeqPacketEntry> entry = new CInSeqPacketEntry(
										pPkt, 
										hQueue
										);
	
    CS lock(m_critInSeq);

	CInSeqPacketEntry* pentry = entry.get();
	m_PacketEntryList.AddTail(pentry);
	entry.detach();

    TrTRACE(XACT_RCV, "Exactly1 receive: Prepared entry for: SeqID=%x / %x, SeqN=%d, Prev=%d. Handling %d entries.", HighSeqID(pPkt->GetSeqID()), LowSeqID(pPkt->GetSeqID()),  pPkt->GetSeqN(), pPkt->GetPrevSeqN(), m_PacketEntryList.GetCount());
}

/*====================================================
CInSequence::CancelSendOrderAckTimer
    Cancel the timer and release object if needed
=====================================================*/
void CInSequence::CancelSendOrderAckTimer(void)
{
	CS lock(m_critInSeq);

    if (m_fSendOrderAckScheduled)
    {
        if (ExCancelTimer(&m_SendOrderAckTimer))
		{
            m_fSendOrderAckScheduled = FALSE;
			Release();
		}
    }

}

bool CInSequence::IsInactive() const
/*++

Routine Description:
	Returns true if no packets belonging to this sequence are currently 
	being processed.
	
--*/
{
	return m_SeqIDVerify == m_SeqIDLogged && m_SeqNVerify == m_SeqNLogged;
}


/*====================================================
CInSequence::SeqIDLogged
    Get for Sequence ID registered
=====================================================*/
LONGLONG CInSequence::SeqIDLogged() const
{
    return m_SeqIDLogged;
}


/*====================================================
CInSequence::SeqNLogged
    Get for last registered seq number
=====================================================*/
ULONG  CInSequence::SeqNLogged() const
{
    return m_SeqNLogged;
}

/*====================================================
CInSequence::LastAccessed
Get for time of last activuty: last msg verified, maybe rejected
=====================================================*/
time_t CInSequence::LastAccessed() const
{
    return m_timeLastAccess;
}


/*====================================================
CInSequence::DirectType
Get DirectType
=====================================================*/
XactDirectType CInSequence::DirectType() const
{
    return m_DirectType;
}

/*====================================================
CInSequence::SetSourceQM
Set for SourceQM TA_Address (or Destination QM Guid)
=====================================================*/
void CInSequence::SetSourceQM(const GUID  *pgTaSrcQm)
{
	CS lock(m_critInSeq);
    CopyMemory(&m_gDestQmOrTaSrcQm, pgTaSrcQm, sizeof(GUID));
}

/*====================================================
CInSequence::RenewHttpOrderAckQueue
Renew http order queue 
=====================================================*/
void  CInSequence::RenewHttpOrderAckQueue(const R<CWcsRef>& OrderAckQueue)
{
	CS lock(m_critInSeq);
	m_HttpOrderAckQueue = OrderAckQueue;	
}

R<CWcsRef> CInSequence::GetHttpOrderAckQueue()
{
	CS lock(m_critInSeq);
	return m_HttpOrderAckQueue;	
}


/*====================================================
CInSequence::TimeToSendOrderAck
    Sends adequate Seq Ack
=====================================================*/
void WINAPI CInSequence::TimeToSendOrderAck(CTimer* pTimer)
{
    //
	// will do Release when finished
	//
	R<CInSequence> pInSeq = CONTAINING_RECORD(pTimer, CInSequence, m_SendOrderAckTimer);

    pInSeq->SendAdequateOrderAck();
}


static
HRESULT
SendSrmpXactAck(
		OBJECTID   *pMessageId,
        const WCHAR* pHttpOrderAckQueue,
		const WCHAR* pStreamId,
		USHORT     usClass,
		USHORT     usPriority,
		LONGLONG   liSeqID,
		ULONG      ulSeqN,
		const QUEUE_FORMAT *pqdDestQueue
		)
{
	ASSERT(pStreamId != NULL);
	ASSERT(pHttpOrderAckQueue != NULL);


	TrTRACE(XACT_RCV, "Exactly1 receive: Sending status ack: Class=%x, SeqID=%x / %x, SeqN=%d .", usClass, HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN);

    //
    // Create Message property on stack
    // with the correlation holding the original packet ID
    //
    CMessageProperty MsgProperty(
							usClass,
							(PUCHAR) pMessageId,
							usPriority,
							MQMSG_DELIVERY_EXPRESS
							);

    MsgProperty.dwTitleSize     = STRLEN(ORDER_ACK_TITLE) +1 ;
    MsgProperty.pTitle          = ORDER_ACK_TITLE;
    MsgProperty.bDefProv        = TRUE;
	MsgProperty.pEodAckStreamId = (UCHAR*)pStreamId;
	MsgProperty.EodAckStreamIdSizeInBytes = (wcslen(pStreamId) + 1) * sizeof(WCHAR);
	MsgProperty.EodAckSeqId  = liSeqID;
	MsgProperty.EodAckSeqNum =	ulSeqN;

	QUEUE_FORMAT XactQueue;
	XactQueue.DirectID(const_cast<WCHAR*>(pHttpOrderAckQueue));
	HRESULT hr = QmpSendPacket(&MsgProperty,&XactQueue, NULL, pqdDestQueue);
	return LogHR(hr, s_FN, 11);
}


HRESULT 
CInSequence::SendSrmpXactFinalAck(
	const CQmPacket& qmPacket,
	USHORT usClass
	) 
{
	ASSERT(qmPacket.IsSrmpIncluded());
	
	if ((qmPacket.GetAuditingMode() == MQMSG_JOURNAL_NONE) || 
		!qmPacket.IsSrmpMessageGeneratedByMsmq())
	{
		return MQ_OK;
	}
	
    OBJECTID MessageId;
    qmPacket.GetMessageId(&MessageId);

	HRESULT hr = SendSrmpXactAck(
						&MessageId,
						GetHttpOrderAckQueue()->getstr(),
						m_key.GetStreamId(),
						usClass,
                    	qmPacket.GetPriority(),
                    	qmPacket.GetSeqID(),
                    	qmPacket.GetSeqN(),
                    	m_key.GetQueueFormat()
						);

	return hr;
}


/*====================================================
CInSequence::TimeToSendOrderAck
    Sends adequate Seq Ack
=====================================================*/
void CInSequence::SendAdequateOrderAck()
{
    HRESULT  hr = MQ_ERROR;
    OBJECTID MsgId = {0};
	LONGLONG SeqID;
	ULONG SeqN;

	R<CWcsRef> HttpOrderAckQueue;
	{
		CS lock(m_critInSeq);
		HttpOrderAckQueue = GetHttpOrderAckQueue();
		m_fSendOrderAckScheduled = FALSE;

		SeqN = m_SeqNLogged;
		SeqID = m_SeqIDLogged;
	}

	if (SeqN == 0)
	{
		//
		// The logging didn't complete yet. When the logger completes writting the 
		// sequence the QM reschedules sending of order ack.
		//
		return;
	}
	
    TrTRACE(XACT_RCV,"Exactly1 receive: SendXactAck MQMSG_CLASS_ORDER_ACK:SeqID=%x / %x, SeqN=%d .", HighSeqID(SeqID), LowSeqID(SeqID), SeqN);

	if(m_DirectType == dtxHttpDirectFlag)
	{
		ASSERT(HttpOrderAckQueue.get() != NULL);
		ASSERT(m_key.GetStreamId() != NULL);

		hr = SendSrmpXactAck(
				&MsgId,
				HttpOrderAckQueue->getstr(),
				m_key.GetStreamId(),
				MQMSG_CLASS_ORDER_ACK,
				0,
				SeqID,
				SeqN,
				m_key.GetQueueFormat()
				);
	}
	else
	{

		//  Send SeqAck (non srmp)
		hr = SendXactAck(
					&MsgId,
					m_DirectType == dtxDirectFlag,
					m_key.GetQMID(),
					&m_taSourceQM,
					MQMSG_CLASS_ORDER_ACK,
					0,
					SeqID,
					SeqN,
					SeqN-1,
					m_key.GetQueueFormat());
	}

    if (SUCCEEDED(hr))
    {
		CS lock(m_critInSeq);
		
        time(&m_timeLastAck);
    }
}

/*====================================================
CInSequence::PlanOrderAck
    Plans sending adequate Seq Ack
=====================================================*/
void CInSequence::PlanOrderAck()
{
    CS lock(m_critInSeq);

    // Get current time
    time_t tNow;
    time(&tNow);

    // Plan next order ack for m_dwIdleAckDelay from now,
    //   this saves extra order acking (batches )
    // But do not delay order ack too much,
    //   otherwise sender will switch to resend
    //
    if (m_fSendOrderAckScheduled &&
        tNow - m_timeLastAck < (time_t)CInSeqHash::m_dwMaxAckDelay)
    {
        CancelSendOrderAckTimer();
    }

    if (!m_fSendOrderAckScheduled)
    {
        //
		// addref here to prevent deleting object while timer is running
		// released in cancel timer or in timer callback
		//
		AddRef();
		ExSetTimer(&m_SendOrderAckTimer, CTimeDuration::FromMilliSeconds(CInSeqHash::m_dwIdleAckDelay));
        m_fSendOrderAckScheduled = TRUE;
    }
}


void CInSequence::Advance(CQmPacket * pPkt)
/*++

Routine Description:
	Advances the verify counters. This allows to receives the next packet in order.
	
--*/
{
    CS lock(m_critInSeq);

    m_SeqIDVerify = pPkt->GetSeqID();
    m_SeqNVerify = pPkt->GetSeqN();

    ASSERT(m_PacketEntryList.GetCount() != 0 && !m_PacketEntryList.GetTail()->m_fPutPacket1Issued);

	m_PacketEntryList.GetTail()->m_fPutPacket1Issued = true;    
}


void CInSequence::AdvanceNACK(CQmPacket * pPkt)
/*++

Routine Description:
	Advances the verify counters. This allows to receives the next packet in order.
	This is a special version for nacked messages. We want to advance the counters
	but we have no more intersest in the entry so we remove it.
	A nacked packet is a packet that was thrown away.
	
--*/
{
    CS lock(m_critInSeq);

    m_SeqIDVerify = pPkt->GetSeqID();
    m_SeqNVerify = pPkt->GetSeqN();

    ASSERT(m_PacketEntryList.GetCount() != 0 && !m_PacketEntryList.GetTail()->m_fPutPacket1Issued);

	CInSeqPacketEntry* entry = m_PacketEntryList.GetTail();

	m_PacketEntryList.RemoveTail();
	delete entry;
}


/*====================================================
CInSequence::Advance
    If SeqID changed, sets it and resets counter to 1
=====================================================*/
void CInSequence::AdvanceRecovered(LONGLONG liSeqID, ULONG ulSeqN, const GUID  *pgTaSrcQm, R<CWcsRef> OrderAckQueue)
/*++

Routine Description:
	Advances the verify and accept counters. 
	Function is called at recovery. 
	At recovery there is no need to process the packets so the accept and verify 
	counters are kept equal.
	
--*/
{
    CS lock(m_critInSeq);

    if (liSeqID <  m_SeqIDVerify || (liSeqID == m_SeqIDVerify && ulSeqN  <  m_SeqNVerify))
		return;
    
    m_SeqIDVerify = liSeqID;
    m_SeqIDLogged = liSeqID;
    m_SeqNVerify = ulSeqN;
    m_SeqNLogged = ulSeqN;

	UpdateOrderQueueAndDstQueue(pgTaSrcQm, OrderAckQueue);
}


bool CInSequence::WasPacketLogged(CQmPacket *pPkt)
/*++

Routine Description:
	Used at recovery to decide if a recovered packet was accepted (finished
	the acceptance process) before msmq went down.
	
--*/
{
	return WasLogDone(pPkt->GetSeqID(), pPkt->GetSeqN());
}

bool CInSequence::WasLogDone(LONGLONG SeqID, ULONG SeqN)
{
	CS lock(m_critInSeq);

	if(SeqID < m_SeqIDLogged)
		return true;

	if(SeqID == m_SeqIDLogged && 
		SeqN <= m_SeqNLogged)
		return true;

	return false;
}

void CInSequence::SetLogDone(LONGLONG SeqID, ULONG SeqN)
{
	CS lock(m_critInSeq);

	ASSERT(!WasLogDone(SeqID, SeqN));

	m_SeqIDLogged = SeqID;
	m_SeqNLogged = SeqN;
}

POSITION CInSequence::FindEntry(LONGLONG SeqID, ULONG SeqN)
{
    CS lock(m_critInSeq);

	POSITION rpos = NULL;
	for(POSITION pos = m_PacketEntryList.GetHeadPosition(); pos != NULL;)
	{
		rpos = pos;
		CInSeqPacketEntry* entry = m_PacketEntryList.GetNext(pos);

		//
		// Note: Other entries with same seqid,seqN may be found as marked for delete!
		//
		if(entry->m_SeqID == SeqID && entry->m_SeqN == SeqN)
			return rpos;
	}

	return NULL;
}

POSITION CInSequence::FindPacket(CQmPacket *pPkt)
{
    CS lock(m_critInSeq);

	POSITION rpos = NULL;
	for(POSITION pos = m_PacketEntryList.GetHeadPosition(); pos != NULL;)
	{
		rpos = pos;
		CInSeqPacketEntry* entry = m_PacketEntryList.GetNext(pos);

		if(entry->m_pDriverPacket == pPkt->GetPointerToDriverPacket())
			return rpos;
	}

	return NULL;
}

void CInSequence::CheckFirstEntry()
/*++

Routine Description:
	Decide what to do next by checking the state of the first entry in the list.
	
--*/
{
	CInSeqPacketEntry entry;

	{
    	CS lock(m_critInSeq);

		if(m_PacketEntryList.GetCount() == 0)
			return;

		//
		// Work with copy of entry outside of critical section scope.
		//
    	entry = *m_PacketEntryList.GetHead();
	}

	if(!entry.m_fPutPacket1Done)
	{
		//
		// If first packet did not finish save to disk, there is nothing to be done.
		//
		return;
	}

	if(entry.m_fMarkedForDelete)
	{
		//
		// First packet is ready for delete.
		//
		PostDeleteEntries();
		return;
	}

	if(WasLogDone(entry.m_SeqID, entry.m_SeqN))
	{
		//
		// First packet is ready for unfreeze. Unfreeze some entries.
		//
		PostUnfreezeEntries();
		return;
	}

	if(InterlockedCompareExchange(&m_fLogPending, 1, 0) == 0)
	{
		//
		// First packet just finished save. It is ready for logging. Log some entries
		//
		LogSequence();
		return;
	}
}


void CInSequence::FreePackets(CQmPacket *pPkt)
/*++

Routine Description:
	This routine solved a tricky problem.
	When a packet fails ACPutPacket1 asynchronously, you have to delete all the packets that 
	followed it. Why? because the order of packets in the queue is determined by the order
	of the calls to ACPutPacket1. 
	e.g: 
		1. P1 starts put packet. 
		2. p2 starts put packet.
		3. p1 fails put packet asynchronously.
		4. p2 succeeds.
		5. Resend of p1 (p1r) is accepted.

		result: p2 appears before p1r in the queue.

	This function marks all the packets that need to be deleted. And resets the verify counters
	to accept the resend of all of them.

	It finds the first packet that did not finish put packet and that is not marked already
	for delete and marks it and all the packets following it for delete.
	
--*/
{
	TrWARNING(XACT_RCV, "Exactly1 receive: Packet failed ACPutPacket1 async. Freeing packets: SeqID=%x / %x, SeqN=%d, Prev=%d.", HighSeqID(pPkt->GetSeqID()), LowSeqID(pPkt->GetSeqID()), pPkt->GetSeqN(), pPkt->GetPrevSeqN());
	
	{
	    CS lock(m_critInSeq);

		POSITION FailedPos = FindPacket(pPkt);
		ASSERT(("Excpected to find entry.", FailedPos != NULL));

		CInSeqPacketEntry* pFailedEntry = m_PacketEntryList.GetAt(FailedPos);

		if(!pFailedEntry->m_fMarkedForDelete)			
		{
			//
			// Find the first packet entry that did not finish saving to disk. 
			//
			CInSeqPacketEntry* entry = NULL;
			POSITION pos = m_PacketEntryList.GetHeadPosition();
			
			for(;pos != NULL;)
			{
				entry = m_PacketEntryList.GetNext(pos);
				if(!entry->m_fPutPacket1Done && !entry->m_fMarkedForDelete)
					break;
			}

			ASSERT(("Expected to find entry.", entry != NULL));

			//
			// Reset the verify counters to that entry to enable receiving 
			// the messages resend.
			//
			m_SeqIDVerify = entry->m_SeqID;
			m_SeqNVerify = entry->m_SeqN - 1;

			//
			// Mark for delete all packets entries from that entry up to 
			// the last one.
			//
			entry->m_fMarkedForDelete = true;
			
			for(;pos != NULL;)
			{
				entry = m_PacketEntryList.GetNext(pos);
				entry->m_fMarkedForDelete = true;
			}
		}

		pFailedEntry->m_fPutPacket1Done = true;
	}

	CheckFirstEntry();
}


void CInSequence::PostDeleteEntries()
{
	if(InterlockedCompareExchange(&m_fDeletePending, 1, 0) == 1)
		return;

	AddRef();
	ExPostRequestMustSucceeded(&m_DeleteEntries_ov);
}


void WINAPI CInSequence::OverlappedDeleteEntries(EXOVERLAPPED* ov)
{
	R<CInSequence> pInSeq = CONTAINING_RECORD(ov, CInSequence, m_DeleteEntries_ov);

	pInSeq->DeleteEntries();
}


void CInSequence::DeleteEntries()
/*++

Routine Description:
	Delete packets from head of list until no more packets are found that are ready for delete
	
--*/
{
	try
	{
		for(;;)
		{
			//
			// Interesting crash point. There has been a problem and packets get deleted.
			// Will this problem be handled smoothly on recovery?
			//
			PROBABILITY_CRASH_POINT(1, L"While deleting CInSequence entries.");
			
			CInSeqPacketEntry* entry = NULL;

			{
				CS lock(m_critInSeq);

				//
				// Stop delete loop when the first packet is not ready for delete.
				//
				if(m_PacketEntryList.GetCount() == 0 || 
					!m_PacketEntryList.GetHead()->m_fPutPacket1Done ||
					!m_PacketEntryList.GetHead()->m_fMarkedForDelete)
				{
					//
					// Allow for other threads to issue new Delete requests
					//
					InterlockedExchange(&m_fDeletePending, 0);
					break;
				}

				entry = m_PacketEntryList.GetHead();
			}

			PROBABILITY_THROW_EXCEPTION(1, L"Before freeing a packet by CInSequence.");
			QmAcFreePacket(entry->m_pDriverPacket, 0, eDoNotDeferOnFailure);

			CS lock(m_critInSeq);
			
			m_PacketEntryList.RemoveHead();
			delete entry;
		}

		CheckFirstEntry();
		return;
	}
	catch(const exception&)
	{
		InterlockedExchange(&m_fDeletePending, 0);
	
		Sleep(xRetryFailureTimeout);
		PostDeleteEntries();
		return;
	}
}


void CInSequence::Register(CQmPacket * pPkt)
/*++

Routine Description:
	Packet finished async-put-packet. Mark it and check to see if there is any work to do.
	
--*/
{
	TrTRACE(XACT_RCV, "Exactly1 receive: Packet completed ACPutPacket1 async.: SeqID=%x / %x, SeqN=%d.", HighSeqID(pPkt->GetSeqID()), LowSeqID(pPkt->GetSeqID()), pPkt->GetSeqN());

	{
	    CS lock(m_critInSeq);

		POSITION pos = FindPacket(pPkt);
		ASSERT(("Expected to find entry.", pos != NULL));

		CInSeqPacketEntry* entry = m_PacketEntryList.GetAt(pos);

		entry->m_fPutPacket1Done = true;
	}

	CheckFirstEntry();
}

void CInSequence::ClearLogIssuedFlag(LONGLONG SeqID, ULONG SeqN)
{
    	CS lock(m_critInSeq);
		
		for(POSITION pos = m_PacketEntryList.GetHeadPosition(); pos != NULL;)
		{
			CInSeqPacketEntry* entry = m_PacketEntryList.GetNext(pos);

			if(entry->m_SeqID == SeqID && entry->m_SeqID == SeqN)
			{
				entry->m_fLogIssued = false;
				return;
			}
		}
}

void CInSequence::ScheduleLogSequence(DWORD millisec)
{
	if(InterlockedCompareExchange(&m_fLogPending, 1, 0) == 1)
		return;

	AddRef();
	ExSetTimer(&m_LogSequenceTimer, CTimeDuration::FromMilliSeconds(millisec));
}


void WINAPI CInSequence::TimeToLogSequence(CTimer* pTimer)
{
	R<CInSequence> pInSeq = CONTAINING_RECORD(pTimer, CInSequence, m_LogSequenceTimer);

	pInSeq->LogSequence();
}


void CInSequence::LogSequence()
/*++

Routine Description:
	Log change to CInSequence counters before it happens.
	Sounds strange?

	Finds the latest packet whose counters are valid for logging. It is the last in a series of 
	packets which finished put-packet and were not marked for delete.
	
--*/
{
	//
	// Allow for other threads to issue new log requests
	//
	InterlockedExchange(&m_fLogPending, 0);

	CInSeqPacketEntry EntryToLog;
	bool fLogOrderQueue = false;

    {
    	CS lock(m_critInSeq);
		
		//
		// Find sequence entry to log
		//
		CInSeqPacketEntry* rentry = NULL;
		
		for(POSITION pos = m_PacketEntryList.GetHeadPosition(); pos != NULL;)
		{
			CInSeqPacketEntry* entry = m_PacketEntryList.GetNext(pos);

			if(!entry->m_fPutPacket1Done || entry->m_fMarkedForDelete)
				break;

			//
			// We want to log changes to the order ack queue
			//
			if(entry->m_fOrderQueueUpdated && !WasLogDone(entry->m_SeqID, entry->m_SeqN))
			{
				fLogOrderQueue = true;
			}

			rentry = entry;
		}

		if(rentry == NULL || rentry->m_fLogIssued || WasLogDone(rentry->m_SeqID, rentry->m_SeqN))
		{
			//
			// Log is/was done by another thread.
			//
			return;
		}

		rentry->m_fLogIssued = true;
		
		//
		// Work with copy of entry, since entry might be removed by different thread.
		//
		EntryToLog = *rentry;
    }

	//
	// moderatly interesting crash point. 
	// crash happens between packet save and sequence log.
	// Will this be handled smoothly on recovery?
	//
	PROBABILITY_CRASH_POINT(100, L"Before logging CInSequence change.");
	
	try
	{
		Log(&EntryToLog, fLogOrderQueue);
	}
	catch(const exception&)
	{
		ClearLogIssuedFlag(EntryToLog.m_SeqID, EntryToLog.m_SeqN);
		ScheduleLogSequence(xRetryFailureTimeout);
	}
}

void CInSequence::Log(CInSeqPacketEntry* entry, bool fLogOrderQueue)
{
	TrTRACE(XACT_RCV,"Exactly1 receive: Logging ISSUED:SeqID=%x / %x, SeqN=%d. orderQueue = %ls", HighSeqID(entry->m_SeqID), LowSeqID(entry->m_SeqID), entry->m_SeqN, (fLogOrderQueue ? m_HttpOrderAckQueue->getstr() : L"NULL"));
	
    ASSERT(entry->m_SeqID > 0);
    CRASH_POINT(101);

	P<CInSeqLogContext> context = new CInSeqLogContext(this, entry->m_SeqID, entry->m_SeqN);
    time_t timeCur;
    time(&timeCur);

	if(dtxHttpDirectFlag == m_DirectType)
	{		
		CInSeqRecordSrmp logRec(
			m_key.GetQueueFormat()->DirectID(),
			m_key.GetRefStreamId(),
			entry->m_SeqID,
			entry->m_SeqN,
			timeCur,
			(fLogOrderQueue ? m_HttpOrderAckQueue : NULL)
			);

		// Log down the newcomer
		g_Logger.LogInSeqRecSrmp(
			 FALSE,                         // flush hint
			 context.get(),                       // notification element
			 &logRec);                      // log data

		context.detach();
		return;
	}

    // Log record with all relevant data
    CInSeqRecord logRec(
        m_key.GetQMID(),
        m_key.GetQueueFormat(),
        entry->m_SeqID,
        entry->m_SeqN,
        timeCur,
        &m_gDestQmOrTaSrcQm
	    );

    // Log down the newcomer
    g_Logger.LogInSeqRec(
             FALSE,                         // flush hint
             context.get(),                       // notification element
             &logRec);                      // log data

	context.detach();
}


void CInSequence::AsyncLogDone(CInSeqLogContext *context, HRESULT hr)
/*++

Routine Description:
	Mark all logged packets as logged.
		
--*/
{	
	P<CInSeqLogContext> AutoContext = context;
	
	if(FAILED(hr))
	{
		TrWARNING(XACT_RCV,"Exactly1 receive: Logging FAILED:SeqID=%x / %x, SeqN=%d .", HighSeqID(context->m_SeqID), LowSeqID(context->m_SeqID), context->m_SeqN);
		
		ClearLogIssuedFlag(context->m_SeqID, context->m_SeqN);
		ScheduleLogSequence(xRetryFailureTimeout);
		return;
	}

	{
		CS lock(m_critInSeq);

		if(WasLogDone(context->m_SeqID, context->m_SeqN))
		{
			//
			// No new packets to unfreeze.
			//
			return;
		}

		TrTRACE(XACT_RCV,"Exactly1 receive: Logging DONE, Setting counters, planning ack.:SeqID=%x / %x, SeqN=%d .", HighSeqID(context->m_SeqID), LowSeqID(context->m_SeqID), context->m_SeqN);

		SetLogDone(context->m_SeqID, context->m_SeqN);
		PlanOrderAck();
	}

	PostUnfreezeEntries();
}


void CInSequence::PostUnfreezeEntries()
{
	if(InterlockedCompareExchange(&m_fUnfreezePending, 1, 0) == 1)
		return;

	AddRef();
	ExPostRequestMustSucceeded(&m_UnfreezeEntries_ov);
}


void WINAPI CInSequence::OverlappedUnfreezeEntries(EXOVERLAPPED* ov)
{
	R<CInSequence> pInSeq = CONTAINING_RECORD(ov, CInSequence, m_UnfreezeEntries_ov);

	pInSeq->UnfreezeEntries();
}


void CInSequence::UnfreezeEntries()
/*++

Routine Description:
	Unfreeze packet-entries one by one from the head of the list.
	Stop when no ready packet-entry is found.
	
--*/
{
	try
	{
		for(;;)
		{	
			//
			// General crash point. Crash during normal operation.
			//
			PROBABILITY_CRASH_POINT(1000, L"While unfreezing packets by CInSequence.");
			
			CInSeqPacketEntry* entry = NULL;

			{
				CS lock(m_critInSeq);

				if(m_PacketEntryList.GetCount() == 0 || 
					!WasLogDone(m_PacketEntryList.GetHead()->m_SeqID, m_PacketEntryList.GetHead()->m_SeqN))
				{
					//
					// Allow for other threads to issue new unfreeze requests
					//
					InterlockedExchange(&m_fUnfreezePending, 0);
					break;
				}

				entry = m_PacketEntryList.GetHead();
			}

			PROBABILITY_THROW_EXCEPTION(1, L"Before unfreezing a packet by CInSequence.");
			QmAcPutPacket(entry->m_hQueue, entry->m_pDriverPacket, eDoNotDeferOnFailure);

			TrTRACE(XACT_RCV,"Exactly1 receive: Unfreezed: SeqID=%x / %x, SeqN=%d .", HighSeqID(entry->m_SeqID), LowSeqID(entry->m_SeqID), entry->m_SeqN);
			
			CS lock(m_critInSeq);
			
			m_PacketEntryList.RemoveHead();
			delete entry;
		}

		CheckFirstEntry();
		return;
	}
	catch(const exception&)
	{
		InterlockedExchange(&m_fUnfreezePending, 0);
	
		Sleep(xRetryFailureTimeout);
		PostUnfreezeEntries();
		return;
	}
}


void CInSequence::SetLastAccessed()
{
	CS lock(m_critInSeq);
	
    time(&m_timeLastAccess);
}

BOOL CInSequence::Save(HANDLE hFile)
{
    PERSIST_DATA;
    LONGLONG liIDReg;
    ULONG ulNReg;
    time_t timeLastAccess;
    GUID gDestQmOrTaSrcQm;

	{
		CS lock(m_critInSeq);
		
	    liIDReg = m_SeqIDLogged;
	    ulNReg = m_SeqNLogged;
	    timeLastAccess = m_timeLastAccess;
		gDestQmOrTaSrcQm = m_gDestQmOrTaSrcQm;
	}

	//
	// Any field saved here should be checked that it is not changed by another thread while in this routine,
	// or verify that it does not make any harm.
	//
	SAVE_FIELD(liIDReg);
    SAVE_FIELD(ulNReg);
    SAVE_FIELD(timeLastAccess);
    SAVE_FIELD(m_DirectType);
    SAVE_FIELD(gDestQmOrTaSrcQm);

	//
	// If no direct http - no order queue to save
	//
	if(m_DirectType != dtxHttpDirectFlag)
		return TRUE;
	
	//
	//Save order queue url
	//
	R<CWcsRef> HttpOrderAckQueue = GetHttpOrderAckQueue();
	DWORD len = (DWORD)(HttpOrderAckQueue.get() ?  (wcslen(HttpOrderAckQueue->getstr()) +1)*sizeof(WCHAR) : 0);

	SAVE_FIELD(len);
	if(len != 0)
	{
		SAVE_DATA(HttpOrderAckQueue->getstr(), len);
	}

    return TRUE;
}

BOOL CInSequence::Load(HANDLE hFile)
{
    PERSIST_DATA;
    LONGLONG  liIDReg;
    ULONG     ulNReg;

    LOAD_FIELD(liIDReg);
    m_SeqIDVerify = liIDReg;
    m_SeqIDLogged = liIDReg;

    LOAD_FIELD(ulNReg);
    m_SeqNVerify = ulNReg;
    m_SeqNLogged = ulNReg;

    LOAD_FIELD(m_timeLastAccess);
    LOAD_FIELD(m_DirectType);
    LOAD_FIELD(m_gDestQmOrTaSrcQm);

	if(m_DirectType == dtxHttpDirectFlag)
	{
		DWORD OrderQueueStringSize;
		LOAD_FIELD(OrderQueueStringSize);
		if(OrderQueueStringSize != 0)
		{
			AP<WCHAR> pHttpOrderAckQueue;
			LOAD_ALLOCATE_DATA(pHttpOrderAckQueue, OrderQueueStringSize, PWCHAR);
			m_HttpOrderAckQueue = R<CWcsRef>(new CWcsRef(pHttpOrderAckQueue, 0));
			pHttpOrderAckQueue.detach();
		}
	}
		

    TrTRACE(XACT_RCV, "Exactly1 receive: restored from Checkpoint: Sequence %x / %x, LastSeqN=%d", HighSeqID(m_SeqIDVerify), LowSeqID(m_SeqIDVerify), m_SeqNVerify);

    return TRUE;
}

//--------------------------------------
//
// Class  CInSeqHash
//
//--------------------------------------

#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CInSeqHash::CInSeqHash
    Constructor
=====================================================*/
CInSeqHash::CInSeqHash() :
    m_fCleanupScheduled(FALSE),
    m_CleanupTimer(TimeToCleanupDeadSequence),
    m_PingPonger(this,
                 FALCON_DEFAULT_INSEQFILE_PATH,
                 FALCON_INSEQFILE_PATH_REGNAME,
                 FALCON_INSEQFILE_REFER_NAME)
{
    DWORD dwDef1 = MSMQ_DEFAULT_IDLE_ACK_DELAY;
    READ_REG_DWORD(m_dwIdleAckDelay,
                  MSMQ_IDLE_ACK_DELAY_REGNAME,
                  &dwDef1 ) ;

    DWORD dwDef2 = FALCON_MAX_SEQ_ACK_DELAY;
    READ_REG_DWORD(m_dwMaxAckDelay,
                  FALCON_MAX_SEQ_ACK_DELAY_REGNAME,
                  &dwDef2 ) ;

    DWORD dwDef3 = FALCON_DEFAULT_INSEQS_CHECK_INTERVAL;
    READ_REG_DWORD(m_ulRevisionPeriod,
                  FALCON_INSEQS_CHECK_REGNAME,
                  &dwDef3 ) ;

    m_ulRevisionPeriod *= 60;

    DWORD dwDef4 = FALCON_DEFAULT_INSEQS_CLEANUP_INTERVAL;
    READ_REG_DWORD(m_ulCleanupPeriod,
                  FALCON_INSEQS_CLEANUP_REGNAME,
                  &dwDef4 ) ;

    m_ulCleanupPeriod *= (24 * 60 *60);
}
#pragma warning(default: 4355)  // 'this' : used in base member initializer list

/*====================================================
CInSeqHash::~CInSeqHash
    Destructor
=====================================================*/
CInSeqHash::~CInSeqHash()
{
    if (m_fCleanupScheduled)
    {
        ExCancelTimer(&m_CleanupTimer);
    }
}

/*====================================================
CInSeqHash::Destroy
    Destroys everything
=====================================================*/
void CInSeqHash::Destroy()
{
    CSW lock(m_RWLockInSeqHash);

    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
        CKeyInSeq    key;
        R<CInSequence> pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

        m_mapInSeqs.RemoveKey(key);
   }
}

/*====================================================
CInSeqHash::Lookup
    Looks for the InSequence; TRUE = Found
=====================================================*/
BOOL CInSeqHash::Lookup(
       const GUID    *pQMID,
       QUEUE_FORMAT  *pqf,
	   const R<CWcsRef>&  StreamId,
       R<CInSequence>& InSeq)
{
    CSR lock(m_RWLockInSeqHash);

    CKeyInSeq key(pQMID,  pqf ,StreamId);

    if (m_mapInSeqs.Lookup(key, InSeq))
    {
        return TRUE;
    }

    return FALSE;
}



/*====================================================
CInSeqHash::AddSequence
    Looks for / Adds new InSequence to the hash;
=====================================================*/
R<CInSequence> CInSeqHash::AddSequence(
       const GUID   *pQMID,
       QUEUE_FORMAT *pqf,
       LONGLONG      liSeqID,
       XactDirectType   DirectType,
       const GUID   *pgTaSrcQm,
	   const R<CWcsRef>&  HttpOrderAckQueue,
	   const R<CWcsRef>&  StreamId)
{
	ASSERT(!( StreamId.get() != NULL && !FnIsDirectHttpFormatName(pqf)) );
	ASSERT(!( StreamId.get() == NULL && FnIsDirectHttpFormatName(pqf)) );

	//
	// We don't allow new entry to be created without order queue
	//
	if(StreamId.get() != NULL &&  HttpOrderAckQueue.get() == NULL)
	{
		//
		// We may get here in an out of order scenario. 
		// If we get a message, other than the first one, before the first message,
		// we'll want to create a new sequence but the message will not have an order ack queue.
		//
		TrERROR(SRMP,"Http Packet rejected because of a missing order queue : SeqID=%x / %x", HIGH_DWORD(liSeqID), LOW_DWORD(liSeqID));
		throw exception();
	}
	
	CSW lock(m_RWLockInSeqHash);

    CKeyInSeq key(pQMID,  pqf ,StreamId);
	R<CInSequence> pInSeq;
	
    //
    // First try a lookup because sequence could have been added before the lock was grabbed.
    //
    if (m_mapInSeqs.Lookup(key, pInSeq))
    	return pInSeq;
    
    pInSeq = new CInSequence(key, liSeqID, 0, DirectType, pgTaSrcQm, HttpOrderAckQueue);

    m_mapInSeqs.SetAt(key, pInSeq);
    if (!m_fCleanupScheduled)
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
        m_fCleanupScheduled = TRUE;
    }

    TrTRACE(XACT_RCV, "Exactly1 receive: Adding new sequence: SeqID=%x / %x", HighSeqID(liSeqID), LowSeqID(liSeqID));

    return pInSeq;
}


R<CInSequence> CInSeqHash::LookupSequence(CQmPacket* pPkt)
{
    QUEUE_FORMAT qf;

    pPkt->GetDestinationQueue(&qf);
    
    const GUID *gSenderID  = pPkt->GetSrcQMGuid();
	R<CWcsRef> StreamId = SafeGetStreamId(*pPkt);
   	
   	R<CInSequence> pInSeq;
   	
	Lookup(gSenderID, &qf, StreamId ,pInSeq);

	return pInSeq;
}


R<CInSequence> CInSeqHash::LookupCreateSequence(CQmPacket* pPkt)
{
    QUEUE_FORMAT qf;

    pPkt->GetDestinationQueue(&qf);
    
    LONGLONG      liSeqID  = pPkt->GetSeqID();
    const GUID *gSenderID  = pPkt->GetSrcQMGuid();
    const GUID   *gDestID  = pPkt->GetDstQMGuid();  // For direct: keeps source address
	XactDirectType   DirectType = GetDirectType(&qf);
  	R<CWcsRef> OrderAckQueue = SafeGetOrderQueue(*pPkt);
	R<CWcsRef> StreamId = SafeGetStreamId(*pPkt);

   	return LookupCreateSequenceInternal(
   				&qf, 
   				liSeqID, 
   				gSenderID, 
   				gDestID, 
   				DirectType, 
   				OrderAckQueue, 
   				StreamId
   				);  
}



R<CInSequence> 
CInSeqHash::LookupCreateSequenceInternal(
				QUEUE_FORMAT *pqf,
				LONGLONG liSeqID,
    			const GUID *gSenderID,
    			const GUID *gDestID,
				XactDirectType DirectType,
  				R<CWcsRef> OrderAckQueue,
				R<CWcsRef> StreamId
				)
{
   	R<CInSequence> pInSeq;

	if (Lookup(gSenderID, pqf, StreamId ,pInSeq))
		return pInSeq;
	
	pInSeq = AddSequence(
				gSenderID,
				pqf,
				liSeqID,
				DirectType,
				gDestID,
				OrderAckQueue,
				StreamId
				);

    return pInSeq;
}



/*====================================================
SendXactAck
    Sends Seq.Ack or status update to the source QM
=====================================================*/
HRESULT SendXactAck(OBJECTID   *pMessageId,
                    bool    fDirect,
					const GUID *pSrcQMId,
                    const TA_ADDRESS *pa,
                    USHORT     usClass,
                    USHORT     usPriority,
                    LONGLONG   liSeqID,
                    ULONG      ulSeqN,
                    ULONG      ulPrevSeqN,
                    const QUEUE_FORMAT *pqdDestQueue)
{

    OrderAckData    OrderData;
    HRESULT hr;

    TrTRACE(XACT_RCV, "Exactly1 receive: Sending status ack: Class=%x, SeqID=%x / %x, SeqN=%d .", usClass, HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN);

    //
    // Define delivery. We want final acks to be recoverable, and order ack - express
    //
    UCHAR ucDelivery = (UCHAR)(usClass == MQMSG_CLASS_ORDER_ACK ?
                                   MQMSG_DELIVERY_EXPRESS :
                                   MQMSG_DELIVERY_RECOVERABLE);
    //
    // Create Message property on stack
    //     with the correlation holding the original packet ID
    //
    CMessageProperty MsgProperty(usClass,
                     (PUCHAR) pMessageId,
                     usPriority,
                     ucDelivery);

    if (usClass == MQMSG_CLASS_ORDER_ACK || MQCLASS_NACK(usClass))
    {
        //
        // Create Order structure to send as a body
        //
        OrderData.m_liSeqID     = liSeqID;
        OrderData.m_ulSeqN      = ulSeqN;
        OrderData.m_ulPrevSeqN  = ulPrevSeqN;
        CopyMemory(&OrderData.MessageID, pMessageId, sizeof(OBJECTID));

        MsgProperty.dwTitleSize     = STRLEN(ORDER_ACK_TITLE) + 1;
        MsgProperty.pTitle          = ORDER_ACK_TITLE;
        MsgProperty.dwBodySize      = sizeof(OrderData);
        MsgProperty.dwAllocBodySize = sizeof(OrderData);
        MsgProperty.pBody           = (PUCHAR) &OrderData;
        MsgProperty.bDefProv        = TRUE;
    }


	QUEUE_FORMAT XactQueue;
	WCHAR wsz[150], wszAddr[100];

    if (fDirect)
    {
        TA2StringAddr(pa, wszAddr, 100);
        ASSERT(pa->AddressType == IP_ADDRESS_TYPE);

        wcscpy(wsz, FN_DIRECT_TCP_TOKEN);
        wcscat(wsz, wszAddr+2); // +2 jumps over not-needed type
        wcscat(wsz, FN_PRIVATE_SEPERATOR);
        wcscat(wsz, PRIVATE_QUEUE_PATH_INDICATIOR);
        wcscat(wsz, ORDERING_QUEUE_NAME);

        XactQueue.DirectID(wsz);
    }
    else
    {
        XactQueue.PrivateID(*pSrcQMId, ORDER_QUEUE_PRIVATE_INDEX);
    }

    hr = QmpSendPacket(&MsgProperty,&XactQueue, NULL, pqdDestQueue);
    return LogHR(hr, s_FN, 10);
}


BOOL CInSeqHash::Save(HANDLE  hFile)
{
    CSR lock(m_RWLockInSeqHash);

	TrTRACE(XACT_RCV, "The Inseq Hash save started.");
	int n = 0;
	
    PERSIST_DATA;

    ULONG cLen = m_mapInSeqs.GetCount();
    SAVE_FIELD(cLen);

    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
    	n++;
    	
        CKeyInSeq    key;
        R<CInSequence> pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

        if (!key.Save(hFile))
        {
            return FALSE;
        }

        if (!pInSeq->Save(hFile))
        {
            return FALSE;
        }
    }

    SAVE_FIELD(m_ulPingNo);
    SAVE_FIELD(m_ulSignature);

	TrTRACE(XACT_RCV, "The Inseq Hash save done. Saved %d entries", n);
	
    return TRUE;
}

BOOL CInSeqHash::Load(HANDLE hFile)
{
    PERSIST_DATA;

    ULONG cLen;
    LOAD_FIELD(cLen);

    for (ULONG i=0; i<cLen; i++)
    {
        CKeyInSeq    key;

        if (!key.Load(hFile))
        {
            return FALSE;
        }

        R<CInSequence> pInSeq = new CInSequence(key);
        if (!pInSeq->Load(hFile))
        {
            return FALSE;
        }

        m_mapInSeqs.SetAt(key, pInSeq);
        if (!m_fCleanupScheduled)
        {
            ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
            m_fCleanupScheduled = TRUE;
        }
    }

    LOAD_FIELD(m_ulPingNo);
    LOAD_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CInSeqHash::SaveInFile
    Saves the InSequences Hash in the file
=====================================================*/
HRESULT CInSeqHash::SaveInFile(LPWSTR wszFileName, ULONG, BOOL)
{
    TrTRACE(XACT_RCV, "Saved InSeqs: %ls (ping=%d)", wszFileName, m_ulPingNo);

    CFileHandle hFile = CreateFile(
                             wszFileName,                                       // pointer to name of the file
                             GENERIC_WRITE,                                     // access mode: write
                             0,                                                 // share  mode: exclusive
                             NULL,                                              // no security
                             OPEN_ALWAYS,                                      // open existing or create new
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // file attributes and flags: we need to avoid lazy write
                             NULL);                                             // handle to file with attributes to copy


    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
		HRESULT hr = HRESULT_FROM_WIN32(gle);

        LogHR(hr, s_FN, 41);
        TrERROR(XACT_GENERAL, "Failed to create transactional logger file: %ls. %!winerr!", wszFileName, gle);

        return hr;
    }

    if (Save(hFile))
        return MQ_OK;
    
    TrERROR(XACT_GENERAL, "Failed to save transactional logger file: %ls.", wszFileName);
    return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 40);
}



/*====================================================
CInSeqHash::LoadFromFile
    Loads the InSequences Hash from the file
=====================================================*/
HRESULT CInSeqHash::LoadFromFile(LPWSTR wszFileName)
{
    CSW      lock(m_RWLockInSeqHash);
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;

    hFile = CreateFile(
             wszFileName,                       // pointer to name of the file
             GENERIC_READ,                      // access mode: write
             0,                                 // share  mode: exclusive
             NULL,                              // no security
             OPEN_EXISTING,                     // open existing
             FILE_ATTRIBUTE_NORMAL,             // file attributes: we may use Hidden once
             NULL);                             // handle to file with attributes to copy

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Load(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

#ifdef _DEBUG
    if (SUCCEEDED(hr))
    {
        TrTRACE(XACT_RCV, "Loaded InSeqs: %ls (ping=%d)", wszFileName, m_ulPingNo);
    }
#endif

    return LogHR(hr, s_FN, 50);
}

/*====================================================
CInSeqHash::Check
    Verifies the state
=====================================================*/
BOOL CInSeqHash::Check()
{
    return (m_ulSignature == INSEQS_SIGNATURE);
}


/*====================================================
CInSeqHash::Format
    Formats the initial state
=====================================================*/
HRESULT CInSeqHash::Format(ULONG ulPingNo)
{
     m_ulPingNo = ulPingNo;
     m_ulSignature = INSEQS_SIGNATURE;

     return MQ_OK;
}

/*====================================================
QMPreInitInSeqHash
    PreInitializes Incoming Sequences Hash
=====================================================*/
HRESULT QMPreInitInSeqHash(ULONG ulVersion, TypePreInit tpCase)
{
   ASSERT(!g_pInSeqHash);
   g_pInSeqHash = new CInSeqHash();

   ASSERT(g_pInSeqHash);
   return LogHR(g_pInSeqHash->PreInit(ulVersion, tpCase), s_FN, 60);
}


/*====================================================
QMFinishInSeqHash
    Frees Incoming Sequences Hash
=====================================================*/
void QMFinishInSeqHash()
{
   if (g_pInSeqHash)
   {
        delete g_pInSeqHash;
        g_pInSeqHash = NULL;
   }
   return;
}

void CInSeqHash::HandleInSecSrmp(void* pData, ULONG cbData)
{
	CInSeqRecordSrmp   TheInSeqRecordSrmp((BYTE*)pData,cbData);
	GUID guidnull (GUID_NULL);
	QUEUE_FORMAT DestinationQueueFormat;
	DestinationQueueFormat.DirectID(TheInSeqRecordSrmp.m_pDestination.get());

	R<CInSequence> pInSeq = LookupCreateSequenceInternal(
								&DestinationQueueFormat,
								TheInSeqRecordSrmp.m_StaticData.m_liSeqID,
				    			&guidnull,
				    			&guidnull,
								dtxHttpDirectFlag,
				  				TheInSeqRecordSrmp.m_pHttpOrderAckDestination,
								TheInSeqRecordSrmp.m_pStreamId
								);
	pInSeq->AdvanceRecovered(
				TheInSeqRecordSrmp.m_StaticData.m_liSeqID, 
				numeric_cast<ULONG>(TheInSeqRecordSrmp.m_StaticData.m_ulNextSeqN),
				&guidnull,
				TheInSeqRecordSrmp.m_pHttpOrderAckDestination
				);

    TrTRACE(XACT_LOG, "InSeq recovery: SRMP Sequence %x / %x, LastSeqN=%d, direct=%ls", HighSeqID(TheInSeqRecordSrmp.m_StaticData.m_liSeqID), LowSeqID(TheInSeqRecordSrmp.m_StaticData.m_liSeqID), TheInSeqRecordSrmp.m_StaticData.m_ulNextSeqN, TheInSeqRecordSrmp.m_pDestination.get());
}

void CInSeqHash::HandleInSec(PVOID pData, ULONG cbData)
{
	InSeqRecord *pInSeqRecord = (InSeqRecord *)pData;

	DBG_USED(cbData);
    ASSERT(cbData == (
               sizeof(InSeqRecord) -
               sizeof(pInSeqRecord->wszDirectName)+
               sizeof(WCHAR) * ( wcslen(pInSeqRecord->wszDirectName) + 1)));				

    XactDirectType DirectType = pInSeqRecord->QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT ? dtxDirectFlag : dtxNoDirectFlag;

    if(DirectType == dtxDirectFlag)
    {
        pInSeqRecord->QueueFormat.DirectID(pInSeqRecord->wszDirectName);
    }

	R<CInSequence> pInSeq = LookupCreateSequenceInternal(
								&pInSeqRecord->QueueFormat,
								pInSeqRecord->liSeqID,
				    			&pInSeqRecord->Guid,
				    			&pInSeqRecord->guidDestOrTaSrcQm,
								DirectType,
				  				NULL,
								NULL
								);
	pInSeq->AdvanceRecovered(
				pInSeqRecord->liSeqID, 
				pInSeqRecord->ulNextSeqN,
				&pInSeqRecord->guidDestOrTaSrcQm,
				NULL
				);

    TrTRACE(XACT_LOG, "InSeq recovery: Sequence %x / %x, LastSeqN=%d, direct=%ls", HighSeqID(pInSeqRecord->liSeqID), LowSeqID(pInSeqRecord->liSeqID), pInSeqRecord->ulNextSeqN, pInSeqRecord->wszDirectName);
}


/*====================================================
CInSeqHash::SequnceRecordRecovery
Recovery function: called per each log record
=====================================================*/
void CInSeqHash::SequnceRecordRecovery(USHORT usRecType, PVOID pData, ULONG cbData)
{
    switch (usRecType)
    {
      case LOGREC_TYPE_INSEQ:
      HandleInSec(pData,cbData);
      break;

	  case LOGREC_TYPE_INSEQ_SRMP:
	  HandleInSecSrmp(pData,cbData);
	  break;
	
	
    default:
        ASSERT(0);
        break;
    }
}


/*====================================================
CInSeqHash::PreInit
    PreIntialization of the In Seq Hash (load)
=====================================================*/
HRESULT CInSeqHash::PreInit(ULONG ulVersion, TypePreInit tpCase)
{
    switch(tpCase)
    {
    case piNoData:
        m_PingPonger.ChooseFileName();
        Format(0);
        return MQ_OK;
    case piNewData:
        return LogHR(m_PingPonger.Init(ulVersion), s_FN, 70);
    case piOldData:
        return LogHR(m_PingPonger.Init_Legacy(), s_FN, 80);
    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 90);
    }
}

/*====================================================
CInSeqHash::Save
    Saves in appropriate file
=====================================================*/
HRESULT CInSeqHash::Save()
{
    return LogHR(m_PingPonger.Save(), s_FN, 100);
}

// Get/Set methods
ULONG &CInSeqHash::PingNo()
{
    return m_ulPingNo;
}

template<>
void AFXAPI DestructElements(CInSequence ** /*ppInSeqs */, int /*n*/)
{
//    for (int i=0;i<n;i++)
//        delete *ppInSeqs++;
}

/*====================================================
TimeToCleanupDeadSequence
    Scheduled periodically to delete dead incomong sequences
=====================================================*/
void WINAPI CInSeqHash::TimeToCleanupDeadSequence(CTimer* /*pTimer*/)
{
    g_pInSeqHash->CleanupDeadSequences();
}

void CInSeqHash::CleanupDeadSequences()
{
    // Serializing all outgoing hash activity on the highest level
    CSW lock(m_RWLockInSeqHash);

    ASSERT(m_fCleanupScheduled);

    time_t timeCur;
    time(&timeCur);

    // Loop upon all sequences
    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
        CKeyInSeq key;
        R<CInSequence> pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

		//
        // Is it inactive?
        //
        if (timeCur - pInSeq->LastAccessed()  > (long)m_ulCleanupPeriod) 
        {
        	ASSERT_BENIGN(("Expected sequence to be inactive", pInSeq->IsInactive()));
            m_mapInSeqs.RemoveKey(key);
        }
    }

    if (m_mapInSeqs.IsEmpty())
    {
        m_fCleanupScheduled = FALSE;
        return;
    }

    ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
}

void
CInSeqHash::GetInSequenceInformation(
    const QUEUE_FORMAT *pqf,
    LPCWSTR QueueName,
    GUID** ppSenderId,
    ULARGE_INTEGER** ppSeqId,
    DWORD** ppSeqN,
    LPWSTR** ppSendQueueFormatName,
    TIME32** ppLastActiveTime,
    DWORD** ppRejectCount,
    DWORD* pSize
    )
{
    CList<POSITION, POSITION> FindPosList;
    CSR lock(m_RWLockInSeqHash);

    POSITION pos;
    POSITION PrevPos;
    pos = m_mapInSeqs.GetStartPosition();

    while (pos)
    {
        PrevPos = pos;

        CKeyInSeq InSeqKey;
        R<CInSequence> InSeq;
        m_mapInSeqs.GetNextAssoc(pos, InSeqKey, InSeq);

        const QUEUE_FORMAT* KeyFormatName = InSeqKey.GetQueueFormat();
        if (*KeyFormatName == *pqf)
        {
            FindPosList.AddTail(PrevPos);
        }
        else
        {
            if (KeyFormatName->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
            {
                LPCWSTR DirectId = KeyFormatName->DirectID();

				AP<WCHAR> QueuePathName;
                LPCWSTR DirectQueueName = NULL;

				if(InSeq->DirectType() == dtxDirectFlag)
				{
					DirectQueueName = wcschr(DirectId, L'\\');
					if(DirectQueueName == NULL)
					{
						ASSERT(("Invalid direct queue format name",0));
						TrERROR(XACT_GENERAL, "Bad queue path name '%ls'", DirectId);
						continue;
					}
				}
				else
				{
					ASSERT(InSeq->DirectType() == dtxHttpDirectFlag);

					try
					{
						FnDirectIDToLocalPathName(
							DirectId,
							L".",	// LocalMachineName
							QueuePathName
							);

					}
					catch(const exception&)
					{
						continue;
					}
					
					DirectQueueName = wcschr(QueuePathName, L'\\');
					if(DirectQueueName == NULL)
					{
						ASSERT(("Invalid direct queue format name",0));
						TrERROR(XACT_GENERAL, "Bad queue path name '%ls'", QueuePathName);
						continue;
					}
				}

				ASSERT(DirectQueueName != NULL);

				DirectQueueName++;

                if (CompareStringsNoCase(DirectQueueName, QueueName) == 0)
                {
                    FindPosList.AddTail(PrevPos);
                }
            }
        }
    }

    DWORD count = FindPosList.GetCount();

    if (count == 0)
    {
        *ppSenderId = NULL;
        *ppSeqId = NULL;
        *ppSeqN = NULL;
        *ppSendQueueFormatName = NULL;
        *ppLastActiveTime = NULL;
        *pSize = count;

        return;
    }

    //
    // Allocates Arrays to return the Data
    //
    AP<GUID> pSenderId = new GUID[count];
    AP<ULARGE_INTEGER> pSeqId = new ULARGE_INTEGER[count];
    AP<DWORD> pSeqN = new DWORD[count];
    AP<LPWSTR> pSendQueueFormatName = new LPWSTR[count];
    AP<TIME32> pLastActiveTime = new TIME32[count];
    AP<DWORD> pRejectCount = new DWORD[count];

    DWORD Index = 0;
    pos = FindPosList.GetHeadPosition();

    try
    {
        while(pos)
        {
            POSITION mapPos = FindPosList.GetNext(pos);

            CKeyInSeq InSeqKey;
            R<CInSequence> pInSeq;
            m_mapInSeqs.GetNextAssoc(mapPos, InSeqKey, pInSeq);

            pSenderId[Index] = *InSeqKey.GetQMID();
            pSeqId[Index].QuadPart = pInSeq->SeqIDLogged();
            pSeqN[Index] = pInSeq->SeqNLogged();
            pLastActiveTime[Index] = INT_PTR_TO_INT(pInSeq->LastAccessed()); //BUGBUG bug year 2038
            pRejectCount[Index] = pInSeq->GetRejectCount();

            //
            // Copy the format name
            //
            WCHAR QueueFormatName[1000];
            DWORD RequiredSize;
            HRESULT hr = MQpQueueFormatToFormatName(
                            InSeqKey.GetQueueFormat(),
                            QueueFormatName,
                            1000,
                            &RequiredSize,
                            false
                            );
            ASSERT(SUCCEEDED(hr));
            LogHR(hr, s_FN, 174);
            pSendQueueFormatName[Index] = new WCHAR[RequiredSize + 1];
            wcscpy(pSendQueueFormatName[Index], QueueFormatName);

            ++Index;
        }
    }
    catch (const bad_alloc&)
    {
        while(Index)
        {
            delete [] pSendQueueFormatName[--Index];
        }

        LogIllegalPoint(s_FN, 84);
        throw;
    }

    ASSERT(Index == count);

    *ppSenderId = pSenderId.detach();
    *ppSeqId = pSeqId.detach();
    *ppSeqN = pSeqN.detach();
    *ppSendQueueFormatName = pSendQueueFormatName.detach();
    *ppLastActiveTime = pLastActiveTime.detach();
    *ppRejectCount = pRejectCount.detach();
    *pSize = count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactin.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactIn.h

Abstract:
    Exactly-once receiver implementation classes:
        CKeyinSeq           - Incoming Sequence Key
        CInSequence         - Incoming Sequence,
        CInSeqHash          - Incoming Sequences Hash table

    Persistency:  ping-pong + Win32 File writes + logger

Author:
    AlexDad

--*/

#ifndef __XACTIN_H__
#define __XACTIN_H__
#include "xactlog.h"
#include <rwlock.h>

#define FILE_NAME_MAX_SIZE     256
enum XactDirectType{dtxNoDirectFlag = 0, 
					dtxDirectFlag = 1, 
					dtxHttpDirectFlag = 2};

//
// This type is persist to disk - it must be integer (4 bytes) long
//
C_ASSERT(sizeof(XactDirectType) == sizeof(int));



//---------------------------------------------------------------------
//
// class CKeyInSeq (needed for CMap)
//
//---------------------------------------------------------------------
class CKeyInSeq
{
public:
    CKeyInSeq(const GUID *pGuid, QUEUE_FORMAT *pqf,const  R<CWcsRef>& StreamId);
    CKeyInSeq();
    
    ~CKeyInSeq();

    // Get methods
    const GUID  *GetQMID()  const;
    const QUEUE_FORMAT  *GetQueueFormat() const;
	const WCHAR* GetStreamId() const;
	R<CWcsRef> GetRefStreamId() const;

    CKeyInSeq &operator=(const CKeyInSeq &key2 );

    // Persistency
    BOOL Save(HANDLE hFile);
    BOOL Load(HANDLE hFile);

private:
	CKeyInSeq(const CKeyInSeq &key);
	BOOL SaveNonSrmp(HANDLE hFile);
	BOOL SaveSrmp(HANDLE hFile);
	BOOL LoadNonSrmp(HANDLE hFile);
	BOOL LoadSrmp(HANDLE );
	BOOL LoadQueueFormat(HANDLE hFile);
	BOOL LoadSrmpStream(HANDLE hFile);
 

private:
    GUID         m_Guid;
    QUEUE_FORMAT m_QueueFormat;
	R<CWcsRef>    m_StreamId;
};

// CMap helper functions
template<>
UINT AFXAPI HashKey(CKeyInSeq& key);
BOOL operator==(const CKeyInSeq &key1, const CKeyInSeq &key2);



class CInSeqPacketEntry
{
public:
	CInSeqPacketEntry();
	CInSeqPacketEntry(
		CQmPacket *pPkt,
		HANDLE hQueue
		);
	
	bool m_fPutPacket1Issued;
	bool m_fPutPacket1Done;
	bool m_fLogIssued;
	bool m_fMarkedForDelete;

	CBaseHeader *m_pBasicHeader;
    CPacket *m_pDriverPacket;
	HANDLE m_hQueue;

	LONGLONG m_SeqID;
    ULONG m_SeqN;

    bool m_fOrderQueueUpdated;
};



class CInSequence;



class CInSeqLogContext: public CAsynchSupport
{
	friend class CInSequence;
	
public:
     CInSeqLogContext(
		CInSequence *inseq,
		LONGLONG seqID,
	    ULONG seqN
     	);     
    ~CInSeqLogContext() {}

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback(HRESULT /* hr */, LRP /* lrpAppendLRP */) { ASSERT(0); }

private:
	R<CInSequence> m_inseq;

	LONGLONG m_SeqID;
    ULONG m_SeqN;
};



//---------------------------------------------------------
//
//  class CInSequence
//
//---------------------------------------------------------
class CInSequence: public CReference
{
	friend class CInSeqLogContext;
	
public:
    CInSequence(const CKeyInSeq &key,
                const LONGLONG liSeqID, 
                const ULONG ulSeqN, 
                XactDirectType DirectType,
                const GUID  *pgTaSrcQm ,
				const R<CWcsRef>&   HttpOrderAckQueue);
    
    CInSequence(const CKeyInSeq &key);
    ~CInSequence();

	bool VerifyAndPrepare(CQmPacket *pPkt, HANDLE hQueue);
    void Advance(CQmPacket *pPkt); // Advances SeqID/N Ver
    void AdvanceNACK(CQmPacket *pPkt); // Advances SeqID/N Ver
    void AdvanceRecovered(LONGLONG liSeqID, ULONG ulSeqN, const GUID  *pgTaSrcQm, R<CWcsRef> OrderAckQueue); 
	bool WasPacketLogged(CQmPacket *pPkt);
	
	void FreePackets(CQmPacket *pPkt);
    void Register(CQmPacket *PktPtrs);
		
	bool IsInactive() const;
    time_t LastAccessed() const;   // GET: Last access time (last msg verified, maybe rejected)

	//    
	// Set methods
	//
	void SetSourceQM(const GUID  *pgTaSrcQm);
	void RenewHttpOrderAckQueue(const R<CWcsRef>& OrderAckQueue);
    
    //
    // Persistency
    //
    BOOL Save(HANDLE hFile);
    BOOL Load(HANDLE hFile);

    //
    // Management function
    //
	XactDirectType DirectType() const;  // GET: DirectType	
    DWORD GetRejectCount(void) const;
    LONGLONG SeqIDLogged() const;       // GET: SeqID Accepted
    ULONG SeqNLogged() const;        // GET: Last SeqN Accepted

	static void WINAPI OverlappedDeleteEntries(EXOVERLAPPED* ov);	
	static void WINAPI TimeToLogSequence(CTimer* pTimer);	
	static void WINAPI OverlappedUnfreezeEntries(EXOVERLAPPED* ov);	
    static void WINAPI TimeToSendOrderAck(CTimer* pTimer);
	void CancelSendOrderAckTimer(void);

	CCriticalSection& GetCriticalSection() { return m_critInSeq; }

	HRESULT 
	CInSequence::SendSrmpXactFinalAck(
		const CQmPacket& qmPacket,
		USHORT usClass
		);

private:
	R<CWcsRef> GetHttpOrderAckQueue();
	void UpdateOrderQueueAndDstQueue(const GUID  *pgTaSrcQm, R<CWcsRef> OrderAckQueue);	

	bool Verify(CQmPacket *pPkt);  // Verifies that the packet is in correct order
	void Prepare(CQmPacket *pPkt, HANDLE hQueue);
	void CleanupUnissuedEntries();

	POSITION FindEntry(LONGLONG SeqID, ULONG SeqN);
	POSITION FindPacket(CQmPacket *pPkt);
	void CheckFirstEntry();

	void PostDeleteEntries();
	void DeleteEntries();
	
	void ClearLogIssuedFlag(LONGLONG SeqID, ULONG SeqN);
	void ScheduleLogSequence(DWORD millisec = 0);
	void LogSequence();	
	void Log(CInSeqPacketEntry* entry, bool fLogOrderQueue);
	void AsyncLogDone(CInSeqLogContext *context, HRESULT hr);

	bool WasLogDone(LONGLONG SeqID, ULONG SeqN);
	void SetLogDone(LONGLONG SeqID, ULONG SeqN);
	
	void PostUnfreezeEntries();
	void UnfreezeEntries();

    void SetLastAccessed();                         // Remembers the time of last access
    void PlanOrderAck();                               // Plans sending order ack
    void SendAdequateOrderAck();                       // Sends the order ack

private:
    CCriticalSection   m_critInSeq;      // critical section for planning

    CKeyInSeq  m_key;                   // Sender QM GUID and  Sequence ID

    LONGLONG   m_SeqIDVerify;          // Current (or last) Sequence ID verified
    ULONG      m_SeqNVerify;          // Last message number verified
    LONGLONG   m_SeqIDLogged;      // Current (or last) Sequence ID accepted
    ULONG      m_SeqNLogged;      // Last message number accepted

	CList<CInSeqPacketEntry*, CInSeqPacketEntry*&> m_PacketEntryList;
	static const int m_xMaxEntriesAllowed = 10000;
	
    time_t     m_timeLastAccess;        // time of the last access to the sequence
    time_t     m_timeLastAck;           // time of the last order ack sending

    XactDirectType     m_DirectType;               // flag of direct addressing
    union {                 
        GUID        m_gDestQmOrTaSrcQm; // for non-direct: GUID of destination QM
        TA_ADDRESS  m_taSourceQM;       // for direct: address of source QM
    };

	R<CWcsRef> m_HttpOrderAckQueue;

    DWORD m_AdminRejectCount;

    BOOL m_fSendOrderAckScheduled;
    CTimer m_SendOrderAckTimer;

    LONG volatile m_fDeletePending;
    EXOVERLAPPED m_DeleteEntries_ov;

    LONG volatile m_fLogPending;
    CTimer m_LogSequenceTimer;

    LONG volatile m_fUnfreezePending;
    EXOVERLAPPED m_UnfreezeEntries_ov;
};

inline
DWORD 
CInSequence::GetRejectCount(
    void
    ) const
{
    return m_AdminRejectCount;
}


//---------------------------------------------------------
//
//  class CInSeqHash
//
//---------------------------------------------------------

class CInSeqHash  : public CPersist {

public:
    CInSeqHash();
    ~CInSeqHash();

	R<CInSequence> LookupSequence(CQmPacket *pPkt);
	R<CInSequence> LookupCreateSequence(CQmPacket *pPkt);
	
    VOID    CleanupDeadSequences();           // Erases dead sequences

    HRESULT PreInit(
    			ULONG ulVersion,
                TypePreInit tpCase
                );      // PreInitializes (loads data)
                                             
    HRESULT Save();  // Persist object to disk

	void SequnceRecordRecovery(					      // Recovery function 
				USHORT usRecType,			  //  (will be called for each log record)
				PVOID pData, 
				ULONG cbData);

    //
    // Management Function
    //
    void
    GetInSequenceInformation(
        const QUEUE_FORMAT *pqf,
        LPCWSTR QueueName,
        GUID** ppSenderId,
        ULARGE_INTEGER** ppSeqId,
        DWORD** ppSeqN,
        LPWSTR** ppSendQueueFormatName,
        TIME32** ppLastActiveTime,
        DWORD** ppRejectCount,
        DWORD* pSize
        );


    static void WINAPI TimeToCleanupDeadSequence(CTimer* pTimer);
    static DWORD m_dwIdleAckDelay;
    static DWORD m_dwMaxAckDelay;

	//
	// implementation of CPersist virtual base functions.
	//
    HRESULT SaveInFile(                       // Saves in file
                LPWSTR wszFileName, 
                ULONG ulIndex,
                BOOL fCheck);

    HRESULT LoadFromFile(LPWSTR wszFileName); // Loads from file

    BOOL    Check();                          // Verifies the state

    HRESULT Format(ULONG ulPingNo);           // Formats empty instance

    void    Destroy();                        // Destroyes allocated data
    
    ULONG&  PingNo();                         // Gives access to ulPingNo


private:
	void HandleInSecSrmp(void* pData, ULONG cbData);

	void HandleInSec(void* pData, ULONG cbData);
	
    R<CInSequence> AddSequence(                                 // Looks for / Adds new InSequence to the hash; FALSE=existed before
                const GUID   *pQMID,
                QUEUE_FORMAT *pqf,
                LONGLONG      liSeqID,
                XactDirectType   DirectType,
                const GUID     *pgTaSrcQm,
				const R<CWcsRef>&  pHttpOrderAckQueue,
				const R<CWcsRef>&  pStreamId);

	R<CInSequence> LookupCreateSequenceInternal(
				QUEUE_FORMAT *qf,
				LONGLONG liSeqID,
    			const GUID *gSenderID,
    			const GUID *gDestID,
				XactDirectType DirectType,
  				R<CWcsRef> OrderAckQueue,
				R<CWcsRef> StreamId
				);
	
    BOOL Lookup(                              // Looks for the InSequence; TRUE = Found
                const GUID     *pQMID,
                QUEUE_FORMAT   *pqf,
				const R<CWcsRef>&  StreamId,
                R<CInSequence> &InSeq);

    BOOL Save(HANDLE  hFile);              // Save / Load
    BOOL Load(HANDLE  hFile);

private:
	//
	// This RW lock is used to control access to the map.
	//
    CReadWriteLock m_RWLockInSeqHash;        // critical section for write 

    // Mapping {Sender QMID, FormatName} --> InSequence (= SeqID + SeqN)
    CMap<CKeyInSeq, CKeyInSeq &, R<CInSequence>, R<CInSequence>&> m_mapInSeqs;

    // Data for persistency control (via 2 ping-pong files)
    ULONG      m_ulPingNo;                    // Current counter of ping write
    ULONG      m_ulSignature;                 // Saving signature

    #ifndef COMP_TEST
    CPingPong  m_PingPonger;                  // Ping-Pong persistency object
    #endif

    ULONG      m_ulRevisionPeriod;            // period for checking dead sequences
    ULONG      m_ulCleanupPeriod;             // period of inactivity for deleting dead sequences

    BOOL m_fCleanupScheduled;
    CTimer m_CleanupTimer;
};

template<>
void AFXAPI DestructElements(CInSequence ** ppInSeqs, int n);

HRESULT SendXactAck(OBJECTID   *pMessageId,
                    bool    fDirect, 
				    const GUID *pSrcQMId,
                    const TA_ADDRESS *pa,
                    USHORT     usClass,
                    USHORT     usPriority,
                    LONGLONG   liSeqID,
                    ULONG      ulSeqN,
                    ULONG      ulPrevSeqN,
                    const QUEUE_FORMAT *pqdDestQueue);






//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------

extern CInSeqHash *g_pInSeqHash;

extern HRESULT QMPreInitInSeqHash(ULONG ulVersion, TypePreInit tpCase);
extern void    QMFinishInSeqHash();


#endif __XACTIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactmode.cpp ===
/*++
    Copyright (c) 1998  Microsoft Corporation

Module Name:
    xactmode.cpp

Abstract:
    This module deals with figuring out the transactional mode
	(g_fDefaultCommit)
 
Author:
    Amnon Horowitz (amnonh)

--*/

#include "stdh.h"
#include "xactmode.h"
#include "clusapi.h"

#include "xactmode.tmh"

BOOL g_fDefaultCommit;

static const LPWSTR szDefaultCommit = TEXT("DefaultCommit");

static WCHAR *s_FN=L"xactmode";

//---------------------------------------------------------------------
// InDefaultCommit
//
//	Consult registry and figure out if we are DefaultCommit Mode
//---------------------------------------------------------------------
inline HRESULT InDefaultCommit(LPBOOL pf) 
{
	WCHAR buf[64];
	DWORD  dwSize;
	DWORD  dwType;
	const LPWSTR szDefault = TEXT("No");
	LONG rc;

	dwSize = 64 * sizeof(WCHAR);
	dwType = REG_SZ;
	rc = GetFalconKeyValue(MSMQ_TRANSACTION_MODE_REGNAME,
								 &dwType,
								 buf,
								 &dwSize,
								 szDefault);

	if(rc == ERROR_SUCCESS)
	{
		if(dwType == REG_SZ && wcscmp(buf, szDefaultCommit) == 0)
        {
			*pf = TRUE;
        }
		else
        {
			*pf = FALSE;
        }
        return MQ_OK;
	}

	if(rc == ERROR_MORE_DATA)
	{
		*pf = FALSE;
		return MQ_OK;
	}

    EvReportWithError(EVENT_ERROR_QM_READ_REGISTRY, rc, 1, MSMQ_TRANSACTION_MODE_REGNAME);
	return HRESULT_FROM_WIN32(rc);
}

//---------------------------------------------------------------------
// SetDefaultCommit
//
//	Set DefaultCommit mode in the registry
//---------------------------------------------------------------------
inline HRESULT SetDefaultCommit()
{
	DWORD	dwType = REG_SZ;
	DWORD	dwSize = (wcslen(szDefaultCommit) + 1) * sizeof(WCHAR);

	LONG rc = SetFalconKeyValue(
                    MSMQ_TRANSACTION_MODE_REGNAME, 
                    &dwType,
                    szDefaultCommit,
                    &dwSize
                    );

	return HRESULT_FROM_WIN32(rc);
}


//---------------------------------------------------------------------
// ConfigureXactMode
//
//	Called prior to recovery to figure out which transactional mode
//	we are in, and if we want to try and switch to a different mode.
//---------------------------------------------------------------------
HRESULT ConfigureXactMode()
{
    HRESULT rc = InDefaultCommit(&g_fDefaultCommit);
    return LogHR(rc, s_FN, 30);
}

//---------------------------------------------------------------------
// ReconfigureXactMode
//
//	Called after succesfull recovery, to possiby switch to 
//	DefaultCommit mode.
//---------------------------------------------------------------------
HRESULT ReconfigureXactMode()
{
	if(g_fDefaultCommit)
		return MQ_OK;

	return SetDefaultCommit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactlog.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactLog.h

Abstract:
	Provides interface to the Viper Log Manager

Author:
    AlexDad

--*/

#ifndef __XACTLOG_H__
#define __XACTLOG_H__

// Logger interface include files
#include "ilgstor.h"
#include "ilgread.h"
#include "ilgwrite.h"
#include "ilgwrta.h"
#include "ilrp.h"
#include "ilginit.h"
#include "ilgcrea.h"
#include <limits.h>
#include <tr.h>
#include <ref.h>
#include <strutl.h>

//
// Log record types
//
#define LOGREC_TYPE_EMPTY		    1
#define LOGREC_TYPE_INSEQ		    2
#define	LOGREC_TYPE_XACT_STATUS     3
#define	LOGREC_TYPE_XACT_PREPINFO   4
#define	LOGREC_TYPE_XACT_DATA       5
#define	LOGREC_TYPE_CONSOLIDATION   6
#define LOGREC_TYPE_INSEQ_SRMP	    7


// Function type for recovery
typedef void (*LOG_RECOVERY_ROUTINE)(USHORT usRecType, PVOID pData, ULONG cbData);

// Function signals logger to stop
extern HANDLE XactLogSignalExitThread();


//--------------------------------------
//
// Empty Log Record
//
//--------------------------------------
typedef struct _EmptyRecord{
	ULONG    ulData;
} EmptyRecord;

//--------------------------------------
//
// Checkpoint Consolidation Log Record
//
//--------------------------------------
typedef struct _ConsolidationRecord{
    ULONG  m_ulInSeqVersion;
    ULONG  m_ulXactVersion;
} ConsolidationRecord;


class CConsolidationRecord 
{
public:
	CConsolidationRecord(
        ULONG ulInseqVersion,
        ULONG ulXactVersion);
	~CConsolidationRecord();

	ConsolidationRecord   m_Data;
};


//--------------------------------------
//
// Incoming Sequence Log Record
//
//--------------------------------------
#define MY_DN_LENGTH   MQ_MAX_Q_NAME_LEN


typedef struct _InSeqRecord{
	GUID          Guid;
    QUEUE_FORMAT  QueueFormat;
    LONGLONG      liSeqID;
    ULONG         ulNextSeqN;
    union {
        GUID        guidDestOrTaSrcQm;
        TA_ADDRESS  taSourceQM;
    };
    time_t        timeLastActive;
    WCHAR         wszDirectName[MY_DN_LENGTH];         // we write only filled part of it
} InSeqRecord;



class CInSeqRecord 
{
public:
	CInSeqRecord(
		const GUID	  *pGuid,
		const QUEUE_FORMAT  *pQueueFormat,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
        const GUID   *pGuidDestOrTaSrcQm);
       
	~CInSeqRecord();

	InSeqRecord   m_Data;
};

struct InSeqRecordSrmp
{
	InSeqRecordSrmp(
		LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive)
		:
		m_liSeqID(liSeqID),
		m_ulNextSeqN(ulNextSeqN),
		m_timeLastActive(timeLastActive)
		{}

	InSeqRecordSrmp(){}


	LONGLONG  m_liSeqID;
	LONGLONG  m_ulNextSeqN;
	time_t    m_timeLastActive; 
};




class CInSeqRecordSrmp 
{
public:
	CInSeqRecordSrmp(
		const WCHAR* pDestination,
		const R<CWcsRef>&  StreamId,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
		const R<CWcsRef>&  HttpOrderAckDestination
        );
    
	CInSeqRecordSrmp(const BYTE* pdata, DWORD len);

	const BYTE* Serialize(DWORD* plen);

	AP<BYTE> m_tofree;
	InSeqRecordSrmp m_StaticData;
	AP<WCHAR>  m_pDestination;
	R<CWcsRef> m_pStreamId;
	R<CWcsRef> m_pHttpOrderAckDestination;
};



//--------------------------------------
//
// Transaction Log Records:
//    Xact status, PrepInfo,  XactData
//
//--------------------------------------

// XactStatusRecord
typedef struct _XactStatusRecord {
	ULONG         m_ulIndex;
    TXACTION      m_taAction;
    ULONG         m_ulFlags;
} XactStatusRecord;


class CXactStatusRecord 
{
public:
	CXactStatusRecord(
          ULONG    ulIndex,
          TXACTION taAction,
          ULONG    ulFlags);
    ~CXactStatusRecord();

	XactStatusRecord   m_Data;
};

// PrepInfoRecord
#pragma warning(disable: 4200)          // zero-sized array in struct/union
typedef struct _PrepInfoRecord {
	ULONG         m_ulIndex;
    ULONG         m_cbPrepInfo;
    UCHAR         m_bPrepInfo[];
} PrepInfoRecord;
#pragma warning(default: 4200)          // zero-sized array in struct/union

class CPrepInfoRecord 
{
public:
	CPrepInfoRecord(
          ULONG    ulIndex,
          ULONG    cbPrepInfo,
          UCHAR    *pbPrepInfo);
    ~CPrepInfoRecord();

	PrepInfoRecord   *m_pData;
};

// XactDataRecord
typedef struct _XactDataRecord {
	ULONG         m_ulIndex;
    ULONG         m_ulSeqNum;  
    BOOL          m_fSinglePhase;
    XACTUOW       m_uow;	
} XactDataRecord;


class CXactDataRecord 
{
public:
	CXactDataRecord(
          ULONG    ulIndex,
          ULONG    ulSeqNum,
          BOOL     fSinglePhase,
          const XACTUOW  *puow
          );
    ~CXactDataRecord();

	XactDataRecord   m_Data;
};

//---------------------------------------------------------
//
//  class CXactStatusFlush : flush notification element 
//
//---------------------------------------------------------
class CXactStatusFlush: public CAsynchSupport
{
public:
     CXactStatusFlush(CTransaction *pCTrans, TXFLUSHCONTEXT tcContext);
    ~CXactStatusFlush();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);
     static void WINAPI TimeToCallback(CTimer* pTimer); 
     VOID AppendCallbackWork();

private:
	R<CTransaction>      m_pTrans;
    TXFLUSHCONTEXT       m_tcContext;

    HRESULT              m_hr;
    CTimer               m_Timer;
};


//---------------------------------------------------------
//
//  class CConsolidationFlush : flush notification element 
//
//---------------------------------------------------------
class CConsolidationFlush: public CAsynchSupport
{
public:
     CConsolidationFlush(HANDLE hEvent);
    ~CConsolidationFlush();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);

private:
	HANDLE   m_hEvent;
};

//---------------------------------------------------------
//
//  class CChkptNotification : checkpoint notification element 
//
//---------------------------------------------------------
class CChkptNotification: public CAsynchSupport
{
public:
     CChkptNotification(HANDLE hEvent);
    ~CChkptNotification();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);

	 bool WasEventSet();

private:
     HANDLE m_hEvent;
	 bool	m_fEventWasSet;
};

//--------------------------------------
//
// Class CLogger
//
//--------------------------------------
class CLogger {

public:
    CLogger();
    ~CLogger();

    //Initialization
    HRESULT PreInit(
                 BOOL *pfLogExists,
				 BOOL *pfNewTypeLogFile,
				 BOOL fLogfileMustExist
				 );
    HRESULT Init(
                 PULONG pulVerInSeq, 
                 PULONG pulVerXact,
                 ULONG  ulNumCheckpointFromTheEnd);
    HRESULT Init_Legacy();
    HRESULT Recover();

    void Activate();
	void Finish();
    bool Stoped() const;
    void SignalStop();

    // Logging: external level
    void    LogXactPhase(                       // Logs the xact life phase
                ULONG ulIndex, 
                TXACTION txAction);

    void    LogXactFlags(CTransaction *pTrans); // Logs the xact flags
    
    void    LogXactFlagsAndWait(                // Logs xact flags and waits
                TXFLUSHCONTEXT tcContext,
                CTransaction   *pCTrans,
                BOOL fFlushNow=FALSE);
    
    void    LogXactPrepareInfo(                 // Logs xact prepare info
                ULONG  ulIndex,
                ULONG  cbPrepareInfo,
                UCHAR *pbPrepareInfo);

    void    LogXactData(                        // Logs xact data (uow, seqnum)
                ULONG    ulIndex,
                ULONG    ulSeqNum,
                BOOL     fSinglePhase,
                const XACTUOW  *puow);

    void LogInSeqRec(
                BOOL          fFlush,			  // flush hint
                CAsynchSupport *pContext,		 // notification element
				CInSeqRecord *pInSeqRecord);	// log data 

	void LogInSeqRecSrmp(
            BOOL          fFlush,			      // flush hint
            CAsynchSupport *pContext,			 // notification element
			CInSeqRecordSrmp *pInSeqRecord);  	// log data 

    
    LRP LogConsolidationRec(
                ULONG ulInSeq,                      // Version of the InSeq checkpoint file
                ULONG ulXact,                       // Version of the Trans checkpoint file
                HANDLE hEvent                     // Event to signal on notification
				);

    HRESULT LogEmptyRec(void);

    BOOL    MakeCheckpoint(HANDLE hComplete);   // orders checkpoint; result means only request, not result
    void    Checkpoint(LRP lrp);                       // writes checkpoint record
    HANDLE  FlusherEvent();                     // Get for the flusher event
    HANDLE  FlusherThread();
    BOOL    Dirty();                            // Get for the dirty flag
    void    ClearDirty();                       // Clears away the flag
    void    SignalCheckpointWriteComplete();    // Signals that checkpoint write completed
    BOOL    Active();                           // Is active
    BOOL    InRecovery();                       // In recovery

	DWORD	GetCheckpointInterval();

    DWORD   CompareLRP(LRP lrpLRP1, LRP lrpLRP2);  // 0: equal, 
                                                   // 1:lrp1 older than lrpLRP2
                                                   // 2:lrp2 older than lrpLRP1

    void    SetCurrent(LRP lrpLRP);              // collects highest LRP

	HRESULT GetLogFileCreated(LPBOOL pfLogFileCreated) ;
	HRESULT SetLogFileCreated();

private:
    // Initialization
    BOOL    LogExists();
    void    ChooseFileName(WCHAR *wszDefFileName, WCHAR *wszRegKey);
    HRESULT GetLogMgr(void);
    HRESULT InitLog();
    HRESULT CreateLogFile(void);
    HRESULT CreateInitialChkpoints(void);
    HRESULT InitLogRead(void);
    HRESULT InitLogWrite(void);

    // Logging: internal level
    void LogXactStatusRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CXactStatusRecord *pInSeqRecord);	// log data 
    
    void LogPrepInfoRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CPrepInfoRecord   *pPrepInfoRecord);// log data 
    
    void LogXactDataRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CXactDataRecord   *pXactDataRecord);// log data 
    
    // Logging primitives
	LOGREC *CreateLOGREC(
                USHORT usUserType, 
                PVOID pData, 
                ULONG cbData);

    LRP Log(
                USHORT          usRecType,      // log record type
                BOOL            fFlush,			// flush hint
                CAsynchSupport *pCAsynchSupport,// notification element
			    VOID           *pData,          // log data 
                ULONG           cbData);

    // Recovery
	HRESULT ReadToEnd(LOG_RECOVERY_ROUTINE pf);
    HRESULT ReadLRP(  LOG_RECOVERY_ROUTINE pf);
    HRESULT ReadNext( LOG_RECOVERY_ROUTINE pf);
    
    // Cleanup
    void ReleaseWriteStream(void);
    void ReleaseReadStream(void);
    void ReleaseLogStorage();
    void ReleaseLogInit();
    void ReleaseLogCF();

private:
	// Log manager interfaces
    IClassFactory		*m_pCF;
    ILogInit			*m_pILogInit;
    ILogStorage			*m_pILogStorage;
    ILogRecordPointer	*m_ILogRecordPointer;
    ILogRead			*m_pILogRead;
    ILogWrite			*m_pILogWrite;
    ILogWriteAsynch		*m_pILogWriteAsynch;

	// Log manager tuning parameters
	UINT                 m_uiTimerInterval;	// msec: logger will check the need  for flush/chkpt each this interval
	UINT				 m_uiFlushInterval; // msec: logger will flush at least at this intervals 
	UINT				 m_uiChkPtInterval; // msec: logger will write his internal chkpts at these intervals 
    UINT                 m_uiSleepAsynch;   // msec: to sleep before repeating AppendAsynch when not enough append threads
    UINT                 m_uiAsynchRepeatLimit;   // msec: repeat limit for AppendAsynch when not enough append threads
	ULONG				 m_ulLogBuffers;
	ULONG				 m_ulLogSize;

	// Logging current data
    CHAR                 m_szFileName[FILE_NAME_MAX_SIZE]; // log storage name
    LRP 				 m_lrpCurrent;              // Current LRP used
    DWORD				 m_dwStreamMode;	        // STRMMODEWRITE or STRMMODEREAD 
    ULONG				 m_ulAvailableSpace;        // Space left after write
    ULONG				 m_ulFileSize;		        // Total possible space in log

    // Checkpointing
    BOOL                 m_fDirty;          // there were changes since last flush
    HANDLE               m_hFlusherEvent;   // Event for flusher coordination
    HANDLE               m_hFlusherThread;  // Flusher thread
    HANDLE               m_hCompleteEvent;  // Event for complete coordination

    // State
    BOOL                 m_fActive;            // set AFTER starting action
    BOOL                 m_fInRecovery;        // set while in recovery stage

    // Checkpoint event
    HANDLE               m_hChkptReadyEvent;    
    ULONG				 m_ulCheckpointInterval;

    bool m_fStop;
};


// Single Global Instance of the logger
extern CLogger    g_Logger;



#endif  __XACTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactlog.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactLog.cpp

Abstract:
    Logging implementation - synchronous logging

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "QmThrd.h"
#include "CDeferredExecutionList.h"
#include "acapi.h"
#include "qmpkt.h"
#include "qmutil.h"
#include "qformat.h"
#include "xactstyl.h"
#include "xact.h"
#include "xactping.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactlog.h"
#include "logmgrgu.h"
#include <mqexception.h>

#include "qmacapi.h"

#include "xactlog.tmh"

#define MAX_WAIT_FOR_FLUSH_TIME  100000

static WCHAR *s_FN=L"xactlog";

//#include "..\..\tools\viper96\resdll\enu\msdtcmsg.h"
// Copy/paste from there
#define IDS_DTC_W_LOGENDOFFILE           ((DWORD)0x8000102AL)
#define IDS_DTC_W_LOGNOMOREASYNCHWRITES  ((DWORD)0x8000102CL)

extern void SeqPktTimedOutEx(LONGLONG liSeqID, ULONG ulSeqN, ULONG ulPrevSeqN);

typedef HRESULT  (STDAPICALLTYPE * GET_CLASS_OBJECT)(REFCLSID clsid,
													 REFIID riid,
													 void ** ppv);

// Flusher thread routine
static DWORD WINAPI FlusherThreadRoutine(LPVOID);
static void RecoveryFromLogFn(USHORT usRecType, PVOID pData, ULONG cbData);

// static CCriticalSection  g_crUnfreezing;    // Serializes calls to AcPutPacket which unfreeze incoming packets

// Single Global Instance of the logger
CLogger  g_Logger;

// Names for debug print
WCHAR *g_RecoveryRecords[] = 
{
    L"None",
    L"Empty",
    L"InSeq",
    L"XactStatus",
    L"PrepInfo",
    L"XactData",
    L"ConsRec"
};



CInSeqRecordSrmp::CInSeqRecordSrmp(
		const WCHAR* pDestination,
		const R<CWcsRef>&  StreamId,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
		const R<CWcsRef>&  HttpOrderAckDestination
        ):
		m_StaticData(liSeqID, ulNextSeqN, timeLastActive),
		m_pStreamId(StreamId),
		m_pHttpOrderAckDestination(HttpOrderAckDestination),
		m_pDestination(newwcs(pDestination))
{
													
}



CInSeqRecordSrmp::CInSeqRecordSrmp(
	const BYTE* pdata, 
	DWORD len
	)
{
	ASSERT(len >=  sizeof(m_StaticData));
	DBG_USED(len);
	memcpy(&m_StaticData, pdata,sizeof(m_StaticData));
	pdata += sizeof(m_StaticData);


	const WCHAR* pDestination = reinterpret_cast<const WCHAR*>(pdata) ;
	ASSERT(pDestination);
	ASSERT(ISALIGN2_PTR(pDestination)); //allignment  assert
	m_pDestination = newwcs(pDestination);
	

	const WCHAR* pStreamId = pDestination +wcslen(pDestination) +1;
	ASSERT((BYTE*)pStreamId < pdata +  len);
 	m_pStreamId = R<CWcsRef>(new CWcsRef(pStreamId));


	const WCHAR* pHttpOrderAckDestination = pStreamId + wcslen(pStreamId) +1;
	ASSERT((BYTE*)pHttpOrderAckDestination < pdata +  len);
	if(pHttpOrderAckDestination[0] != L'\0')
	{
		m_pHttpOrderAckDestination = R<CWcsRef>(new CWcsRef(pHttpOrderAckDestination));
	}
}


const BYTE* CInSeqRecordSrmp::Serialize(DWORD* plen)
{
	ASSERT(m_pStreamId.get() != NULL);
	ASSERT(m_pStreamId->getstr() != NULL);

	const WCHAR* pOrderQueue = (m_pHttpOrderAckDestination.get() != 0) ? m_pHttpOrderAckDestination->getstr() : L"";
	size_t DestinationQueueLen =  (wcslen(m_pDestination.get()) +1)* sizeof(WCHAR);
	size_t StreamIdlen = (wcslen(m_pStreamId->getstr()) +1)* sizeof(WCHAR);
    size_t HttpOrderAckDestinationLen = (wcslen(pOrderQueue) +1)* sizeof(WCHAR);
	

	*plen =  numeric_cast<DWORD>(sizeof(m_StaticData) + StreamIdlen + HttpOrderAckDestinationLen + DestinationQueueLen);

	m_tofree = new BYTE[*plen];
	BYTE* ptr= 	m_tofree.get();

	memcpy(ptr,&m_StaticData,sizeof(m_StaticData));
	ptr += 	sizeof(m_StaticData);

	memcpy(ptr, m_pDestination.get() , DestinationQueueLen); 
	ptr += DestinationQueueLen;
	
	memcpy(ptr, m_pStreamId->getstr() , StreamIdlen); 
	ptr += StreamIdlen;
	
	memcpy(ptr, pOrderQueue, HttpOrderAckDestinationLen); 
	
	return 	m_tofree.get();
}






//--------------------------------------
//
// Class CInSeqRecord
//
//--------------------------------------
CInSeqRecord::CInSeqRecord(
		const GUID	  *pGuidSrcQm,
		const QUEUE_FORMAT  *pQueueFormat,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
        const GUID   *pGuidDestOrTaSrcQm)
	
{
	memcpy(&m_Data.Guid,                pGuidSrcQm,         sizeof(GUID));
	memcpy(&m_Data.guidDestOrTaSrcQm,   pGuidDestOrTaSrcQm, sizeof(GUID));
    memcpy(&m_Data.QueueFormat,         pQueueFormat,       sizeof(QUEUE_FORMAT));

    m_Data.liSeqID			= liSeqID;
    m_Data.ulNextSeqN		= ulNextSeqN;
    m_Data.timeLastActive	= timeLastActive;

    if (m_Data.QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
	    wcsncpy(m_Data.wszDirectName, 
                m_Data.QueueFormat.DirectID(), 
                MY_DN_LENGTH);
	    m_Data.wszDirectName[MY_DN_LENGTH-1] = L'\0';
    }
    else
    {
        m_Data.wszDirectName[0] = L'\0';
    }
}

CInSeqRecord::~CInSeqRecord()
{
}



//--------------------------------------
//
// Class CConsolidationRecord
//
//--------------------------------------
CConsolidationRecord::CConsolidationRecord(
        ULONG ulInseq,
        ULONG ulXact)
{
    m_Data.m_ulInSeqVersion = ulInseq;
    m_Data.m_ulXactVersion  = ulXact;
}

CConsolidationRecord::~CConsolidationRecord()
{
}

//--------------------------------------
//
// Class CXactStatusRecord
//
//--------------------------------------
CXactStatusRecord::CXactStatusRecord(
    ULONG    ulIndex,
    TXACTION taAction,
    ULONG    ulFlags)
{
    m_Data.m_ulIndex    = ulIndex;
    m_Data.m_taAction   = taAction;
    m_Data.m_ulFlags    = ulFlags;
}

CXactStatusRecord::~CXactStatusRecord()
{
}

//--------------------------------------
//
// Class CPrepInfoRecord
//
//--------------------------------------

CPrepInfoRecord::CPrepInfoRecord(
    ULONG    ulIndex,
    ULONG    cbPrepInfo,
    UCHAR    *pbPrepInfo)
{
    m_pData = (PrepInfoRecord *) new CHAR[sizeof(PrepInfoRecord) +  cbPrepInfo];
    m_pData->m_ulIndex    = ulIndex;
    m_pData->m_cbPrepInfo = cbPrepInfo;
	memcpy(&m_pData->m_bPrepInfo[0], pbPrepInfo, cbPrepInfo);
}

CPrepInfoRecord::~CPrepInfoRecord()
{
    delete [] m_pData;
}

//--------------------------------------
//
// Class CXactDataRecord
//
//--------------------------------------

CXactDataRecord::CXactDataRecord(
    ULONG    ulIndex,
    ULONG    ulSeqNum,
    BOOL     fSinglePhase,
    const XACTUOW  *pUow)
{
    m_Data.m_ulIndex      = ulIndex;
    m_Data.m_ulSeqNum     = ulSeqNum;
    m_Data.m_fSinglePhase = fSinglePhase;
	memcpy(&m_Data.m_uow, pUow, sizeof(XACTUOW));
}

CXactDataRecord::~CXactDataRecord()
{
}



//--------------------------------------
//
// Class CXactStatusFlush
//
//--------------------------------------

CXactStatusFlush::CXactStatusFlush(
    CTransaction   *pCTrans, 
    TXFLUSHCONTEXT tcContext
    ) :
	m_pTrans(SafeAddRef(pCTrans)),
    m_Timer(TimeToCallback) 
{
    m_tcContext  = tcContext;
}

CXactStatusFlush::~CXactStatusFlush()
{
}

/*====================================================
CXactStatusFlush::AppendCallback
    Called per each log record after flush has been finished
=====================================================*/
VOID CXactStatusFlush::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
	CRASH_POINT(103);
    TrTRACE(XACT_LOG, "CXactStatusFlush::AppendCallback : lrp=%I64x, hr=%x", lrpAppendLRP.QuadPart, hr);

    m_hr           = hr;
    ExSetTimer(&m_Timer, CTimeDuration(0));
}

/*====================================================
CXactStatusFlush::TimeToCallback 
    Called by timer when scheduled by notification
=====================================================*/
void WINAPI CXactStatusFlush::TimeToCallback(CTimer* pTimer)
{
    CXactStatusFlush* pFlush = CONTAINING_RECORD(pTimer, CXactStatusFlush, m_Timer);
    pFlush->AppendCallbackWork();
}

/*====================================================
CXactStatusFlush::TimeToCallback
    Real work on callback
=====================================================*/
void CXactStatusFlush::AppendCallbackWork()
{
    m_pTrans->LogFlushed(m_tcContext, m_hr);
    delete this;
}

/*====================================================
CXactStatusFlush::ChkPtCallback
    Called per each checkpoint after it has been written
=====================================================*/
VOID CXactStatusFlush::ChkPtCallback (HRESULT /*hr*/, LRP /*lrpAppendLRP*/)
{

}

//--------------------------------------
//
// Class CConsolidationFlush
//
//--------------------------------------

CConsolidationFlush::CConsolidationFlush(HANDLE hEvent)
{
	m_hEvent = hEvent;
}

CConsolidationFlush::~CConsolidationFlush()
{
}

/*====================================================
CConsolidationFlush::AppendCallback
    Called per each log record after flush has been finished
=====================================================*/
VOID CConsolidationFlush::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
    TrTRACE(XACT_LOG, "CConsolidationFlush::AppendCallback : lrp=%I64x, hr=%x", lrpAppendLRP.QuadPart, hr);

    SetEvent(m_hEvent);

    delete this;
}

/*====================================================
CConsolidationFlush::ChkPtCallback
    Called per each checkpoint after it has been written
=====================================================*/
VOID CConsolidationFlush::ChkPtCallback (HRESULT /*hr*/, LRP /*lrpAppendLRP*/)
{

}

//--------------------------------------
//
// Class CChkptNotification
//
//--------------------------------------

CChkptNotification::CChkptNotification(
    HANDLE hEvent)
{
	m_hEvent = hEvent;
	m_fEventWasSet = false;
}

CChkptNotification::~CChkptNotification()
{
}

/*====================================================
CChkptNotification::AppendCallback
=====================================================*/
VOID CChkptNotification::AppendCallback(HRESULT /*hr*/, LRP /*lrpAppendLRP*/)
{
}

/*====================================================
CChkptNotification::ChkPtCallback
    Called after checkpoint has been written
=====================================================*/
VOID CChkptNotification::ChkPtCallback (HRESULT hr, LRP lrpAppendLRP)
{
	m_fEventWasSet = true;
    SetEvent(m_hEvent);
    TrWARNING(XACT_LOG, "CChkptNotification::ChkPtCallback : lrp=%I64x, hr=%x", lrpAppendLRP.QuadPart, hr);
}


bool CChkptNotification::WasEventSet()
{
	return m_fEventWasSet;
}


//--------------------------------------
//
// Class CLogger
//
//--------------------------------------
CLogger::CLogger() :
    m_fStop(false)
{
    m_pCF               = NULL;
    m_pILogInit         = NULL;
    m_pILogStorage      = NULL;
    m_ILogRecordPointer = NULL;
    m_pILogRead         = NULL;
    m_pILogWrite        = NULL;
    m_pILogWriteAsynch  = NULL;

    m_szFileName[0]     = '\0';;
    memset(&m_lrpCurrent, 0, sizeof(LRP));
    m_ulAvailableSpace  = 0;
    m_ulFileSize        = 0;
	m_uiTimerInterval   = 0;  
 	m_uiFlushInterval   = 0;  
	m_uiChkPtInterval   = 0;  
	m_uiSleepAsynch     = 0;
    m_uiAsynchRepeatLimit = 0;
    m_ulLogBuffers		= 0;
	m_ulLogSize			= 0;
    m_fDirty            = FALSE;
    m_hFlusherEvent     = NULL;
    m_hCompleteEvent    = NULL;
    m_hFlusherThread    = NULL;
    m_fActive           = FALSE;
    m_fInRecovery       = FALSE;
    m_hChkptReadyEvent  = CreateEvent(0, FALSE ,FALSE, 0);
    if (m_hChkptReadyEvent == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 106);
        throw bad_alloc();
    }
}

CLogger::~CLogger()
{
}

/*====================================================
CLogger::Finish
    Releases all log manager interfaces
=====================================================*/
void CLogger::Finish()
{
    if (m_pILogWrite)
    {
        m_pILogWrite->Release();
    }

    if (m_pILogWriteAsynch)
    {
        m_pILogWriteAsynch->Release();
    }

    if (m_ILogRecordPointer)
    {
        m_ILogRecordPointer->Release();
    }

    if (m_pILogStorage)
    {
        m_pILogStorage->Release();
    }

    if (m_pILogInit)
    {
        m_pILogInit->Release();
    }

    if (m_pILogRead)
    {
        m_pILogRead->Release();
    }
}

/*====================================================
CLogger::LogExists
    Checks existance of the log file
=====================================================*/
BOOL CLogger::LogExists()
{
  HANDLE hFile = CreateFileA(
        m_szFileName,           // pointer to name of the file
        GENERIC_READ,           // access (read-write) mode
        FILE_SHARE_READ,        // share mode
        0,                      // pointer to security attributes
        OPEN_EXISTING,          // how to create
        0,                      // file attributes
        NULL);                  // handle to file with attributes to copy)

  if (hFile != INVALID_HANDLE_VALUE)
  {
      CloseHandle(hFile);
      return TRUE;
  }
  else
  {
      return FALSE;
  }
}


//---------------------------------------------------------------------
// GetLogFileCreated
//
//	Consult registry and figure out if the logger data are in a new style
//    (there is consolidation record with checkpoint foles versions)
//---------------------------------------------------------------------
HRESULT CLogger::GetLogFileCreated(LPBOOL pfLogFileCreated) 
{
    DWORD   dwDef = 0;
    DWORD   dwLogFileCreated;
    DWORD   dwSize = sizeof(DWORD);
    DWORD   dwType = REG_DWORD ;

    LONG res = GetFalconKeyValue(
                    FALCON_LOGDATA_CREATED_REGNAME,
                    &dwType,
                    &dwLogFileCreated,
                    &dwSize,
                    (LPCTSTR) &dwDef
                    );

    if (res != ERROR_SUCCESS)
    {
        EvReportWithError(EVENT_ERROR_QM_READ_REGISTRY, res, 1, FALCON_LOGDATA_CREATED_REGNAME);
        return HRESULT_FROM_WIN32(res);
    }

    ASSERT(dwType == REG_DWORD) ;

    *pfLogFileCreated = (dwLogFileCreated == 1);
    return MQ_OK;
}

//---------------------------------------------------------------------
// SetLogFileCreated
//
//	Set Log file was created in the registry
//---------------------------------------------------------------------
HRESULT CLogger::SetLogFileCreated()
{
	DWORD	dwType = REG_DWORD;
	DWORD	dwSize = sizeof(DWORD);
    DWORD   dwVal  = 1;

    LONG rc = SetFalconKeyValue(
                    FALCON_LOGDATA_CREATED_REGNAME, 
                    &dwType,
                    &dwVal,
                    &dwSize
                    );
    if (rc == ERROR_SUCCESS)
        return MQ_OK;

    return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 20);
}



/*====================================================
CLogger::PreInit
    PreInits the logger 
=====================================================*/
HRESULT CLogger::PreInit(BOOL *pfLogFileFound, BOOL *pfNewTypeLogFile, BOOL fLogfileMustExist)
{
    // Get log filename from registry or from default
    ChooseFileName(FALCON_DEFAULT_LOGMGR_PATH, FALCON_LOGMGR_PATH_REGNAME); 

    // Load log manager and get it's CF interface
	HRESULT hr = GetLogMgr();
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        return LogHR(hr, s_FN, 20);
    }

	//
	// This registry flag indicates if a new-type log file already exists (was created).
	//
    hr = GetLogFileCreated(pfNewTypeLogFile);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        return LogHR(hr, s_FN, 20);
    }

	*pfLogFileFound = LogExists();

	//
	// Already created the log file on a previous net start msmq.
	//
	if(*pfLogFileFound && *pfNewTypeLogFile)
		return MQ_OK;

    //
	// Upgrade scenario. Naturally log file exists.
	//
	if (*pfLogFileFound && fLogfileMustExist)
		return MQ_OK;
	
	if(fLogfileMustExist || *pfNewTypeLogFile)
	{
		//
		// Just to clarify.
		//
		ASSERT(!*pfLogFileFound); 

		//
		// We excpected to find a log file but did not find it. This may happen because of low resources.
		//
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
		TrERROR(XACT_LOG, "Failed to find log file.");
		return hr;
	}

	//
	// We may also reach here with "*pfLogFileFound && !*pfNewTypeLogFile && !fLogfileMustExist" which means that a previous attempt to create
	// the log file failed, so the file exists but since the creation did not complete successfully the registry flag was not set.
	// In this case we retry to create the log file.
	//
	*pfLogFileFound = FALSE;

    hr = CreateLogFile();
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        return LogHR(hr, s_FN, 30);
    }

    hr = InitLog();						// Try to init log file
	CHECK_RETURN(1010);

	hr = CreateInitialChkpoints();	    // We need 2 checkpoints in the very beginning
	CHECK_RETURN(1020);

    hr = InitLogRead();					// Get Read interface
	CHECK_RETURN(1030);

    hr = m_pILogRead->GetCheckpoint(1, &m_lrpCurrent);
    TrTRACE(XACT_LOG, "GetCheckpoint in ReadToEnd: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1040);
    
    return MQ_OK;
}


/*====================================================
CLogger::Init
    Inits the logger data
=====================================================*/
HRESULT CLogger::Init(PULONG pulVerInSeq, 
                      PULONG pulVerXact, 
                      ULONG ulNumCheckpointFromTheEnd)
{
    HRESULT hr = MQ_OK;

	hr = InitLog();						// Try to init log file
	CHECK_RETURN(1050);

    hr = InitLogRead();					// Get Read interface
	CHECK_RETURN(1060);

    // Find LRP of the 1st record after X-st checkpoint
	hr = m_pILogRead->GetCheckpoint(ulNumCheckpointFromTheEnd, &m_lrpCurrent);
    TrTRACE(XACT_LOG, "GetCheckpoint: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1070);

    // Read 1st record after last checkpoint
    ULONG   ulSize;
	USHORT  usType;

    hr = m_pILogRead->ReadLRP(m_lrpCurrent,	&ulSize, &usType);
    TrTRACE(XACT_LOG, "ReadLRP in ReadLRP: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1080);

    if (usType != LOGREC_TYPE_CONSOLIDATION ||
        ulSize != sizeof(ConsolidationRecord))
    {
        TrERROR(XACT_LOG, "No consolidation record");
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 40);
    }

    ConsolidationRecord ConsData;
    hr = m_pILogRead->GetCurrentLogRecord((PCHAR)&ConsData);
	CHECK_RETURN(1090);

    *pulVerInSeq = ConsData.m_ulInSeqVersion;
    *pulVerXact  = ConsData.m_ulXactVersion; 

    return LogHR(hr, s_FN, 50);
}

/*====================================================
CLogger::Init_Legacy
    Inits the logger data from the old-style data after upgrade
=====================================================*/
HRESULT CLogger::Init_Legacy()
{
    HRESULT hr;

	hr = InitLog();						// Try to init log file
	CHECK_RETURN(1100);

	hr = InitLogRead();					// Get Read interface
	CHECK_RETURN(1120);

	//
    // Find LRP of the 1st record after oldest checkpoint.
	// We want to read all the logged records since the oldest checkpoint, to make sure we don't miss logged data
	// if the most recent checkpoint fails to load.
	//
	hr = m_pILogRead->GetCheckpoint(2, &m_lrpCurrent);
    TrTRACE(XACT_LOG, "GetCheckpoint: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1130);

    return MQ_OK;
}

/*====================================================
CLogger::Recover
    Recovers from the logger data
=====================================================*/
HRESULT CLogger::Recover()
{
    HRESULT hr = MQ_OK;

    try
    {
        // Starting recovery stage
        m_fInRecovery = TRUE;

		hr = ReadToEnd(RecoveryFromLogFn);	// Recover record after record
        TrTRACE(XACT_LOG, "Log init: Read to end, hr=%x", hr);
        if (hr == IDS_DTC_W_LOGENDOFFILE) 		        // normally returns EOF code
        {
            hr = S_OK;
        }
		CHECK_RETURN(1140);

        // Starting recovery stage
        m_fInRecovery = FALSE;

		ReleaseReadStream();				
		
		hr = InitLogWrite();
		CHECK_RETURN(1150);

		ReleaseLogInit();
		ReleaseLogCF();

        // Create flushing thread and coordinating event.
        m_hFlusherEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hFlusherEvent == NULL)
        {
			DWORD gle = GetLastError();
			TrERROR(XACT_LOG, "Failed to create flush thread event. %!winerr!", gle);
            return LogHR(HRESULT_FROM_WIN32(gle), s_FN, 184);
        }

		HANDLE hConsolidationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (hConsolidationEvent == NULL)
		{
			DWORD gle = GetLastError();
			TrERROR(XACT_LOG, "Failed to create consolidation event. %!winerr!", gle);
			CloseHandle(m_hFlusherEvent);
            return LogHR(HRESULT_FROM_WIN32(gle), s_FN, 184);
		}

        // Schedule first periodical flushing
        DWORD   dwDef = FALCON_DEFAULT_RM_FLUSH_INTERVAL;
        READ_REG_DWORD(m_ulCheckpointInterval,
                       FALCON_RM_FLUSH_INTERVAL_REGNAME,
                       &dwDef ) ;

        DWORD dwThreadId;
        m_hFlusherThread = CreateThread( NULL,
                                    0,
                                    FlusherThreadRoutine,
                                    hConsolidationEvent,
                                    0,
                                    &dwThreadId);

		if (m_hFlusherThread == NULL)
		{
			DWORD gle = GetLastError();
			TrERROR(XACT_LOG, "Failed to create flush thread. %!winerr!", gle);
			CloseHandle(m_hFlusherEvent);
			CloseHandle(hConsolidationEvent);
            return LogHR(HRESULT_FROM_WIN32(gle), s_FN, 184);
		}
    }
	catch(const exception&)
	{
        hr = MQ_ERROR;
	}

    return LogHR(hr, s_FN, 60);
}

/*====================================================
CLogger::Activate
    Activates the logger writing
=====================================================*/
void CLogger::Activate()
{
    m_fActive = TRUE;
}

/*====================================================
CLogger::Active
    Indicates that the logger is active
=====================================================*/
BOOL CLogger::Active()
{
    return m_fActive;
}

/*====================================================
CLogger::InRecovery
    Indicates that the logger is in a recovery stage
=====================================================*/
BOOL CLogger::InRecovery()
{
    return m_fInRecovery;
}

/*====================================================
CLogger::ChooseFileName
    Gets from Registry or from defaults file pathname
=====================================================*/
void CLogger::ChooseFileName(WCHAR *wszDefFileName, WCHAR *wszRegKey)
{
	WCHAR  wsz[1000];
    WCHAR  wszFileName[1000]; // log storage name

	// Prepare initial log file pathname
	wcscpy(wsz, L"\\");
	wcscat(wsz, wszDefFileName);

    if(!GetRegistryStoragePath(wszRegKey, wszFileName, 1000, wsz))
    {
        if (!GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, wszFileName, 1000, wsz))
        {
            wcscpy(wszFileName,L"C:");
			wcscat(wszFileName,wsz);
        }
    }

    size_t sz = wcstombs(m_szFileName, wszFileName, sizeof(m_szFileName));
    ASSERT(sz == wcslen(wszFileName));

	DBG_USED(sz);

	// Prepare logger parameters 
	DWORD dwDef;

    dwDef = FALCON_DEFAULT_LOGMGR_TIMERINTERVAL;
    READ_REG_DWORD(m_uiTimerInterval,
                   FALCON_LOGMGR_TIMERINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_FLUSHINTERVAL;
    READ_REG_DWORD(m_uiFlushInterval,
                   FALCON_LOGMGR_FLUSHINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_CHKPTINTERVAL;
    READ_REG_DWORD(m_uiChkPtInterval,
                   FALCON_LOGMGR_CHKPTINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_SLEEP_ASYNCH;
    READ_REG_DWORD(m_uiSleepAsynch,
                   FALCON_LOGMGR_SLEEP_ASYNCH_REGNAME,
                   &dwDef ) ;
    
    dwDef = FALCON_DEFAULT_LOGMGR_REPEAT_ASYNCH;
    READ_REG_DWORD(m_uiAsynchRepeatLimit,
                   FALCON_LOGMGR_REPEAT_ASYNCH_REGNAME,
                   &dwDef ) ;
    
    dwDef = FALCON_DEFAULT_LOGMGR_BUFFERS;
    READ_REG_DWORD(m_ulLogBuffers,
                   FALCON_LOGMGR_BUFFERS_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_SIZE;
    READ_REG_DWORD(m_ulLogSize,
                   FALCON_LOGMGR_SIZE_REGNAME,
                   &dwDef ) ;

}

/*====================================================
CLogger::GetLogMgr
    Loads the log mgr library and gets ClassFactory interface
=====================================================*/
HRESULT CLogger::GetLogMgr(void)
{
	HRESULT   hr;
	HINSTANCE hIns;
	FARPROC   farproc;
	GET_CLASS_OBJECT getClassObject;
	                                                                             	                                                                             
    hIns = LoadLibrary(L"MqLogMgr.dll");
	if (!hIns)
	{
		return LogHR(MQ_ERROR_LOGMGR_LOAD, s_FN, 70);
	}

	farproc = GetProcAddress(hIns,"DllGetClassObject");
	getClassObject = (GET_CLASS_OBJECT) farproc;
	if (!getClassObject)
	{
		return LogHR(MQ_ERROR_LOGMGR_LOAD, s_FN, 80);
	}

 	hr = getClassObject(
 				CLSID_CLogMgr, 
 				IID_IClassFactory, 
 				(void **)&m_pCF);
	if (FAILED(hr))
	{
		LogHR(hr, s_FN, 90);
        return MQ_ERROR_LOGMGR_LOAD;
	}
	
	return LogHR(hr, s_FN, 100);
}

/*===================================================
CLogger::InitLog
    Loads the log mgr library and gets it's interfaces
=====================================================*/
HRESULT CLogger::InitLog()
{
	// Create LogInit instance
	ASSERT(m_pCF);
	HRESULT hr = m_pCF->CreateInstance(
 					NULL, 
 					IID_ILogInit, 
 					(void **)&m_pILogInit);
	CHECK_RETURN(1160);

	// Init log manager
	ASSERT(m_pILogInit);
	hr = m_pILogInit->Init(
				&m_ulFileSize,		// Total storage capacity
				&m_ulAvailableSpace,// Available space
 				m_szFileName,		// Full file spec
 				0,					// File initialization signature
 				TRUE,				// fFixedSize
                m_uiTimerInterval,	// uiTimerInterval  
	  			m_uiFlushInterval,	// uiFlushInterval  
	  			m_uiChkPtInterval,  // uiChkPtInterval  
				m_ulLogBuffers);    // logbuffers
	if (hr != S_OK)
	{
		m_pILogInit->Release();
		m_pILogInit = NULL;

        //
        // Workaround bug 8336; logmgr might return non zero error codes
        // set the retunred value to be HRESULT value.
        //
        LogMsgHR(hr, s_FN, 110);        // Use LogMsgHR here so that we will have the failure code log
        return HRESULT_FROM_WIN32(hr);
	}

	// Get ILogStorage interface
 	hr = m_pILogInit->QueryInterface(IID_ILogStorage, (void **)&m_pILogStorage);
	CHECK_RETURN(1170);

	// Get ILogRecordPointer interface
	hr = m_pILogStorage->QueryInterface(IID_ILogRecordPointer, (void **)&m_ILogRecordPointer);
    CHECK_RETURN(1180);
	
	return LogHR(hr, s_FN, 120);
}

/*===================================================
CLogger::CreateLogFile
    Creates and preformats log file
=====================================================*/
HRESULT CLogger::CreateLogFile(void)
{
	// Get ILogCreateStorage interface
    R<ILogCreateStorage> pILogCreateStorage;
	ASSERT(m_pCF);
 	HRESULT hr = m_pCF->CreateInstance(
 					NULL, 
 					IID_ILogCreateStorage, 
 					(void **)&pILogCreateStorage.ref());
    CHECK_RETURN(1190);

	// Create storage 
	hr = pILogCreateStorage->CreateStorage(                                  
	  							m_szFileName,		// ptstrFullFileSpec       
	  							m_ulLogSize,		// ulLogSize               
 	  							0x0,				// ulInitSig               
  	  							TRUE,				// Overwrite               
 	  							m_uiTimerInterval,	
	  							m_uiFlushInterval,	
	  							m_uiChkPtInterval);	

    if (hr != S_OK)
	{
        //
        // Workaround bug 8336; logmgr might return non zero error codes
        // set the return value to be HRESULT value.
        //
    	LogMsgHR(hr, s_FN, 1200);
        return HRESULT_FROM_WIN32(hr);
    }

	
    
    hr = pILogCreateStorage->CreateStream("Streamname");                     
    CHECK_RETURN(1210);

	return LogHR(hr, s_FN, 130);
}

/*===================================================
CLogger::LogEmptyRec
    Writes empty log record
=====================================================*/
HRESULT CLogger::LogEmptyRec(void)
{
    HRESULT hr = MQ_OK;
	EmptyRecord  empty;

    AP<LOGREC> plgr = CreateLOGREC(LOGREC_TYPE_EMPTY, &empty, sizeof(empty));
	ASSERT(plgr);

    LRP lrpTmpLRP;
    LRP lrpLastPerm;
	memset((char *)&lrpLastPerm, 0, sizeof(LRP));

	// Write it down to get current lrp
	ULONG ulcbNumRecs = 0;
	ASSERT(m_pILogWrite);
	hr  =  m_pILogWrite->Append(
							plgr,
							(ULONG)1,			// # records
							&lrpTmpLRP,
							&ulcbNumRecs,
							&lrpLastPerm,		// pLRPLastPerm
							TRUE,				// fFlushNow
							&m_ulAvailableSpace);				
    TrTRACE(XACT_LOG, "Append in LogEmptyRec: lrp=%I64x, hr=%x", lrpTmpLRP.QuadPart, hr);

    if (hr == S_OK)
    {
        SetCurrent(lrpTmpLRP);
    }

	CHECK_RETURN(1220);

	if(ulcbNumRecs == 0) 
	{
		hr = HRESULT_FROM_WIN32(hr);
	}

    return LogHR(hr, s_FN, 140);
}


/*===================================================
CLogger::LogConsolidationRec
    Logs down the Consolidation Record
=====================================================*/
LRP CLogger::LogConsolidationRec(ULONG ulInSeq, ULONG ulXact, HANDLE hEvent)
{
    if (!m_fActive)
    {
		LRP NullLRP = {0};
        return NullLRP;
    }

    TrTRACE(XACT_LOG, "Log Consolidation: InSeq=%d, Xact=%d", ulInSeq,ulXact);

    CConsolidationRecord logRec(ulInSeq, ulXact);
    P<CConsolidationFlush>  pNotify = new CConsolidationFlush(hEvent);

    LRP lrp = Log(
					LOGREC_TYPE_CONSOLIDATION, 
					TRUE, 
					pNotify, 
					&logRec.m_Data,
					sizeof(ConsolidationRecord));

    CRASH_POINT(107);
    
    pNotify.detach();

	return lrp;
}


/*===================================================
CLogger::CreateInitialChkpoints
    Creates 2 initial checkpoints in the beginning of a new file
	They are needed for smooth recovery code
=====================================================*/
HRESULT CLogger::CreateInitialChkpoints(void)
{
	// Initial writing empty record 
	HRESULT hr = InitLogWrite();
	CHECK_RETURN(1230);

    hr = LogEmptyRec();
    CHECK_RETURN(1240);

	// Write 2 checkpoints
	hr = m_pILogWrite->SetCheckpoint(m_lrpCurrent);
    TrERROR(XACT_LOG, "SetCheckpoint in CreateInitialChkpoints1: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1250);

	hr = m_pILogWrite->SetCheckpoint(m_lrpCurrent);  
    TrERROR(XACT_LOG, "SetCheckpoint in CreateInitialChkpoints2: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1260);

	ReleaseWriteStream();
	return S_OK;
}

/*===================================================
CLogger::InitLogWrite
    Initializes the log for writing
=====================================================*/
HRESULT CLogger::InitLogWrite(void)
{
	ASSERT(m_pILogStorage);
	HRESULT hr = m_pILogStorage->OpenLogStream("Streamname", STRMMODEWRITE, (void **)&m_pILogWrite);
	CHECK_RETURN(1270);

 	hr = m_pILogWrite->QueryInterface(IID_ILogWriteAsynch, (void **)&m_pILogWriteAsynch);
	CHECK_RETURN(1280);

	hr = m_pILogWriteAsynch->Init(1000);	// cbMaxOutstandingWrites  ... tuning
	CHECK_RETURN(1290);

	return LogHR(hr, s_FN, 160);
}

/*===================================================
CLogger::InitLogRead
    Initializes the log for reading
=====================================================*/
HRESULT CLogger::InitLogRead(void)
{
	ASSERT(m_pILogStorage);
	HRESULT hr = m_pILogStorage->OpenLogStream("Streamname", STRMMODEREAD, (void **)&m_pILogRead); 	// also OpenLogStreamByClassID
	CHECK_RETURN(1300);

	ASSERT(m_pILogRead);
 	hr  =  m_pILogRead->ReadInit();
	CHECK_RETURN(1310);

	return LogHR(hr, s_FN, 170);
}


/*===================================================
CLogger::ReleaseWriteStream
    Releases log writing interfaces
=====================================================*/
void CLogger::ReleaseWriteStream(void)
{
	ASSERT(m_pILogWrite);
	m_pILogWrite->Release();
	m_pILogWrite = NULL;

	ASSERT(m_pILogWriteAsynch);
	m_pILogWriteAsynch->Release();
	m_pILogWriteAsynch = NULL;
}

/*===================================================
CLogger::ReleaseReadStream
    Releases log reading interfaces
=====================================================*/
void CLogger::ReleaseReadStream(void)
{
	ASSERT(m_pILogRead);
	m_pILogRead->Release();
	m_pILogRead = NULL;
}

/*===================================================
CLogger::ReleaseLogStorage
    Releases log storage interfaces
=====================================================*/
void CLogger::ReleaseLogStorage()
{
	ASSERT(m_pILogStorage);
	m_pILogStorage->Release();
	m_pILogStorage = NULL;

	ASSERT(m_ILogRecordPointer);
	m_ILogRecordPointer->Release();
	m_ILogRecordPointer = NULL;
}

/*===================================================
CLogger::ReleaseLogInit
    Releases log init interfaces
=====================================================*/
void CLogger::ReleaseLogInit()
{
	ASSERT(m_pILogInit);
	m_pILogInit->Release();
	m_pILogInit = NULL;
}

/*===================================================
CLogger::ReleaseLogCF
    Releases log class factory interfaces
=====================================================*/
void CLogger::ReleaseLogCF()
{
	ASSERT(m_pCF);
	m_pCF->Release();
	m_pCF = NULL;
}

/*===================================================
CLogger::CheckPoint
    Writes the checkpoint; blocks till the operation end
=====================================================*/
void CLogger::Checkpoint(LRP lrp)
{
    if (!m_fActive)
    {
        return;
    }

    P<CChkptNotification> pNotify = new CChkptNotification(m_hChkptReadyEvent);
    LRP lrpCkpt;

  	ASSERT(m_pILogWriteAsynch);
    HRESULT hr = EVALUATE_OR_INJECT_FAILURE(m_pILogWriteAsynch->SetCheckpoint(lrp, pNotify, &lrpCkpt));

    // Waiting till checkpoint record is written into the log
    if (FAILED(hr))
	{
		TrERROR(XACT_LOG, "Failed to invoke an asynchronous checkpoint operation. %!hresult!", hr);
		throw bad_hresult(hr);
	}

    DWORD dwResult = WaitForSingleObject(m_hChkptReadyEvent, MAX_WAIT_FOR_FLUSH_TIME);
    if (dwResult != WAIT_OBJECT_0 && !pNotify->WasEventSet())
    {
	    LogIllegalPoint(s_FN, 208);
		throw bad_hresult(MQ_ERROR);
    }

    TrTRACE(XACT_LOG, "SetCheckpoint in Checkpoint: lrp=%I64x, hr=%x", lrp.QuadPart, hr);
    return;
}

/*===================================================
CLogger::MakeCheckPoint
    Initiates checkpoint 
    Return code shows only success in initiating checkpoint, not of the writing checkpoint
=====================================================*/
BOOL CLogger::MakeCheckpoint(HANDLE hComplete)
{
    //
    // Don't do checkpoint if recovery did not finish
    //
    if (m_hFlusherEvent == NULL)
    {
          return LogBOOL(FALSE, s_FN, 217);
    }

    m_fDirty = TRUE;   
    m_hCompleteEvent = hComplete;

    SetEvent(m_hFlusherEvent);

    TrTRACE(XACT_LOG, "Log checkpoint ordered");
    return TRUE;
}

/*===================================================
CLogger::Log
    Logs really
=====================================================*/
LRP CLogger::Log(
            USHORT          usRecType,      // log record type
            BOOL            fFlush,			// flush hint
            CAsynchSupport *pCAsynchSupport,// notification element
			VOID           *pData,          // log data 
            ULONG           cbData)  	
{
    HRESULT hr;
    TrTRACE(XACT_LOG, "Log record written: type=%d, len=%d", usRecType,cbData);

    if(!m_fActive)
	{
		LRP NullLRP = {0};
		return NullLRP;
	}

	//
	// if log file space has gone so low, we only allow the flusher thread to write in it 
	// (consolidation records) while it is trying to make a checkpoint.
	//
	if(usRecType != LOGREC_TYPE_CONSOLIDATION && m_ulAvailableSpace < (m_ulLogSize / 128))
	{
		TrERROR(XACT_LOG, "Failed logging because log file is full. Available size = %d bytes", m_ulAvailableSpace);
		throw bad_alloc();
	}

    m_fDirty = TRUE;   // remembers changes since Flush

    AP<LOGREC>plgr = CreateLOGREC (usRecType, 
								   pData, 
								   cbData);  
	ASSERT(plgr);

	LRP CurrentLRP = {0};

    if (pCAsynchSupport)
    {
    	ASSERT(m_pILogWriteAsynch);

	    hr = EVALUATE_OR_INJECT_FAILURE(m_pILogWriteAsynch->AppendAsynch(
										plgr, 
										&CurrentLRP,
										pCAsynchSupport,
										fFlush,   //hint
										&m_ulAvailableSpace));

        for (UINT iRpt=0; 
             iRpt<m_uiAsynchRepeatLimit && hr == IDS_DTC_W_LOGNOMOREASYNCHWRITES; 
             iRpt++)
        {
            Sleep(m_uiSleepAsynch);
    	    hr = m_pILogWriteAsynch->AppendAsynch(
									plgr,
									&CurrentLRP,
									pCAsynchSupport,
									fFlush,   //hint
									&m_ulAvailableSpace);
            TrTRACE(XACT_LOG, "AppendAsynch in Log: lrp=%I64x, hr=%x", CurrentLRP.QuadPart, hr);
        }
	
		hr = HRESULT_FROM_WIN32(hr);

        if (FAILED(hr))
        {
            TrERROR(XACT_LOG, "Failed to log with AppendAsynch. %!hresult!", hr);
			throw bad_hresult(hr);
        }

        #ifdef _DEBUG
        if (iRpt > 0)
        {
            TrWARNING(XACT_LOG, "Log: append asynch slow-down: sleep %d msec.", iRpt*m_uiSleepAsynch);
        }
        #endif
    }
    else
    {
	    LRP lrpLastPerm;
	    ULONG ulcbNumRecs = 0;
    	ASSERT(m_pILogWrite);

        hr  =  EVALUATE_OR_INJECT_FAILURE(m_pILogWrite->Append(
										plgr,
										(ULONG)1,			// # records
										&CurrentLRP,
										&ulcbNumRecs,
										&lrpLastPerm,		
										fFlush,				// hint
										&m_ulAvailableSpace));				
        TrTRACE(XACT_LOG, "Append in Log: lrp=%I64x, hr=%x", CurrentLRP.QuadPart, hr);

		hr = HRESULT_FROM_WIN32(hr);

        if (FAILED(hr) || ulcbNumRecs == 0)
        {
            TrERROR(XACT_LOG, "Failed to log with Append. %!hresult!", hr);
            throw bad_hresult(hr);
        }
    }

    if ((m_ulAvailableSpace < m_ulLogSize / 4) && (usRecType != LOGREC_TYPE_CONSOLIDATION))
    {
        // Log is more than 3/4 full - worth to checkpoint 
        SetEvent(m_hFlusherEvent);
    }

	return CurrentLRP;
}


/*===================================================
CLogger::LogInSeqRecSrmp
    Logs down the Incoming Sequence Update record with srmp order ack
=====================================================*/
void CLogger::LogInSeqRecSrmp(
            BOOL          fFlush,			   // flush hint
            CAsynchSupport *pContext,	      // notification element
			CInSeqRecordSrmp *pInSeqRecord)  // log data 
{
    if (!m_fActive)
    {
        return;
    }

     
	ULONG ul;
	const BYTE* pData = pInSeqRecord->Serialize(&ul);

    Log(
     LOGREC_TYPE_INSEQ_SRMP, 
     fFlush, 
     pContext, 
     (void*)pData,
     ul);
}



/*===================================================
CLogger::LogInSeqRec
    Logs down the Incoming Sequence Update record
=====================================================*/
void CLogger::LogInSeqRec(
            BOOL          fFlush,			// flush hint
            CAsynchSupport *pContext,	   // notification element
			CInSeqRecord *pInSeqRecord)   // log data 
{
    if (!m_fActive)
    {
        return;
    }

    TrTRACE(XACT_LOG, "Log InSeq: SeqID=%I64d, SeqN=%d", pInSeqRecord->m_Data.liSeqID,pInSeqRecord->m_Data.ulNextSeqN);

    // Calculating real length of the record
    ULONG ul = sizeof(InSeqRecord) - 
               sizeof(pInSeqRecord->m_Data.wszDirectName) + 
               sizeof(WCHAR) * ( wcslen(pInSeqRecord->m_Data.wszDirectName) + 1 );
			  
    Log(
     LOGREC_TYPE_INSEQ, 
     fFlush, 
     pContext, 
     &pInSeqRecord->m_Data,
     ul);
}

/*===================================================
CLogger::LogXactStatusRec
    Logs down the Xact Status record
=====================================================*/
void CLogger::LogXactStatusRec(
            BOOL               fFlush,			// flush hint
            CXactStatusFlush  *pNotify,			// notification element
			CXactStatusRecord *pXactStatusRecord)  	// log data 
{
    if (!m_fActive)
    {
        return;
    }

    Log(
        LOGREC_TYPE_XACT_STATUS, 
        fFlush, 
        pNotify, 
        &pXactStatusRecord->m_Data,
        sizeof(XactStatusRecord)); 
}

/*===================================================
CLogger::LogPrepInfoRec
    Logs down the PrepareInfo record
=====================================================*/
void CLogger::LogPrepInfoRec(
            BOOL              fFlush,			// flush hint
            CXactStatusFlush *pNotify,			// notification element
			CPrepInfoRecord  *pPrepInfoRecord) 	// log data 
{
    if (!m_fActive)
    {
        return;
    }

    Log(
        LOGREC_TYPE_XACT_PREPINFO, 
        fFlush, 
        pNotify, 
        pPrepInfoRecord->m_pData,
        sizeof(PrepInfoRecord) + pPrepInfoRecord->m_pData->m_cbPrepInfo); 
}

/*===================================================
CLogger::LogXactDataRec
    Logs down the XactData record
=====================================================*/
void CLogger::LogXactDataRec(
            BOOL               fFlush,			// flush hint
            CXactStatusFlush  *pNotify,			// notification element
			CXactDataRecord   *pXactDataRecord) // log data 
{
    if (!m_fActive)
    {
        return;
    }

    Log(
        LOGREC_TYPE_XACT_DATA, 
        fFlush, 
        pNotify, 
        &pXactDataRecord->m_Data,
        sizeof(XactDataRecord)); 
}


/*===================================================
CLogger::LogXactPhase
    Logs down the Xact life phase: creation, deletion
=====================================================*/
void CLogger::LogXactPhase(ULONG ulIndex, TXACTION txAction)
{
    if (!m_fActive)
    {
        return;
    }

    CXactStatusRecord logRec(ulIndex, txAction,  TX_UNINITIALIZED);
                                                  // ignored
    TrTRACE(XACT_LOG, "Log Xact Phase: Index=%d, Action=%d", ulIndex,txAction);

    LogXactStatusRec(
        FALSE,							// flush hint
        NULL,  						    // notification element
        &logRec);						// log data 
    
    CRASH_POINT(107);
}


/*===================================================
CLogger::LogXactFlags
    Logs down the Xact Flags
=====================================================*/
void CLogger::LogXactFlags(CTransaction *pTrans)
{
    if (!m_fActive)
    {
        return;
    }

    TrTRACE(XACT_LOG, "Log Xact Flags: Index=%d, Flags=%d", pTrans->GetIndex(), pTrans->GetFlags());

    CXactStatusRecord logRec(pTrans->GetIndex(), TA_STATUS_CHANGE,  pTrans->GetFlags());
    
	g_Logger.LogXactStatusRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             &logRec);						// log data 

    CRASH_POINT(108);
}

/*===================================================
CLogger::LogXactFlagsAndWait
    Logs down the Xact Flags; asks for continue xact after flush
=====================================================*/
void CLogger::LogXactFlagsAndWait(
                              TXFLUSHCONTEXT tcContext,
                              CTransaction   *pCTrans,
                              BOOL fFlushNow //=FALSE
							  )
{
	if (!m_fActive)
	{
		pCTrans->LogFlushed(tcContext, MQ_OK);
		return;
	}

	TrTRACE(XACT_LOG, "Log Xact Flags And Wait: Index=%d, Flags=%d", pCTrans->GetIndex(),pCTrans->GetFlags());

	CXactStatusRecord logRec(pCTrans->GetIndex(),
							  TA_STATUS_CHANGE,  
							  pCTrans->GetFlags());

	//
	// This structure add a reference to the transaction.
	//
	P<CXactStatusFlush> pNotify = 
		new CXactStatusFlush(pCTrans, tcContext);

	LogXactStatusRec(
			 fFlushNow,						// flush hint
			 pNotify.get(),					// notification element
			 &logRec);						// log data 

	CRASH_POINT(104);

	pNotify.detach();
}


/*===================================================
CLogger::LogXactPrepareInfo
    Logs down the Xact Prepare Info
=====================================================*/
void CLogger::LogXactPrepareInfo(
                              ULONG  ulIndex,
                              ULONG  cbPrepareInfo,
                              UCHAR *pbPrepareInfo)
{
    if (!m_fActive)
    {
        return;
    }

    CPrepInfoRecord logRec(ulIndex, 
                            cbPrepareInfo, 
                            pbPrepareInfo);

    TrTRACE(XACT_LOG, "Log Xact PrepInfo: Index=%d, Len=%d", ulIndex,cbPrepareInfo);
        
    g_Logger.LogPrepInfoRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             &logRec);						// log data 
        
    CRASH_POINT(105);
}

/*===================================================
CLogger::LogXactData
    Logs down the Xact Data (uow, SeqNum)
=====================================================*/
void CLogger::LogXactData(              
                ULONG    ulIndex,
                ULONG    ulSeqNum,
                BOOL     fSinglePhase,
                const    XACTUOW  *puow)
{
    if (!m_fActive)
    {
        return;
    }

    CXactDataRecord logRec(ulIndex, 
                            ulSeqNum, 
                            fSinglePhase,
                            puow);

    TrTRACE(XACT_LOG, "Log Xact Data: Index=%d, SeqNum=%d, Single=%d", ulIndex,ulSeqNum,fSinglePhase);
        
    g_Logger.LogXactDataRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             &logRec);						// log data 
        
    CRASH_POINT(106);
}

/*===================================================
CLogger::CreateLOGREC
    Creates log record
=====================================================*/
LOGREC *CLogger::CreateLOGREC(USHORT usUserType, PVOID pData, ULONG cbData)
{
	ULONG ulBytelength =  sizeof(LOGREC) + cbData;

	void *pvAlloc = new char[ulBytelength];
	ASSERT(pvAlloc);

	LOGREC * plgrLogRec = (LOGREC *)pvAlloc;
	memset(pvAlloc, 0, ulBytelength);
		
	plgrLogRec->pchBuffer	 = (char *)pvAlloc + sizeof(LOGREC);
	plgrLogRec->ulByteLength = ulBytelength - sizeof(LOGREC);
	plgrLogRec->usUserType	 = usUserType;

	memcpy(plgrLogRec->pchBuffer, pData, cbData);

	return (plgrLogRec);
}


/*===================================================
CLogger::ReadToEnd
    Recovers by reading all records from the current position
=====================================================*/
HRESULT CLogger::ReadToEnd(LOG_RECOVERY_ROUTINE pf)
{
    HRESULT hr = MQ_OK;
	ASSERT(m_pILogRead);

	hr = ReadLRP(pf);
	CHECK_RETURN(1320);

    while (hr == S_OK)
	{
		hr = ReadNext(pf);
	}

	return hr;

}

/*===================================================
CLogger::ReadLRP
    Reads the currently pointed record and calls recover function
=====================================================*/
HRESULT CLogger::ReadLRP(LOG_RECOVERY_ROUTINE pf)
{
	ULONG   ulSize;
	USHORT  usType;

	ASSERT(m_pILogRead);
	HRESULT hr = m_pILogRead->ReadLRP(
							m_lrpCurrent,
							&ulSize,
							&usType);
    TrTRACE(XACT_LOG, "ReadLRP in ReadLRP: lrp=%I64x, hr=%x", m_lrpCurrent.QuadPart, hr);
	CHECK_RETURN(1340);

	AP<CHAR> pData = new CHAR[ulSize];
	ASSERT(pData);
	ASSERT(m_pILogRead);

	hr = m_pILogRead->GetCurrentLogRecord(pData);
	CHECK_RETURN(1350);

	(*pf)(usType, pData, ulSize);

	return LogHR(hr, s_FN, 250);
}


/*===================================================
CLogger::ReadNext
    Reads the next record and calls recover function
=====================================================*/
HRESULT CLogger::ReadNext(LOG_RECOVERY_ROUTINE pf)
{
	ULONG	ulSize;
	USHORT	usType;
	LRP		lrpOut;
	memset((char *)&lrpOut, 0, sizeof(LRP));

	HRESULT hr = m_pILogRead->ReadNext(&lrpOut, &ulSize, &usType);
    TrTRACE(XACT_LOG, "ReadNext in ReadNext: lrp=%I64x, hr=%x", lrpOut.QuadPart, hr);
	if (FAILED(hr))        
	{                       
    	TrWARNING(LOG, "ILogRead->ReadNext() failed. hr = %!hresult!", hr);
        return hr;          
    }


	AP<CHAR> pData = new CHAR[ulSize];
	ASSERT(pData);
	ASSERT(m_pILogRead);

	hr = m_pILogRead->GetCurrentLogRecord(pData);
	CHECK_RETURN(1370);

	(*pf)(usType, pData, ulSize);

	return LogHR(hr, s_FN, 260);
}


/*===================================================
CLogger::FlusherEvent()
    Get method for the flusher coordination event 
=====================================================*/
HANDLE CLogger::FlusherEvent()
{
    return m_hFlusherEvent;
}


/*===================================================
CLogger::FlusherThread()
    Get method for the flusher thread handle
=====================================================*/
inline HANDLE CLogger::FlusherThread()
{
    return m_hFlusherThread;
}


/*===================================================
CLogger::Dirty()
    Get method for the Dirty flag - meaning logs since flush
=====================================================*/
BOOL CLogger::Dirty()
{
    return m_fDirty  && m_fActive;
}

/*===================================================
CLogger::ClearDirty()
    Set method for the Dirty flag - clearing away the flag
=====================================================*/
void CLogger::ClearDirty()
{
    m_fDirty = FALSE;
}


/*===================================================
CLogger::SignalCheckpointWriteComplete()
    Sets the event signalling write complete
=====================================================*/
void CLogger::SignalCheckpointWriteComplete()
{
    if (m_hCompleteEvent)
    {
        SetEvent(m_hCompleteEvent);
        m_hCompleteEvent = NULL;
    }
}

/*====================================================
FlusherThreadRoutine
    Thread routine of the flusher thread
=====================================================*/
static DWORD WINAPI FlusherThreadRoutine(LPVOID p)
{
    HRESULT hr;
    HANDLE  hFlusherEvent = g_Logger.FlusherEvent();
    HANDLE hConsolidationEvent = HANDLE(p);
	DWORD CheckpointInterval = g_Logger.GetCheckpointInterval();
	
    for (;;)
    {
		ULONG OldInSecHashPingNo = g_pInSeqHash->PingNo();
		ULONG OldRMPingNo = g_pRM->PingNo();	

		try
		{
			// Wait for the signal
			DWORD dwResult = WaitForSingleObject(hFlusherEvent, CheckpointInterval);
			if (dwResult != WAIT_OBJECT_0 && dwResult != WAIT_TIMEOUT)
			{
				DWORD gle = GetLastError();
				LogNTStatus(gle, s_FN, 209);
				throw bad_win32_error(gle);
			}

			// 
			// NOTE: If we are stopping the service or shutting down, we do not want
			// to write the checkpoint, just terminate gracefully
			// We will use g_logger.Stoped througout the code to immediately break if
			// we are requested to stop/shutdown the process
			//
			if (g_Logger.Stoped())
				break;

			TrTRACE(XACT_LOG, "Log checkpoint awakened");

			if(g_Logger.Dirty())
			{
				TrWARNING(XACT_LOG, "Log checkpoint executed");

				// Writing consolidation record
				//    it will be first read at recovery
				LRP ConsolidationLRP = g_Logger.LogConsolidationRec(OldInSecHashPingNo + 1, OldRMPingNo + 1, hConsolidationEvent);
				
				TrTRACE(XACT_LOG, "Log checkpoint: logger.ConsolidationRecord.");
				CRASH_POINT(403);

				if (g_Logger.Stoped())
					break;

				// Wait till consolidation record is notified 
				//    it covers all logging that started before this one
				dwResult = WaitForSingleObject(hConsolidationEvent, MAX_WAIT_FOR_FLUSH_TIME);

				if (g_Logger.Stoped())
					break;

				if (dwResult != WAIT_OBJECT_0)
				{
					DWORD gle = GetLastError();
					LogIllegalPoint(s_FN, 211);
					TrERROR(XACT_LOG, "Failed wait for consolidation event. %!winerr!", GetLastError());
					ASSERT(0);
					//
					// Normally we should not reach this point.
					// We throw an exception here since we expect logmgr bugs. 
					//
					throw bad_win32_error(gle);
				}
				CRASH_POINT(404);

				//
				// Starting anew to track changes. Cannot clear earlier since logging the consolidation record sets the dirty flag!
				//
				g_Logger.ClearDirty();

				// Saving the whole InSeqHash in ping-pong file
				hr = g_pInSeqHash->Save();
				if (FAILED(hr))
				{
					TrERROR(XACT_LOG, "Failed to save the inseq hash state to a checkpoint file. %!hresult!", hr);
					throw bad_hresult(hr);
				}

				TrTRACE(XACT_LOG, "Log checkpoint: inseq.save: hr=%x", hr);
				CRASH_POINT(401);

				if (g_Logger.Stoped())
					break;

				// Saving the transactions persistant data
				hr = g_pRM->Save();
				if (FAILED(hr))
				{
					TrERROR(XACT_LOG, "Failed to save the transactions state to a checkpoint file. %!hresult!", hr);
					throw bad_hresult(hr);
				}
				TrTRACE(XACT_LOG, "Log checkpoint: rm.save: hr=%x", hr);

				CRASH_POINT(402);

				if (g_Logger.Stoped())
					break;

				// Writing checkpoint (ONLY if everything was saved fine)
				//    it marks where next recovery will start reading
				g_Logger.Checkpoint(ConsolidationLRP);

				TrTRACE(XACT_LOG, "Log checkpoint: logger.checkpoint: hr=%x", hr);

				CRASH_POINT(405);
			}

			// Inform caller that checkpoint is ready
			g_Logger.SignalCheckpointWriteComplete();

			if(g_Logger.Stoped())
				break;

			continue;
		}
		catch(const bad_alloc&)
		{
			TrERROR(XACT_LOG, "Checkpoint flush failed because of insufficient resources.");
		}
		catch(const bad_hresult& e)
		{
			TrERROR(XACT_LOG, "Checkpoint flush failed. %!hresult!", e.error());
		}
		catch(const bad_win32_error& e)
		{
			TrERROR(XACT_LOG, "Checkpoint flush failed. %!winerr!", e.error());
		}
		catch(const exception&)
		{
			TrERROR(XACT_LOG, "Flusher thread was hit by exception.");
		}

		//
		// If we don't restore the old ping numbers, two failure in a row might leave us without valid checkpoint files!
		//
		g_pInSeqHash->PingNo() = OldInSecHashPingNo;
		g_pRM->PingNo() = OldRMPingNo;

		if (g_Logger.Stoped())
			break;
		
		//
		// If we failed to checkpoint we rest here for a while. This is since we assume that most common reason
		// for failure is low resources. Resting for 5 seconds will give the system a chance to recover from 
		// the low resources situation.
		//
		Sleep(5000);
    }

	//
	// The service was stopped or shut down
	// Clean up and exit
	//
	CloseHandle(hFlusherEvent);
	CloseHandle(hConsolidationEvent);
	return 0;
}



DWORD CLogger::GetCheckpointInterval()
{
	return m_ulCheckpointInterval;
}


inline bool CLogger::Stoped() const
{
    return m_fStop;
}


inline void CLogger::SignalStop()
{
    m_fStop = true;
}


/*====================================================
XactLogSignalExitThread
    Signals the logger thread to stop
    The function returns the logger thread handle
=====================================================*/
HANDLE XactLogSignalExitThread()
{
    g_Logger.SignalStop();
    if(!SetEvent(g_Logger.FlusherEvent()))
    {
        LogBOOL(FALSE, s_FN, 216);
        return INVALID_HANDLE_VALUE; 
    }

	return g_Logger.FlusherThread();
}

static void RecoveryFromLogFn(USHORT usRecType, PVOID pData, ULONG cbData)
{
    TrTRACE(XACT_LOG, "Recovery record: %ls (type=%d, len=%d)", g_RecoveryRecords[usRecType], usRecType,cbData);

    switch(usRecType)
    {
    case LOGREC_TYPE_EMPTY :
    case LOGREC_TYPE_CONSOLIDATION :
        break;

    case LOGREC_TYPE_INSEQ :
	case LOGREC_TYPE_INSEQ_SRMP:
        g_pInSeqHash->SequnceRecordRecovery(usRecType, pData, cbData);
        break;

	

    case LOGREC_TYPE_XACT_STATUS :
    case LOGREC_TYPE_XACT_DATA:
    case LOGREC_TYPE_XACT_PREPINFO:
        g_pRM->XactFlagsRecovery(usRecType, pData, cbData);
        break;

    default:
		ASSERT(0);
        break;
    }
}


/*====================================================
CLogger::CompareLRP
    Compares LRP 
=====================================================*/
DWORD CLogger::CompareLRP(LRP lrpLRP1, LRP lrpLRP2)
{
    ASSERT(m_ILogRecordPointer);
    return m_ILogRecordPointer->CompareLRP(lrpLRP1, lrpLRP2);
}


/*====================================================
CLogger::SetCurrent
    Collects highest LRP 
=====================================================*/
void CLogger::SetCurrent(LRP lrpLRP)
{
	ASSERT(m_ILogRecordPointer);
    ASSERT (m_ILogRecordPointer->CompareLRP(lrpLRP, m_lrpCurrent) == 2);

	m_lrpCurrent = lrpLRP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactmode.h ===
/*++
    Copyright (c) 1998  Microsoft Corporation

Module Name:
    xactmode.h

Abstract:
    This module deals with figuring out the transactional mode
	(g_fDefaultCommit)

Author:
    Amnon Horowitz (amnonh)

--*/

extern BOOL	g_fDefaultCommit;
HRESULT ConfigureXactMode();
HRESULT ReconfigureXactMode();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactout.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactOut.h

Abstract:
    Exactly-once sender implementation classes:
        CSeqPacket      - Sequential Packet,
        COutSequence    - Outgoing Sequence,
        COutSeqHash     - Outgoing Sequences Hash table

Author:
    AlexDad

--*/

#ifndef __XACTOUT_H__
#define __XACTOUT_H__

#include <Ex.h>
#include "msgprops.h"
#include <ref.h>

#define ORDER_ACK_TITLE       (L"QM Ordering Ack")

HRESULT QMInitOrderQueue();

BOOL WINAPI ReceiveOrderCommands(CMessageProperty* pmp, QUEUE_FORMAT* pqf);

void SeqPktTimedOut(CBaseHeader * pPktBaseHdr, CPacket * pDriverPacket, BOOL fTimeToBeReceived);

DWORD HashGUID(const GUID &guid);

class COutSeqHash;  // forward declaration

//-------------------------------------
// Ordering ack data format
//-------------------------------------
#pragma pack(push, 1)
struct OrderAckData {
    LONGLONG  m_liSeqID;
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
    OBJECTID  MessageID;
};
#pragma pack(pop)


//---------------------------------------------------------------------
//
// class CKeyDirection (needed for CMap)
//
//---------------------------------------------------------------------
class CKeyDirection : public QUEUE_FORMAT
{
public:
    CKeyDirection(const QUEUE_FORMAT *pqf);
    CKeyDirection();
    CKeyDirection(const CKeyDirection &key);
    ~CKeyDirection();

    CKeyDirection &operator=(const CKeyDirection &key2 );
};

// CMap helper functions
template<>
UINT AFXAPI HashKey(const CKeyDirection& key);

//---------------------------------------------------------
//
//  class CSeqPacket
//
//---------------------------------------------------------

class CSeqPacket {

public:
    CSeqPacket(CQmPacket *);
    CSeqPacket();
    ~CSeqPacket();

    // Get / Set for local fields
    inline CQmPacket *Pkt() const;
    void   SetClass(USHORT usClass);
    inline USHORT     GetClass(void);

    // Get for  CQmPacket's fields
    inline LONGLONG   GetSeqID(void) const;
    inline ULONG      GetSeqN(void) const;
    inline LONG       GetHighSeqID(void) const;
    inline DWORD      GetLowSeqID(void) const;

    inline ULONG      GetPrevSeqN(void) const;
    inline void       SetPrevSeqN(ULONG ulPrevSeqN);

    // Driver operations on the packet
    HRESULT           AcFreePacket();
    void              DeletePacket(USHORT usClass);
    HRESULT           Save();
    void AssignPacket(CQmPacket *);

private:

    CQmPacket *m_pQmPkt;              // QM Packet ptr
    USHORT    m_usClass;              // Packet class (status for the journal)

    LONGLONG  m_liSeqID;              // Replicas from the packet
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
};

//---------------------------------------------------------
//
//  class COutSequence
//
//---------------------------------------------------------

class COutSequence: public CReference
{

public:
    COutSequence(LONGLONG liSeqID,
                 const QUEUE_FORMAT* pqf,
				 HANDLE hQueue,
				 const CSenderStream* pSenderStream
				 );

	bool IsValidAck(const CSenderStream* pSenderStream)const;

    inline LONGLONG SeqID(void)     const;    // Get: Sequence ID
    inline LONG     HighSeqID(void) const;
    inline DWORD    LowSeqID(void)  const;

    void   SetAckSeqN(ULONG SeqN);            // Set/Get: max  acked number
    inline ULONG AckSeqN(void)      const;

    CKeyDirection *KeyDirection(void);        // Get: direction

    inline ULONG ResendIndex(void)  const;    // Current resend index
    inline void  ClearResendIndex(void);	  // Reset the resend index to zero
    void  PlanNextResend(BOOL fImmediate);    // Schedule next resend
    void  StartResendTimer(BOOL fImmediate);  // Schedules first resend

    inline ULONG LastResent(void);            // Returns the number of the last resent packet; INFINITE means no resend state
    inline void  LastResent(ULONG ul);        // Sets it

    inline BOOL  IsEmpty(void) const;         // Indicates there is no Qm-owned packets
    inline BOOL  OnHold(void) const;          // Indicates there the sequence is on hold (blocked by previous sequences)
    inline BOOL  Advanced(void);              // Indicates acking advance; remembers m_ulPrevAckSeqN
                                              // NB - should be called from one place only

    BOOL  Lookup(ULONG ulSeqN,                // Looks for the packet with the given SeqN
                 CSeqPacket **ppSeqPkt);

    void Insert(CQmPacket *pPkt);             // Inserts new QM packet into the sequence

    BOOL  Add(ULONG      ulSeqN,              // Adds the QM packet to the sequence
              CQmPacket  *pPkt,
              CSeqPacket **ppSeqPkt);

    BOOL  PreSendProcess(CQmPacket* pPkt);
    void  PostSendProcess(CQmPacket* pPkt,
                         ULONG ulMaxTTRQ);

    void  RequestDelete();                    // Marks the sequence for deletion and plans resend
    BOOL  Delete(ULONG ulSeqN,                // Deletes the packet from the list, frees memory
                 USHORT usClass);             //     class for NACK/ACK

    void  SeqAckCame(ULONG ulSeqN);           // Modifies everything when SeqAck came
    void  BadDestAckCame(ULONG ulSeqN,        // Resolves all pkts up to pointed as BadDestQueue
                       USHORT usClass);

    void  TreatOutSequence();                 // Periodical treatment of outgoing sequence
    static void WINAPI
          TimeToResendOutSequence(CTimer* pTimer);

    void  ResendSequence();                   // Resends the whole sequence
    BOOL  ResendSeqPkt(CSeqPacket *pSeqPkt);  // Resends the seq packet

    void UpdateOnHoldStatus(CQmPacket* pPkt); // Updates On Hold status of the sequence

    R<COutSequence> GetPrevSeq();                 // Previous sequence in specific direction
    void SetPrevSeq(R<COutSequence> p);
    R<COutSequence> GetNextSeq();                 // Next     sequence in specific direction
    void SetNextSeq(R<COutSequence> p);
    void GetLastAckForDirection(              // Finds out last ack for the whole direction
           LONGLONG *pliAckSeqID,
           ULONG *pulAckSeqN);


    //
    // Admin Functions
    //
    HRESULT GetUnackedSequence(
        LONGLONG* pliSeqID,
        ULONG* pulSeqN,
        ULONG* pulPrevSeqN,
        BOOL fFirst
        ) const;

    DWORD   GetUnackedCount  (void) const;
    time_t  GetLastAckedTime (void) const;
    DWORD   GetLastAckCount  (void) const;
    DWORD   GetResendInterval(void) const;
    time_t  GetNextResendTime(void) const;
    void    AdminResend      (void);

private:
    ~COutSequence();

private:
    LONGLONG   m_liSeqID;               // sequence ID
    BOOL       m_fMarkedForDelete;      // flag of the delete request

    ULONG      m_ulResendCycleIndex;    // index of the current resend cycle
    time_t     m_NextResendTime;        // time of the next resend

    time_t     m_timeLastAck;           // time of creation or last ack coming

    ULONG      m_ulLastAckSeqN;         // Max known acked number
    ULONG      m_ulPrevAckSeqN;         // Max known acked number at the previous resend iteration
    ULONG      m_ulLastAckCount;        // SeqN of duplicate order ack received

    //
    // Key controls for the algorithm
    //
    ULONG      m_ulLastResent;          // SeqN of the last packet that has been resent by ResendSequence
                                        //   We do not send anything bigger
                                        //   INFINITE means NOT ResendInProgress, so send everything

    // List of unacked packets for resend
    CList<CSeqPacket *, CSeqPacket *&>         m_listSeqUnackedPkts;

    // Direction: destination format name
    CKeyDirection m_keyDirection;

    // Links in the double-linked list of sequences per direction
    R<COutSequence> m_pPrevSeq;
    R<COutSequence> m_pNextSeq;

    // Resending timer
    CTimer m_ResendTimer;
    BOOL m_fResendScheduled;

	// Queue handle
	HANDLE m_hQueue;

    // Flag of sequence On Hold - if set, messages cannot be sent
    BOOL m_fOnHold;
	P<CSenderStream> m_pSenderStream;
};

//---------------------------------------------------------
//
//  class COutSeqHash
//
//---------------------------------------------------------

class COutSeqHash  //: public CPersist
{
    public:
        COutSeqHash();
        ~COutSeqHash();

		R<COutSequence> FindLastSmallerSequence(		  // Find last smaller sequence from direction
		        	 LONGLONG liSeqID,
		        	 CKeyDirection *pkeyDirection);
		
        void LinkSequence(                            // Links the sequence into the SeqID-based and Direction-based structures
                     LONGLONG liSeqID,
                     CKeyDirection *pkeyDirection,
                     R<COutSequence> pOutSeq);
        void SeqAckCame(                              // Reflects coming of the Seq ACK
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     const QUEUE_FORMAT* pqf
					 );

        BOOL Consult(                                 // Looks for the sequence (not creating it)
                     LONGLONG liSeqID,
                     R<COutSequence>& pOutSeq) const;

        R<COutSequence> ProvideSequence(                // Looks for the sequence or creates it
                     LONGLONG liSeqID,
                     const QUEUE_FORMAT *pqf,
					 const CSenderStream* pSenderStream,
                     IN bool bInSend
					 );

        void  AckedPacket(                            // Marks acked packet
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     CQmPacket* pPkt);

        BOOL  Delete(                                 // Deletes packet
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     USHORT usClass);

        void  DeleteSeq(LONGLONG liSeqId);            // Deletes the sequence

        BOOL PreSendProcess(CQmPacket* pPkt,
                            IN bool bInSend);        // Preprocesses the message before send

        void PostSendProcess(CQmPacket* pPkt);       // Postprocesses the message after send

        void NonSendProcess(                         // PostProcesses the case of non-sent message
                    CQmPacket* pPkt,
                    USHORT usClass);

        void KeepDelivered(                          // Moves the packet to the list of delivered
                    CSeqPacket *pSeqPkt);

        void ResolveDelivered(
                    OBJECTID* pMsgId,
                    USHORT   usClass);

        BOOL LookupDelivered(                        // Looks up the packet in the delivered map
                    OBJECTID   *pMsgId,
                    CSeqPacket **ppSeqPkt);

        void SeqPktTimedOutEx(                       // Processes TTRQ timeout for non-delivered pkt
                    CQmPacket *pPkt,
                    CBaseHeader* pPktBaseHdr);

        HRESULT TreatOutgoingOrdered();              // For each sequence, recalculates Previous and adds TimedOut records

        //
        // Administration functions
        //
        HRESULT GetLastAck(
             LONGLONG liSeqID,
             ULONG& ulSeqN
             ) const;

        HRESULT GetUnackedSequence(
            LONGLONG liSeqID,
            ULONG* pulSeqN,
            ULONG* pulPrevSeqN,
            BOOL fFirst
            ) const;

        DWORD   GetUnackedCount(LONGLONG liSeqID)     const;
        time_t  GetLastAckedTime(LONGLONG liSeqID)    const;
        DWORD   GetLastAckCount(LONGLONG liSeqID)     const;
        DWORD   GetResendInterval(LONGLONG liSeqID)   const;
        time_t  GetNextResendTime(LONGLONG liSeqID)   const;
        DWORD   GetAckedNoReadCount(LONGLONG liSeqID) const;
        DWORD   GetResendCount(LONGLONG liSeqID)      const;
        DWORD   GetResendIndex(LONGLONG liSeqID)      const;
        void    AdminResend(LONGLONG liSeqID)         const;

    private:
        // Mapping of all current outgoing sequences
        CMap<LONGLONG, LONGLONG &, R<COutSequence>, R<COutSequence>&>m_mapOutSeqs;

        // Mapping Msg ID to waiting ack packet
        CMap<DWORD, DWORD, CSeqPacket *, CSeqPacket *&> m_mapWaitAck;

        // Mapping Msg ID to MSG that was acked and have not gotten order ack yet.
        CMap<DWORD, DWORD, USHORT, USHORT> m_mapAckValue;

        // Mapping of all current outgoing directions
        CMap<CKeyDirection, const CKeyDirection &, R<COutSequence>, R<COutSequence>&>m_mapDirections;

        // Data for persistency control (via 2 ping-pong files)
        ULONG      m_ulPingNo;                    // Current counter of ping write
        ULONG      m_ulSignature;                 // Saving signature

        ULONG      m_ulMaxTTRQ;                   // last TTRQ absolutee time as learned from the driver
        //
        // Management Function
        //
        enum INFO_TYPE {
            eUnackedCount,
            eLastAckTime,
            eLastAckCount,
            eResendInterval,
            eResendTime,
            eResendIndex,
        };

        DWORD_PTR
        GetOutSequenceInfo(
            LONGLONG liSeqID,
            INFO_TYPE InfoType
            ) const;
};

//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------

extern COutSeqHash       g_OutSeqHash;
extern CCriticalSection  g_critOutSeqHash;

//---------------------------------------------------------
//
//  inline implementations
//
//---------------------------------------------------------

inline USHORT CSeqPacket::GetClass(void)
{
    return m_usClass;
}

inline CQmPacket *CSeqPacket::Pkt(void) const
{
    return(m_pQmPkt);
}

inline LONGLONG CSeqPacket::GetSeqID(void) const
{
    return m_liSeqID;
}

inline ULONG CSeqPacket::GetSeqN(void) const
{
    return m_ulSeqN;
}

inline LONG CSeqPacket::GetHighSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->HighPart;
}

inline DWORD CSeqPacket::GetLowSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->LowPart;
}

inline ULONG CSeqPacket::GetPrevSeqN(void) const
{
    return m_pQmPkt->GetPrevSeqN();
}

inline void CSeqPacket::SetPrevSeqN(ULONG ulPrevSeqN)
{
    m_pQmPkt->SetPrevSeqN(ulPrevSeqN);
    m_ulPrevSeqN = ulPrevSeqN;
}

inline LONGLONG COutSequence::SeqID(void) const
{
    return m_liSeqID;
}

inline LONG COutSequence::HighSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->HighPart;
}

inline DWORD COutSequence::LowSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->LowPart;
}

inline ULONG COutSequence::AckSeqN(void) const
{
    return m_ulLastAckSeqN;
}

inline ULONG COutSequence::LastResent()
{
    return m_ulLastResent;
}

inline void COutSequence::LastResent(ULONG ul)
{
    m_ulLastResent = ul;
    return;
}

inline ULONG COutSequence::ResendIndex(void) const
{
    return(m_ulResendCycleIndex);
}

inline void COutSequence::ClearResendIndex(void)
{
    m_ulResendCycleIndex = 0;
    return;
}

inline BOOL  COutSequence::Advanced()
{
    BOOL f =  (m_ulLastAckSeqN > m_ulPrevAckSeqN);
    m_ulPrevAckSeqN = m_ulLastAckSeqN;
    return f;
}

inline BOOL COutSequence::IsEmpty(void) const
{
    return (m_listSeqUnackedPkts.IsEmpty());
}

inline BOOL COutSequence::OnHold(void) const
{
    return (m_fOnHold);
}


inline
DWORD
COutSequence::GetUnackedCount(
    void
    ) const
{
    return  m_listSeqUnackedPkts.GetCount();
}

inline
time_t
COutSequence::GetLastAckedTime(
    void
    ) const
{
    return m_timeLastAck;
}

inline
time_t
COutSequence::GetNextResendTime(
    void
    ) const
{
    return m_NextResendTime;
}

inline
DWORD
COutSequence::GetLastAckCount(
    void
    ) const
{
    return m_ulLastAckCount;
}


inline R<COutSequence> COutSequence::GetPrevSeq()
{
    return m_pPrevSeq;
}

inline R<COutSequence> COutSequence::GetNextSeq()
{
    return m_pNextSeq;
}

inline void COutSequence::SetPrevSeq(R<COutSequence> p)
{
    m_pPrevSeq = p;
}

inline void COutSequence::SetNextSeq(R<COutSequence> p)
{
    m_pNextSeq = p;
}

inline CKeyDirection *COutSequence::KeyDirection(void)
{
    return &m_keyDirection;
}

inline
DWORD
COutSeqHash::GetUnackedCount(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eUnackedCount));
}

inline
time_t
COutSeqHash::GetLastAckedTime(
    LONGLONG liSeqID
    ) const
{
    return GetOutSequenceInfo(liSeqID,eLastAckTime);
}

inline
DWORD
COutSeqHash::GetLastAckCount(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eLastAckCount));
}

inline
DWORD
COutSeqHash::GetResendInterval(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eResendInterval));
}

inline
time_t
COutSeqHash::GetNextResendTime(
    LONGLONG liSeqID
    ) const
{
    return GetOutSequenceInfo(liSeqID,eResendTime);
}

inline
DWORD
COutSeqHash::GetResendIndex(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eResendIndex));
}

inline LONG HighSeqID(LONGLONG ll)
{
    return ((LARGE_INTEGER*)&ll)->HighPart;
}

inline DWORD LowSeqID(LONGLONG ll)
{
    return ((LARGE_INTEGER*)&ll)->LowPart;
}

#endif __XACTOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactout.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactOut.cpp

Abstract:
    Current Outgoing Sequences objects implementation

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "qmpkt.h"
#include "cqmgr.h"
#include "privque.h"
#include "fn.h"
#include "phinfo.h"
#include "phuser.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactlog.h"
#include "cqpriv.h"

#include "qmacapi.h"

#include "xactout.tmh"

extern HANDLE      g_hAc;
extern LPTSTR      g_szMachineName;


static WCHAR *s_FN=L"xactout";

// Provides WARNING dbgmsgs on changing send/bypass status
static BOOL s_SendingState = FALSE;

// Exactly-one sequences resend time cycle
ULONG  g_aulSeqResendCycle[] = {
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND10_TIME*1000}; // 1: 6h

// Delay for local timeout of non-received messages
ULONG   g_ulDelayExpire = INFINITE;

//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------
COutSeqHash       g_OutSeqHash;        // Structure keeps all outgoing sequences

//
// This critical section is initialized for preallocated resources.
// This means it does not throw exception when entered.
//
CCriticalSection  g_critOutSeqHash(CCriticalSection::xAllocateSpinCount);    // Serializes all outgoing hash activity on the highest level

//--------------------------------------
//
// Class  CSeqPacket
//
//--------------------------------------

CSeqPacket::CSeqPacket(CQmPacket *pPkt)
{
    m_pQmPkt     = pPkt;
    m_usClass    = 0;
    m_liSeqID    = m_pQmPkt->GetSeqID();
    m_ulSeqN     = m_pQmPkt->GetSeqN();
}

CSeqPacket::CSeqPacket()
{
    m_pQmPkt     = NULL;
}

CSeqPacket::~CSeqPacket()
{
	if(m_pQmPkt != NULL)
	{
		delete m_pQmPkt;
	}
}

void CSeqPacket::AssignPacket(CQmPacket *pPkt)
{
    m_pQmPkt     = pPkt;
    m_usClass    = 0;
    m_liSeqID    = m_pQmPkt->GetSeqID();
    m_ulSeqN     = m_pQmPkt->GetSeqN();
}

void CSeqPacket::SetClass(USHORT usClass)
{
    //Don't reset the final receive acks
    if (m_usClass == MQMSG_CLASS_ACK_RECEIVE || MQCLASS_NEG_RECEIVE(m_usClass))
    {
        return;
    }

    // Don't reset the final delivery acks
    if ((usClass == MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT) && (m_usClass != 0))
    {
        return;
    }

    // keeping class provides with last known state
    if (usClass)
	{
		m_usClass = usClass;
	}
}

HRESULT CSeqPacket::AcFreePacket()
{
	ASSERT(m_pQmPkt != NULL);
    QmAcFreePacket(
			   	   m_pQmPkt->GetPointerToDriverPacket(),
			   	   m_usClass,
   			       eDeferOnFailure);

	return MQ_OK;	
}

/*====================================================
CSeqPacket::DeletePacket
    Deletes packet
=====================================================*/
void CSeqPacket::DeletePacket(USHORT usClass)
{
    TrTRACE(XACT_SEND, "Exactly1 send: DeletePacket: SeqN=%d, SeqID=%x / %x, Class %x -> %x", GetSeqN(), GetHighSeqID(), GetLowSeqID(), GetClass(), usClass);

    // Keep the class
    SetClass(usClass);

    // Process deleting
    switch(usClass)
    {
    case MQMSG_CLASS_ACK_REACH_QUEUE:
        // Packet was delivered
        g_OutSeqHash.KeepDelivered(this);   // Move to the delivered list
        break;

    case MQMSG_CLASS_ACK_RECEIVE:
        // Packet was received
        // Do we need ACK here?
        AcFreePacket();                     // Kill the packet
        delete this;
        break;

    case 0:
        // We don't know (e.g. on going down)
        delete this;
        break;

    default:
        //  Send negative acknowledgment for TTRQ and TTBR/local
        ASSERT(MQCLASS_NACK(usClass));
        if((usClass == MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT ||
            usClass == MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER) &&
           MQCLASS_MATCH_ACKNOWLEDGMENT(usClass, Pkt()->GetAckType()))
        {
            Pkt()->CreateAck(usClass);
        }

        // Killing the packet
        AcFreePacket();
        delete this;
        break;
    }
}

// Stores the packet and waits till store finish
HRESULT CSeqPacket::Save()
{
    return LogHR(m_pQmPkt->Save(), s_FN, 20);
}

//--------------------------------------
//
// Class  COutSequence
//
//--------------------------------------


/*====================================================
COutSequence::COutSequence - Constructor
=====================================================*/
COutSequence::COutSequence(
	LONGLONG liSeqID,
	const QUEUE_FORMAT* pqf,
	HANDLE hQueue,
	const CSenderStream* pSenderStream
	) :
	m_ResendTimer(TimeToResendOutSequence),
    m_keyDirection(CKeyDirection(pqf)),
	m_pSenderStream(pSenderStream ? new CSenderStream(*pSenderStream) : NULL)
{
    m_liSeqID            = liSeqID;
    m_timeLastAck        = MqSysTime();
    m_pPrevSeq           = NULL;
    m_pNextSeq           = NULL;
    m_ulLastAckSeqN      = 0;
    m_ulPrevAckSeqN      = 0;
    m_ulLastResent       = INFINITE;        // means we are not in the resending state
    m_fMarkedForDelete   = FALSE;
    m_fResendScheduled   = FALSE;
    m_ulResendCycleIndex = 0;
    m_NextResendTime     = 0;
    m_ulLastAckCount     = 0;
    m_hQueue             = hQueue;
    m_fOnHold            = TRUE;

	R<COutSequence> pSeq = SafeAddRef(this);
    g_OutSeqHash.LinkSequence(liSeqID, &m_keyDirection, pSeq);
}


//
// Check if the order ack messages is in response outgoing delivery we have.
// It might be an hacker packet so we should match the sender stream on the response
// we the sender stream we have.
//
bool COutSequence::IsValidAck(const CSenderStream* pSenderStream)const
{
	if(m_pSenderStream != NULL)
	{
		if(pSenderStream == NULL)
			return false;

		return *m_pSenderStream == *pSenderStream;
	}
	return true;
}



/*====================================================
COutSequence::~COutSequence  - Destructor
=====================================================*/
COutSequence::~COutSequence()
{
    ASSERT(!m_ResendTimer.InUse());
}

/*====================================================
COutSequence::SetAckSeqN
    Sets the m_ulLastAckSeqN as max Ack seen so far
=====================================================*/
void COutSequence::SetAckSeqN(ULONG ulSeqN)
{
    if (ulSeqN > m_ulLastAckSeqN)
    {
        m_ulLastAckSeqN = ulSeqN;
        m_ulLastAckCount = 0;
    }

    ++m_ulLastAckCount;
}

/*====================================================
COutSequence::Add
    Adds new CSeqPacket to the Sequence.
    List is sorted by SeqN (increasing order).
    No duplicates allowed (otherwise returns FALSE)
=====================================================*/
BOOL COutSequence::Add(ULONG ulSeqN, CQmPacket *pQmPkt, CSeqPacket **ppSeqPkt)
{
    // Look for the correct place in the list
    BOOL        fAddToHead  = TRUE;

    POSITION posInList  = m_listSeqUnackedPkts.GetTailPosition(),
             posCurrent = NULL;

    while (posInList != NULL)
    {
        posCurrent = posInList;
        CSeqPacket* pSeqPktPrev = m_listSeqUnackedPkts.GetPrev(posInList);

        if (pSeqPktPrev->GetSeqN() == ulSeqN)
        {
            // Duplicate
            *ppSeqPkt = pSeqPktPrev;
            return FALSE;
        }
        else if (pSeqPktPrev->GetSeqN() < ulSeqN)
        {
            // This will be the last packet
            fAddToHead = FALSE;
            break;
        }
   }

   P<CSeqPacket> SeqPkt = new CSeqPacket();
   CSeqPacket* pSeqPkt = SeqPkt.get();
   
   // return the pointer
   if (ppSeqPkt)
   {
        *ppSeqPkt = pSeqPkt;
   }

   // Add the packet to the list
   if (fAddToHead)
   {
       m_listSeqUnackedPkts.AddHead(pSeqPkt);
   }
   else
   {
       m_listSeqUnackedPkts.InsertAfter(posCurrent, pSeqPkt);
   }

   pSeqPkt->AssignPacket(pQmPkt);
   ASSERT(ulSeqN == pSeqPkt->GetSeqN());
   
   SeqPkt.detach();
   return TRUE;
}

/*====================================================
COutSequence::Lookup
    Looks for the CSeqPacket by SeqN.
    Returns TRUE  and pointer to the exact packet - if found
    Returns FALSE and pointer to the next packet  - if not found
=====================================================*/
BOOL COutSequence::Lookup(ULONG ulSeqN, CSeqPacket **ppSeqPkt)
{
    CSeqPacket* pPkt = NULL;
    ASSERT(ppSeqPkt);

    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            *ppSeqPkt = pPkt;
            return TRUE;
        }
        else if (pPkt->GetSeqN() > ulSeqN)
        {
            *ppSeqPkt = pPkt;
            return FALSE;
        }
    }

    *ppSeqPkt = NULL;
    return FALSE;
}

/*====================================================
COutSequence::Insert
    Inserts data to the hash
    Returns sequence pointer if the sequence was added
=====================================================*/
void COutSequence::Insert(CQmPacket *pPkt)
{
    ULONG ulSeqN  = pPkt->GetSeqN();
    CSeqPacket   *pSeqPkt;

    // We will need to know later whether it was empty
    BOOL fEmpty = IsEmpty();

    // Adding packet to the sequence if not exists

    Add(ulSeqN, pPkt, &pSeqPkt);


    if (OnHold() && fEmpty)
    {
        //
        //  Verify whether sequence is still on hold
        //  We can do it only for the first packet, because sequence never gets hold later
        //
        UpdateOnHoldStatus(m_listSeqUnackedPkts.GetHead()->Pkt());
    }

    if (OnHold())
    {
        //
        // Previous sequence is active. don't start timer
        //
        return;
    }

    StartResendTimer(FALSE);

    return;
}


/*====================================================
COutSequence::Delete
    Looks for the CSeqPkt by SeqN and deletes it
    Returns TRUE if found
=====================================================*/
BOOL COutSequence::Delete(ULONG ulSeqN, USHORT usClass)
{
    CSeqPacket *pPkt;
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            m_listSeqUnackedPkts.RemoveAt(posCurrent);
            pPkt->DeletePacket(usClass);
            return TRUE;
        }
        else if (pPkt->GetSeqN() > ulSeqN)
        {
            return FALSE;
        }
   }

   return FALSE;
}

/*====================================================
COutSequence::SeqAckCame
    Treats the case when an order ack came:
      - acks all relevant packets from this and previous sequences
      - AckNo > LastResent means all those resent has came,
        so we are exiting resending state and seting LastResent=INFINITY,
      - if advanced but still there are some non-acked resent packets
            - cancel current ResendTimer and schedule it for 30"
      - if advanced so that all resent packets has been acked
            - cancel current ResendTimer and schedule it immediately
              because unsent packets may have accumulated during resend state)
            - sets LastResent = INFINITE : we are not in resend state anymore
=====================================================*/
void COutSequence::SeqAckCame(ULONG ulSeqN)
{
    // Updating last time order acked was received
    m_timeLastAck = MqSysTime();

    // Keeping max ack number
    SetAckSeqN(ulSeqN);

    R<COutSequence> pPrev = GetPrevSeq();
    if (pPrev.get() != NULL)
    {
        pPrev->SeqAckCame(INFINITE);
    }

    // Cleaning packets list
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() <= AckSeqN())
        {
            // Packet is acked already
            TrTRACE(XACT_SEND, "Exactly1 send: Acked pkt: SeqID=%x / %x, SeqN=%d, Prev=%d . Moving to delivered list",
                    HighSeqID(), LowSeqID(), pPkt->GetSeqN(), pPkt->GetPrevSeqN());

            m_listSeqUnackedPkts.RemoveAt(posCurrent);        // Remove from unacked   list
            g_OutSeqHash.KeepDelivered(pPkt);                 // Move to the delivered list
        }
        else
        {
            break;
        }
   }

   // Did we saw advance since previous order ack?
   if (Advanced())           // NB: it is the only place Advanced is called
   {
   		if (LastResent() == INFINITE)
   		{
   			ClearResendIndex();
   			PlanNextResend(FALSE);
   			return;
   		}
   		
        // Do we have everything resent acked?
        if (ulSeqN >= LastResent())
        {
			while (!m_listSeqUnackedPkts.IsEmpty())
			{
		        P<CSeqPacket> pSeqPkt = m_listSeqUnackedPkts.GetHead();

		        if (!ResendSeqPkt(pSeqPkt))
		        {
			    	PlanNextResend(TRUE);
		            return;
		        }

		        TrWARNING(XACT_SEND, "Exactly1 send: Resend sequence: SeqID=%x / %x  SeqNo=%d", HighSeqID(), LowSeqID(), pSeqPkt->GetSeqN());

				//
		        // Delete the packet, we don't need it in OutHash
		        //
		        m_listSeqUnackedPkts.RemoveHead();
		    }

			if (m_fResendScheduled && ExCancelTimer(&m_ResendTimer))
			{
	        	TrTRACE(XACT_SEND,"Exactly1 send: SeqAckCame Advanced, Cancel resend state: SeqID=%x / %x - resend.", HighSeqID(), LowSeqID());
				Release();
				m_fResendScheduled = FALSE;
			}
			LastResent(INFINITE);

	        TrTRACE(XACT_SEND,"Exactly1 send: Advanced, leaving resend state: SeqID=%x / %x - resend.", HighSeqID(), LowSeqID());
        }

        ClearResendIndex();
   }
}

/*====================================================
COutSequence::BadDestAckCame
    Deletes all packets up to pointed, moves them to
    delivered list and resolves them with the given class

    This is a special case because bad destination ack may come as
    random error from the FRS on the way. It does not mean order ack.
=====================================================*/
void COutSequence::BadDestAckCame(ULONG ulSeqN, USHORT usClass)
{
    // Cleaning packets list
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pPkt = m_listSeqUnackedPkts.GetNext(posInList);
        OBJECTID MsgId;
        pPkt->Pkt()->GetMessageId(&MsgId);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            TrTRACE(XACT_SEND, "Exactly1 send: BadDestAckCame pkt: SeqID=%x / %x, SeqN=%d, Prev=%d . Moving to delivered list",
                    HighSeqID(), LowSeqID(), pPkt->GetSeqN(), pPkt->GetPrevSeqN());

            m_listSeqUnackedPkts.RemoveAt(posCurrent);        // Remove from unacked   list
            g_OutSeqHash.KeepDelivered(pPkt);                 // Move to the delivered list
            g_OutSeqHash.ResolveDelivered(&MsgId, usClass);   // Resolve it as bad dest.
            //
            //  NOTE: KeepDelivered() may delete the pkt, don't use
            //        further in the code
            //
            continue;
        }

        if (pPkt->GetSeqN() >= ulSeqN)
        {
            break;
        }
   }

   return;
}

//--------------------------------------
//
// Class  COutSeqHash
//
//--------------------------------------

/*====================================================
COutSeqHash::COutSeqHash  -     Constructor
=====================================================*/
COutSeqHash::COutSeqHash()
{
    DWORD dwDef;
    ASSERT(sizeof(g_aulSeqResendCycle) / sizeof(ULONG) == 10);

    // Get resend intervals
    dwDef = FALCON_DEFAULT_ORDERED_RESEND13_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[0],
                  FALCON_ORDERED_RESEND13_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[0]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[1] = g_aulSeqResendCycle[0];
    g_aulSeqResendCycle[2] = g_aulSeqResendCycle[0];


    dwDef = FALCON_DEFAULT_ORDERED_RESEND46_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[3],
                  FALCON_ORDERED_RESEND46_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[3]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[4] = g_aulSeqResendCycle[3];
    g_aulSeqResendCycle[5] = g_aulSeqResendCycle[3];


    dwDef = FALCON_DEFAULT_ORDERED_RESEND79_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[6],
                  FALCON_ORDERED_RESEND79_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[6]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[7] = g_aulSeqResendCycle[6];
    g_aulSeqResendCycle[8] = g_aulSeqResendCycle[6];

    dwDef = FALCON_DEFAULT_ORDERED_RESEND10_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[9],
                  FALCON_ORDERED_RESEND10_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[9]*= 1000;  // sec--> msec

    m_ulMaxTTRQ = 0;

    #ifdef _DEBUG
    // Get xact resend time
    dwDef = 0;
    ULONG  ulTime;
    READ_REG_DWORD(ulTime,
                   FALCON_DBG_RESEND_REGNAME,
                   &dwDef ) ;
    if (ulTime)
    {
        for (int i=0; i<sizeof(g_aulSeqResendCycle) / sizeof(ULONG); i++)
            g_aulSeqResendCycle[i] = ulTime * 1000;
    }
    #endif

    // Get local expiration delay default
    ULONG ulDefault = 0;
    READ_REG_DWORD(g_ulDelayExpire,
                  FALCON_XACT_DELAY_LOCAL_EXPIRE_REGNAME,
                  &ulDefault ) ;
}

/*====================================================
COutSeqHash::~COutSeqHash   -     Destructor
=====================================================*/
COutSeqHash::~COutSeqHash()
{
}


static bool IsValidAck(LONGLONG liSeqID, const CSenderStream* pSenderStream)
{
	R<COutSequence> pOutSeq;
	if(!g_OutSeqHash.Consult(liSeqID, pOutSeq))
		return false;

	return pOutSeq->IsValidAck(pSenderStream);
}


/*====================================================
COutSeqHash::FindLastSmallerSequence
    find last smaller sequence from direction
=====================================================*/
R<COutSequence> COutSeqHash::FindLastSmallerSequence(
        LONGLONG liSeqID,
        CKeyDirection *pkeyDirection)
{
    R<COutSequence> pCur;

    if (!m_mapDirections.Lookup(*pkeyDirection, pCur))
    {
    	return NULL;
    }

    ASSERT(pCur.get() != NULL);
    R<COutSequence> pLastSmaller;

    while (pCur.get() != NULL && pCur->SeqID() < liSeqID)
    {
        pLastSmaller = pCur;
        pCur = pCur->GetNextSeq();
    }

    //
    // the list can not contain the sequence id we are looking for
    //
	ASSERT ((pCur.get() == NULL) || (pCur->SeqID() > liSeqID));
    return pLastSmaller;
}


/*====================================================
COutSeqHash::LinkSequence
    Inserts new sequence into the per-SeqID  and per-direction CMAPs
=====================================================*/
void COutSeqHash::LinkSequence(
        LONGLONG liSeqID,
        CKeyDirection *pkeyDirection,
        R<COutSequence> pOutSeq)
{
    // Adding the sequence to the SeqID-based mapping
    m_mapOutSeqs.SetAt(liSeqID, pOutSeq);

    // Adding the sequence to the direction-based structure

    // Looking for the first sequence for a direction
    R<COutSequence> pExistingOutSeq;

    if (!m_mapDirections.Lookup(*pkeyDirection, pExistingOutSeq))
    {
        // This starts new direction
        m_mapDirections.SetAt(*pkeyDirection, pOutSeq);
    }
    else
    {
        // Adding the sequence to the sorted list
        R<COutSequence> pCur = pExistingOutSeq;
        R<COutSequence> pLastSmaller;
        ASSERT(pCur.get() != NULL);

        while (pCur.get() != NULL && pCur->SeqID() < liSeqID)
        {
            pLastSmaller = pCur;
            pCur = pCur->GetNextSeq();
        }

        if(pLastSmaller.get() != NULL)
        {
            // Inserting after pLastSmaller
            pOutSeq->SetPrevSeq(pLastSmaller);
            pOutSeq->SetNextSeq(pLastSmaller->GetNextSeq());

            if (pLastSmaller->GetNextSeq().get() != NULL)
            {
                (pLastSmaller->GetNextSeq())->SetPrevSeq(pOutSeq);
            }
            pLastSmaller->SetNextSeq(pOutSeq);
        }
        else
        {
            // First element was greater, so inserting as 1st element
            m_mapDirections.SetAt(*pkeyDirection, pOutSeq);

            pOutSeq->SetPrevSeq(NULL);
            pOutSeq->SetNextSeq(pExistingOutSeq);

            pExistingOutSeq->SetPrevSeq(pOutSeq);
        }
    }
}


/*====================================================
COutSeqHash::SeqAckCame
    Processes incoming order ack
=====================================================*/
void COutSeqHash::SeqAckCame(LONGLONG liSeqID, ULONG ulSeqN, const QUEUE_FORMAT* pqf)
{
    TrTRACE(XACT_SEND, "Exactly1 send: SeqAckCame: SeqID=%x / %x, SeqN=%d came",
            HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN);
	//
    // Looking for existing sequence
    //
    R<COutSequence> pOutSeq;
    if (!Consult(liSeqID, pOutSeq))
    {
    	//
    	// sequence not found, looking for the greatest smaller sequence
    	//	This can probably happen in backup-restore scenarios.
    	//
    	CKeyDirection direction(pqf);
    	pOutSeq = FindLastSmallerSequence(liSeqID, &direction);
    	if (NULL == pOutSeq.get())
    	{
        	return;
    	}
    }

    // Apply order ack to this sequence
    pOutSeq->SeqAckCame(ulSeqN);
}


/*====================================================
COutSeqHash::AckedPacket
    Treats the acked packet
=====================================================*/
void COutSeqHash::AckedPacket(LONGLONG liSeqID, ULONG ulSeqN, CQmPacket* pPkt)
{
    if (!Delete(liSeqID, ulSeqN, MQMSG_CLASS_ACK_REACH_QUEUE))
    {
        // The packet was not found in the OutSeqHash; maybe it was new
		CSeqPacket *pSeqPkt = new CSeqPacket(pPkt);
		g_OutSeqHash.KeepDelivered(pSeqPkt);   // Move to the delivered list
    }

    TrTRACE(XACT_SEND, "Exactly1 send: AckedPacket:  SeqID=%x / %x, SeqN=%d pkt is acked",
           HighSeqID(liSeqID), LowSeqID(liSeqID),  ulSeqN);
}

/*====================================================
COutSeqHash::Delete
    Deletes packet from hash

Returns TRUE if found
=====================================================*/
BOOL COutSeqHash::Delete(LONGLONG liSeqID, ULONG ulSeqN, USHORT usClass)
{
    R<COutSequence> pOutSeq;

    if (m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
    {
        return pOutSeq->Delete(ulSeqN, usClass);
    }
    return FALSE;
}

/*====================================================
COutSeqHash::Consult
    Looks for the OutSequence by SeqID

Returns TRUE if found and pointer to the OutSeqence
=====================================================*/
BOOL COutSeqHash::Consult(LONGLONG liSeqID,  R<COutSequence>& pOutSeq) const
{
	ASSERT(pOutSeq.get() == NULL);
	
    if (m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
        return TRUE;

    return FALSE;
}

/*====================================================
COutSeqHash::ProvideSequence
    Looks for the OutSequence by SeqID; if there is no, creates it
=====================================================*/

R<COutSequence> COutSeqHash::ProvideSequence( LONGLONG liSeqID,
                                            const QUEUE_FORMAT* pqf,
                                            const CSenderStream* pSenderStream,
                                            IN bool bInSend)
{
    R<COutSequence> pOutSeq;

    if (Consult(liSeqID, pOutSeq))
    {
        return pOutSeq;
    }

	// Get queue handle
	CQueue* pQueue;
    if(!QueueMgr.LookUpQueue(pqf, &pQueue, false, bInSend))
		return NULL;

	HANDLE hQueue = pQueue->GetQueueHandle();
    pQueue->Release();

    // Adding new COutSequence
    pOutSeq = new COutSequence(liSeqID, pqf, hQueue, pSenderStream);

    TrTRACE(XACT_SEND, "Exactly1 send: Creating new sequence: SeqID=%x / %x  ",
            HighSeqID(liSeqID), LowSeqID(liSeqID));

    return pOutSeq;
}


/*====================================================
COutSeqHash::DeleteSeq
    Deletes sequence from the hash
=====================================================*/
void COutSeqHash::DeleteSeq(LONGLONG liSeqID)
{
    R<COutSequence> pOutSeq;

    TrTRACE(XACT_SEND, "Exactly1 send: DeleteSeq: SeqID=%x / %x . Deleting.", HighSeqID(liSeqID), LowSeqID(liSeqID));

    // Nothing to do if the sequence does not exist
    if (!m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
    {
        TrTRACE(XACT_SEND, "Exactly1 send: DeleteSeq: SeqID=%x / %x . Sequence not found.",
                HighSeqID(liSeqID), LowSeqID(liSeqID));
        return;
    }

	//
	// in normal operation we need to be in the end of the list
	// we go to the end to prevent memory leaks in unexpected scenario
	//
	ASSERT (pOutSeq->GetNextSeq().get() == NULL);
	while (pOutSeq->GetNextSeq().get() != NULL)
	{
		pOutSeq = pOutSeq->GetNextSeq();
	}

    // Delete all previous sequences
	while (pOutSeq.get() != NULL)
	{
	    // We should come here only with zero packets inside (because ReleaseQueue will not be called otherwise)
	    ASSERT(pOutSeq->IsEmpty());

	    // Exclude the sequence from the SeqID-based CMap
	    LONGLONG liTempSeqID = pOutSeq->SeqID();
	   	m_mapOutSeqs.RemoveKey(liTempSeqID);

	    R<COutSequence> pPrevSeq = pOutSeq->GetPrevSeq();
	    if (pOutSeq->GetPrevSeq().get() == NULL)
	    {
	        // It was first, Close the direction, there is nothing there.
	        m_mapDirections.RemoveKey(*(pOutSeq->KeyDirection()));
	    }
		else
		{
			pOutSeq->GetPrevSeq()->SetNextSeq(NULL);
			pOutSeq->SetPrevSeq(NULL);
		}

	    pOutSeq->RequestDelete();

	    pOutSeq = pPrevSeq;
	}
    return;
}

/*====================================================
COutSeqHash::PreSendProcess
    Decides if to send packet

Returns TRUE if the packet should be sent
=====================================================*/
BOOL COutSeqHash::PreSendProcess(CQmPacket* pPkt,
                                 IN bool bInSend)
{
    //
    // N.B. Packets may arrive here in the wrong order from the queue.
    //

    ASSERT(pPkt->IsOrdered());

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);
	DBG_USED(ulSeqN);


    ASSERT(liSeqID > 0);  // The packet is ordered.

    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    //
    // Creating new sequence,
    //    if we don't do it, PreSend on recovery will be unable to stop non-first sequences
    QUEUE_FORMAT qf;
    pPkt->GetDestinationQueue(&qf);


		
    R<COutSequence> pOutSeq = ProvideSequence(
		liSeqID,
		&qf,
		(pPkt->IsSenderStreamIncluded() ? pPkt->GetSenderStream() : NULL),
        bInSend
		);



	ASSERT(pOutSeq.get() != NULL);

    // Main bulk of processing
    BOOL fSend = pOutSeq->PreSendProcess(pPkt);

    TrTRACE(XACT_SEND, "Exactly1 send: SeqID=%x / %x, SeqN=%d, Prev=%d . %ls",
            HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN, ulPrevSeqN,
            (fSend ? _TEXT("Sending") : _TEXT("Bypassing")));
    s_SendingState = fSend;

    return fSend;   // send it or not
}

/*====================================================
COutSequence::PreSendProcess
    Decides if to send packet

Returns TRUE if the packet should be sent
=====================================================*/
BOOL COutSequence::PreSendProcess(CQmPacket* pPkt)
{
    //
    // N.B. Packets may arrive here in the wrong order from the queue.
    //

    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

    // Is the packet acked already?
    if (ulSeqN <= AckSeqN())
    {
        TrTRACE(XACT_SEND, "Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d, Prev=%d is acked already",
                HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN);

        // PostSend will treat this case
        return FALSE;  // no send
    }

    //
    // Do not send new-comer packet if the sequence is in resend state
    //    Resend state means we are resending just what we had at the moment of resend decision
    //    All new packets coming during resend state are not sent but kept.
    //
    //    Note that LastResend!=INFINITY means exactly resend state
    //
    if (ulSeqN > LastResent())
    {
        TrTRACE(XACT_SEND, "Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: postponed till next resend",
            HighSeqID(), LowSeqID(), ulSeqN);

        return FALSE;
    }

    //
    // Decide whether the sequence if on hold
    //
    if (ulPrevSeqN == 0 && m_fOnHold)
    {
        //
        //  Verify whether sequence is still on hold
        //
        UpdateOnHoldStatus(pPkt);

        TrTRACE(XACT_SEND, "Exactly1 send: PreSendProcess: Sequence SeqID=%x / %x : decided OnHold=%d ",
            HighSeqID(), LowSeqID(), m_fOnHold);

    }

    //
    // Now, we send exactly when sequence is not on hold
    //
    TrTRACE(XACT_SEND, "Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: %ls ",
        HighSeqID(), LowSeqID(), ulSeqN,
        (m_fOnHold ? _TEXT("Holding") : _TEXT("Sending")));

    return (!m_fOnHold);
}


/*====================================================
COutSequence::UpdateOnHoldStatus
    Verifies On Hold status
=====================================================*/
void COutSequence::UpdateOnHoldStatus(CQmPacket* pPkt)
{
    LONGLONG liAckSeqID;
    ULONG    ulAckSeqN;

    //
    //  Find last ack for the direction
    //
    GetLastAckForDirection(&liAckSeqID, &ulAckSeqN);

    //
    // Set latest acknowledgment information in the queue
    //
    ACSetSequenceAck(m_hQueue, liAckSeqID, ulAckSeqN);
    HRESULT hr = ACIsSequenceOnHold(m_hQueue, pPkt->GetPointerToDriverPacket());
    if (hr == STATUS_INSUFFICIENT_RESOURCES)
    {
        //
        // ISSUE-2000/12/20-shaik Handle ACIsSequenceOnHold failure
        //
        ASSERT(("ISSUE-2000/12/20-shaik Handle ACIsSequenceOnHold failure", 0));
        ASSERT_RELEASE(0);
    }

    m_fOnHold = SUCCEEDED(hr);
}

/*====================================================
COutSeqHash::PostSendProcess
    Inserts packet in the OutgoingSeqences hash
=====================================================*/
void COutSeqHash::PostSendProcess(CQmPacket* pPkt)
{
    //
    // N.B. Packets may NOT arrive here in the right order from the queue.
    // The order is changed if in PreSendProcess we decide not to send a
    // packet after enabling other packets to be sent.
    // The packets that are send arrive here only after session acknowledgment,
    // but those that are not arrive here immediately.
    //

    ASSERT(pPkt->IsOrdered());
    ASSERT(QmpIsLocalMachine(pPkt->GetSrcQMGuid()));

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
    ulPrevSeqN  = pPkt->GetPrevSeqN();
	UNREFERENCED_PARAMETER(ulPrevSeqN);
	UNREFERENCED_PARAMETER(ulSeqN);


    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    // Find the sequence 0 it should exist because PreSend worked already
    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    ASSERT(fSequenceExist);
    ASSERT(pOutSeq.get() != NULL);
	DBG_USED(fSequenceExist);

    // Main bulk of processing
    pOutSeq->PostSendProcess(pPkt, m_ulMaxTTRQ);

    return;
}

/*====================================================
COutSequence::PostSendProcess
    Inserts packet in the OutgoingSeqences hash
=====================================================*/
void COutSequence::PostSendProcess(CQmPacket* pPkt, ULONG ulMaxTTRQ)
{
    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);

    //
    // Is the packet acked already?
    //
    if (ulSeqN <= AckSeqN())
    {
        TrTRACE(XACT_SEND, "Exactly1 send: PostSendProcess: Pkt SeqID=%x / %x, SeqN=%d, Prev=%d is acked",
               HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN);

        g_OutSeqHash.AckedPacket(liSeqID, ulSeqN, pPkt);
        return;
    }

    //
    // Catch possibly timed out packet (we want it in XactDeadLetteQueue now and not after 6 hrs)
    //
    CBaseHeader* pcBaseHeader = (CBaseHeader *)(pPkt->GetPointerToPacket());
    if (pcBaseHeader->GetAbsoluteTimeToQueue() < ulMaxTTRQ)
    {
        TrTRACE(XACT_SEND, "Exactly1 send: PostSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: pkt timed out, requeued",
            HighSeqID(), LowSeqID(), ulSeqN);

        // Requeue it back, don't remember
        QmAcPutPacket(m_hQueue, pPkt->GetPointerToDriverPacket(),eDeferOnFailure);
    	delete pPkt;
    	return;
    }

    //
    // Keeping packet in the Sequence for resends.
    //
    Insert(pPkt);

    TrTRACE(XACT_SEND, "Exactly1 send: PostSendProcess: SeqID=%x / %x, SeqN=%d, Prev=%d . Remembering pkt",
            HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN);
    return;
}

/*====================================================
COutSeqHash::NonSendProcess
    Treats the case when the packet was not sent at all
    (e.g., destination machine does not support encryption)
=====================================================*/
void COutSeqHash::NonSendProcess(CQmPacket* pPkt, USHORT usClass)
{
    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    ASSERT(pPkt->IsOrdered());
    ASSERT(QmpIsLocalMachine(pPkt->GetSrcQMGuid()));

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);

    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    ASSERT(fSequenceExist);
	DBG_USED(fSequenceExist);

    if (!Delete(liSeqID, ulSeqN, usClass))
    {
        // The packet was not found in the OutSeqHash; maybe it was new
        // ;;; nack...
	    QmAcFreePacket(
				   	   pPkt->GetPointerToDriverPacket(),
				   	   usClass,
	   			       eDeferOnFailure);
        delete pPkt;
    }


    TrTRACE(XACT_SEND, "Exactly1 send: NonSendProcess: Pkt  SeqID=%x / %x, SeqN=%d, Prev=%d, class=%x",
           HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN, ulPrevSeqN, usClass);
    return;
}

/*====================================================
TimeToResendOutSequence
    Scheduled periodically to treat outgoing sequence
    Checks for the timed out, acked packets and kills them;
    Resends packets
=====================================================*/
void WINAPI COutSequence::TimeToResendOutSequence(CTimer* pTimer)
{

    // Serializing all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    R<COutSequence> pOutSeq = CONTAINING_RECORD(pTimer, COutSequence, m_ResendTimer);
    pOutSeq->TreatOutSequence();
}

/*====================================================
COutSequence::TreatOutSequence
    Cleans all timed out packets from the sequence
=====================================================*/
void COutSequence::TreatOutSequence()
{
    TrTRACE(XACT_SEND, "Exactly1 send: TreatOutSequence SeqID=%x / %x ", HighSeqID(), LowSeqID());

    // We entered into the timer routine, so there is no other timer
    ASSERT(m_fResendScheduled);
    m_fResendScheduled = FALSE;


    // If there was a delete request, delete this sequence
    if (m_fMarkedForDelete)
        return;

    // Is the sequence empty?
    if (m_listSeqUnackedPkts.IsEmpty())
    {
        TrWARNING(XACT_SEND, "Exactly1 send: Resend sequence: SeqID=%x / %x  Empty, no more periods", HighSeqID(), LowSeqID());

        // Don't plan next resend, no need;  we are not in resend state
        TrTRACE(XACT_SEND, "Exactly1 send: TreatOutSequence: Changing LastReSent from %d to INFINITE", LastResent());

        LastResent(INFINITE);

        for(R<COutSequence> pNext = SafeAddRef(this); (pNext = pNext->GetNextSeq()).get() != NULL; )
        {
            if(pNext->OnHold())
            {
                pNext->ResendSequence();
            }
        }
        return;
    }

    TrWARNING(XACT_SEND, "Exactly1 send: Resend sequence: SeqID=%x / %x  Phase=%d", HighSeqID(), LowSeqID(), ResendIndex());

    // Resend all packets
    ResendSequence();

    // plan next resend
    if(!OnHold())
    {
        PlanNextResend(FALSE);
    }
}


/*====================================================
COutSequence::ResendSequence
    Applies the given routine to all packets in the sequence
=====================================================*/
void COutSequence::ResendSequence()
{

    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pSeqPkt = m_listSeqUnackedPkts.GetNext(posInList);

        // Resend the packet
        if (!ResendSeqPkt(pSeqPkt))
            return;

        // Normal case
        TrTRACE(XACT_SEND, "Exactly1 send: ResendSequence, SeqID=%x / %x -  Changing LastReSent from %d to %d",
                 HighSeqID(), LowSeqID(), LastResent(), pSeqPkt->GetSeqN());

        LastResent(pSeqPkt->GetSeqN());

        // Delete the packet, we don't need it in OutHash
        m_listSeqUnackedPkts.RemoveAt(posCurrent);
        delete pSeqPkt;
    }
}

/*====================================================
COutSequence::ResendSeqPkt
    Resend the given packet
    Returns TRUE if the packet was sent
=====================================================*/
BOOL COutSequence::ResendSeqPkt(CSeqPacket *pSeqPkt)
{
    LONGLONG  liSeqID    = pSeqPkt->GetSeqID();
    ULONG     ulSeqN     = pSeqPkt->GetSeqN();
    ULONG     ulPrevSeqN = pSeqPkt->GetPrevSeqN();
    CQmPacket *pPkt      = pSeqPkt->Pkt();
    BOOL      fSent      = FALSE;

	UNREFERENCED_PARAMETER(ulSeqN);
	UNREFERENCED_PARAMETER(liSeqID);
	UNREFERENCED_PARAMETER(ulPrevSeqN);


    if (pPkt->ConnectorQMIncluded() && QmpIsLocalMachine(pPkt->GetConnectorQM()))
    {
        //
        // If the source machine is the connector machine we don't resend the message.
        // In such a case the message is already on the connector queue and the reason
        // it doesn't ACK is only because the Connector application doesn't commit yet.
        //
        TrTRACE(XACT_SEND,"Exactly1 send: No Resend packet SeqID=%x / %x, SeqN=%d, Prev=%d (deliver to Connector) ",
                pSeqPkt->GetHighSeqID(), pSeqPkt->GetLowSeqID(), pSeqPkt->GetSeqN(), pSeqPkt->GetPrevSeqN());
    }
    else
    {
        TrTRACE(XACT_SEND, "Exactly1 send: ResendSeqPkt: SeqID=%x / %x, SeqN=%d, Prev=%d packet",
                pSeqPkt->GetHighSeqID(), pSeqPkt->GetLowSeqID(), pSeqPkt->GetSeqN(), pSeqPkt->GetPrevSeqN());

        // Requeue packet to the driver
        try
        {
        	QmAcPutPacket(m_hQueue, pPkt->GetPointerToDriverPacket(),eDoNotDeferOnFailure);
            fSent = TRUE;
        }
        catch (const bad_hresult&)
        {
        	fSent = FALSE;
        }
    }

    return fSent;
}

/*====================================================
COutSequence::StartResendTimer
    Schedules next resend for the sequence,  if it was not done
=====================================================*/
void COutSequence::StartResendTimer(BOOL fImmediate)
{
    if (!m_fResendScheduled)
    {
        ClearResendIndex();
        PlanNextResend(fImmediate);

        TrTRACE(XACT_SEND, "Exactly1 send StartResendTimer:  SeqID=%x / %x, planning resend",
            HighSeqID(), LowSeqID());
    }
}


/*====================================================
COutSequence::PlanNextResend
    Schedules next resend for the sequence
=====================================================*/
void COutSequence::PlanNextResend(BOOL fImmediate)
{
    ULONG len = sizeof(g_aulSeqResendCycle) / sizeof(ULONG);
    ULONG ind = m_ulResendCycleIndex++;
    ind = (ind >= len ? len-1 : ind);
    ULONG ulNextTime = (fImmediate? 0 : g_aulSeqResendCycle[ind]);

    // Killing potential extra timer
	if (m_fResendScheduled)
	{
		if(ExCancelTimer(&m_ResendTimer))
		{
			Release();
		}
		else
			return;
	}
	
	AddRef();
	
    ExSetTimer(&m_ResendTimer, CTimeDuration::FromMilliSeconds(ulNextTime));
    m_fResendScheduled = TRUE;
    m_NextResendTime   = MqSysTime() + (ulNextTime/1000);
}


/*====================================================
COutSequence::RequestDelete
    Schedules next resend for the sequence
=====================================================*/
void COutSequence::RequestDelete()
{
    m_fMarkedForDelete = TRUE;
}

/*====================================================
COutSequence::GetLastAckForDirection
    Finds out the last ack for the whole direction
    It happens to be the ackN from the last acked sequence
=====================================================*/
void COutSequence::GetLastAckForDirection(
           LONGLONG *pliAckSeqID,
           ULONG *pulAckSeqN)
{
    // First, go to the last sequence in the direction
    R<COutSequence> pSeq = SafeAddRef(this);
    R<COutSequence> p1;

    while ((p1 = pSeq->GetNextSeq()).get() != NULL)
    {
        pSeq = p1;
    }

    // Go back to the first (from the end) sequence with non-zero LastAck data
    while (pSeq.get() != NULL)
    {
        if (pSeq->AckSeqN() != 0)
        {
            *pliAckSeqID = pSeq->SeqID();
            *pulAckSeqN  = pSeq->AckSeqN();
            return;
        }

        pSeq = pSeq->GetPrevSeq();
    }

    *pliAckSeqID = 0;
    *pulAckSeqN  = 0;
    return;
}

/*====================================================
COutSeqHash::KeepDelivered
    Adds the delivered CSeqPacket to the list of waiting for
        the final resolution
    No duplicates allowed (otherwise return FALSE)
=====================================================*/
void COutSeqHash::KeepDelivered(CSeqPacket *pSeqPkt)
{
	P<CSeqPacket> AutoSeqPkt = pSeqPkt;

    CS lock(g_critOutSeqHash);
    CQmPacket *pQmPkt = pSeqPkt->Pkt();

    // Mark the fact that the packet was delivered
    pSeqPkt->SetClass(MQMSG_CLASS_ACK_REACH_QUEUE);

    OBJECTID MsgId;
    USHORT   usClass;
    CSeqPacket *pSeq;

    pQmPkt->GetMessageId(&MsgId);
    ASSERT(QmpIsLocalMachine(&MsgId.Lineage));

    {
        // Do we know the final resolution already?
        if (m_mapAckValue.Lookup(MsgId.Uniquifier, usClass))
        {
            TrTRACE(XACT_SEND, "Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d, Acked %x Got order ack, freed",
                     HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN(), usClass);

            //
            //  Mark the message with the received ack
            //
            pSeqPkt->SetClass(usClass);

            BOOL f = m_mapAckValue.RemoveKey(MsgId.Uniquifier);
            ASSERT(f);
			DBG_USED(f);

            // Free packet
            HRESULT hr = pSeqPkt->AcFreePacket();
            ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);
        }
        else if (!m_mapWaitAck.Lookup(MsgId.Uniquifier,pSeq))
        {
            // Is follow-up canceled?
            if (pQmPkt->GetCancelFollowUp())
            {
                TrTRACE(XACT_SEND, "Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d delivered and freed",
                         HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN());

                // Free packet, no follow-up
                HRESULT hr = pSeqPkt->AcFreePacket();
                ASSERT(SUCCEEDED(hr));
				DBG_USED(hr);
            }

            else
            {
                TrTRACE(XACT_SEND, "Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d delivered and kept",
                         HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN());

                // Inserting packet into the delivered map for follow-up
                m_mapWaitAck[MsgId.Uniquifier] = pSeqPkt;
				AutoSeqPkt.detach();
            }
        }
    }
}


/*====================================================
COutSeqHash::LookupDelivered
    looks for the delivered CSeqPacket in the list of waiting for
        the final resolution, sets the class and frees the packet
=====================================================*/
BOOL COutSeqHash::LookupDelivered(OBJECTID   *pMsgId,
                                  CSeqPacket **ppSeqPkt)
{
    CSeqPacket *pSeqPkt;

    BOOL f = m_mapWaitAck.Lookup(pMsgId->Uniquifier, pSeqPkt);

    if (f && ppSeqPkt)
    {
        *ppSeqPkt = pSeqPkt;
    }

    return f;
}

/*====================================================
COutSeqHash::ResolveDelivered
    looks for the delivered CSeqPacket in the list of waiting for
        the final resolution, sets the class and frees the packet
=====================================================*/
void COutSeqHash::ResolveDelivered(OBJECTID* pMsgId,
                                   USHORT    usClass)
{
	if ((!MQCLASS_NACK(usClass)) && (usClass != MQMSG_CLASS_ACK_RECEIVE))
	{
		ASSERT_BENIGN(0);
		TrERROR(XACT_GENERAL, "Rejecting order ack that its class is not valid");
		throw exception();
	}

    // Serializing all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);
    CSeqPacket *pSeqPkt;

    // Is the packet waiting already in the delivered list?
    if (m_mapWaitAck.Lookup(pMsgId->Uniquifier, pSeqPkt))
    {
        // Remove the packet from delivered map
        m_mapWaitAck.RemoveKey(pMsgId->Uniquifier);

        // Delete packet with Ack/NAck and AcFreePacket if needed
        pSeqPkt->DeletePacket(usClass);

        TrTRACE(XACT_SEND, "Exactly1 send:ResolveDelivered: Msg Id = %d, Ack Value = %x got ack",pMsgId->Uniquifier, usClass);
    }
    else
    {
        USHORT usValue;
        if(!m_mapAckValue.Lookup(pMsgId->Uniquifier, usValue))
        {
            //
            //  Save the acknowledgment only if we don't know it yet, otherwise
            //  keep the first one that arrived.
            //
            m_mapAckValue[pMsgId->Uniquifier] = usClass;
        }
    }
}


/*====================================================
SeqPktTimedOut
    Called from driver handle routine at packet time-out
=====================================================*/
void SeqPktTimedOut(CBaseHeader * pPktBaseHdr, CPacket *  pDriverPacket, BOOL fTimeToBeReceived)
{
    OBJECTID MsgId;
    CQmPacket Pkt(pPktBaseHdr, pDriverPacket);
    Pkt.GetMessageId(&MsgId);

    if (fTimeToBeReceived)
    {
        // TTBR
        TrTRACE(XACT_SEND, "Exactly1 send: TTBR TimeOut: Pkt SeqID=%x / %x, SeqN=%d",
           HighSeqID(Pkt.GetSeqID()), LowSeqID(Pkt.GetSeqID()), Pkt.GetSeqN());

        USHORT usClass = MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER;

        g_OutSeqHash.ResolveDelivered(&MsgId, usClass);

       QmAcFreePacket1(g_hAc, pDriverPacket, usClass, eDeferOnFailure);
    }
    else
    {
        // TTRQ
        TrTRACE(XACT_SEND, "Exactly1 send: TTRQ TimeOut: Pkt SeqID=%x / %x, SeqN=%d",
           HighSeqID(Pkt.GetSeqID()), LowSeqID(Pkt.GetSeqID()), Pkt.GetSeqN());

        if (g_OutSeqHash.LookupDelivered(&MsgId, NULL))
        {
            // Packet is in delivered list already, we must ONLY arm the TTBR timer

            // Calculate additional delay for TTBR as min of specified TTRQ,TTBR
            //  or take it from registry if it has been specified there
            ULONG ulDelay = 0;
            if (g_ulDelayExpire != 0)
            {
                ulDelay = g_ulDelayExpire;
            }
            else
            {
                CBaseHeader* pBase = (CBaseHeader *)pPktBaseHdr;
                CUserHeader* pUser = (CUserHeader*) pBase->GetNextSection();

                if (pBase->GetAbsoluteTimeToQueue() > pUser->GetSentTime())
                {
                    ulDelay = pBase->GetAbsoluteTimeToQueue() - pUser->GetSentTime();
                }
            }

            QmAcArmPacketTimer(g_hAc, pDriverPacket, TRUE, ulDelay, eDeferOnFailure);
        }
        else
        {
            // The packet is not delivered yet

            // Process TTRQ
            g_OutSeqHash.SeqPktTimedOutEx(&Pkt, pPktBaseHdr);

            // Release reference counter
            QmAcFreePacket1(g_hAc, pDriverPacket, MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, eDeferOnFailure);
        }
    }
}


/*====================================================
COutSeqHash::SeqPktTimedOutEx
    Called from driver handle routine at packet TTRQ time-out
=====================================================*/
void COutSeqHash::SeqPktTimedOutEx(CQmPacket *pPkt, CBaseHeader* pPktBaseHdr)
{
    // Serializing all outgoing hash activity on the highest level
    // Entering MsgId into the Recently Timed Out Cache (to prevent sending)

    CS lock(g_critOutSeqHash);

    LONGLONG  liSeqID    = pPkt->GetSeqID();
    ULONG     ulSeqN     = pPkt->GetSeqN();
    ULONG     ulPrevSeqN = pPkt->GetPrevSeqN();
	UNREFERENCED_PARAMETER(ulPrevSeqN);

    TrTRACE(XACT_SEND, "Exactly1 send: TTRQ TimeOut: Pkt  SeqID=%x / %x, SeqN=%d",
           HighSeqID(pPkt->GetSeqID()), LowSeqID(pPkt->GetSeqID()), ulSeqN);

    // Remember last shot TTRQ we learned from the driver
    m_ulMaxTTRQ = pPktBaseHdr->GetAbsoluteTimeToQueue();

    // Looking for the Seq packet among outgoing sequences
    R<COutSequence> pOutSeq;
    Consult(liSeqID, pOutSeq);

    // Remove pkt from the sequence, generate NACK
    if (pOutSeq.get() != NULL && pOutSeq->Delete(ulSeqN, MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT))
        return;

    // The packet was not found in the OutSeqHash; maybe it was new

    //  Send negative acknowledgment
    UCHAR AckType =  pPkt->GetAckType();
    if(MQCLASS_MATCH_ACKNOWLEDGMENT(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, AckType))
    {
        pPkt->CreateAck(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT);
    }
}

static
VOID
ReceiveOrderCommandsInternal(
    const CMessageProperty* pmp,
    const QUEUE_FORMAT* pqf
	)
{
	if (!pmp->bConnector && (pmp->dwBodySize == sizeof(OrderAckData)))
    {
        // This ack comes from Falcon QM, not from Connector application
        if (pmp->wClass == MQMSG_CLASS_NACK_BAD_DST_Q)
        {
            //
            // Bad Destination or Queue Deleted Ack
            //    may be temporary: the queue may be created/published later
            // We kill it and insert into the holes list
            //

            //
            // Need comments.
            // MQMSG_CLASS_NACK_BAD_DST_Q may arrive not from our intended destiantion machine
            // thus this does not mean that all previous packets are delivered. so DON'T handle
            // this as an Order ACK.
            //
            OrderAckData*  pOrderData = (OrderAckData*)pmp->pBody;

            TrTRACE(XACT_SEND, "Exactly1 send: Order Ack came: SeqID=%x / %x, SeqN=%d, Class=%x ",
                            HighSeqID(pOrderData->m_liSeqID), LowSeqID(pOrderData->m_liSeqID),
                            pOrderData->m_ulSeqN, pmp->wClass);

            // We want to move this specific outgoing msg to resolved/bad_dest.
            R<COutSequence> pOutSeq;
            if (g_OutSeqHash.Consult(pOrderData->m_liSeqID, pOutSeq))
            {
                pOutSeq->BadDestAckCame(pOrderData->m_ulSeqN, pmp->wClass);
            }
        }

        if (pmp->wClass == MQMSG_CLASS_ORDER_ACK ||
            pmp->wClass == MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q ||
            pmp->wClass == MQMSG_CLASS_NACK_Q_DELETED)
        {
            //
            // These acks signal that the message reached queue and had right seq n
            // Move this and all preceding msgs from outgoing Q to delivered list
            //
            OrderAckData*  pOrderData = (OrderAckData*)pmp->pBody;

            TrTRACE(XACT_SEND, "Exactly1 send: Order Ack came: SeqID=%x / %x, SeqN=%d, Class=%x ",
                            HighSeqID(pOrderData->m_liSeqID), LowSeqID(pOrderData->m_liSeqID), pOrderData->m_ulSeqN, pmp->wClass);

            g_OutSeqHash.SeqAckCame(pOrderData->m_liSeqID,
                                    pOrderData->m_ulSeqN,
                                    pqf
									);
        }
    }
    else
    {
        TrTRACE(XACT_SEND, "Exactly1 send: Non-order Ack came: Class=%x ", pmp->wClass);
    }


    if (pmp->wClass != MQMSG_CLASS_ORDER_ACK)
    {
        // All acks except seq mean final resolution
        g_OutSeqHash.ResolveDelivered((OBJECTID*)pmp->pCorrelationID, pmp->wClass);
    }
}


VOID
WINAPI
ReceiveOrderCommands(
    const CMessageProperty* pmp,
    const QUEUE_FORMAT* pqf
	)
{
    CS lock(g_critOutSeqHash);  // Serializes all outgoing hash activity on the highest level
    ASSERT(pmp != NULL);

	if(pmp->pEodAckStreamId == NULL)
	{
		//
		// This message is a native protocol acknowldgment. It might be an order
		// acknowledgment or some other class. Go process it.
		//
		ASSERT(!FnIsDirectHttpFormatName(pqf));
		ReceiveOrderCommandsInternal(pmp, pqf);
		return;
	}

	//
	// This message is an SRMP order acknowledgment. Emulate native protocol
	// data and go process this message.
	//

	//
	// first of all we do some validity checks
	//
	if ((pmp->dwBodySize !=0) || (pmp->dwAllocBodySize != 0))
	{
		TrERROR(XACT_GENERAL,"Rejecting SRMP order ack with body");
		ASSERT_BENIGN(pmp->dwBodySize == 0);
		ASSERT_BENIGN(pmp->dwAllocBodySize == 0);
		return;
	}
	if (!FnIsDirectHttpFormatName(pqf))
	{
		TrERROR(XACT_GENERAL,"Rejecting SRMP order ack without HTTP format name");
		ASSERT_BENIGN(FnIsDirectHttpFormatName(pqf));
		return;
	}
	if((pmp->EodAckSeqNum<0) || (pmp->EodAckSeqNum > ULONG_MAX))
	{
		TrERROR(XACT_GENERAL,"Rejecting SRMP order ack with SeqID not in range");
		ASSERT_BENIGN(0);
		return;
	}

	LONGLONG SeqId = pmp->EodAckSeqId;
	ULONG SeqNo = static_cast<ULONG>(pmp->EodAckSeqNum);
	if(IsValidAck(SeqId, pmp->pSenderStream))
	{
        if (pmp->wClass == MQMSG_CLASS_ORDER_ACK)
        {
			g_OutSeqHash.SeqAckCame(SeqId, SeqNo, pqf);
		} 
		else
		{
 	        g_OutSeqHash.ResolveDelivered((OBJECTID*)pmp->pCorrelationID, pmp->wClass);
    	}
        return;
	}
	
	TrERROR(
		XACT_GENERAL,
		"Rejecting order ack that does not match any exsiting stream. SeqID=%I64x",
		SeqId
		);
	
	if ((NULL != pmp->pSenderStream) && (pmp->pSenderStream->IsValid()))
	{
		TrERROR(
			XACT_GENERAL,
			"Rejecting order ack that does not match any exsiting stream. SenderStream=%.*s",
			xstr_t((char*)pmp->pSenderStream->data(), pmp->pSenderStream->size())
			);
	}
}


/*====================================================
GetOrderQueueFormat
    Provides order queue format name
=====================================================*/
static HRESULT GetOrderQueueFormat(QUEUE_FORMAT * pQueueFormat)
{
    HRESULT rc;
    WCHAR wsz[256];

    wcscpy(wsz,g_szMachineName);                  // machine name
    wcscat(wsz, FN_PRIVATE_SEPERATOR);            // '\'
    wcscat(wsz, PRIVATE_QUEUE_PATH_INDICATIOR);   //  'private$\'
    wcscat(wsz, ORDERING_QUEUE_NAME);             //'ORDER_QUEUE$'

    // Building queue format
    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(wsz, pQueueFormat);

    if (FAILED(rc))
    {
        LogHR(rc, s_FN, 30);        // The ORDER_QUEUE doesn't exist
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));

    return(MQ_OK);
}

/*====================================================
QMInitOrderQueue
    Initializes continuous reading from the Ordering Queue
=====================================================*/
HRESULT QMInitOrderQueue()
{
    QUEUE_FORMAT QueueFormat;

    TrTRACE(XACT_GENERAL, "Entering CResourceManager::InitOrderQueue");

    HRESULT hr = GetOrderQueueFormat( &QueueFormat);
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "ERROR : CResourceManager::InitOrderQueue -> couldn't get Ordering Queue from registry!!!");
        return LogHR(hr, s_FN, 40);
    }

    return LogHR(QmpOpenAppsReceiveQueue(&QueueFormat,ReceiveOrderCommands), s_FN, 1321);
}


HRESULT
COutSeqHash::GetLastAck(
     LONGLONG liSeqID,
     ULONG& ulSeqN
     ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    if (!fSequenceExist)
    {
        return LogHR(MQ_ERROR, s_FN, 50);
    }

    ulSeqN = pOutSeq->AckSeqN();

    return MQ_OK;


}

HRESULT
COutSequence::GetUnackedSequence(
    LONGLONG* pliSeqID,
    ULONG* pulSeqN,
    ULONG* pulPrevSeqN,
    BOOL fFirst
    ) const
{
    if (m_listSeqUnackedPkts.IsEmpty())
    {
        *pliSeqID = 0;
        *pulSeqN = 0;
        *pulPrevSeqN = 0;
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    CSeqPacket* pSeqPacket;
    if (fFirst)
    {
        pSeqPacket = m_listSeqUnackedPkts.GetHead();
    }
    else
    {
        pSeqPacket = m_listSeqUnackedPkts.GetTail();
    }

    *pliSeqID = pSeqPacket->GetSeqID();
    *pulSeqN = pSeqPacket->GetSeqN();
    *pulPrevSeqN = pSeqPacket->GetPrevSeqN();

    return MQ_OK;
}


DWORD
COutSequence::GetResendInterval(
    void
    )const
{
    ULONG len = sizeof(g_aulSeqResendCycle) / sizeof(ULONG);
    ULONG ind = ResendIndex();
    ind = (ind >= len ? len-1 : ind);

    return g_aulSeqResendCycle[ind];
}


HRESULT
COutSeqHash::GetUnackedSequence(
    LONGLONG liSeqID,
    ULONG* pulSeqN,
    ULONG* pulPrevSeqN,
    BOOL fFirst
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    if (!fSequenceExist)
    {
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    LONGLONG tempSeqId;
    HRESULT hr;
    hr = pOutSeq->GetUnackedSequence(&tempSeqId, pulSeqN, pulPrevSeqN, fFirst);
    ASSERT(FAILED(hr) || (tempSeqId == liSeqID));

    return MQ_OK;
}


DWORD_PTR
COutSeqHash::GetOutSequenceInfo(
    LONGLONG liSeqID,
    INFO_TYPE InfoType
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    //
    // Look for the out sequence in the internal data structure. If not found return 0
    //
    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    if (!fSequenceExist)
    {
        return 0;
    }

    switch (InfoType)
    {
        case eUnackedCount:
            return pOutSeq->GetUnackedCount();

        case eLastAckTime:
            return pOutSeq->GetLastAckedTime();

        case eLastAckCount:
            return pOutSeq->GetLastAckCount();

        case eResendInterval:
            return pOutSeq->GetResendInterval();

        case eResendTime:
            return pOutSeq->GetNextResendTime();

        case eResendIndex:
            return pOutSeq->ResendIndex();

        default:
            ASSERT(0);
            return 0;
    }

}


DWORD
COutSeqHash::GetAckedNoReadCount(
    LONGLONG liSeqID
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    DWORD count = 0;
    POSITION pos = m_mapWaitAck.GetStartPosition();
    while(pos)
    {
        CSeqPacket* pSeqPacket;
        DWORD Id;
        m_mapWaitAck.GetNextAssoc(pos, Id, pSeqPacket);
        if (pSeqPacket->GetSeqID() == liSeqID)
        {
            ++count;
        }
    }

    return count;
}


void
COutSeqHash::AdminResend(
    LONGLONG liSeqID
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    //
    // Look for the out sequence in the internal data structure. If not found return 0
    //
    R<COutSequence> pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, pOutSeq);
    if (!fSequenceExist)
    {
        return;
    }

    pOutSeq->AdminResend();
}


void
COutSequence::AdminResend(
    void
    )
{
    TrWARNING(XACT_SEND, "Exactly1 send: Admin Resend sequence: SeqID=%x / %x",  HighSeqID(), LowSeqID());

    //
    // Resend all packets
    //
    PlanNextResend(TRUE);
}

//--------------------------------------
//
// Class  CKeyDirection
//
//--------------------------------------
CKeyDirection::CKeyDirection(const QUEUE_FORMAT *pqf)
{
    CopyQueueFormat(*this, *pqf);
}

CKeyDirection::CKeyDirection()
{
}

CKeyDirection::CKeyDirection(const CKeyDirection &key)
{
    CopyQueueFormat(*this, key);
}

CKeyDirection::~CKeyDirection()
{
    DisposeString();
}

/*====================================================
HashKey for CKeyDirection CMap
    Makes ^ of subsequent double words
=====================================================*/
template<>
UINT AFXAPI HashKey(const CKeyDirection& key)
{
    DWORD dw2, dw3 = 0, dw4 = 0;

    dw2 = key.GetType();

    switch(key.GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            dw3 = HashGUID(key.PublicID());
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            dw3 = HashGUID(key.PrivateID().Lineage);
            dw4 = key.PrivateID().Uniquifier;
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            dw3 = HashKey(key.DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            dw3 = HashGUID(key.MachineID());
            break;
    }

    return dw2 ^ dw3 ^ dw4;
}

CKeyDirection &CKeyDirection::operator=(const CKeyDirection &key2 )
{
    CopyQueueFormat(*this, key2);
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactping.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactPing.cpp

Abstract:
    Ping-Pong persistency mechanism implementation

    Any data structure may be made persistent with this mechanism.
    Two files are allocated for keeping the data.
    Each Save writes into the alternate file.
    So we may be sure that we have at least 1 successfull copy.
    Ping-Pong loads from the latest valid copy.

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#ifndef COMP_TEST
#include "qmutil.h"
#else
#include <afxwin.h>
BOOL GetRegistryStoragePath(LPWSTR w1, LPWSTR w2, LPWSTR w3) {  return FALSE; }
#endif

#include "xactping.h"

#include "xactping.tmh"

static WCHAR *s_FN=L"xactping";

/*====================================================
CPingPong::CPingPong
    Constructor
=====================================================*/
CPingPong::CPingPong(
         CPersist *pPers,
         LPWSTR    pwsDefFileName, 
         LPWSTR    pwsRegKey,
         LPWSTR    pwszReportName)
{
    m_pPersistObject = pPers;

    wcscpy(m_wszRegKey,      pwsRegKey);
    wcscpy(m_wszDefFileName, pwsDefFileName);
    wcscpy(m_wszReportName,  pwszReportName);

    m_pwszFile[0]  = &m_wszFileNames[0];
    m_pwszFile[1]  = &m_wszFileNames[FILE_NAME_MAX_SIZE + 1];
}

/*====================================================
CPingPong::~CPingPong
    Destructor
=====================================================*/
CPingPong::~CPingPong()
{
}


/*====================================================
CPingPong::Init
    Inits the InSequences Hash
=====================================================*/
HRESULT CPingPong::Init(ULONG ulVersion)
{
    // Get ping-pong filename from registry or from default
    ChooseFileName();

    // We've found/formatted valid file and know his index
    HRESULT hr = m_pPersistObject->LoadFromFile(m_pwszFile[ulVersion%2]);
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "Cannot load %ls: hr=%x", m_wszReportName,  hr);
        LogHR(hr, s_FN, 10);
        return MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA;
    }

    // Is it the right version?
    if (ulVersion != m_pPersistObject->PingNo())
    {
        TrERROR(XACT_GENERAL, "Wrong version in checkpoint file %ls", m_wszReportName);
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 20);
    }

    // Checks the contents
    if (!m_pPersistObject->Check())
    {
        TrERROR(XACT_GENERAL, "Wrong data in checkpoint file %ls", m_wszReportName);
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 30);
    }

    // OK, we are ready
    return MQ_OK;
}

/*====================================================
CPingPong::Save
    Saves the correct state of the persistent object
=====================================================*/
HRESULT CPingPong::Save()
{
    HRESULT hr = S_OK;
    m_pPersistObject->PingNo()++;

    int ind = (m_pPersistObject->PingNo())  % 2;

    hr = m_pPersistObject->SaveInFile(m_pwszFile[ind], ind, FALSE);
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "Cannot save %ls: hr=%x", m_wszReportName, hr);
    }
    return LogHR(hr, s_FN, 50);
}

/*====================================================
CPingPong::Verify_Legacy
    Verifies both copies and finds the  valid one
=====================================================*/
BOOL CPingPong::Verify_Legacy(ULONG &ulPingNo)
{
    ULONG   ulPing[2];
    BOOL    fOk[2];
    HRESULT hr;

    // Test both copies
    for (int j=0; j<2; j++)
    {
        // Loads data
        hr = m_pPersistObject->LoadFromFile(m_pwszFile[j]);
        if (SUCCEEDED(hr))
        {
            // Checks them
            fOk[j]    = m_pPersistObject->Check();
            ulPing[j] = m_pPersistObject->PingNo();
            m_pPersistObject->Destroy();
        }
        else
        {
             fOk[j] = FALSE;
        }
    }

    if (fOk[0])
    {
        if (fOk[1])
            ulPingNo = (ulPing[0] > ulPing[1] ? 0 : 1); // both OK, take the latest
        else
            ulPingNo = 0;                               // 1th is bad
    }
    else
    {
        if (fOk[1])
            ulPingNo = 1;                               // 0th is bad
        else
            return FALSE;
    }

    return(TRUE);
}


/*====================================================
CPingPong::ChooseFileParams
    Gets from Registry or from defaults file pathname

=====================================================*/
HRESULT CPingPong::ChooseFileName()
{
    // Set initial version and index
    WCHAR  wsz1[1000], wsz2[1000];

    wcscpy(wsz1, L"\\");
    wcscat(wsz1, m_wszDefFileName);
    wcscat(wsz1, L".lg1");

    wcscpy(wsz2, L"\\");
    wcscat(wsz2, m_wszDefFileName);
    wcscat(wsz2, L".lg2");


    // Get pathnames for 2 In Sequences log files
    if((GetRegistryStoragePath(m_wszRegKey, m_pwszFile[0], FILE_NAME_MAX_SIZE, wsz1) &&
        GetRegistryStoragePath(m_wszRegKey, m_pwszFile[1], FILE_NAME_MAX_SIZE, wsz2)) == FALSE)
    {
        // Prepare defaults for the transaction logfile names
        if ((GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, m_pwszFile[0], FILE_NAME_MAX_SIZE, wsz1) &&
             GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, m_pwszFile[1], FILE_NAME_MAX_SIZE, wsz2)) == FALSE)
        {
            wcscpy(m_pwszFile[0],L"C:");
            wcscat(m_pwszFile[0],wsz1);

            wcscpy(m_pwszFile[1],L"C:");
            wcscat(m_pwszFile[1],wsz2);
        }
    }

    return MQ_OK;
}

/*====================================================
CPingPong::Init_Legacy
    Inits the InSequences Hash from legacy data
    (works only once after upgrade)
=====================================================*/
HRESULT CPingPong::Init_Legacy()
{
    HRESULT hr = MQ_OK;
    ULONG   ulPingNo;
    // Get ping-pong filename from registry or from default
    ChooseFileName();
    // ignore hr:  if something bad, defaults are guaranteed

    // Verify the files; choose the one to read from
    if (!(Verify_Legacy(ulPingNo)))
    {
        // There is no valid file. Starting from scratch.
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 60);
    }

    // We've found/formatted valid file and know his index
    hr = m_pPersistObject->LoadFromFile(m_pwszFile[ulPingNo]);
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "Cannot load %ls: hr=%x", m_wszReportName, hr);
        return LogHR(hr, s_FN, 70);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactping.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactPing.h

Abstract:
    Persistency classes for ping-pong scheme:
        CPersist
		CPersistPing

Author:
    AlexDad

--*/

#ifndef __XACTPING_H__
#define __XACTPING_H__

#include "xactstyl.h"

enum TypePreInit {
  piNoData,
  piOldData,
  piNewData
};

//---------------------------------------------------------------------
//
// class CPersist: base class for every ping-pong-persistent class
//
//---------------------------------------------------------------------
class CPersist
{
public:
	CPersist::CPersist()  {};
	CPersist::~CPersist() {};

    virtual HRESULT  SaveInFile(                            // Saves in file
                                LPWSTR wszFileName,         //   Filename
                                ULONG ind,                  //   Index (0 or 1)
								BOOL fCheck) = 0;           //   TRUE in checking pass

    virtual HRESULT  LoadFromFile(LPWSTR wszFileName) = 0;  // Loads from file
                                  
 
    virtual BOOL     Check() = 0;                           // Verifies the state and returns ping no

    virtual HRESULT  Format(ULONG ulPingNo) = 0;            // Formats empty instance

    virtual void     Destroy() = 0;                         // Destroys all allocated data

    virtual ULONG&   PingNo() = 0;                          // Gives access to ulPingNo
};


//---------------------------------------------------------------------
//
// class CPersistPing : implements ping-pong functionality
//
//---------------------------------------------------------------------
class CPingPong
{
public:
	CPingPong::CPingPong(
         CPersist *pPers,                     // the class to be persisted
         LPWSTR    pwszRegKey,                // registry key name for files path
         LPWSTR    pwszDefFileName,           // default filename
         LPWSTR    pwszReportName);           // object name for reporting problems

    CPingPong::~CPingPong();

    HRESULT Init(ULONG ulVersion);            // Intialization
    HRESULT Save();                           // Saving

    HRESULT ChooseFileName();                 // Defines pathnames for the in-seq files

    HRESULT Init_Legacy();

private:
    BOOL    Verify_Legacy(ULONG &ulPingNo);   // Verifies both ping-pong files and finds the latest
                             
private:
    CPersist  *m_pPersistObject;              // The object to be persisted

    WCHAR      m_wszFileNames[2*FILE_NAME_MAX_SIZE+2];    // filenames
    LPWSTR     m_pwszFile[2];

    WCHAR      m_wszRegKey[FILE_NAME_MAX_SIZE];           // Registry key name
    WCHAR      m_wszDefFileName[FILE_NAME_MAX_SIZE];      // File default name
    WCHAR      m_wszReportName[FILE_NAME_MAX_SIZE];       // Name for reporting
};

#endif __XACTPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactrm.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    QmXactRm.h

Abstract:
    Transaction Resource Manager general definitions

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTRM_H__
#define __XACTRM_H__

#include "txdtc.h"
#include "qmrt.h"

// forward declaration
class CTransaction;
class CResourceManager;
class CXactSorter;

inline BOOL operator ==(const XACTUOW& a, const XACTUOW& b)
{
    return (memcmp(&a, &b, sizeof(XACTUOW)) == 0);
}

inline BOOL operator !=(const XACTUOW& a, const XACTUOW& b)
{
	return !(a == b);
}

template<>
inline UINT AFXAPI HashKey(const XACTUOW& key)
{
    return (*(UINT*)&key);
}

//---------------------------------------------------------------------
// CIResourceManagerSink: object provides IResourceManagerSink for call by DTC
//---------------------------------------------------------------------

class CIResourceManagerSink: public IResourceManagerSink
{
public:

    CIResourceManagerSink(CResourceManager *pRM);
    ~CIResourceManagerSink(void);

    STDMETHODIMP            QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
    STDMETHODIMP_ (ULONG)   AddRef(void);
    STDMETHODIMP_ (ULONG)   Release(void);

    // IResourceManagerSink interface:
    // Defines the TMDown interface to notify RM when the transaction
    // transaction manager is down.
    //      TMDown          -- callback received when the TM goes down

    STDMETHODIMP            TMDown(void);

private:
    ULONG             m_cRefs;      // reference counter
    CResourceManager *m_pRM;        // backpointer to parent RM
};

//---------------------------------------------------------------------
// CResourceManager object
//---------------------------------------------------------------------
class CResourceManager : public CPersist
{
public:

    // Construction
    CResourceManager();
    ~CResourceManager( void );

    // Initialization
    HRESULT PreInit(ULONG ulVersion, TypePreInit tpCase);
    HRESULT Init(void);
    HRESULT ProvideDtcConnection(void);
    HRESULT ConnectDTC(void);
    void    DisconnectDTC(void);
    HRESULT InitOrderQueue(void);

    HRESULT ReenlistTransaction( 
            byte *pPrepInfo,
            ULONG cbPrepInfo,
            DWORD lTimeout,
            XACTSTAT *pXactStat);

	// Enlist transaction
    HRESULT EnlistTransaction(
            const XACTUOW* pUow,
            DWORD cbCookie,
            unsigned char *pbCookie);

    HRESULT EnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact);

    // Forget transaction
    void ForgetTransaction(CTransaction *pTrans);

	//
	// Find transaction by UOW
	//
	CTransaction *FindTransaction(const XACTUOW *pUOW);

	//
	// Recover all transactions
	//
	HRESULT	  RecoverAllTransactions();

	//
	// Release all complete trasnactions
	//
	void      ReleaseAllCompleteTransactions();

    // Numbering and sorting
    ULONG     AssignSeqNumber();                     // assigns next sequential number for the transaction
    void      InsertPrepared(CTransaction *pTrans);  // inserts the prepared xaction into the list of prepared
    void      InsertCommitted(CTransaction *pTrans); // inserts the Commit1-ed xaction into the list
    void	  RemoveAborted(CTransaction *pTrans);   // removes the prepared xaction fromthe list of prepared
    void      SortedCommit(CTransaction *pTrans);    // marks prepared xact as committed and commits what's possible
    void      SortedCommit3(CTransaction *pTrans);   // marks Commit1-ed xact
    CCriticalSection &SorterCritSection();           // provides access to the sorter crit.section
    CCriticalSection &CritSection();                 // provides access to the crit.section

    // Persistency
    HRESULT SaveInFile(                       // Saves in file
                LPWSTR wszFileName,
                ULONG ulIndex,
                BOOL fCheck);

    HRESULT LoadFromFile(LPWSTR wszFileName);      // Loads from file


    BOOL    Save(HANDLE  hFile);              // Save / Load
    BOOL    Load(HANDLE  hFile);
    BOOL    Check();                          // Verifies the state
    HRESULT Format(ULONG ulPingNo);           // Formats empty instance
    void    Destroy();                        // Destroyes allocated data
    ULONG&  PingNo();                         // Gives access to ulPingNo
    HRESULT Save();                           // Saves via ping-ponger

    void XactFlagsRecovery(                   // Data Recovery per log record
                USHORT usRecType,
                PVOID pData,
                ULONG cbData);


    // Transaction indexing
	ULONG Index();   
   
    // Debugging features
    void IncXactCount();
    void DecXactCount();
	 

private:    
	HRESULT CheckInit();
	CTransaction* GetRecoveringTransaction(ULONG ulIndex);
	CTransaction* NewRecoveringTransaction(ULONG ulIndex);
	void  StartIndexing();                           // start indexing from zero
                                   // provides next unused index



// Live data
private:

    // Mapping UOW->Active Transactions
    CMap<XACTUOW, const XACTUOW&, CTransaction *, CTransaction*> m_Xacts;

    // Temp mapping from Index (used during recovery)
    CMap<ULONG,   const ULONG&,   CTransaction *, CTransaction*> m_XactsRecovery;

    BOOL                   m_fEmpty;     // temp keeping
    ULONG                  m_ulXactIndex;// Last known xact index
    GUID                   m_RMGuid;     // RM instance GUID (recoverable)

    // Data for persistency control (via 2 ping-pong files)
    ULONG                  m_ulPingNo;   // Current counter of ping write
    ULONG                  m_ulSignature;// Saving signature
    CPingPong              m_PingPonger; // Ping-Pong persistency object

    // Current pointers
    IUnknown              *m_punkDTC;    // pointer to the local DTC
    ITransactionImport    *m_pTxImport;  // DTC import transaction interface
    IResourceManager      *m_pIResMgr;   // DTC Resource manager interface.
    CIResourceManagerSink  m_RMSink;     // RM Sink object
    P<CXactSorter>         m_pXactSorter;   // Transactions sorter object
    P<CXactSorter>         m_pCommitSorter; // Commit2 sorter object
	
	//
	// This interlockded exchanged value descides which thread gets to try and connect to the DTC.
	//
	LONG volatile m_ConnectDTCTicket;
	CAutoCloseHandle m_hConnectDTCCompleted;

	//
	// This critical section is initialized for preallocated resources. 
	// This means it does not throw exception when entered.
	//
    CCriticalSection       m_critRM;     // critical section for mutual exclusion

	BOOL				   m_fInitComplete;
	BOOL					m_fNotifyWhenRecoveryCompletes;

#ifdef _DEBUG
    LONG                   m_cXacts;     // live transactions counter
#endif
};

//-------------------------------------
// external declarations of globals
//-------------------------------------
extern CResourceManager *g_pRM;          // Global single instance of the RM

extern HRESULT QMPreInitResourceManager(ULONG ulVersion, TypePreInit tpCase);
extern HRESULT QMInitResourceManager();
extern void    QMFinishResourceManager();

template<>
UINT AFXAPI HashKey( LONGLONG key);

#endif __XACTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactsink.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSink.cpp

Abstract:
    This module implements CIResourceManagerSink object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "Xact.h"

#include "xactsink.tmh"

static WCHAR *s_FN=L"xactsink";


//---------------------------------------------------------------------
// CIResourceManagerSink::CIResourceManagerSink
//---------------------------------------------------------------------

CIResourceManagerSink::CIResourceManagerSink(CResourceManager *pRM)
{
	m_cRefs = 0;
    m_pRM   = pRM;
}


//---------------------------------------------------------------------
// CIResourceManagerSink::~CIResourceManagerSink
//---------------------------------------------------------------------
CIResourceManagerSink::~CIResourceManagerSink(void)
{
	// Do nothing.
}



//---------------------------------------------------------------------
// CIResourceManagerSink::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CIResourceManagerSink::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_IResourceManagerSink == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// CIResourceManagerSink::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CIResourceManagerSink::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// CIResourceManagerSink::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CIResourceManagerSink::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	ASSERT((INT)m_cRefs >= 0);  	// No delete, because we use object statically

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// CIResourceManagerSink::TMDown
//---------------------------------------------------------------------
STDMETHODIMP CIResourceManagerSink::TMDown(void)
{
    TrERROR(XACT_GENERAL, "RM TMDown");

    m_pRM->DisconnectDTC();        // inform RM of DTC failure

    return S_OK;				
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactsort.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSort.h

Abstract:
    Transaction sorter object definition

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTSORT_H__
#define __XACTSORT_H__

#include "xact.h"

//---------------------------------------------------------------------
// CSortedTransaction:  Transaction Sorter List element
//---------------------------------------------------------------------
class CSortedTransaction
{
public:

     CSortedTransaction(CTransaction *pTrans);
    ~CSortedTransaction();

    void            Commit(TXSORTERTYPE type);   // commits really
	void			JumpStartCommitRequest();
    void			CommitRestore();// commits really on recovery stage
    ULONG           SortNum();      // returns sort number
    BOOL            IsMarked();     // returns the mark
    
    BOOL            IsEqual(        // compares with the CTransaction
                        CTransaction *pTrans);      

    void            AskToCommit();    // marks for commit

private:                                        
    CTransaction    *m_pTrans;      // transaction itself
    ULONG           m_ulSortNum;    // seq number of the prepare
    BOOL            m_fMarked;      // marked for commit
};


// Constructor
inline CSortedTransaction::CSortedTransaction(CTransaction *pTrans)
{ 
    m_pTrans    = pTrans; 
    m_pTrans->AddRef();

    m_ulSortNum = pTrans->GetSeqNumber();
    m_fMarked   = FALSE;
}


// Destructor
inline CSortedTransaction::~CSortedTransaction()
{
    m_pTrans->Release();
}

// Real commit for recovery stage
inline void CSortedTransaction::CommitRestore()
{ 
    ASSERT(m_fMarked);
    m_pTrans->CommitRestore0(); 
}

// Get for SortNum index
inline ULONG CSortedTransaction::SortNum() 
{
    return m_ulSortNum;
}

// Get for Marked flag
inline BOOL CSortedTransaction::IsMarked()
{
    return m_fMarked;
}

// Mark for commiting, preserve parameters
inline void CSortedTransaction::AskToCommit()
{
    m_fMarked   = TRUE;
}
 
// Compares with the CTransaction
inline BOOL CSortedTransaction::IsEqual(CTransaction *pTrans)
{
    return (pTrans ==  m_pTrans);
}

//---------------------------------------------------------------------
// CXactSorter: Transaction Sorter Object
//---------------------------------------------------------------------
class CXactSorter
{
public:

    // Construction 
    //
    CXactSorter(TXSORTERTYPE type);
    ~CXactSorter();

    // Main operations
    void InsertPrepared(CTransaction *pTrans);  // inserts prepared xaction
    void RemoveAborted(CTransaction *pTrans);  // removes aborted xaction
    void SortedCommit(CTransaction *pTrans);  // marks as committed and  commits what's possible 
    ULONG AssignSeqNumber();
    CCriticalSection &SorterCritSection();          // provides access to the crit.section

private:
    void DoCommit(CSortedTransaction *pSXact);   // Commit/CommitRestore

    // Data
    //
	CList<CSortedTransaction *, CSortedTransaction *&> 
                        m_listSorter;       // List of prepared transactions
    ULONG               m_ulSeqNum;         // Last used transaction number
    TXSORTERTYPE        m_type;             // Sorter type
};


// Assigns next seq number for the prepared xaction
inline ULONG CXactSorter::AssignSeqNumber()
{
    // BUGBUG:  provide wrap-up
    return m_ulSeqNum++;
}

#endif __XACTSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactsort.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSort.cpp

Abstract:
    Transactions Sorter Object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactSort.h"
#include "XactStyl.h"
#include "cs.h"

#include "xactsort.tmh"

//
// This critical section is initialized for preallocated resources. 
// This means it does not throw exception when entered.
//
static CCriticalSection g_critSorter(CCriticalSection::xAllocateSpinCount);       // provides mutual exclusion for the list
static WCHAR *s_FN=L"xactsort";
                                           // Serves both Prepare and Commit sorters

//--------------------------------------
//
// Class  CXactSorter
//
//--------------------------------------

/*====================================================
CXactSorter::CXactSorter
    Constructor 
=====================================================*/
CXactSorter::CXactSorter(TXSORTERTYPE type) 
{
    m_type           = type;                   // Prepare or Commit sorter
    m_ulSeqNum       = 0;                      // Initial last used transaction number
}


/*====================================================
CXactSorter::~CXactSorter
    Destructor 
=====================================================*/
CXactSorter::~CXactSorter()
{
    CS lock(g_critSorter);

    // Cycle for all transactions
    POSITION posInList = m_listSorter.GetHeadPosition();
    while (posInList != NULL)
    {
        CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
        delete pSXact;
    }

    m_listSorter.RemoveAll();     
}

/*====================================================
CXactSorter::InsertPrepared
    Inserts prepared xaction into the list   
=====================================================*/
void CXactSorter::InsertPrepared(CTransaction *pTrans)
{
    CS lock(g_critSorter);

	//
	// We assume that we never fail in a way that causes a transaction to be added twice to a sorter.
	//
	ASSERT(m_listSorter.IsEmpty() || !m_listSorter.GetTail()->IsEqual(pTrans));

	P<CSortedTransaction> SXact = new CSortedTransaction(pTrans);
    CSortedTransaction* pSXact = SXact.get();

    // In the normal work mode - adding to the end (it is the last prepared xact)
    m_listSorter.AddTail(pSXact);
	SXact.detach(); 
}

/*====================================================
CXactSorter::RemoveAborted
    Removes aborted xact and  commits what's possible    
=====================================================*/
void CXactSorter::RemoveAborted(CTransaction *pTrans)
{
    CS lock(g_critSorter);

    // Lookup for the pointed xaction; note all previous unmarked
    BOOL     fUnmarkedBefore = FALSE;
    BOOL     fFound          = FALSE;
    POSITION posInList = m_listSorter.GetHeadPosition();
    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
        
        ASSERT(pSXact);
        if (pSXact->IsEqual(pTrans))
        {
            m_listSorter.RemoveAt(posCurrent);
            ASSERT(!fFound);
			ASSERT(!pSXact->IsMarked());
            fFound = TRUE;
            delete pSXact;
            continue;
        }

        if(fFound && !pSXact->IsMarked()) 
		{
			//
			// We found a transaction not ready to commit after our aborted transaction,
			// so there is no need to continue searching for a transaction to commit.
			//
			return;
		}

        if(!pSXact->IsMarked() )
		{
			//
			// Remember that we found a transaction unmarked for commit before our aborted transaction, 
			// because in this case we will not try to commit transactions after our aborted transaction.
			//
            fUnmarkedBefore = TRUE;
			continue;
        }
        
		if (fFound && !fUnmarkedBefore)
        {
			//
			// We found a transaction ready for commit, so we try to jump-start the sorted commit process for that transaction.
			//
			pSXact->JumpStartCommitRequest();
			return;
        }
    }
}

/*====================================================
CXactSorter::SortedCommit
    Marks xaction as committed and commits what's possible    
=====================================================*/
void CXactSorter::SortedCommit(CTransaction *pTrans)
{
    CS lock(g_critSorter);

    // Lookup for the pointed xaction; note all previous unmarked
    BOOL     fUnmarkedBefore = FALSE;
    BOOL     fFound          = FALSE;

	//
	// Search through the sorted transactions
	// Commit all transactions until you find the first one which is not marked for commit.
	// (If you can not commit pTransA now, mark it for commit later)
	//
	POSITION posInList = m_listSorter.GetHeadPosition();
	while (posInList != NULL)
	{
		POSITION posCurrent = posInList;
		CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
    
		ASSERT(pSXact);
		if (pSXact->IsEqual(pTrans))
		{
			//
			// Found our transaction. Mark it for commit.
			//
			fFound = TRUE;
			pSXact->AskToCommit();  
		}

		if (!pSXact->IsMarked() && fFound)
		{
			//
			// We found a transaction not ready to commit after our committed transaction,
			// so there is no need to continue searching for a transaction to commit.
			//
			return;
		}

		if (!pSXact->IsMarked())  
		{
			//
			// Found a transaction not marked for commit. Remember that since we can't commit later transactions
			// until we commit this one.
			//
			fUnmarkedBefore = TRUE; 
		}
		
		if (pSXact->IsMarked() && !fUnmarkedBefore)
		{
			//
			// Commit all marked transactions untill we meet an unmarked transaction.
			//
			DoCommit(pSXact);
			m_listSorter.RemoveAt(posCurrent);
		}
	}
}


/*====================================================
CXactSorter::DoCommit
      Committes the sorted transaction
=====================================================*/
void CXactSorter::DoCommit(CSortedTransaction *pSXact)
{
    pSXact->Commit(m_type);
    delete pSXact;
}

/*====================================================
CXactSorter::Commit
      Committes the sorted transaction
=====================================================*/
void CSortedTransaction::Commit(TXSORTERTYPE type)
{ 
    ASSERT(m_fMarked);

    switch (type)
    {
    case TS_PREPARE:
        m_pTrans->CommitRequest0(); 
        break;

    case TS_COMMIT:
        m_pTrans->CommitRequest3(); 
        break;

    default:
        ASSERT(FALSE);
        break;
    }
}

void CSortedTransaction::JumpStartCommitRequest()
{
    ASSERT(m_fMarked);

	m_pTrans->JumpStartCommitRequest();
}


// provides access to the crit.section
CCriticalSection &CXactSorter::SorterCritSection()
{
    return g_critSorter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactrm.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactRm.cpp

Abstract:
    This module implements QM transactional Resource Manager object

Author:
    Alexander Dadiomov (AlexDad)
--*/

#include "stdh.h"
#include "Xact.h"
#include "xactstyl.h"
#include "mqutil.h"
#include "qmutil.h"
#include "qmpkt.h"
#include "xactout.h"
#include "xactsort.h"
#include "xactlog.h"
#include "SmartHandleImpl.h"
#include <mqexception.h>

#include "xactrm.tmh"

static WCHAR *s_FN=L"xactrm";

//-------------------------------------
// Declaration of global RM instance
//-------------------------------------
CResourceManager *g_pRM;

// Crash order for debugging recovery
ULONG g_ulCrashPoint    = 0;
ULONG g_ulCrashLatency  = 0;
ULONG g_ExitProbability = 0;
ULONG g_FailureProbability = 0;
ULONG g_FailureProbabilityStop = 0;
ULONG g_ulXactStub      = 0;

extern LONG g_ActiveCommitThreads;
extern bool g_QmGoingDown;


// Xact file signature
#define XACTS_SIGNATURE         0x5678

//-------------------------------------------
// Externals
//-------------------------------------------

extern void CleanXactQueues();

#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CResourceManager::CResourceManager
    Constructor
=====================================================*/
CResourceManager::CResourceManager()
    : m_PingPonger(this,
                   FALCON_DEFAULT_XACTFILE_PATH,
                   FALCON_XACTFILE_PATH_REGNAME,
                   FALCON_XACTFILE_REFER_NAME),
      m_RMSink(this),
	  m_critRM(CCriticalSection::xAllocateSpinCount)	  
{
    m_punkDTC     = NULL;
    m_pTxImport   = NULL;
    m_pIResMgr    = NULL;
    m_ulXactIndex = 0;
    m_pXactSorter = new CXactSorter(TS_PREPARE);
    m_pCommitSorter = new CXactSorter(TS_COMMIT);
    m_RMGuid.Data1= 0;
	m_fInitComplete = FALSE;
	m_fNotifyWhenRecoveryCompletes = FALSE;

	m_ConnectDTCTicket = 0;

	//
	// Manual reset event to signal that connect to DTC was established.
	//
	m_hConnectDTCCompleted = CreateEvent(NULL, TRUE, FALSE, NULL);
	if(m_hConnectDTCCompleted == NULL)
	{
		DWORD gle = GetLastError();
		TrERROR(XACT_GENERAL, "Failed to create DTC connection event, gle = %!winerr!", gle);
		throw bad_win32_error( gle);
	}

#ifdef _DEBUG
    m_cXacts      = 0;
#endif
}
#pragma warning(default: 4355)  //  'this' : used in base member initializer list


/*====================================================
CResourceManager::~CResourceManager
    Destructor
=====================================================*/
CResourceManager::~CResourceManager()
{
	if (m_punkDTC)
	{
		m_punkDTC->Release();
		m_punkDTC = NULL;
	}

	if (m_pTxImport)
	{
		m_pTxImport->Release();
		m_pTxImport = NULL;
	}

	if (m_pIResMgr)
	{
		m_pIResMgr->Release();
		m_pIResMgr = NULL;
	}
}

/*====================================================
CResourceManager::ConnectDTC
    ConnectDTC : called in init and after DTC's fail
=====================================================*/
HRESULT CResourceManager::ConnectDTC(void)
{
    HRESULT  hr = MQ_ERROR;

    try
    {
        // Get a pointer to DTC and check that DTC is running
        hr = XactGetDTC(&m_punkDTC);
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "XactGetDTC 1 failed: %x ", hr);
        }
        CHECK_RETURN_CODE(MQ_ERROR_DTC_CONNECT, 1500);

        // Release m_pTxImport and m_pIResMgr interfaces
        DisconnectDTC();

		R<IResourceManagerFactory>  pIRmFactory  = NULL;

        // Get the resource manager factory from the IUnknown
        hr = m_punkDTC->QueryInterface(IID_IResourceManagerFactory,(LPVOID *) &pIRmFactory);
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "QI IResourceManagerFactory failed: %x ", hr);
        }
        CHECK_RETURN(1600);

        // Prepare client name (ANSI)
        CHAR szClientName[255];

        WCHAR  wszDtcClientName[255] = FALCON_DEFAULT_RM_CLIENT_NAME;
        DWORD  dwSize = sizeof(wszDtcClientName);
        DWORD  dwType = REG_SZ ;

        LONG lRes = GetFalconKeyValue(
                        FALCON_RM_CLIENT_NAME_REGNAME,
                        &dwType,
                        wszDtcClientName,
                        &dwSize,
                        FALCON_DEFAULT_RM_CLIENT_NAME
                        );
        ASSERT(lRes == ERROR_SUCCESS) ;
        ASSERT(dwType == REG_SZ) ;
		DBG_USED(lRes);

        size_t res = wcstombs(szClientName, wszDtcClientName, sizeof(szClientName));
        ASSERT(res != (size_t)(-1));
		DBG_USED(res);

		R<IResourceManager> pIResMgr;
		// Create instance of the resource manager interface.
        hr = pIRmFactory->Create (&m_RMGuid,
                                  szClientName,
                                  (IResourceManagerSink *) &m_RMSink,
                                  &pIResMgr.ref() );
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "pIRmFactory->Create failed: %x ", hr);
        }
        CHECK_RETURN_CODE(MQ_ERROR_DTC_CONNECT, 1510);

		CS lock(m_critRM);
		
        // Get a pointer to the ITransactionImport interface.
        hr = m_punkDTC->QueryInterface(IID_ITransactionImport,(void **)&m_pTxImport);
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "QI IID_ITransactionImport failed: %x ", hr);
        }
        CHECK_RETURN(1610);

		m_pIResMgr = pIResMgr.detach();
    }
    catch(const exception&)
    {
        if (SUCCEEDED(hr))
	    {
		    hr = MQ_ERROR_DTC_CONNECT;
	    }	
    }

    if (SUCCEEDED(hr))
    {
        TrTRACE(XACT_GENERAL, "Successfully MSDTC initialization");
    }
    else
    {
        TrERROR(XACT_GENERAL, "Could not connect to MSDTC");
    }

    return LogHR(hr, s_FN, 10);

}

/*====================================================
CResourceManager::ProvideDtcConnection
    Called each time before DTC is needed
=====================================================*/
HRESULT CResourceManager::ProvideDtcConnection(void)
{
	HRESULT hr;

	if(m_pIResMgr)
		return(MQ_OK);
	
	LONG InitialValue = InterlockedCompareExchange(&m_ConnectDTCTicket, 1, 0);
	if(InitialValue == 1)
	{
		//
		// Another thread has won the right to establish connection to the DTC. Wait here.
		// Wait 60 seconds for connection to establish before giving up.
		//
		DWORD res = WaitForSingleObject(m_hConnectDTCCompleted, 60000);
		if(res != WAIT_OBJECT_0)
		{
			TrERROR(XACT_GENERAL, "Gave up waiting for DTC connection.");
			return MQ_ERROR_DTC_CONNECT;
		}

		//
		// Did connection complete successfully?
		//
		if(m_pIResMgr == NULL)
		{
			TrTRACE(XACT_GENERAL, "No connection with transaction coordinator");
			return MQ_ERROR_DTC_CONNECT;
		}

		return MQ_OK;
	}

	//
	// We have the right to establish connection to the DTC;
	//
	hr = ConnectDTC();

	//
	// Allow other threads to try and establish connection if needed.
	//
	m_ConnectDTCTicket = 0;
	PulseEvent(m_hConnectDTCCompleted);

	if (FAILED(hr))
	{
        TrTRACE(XACT_GENERAL, "No connection with transaction coordinator");
        return LogHR(hr, s_FN, 20);
	}

    return LogHR(hr, s_FN, 30);
}

/*====================================================
CResourceManager::DisconnectDTC
    DisconnectDTC : called when DTC fails
=====================================================*/
void CResourceManager::DisconnectDTC(void)
{
    CS lock(m_critRM);

	if (m_pTxImport)
	{
		m_pTxImport->Release();
		m_pTxImport = NULL;
	}

	if (m_pIResMgr)
	{
		m_pIResMgr->Release();
		m_pIResMgr  = NULL;
    }

    TrWARNING(XACT_GENERAL, "MSDTC disconnected");
}


/*====================================================
CResourceManager::PreInit
    PreInitialization (DTC connection)
    Should be done before RPC Listen
=====================================================*/
HRESULT CResourceManager::PreInit(ULONG ulVersion, TypePreInit tpCase)
{
    HRESULT  hr = MQ_OK;

    switch(tpCase)
    {
    case piNoData:
        m_PingPonger.ChooseFileName();
        Format(0);
        break;
    case piNewData:
        hr = m_PingPonger.Init(ulVersion);
        break;
    case piOldData:
        hr = m_PingPonger.Init_Legacy();
        break;
    default:
        ASSERT(0);
        hr = MQ_ERROR;
        break;
    }

    if (m_RMGuid.Data1 == 0)
    {
        UuidCreate(&m_RMGuid);
    }
    return LogHR(hr, s_FN, 40);
}

/*====================================================
CResourceManager::Init
    Initialization
=====================================================*/
HRESULT CResourceManager::Init(void)
{
	if(m_fNotifyWhenRecoveryCompletes)
	{
		HRESULT hr;
		hr = ProvideDtcConnection();
		if (FAILED(hr))
		{
			EvReportWithError(EVENT_ERROR_CANNOT_CONNECT_MSDTC, hr);
			return LogHR(hr, s_FN, 50);
		}

		//
		// Report to DTC that all reenlistment is completed
		//

		R<IResourceManager> pIResMgr;
		{
			CS lock(m_critRM);
			pIResMgr = SafeAddRef(m_pIResMgr);
		}

		if(pIResMgr.get() == NULL)
			return MQ_ERROR_DTC_CONNECT;

		pIResMgr->ReenlistmentComplete();
	}

	//
    // Start indexing from zero
	//
    StartIndexing();

	m_fInitComplete = TRUE;
	
    return(MQ_OK);
}



HRESULT CResourceManager::CheckInit()
{
	if(m_fInitComplete)
		return MQ_OK;

	return MQ_ERROR_SERVICE_NOT_AVAILABLE;
}

HRESULT CResourceManager::ReenlistTransaction( 
        byte *pPrepInfo,
        ULONG cbPrepInfo,
        DWORD lTimeout,
        XACTSTAT *pXactStat)
{
	R<IResourceManager> pIResMgr;
	{
		CS lock(m_critRM);
		pIResMgr = SafeAddRef(m_pIResMgr);
	}

	if(pIResMgr.get() == NULL)
		return MQ_ERROR_DTC_CONNECT;

	m_fNotifyWhenRecoveryCompletes = TRUE;

	return pIResMgr->Reenlist(
			pPrepInfo,
			cbPrepInfo,
			lTimeout,
			pXactStat
			);
}


/*====================================================
CResourceManager::EnlistTransaction
    Enlist the external (DTC) transaction
=====================================================*/
HRESULT CResourceManager::EnlistTransaction(
    const XACTUOW* pUow,
    DWORD cbCookie,
    unsigned char *pbCookie)
{
    R<ITransaction>                pTransIm       = NULL;
    R<CTransaction>                pCTrans        = NULL;
    R<ITransactionResourceAsync>   pTransResAsync = NULL;
    R<ITransactionEnlistmentAsync> pEnlist        = NULL;
    CTransaction    *pCTrans1;
    HRESULT          hr     = MQ_OK;
    LONG             lIsoLevel;
    XACTUOW          uow1;

    TrTRACE(XACT_GENERAL," CResourceManager::EnlistTransaction");

	//
	// check if dtc is initalize and if not try to initialize it
	//
	hr = CheckInit();
	if(FAILED(hr))
		return hr;



    // Look for the transaction between the active ones
    {
        CS lock(m_critRM);
        if (m_Xacts.Lookup(*pUow, pCTrans1))
        {
            // Xaction already exists.
            return S_OK;
        }
        
        // Not found.  The  transaction is new.
        try
        {
            pCTrans = new CTransaction(this);
			pCTrans->SetCookie(cbCookie, pbCookie);  // we may need it for remote read
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 80);
        }

        pCTrans->SetUow(pUow);
#ifdef _DEBUG
		CTransaction *p;
#endif
		ASSERT(m_fInitComplete);
		ASSERT(!m_Xacts.Lookup(*pUow, p));
		m_Xacts[*pUow] = pCTrans.get();
    }

    // Creating transaction queue
    hr = pCTrans->CreateTransQueue();
    CHECK_RETURN_CODE(hr, 1520);

    // Provide the RM - DTC connection (it may have been torn down)
    hr = ProvideDtcConnection();
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "ProvideDtcConnection2 failed: %x ", hr);
    }
    CHECK_RETURN(1800);

    R<ITransactionImport> pTxImport;
    R<IResourceManager> pIResMgr;
	{
		CS lock(m_critRM);
		pTxImport = SafeAddRef(m_pTxImport);
		pIResMgr = SafeAddRef(m_pIResMgr);
	}

	if(pTxImport.get() == NULL || pIResMgr.get() == NULL)
		return MQ_ERROR_DTC_CONNECT;
	
    // Import the transaction
    hr = pTxImport->Import(
                     cbCookie,
                     pbCookie,
                     (GUID *) &IID_ITransaction,
                     (void **) &pTransIm
					 );
    if(FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "Import failed: %x ", hr);
		return MQ_ERROR_TRANSACTION_IMPORT;
    }

    pCTrans->SetState(TX_INITIALIZED);

    // Do we need it to addref pData->m_ptxRmAsync [DTC has now a reference] ??

    // prepare  ITransactionResourceAsync interface pointer
    hr = pCTrans->QueryInterface(IID_ITransactionResourceAsync,(LPVOID *) &pTransResAsync);
    CHECK_RETURN(1810);
	
	// Enlist on the transaction
    hr = pIResMgr->Enlist(
         pTransIm.get(),		// IN
         pTransResAsync.get(),	// IN
         (BOID *)&uow1,			// OUT
         &lIsoLevel,			// OUT: ignoring it
         &pEnlist.ref()			// OUT
		 );

    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "Enlist failed: %x ", hr);
		return MQ_ERROR_TRANSACTION_ENLIST;
    }

    pTransResAsync->AddRef();
    pCTrans->SetEnlist(pEnlist.get());

    // BUGBUG: We now reference DTC, so probably we need Addref to some TM interface here

	//
    // Enlistment on transaction is OK. Set current state to reflect enlistment
	//
    pCTrans->SetState(TX_ENLISTED);

    hr = S_OK;

    return LogHR(hr, s_FN, 90);
}

/*====================================================
CResourceManager::EnlistInternalTransaction
    Enlist the internal MSMQ transaction
=====================================================*/
HRESULT CResourceManager::EnlistInternalTransaction(
  XACTUOW *pUow,
  RPC_INT_XACT_HANDLE *phXact)
{
	HRESULT hr = CheckInit();
	if(FAILED(hr))
		return hr;

    R<CTransaction>  pCTrans = NULL;
   

    TrTRACE(XACT_GENERAL, " CResourceManager::EnlistInternalTransaction");

    // Look for the transaction between the active ones
    {
        CS lock(m_critRM);
        CTransaction    *pCTransOld;

        if (m_Xacts.Lookup(*pUow, pCTransOld))
        {
            //
            // Transaction with the same ID already exist. We do not allow
            // enlisting the same transaciton twice. (can't give more than one
            // context handle to the same transaction)
            //
            return LogHR(MQ_ERROR_TRANSACTION_SEQUENCE, s_FN, 99);
        }

        // Not found. Create new internal transaction
        try
        {
            pCTrans = new CTransaction(this, 0, TRUE);
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 100);
        }

		pCTrans->m_eType = 	CBaseContextType::eTransactionCtx;
        pCTrans->SetUow(pUow);

        // Include transaction in mapping (we need it for saving)
        ASSERT(m_fInitComplete);

        m_Xacts[*pUow] = pCTrans.get();

    }


    // Creating transaction queue
    hr = pCTrans->CreateTransQueue();
    CHECK_RETURN_CODE(hr, 1550);

    // Enlistment on transaction is OK. Set current state to reflect enlistment
    pCTrans->SetState(TX_ENLISTED);

	// set RPC context handle to keep pointer to xact
    *phXact = pCTrans.detach();

    return LogHR(hr, s_FN, 110);
}

/*====================================================
QMDoGetTmWhereabouts
    Returns to the app QM's controlling TM whereabouts
=====================================================*/
HRESULT QMDoGetTmWhereabouts(
    DWORD           cbBufSize,
    unsigned char *pbWhereabouts,
    DWORD         *pcbWhereabouts)
{
	DWORD dw = cbBufSize;
    HRESULT hr = XactGetWhereabouts(&dw, pbWhereabouts);
	*pcbWhereabouts = dw;
    return LogHR(hr, s_FN, 120);
}

/*====================================================
QMDoEnlistTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoEnlistTransaction(
    XACTUOW *pUow,
    DWORD cbCookie,
    unsigned char *pbCookie)
{
    ASSERT(g_pRM);

    if (!(cbCookie == 1 && *pbCookie == 0))
    {
        // We don't need DTC for uncoordinated transaction

        HRESULT hr = g_pRM->ProvideDtcConnection();
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "ProvideDtcConnection1 failed: %x ", 0);
            LogHR(hr, s_FN, 130);
            return MQ_ERROR_DTC_CONNECT;
        }
    }

    return LogHR(g_pRM->EnlistTransaction(pUow, cbCookie, pbCookie), s_FN, 140);
}

/*====================================================
QMDoEnlistInternalTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoEnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact)
{
    ASSERT(g_pRM);
    return LogHR(g_pRM->EnlistInternalTransaction(pUow, phXact), s_FN, 150);
}


/*====================================================
QMDoCommitTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoCommitTransaction(
    RPC_INT_XACT_HANDLE *phXact)
{
    InterlockedIncrement(&g_ActiveCommitThreads);
	auto_InterlockedDecrement AutoDec(&g_ActiveCommitThreads);
	if (g_QmGoingDown)
	{
		TrERROR(XACT_GENERAL, "Failing internal commit because QM is going down");
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

    CTransaction *pXact = (CTransaction *)*phXact;

    if (pXact == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 155);
    }

    if(pXact->m_eType != CBaseContextType::eTransactionCtx)
	{
		TrERROR(XACT_GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 191);
	}

    *phXact = NULL;

    HRESULT hr = pXact->InternalCommit();
	//
	// pXact is usually released by now.  However, if a severe error occurs
	// during the commit we might have to leak pXact so we never forget it
	// in a checkpoint
	//

	return LogHR(hr, s_FN, 160);
}


/*====================================================
QMDoAbortTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoAbortTransaction(
    RPC_INT_XACT_HANDLE *phXact)
{
    CTransaction *pXact = (CTransaction *)*phXact;

    if (pXact == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 165);
    }

    if(pXact->m_eType != CBaseContextType::eTransactionCtx)
	{
		TrERROR(XACT_GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 166);
	}

    *phXact = NULL;

    return pXact->InternalAbort();
}

/*====================================================
RPC_INT_XACT_HANDLE_rundown
    Called by RPC when client connection is broken
=====================================================*/
void __RPC_USER RPC_INT_XACT_HANDLE_rundown(RPC_INT_XACT_HANDLE hXact)
{
    CTransaction *pXact = (CTransaction *)hXact;

    if (pXact == NULL)
    {
        LogHR(MQ_ERROR, s_FN, 167);
        return;
    }

    if(pXact->m_eType != CBaseContextType::eTransactionCtx)
	{
		TrERROR(XACT_GENERAL, "Received invalid handle");
		LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 168);
		return;
	}
		
    pXact->InternalAbort();
}

/*====================================================
CResourceManager::ForgetTransaction
    Forget the transaction - exclude it from the mapping
=====================================================*/
void CResourceManager::ForgetTransaction(CTransaction    *pTrans)
{
    CS lock(m_critRM);

    m_Xacts.RemoveKey(*pTrans->GetUow());
	m_XactsRecovery.RemoveKey(pTrans->GetIndex());
}


/*====================================================
QMInitResourceManager
    Initializes RM
=====================================================*/
HRESULT QMInitResourceManager()
{
    ASSERT(g_pRM);
    return LogHR(g_pRM->Init(), s_FN, 170);
}

#ifdef _DEBUG
//
// Induces exit() on probability of g_ExitProbability / (100 * factor)
// Big factor value means lower chances of crash.
//
void PROBABILITY_CRASH_POINT(int factor, WCHAR* msg)
{
	if(g_ExitProbability == 0 || 
		g_ExitProbability <= (ULONG)(rand() % (100 * factor))) 
		return;
	
	TrERROR(GENERAL, "Probability crash point invoked. Exiting Process. %ls", msg);
	ASSERT(("Exit injected.", !g_FailureProbabilityStop)); 
	exit(EXIT_FAILURE); 
}
	
HRESULT InjectFailure()
{
	TrERROR(GENERAL, "Injected MQ_ERROR_INSUFFICIENT_RESOURCES error.");
	ASSERT(("Error injected", !g_FailureProbabilityStop));
	return MQ_ERROR_INSUFFICIENT_RESOURCES;
}


//
// Throws an exception with probability of g_ExitProbability / (100 * factor)
// Big factor value means lower chances of crash.
//
void PROBABILITY_THROW_EXCEPTION(int factor, WCHAR* msg)
{
	if(g_FailureProbability == 0 || 
		g_FailureProbability <= (ULONG)(rand() % (100 * factor)))
		return;
	
	TrERROR(GENERAL, "Injected bad_alloc() exception. %ls", msg);
	ASSERT(("Error injected", !g_FailureProbabilityStop));
	throw bad_alloc();
}
#endif

/*====================================================
QMPreInitResourceManager
    Pre-initialization of the RM
=====================================================*/
HRESULT QMPreInitResourceManager(ULONG ulVersion, TypePreInit tpCase)
{
    ASSERT(!g_pRM);

    #ifdef _DEBUG
    //
    // Get debugging parameters from registry
    //

    // Get initial crash point for QM transactions recovery debugging
    DWORD dwDef = FALCON_DEFAULT_CRASH_POINT;
    READ_REG_DWORD(g_ulCrashPoint,
                   FALCON_CRASH_POINT_REGNAME,
                   &dwDef ) ;
    if (g_ulCrashPoint)
    {
        TrERROR(XACT_GENERAL, "Crash point %d ordered!", g_ulCrashPoint);
    }

    // Get crash latency for QM transactions recovery debugging
    dwDef = FALCON_DEFAULT_CRASH_LATENCY;
    READ_REG_DWORD(g_ulCrashLatency,
                   FALCON_CRASH_LATENCY_REGNAME,
                   &dwDef ) ;

    // Get failure probability for exit and hr calls
    dwDef = 0;
	READ_REG_DWORD(g_ExitProbability,
                   FALCON_XACT_EXIT_PROBABILITY_REGNAME,
                   &dwDef ) ;

	READ_REG_DWORD(g_FailureProbability,
                   FALCON_XACT_FAILURE_PROBABILITY_REGNAME,
                   &dwDef ) ;

	//
	// Init random generator
	//
	srand((unsigned)time(NULL));

    #endif

    //
    // Create and initialize the single copy of resource manager
    //

    g_pRM = new CResourceManager();

    ASSERT(g_pRM);
    return LogHR(g_pRM->PreInit(ulVersion, tpCase), s_FN, 180);
}

/*====================================================
QMFinishResourceManager
    Finishes RM work
=====================================================*/
void QMFinishResourceManager()
{
    if (g_pRM)
    {
        delete g_pRM;
        g_pRM = NULL;
    }
    return;
}

/*====================================================
CResourceManager::IncXactCount
    Increments live transacions counter
=====================================================*/

#ifdef _DEBUG

void CResourceManager::IncXactCount()
{
	InterlockedIncrement(&m_cXacts);
}

#endif

/*====================================================
CResourceManager::DecXactCount
    Decrements live transacions counter
=====================================================*/

#ifdef _DEBUG

void CResourceManager::DecXactCount()
{
    InterlockedDecrement(&m_cXacts);
}

#endif

/*====================================================
CResourceManager::Index
    Returns incremented transacion discriminative index
=====================================================*/
ULONG CResourceManager::Index()
{
    m_ulXactIndex = (m_ulXactIndex == 0xFFFFFFFF ? 0 : m_ulXactIndex+1);
    return m_ulXactIndex;
}

/*====================================================
CResourceManager::StartIndexing
    Starts indexing from zero - must be called after recovery
=====================================================*/
void CResourceManager::StartIndexing()
{
    m_ulXactIndex = 0;
}

/*====================================================
CResourceManager::AssignSeqNumber
    Increments and returns the umber of prepared transactions
=====================================================*/
ULONG CResourceManager::AssignSeqNumber()
{
    return m_pXactSorter->AssignSeqNumber();
}

/*====================================================
CResourceManager::InsertPrepared
    Inserts the prepared xaction into the list of prepared
=====================================================*/
void CResourceManager::InsertPrepared(CTransaction *pTrans)
{
    m_pXactSorter->InsertPrepared(pTrans);
}

/*====================================================
CResourceManager::InsertCommitted
    Inserts the Commit1-ed xaction into the list
=====================================================*/
void CResourceManager::InsertCommitted(CTransaction *pTrans)
{
    m_pCommitSorter->InsertPrepared(pTrans);
}

/*====================================================
CResourceManager::RemoveAborted
    Removes the prepared xaction from the list of prepared
=====================================================*/
void CResourceManager::RemoveAborted(CTransaction *pTrans)
{
    CS lock(m_critRM);  // To prevent deadlock with Flusher thread
    m_pXactSorter->RemoveAborted(pTrans);
}

/*====================================================
CResourceManager::SortedCommit
    Marks the prepared transaction as committed and
    commits what is possible
=====================================================*/
void CResourceManager::SortedCommit(CTransaction *pTrans)
{
    CS lock(m_critRM);  // To prevent deadlock with Flusher thread
    m_pXactSorter->SortedCommit(pTrans);
}

/*====================================================
CResourceManager::SortedCommit3
    Marks the Commit1-ed transaction and
    commits what is possible
=====================================================*/
void CResourceManager::SortedCommit3(CTransaction *pTrans)
{
    CS lock(m_critRM);  // Needed to prevent deadlock with Flusher thread
    m_pCommitSorter->SortedCommit(pTrans);
}


/*====================================================
CResourceManager::Save
    Saves in appropriate file
=====================================================*/
HRESULT CResourceManager::Save()
{
    return m_PingPonger.Save();
}

/*====================================================
CResourceManager::PingNo
    Access to the current ping number
=====================================================*/
ULONG &CResourceManager::PingNo()
{
    return m_ulPingNo;
}


/*====================================================
CResourceManager::Save
    Saves transactions in given file
=====================================================*/
BOOL CResourceManager::Save(HANDLE  hFile)
{
    CS lock(m_critRM);

    PERSIST_DATA;
    SAVE_FIELD(m_RMGuid);

    //
    // Keep file format the same as in MSMQ 1.0. The SeqID field in SP4 is
    // obsolete, and is written just for competability.  erezh 31-Aug-98
    //
    LONGLONG Obsolete = 0;
    SAVE_FIELD(Obsolete);

    ULONG cLen = m_Xacts.GetCount();
    SAVE_FIELD(cLen);

    POSITION posInList = m_Xacts.GetStartPosition();
    while (posInList != NULL)
    {
        XACTUOW       uow;
        CTransaction *pTrans;

        m_Xacts.GetNextAssoc(posInList, uow, pTrans);

        if (!pTrans->Save(hFile))
        {
            return FALSE;
        }
    }

    SAVE_FIELD(m_ulPingNo);
    SAVE_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CResourceManager::Load
    Loads transactions from a given file
=====================================================*/
BOOL CResourceManager::Load(HANDLE hFile)
{
    PERSIST_DATA;

    LOAD_FIELD(m_RMGuid);

    //
    // Keep file format the same as in MSMQ 1.0. The SeqID field in SP4 is
    // obsolete, and is read just for competability.  erezh 31-Aug-98
    //
    LONGLONG Obsolete;
    LOAD_FIELD(Obsolete);

    ULONG cLen;
    LOAD_FIELD(cLen);

	CS lock(m_critRM);

    for (ULONG i=0; i<cLen; i++)
    {
        CTransaction *pTrans = new CTransaction(this);

        if (!pTrans->Load(hFile))
        {
            return FALSE;
        }
#ifdef _DEBUG
		CTransaction *p;
#endif
			ASSERT(!m_XactsRecovery.Lookup(pTrans->GetIndex(), p));
        m_XactsRecovery.SetAt(pTrans->GetIndex(), pTrans);
			ASSERT(!m_Xacts.Lookup(*pTrans->GetUow(), p));
        m_Xacts[*pTrans->GetUow()] = pTrans;
    }

    LOAD_FIELD(m_ulPingNo);
    LOAD_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CResourceManager::SaveInFile
    Saves the transaction persistent data in the file
=====================================================*/
HRESULT CResourceManager::SaveInFile(LPWSTR wszFileName, ULONG, BOOL)
{
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;

    hFile = CreateFile(
             wszFileName,                                       // pointer to name of the file
             GENERIC_WRITE,                                     // access mode: write
             0,                                                  // share  mode: exclusive
             NULL,                                              // no security
             OPEN_ALWAYS,                                      // open existing or create new
             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // file attributes and flags: we need to avoid lazy write
             NULL);                                             // handle to file with attributes to copy


    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Save(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    TrTRACE(XACT_GENERAL, "Saved Xacts: %ls (ping=%d)", wszFileName, m_ulPingNo);

    return hr;
}



/*====================================================
CResourceManager::LoadFromFile
    Loads Transactions from the file
=====================================================*/
HRESULT CResourceManager::LoadFromFile(LPWSTR wszFileName)
{
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;
    hFile = CreateFile(
             wszFileName,                       // pointer to name of the file
             GENERIC_READ,                      // access mode: write
             0,                                 // share  mode: exclusive
             NULL,                              // no security
             OPEN_EXISTING,                     // open existing
             FILE_ATTRIBUTE_NORMAL,             // file attributes: we may use Hidden once
             NULL);                             // handle to file with attributes to copy

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Load(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    #ifdef _DEBUG
    if (SUCCEEDED(hr))
    {
        TrTRACE(XACT_GENERAL,"Loaded Xacts: %ls (ping=%d)", wszFileName, m_ulPingNo);
    }
    #endif

    return hr;
}

/*====================================================
CResourceManager::Check
    Verifies the state
=====================================================*/
BOOL CResourceManager::Check()
{
    return (m_ulSignature == XACTS_SIGNATURE);
}


/*====================================================
CResourceManager::Format
    Formats the initial state
=====================================================*/
HRESULT CResourceManager::Format(ULONG ulPingNo)
{
     m_ulPingNo = ulPingNo;
     m_ulSignature = XACTS_SIGNATURE;

     return MQ_OK;
}


/*====================================================
CResourceManager::Destroy
    Destroys everything - on loading stage
=====================================================*/
void CResourceManager::Destroy()
{
	CS lock(m_critRM);

    POSITION posInList = m_XactsRecovery.GetStartPosition();
    while (posInList != NULL)
    {
        ULONG         ulIndex;
        CTransaction *pTrans;

        m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);

        pTrans->Release();
	}

	ASSERT(m_XactsRecovery.GetCount() == 0);
	ASSERT(m_Xacts.GetCount() == 0);
}

/*====================================================
CResourceManager::NewRecoveringTransaction
    Add transaction to recovery map.
=====================================================*/
CTransaction *CResourceManager::NewRecoveringTransaction(ULONG ulIndex)
{
	TrTRACE(XACT_LOG, "Recovery: Xact Creation, Index=%d", ulIndex);
	R<CTransaction> pTrans = new CTransaction(this, ulIndex);
#ifdef _DEBUG
	CTransaction *p;
#endif
	CS lock(m_critRM);
	ASSERT(!m_XactsRecovery.Lookup(ulIndex, p));
	m_XactsRecovery[ulIndex] = pTrans.get();

	return(pTrans.detach());
}

/*====================================================
CResourceManager::GetRecoveringTransaction
    Find the trasnaction in the recovery map. Add it
	if not found.
=====================================================*/
CTransaction *CResourceManager::GetRecoveringTransaction(ULONG ulIndex)
{
	CTransaction *pTrans;

	CS lock(m_critRM);

	if(!m_XactsRecovery.Lookup(ulIndex, pTrans))
	{
		pTrans = NewRecoveringTransaction(ulIndex);
 	}

	return(pTrans);
}


/*====================================================
CResourceManager::XactFlagsRecovery
    Data recovery function: called per each log record
=====================================================*/
void
CResourceManager::XactFlagsRecovery(
	USHORT usRecType,
	PVOID pData,
	ULONG cbData
	)
{
    switch (usRecType)
    {
    case LOGREC_TYPE_XACT_STATUS:
        ASSERT(cbData == sizeof(XactStatusRecord));
        DBG_USED(cbData);
        {
            XactStatusRecord *pRecord = (XactStatusRecord *)pData;

			if (pRecord->m_taAction == TA_STATUS_CHANGE)
            {
				CTransaction *pTrans;
				pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);
                pTrans->SetFlags(pRecord->m_ulFlags);
            }

            TrTRACE(XACT_GENERAL,"Xact restore: Index %d, Action %d, Flags %d",
                    pRecord->m_ulIndex, pRecord->m_taAction, pRecord->m_ulFlags);
        }
        break;

    case LOGREC_TYPE_XACT_PREPINFO:
        {
            PrepInfoRecord *pRecord = (PrepInfoRecord *)pData;
			CTransaction *pTrans;
			pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);
            pTrans->PrepInfoRecovery(pRecord->m_cbPrepInfo, &pRecord->m_bPrepInfo[0]);

        }
        break;

    case LOGREC_TYPE_XACT_DATA:
        {
			CS lock(m_critRM);

            XactDataRecord *pRecord = (XactDataRecord *)pData;
			CTransaction *pTrans;
			pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);

			CTransaction *p;
            if (m_Xacts.Lookup(*pTrans->GetUow(), p))
            {
                // This can occur when the checkpoint started between creation of xact and 1st logging
                ASSERT(pTrans == p);
                break;
            }

            pTrans->XactDataRecovery(
                    pRecord->m_ulSeqNum,
                    pRecord->m_fSinglePhase,
                    &pRecord->m_uow);

            // Make sure we add the transaction to the UOW map
			ASSERT(!m_Xacts.Lookup(*pTrans->GetUow(), p));
            m_Xacts[*pTrans->GetUow()] = pTrans;
		}
        break;

    default:
        ASSERT(0);
        break;
    }
}

/*====================================================
 provides access to the sorter's critical section
=====================================================*/
CCriticalSection &CResourceManager::SorterCritSection()
{
    return m_pXactSorter->SorterCritSection();
}

/*====================================================
 provides access to the RM's critical section
=====================================================*/
CCriticalSection &CResourceManager::CritSection()
{
    return m_critRM;
}


/*====================================================
  Find a transaction by UOW
=====================================================*/
CTransaction *CResourceManager::FindTransaction(const XACTUOW *pUow)
{
    ASSERT(pUow);
    CTransaction *pTrans;

	CS lock(m_critRM);
	
    if (m_Xacts.Lookup(*pUow, pTrans))
        return(pTrans);
    else
        return(0);
}


/*====================================================
  Release all complete transactions
=====================================================*/
void CResourceManager::ReleaseAllCompleteTransactions()
{
	CS lock(m_critRM);
	ASSERT(m_XactsRecovery.GetCount() >= m_Xacts.GetCount());

	POSITION posInList = m_XactsRecovery.GetStartPosition();

    while (posInList != NULL)
    {
		ULONG ulIndex;
        CTransaction *pTrans;

        // get next xact
        m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);


        // Release transaction if it is complete
		if(pTrans->IsComplete())
		{
			pTrans->Release();
		}
	}
}


/*====================================================
  Recover all transactions
=====================================================*/
HRESULT CResourceManager::RecoverAllTransactions()
{
	POSITION posInList;

	{
		CS lock(m_critRM);
		posInList = m_XactsRecovery.GetStartPosition();
	}

    while (posInList != NULL)
    {
        CTransaction *pTrans;
	    {
			// get next xact
			CS lock(m_critRM);
			ULONG ulIndex;
			m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);
		}


		//
        // Recover the transaction
		// N.B. You can not hold m_critRM while calling Recover, as Recover completes
		// asynchronously. Calling Recover for multiple transactions will exhust all
		// Worker Threads since Recover needs m_critRM in another thread (to try to
		// remove the transaction from m_Xacts & m_XactsRecovery map).
		//
		HRESULT hr;
        hr = pTrans->Recover();
        if (FAILED(hr))
			return(hr);

		pTrans->Release();
	}

	//
	// No one is using the maps anymore.  Make sure.
	//
	ASSERT(m_Xacts.GetCount() == 0);
	ASSERT(m_XactsRecovery.GetCount() == 0);

	return(S_OK);
}

/*====================================================
Hash function for LongLong
=====================================================*/
template<>
UINT AFXAPI HashKey( LONGLONG key)
{
	LARGE_INTEGER li;
	li.QuadPart = key;
    return(li.LowPart + (UINT)li.HighPart);
}

#ifdef _DEBUG
/*====================================================
Stop
    Debugging function called at each problem: to stop on it
=====================================================*/
void Stop()
{
      TrWARNING(XACT_GENERAL, "Stop");
}

/*====================================================
DbgCrash
    Routine is called in crash points for debugging purposes
=====================================================*/
void DbgCrash(int num)
{
    TrERROR(XACT_GENERAL, "Crashing at point %d",num); \
    if (g_ulCrashLatency)
    {
       Sleep(g_ulCrashLatency);
    }

    abort();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\xactstyl.h ===
#ifndef __XACTSTYLE_H__
#define __XACTSTYLE_H__

#include "mqreport.h"

extern void Stop();

#ifdef _DEBUG
#define STOP  Stop()
#else
#define STOP
#endif

#define CHECK_RETURN(point)     \
	    if (FAILED(hr))         \
	    {                       \
            LogMsgHR(hr, s_FN, point); \
            return hr;          \
        }

#define CHECK_RETURN_CODE(code, point) \
	    if (FAILED(hr))         \
	    {                       \
            LogMsgHR(hr, s_FN, point); \
            return code;        \
        }

extern ULONG g_ulCrashPoint;
extern ULONG g_ulCrashLatency;
extern ULONG g_ExitProbability;
extern ULONG g_FailureProbability;
extern ULONG g_FailureProbabilityStop;
extern void DbgCrash(int num);

#ifdef _DEBUG
#define CRASH_POINT(num)               \
    if (num==g_ulCrashPoint)           \
    {                                  \
		STOP;						   \
        DbgCrash(num);                 \
    }

//
// Induces exit() on probability of g_ExitProbability / (100 * factor)
// Big factor value means lower chances of crash.
//
void PROBABILITY_CRASH_POINT(int factor, WCHAR* msg);
	
//
// Throws an exception with probability of g_ExitProbability / (100 * factor)
// Big factor value means lower chances of crash.
//
void PROBABILITY_THROW_EXCEPTION(int factor, WCHAR* msg);

HRESULT InjectFailure();

//
//  Mechanism for controlled failure injection.
//  Injects MQ_ERROR on probablity of (g_FailureProbability / 100)
//
#define EVALUATE_OR_INJECT_FAILURE(expr)	\
	(\
		(g_FailureProbability == 0 || g_FailureProbability <= (ULONG)(rand() % 100)) ? \
		expr : InjectFailure()\
	)

//
//  Injects MQ_ERROR on probablity of (g_FailureProbability / (100 * factor))
//	Higher factor means less failures.
//
#define EVALUATE_OR_INJECT_FAILURE2(expr, factor)	\
	(\
		(g_FailureProbability == 0 || g_FailureProbability <= (ULONG)(rand() % (100 * factor))) ? \
		expr : InjectFailure()\
	)
#else
#define CRASH_POINT(num)
#define PROBABILITY_CRASH_POINT(factor, msg)
#define PROBABILITY_THROW_EXCEPTION(factor, msg)
#define EVALUATE_OR_INJECT_FAILURE(expr) (expr)
#define EVALUATE_OR_INJECT_FAILURE2(expr, factor) (expr)
#endif

#define FILE_NAME_MAX_SIZE	   256

void ReportWriteFailure(DWORD gle);

//--------------------------------------
//
// Macro for persistency implementation
//
//--------------------------------------

#define PERSIST_DATA  BOOL ret = FALSE;     DWORD dw


#define SAVE_FIELD(data)                                                            \
    if (!WriteFile(hFile, &data, sizeof(data), &dw, NULL) ||  sizeof(data) != dw)   \
	{		                                                                        \
        ReportWriteFailure(GetLastError());                                         \
        return ret;                                                                 \
    }

#define SAVE_DATA(data, len)                                                        \
    if (!WriteFile(hFile, data, len, &dw, NULL) ||  len != dw)                      \
	{   																            \
        ReportWriteFailure(GetLastError());                                         \
        return ret;                                                                 \
    }


#define LOAD_FIELD(data)                                                            \
if (!ReadFile(hFile, &data, sizeof(data), &dw, NULL) ||  sizeof(data)!= dw)         \
    {                                                                               \
        return ret;                                                                 \
    }

#define LOAD_DATA(data,len)                                                         \
if (!ReadFile(hFile, &data, len, &dw, NULL) ||  len != dw)                          \
    {                                                                               \
        return ret;                                                                 \
    }

#define LOAD_ALLOCATE_DATA(dataptr,len, type)                                       \
dataptr = (type) new UCHAR[len];                                                    \
if (!ReadFile(hFile, dataptr.get(), len, &dw, NULL) ||  len != dw)                  \
    {                                                                               \
        return ret;                                                                 \
    }

#endif __XACTSTYLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\asyncrxthread.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	AsyncRxThread.cpp

Abstract:

	The async receive thread is used by MQRT to implement the callback mechanism that MQReceiveMessage() supports.
	
	The thread is created only on demand. i.e.: after first invocation of MQReceiveMessage() with a callback function.
	The thread is shut down some time after it remains with no events to monitor. The MQRT library will stay up as long 
	as this thread is alive.

	CreateAsyncRxRequest() returns a context object. This object is an automatic object. If it is destructed without
	calling its Submit() method first, it will cancel the callback request.

Author:

    Nir Aides (t-naides) 19-Aug-2001

Revision History:

--*/



#include "stdh.h"
#include <mqexception.h>
#include <autohandle.h>

#include "AsyncRxThread.tmh"



//
// Data that is needed for each callback entry. Most of it will be passed to the callback function.
//
class CCallbackDescriptor
{
public:
	bool				m_fCanceled;
    QUEUEHANDLE			m_hQueue;
    DWORD				m_timeout;
    DWORD				m_action;
    MQMSGPROPS*			m_pmp;
    LPOVERLAPPED		m_lpOverlapped;
    HANDLE				m_hCursor;
    PMQRECEIVECALLBACK	m_fnReceiveCallback;
    OVERLAPPED			m_overlapped;
};



class CAsyncRxThread
{
public:
	CAsyncRxThread();

	void CreateCallbackRequest(
			CCallbackDescriptor** ppDescriptor, 
			HANDLE hQueue,
			DWORD timeout, 
			DWORD action,
			MQMSGPROPS* pmp,
			LPOVERLAPPED lpOverlapped,
			PMQRECEIVECALLBACK fnReceiveCallback,
			HANDLE hCursor
			);

	void CancelCallbackRequest(CCallbackDescriptor* pDescriptor);

private:
	void Initialize();
	void CleanUp();
	void InvokeCallback(DWORD ObjectIndex);
	void RemoveEntry(DWORD ObjectIndex);
	void RemoveCanceledEntries();

	static DWORD WINAPI AsyncRxThreadProc(LPVOID lpParameter);
	void AsyncRxThread();

private:
	CCriticalSection m_AsyncThreadCS; 

	bool m_fInitialized;
	HANDLE m_hThread;

	HMODULE m_hLibraryReference;

	//
	// This event is used to signal the async thread on new requests.
	//
	HANDLE m_hNewRequestEvent;

	DWORD  m_nEntries;
	CCallbackDescriptor* m_DescriptorsArray[MAXIMUM_WAIT_OBJECTS];
	HANDLE m_EventsArray[MAXIMUM_WAIT_OBJECTS];

	bool m_fRemoveCanceledRequest;
};



CAsyncRxThread g_AsyncRxThread;



CAsyncRxThread::CAsyncRxThread() : 
	m_AsyncThreadCS(),
	m_fInitialized(false),
	m_hThread(NULL),
	m_hNewRequestEvent(NULL),
	m_hLibraryReference(NULL),
	m_fRemoveCanceledRequest(false)
{
}



void CAsyncRxThread::InvokeCallback(DWORD ObjectIndex)
{
	CCallbackDescriptor* descriptor = m_DescriptorsArray[ObjectIndex];

	ASSERT(descriptor != NULL);
	ASSERT(m_EventsArray[ObjectIndex] == descriptor->m_overlapped.hEvent);

	HRESULT hr = RTpConvertToMQCode(DWORD_PTR_TO_DWORD(descriptor->m_overlapped.Internal));

	//
	// Call the application's callback function.
	//
	descriptor->m_fnReceiveCallback(
		hr,
		descriptor->m_hQueue,
		descriptor->m_timeout,
		descriptor->m_action,
		descriptor->m_pmp,
		descriptor->m_lpOverlapped,
		descriptor->m_hCursor
		);
}



void CAsyncRxThread::RemoveEntry(DWORD ObjectIndex)
{
	CS Lock(m_AsyncThreadCS);

	CloseHandle(m_EventsArray[ObjectIndex]);
	delete m_DescriptorsArray[ObjectIndex];

	m_nEntries--;

	for (DWORD index = ObjectIndex; index < m_nEntries; index++)
	{
		m_EventsArray[index] = m_EventsArray[index + 1];
		m_DescriptorsArray[index] = m_DescriptorsArray[index + 1];
	}
}



void CAsyncRxThread::RemoveCanceledEntries()
{
	try
	{
		CS Lock(m_AsyncThreadCS);

		ASSERT(m_fRemoveCanceledRequest);

		for (DWORD index = 1; index < m_nEntries;)
		{
			CCallbackDescriptor* descriptor = m_DescriptorsArray[index];

			if(descriptor->m_fCanceled)
			{
				RemoveEntry(index);
				//
				// Don't increase index++ since the list was shifted left.
				//
				continue;
			}

			index++;
		}

		m_fRemoveCanceledRequest = false;
	}
	catch(const std::bad_alloc&)
	{
		//
		// Thrown by m_AsyncThreadCS. Nothing to do. Will try to remove again later.
		//
	}
}



DWORD WINAPI CAsyncRxThread::AsyncRxThreadProc(LPVOID lpParameter)
{
	ASSERT(lpParameter != NULL);

	CAsyncRxThread* p = (CAsyncRxThread*)lpParameter;

	p->AsyncRxThread();

	return 0;
}



void CAsyncRxThread::AsyncRxThread()
{
	for(;;)
	{
		try
		{
			if(m_fRemoveCanceledRequest)
			{
				RemoveCanceledEntries();
			}

			//
			// We generally don't want a timeout for performance reasons since it may impact the working set of
			// the process using this API. On the other hand we can't have INFINITE timeout since there is a failure
			// scenario that might leave the thread (and the entire MQRT dll) going forever without shutting down. 
			// This can happen if we fail to cancel an entry. The solution is to take a near infinite timeout. 
			// Here we chose 10 hours
			//
			DWORD timeout = 10 * 60 * 60 * 1000;

			DWORD nEntries = m_nEntries;
			if(nEntries == 1)
			{
				//
				// 40 seconds timeout. If the thread is left without registered callbacks it will shut down after this timeout.
				//
				timeout = 40 * 1000;
			}

			DWORD ObjectIndex = WaitForMultipleObjects(
									nEntries,
									m_EventsArray,
									FALSE, // return on any object
									timeout 
									);

			if (ObjectIndex == WAIT_TIMEOUT)
			{
				HMODULE hLib;

				{
					CS Lock(m_AsyncThreadCS);
					
					if (m_nEntries > 1)
						continue;

					//
					// A list size of 1 means that there are no requests at all since the first event in the list
					// is the 'new event in the list' event.
					// So if the list size is one after the timeout period, we shut the thread down.
					//

					hLib = m_hLibraryReference;
					CleanUp();
				}

				//
				// Must occur outside the Lock's scope to allow it to unwind!
				//					
				FreeLibraryAndExitThread(hLib, 0);
			}

			ObjectIndex -= WAIT_OBJECT_0;

			ASSERT(ObjectIndex < nEntries);

			if (ObjectIndex == 0)
			{
				//
				// The first event in the m_EventsArray[] array is a special event used to signal 
				// that a new event has been added to the end of the list, or that an entry needs to be canceled.
				// In both cases we need to 'continue'. 
				//
				continue;
			}

			//
			// Assert the assumption that an entry could not have been signaled if it was canceled. 
			// i.e. if the driver rejected the receive operation it will not signal the event.
			//
			ASSERT(!m_DescriptorsArray[ObjectIndex]->m_fCanceled);

			//
			// One of the events fired. An async receive operation has completed. Time to invoke the 
			// callback function.
			//
			InvokeCallback(ObjectIndex);

			RemoveEntry(ObjectIndex); 
		}
		catch(const std::bad_alloc&)
		{
			//
			// Thrown by m_AsyncThreadCS. Nothing to do. Will try again later.
			//
			continue;
		}

	}
}



static HMODULE GetLibraryReference()
{
	WCHAR szModuleName[_MAX_PATH];
	szModuleName[_MAX_PATH - 1] = L'\0';
	
    DWORD res = GetModuleFileName(g_hInstance, szModuleName, STRLEN(szModuleName));
	if(res == 0)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to get module file name, error %d", gle);
		throw bad_win32_error(gle);
	}

    HMODULE handle = LoadLibrary(szModuleName);
	if(handle == NULL)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to load library, error %d", gle);
		throw bad_win32_error(gle);
	}

	return handle;
}



void CAsyncRxThread::Initialize()
{
	if(m_hThread != NULL)
	{
		//
		// There is a scenario when the MQRT dll is shut down but before the async thread terminates, 
		// the MQRT is loaded again and we may end up trying to 
		// create a new async thread before the old one exits, so we wait here.
		//
		DWORD res = WaitForSingleObject(m_hThread, INFINITE);
		if(res != WAIT_OBJECT_0)
		{
			DWORD gle = GetLastError();
			TrERROR(RPC, "Failed wait for cancel thread to exit, error %d", gle);
			throw bad_win32_error(gle);
		}

		HANDLE hThread = m_hThread;
		m_hThread = NULL;
		CloseHandle(hThread);
	}

	CHandle hNewRequestEvent = CreateEvent( 
									NULL,
									FALSE,  // automatic reset
									FALSE, // initially not signalled
									NULL 
									);

	if (hNewRequestEvent == NULL)
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to create async event, error %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	//
	// We set the initial size to one since the first event in the list is the special 'm_hNewRequestEvent'. 
	// This special event is not a pending request. The value of '1' is just technical.
	//
	m_nEntries = 1;
	m_EventsArray[0] = hNewRequestEvent;

    ASSERT(m_hThread == NULL);
	ASSERT(m_hLibraryReference == NULL);

	//
	// Creation of thread should be last so structures are already initialized.
	//
	m_hLibraryReference = GetLibraryReference();

	DWORD id;

	m_hThread = CreateThread( 
							NULL,
							0,       // stack size
							CAsyncRxThread::AsyncRxThreadProc,
							this,
							0,       // creation flag
							&id 
							);

	if (m_hThread == NULL)
	{
		DWORD gle = GetLastError();
		FreeLibrary(m_hLibraryReference);
		TrERROR(GENERAL, "Failed to create async thread, error %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	ASSERT(m_hNewRequestEvent == NULL);

	m_hNewRequestEvent = hNewRequestEvent.detach();
}



void CAsyncRxThread::CleanUp()
{
	ASSERT(m_nEntries == 1);

	CloseHandle(m_hNewRequestEvent);
	m_hNewRequestEvent = NULL;
	m_hLibraryReference = NULL;

	m_fInitialized = false;
	m_fRemoveCanceledRequest = false;
}



void 
CreateAsyncRxRequest(
				OUT CAutoCallbackDescriptor& descriptor, 
				IN HANDLE hQueue,
				IN DWORD timeout, 
				IN DWORD action,
				IN MQMSGPROPS* pmp,
				IN LPOVERLAPPED lpOverlapped,
				IN PMQRECEIVECALLBACK fnReceiveCallback,
				IN HANDLE hCursor
				)
/*++

Routine Description:

    create callback request entry.

Arguments:

	descriptor - [OUT] this argument should be used for cancelation.

Return Value:

--*/
{
	g_AsyncRxThread.CreateCallbackRequest(
		descriptor.ref(), 
		hQueue,
		timeout, 
		action,
		pmp,
		lpOverlapped,
		fnReceiveCallback,
		hCursor
		);
}



void 
CAsyncRxThread::CreateCallbackRequest(
				CCallbackDescriptor** ppDescriptor, 
				HANDLE hQueue,
				DWORD timeout, 
				DWORD action,
				MQMSGPROPS* pmp,
				LPOVERLAPPED lpOverlapped,
				PMQRECEIVECALLBACK fnReceiveCallback,
				HANDLE hCursor
				)
{
	CS Lock(m_AsyncThreadCS);

	if (!m_fInitialized)
	{
		Initialize();
		m_fInitialized = true;
	}

	if (m_nEntries >= MAXIMUM_WAIT_OBJECTS)
	{
		TrERROR(GENERAL, "Failed to add async event since Too many events are pending.");
		throw bad_alloc();
	}

	//
	// The event that will be passed inside the overlapped structure to the driver.
	//
	CHandle AsyncEvent = CreateEvent( 
							NULL,
							TRUE,  // manual reset
							FALSE, // not signalled
							NULL 
							);
	
	if (AsyncEvent == NULL) 
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to create callback event with error %!winerr!.", gle);
		throw bad_win32_error(gle);
	}

	P<CCallbackDescriptor> descriptor = new CCallbackDescriptor;

	descriptor->m_fCanceled = false;
	descriptor->m_hQueue = hQueue;
	descriptor->m_timeout = timeout;
	descriptor->m_action = action;
	descriptor->m_pmp = pmp;
	descriptor->m_lpOverlapped = lpOverlapped;
	descriptor->m_fnReceiveCallback = fnReceiveCallback;
	descriptor->m_hCursor = hCursor;
	descriptor->m_overlapped.hEvent = AsyncEvent;

	m_EventsArray[m_nEntries] = AsyncEvent;
	m_DescriptorsArray[m_nEntries] = descriptor;
	m_nEntries++;

	//
	// Signal the async thread that there is a new request.
	//
	BOOL fRes = SetEvent(m_hNewRequestEvent); 
	if(!fRes)
	{
		m_nEntries--;
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to signal new callback event, with error %!winerr!.", gle);
		throw bad_win32_error(gle);
	}

	AsyncEvent.detach();
	*ppDescriptor = descriptor.detach();
}



void CAsyncRxThread::CancelCallbackRequest(CCallbackDescriptor* pDescriptor)
{
	CS Lock(m_AsyncThreadCS);

	ASSERT(m_fInitialized);

#ifdef _DEBUG
	for (DWORD index = 1; index < m_nEntries; index++)
	{
		if(m_DescriptorsArray[index] == pDescriptor)
			break;
	}

	ASSERT(("Tried to cancel a non-existing callback entry.",index != m_nEntries));
#endif

	pDescriptor->m_fCanceled = true;
	m_fRemoveCanceledRequest = true;
	SetEvent(m_hNewRequestEvent);
}



void CAutoCallbackDescriptor::CancelAsyncRxRequest()
{
	ASSERT(m_descriptor != NULL);

	try
	{
		g_AsyncRxThread.CancelCallbackRequest(this->detach());
	}
	catch(const bad_alloc&)
	{
		//
		// Thrown by m_AsyncThreadCS. Nothing to do. Will try again later.
		//
	}
}



OVERLAPPED* CAutoCallbackDescriptor::GetOverlapped()
{
	ASSERT(m_descriptor != NULL);

	return &m_descriptor->m_overlapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\authlevel.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    authlevel.h

Abstract:
    defines for PROPID_M_AUTH_LEVEL

Author:
    Ilan Herbst (ilanh) 05-Nov-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _AUTHLEVEL_H_
#define _AUTHLEVEL_H_

#define IS_AUTH_LEVEL_ALWAYS_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_ALWAYS) != 0)
#define IS_AUTH_LEVEL_SIG10_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG10) != 0)
#define IS_AUTH_LEVEL_SIG20_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG20) != 0)
#define IS_AUTH_LEVEL_SIG30_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG30) != 0)
#define IS_AUTH_LEVEL_XMLDSIG_BIT(level)	(((level) & MQMSG_AUTH_LEVEL_XMLDSIG_V1) != 0)

#define SET_AUTH_LEVEL_SIG10_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG10
#define SET_AUTH_LEVEL_SIG20_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG20
#define SET_AUTH_LEVEL_SIG30_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG30

#define CLEAR_AUTH_LEVEL_SIG10_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG10)
#define CLEAR_AUTH_LEVEL_SIG20_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG20)
#define CLEAR_AUTH_LEVEL_SIG30_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG30)

#define GET_AUTH_LEVEL_MSMQ_PROTOCOL(level)		((level) & AUTH_LEVEL_MASK)

#endif // _AUTHLEVEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\dllmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     conradc   12 April 2001
//              Originated from %sdxroot%\MergedComponents\dload\dllmap.c
//
//----------------------------------------------------------------------------

#include "stdh.h"
#include "dld.h"



//
// All of the dll's that dld.lib supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)

DECLARE_PROCNAME_MAP(mqrtdep)




const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // must be in alphabetical increasing order 
    DLDENTRYP(mqrtdep)
};


const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\mc.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Machine configuration

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <stdh.h>
#include <mqmacro.h>
#include <rtp.h>

#include "mc.tmh"

LPCWSTR
McComputerName(
	VOID
	)
/*++

Routine Description:
    Returns the computer name

Arguments:
    None.

Returned Value:
    A pointer to the computer name string buffer.

--*/
{
	return g_lpwcsComputerName;
}



DWORD
McComputerNameLen(
	VOID
	)
{
	return g_dwComputerNameLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    QUEUE_FORMAT <--> Format Name String conversion routines

Author:

    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#include "stdh.h"
#include <mqformat.h>

#include "fnparse.tmh"

static WCHAR *s_FN=L"rt/fnparse";

//=========================================================
//
//  QUEUE_FORMAT -> Format Name String conversion routine
//
//=========================================================

//---------------------------------------------------------
//
//  Function:
//      RTpQueueFormatToFormatName
//
//  Description:
//      Convert QUEUE_FORMAT to a format name string.
//
//---------------------------------------------------------
HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    )
{
    HRESULT hr = MQpQueueFormatToFormatName(
            pQueueFormat,
            lpwcsFormatName,
            dwBufferLength,
            lpdwFormatNameLength,
            false
            );
    if(FAILED(hr))
    {
    	TrERROR(GENERAL, "Failed to convert queue format to format name. %!hresult!", hr);
    }
    return hr;
}


//+-------------------------------------------
//
//  BOOL  RTpIsLocalPublicQueue()
//
//+-------------------------------------------

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName)
{
    WCHAR  wDelimiter = lpwcsExpandedPathName[ g_dwComputerNameLen ] ;

    if ((wDelimiter == PN_DELIMITER_C) ||
        (wDelimiter == PN_LOCAL_MACHINE_C))
    {
        //
        // Delimiter OK (either end of NETBios machine name, or dot of
        // DNS name. Continue checking.
        //
    }
    else
    {
        return FALSE ;
    }

    DWORD dwSize = g_dwComputerNameLen + 1 ;
    P<WCHAR> pQueueCompName = new WCHAR[ dwSize ] ;
    lstrcpynW( pQueueCompName.get(), lpwcsExpandedPathName, dwSize ) ;

    BOOL bRet = (lstrcmpi( g_lpwcsComputerName, pQueueCompName.get() ) == 0) ;
    return bRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\qmrt_c_.c ===
#pragma warning(push, 3)
#include <qmrt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\cursor.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cursor.cpp

Abstract:

    This module contains code involved with Cursor APIs.

Author:

    Erez Haba (erezh) 21-Jan-96
    Doron Juster  16-apr-1996, added MQFreeMemory.
    Doron Juster  30-apr-1996, added support for remote reading.

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include "rtprpc.h"
#include "acdef.h"
#include <rtdep.h>
#include <Fn.h>

#include "cursor.tmh"

static WCHAR *s_FN=L"rt/cursor";

inline
HRESULT
MQpExceptionTranslator(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}


EXTERN_C
HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    )
{
	if(g_fDependentClient)
		return DepCreateCursor(
					hQueue, 
					phCursor
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    HACCursor32 hCursor = 0;
    CCursorInfo* pCursorInfo = 0;

    rc = MQ_OK;

    __try
    {
        __try
        {
            __try
            {
                pCursorInfo = new CCursorInfo;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 40);
            }

		    OVERLAPPED ov = {0};
		    hr = GetThreadEvent(ov.hEvent);
			if(FAILED(hr))
				return LogHR(hr, s_FN, 45);

            //
            //  Call AC driver
            //
            rc = ACCreateCursor(hQueue, &hCursor, &ov);

			ASSERT(rc != MQ_INFORMATION_REMOTE_OPERATION);

		    if(rc == MQ_INFORMATION_OPERATION_PENDING)
		    {
		        //
		        //  Wait for Remote Create Cursor completion
		        //
		        DWORD dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
		        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
		        rc = DWORD_PTR_TO_DWORD(ov.Internal);
				if (dwResult != WAIT_OBJECT_0)
		        {
					DWORD gle = GetLastError();
					TrERROR(GENERAL, "Failed WaitForSingleObject, gle = %!winerr!", gle);
					rc = MQ_ERROR_INSUFFICIENT_RESOURCES;
		        }

				TrTRACE(GENERAL, "Opening Remote cursor, hQueue = 0x%p, hCursor = 0x%x", hQueue, (DWORD)hCursor);
		    }

            if(SUCCEEDED(rc))
            {
	            pCursorInfo->hQueue = hQueue;
                pCursorInfo->hCursor = hCursor;
                *phCursor = pCursorInfo;
                pCursorInfo = 0;
            }
        }
        __finally
        {
            delete pCursorInfo;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  MQpExceptionTranslator(GetExceptionCode());
    }

    return LogHR(rc, s_FN, 50);
}

EXTERN_C
HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    )
{
	if(g_fDependentClient)
		return DepCloseCursor(hCursor);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    __try
    {
        rc = ACCloseCursor(
                CI2QH(hCursor),
                CI2CH(hCursor)
                );

        if(SUCCEEDED(rc))
        {
            //
            //  delete the cursor info only when everything is OK. we do not
            //  want to currupt user heap.
            //
            delete hCursor;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The cursor structure is invalid
        //
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 60);
    }

    return LogHR(rc, s_FN, 70);
}


EXTERN_C
void
APIENTRY
MQFreeMemory(
    IN  PVOID pvMemory
    )
{
	if(g_fDependentClient)
		return DepFreeMemory(pvMemory);

	delete[] pvMemory;
}


EXTERN_C
PVOID
APIENTRY
MQAllocateMemory(
    IN  DWORD size
    )
{
	PVOID ptr = reinterpret_cast<PVOID>(new BYTE[size]);
	return ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\machdomain.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.cpp

Abstract:

	Handle machine domain

Author:		 

    Ilan  Herbst  (ilanh)  4-Sep-2001

--*/

#include "stdh.h"
#include "rtputl.h"
#include "autoreln.h"
#include <Dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include "ad.h"

#include "machdomain.tmh"


static LPWSTR FindMachineDomain()
/*++
Routine Description:
	Find local machine domain

Arguments:
	None

Returned Value:
	machine domain, NULL if not found

--*/
{
	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					NULL, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		//
		// This will be the case in NT4 domain
		//
		TrERROR(GENERAL, "Failed to find local machine domain, DsGetDcName failed, gle = %!winerr!", dw);
		return NULL;
	}

	ASSERT(pDcInfo->DomainName != NULL);
	TrTRACE(GENERAL, "Local machine doamain = %ls", pDcInfo->DomainName);
	AP<WCHAR> pMachineDomain = new WCHAR[wcslen(pDcInfo->DomainName) + 1];
    wcscpy(pMachineDomain, pDcInfo->DomainName);
	return pMachineDomain.detach();
}


static AP<WCHAR> s_pMachineDomain; 

LPCWSTR MachineDomain()
/*++
Routine Description:
	find local machine domain.

Arguments:
	None

Returned Value:
	return machine domain

--*/
{
	if(ADGetEnterprise() == eMqis)
	{
		//
		// mqdscli doesn't need the domain name only mqad
		//
		return NULL;
	}
	
	static bool s_fInitialize = false;

	if(s_fInitialize)
	{
		TrTRACE(GENERAL, "local machine domain = %ls", s_pMachineDomain.get());
		return s_pMachineDomain;
	}

	//
	// Get local computer domain
	//
	AP<WCHAR> pMachineDomain = FindMachineDomain();

	if(NULL != InterlockedCompareExchangePointer(
					&s_pMachineDomain.ref_unsafe(), 
					pMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fInitialize);
		ASSERT(s_pMachineDomain != NULL);
		return s_pMachineDomain;
	}

	//
	// The exchange was done
	//
	s_fInitialize = true;
	ASSERT(s_pMachineDomain == pMachineDomain);
	pMachineDomain.detach();

	TrTRACE(GENERAL, "local machine domain = %ls", s_pMachineDomain.get());
	return s_pMachineDomain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\machine.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module contains code involved with Machine APIs.

Author:

    Ronit Hartmann (ronith)

Revision History:

--*/

#include "stdh.h"
#include <ad.h>
#include <mqsec.h>
#include "_registr.h"
#include <_guid.h>
#include "version.h"
#include <mqversion.h>
#include <mqnames.h>
#include <rtdep.h>
#include "rtputl.h"
#include "mqexception.h"

#include "machine.tmh"

static WCHAR *s_FN=L"rt/machine";

BOOL
IsConnectionRequested(IN MQQMPROPS * pQMProps,
                      IN DWORD* pdwIndex)
{
    for(DWORD i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_CONNECTION)
        {
            ASSERT(pQMProps-> aPropVar[i].vt == VT_NULL);

            pQMProps->aPropID[i] = PROPID_QM_SITE_IDS;
            *pdwIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

//+------------------------------------------
//
//  HRESULT  GetEncryptionPublicKey()
//
//+------------------------------------------

HRESULT
GetEncryptionPublicKey(
    IN LPCWSTR          lpwcsMachineName,
    IN const GUID *     pguidMachineId,
    IN OUT HRESULT*     aStatus,
    IN OUT MQQMPROPS   *pQMProps
    )
{
    DWORD i;
    BOOL fFirst = TRUE;
    HRESULT hr = MQ_OK;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if ((pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK) ||
            (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_BASE))
        {
            //
            // Use msmq1.0 code, because our server can be either msmq1.0
            // or msmq2.0.
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 10);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                PROPID prop =  PROPID_QM_ENCRYPT_PK;

                if (lpwcsMachineName)
                {
                    hr = ADGetObjectProperties(
								eMACHINE,
								MachineDomain(),     // pwcsDomainController
								false,	   // fServerName
								lpwcsMachineName,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                else
                {
                    hr = ADGetObjectPropertiesGuid(
								eMACHINE,
								MachineDomain(),      // pwcsDomainController
								false,	   // fServerName
								pguidMachineId,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                if (FAILED(hr))
                {
                    break;
                }

				//
				// PROPID_QM_ENCRYPTION_PK, PROPID_QM_ENCRYPTION_PK_BASE
				// are VT_UI1|VT_VECTOR
				// while PROPID_QM_ENCRYPT_PK is VT_BLOB
				//
                ASSERT(pQMProps-> aPropVar[i].vt == VT_BLOB);
                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                
                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20) ;
    }

    //
    // now see if caller asked for enhanced key (128 bits).
    //
    fFirst = TRUE;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_ENHANCED)
        {
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 30);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                P<BYTE> pPbKey ;
                DWORD dwReqLen;

                hr = MQSec_GetPubKeysFromDS( pguidMachineId,
                                             lpwcsMachineName,
                                             eEnhancedProvider,
                                             PROPID_QM_ENCRYPT_PKS,
                                            &pPbKey,
                                            &dwReqLen ) ;
                if (FAILED(hr))
                {
                    break;
                }

                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                pQMProps-> aPropVar[i].caub.cElems = dwReqLen;
                pQMProps-> aPropVar[i].caub.pElems = new UCHAR[dwReqLen];
                memcpy(pQMProps->aPropVar[i].caub.pElems, pPbKey.get(), dwReqLen);

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    return LogHR(hr, s_FN, 40);
}

HRESULT GetCNNameList(IN OUT MQPROPVARIANT* pVar)
{
	HRESULT hr; 

    ASSERT(pVar->vt == (VT_CLSID|VT_VECTOR));

    //
    // pVar contains the list of sites where the machine reside
    //

    AP<LPWSTR> pElems = new LPWSTR[(pVar->cauuid).cElems];
	memset(pElems.get(), 0, sizeof(LPWSTR) * (pVar->cauuid).cElems);

	try
	{
		for(DWORD i = 0; i < (pVar->cauuid).cElems; i++)
		{
			HRESULT hr;
			PROPID      aProp[2];
			PROPVARIANT aVar[2];
			ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

			aProp[0] = PROPID_S_FOREIGN;
			aProp[1] = PROPID_S_PATHNAME;
			aVar[0].vt = VT_UI1;
			aVar[1].vt = VT_NULL;

			hr = ADGetObjectPropertiesGuid(
							eSITE,
							MachineDomain(),      // pwcsDomainCOntroller
							false,	    // fServerName
							&((pVar->cauuid).pElems[i]),
							cProps,
							aProp,
							aVar);   

			if (FAILED(hr))
			{
				throw bad_hresult(hr);
			}

			GUID_STRING wszGuid;
			MQpGuidToString(&((pVar->cauuid).pElems[i]), wszGuid);

			DWORD dwTypeSize;
			LPWSTR lpwsTypeNmae;

			switch (aVar[0].bVal)
			{
				case 0:
					//
					//  non foreign site
					//
					dwTypeSize = wcslen(L"IP_CONNECTION");
					lpwsTypeNmae = L"IP_CONNECTION";
					break;
				case 1:
					//
					// foreign site
					//
					dwTypeSize = wcslen(L"FOREIGN_CONNECTION");
					lpwsTypeNmae = L"FOREIGN_CONNECTION";
					break;
				default:
					dwTypeSize = wcslen(L"UNKNOWN_CONNECTION");
					lpwsTypeNmae = L"UNKNOWN_CONNECTION";
					break;
			}

			DWORD CNNameSize = dwTypeSize + 1 +                 // protocol id
							   wcslen(wszGuid) + 1+             // site Guid
							   wcslen(aVar[1].pwszVal) + 1;     // site Name

			pElems[i] = new WCHAR[CNNameSize];
			wsprintf(pElems[i],L"%s %s %s",lpwsTypeNmae, wszGuid, aVar[1].pwszVal);

			delete  [] aVar[1].pwszVal;
		}

		delete [] (pVar->cauuid).pElems;
		(pVar->calpwstr).cElems = (pVar->cauuid).cElems;
		(pVar->calpwstr).pElems = pElems.detach();

		pVar->vt = VT_LPWSTR|VT_VECTOR;

		return MQ_OK;
	}
	catch(const bad_alloc&)
	{
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const bad_hresult& e)
	{
		hr = e.error();
	}

	for(DWORD i = 0; i < (pVar->cauuid).cElems; i++)
	{
		delete[] pElems[i] ;
	}

	return LogHR(hr, s_FN, 50);
}

EXTERN_C
HRESULT
APIENTRY
MQGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID *    pguidMachineId,
    IN OUT MQQMPROPS * pQMProps)
{
	if(g_fDependentClient)
		return DepGetMachineProperties(
					lpwcsMachineName, 
					pguidMachineId,
					pQMProps
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc(MQDS_MACHINE), rc1(MQDS_MACHINE);
    LPWSTR lpwsPathName =  (LPWSTR)lpwcsMachineName;
    MQQMPROPS *pGoodQMProps;
    char *pTmpQPBuff = NULL;
    BOOL fGetConnection = FALSE;
    DWORD dwConnectionIndex = 0;
    HRESULT* aLocalStatus_buff = NULL;


    __try
    {
        __try
        {
            if (( lpwcsMachineName != NULL) &&
                ( pguidMachineId != NULL))
            {
                //
                //  the user cannot specify both machine name
                //  and guid
                //
                TrERROR(GENERAL, "The method was called with invalid parameters. Both a machine name and guid were specified.");
                return MQ_ERROR_INVALID_PARAMETER;
            }

            if ( pguidMachineId == NULL)
            {
                //
                //  if machine name is NULL, the calls refers to the
                //  local machine
                //
                if ( lpwcsMachineName == NULL)
                {
                    lpwsPathName = g_lpwcsComputerName;
                }
            }

            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (!pQMProps->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pQMProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pQMProps->aStatus;
            }

            //
            // See if the application wants to retrieve the key exchange
            // public key of the QM.
            //
            DWORD iPbKey;

            for (iPbKey = 0;
                 (iPbKey < pQMProps->cProp) &&
                    (pQMProps->aPropID[iPbKey] != PROPID_QM_ENCRYPTION_PK);
                 iPbKey++)
			{
				NULL;
			}

            //
            //  Check QM properties structure
            //
            rc1 = RTpCheckQMProps( pQMProps,
                                   aLocalStatus,
                                   &pGoodQMProps,
                                   &pTmpQPBuff );

            if (FAILED(rc1))
            {
            	TrERROR(GENERAL,"Failed to check QM props. %!hresult!", rc1);
                return rc1;
            }

            if ((rc1 == MQ_INFORMATION_PROPERTY) && (iPbKey < pQMProps->cProp))
            {
                //
                // If only PROPID_QM_ENCRYPTION_PK caused the return code
                // of RTpCheckQMProps to return MQ_INFORMATION_PROPERTY, so
                // convert it to MQ_OK.
                //
                rc1 = MQ_OK;

                for (DWORD iProp = 0; iProp < pQMProps->cProp; iProp++)
                {
                    if (aLocalStatus[iProp] != MQ_OK)
                    {
                        rc1 = MQ_INFORMATION_PROPERTY;
                        break;
                    }
                }
            }

            //
            // We may get here with zero properties to retrieve, if the
            // application is only interested in PROPID_QM_ENCRYPTION_PK.
            //
            if (pGoodQMProps->cProp)
            {
                //
                // Check if CN list is requested. If yes return the Index and replace the
                // property to PROPID_QM_CNS
                //
                fGetConnection = IsConnectionRequested(pGoodQMProps,
                                                       &dwConnectionIndex);

                if (lpwsPathName)
                {
                    rc = ADGetObjectProperties(
                                eMACHINE,
								MachineDomain(),     // pwcsDomainController
								false,	    // fServerName
                                lpwsPathName,
                                pGoodQMProps->cProp,
                                pGoodQMProps->aPropID,
                                pGoodQMProps->aPropVar
								);
                }
                else
                {
                    rc = ADGetObjectPropertiesGuid(
                                eMACHINE,
								MachineDomain(),     // pwcsDomainController
								false,	    // fServerName
                                pguidMachineId,
                                pGoodQMProps->cProp,
                                pGoodQMProps->aPropID,
                                pGoodQMProps->aPropVar
								);
                }
            }
            else
            {
                rc = MQ_OK;
            }

			if ( fGetConnection	)
			{
				//
				//	Replace back the connection propid value ( also in case
				//	of failure)
				//
				pGoodQMProps->aPropID[dwConnectionIndex] = 	PROPID_QM_CONNECTION;
			}

            if (SUCCEEDED(rc))
            {
                rc = GetEncryptionPublicKey(lpwsPathName,
                                            pguidMachineId,
                                            aLocalStatus,
                                            pQMProps);
            }

            if (SUCCEEDED(rc) && fGetConnection)
            {
                rc = GetCNNameList(&(pGoodQMProps->aPropVar[dwConnectionIndex]));
            }
            //
            // Here we have out machindwConnectionIndexe properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            //
            if (SUCCEEDED(rc) && (pQMProps != pGoodQMProps))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQMProps->cProp; i++, j++)
                {
                    while(pQMProps->aPropID[j] != pGoodQMProps->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pQMProps->cProp);
                    }
                    pQMProps->aPropVar[j] = pGoodQMProps->aPropVar[i];

                }

                //
                // Check if there is a real warning or the warning came from
                // the PROPID_QM_ENCRYPTION_PK property
                //
                BOOL fWarn = FALSE;
                for (i = 0; i < pQMProps->cProp; i++)
                {
                    if (aLocalStatus[i] != MQ_OK)
                    {
                        fWarn = TRUE;
                    }
                }

                if (!fWarn && (rc1 != MQ_OK))
                {
                    rc1 = MQ_OK;
                }

            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 80); 
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete[] aLocalStatus_buff;
    }

	if (FAILED(rc))
	{
		TrERROR(GENERAL, "Failed to get machine poperties for %ls. %!hresult!", lpwcsMachineName, rc);
		return rc;
	}

    return LogHR(rc1, s_FN, 90);
}

//---------------------------------------------------------
//
//  FillPrivateComputerVersion(...)
//
//  Description:
//
//      Retrieve private computer MSMQ version
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void FillPrivateComputerVersion(
			IN OUT MQPROPVARIANT * pvar
			)
{
	struct lcversion
	{
		unsigned short buildNumber;
		unsigned char minor;
		unsigned char major;
	};

	lcversion * plcversion = (lcversion *)&pvar->ulVal;
	plcversion->major = MSMQ_RMJ;
	plcversion->minor = MSMQ_RMM;
	plcversion->buildNumber = rup;
	pvar->vt = VT_UI4;
}

//---------------------------------------------------------
//
//  FillPrivateComputerDsEnabled(...)
//
//  Description:
//
//      Retrieve private computer DS enabled state
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void  FillPrivateComputerDsEnabled(
			IN OUT MQPROPVARIANT * pvar
			)
{
	pvar->boolVal = (IsWorkGroupMode()) ? VARIANT_FALSE : VARIANT_TRUE;
	pvar->vt = VT_BOOL;
}

//---------------------------------------------------------
//
//  MQGetPrivateComputerInformation(...)
//
//  Description:
//
//      Falcon API.
//      Retrieve local computer properties (i.e. calculated properties
//      not ones that are kept in the DS).
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR			lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
)
{
	if(g_fDependentClient)
		return DepGetPrivateComputerInformation(
					lpwcsComputerName, 
					pPrivateProps
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc(MQDS_MACHINE);

	//
	//	For the time being 	lpwcsComputerName must be NULL
	//
	if ( lpwcsComputerName != NULL)
	{
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
	}

    HRESULT* aLocalStatus_buff = NULL;

    __try
    {
		__try
		{
            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (pPrivateProps->aStatus == NULL)
            {
                aLocalStatus_buff = new HRESULT[pPrivateProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pPrivateProps->aStatus;
            }
            //
            //  validate props and variants
            //
			rc = RTpCheckComputerProps(
				pPrivateProps,
				aLocalStatus
				);
			if (FAILED(rc))
			{
				return LogHR(rc, s_FN, 120);
			}

			for ( DWORD i = 0; i < pPrivateProps->cProp; i++)
			{
				if ( aLocalStatus[i] != MQ_OK)
				{
					//
					//	don't fill in response for unsupported properties, or
					//  properties that are duplicate etc.
					//
					continue;
				}
				switch ( pPrivateProps->aPropID[i])
				{
				case PROPID_PC_VERSION:
					FillPrivateComputerVersion( &pPrivateProps->aPropVar[i]);
					break;
				case PROPID_PC_DS_ENABLED:
					FillPrivateComputerDsEnabled(&pPrivateProps->aPropVar[i]);
					break;
				default:
					ASSERT(0);
					return LogHR(MQ_ERROR_PROPERTY, s_FN, 130);
					break;
				}
			}

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 140); 
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }
    return LogHR(rc, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\qmmgmt_c_.c ===
#pragma warning(push, 3)
#include <qmmgmt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\message.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    message.cpp

Abstract:

    This module contains code involved with Message APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include <_secutil.h>
#include "mqutil.h"
#include <mqcrypt.h>
#include "rtsecutl.h"
#include "acdef.h"
#include "rtprpc.h"
#include "objbase.h"
#define _MTX_NOFORCE_LIBS
#include "comsvcs.h"
#include "TXDTC.H"
#include "xactmq.h"
#include <mqsec.h>
#include <ph.h>
#include <rtdep.h>
#include <SignMqf.h>
#include <autohandle.h>
#include "cry.h"
#include "SignMessageXml.h"
#include "mqformat.h"
#include "mqfutils.h"
#include "authlevel.h"

#include "message.tmh"

extern GUID  g_QMId;

static WCHAR *s_FN=L"rt/message";



static
bool
NeedToSignMqf(
	IN LPCWSTR pwszTargetFormatName
	)
/*++
Routine Description:
	Check if we need to sign with Mqf signature.
	check if Target Queue is MQF or DL.

Arguments:
	pwszTargetFormatName - Target queue FormatName

Returned Value:
	true if we must sign with MQF signature, false if not

--*/
{
	//
	// Check Target Queue FormatName
	//
	AP<QUEUE_FORMAT> pMqf;
	DWORD nMqf;
	CStringsToFree StringsToFree;
	if (!FnMqfToQueueFormats(
			pwszTargetFormatName,
			pMqf,
			&nMqf,
			StringsToFree
			))
	{
		ASSERT(("FnMqfToQueueFormats failed, we should catch this earlier", 0));
		return false;
	}

	ASSERT(nMqf > 0);

	return MQpNeedDestinationMqfHeader(pMqf, nMqf);
}


static
bool
CanSignMqf(
	IN LPCWSTR pwszTargetFormatName,
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Check if we need to sign with Mqf signature.
	Check if Response or Admin queues are MQF
	or if Target Queue is MQF or DL.

Arguments:
	pwszTargetFormatName - Target queue FormatName
    pSendParams - pointer to send params.

Returned Value:
	true if we need to sign with MQF signature, false if not

--*/
{
	//
	// Check Target Queue FormatName
	//
	AP<QUEUE_FORMAT> pMqf;
	DWORD nMqf;
	CStringsToFree StringsToFree;
	if (!FnMqfToQueueFormats(
			pwszTargetFormatName,
			pMqf,
			&nMqf,
			StringsToFree
			))
	{
		ASSERT(("FnMqfToQueueFormats failed, we should catch this earlier", 0));
		return false;
	}

	ASSERT(nMqf > 0);

	return MQpNeedMqfHeaders(pMqf, nMqf, pSendParams);
}



//---------------------------------------------------------
//
//  GetThreadEvent(...)
//
//  Description:
//
//      Get RT event for this thread. Get it either from
//      The TLS or create a new one.
//
//  Return Value:
//
//      The event handle
//
//---------------------------------------------------------

HRESULT GetThreadEvent(HANDLE& hEvent)
{
    hEvent = TlsGetValue(g_dwThreadEventIndex);
    if (hEvent != NULL)
    {
        return MQ_OK;
    }
	
	DWORD gle = GetLastError();
	if(gle != NO_ERROR)
	{
		TrERROR(GENERAL, "Failed to get event from TLS. Tls index = %d. %!winerr!", g_dwThreadEventIndex, gle);
		return HRESULT_FROM_WIN32(gle);
	}

    //
    //  Event was never allocated for this thread.
    //
    hEvent = CreateEvent(0, TRUE, TRUE, 0);

    if(hEvent == NULL)
    { 
    	gle = GetLastError();
		TrERROR(GENERAL, "Failed to create event for thread. %!winerr!", gle);
        return HRESULT_FROM_WIN32(gle);
    }

    //
    //  Set the Event first bit to disable completion port posting
    //
    hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

    BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
	if(!fSuccess)
	{
		gle = GetLastError();
		TrERROR(GENERAL, "Failed to set TLS value.TLS index = %d. %!winerr!",g_dwThreadEventIndex, gle);
		CloseHandle(hEvent);
		return HRESULT_FROM_WIN32(gle);
	}

    return MQ_OK;
}


static
HRESULT
CalcSignutureTypes(
    IN OUT CACSendParameters *pSendParams,
    OUT ULONG*				pulAuthLevel,
	IN LPCWSTR				pwszTargetFormatName,
	IN const CACGetQueueHandleProperties& qhp
	)
/*++

Routine Description:
	
	Decide which signature types(versions) should be sign.

Arguments:
    pSendParams - pointer to send params.
  	pulAuthLevel - authentication level
	pwszTargetFormatName - targert format name
	qhp - queue handle properties, this have the information which protocols are in use

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	ASSERT(pSendParams->MsgProps.ulAuthLevel != MQMSG_AUTH_LEVEL_NONE);
	ASSERT(qhp.fProtocolSrmp || qhp.fProtocolMsmq);

	ULONG ulAuthLevelSrmp = MQMSG_AUTH_LEVEL_NONE;
	if(qhp.fProtocolSrmp)
	{
		//
		// for Srmp protocol authentication we currently have only one type
		//
		ulAuthLevelSrmp = MQMSG_AUTH_LEVEL_XMLDSIG_V1;
		TrTRACE(SECURITY, "RT: SignutureTypes(), ProtocolSrmp signature MQMSG_AUTH_LEVEL_XMLDSIG_V1");
	}

	ULONG ulAuthLevelMsmq = MQMSG_AUTH_LEVEL_NONE;

	if(qhp.fProtocolMsmq)
	{
		ulAuthLevelMsmq = pSendParams->MsgProps.ulAuthLevel;

		if(pSendParams->MsgProps.ulAuthLevel == MQMSG_AUTH_LEVEL_ALWAYS)
		{
			//
			// See if registry is configured to compute only one signature.
			//
			static DWORD s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN;
			static BOOL  s_fAuthnAlreadyRead = FALSE;

			if (!s_fAuthnAlreadyRead)
			{
				DWORD dwSize = sizeof(DWORD);
				DWORD dwType = REG_DWORD;

				LONG res = GetFalconKeyValue(
									  SEND_MSG_AUTHN_REGNAME,
									 &dwType,
									 &s_dwAuthnLevel,
									 &dwSize
									 );

				if (res != ERROR_SUCCESS)
				{
					s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN;
					TrTRACE(SECURITY, "RT: SignutureTypes(), registry key not exist using default = %d", DEFAULT_SEND_MSG_AUTHN);
				}
				else if (!IS_VALID_AUTH_LEVEL(s_dwAuthnLevel))
				{
					//
					// Allow only AUTH_LEVEL_MASK bits to be set
					// Wrong value in registry. Use the default, to have
					// predictable results.
					//
					TrWARNING(SECURITY, "RT: SignutureTypes(), Wrong registry value %d (invalid bits), using default = %d", s_dwAuthnLevel, DEFAULT_SEND_MSG_AUTHN);
					s_dwAuthnLevel = DEFAULT_SEND_MSG_AUTHN;
				}
				else if (IS_AUTH_LEVEL_ALWAYS_BIT(s_dwAuthnLevel) && (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_ALWAYS))
				{
					//
					// MQMSG_AUTH_LEVEL_ALWAYS bit can not be set with other bits
					// Wrong value in registry. Use the default, to have
					// predictable results.
					//
					TrWARNING(SECURITY, "RT: SignutureTypes(), Wrong registry value %d (ALWAYS bit set with other bits), using default = %d", s_dwAuthnLevel, DEFAULT_SEND_MSG_AUTHN);
					s_dwAuthnLevel = DEFAULT_SEND_MSG_AUTHN;
				}

				s_fAuthnAlreadyRead = TRUE;

				//
				// This should be the default.
				// by default, authenticate only with old style, to prevent
				// performance hit and to be backward  compatible.
				//
				ASSERT(DEFAULT_SEND_MSG_AUTHN == MQMSG_AUTH_LEVEL_SIG10);
			}
			ulAuthLevelMsmq = s_dwAuthnLevel;
			TrTRACE(SECURITY, "RT: SignutureTypes(), MQMSG_AUTH_LEVEL_ALWAYS(read registry): ulAuthLevelMsmq = %d", ulAuthLevelMsmq);
		}

		if(ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_ALWAYS)
		{
			//
			// We were asked to compute all possible signatures.
			// Replace the MQMSG_AUTH_LEVEL_ALWAYS with value that set all the signature bits
			//
			ulAuthLevelMsmq = (MQMSG_AUTH_LEVEL_SIG10 | MQMSG_AUTH_LEVEL_SIG20 | MQMSG_AUTH_LEVEL_SIG30);
		}

		if(IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq))
		{
			//
			// The user ask to compute MSMQ20 signature
			// Check if we can sign MSMQ20 signature
			//
			if(NeedToSignMqf(pwszTargetFormatName))
			{
				//
				// ISSUE-2000/11/05-ilanhh should we return error if registry is configured to MQMSG_AUTH_LEVEL_SIG20 ?
				// or just if user application asked for MQMSG_AUTH_LEVEL_SIG20
				// pSendParams->MsgProps.ulAuthLevel is the user application input
				// ulAuthLevel is also the registry setting in case MQMSG_AUTH_LEVEL_ALWAYS
				//
				if(ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_SIG20)		
				{
					//
					// User ask specifically for MSMQ20 signature
					//
					TrERROR(SECURITY, "User (or registry) ask specifically for MSMQ20 signature, but DestinationQueue is Mqf or DL");
					return MQ_ERROR_CANNOT_SIGN_DATA_EX;
				}

				//
				// MSMQ20 will failes, remove MQMSG_AUTH_LEVEL_SIG20 bit
				//
				CLEAR_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq);

				//
				// Turn on MQMSG_AUTH_LEVEL_SIG10, MQMSG_AUTH_LEVEL_SIG30 signature bits
				//
				SET_AUTH_LEVEL_SIG10_BIT(ulAuthLevelMsmq);
				SET_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq);

				TrWARNING(SECURITY, "RT: SignutureTypes(), DestinationQueue is Mqf or DL, Replace MSMQ20 signature with MSMQ10 and MSMQ30 signatures");
			}

			//
			// ISSUE-2000/11/05-ilanhh we don't convert MQMSG_AUTH_LEVEL_SIG20 to MQMSG_AUTH_LEVEL_SIG30
			// if we NeedMqfSignature but not MustMqfSignature (Admin, Response queues)
			// in that case the user should ask for MQMSG_AUTH_LEVEL_SIG30 if he wants it.
			//
		}

		if(IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq))
		{
			//
			// We will not prepare MSMQ30 signature if we don't have MQF headers
			// BUGBUG: need to support this. ilanh 05-Nov-2000
			//
			if(!CanSignMqf(pwszTargetFormatName, pSendParams))
			{
				//
				// Mqf headers will not be include in the packet
				// Remove MQMSG_AUTH_LEVEL_SIG30 bit
				// and replace it with MQMSG_AUTH_LEVEL_SIG20 signature
				// which in this case is almost the same
				//
				CLEAR_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq);
				SET_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq);

				TrWARNING(SECURITY, "RT: SignutureTypes(), We dont have any MQF headers, Replace MSMQ30 signature with MSMQ20 signatures");
			}
		}
	}

	ULONG ulAuthLevel = ulAuthLevelMsmq | ulAuthLevelSrmp;
	pSendParams->MsgProps.ulAuthLevel = ulAuthLevel;
	*pulAuthLevel = ulAuthLevel;
	return MQ_OK;
}


static
bool
ShouldSignMessage(
    IN CACMessageProperties* pMsgProps
	)
/*++

Routine Description:
	
	Check if we should sign the message.

Arguments:
    pMsgProps - pointer to message properties.

Returned Value:
    true if the message should be signed, false if not.

--*/
{
	if(pMsgProps->ulAuthLevel == MQMSG_AUTH_LEVEL_NONE)
	{
		TrTRACE(SECURITY, "RT: ShouldSignMessage() = false");
		return false;
	}

	ASSERT(IS_VALID_AUTH_LEVEL(pMsgProps->ulAuthLevel));

	TrTRACE(SECURITY, "RT: ShouldSignMessage() = true");
	return true;

}


//+-------------------------------------
//
//  HRESULT  _BeginToSignMessage()
//
//+-------------------------------------

static
HRESULT
_BeginToSignMessage(
	IN CACMessageProperties * pMsgProps,
	IN PMQSECURITY_CONTEXT    pSecCtx,
	OUT HCRYPTHASH          * phHash
	)
{
    HRESULT hr;
    DWORD   dwErr;

    ASSERT(pSecCtx);

    if (!pSecCtx->hProv)
    {
        //
        // Import the private key into process hive.
        //
        hr = RTpImportPrivateKey(pSecCtx);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 20);
        }
    }
    ASSERT(pSecCtx->hProv);

    //
    // Create the hash object.
    //
    if (!CryptCreateHash(
            pSecCtx->hProv,
            *pMsgProps->pulHashAlg,
            0,
            0,
            phHash
			))
    {
        dwErr = GetLastError();
        TrERROR(SECURITY, "RT: _BeginToSignMessage(), fail at CryptCreateHash(), err- %lxh", dwErr);

        LogNTStatus(dwErr, s_FN, 29);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 30);
    }

    return MQ_OK;
}

//-------------------------------------------------------------------------
//
//  HRESULT SignMessage()
//
//  Description:
//
//      Signs the messag body. compute the hash, and sign it with private
//      key. This add a signature section to the packet
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//-------------------------------------------------------------------------

static
HRESULT
SignMessage(
	IN CACSendParameters * pSendParams,
	IN PMQSECURITY_CONTEXT pSecCtx
	)
{
    HCRYPTHASH  hHash = NULL;

    CACMessageProperties * pMsgProps = &pSendParams->MsgProps;

    HRESULT hr =  _BeginToSignMessage(
						pMsgProps,
						pSecCtx,
						&hHash
						);
    if (FAILED(hr))
    {
        return hr;
    }
    CHCryptHash hAutoRelHash = hHash;

	//
	// Prepare old QueueFormat response and admin queues
	//
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(pSendParams->nResponseMqf, pSendParams->ResponseMqf, &pResponseQueueFormat);

    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(pSendParams->nAdminMqf, pSendParams->AdminMqf, &pAdminQueueFormat);

	hr = HashMessageProperties( // Compute the hash value for the mesage body.
            hHash,
            pMsgProps->ppCorrelationID ? *pMsgProps->ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            pMsgProps->pApplicationTag ? *pMsgProps->pApplicationTag : DEFAULT_M_APPSPECIFIC,
            pMsgProps->ppBody ? *pMsgProps->ppBody : NULL,
            pMsgProps->ulBodyBufferSizeInBytes,
            pMsgProps->ppTitle ? *pMsgProps->ppTitle : NULL,
            pMsgProps->ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            pResponseQueueFormat,
            pAdminQueueFormat
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    if (!CryptSignHash(        // Sign the mesage.
            hHash,
			pSecCtx->dwPrivateKeySpec,
            NULL,
            0,
            *(pMsgProps->ppSignature),
            &pMsgProps->ulSignatureSize
			))
    {
        DWORD dwErr = GetLastError();
        TrERROR(SECURITY, "CryptSignHash() failed, err- %!winerr!", dwErr);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (pMsgProps->ulSignatureSize == 0)
    {
        TrERROR(SECURITY, "RT: SignMessage(), CryptSignHash return with zero signature size");

        ASSERT(pMsgProps->ulSignatureSize != 0);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 60);
    }

	TrTRACE(SECURITY, "RT: SignMessage() MSMQ10 signature complete ok");
    return(MQ_OK);
}

//---------------------------------------------------------
//
//  _SignMessageEx
//
//  Description:
//
//    Signs properties that were not signed in msmq1.0
//    Properties we sign here:
//    - target queue
//    - source qm guid
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//---------------------------------------------------------

static
HRESULT
_SignMessageEx(
	IN LPCWSTR				  pwszTargetFormatName,
	IN OUT CACSendParameters  *pSendParams,
	IN PMQSECURITY_CONTEXT     pSecCtx,
	OUT BYTE                  *pSignBufIn,
	OUT DWORD                 *pdwSignSize
	)
{
	//
    // Prepare the necessray structers to be included in packet.
    //
    struct _SecuritySectionEx *pSecEx = (struct _SecuritySectionEx *) pSignBufIn;
    struct _SecuritySubSectionEx *pSubSecEx = (struct _SecuritySubSectionEx *) (&(pSecEx->aData[0]));

    ULONG  ulTestLen = 0;
    USHORT ulTestSections = 0;

#ifdef _DEBUG
{
    //
    // Simulate subsection that precede the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
	BYTE* pSubPtr = NULL;
    static DWORD s_dwPrefixCount = 0;
    static BOOL  s_fPreAlreadyRead = FALSE;

    if (!s_fPreAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG res = GetFalconKeyValue(
					   PREFIX_SUB_SECTIONS_REGNAME,
					   &dwType,
					   &s_dwPrefixCount,
					   &dwSize
					   );

        if (res != ERROR_SUCCESS)
        {
            s_dwPrefixCount = 0;
        }
        s_fPreAlreadyRead = TRUE;
    }

    for ( USHORT j = 0 ; j < (USHORT) s_dwPrefixCount ; j++ )
    {
        ulTestSections++;
        pSubSecEx->eType = e_SecInfo_Test;
        pSubSecEx->_u.wFlags = 0;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 7) + 1 +
                                    sizeof(struct _SecuritySubSectionEx));

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr;
    }
}
#endif

    pSubSecEx->eType = e_SecInfo_User_Signature_ex;
    pSubSecEx->_u.wFlags = 0;
    pSubSecEx->_u._UserSigEx.m_bfTargetQueue = 1;
    pSubSecEx->_u._UserSigEx.m_bfSourceQMGuid = 1;
    pSubSecEx->_u._UserSigEx.m_bfUserFlags = 1;
    pSubSecEx->_u._UserSigEx.m_bfConnectorType = 1;

    BYTE *pSignBuf = (BYTE*) &(pSubSecEx->aData[0]);

    //
    // start signing (create the hash object).
    //
    HCRYPTHASH hHash;

    CACMessageProperties * pMsgProps = &pSendParams->MsgProps;

    HRESULT hr = _BeginToSignMessage(
					 pMsgProps,
                     pSecCtx,
                     &hHash
					 );

    if (FAILED(hr))
    {
        return hr;
    }
    CHCryptHash hAutoRelHash = hHash;

	//
	// Prepare old QueueFormat response and admin queue
	//
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(pSendParams->nResponseMqf, pSendParams->ResponseMqf, &pResponseQueueFormat);

    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(pSendParams->nAdminMqf, pSendParams->AdminMqf, &pAdminQueueFormat);

    hr = HashMessageProperties(
             hHash,
             pMsgProps->ppCorrelationID ? *pMsgProps->ppCorrelationID : NULL,
             PROPID_M_CORRELATIONID_SIZE,
             pMsgProps->pApplicationTag ? *pMsgProps->pApplicationTag : DEFAULT_M_APPSPECIFIC,
             pMsgProps->ppBody ? *pMsgProps->ppBody : NULL,
             pMsgProps->ulBodyBufferSizeInBytes,
             pMsgProps->ppTitle ? *pMsgProps->ppTitle : NULL,
             pMsgProps->ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
             pResponseQueueFormat,
             pAdminQueueFormat
			 );

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

    sUserFlags.bDelivery = DEFAULT_M_DELIVERY;
    sUserFlags.bPriority = DEFAULT_M_PRIORITY;
    sUserFlags.bAuditing = DEFAULT_M_JOURNAL;
    sUserFlags.bAck      = DEFAULT_M_ACKNOWLEDGE;
    sUserFlags.usClass   = MQMSG_CLASS_NORMAL;

    if (pMsgProps->pDelivery)
    {
        sUserFlags.bDelivery = *(pMsgProps->pDelivery);
    }
    if (pMsgProps->pPriority)
    {
        sUserFlags.bPriority = *(pMsgProps->pPriority);
    }
    if (pMsgProps->pAuditing)
    {
        sUserFlags.bAuditing = *(pMsgProps->pAuditing);
    }
    if (pMsgProps->pAcknowledge)
    {
        sUserFlags.bAck      = *(pMsgProps->pAcknowledge);
    }
    if (pMsgProps->pClass)
    {
        sUserFlags.usClass   = *(pMsgProps->pClass);
    }
    if (pMsgProps->pulBodyType)
    {
        sUserFlags.ulBodyType = *(pMsgProps->pulBodyType);
    }

    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;
    if (pMsgProps->ppConnectorType)
    {
        pConnectorGuid = *(pMsgProps->ppConnectorType);
    }

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry));
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[ dwStructSize ];

    pHashData->cEntries = 4;
    (pHashData->aEntries[0]).dwSize = (1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR);
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID);
    (pHashData->aEntries[1]).pData = (const BYTE*) &g_QMId;
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags);
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags;
    (pHashData->aEntries[3]).dwSize = sizeof(GUID);
    (pHashData->aEntries[3]).pData = (const BYTE*) pConnectorGuid;

    hr = MQSigHashMessageProperties(hHash, pHashData);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // sign the has with private key.
    //
    if (!CryptSignHash(
            hHash,
			pSecCtx->dwPrivateKeySpec,
            NULL,
            0,
            pSignBuf,
            pdwSignSize
			))
    {
    	DWORD gle = GetLastError();
        TrERROR(SECURITY, "CryptSignHash() failed, err = %!winerr!", gle);
        return MQ_ERROR_CANNOT_SIGN_DATA_EX;
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (*pdwSignSize == 0)
    {
        TrERROR(SECURITY, "_SignMessageEx(), CryptSignHash return with zero signature size");

        ASSERT(*pdwSignSize != 0);
        return MQ_ERROR_CANNOT_SIGN_DATA_EX;
    }

    pSubSecEx->wSubSectionLen = (USHORT)
                    (sizeof(struct _SecuritySubSectionEx) + *pdwSignSize);
    ULONG ulSignExLen = ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);

#ifdef _DEBUG
{
	BYTE* pSubPtr = NULL;
    //
    // Simulate subsection that succeed the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPostfixCount = 0;
    static BOOL  s_fPostAlreadyRead = FALSE;

    if (!s_fPostAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG res = GetFalconKeyValue(
					   POSTFIX_SUB_SECTIONS_REGNAME,
					   &dwType,
					   &s_dwPostfixCount,
					   &dwSize
					   );
        if (res != ERROR_SUCCESS)
        {
            s_dwPostfixCount = 0;
        }
        s_fPostAlreadyRead = TRUE;
    }

    pSubPtr = ((BYTE*) pSubSecEx) + ulSignExLen;

    for ( USHORT j = 0; j < (USHORT) s_dwPostfixCount; j++ )
    {
        ulTestSections++;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr;
        pSubSecEx->eType = e_SecInfo_Test;
        pSubSecEx->_u.wFlags = 0;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 11) + 1 +
                                   sizeof(struct _SecuritySubSectionEx));

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
    }
}
#endif

    pSecEx->cSubSectionCount = (USHORT) (1 + ulTestSections);
    pSecEx->wSectionLen = (USHORT) ( sizeof(struct _SecuritySectionEx)   +
                                     ulSignExLen                         +
                                     ulTestLen );

    *pdwSignSize = pSecEx->wSectionLen;

	TrTRACE(SECURITY, "RT: _SignMessageEx() MSMQ20 signature complete ok");
    return MQ_OK;
}

//+-------------------------------------------------------
//
//  BOOL  ShouldEncryptMessage()
//
//  Return TRUE, if the message should be encrypted.
//
//+-------------------------------------------------------

static
BOOL
ShouldEncryptMessage(
    CACMessageProperties * pMsgProps,
    enum enumProvider    * peProvider
    )
{
    BOOL bRet = FALSE;

    if (!pMsgProps->ulBodyBufferSizeInBytes)
    {
        //
        // No message body, nothing to encrypt.
        //
        return(FALSE);
    }

    switch (*pMsgProps->pulPrivLevel)
    {
    case MQMSG_PRIV_LEVEL_NONE:
        bRet = FALSE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_BASE:
        *peProvider = eBaseProvider;
        bRet = TRUE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        *peProvider = eEnhancedProvider;
        bRet = TRUE;
        break;
    }

    return(bRet);
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentViperTransaction
//
// Gets current COM+ transaction if there is one...
//
// CoGetObjectContext is exported by OLE32.dll
// IObjectContextInfo is defined in the latest COM+ SDK (part of the platform SDK)
//=--------------------------------------------------------------------------=

static HRESULT  GetCurrentViperTransaction(OUT ITransaction **ppITransaction)
{
    *ppITransaction = NULL;
    IObjectContextInfo *pInfo  = NULL;

    HRESULT hr = CoGetObjectContext(IID_IObjectContextInfo, (void **)&pInfo);
    if (SUCCEEDED(hr) && pInfo)
    {
        //
        // Win bug 606598.
        // We're in the context of COM+.
        // if GetTransaction() succeed then:
        // 1. if pTransaction is NULL, then we're outside of a transaction.
        // 2. if not-NULL, then we're inside transaction context.
        // If GetTransaction fail then we fail the api.
        //
    	hr = pInfo -> GetTransaction((IUnknown **) ppITransaction);
	    pInfo -> Release();

        if (FAILED(hr))
        {
		    TrERROR(XACT_GENERAL, "GetTransaction() failed, hr- 0x%lx", hr);
        }
    }
    else if (hr == E_NOINTERFACE)
    {
        //
        // We know for sure the we're not in the context of COM+.
        // Go on without transaction.
        //
        hr = MQ_OK ;
    }
    else
    {
        //
        // Let's fail the api. We have no idea what happened.
        //
		TrERROR(XACT_GENERAL, "CoGetObjectContext() failed, hr- 0x%lx", hr);
        hr = MQ_ERROR_DTC_CONNECT ;
    }

    return hr ;
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentXATransaction
// Gets current XA transaction if there is one...
//=--------------------------------------------------------------------------=

static HRESULT  GetCurrentXATransaction(ITransaction **ppITransaction)
{
    *ppITransaction = NULL ;
    IXATransLookup *pXALookup = NULL;
    HRESULT         hr = MQ_OK;
    IUnknown       *punkDtc = NULL;

    hr = XactGetDTC(&punkDtc);

    if (FAILED(hr) || punkDtc==NULL)
    {
        LogHR(hr, s_FN, 80);
        return  MQ_ERROR_DTC_CONNECT ;
    }

    // Get the DTC  ITransactionImportWhereabouts interface
    hr = punkDtc->QueryInterface (IID_IXATransLookup, (void **)(&pXALookup));
    punkDtc->Release();
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 90);
        return hr ;
    }
    ASSERT(pXALookup);

    hr = pXALookup->Lookup(ppITransaction);
    pXALookup->Release();

    if (hr == XACT_E_NOTRANSACTION)
    {
        //
        // Win bug 606598.
        // We're outside of a XA transaction, for sure.
        //
        *ppITransaction = NULL ;
        hr = MQ_OK ;
    }
    else if (FAILED(hr))
    {
        LogHR(hr, s_FN, 100);
    }

    return hr ;
}


static
HRESULT
GetCertAndSecurityContext(
    IN OUT CACMessageProperties *pMsgProps,
	OUT BYTE **ppUserCert,
    IN OUT PMQSECURITY_CONTEXT& pSecCtx,
	OUT P<MQSECURITY_CONTEXT>& pSecCtxToFree
	)
/*++

Routine Description:
	Check and initialize the User Certificate and the security context.
	Note: This function replaced the block in RTpSendMessage that dealt with this

Arguments:
    pMsgProps - pointer to send message properties.
	ppUserCert - pointer to the user certificate.
	pSecCtx - pointer to the security context.
	pSecCtxToFree - auto pointer for releasing the created temporary security context

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
    BOOL bShouldGetCertInfo = TRUE;

    if (!pSecCtx)
    {
        //
        // Security context NOT provided by caller, in a
        // message property.
        //
        if (!pMsgProps->ppSenderCert)
        {
            //
            // Caller also did not provide a certificate in the
            // message properties array. In this case we take the
            // cached security context of the process.
            //

            HRESULT hr = InitSecurityContextCertInfo();
            if(FAILED(hr))
			{
				TrERROR(GENERAL, "Failed to init the certificate info. %!hresult!", hr);
				return hr;
			}
            
            if (!g_pSecCntx->pUserCert)
            {
                //
                // The process does not have an internal
                // certificate, there is nothing that we can do
                // but fail.
                //
                return LogHR(MQ_ERROR_NO_INTERNAL_USER_CERT, s_FN, 152);
            }
            *ppUserCert = g_pSecCntx->pUserCert;
            pMsgProps->ppSenderCert = ppUserCert;
            pMsgProps->ulSenderCertLen = g_pSecCntx->dwUserCertLen;
            pSecCtx = g_pSecCntx;
            bShouldGetCertInfo = FALSE;
        }
    }
    else
    {
        if (!pMsgProps->ppSenderCert)
        {
            //
            // Caller provided a security context, but not a
            // certificate. We take the certificate from the
            // security context.
            //
            *ppUserCert = pSecCtx->pUserCert;
            pMsgProps->ppSenderCert = ppUserCert;
            pMsgProps->ulSenderCertLen = pSecCtx->dwUserCertLen;
            bShouldGetCertInfo = FALSE;
        }
        else
        {
            //
            // We have a security context and a certificate in
            // PROPID_M_USER_CERT. In this case, we should use
            // the certificate in PROPID_M_USER_CERT. We can use
            // the cashed certificate information in the security
            // context, if the certificate in the security context
            // is the same as in PROPID_M_USER_CERT.
            //
            bShouldGetCertInfo =
                (pSecCtx->dwUserCertLen != pMsgProps->ulSenderCertLen) ||
                (memcmp(
                     pSecCtx->pUserCert,
                     *pMsgProps->ppSenderCert,
                     pMsgProps->ulSenderCertLen
					 ) != 0);
        }
    }

    if (bShouldGetCertInfo)
    {
        //
        // Caller provided a certificate, but not a security
        // context.  Get all the information for the certificate.
        // We put the certificate information in a temporary
        // security context.
        //
        ASSERT(pMsgProps->ppSenderCert);

	    pSecCtxToFree = AllocSecurityContext();
		PMQSECURITY_CONTEXT pTmpSecCtx = pSecCtxToFree.get();

        HRESULT hr = GetCertInfo(
                         false,
						 pTmpSecCtx->fLocalSystem,
						 pMsgProps->ppSenderCert,
						 &pMsgProps->ulSenderCertLen,
						 &pTmpSecCtx->hProv,
						 &pTmpSecCtx->wszProvName,
						 &pTmpSecCtx->dwProvType,
						 &pTmpSecCtx->bDefProv,
						 &pTmpSecCtx->bInternalCert,
						 &pTmpSecCtx->dwPrivateKeySpec
						 );

        //
        // The caller can not provide the internal certificate as
        // a message property, only his own externel certificate.
        // ASSERT this condition.
        //
        ASSERT(!(pTmpSecCtx->bInternalCert));

		//
		// dwPrivateKeySpec	must be AT_SIGNATURE or AT_KEYEXCHANGE
		//
        ASSERT((pTmpSecCtx->dwPrivateKeySpec == AT_SIGNATURE) ||
			   (pTmpSecCtx->dwPrivateKeySpec == AT_KEYEXCHANGE));

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 160);
        }

        if (pSecCtx)
        {
            //
            // If we got the certificate from PROPID_M_USER_CERT,
            // but we have also a security context, we should get
            // the sender ID from the security context. So copy
            // the sender ID from the security context that we
            // get from the application into the temporary
            // security context.
            //
            pTmpSecCtx->fLocalUser = pSecCtx->fLocalUser;

            if (!pSecCtx->fLocalUser)
            {
                pTmpSecCtx->dwUserSidLen = pSecCtx->dwUserSidLen;
                pTmpSecCtx->pUserSid = new BYTE[pSecCtx->dwUserSidLen];
                BOOL bRet = CopySid(
                                pSecCtx->dwUserSidLen,
                                pTmpSecCtx->pUserSid,
                                pSecCtx->pUserSid
								);
                ASSERT(bRet);
				DBG_USED(bRet);
            }
        }
        else
        {
            pTmpSecCtx->fLocalUser = g_pSecCntx->fLocalUser;
        }

        pSecCtx = pTmpSecCtx;
    }

    ASSERT(pSecCtx);
	return MQ_OK;
}


static
HRESULT
SignMessageMsmq12(
    IN PMQSECURITY_CONTEXT pSecCtx,
    IN ULONG ulAuthLevel,
    IN ULONG* pulProvNameSizeAll,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters *pSendParams,
	IN OUT BYTE *pabMessageSignature,
	OUT AP<BYTE>& pSignatureMqf
	)
/*++

Routine Description:
	Create the Signature for msmq1.0 and msmq2.0
	Note: This function replaced the block in RTpSendMessage that dealt with this

Arguments:
	pSecCtx - pointer to the security context.
	ppUserCert - pointer to the user certificate.
  	ulAuthLevel - authentication level
	pulProvNameSizeAll - provider name size including the extra sections
	pwszTargetFormatName - targert format name
    pSendParams - pointer to send params.
	pabMessageSignature - pointer to signature buffer.
	pSignatureMqf - auto pointer of byte for the signature mqf

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	//
	// Get only the AUTH_LEVEL_MSMQ_PROTOCOL bits
	//
	ULONG ulAuthLevelMsmq = GET_AUTH_LEVEL_MSMQ_PROTOCOL(ulAuthLevel);
	TrTRACE(SECURITY, "RT: SignMessageMsmq12(), AUTH_LEVEL_MSMQ_PROTOCOL = %d", ulAuthLevelMsmq);

	//
	// Sign the message.
	//
	ASSERT(ulAuthLevelMsmq != MQMSG_AUTH_LEVEL_ALWAYS);
	ASSERT(ulAuthLevelMsmq != MQMSG_AUTH_LEVEL_NONE);

	if(IS_AUTH_LEVEL_SIG10_BIT(ulAuthLevelMsmq))
	{
		HRESULT hr = SignMessage(pSendParams, pSecCtx);
		if(FAILED(hr))
		{
			return hr;
		}
		ASSERT(pSendParams->MsgProps.ulSignatureSize != 0);
	}
	else
	{
		//
		// Sign only with win2k style or Mqfsignature.
		// make the "msmq1.0" signature dummy, with a single
		// null dword. It's too risky to have a null pointer
		// as msmq1.0 signature, so a dummy value is better.
		// win2k code will ignore it anyway.
		//
		pSendParams->MsgProps.ulSignatureSize = 4;
		memset(pabMessageSignature, 0, pSendParams->MsgProps.ulSignatureSize);
	}

	//
	// Now create the "Extra" signature. Sign all those
	// properties that were not signed on msmq1.0.
	//
	BYTE abMessageSignatureEx[MAX_MESSAGE_SIGNATURE_SIZE_EX];
	DWORD dwSignSizeEx = sizeof(abMessageSignatureEx);

	if (ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_SIG10)
	{
		//
		// enhanced signature (win2k style) not needed.
		//
		dwSignSizeEx = 0;
	}
	else
	{
		ASSERT(IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq) || IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq));
		
		//
		// Currently if need EX signature check if we need to sign with Mqf Signature
		//
		HRESULT hr;
		if(IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq))
		{
			hr = SignMqf(
						pSecCtx,
						pwszTargetFormatName,
						pSendParams,
						pSignatureMqf,							
						&pSendParams->SignatureMqfSize			
						);
			if(FAILED(hr))
			{
				return hr;
			}
		}

		if(!IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq))
		{
			return MQ_OK;
		}

		hr = _SignMessageEx(
				 pwszTargetFormatName,
				 pSendParams,
				 pSecCtx,
				 abMessageSignatureEx,
				 &dwSignSizeEx
				 );

		if(FAILED(hr))
		{
			return hr;
		}

		ASSERT(dwSignSizeEx != 0);
	}

	//
	// Copy the Ex signature to the standard signature buffer.
	// The driver will separate them and insert them in the
	// packet in the proper place. This is necessary to keep
	// the send parameters buffer without changes.
	//
	if (dwSignSizeEx == 0)
	{
		//
		// Signature not created. That's ok.
		//
	}
	else if ((dwSignSizeEx + pSendParams->MsgProps.ulSignatureSize) <=
								 MAX_MESSAGE_SIGNATURE_SIZE_EX)
	{
		memcpy(
			&(pabMessageSignature[pSendParams->MsgProps.ulSignatureSize ]),
			abMessageSignatureEx,
			dwSignSizeEx
			);

		pSendParams->MsgProps.ulSignatureSize += dwSignSizeEx;

		//
		// Compute size of authentication "provider" field. This
		// field contain the provider name and extra authentication
		// data that was added for post win2k rtm.
		//
		*pulProvNameSizeAll = dwSignSizeEx +
					 ALIGNUP4_ULONG(ComputeAuthProvNameSize(&pSendParams->MsgProps));
		pSendParams->MsgProps.pulAuthProvNameLenProp = pulProvNameSizeAll;
	}
	else
	{
		ASSERT(("Total size of msmq2.0 signature_ex > MAX_MESSAGE_SIGNATURE_SIZE_EX", 0));
		LogHR(MQ_ERROR, s_FN, 170);
	}
	return MQ_OK;
}


static
HRESULT
HandleSignature(
    IN QUEUEHANDLE  hQueue,
	IN OUT CACSendParameters *pSendParams,
    OUT PMQSECURITY_CONTEXT& pSecCtx,
	OUT P<MQSECURITY_CONTEXT>& pSecCtxToFree,
	OUT BYTE **ppUserCert,
    OUT ULONG *pulAuthLevel,
    OUT ULONG *pulProvNameSizeAll,
	OUT WCHAR **ppProvName,
	OUT BYTE **ppabMessageSignature,
	IN ULONG abMessageSignatureSize,
	OUT AP<char>& pSignatureElement,
	OUT AP<BYTE>& pSignatureMqf
	)
/*++

Routine Description:
	Handle the Signature
	Note: This function replaced the block in RTpSendMessage that dealt with the signature

Arguments:
	hQueue - queue handle
    pSendParams - pointer to send params.
	pSecCtx - pointer to the security context.
	pSecCtxToFree - auto pointer for releasing the created temporary security context
	ppUserCert - pointer to the user certificate.
  	pulAuthLevel - pointer to long, authentication level
	pulProvNameSizeAll - pointer to long, provider name size including the extra sections
	ppProvName - pointer to provider name wstring.
	ppabMessageSignature - pointer to pointer of the signature buffer.
	abMessageSignatureSize - Signature buffer size
	pSignatureElement - auto pointer of char for the XMLDSIG signature element string
	pSignatureMqf - auto pointer of byte for the mqf signature

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	//
	// Signature is given by the user
	//
    if (pSendParams->MsgProps.ppSignature)
    {
        if (!pSecCtx && !pSendParams->MsgProps.ppSenderCert)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
        }
        if (!pSendParams->MsgProps.ppSenderCert)
        {
            //
            // We have a security context and no certificate. We
            // take the certificate from the security context.
            //
            *ppUserCert = pSecCtx->pUserCert;
            pSendParams->MsgProps.ppSenderCert = ppUserCert;
            pSendParams->MsgProps.ulSenderCertLen = pSecCtx->dwUserCertLen;
        }

        if (pSendParams->MsgProps.ppwcsProvName)
        {
            ASSERT(pSendParams->MsgProps.pulProvType);
            pSendParams->MsgProps.fDefaultProvider = FALSE;
        }

		return MQ_OK;
    }

	//
	// Should not sign the message --> signature length = 0
	//
	if (!ShouldSignMessage(&pSendParams->MsgProps))
	{
        pSendParams->MsgProps.ulSignatureSize = 0;
		return MQ_OK;
	}

	//
	// Get Target Queue name and decide whether it is Http message
	//
	DWORD dwTargetFormatNameLength = 0;
	HRESULT hr = ACHandleToFormatName(
					 hQueue,
					 NULL,
					 &dwTargetFormatNameLength
					 );

	if(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
	{
		//
		// We got other error then the expected MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL
		// e.g. MQ_ERROR_STALE_HANDLE
		//
		ASSERT(hr != MQ_OK);
        return LogHR(hr, s_FN, 144);
	}

	ASSERT(hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
	ASSERT(dwTargetFormatNameLength > 0);

	AP<WCHAR> pwszTargetFormatName = new WCHAR[dwTargetFormatNameLength];

	hr = ACHandleToFormatName(
			 hQueue,
			 pwszTargetFormatName.get(),
			 &dwTargetFormatNameLength
			 );

	ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 145);
    }

	//
	// Call ACGetQueueHandleProperties to get the types of signatures needed
	// this is based on the queue types we have in the handle.
	//
	CACGetQueueHandleProperties	qhp;
	hr = ACGetQueueHandleProperties(
			 hQueue,
			 qhp
			 );

	if (FAILED(hr))
	{
		return LogHR(hr, s_FN, 146);
	}

	TrTRACE(SECURITY, "RT: HandleSignature(), fProtocolSrmp = %d, fProtocolMsmq = %d", qhp.fProtocolSrmp, qhp.fProtocolMsmq);

	if(!qhp.fProtocolSrmp && !qhp.fProtocolMsmq)
	{
		//
		// Neither of protocols exists!
		// this will be the case for DL= that is empty
		//
		TrTRACE(SECURITY, "RT: HandleSignature(), We have no protocol (empty DL)");
		return LogHR(MQ_OK, s_FN, 147);
	}
	
	hr = CalcSignutureTypes(
			pSendParams,
			pulAuthLevel,
			pwszTargetFormatName.get(),
			qhp
			);

	if (FAILED(hr))
	{
		return LogHR(hr, s_FN, 148);
	}

	//
	// pSecCtx is reference parameters
	//
	hr = GetCertAndSecurityContext(
			 &pSendParams->MsgProps,
			 ppUserCert,
			 pSecCtx,
			 pSecCtxToFree
			 );

	if (FAILED(hr))
	{
		return LogHR(hr, s_FN, 150);
	}

    //
    // Fill the SendParam with the provider information for the
    // certificate.
    //
    if (pSecCtx->wszProvName == NULL)
    {
        //
        // we don't have a provider, so we can't sign.
        //
        ASSERT(pSecCtx->hProv == NULL);
        if (pSendParams->MsgProps.ppSenderCert == NULL)
        {
            //
            // we don't have a certificate. That's a
            // user error.
            //
            return LogHR(MQ_ERROR_CERTIFICATE_NOT_PROVIDED, s_FN, 162);
        }
        else
        {
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 164);
        }
    }

    *ppProvName = pSecCtx->wszProvName;
    pSendParams->MsgProps.ppwcsProvName = ppProvName;
    pSendParams->MsgProps.ulProvNameLen = wcslen(pSecCtx->wszProvName) + 1;
    pSendParams->MsgProps.pulProvType = &pSecCtx->dwProvType;
    pSendParams->MsgProps.fDefaultProvider = pSecCtx->bDefProv;

	if(qhp.fProtocolMsmq)
	{
		//
		// msmq1.0 and msmq2.0 signature treatment.
		//
		// Set the buffer for the signature.
		//
		pSendParams->MsgProps.ppSignature = ppabMessageSignature;
		pSendParams->MsgProps.ulSignatureSize = abMessageSignatureSize;

		hr = SignMessageMsmq12(
				 pSecCtx,
				 *pulAuthLevel,
				 pulProvNameSizeAll,
				 pwszTargetFormatName.get(),
				 pSendParams,
				 *ppabMessageSignature,
				 pSignatureMqf
				 );

		if(FAILED(hr))
		{
			return LogHR(hr, s_FN, 168);
		}
	}	
	
	if(!qhp.fProtocolSrmp)
	{
		return LogHR(MQ_OK, s_FN, 169);
	}

	//
	// Handle Srmp message signature
	//
	try
	{
		BYTE** ppSignatureElementByte = reinterpret_cast<BYTE **>(&pSignatureElement);

		hr = SignMessageXmlDSig(
				 pSecCtx,
				 pSendParams,
				 pSignatureElement
				 );


		if(FAILED(hr))
		{
			return LogHR(hr, s_FN, 166);
		}

		pSendParams->ulXmldsigSize = strlen(pSignatureElement.get());
		pSendParams->ppXmldsig = ppSignatureElementByte;

		return MQ_OK;
	}
	catch (const bad_CryptoApi& exp)
	{
        TrERROR(SECURITY, "RT: SignMessageXmlDSig(), bad Crypto Class Api Excption ErrorCode = %x", exp.error());
		DBG_USED(exp);

		return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 167);
	}
	catch (const bad_alloc&)
	{
        TrERROR(SECURITY, "RT: SignMessageXmlDSig(), bad_alloc Excption");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//---------------------------------------------------------
//
//  RTpSendMessage(...)
//
//  Description:
//
//      Helper function for MQSendMessage
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
static
HRESULT
RTpSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
    )
{
    HRESULT hr;
    XACTUOW Uow;


    BYTE* pUserSid;
    BYTE* pUserCert;
    WCHAR* pProvName;

    CMQHResult rc , rc1;
    rc = MQ_OK;
    rc1 = MQ_OK;

    CACSendParameters SendParams;
    BOOL         fSingleTransaction = FALSE;

    //
    // Set defaults.
	//
    ULONG ulDefHashAlg = PROPID_M_DEFUALT_HASH_ALG;
    ULONG ulDefEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;
    ULONG ulDefPrivLevel = DEFAULT_M_PRIV_LEVEL;
    ULONG ulDefSenderIdType = DEFAULT_M_SENDERID_TYPE;
    ULONG ulSenderIdTypeNone = MQMSG_SENDERID_TYPE_NONE;

    SendParams.MsgProps.pulHashAlg = &ulDefHashAlg;
    SendParams.MsgProps.pulPrivLevel = &ulDefPrivLevel;
    SendParams.MsgProps.pulEncryptAlg = &ulDefEncryptAlg;
    SendParams.MsgProps.pulSenderIDType = &ulDefSenderIdType;
    SendParams.MsgProps.fDefaultProvider = TRUE;
    SendParams.MsgProps.ulAuthLevel = DEFAULT_M_AUTH_LEVEL;

    //
    //  Parse message properties
    //
    PMQSECURITY_CONTEXT pSecCtx;
    CStringsToFree ResponseStringsToFree, AdminStringsToFree;
    rc1 = RTpParseSendMessageProperties(
            SendParams,
            pmp->cProp,
            pmp->aPropID,
            pmp->aPropVar,
            pmp->aStatus,
            &pSecCtx,
            ResponseStringsToFree,
            AdminStringsToFree
			);

    if(FAILED(rc1))
    {
        return LogHR(rc1, s_FN, 110);
    }

    //
    // Look for Viper transaction if any
    //

    //
    // Ref - wrapper to ensure autorelease of the transaction
    //
    R<ITransaction> ref;
    if (pTransaction == MQ_MTS_TRANSACTION)
    {
        hr = GetCurrentViperTransaction(&pTransaction);
		if(FAILED(hr))
		{
            return LogHR(hr, s_FN, 112);
		}
	    ref = pTransaction;
	}
    else if (pTransaction == MQ_XA_TRANSACTION)
    {
        hr = GetCurrentXATransaction(&pTransaction);
		if(FAILED(hr))
		{
            return LogHR(hr, s_FN, 114);
		}
        ref = pTransaction;
    }
    else if (pTransaction == MQ_SINGLE_MESSAGE)
    {
        hr = MQBeginTransaction(&pTransaction);
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 120);
        }

        fSingleTransaction    = TRUE;
		if(pTransaction != NULL)
		{
	        ref = pTransaction;
		}
    }

    //
    // Enlist QM in the transaction (with caching);
    //
    if (pTransaction)
    {
        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        SendParams.MsgProps.pUow = &Uow;

        if(FAILED(hr))
        {
            LogHR(hr, s_FN, 130);
            return hr;
        }
    }

	//
    // Change values for the transaction case
	//
    static UCHAR Delivery;
    static UCHAR Priority;

    if (pTransaction)
    {
        Delivery = MQMSG_DELIVERY_RECOVERABLE;
        Priority = 0;

        SendParams.MsgProps.pDelivery = &Delivery;
        SendParams.MsgProps.pPriority = &Priority;
    }

    //
    // Treat security
    //
    if (!g_pSecCntx)
    {
        //
        //  It might not be initialized if the queue was
        //  not opened for send;
        //
        InitSecurityContext();
    }

    BYTE abMessageSignature[MAX_MESSAGE_SIGNATURE_SIZE_EX];
    BYTE* pabMessageSignature = abMessageSignature;
	AP<char> pSignatureElement;
	AP<BYTE> pSignatureMqf;
    ULONG ulProvNameSizeAll = 0;
    ULONG ulAuthLevel = 0;
	P<MQSECURITY_CONTEXT> pSecCtxToFree;

	hr = HandleSignature(
			 hQueue,
			 &SendParams,
			 pSecCtx,
			 pSecCtxToFree,
			 &pUserCert,
			 &ulAuthLevel,
			 &ulProvNameSizeAll,
			 &pProvName,
			 &pabMessageSignature,
			 TABLE_SIZE(abMessageSignature),
			 pSignatureElement,
			 pSignatureMqf
			 );

	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to handle signature. %!hresult!", hr);
		return hr;
	}

    if(!SendParams.MsgProps.ppSenderID && *SendParams.MsgProps.pulSenderIDType == MQMSG_SENDERID_TYPE_SID)
    {
        if ((pSecCtx && pSecCtx->fLocalUser) ||
            (!pSecCtx && g_pSecCntx->fLocalUser))
        {
            //
            // In case this is a local user, we do not send the user's
            // SID with the message, eventhough the application asked
            // to send it.
            //
            SendParams.MsgProps.pulSenderIDType = &ulSenderIdTypeNone;
        }
        else
        {
            //
            // We should pass the sender ID. Either get it from the
            // security context, if available, or get it from the
            // cached process security context.
            //
            if (!pSecCtx || !pSecCtx->pUserSid)
            {
                if (!g_pSecCntx->pUserSid)
                {
                    //
                    // The cahced process context does not contain the
                    // sender's SID. There is nothing that we can do but
                    // fail.
                    //
                    return LogHR(MQ_ERROR_COULD_NOT_GET_USER_SID, s_FN, 172);
                }
                pUserSid = g_pSecCntx->pUserSid;
                SendParams.MsgProps.uSenderIDLen = (USHORT)g_pSecCntx->dwUserSidLen;
            }
            else
            {
                pUserSid = pSecCtx->pUserSid;
                SendParams.MsgProps.uSenderIDLen = (USHORT)pSecCtx->dwUserSidLen;
            }
            SendParams.MsgProps.ppSenderID = &pUserSid;
        }
    }

    if (SendParams.MsgProps.ppSymmKeys)
    {
        //
        // the application supplied the symmetric key. In such a case
        // doesn't do any encryption
        //
        //
        // When the symm key is supplied, we assume that the body is encrypted and
        // we mark it as such and ignore PROPID_M_PRIV_LEVEL.
        //
        if (SendParams.MsgProps.pulPrivLevel &&
            (*(SendParams.MsgProps.pulPrivLevel) == MQMSG_PRIV_LEVEL_BODY_ENHANCED))
        {
            //
            // priv level supplied by caller.
            //
        }
        else
        {
            //
            // use default.
            //
            ulDefPrivLevel = MQMSG_PRIV_LEVEL_BODY_BASE;
            SendParams.MsgProps.pulPrivLevel = &ulDefPrivLevel;
        }
        SendParams.MsgProps.bEncrypted = TRUE;
    }
    else
    {
        enum enumProvider eProvider;
        if (ShouldEncryptMessage(&SendParams.MsgProps, &eProvider))
        {
            //
            // If we should use a block cypher enlarge the allocated
            // space for the message body, so it will be able to accomodate
            // the encrypted data.
            //

            if (*SendParams.MsgProps.pulEncryptAlg == CALG_RC2)
            {
                //
                // Make more room for RC2 encryption.
                //
                DWORD dwBlockSize;
                hr = MQSec_GetCryptoProvProperty( eProvider,
                                                  eBlockSize,
                                                  NULL,
                                                 &dwBlockSize );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 180);
                }

                SendParams.MsgProps.ulAllocBodyBufferInBytes +=
                                          ((2 * dwBlockSize) - 1);
                SendParams.MsgProps.ulAllocBodyBufferInBytes &= ~(dwBlockSize - 1);
            }

            DWORD dwSymmSize;
            hr = MQSec_GetCryptoProvProperty( eProvider,
                                              eSessionKeySize,
                                              NULL,
                                             &dwSymmSize );
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 190);
            }

            SendParams.MsgProps.ulSymmKeysSize = dwSymmSize;
        }
    }

    //
    //  Call AC driver
    //
    OVERLAPPED ov = {0};
    hr = GetThreadEvent(ov.hEvent);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }



    rc = ACSendMessage(
            hQueue,
            SendParams,
            &ov
            );
    LogHR(rc, s_FN, 298);

    if (rc == MQ_INFORMATION_OPERATION_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ov.hEvent,
                        INFINITE
                        );

        //
        //  BUGBUG: MQSendMessage, must succeed in WaitForSingleObject
        //
        ASSERT(dwResult == WAIT_OBJECT_0);

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

	if (SUCCEEDED(rc))
	{
		//
		// Log to tracing that a message was sent.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			DWORD dwMessageDelivery = (NULL != SendParams.MsgProps.pDelivery) ? *(SendParams.MsgProps.pDelivery) : -1;
			DWORD dwMessageClass = (NULL != SendParams.MsgProps.pAcknowledge) ? *(SendParams.MsgProps.pAcknowledge) : -1;
			WCHAR *wszLabel = L"NO LABEL";							
			DWORD dwLabelLen = wcslen(wszLabel);									
			if (NULL != SendParams.MsgProps.ppTitle && NULL != *(SendParams.MsgProps.ppTitle))
			{													
				wszLabel = *(SendParams.MsgProps.ppTitle);			
				dwLabelLen = SendParams.MsgProps.ulTitleBufferSizeInWCHARs; 
			}														
																	
			WCHAR wszQueueName1[200];
			DWORD dwQueueNameLength = TABLE_SIZE(wszQueueName1) - 1;
			HRESULT hr = MQHandleToFormatName(hQueue, wszQueueName1, &dwQueueNameLength);
			WCHAR *wszQName;
			if (SUCCEEDED(hr))
			{
				wszQName = wszQueueName1;
			}
			else
			{
		    	TrERROR(GENERAL, "Failed in MQHandleToFormatName: %!hresult!", hr);
				wszQName = L"*** Unknown Queue ***";																	
			}
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls    Delivery:0x%x   Class:0x%x   Label:%.*ls", 
				L"Sending message from RT",  
				wszQName,
				dwMessageDelivery,
				dwMessageClass,
				xwcs_t(wszLabel, dwLabelLen));
		}
	}

	delete [] SendParams.AdminMqf;
	delete [] SendParams.ResponseMqf;

    if(FAILED(rc))
    {
        //
        //  ACSendMessage failed (immidiatly or after waiting)
        //
        return LogHR(rc, s_FN, 200);
    }


    if (fSingleTransaction)
    {
		//
        // RPC call to QM for prepare/commit
		//
        rc = pTransaction->Commit(0,0,0);
        if(FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }
    }

	//
	// Bugfix of bug 5588. niraides 18-Jul-2000
	//
    return rc1;

}  // RTpSendMessage


//---------------------------------------------------------
//
//  MQSendMessage(...)
//
//  Description:
//
//      Falcon API.
//      Send a message to a queue
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
    )
{
	if(g_fDependentClient)
		return DepSendMessage(
					hQueue,
					pmp,
					pTransaction
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;

    __try
    {
        rc = RTpSendMessage(hQueue, pmp, pTransaction);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The exception is due to invalid parameter
        //
        rc = GetExceptionCode();
    }

	if(FAILED(rc))
	{
		TrERROR(GENERAL, "Failed to send a message. %!hresult!", rc);
	}

    return rc;
}



//---------------------------------------------------------
//
//  RtpReceiveMessage(...)
//
//  Description:
//
//      Rt Internal - Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

HRESULT
RtpReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction,
    ULONGLONG ullLookupId,
    bool fUseLookupId
    )
{
    CMQHResult rc, rc1;
    XACTUOW Uow;
    HRESULT hr = MQ_OK;

    R<ITransaction> TransactionGenerated;

    rc = MQ_OK;
    rc1 = MQ_OK;

	//
	// Look for Viper transaction if any
	//
	if (pTransaction == MQ_MTS_TRANSACTION)
	{
		hr = GetCurrentViperTransaction(&pTransaction) ;
        if (FAILED(hr))
        {
        	TrERROR(GENERAL, "Failed to get the current Viper transaction. %!hresult!", hr);
			return hr;
        }
	    TransactionGenerated = pTransaction ;
	}
	else if (pTransaction == MQ_XA_TRANSACTION)
	{
		hr = GetCurrentXATransaction(&pTransaction) ;
        if (FAILED(hr))
        {
        	TrERROR(GENERAL, "Failed to get the current XA transaction. %!hresult!", hr);
			return hr;
        }
	    TransactionGenerated = pTransaction ;
	}
	else if (pTransaction == MQ_SINGLE_MESSAGE)
	{
		pTransaction = NULL;
	}

	if ((dwAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
		(dwAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK)
	{
		// PEEK cannot be transacted, but can work with transacted queue
		if (pTransaction != NULL)
		{
			TrERROR(GENERAL, "Error. Peek cannot be transacted.");
			return MQ_ERROR_TRANSACTION_USAGE;
		}
	}

	// Check usage: transaction urges synchronous operation
	if (pTransaction)
	{
		if (lpOverlapped || (fnReceiveCallback!=NULL))  // Transacted Receive is synchronous only
		{
			TrERROR(GENERAL, "Error. Transacted receive must be synchronous.");
			return MQ_ERROR_TRANSACTION_USAGE;
		}
	}

	CACReceiveParameters ReceiveParams;
	ReceiveParams.RequestTimeout = dwTimeout;
	ReceiveParams.Action = dwAction;
	ReceiveParams.Cursor = (hCursor != 0) ? CI2CH(hCursor) : 0;
	ReceiveParams.LookupId = ullLookupId;

	// Enlist QM in the transaction (for the first time);
	// Check that the transaction state is correct
	if (pTransaction)
	{
		// Enlist QM in transaction, if it isn't enlisted already
		hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
		ReceiveParams.MsgProps.pUow = &Uow;

		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to enlist QM in transaction. %!hresult!", hr);
			return hr;
		}
	}

	//
	//  Parse properties
	//
	if(pmp !=0)
	{
		//
		//  Parse message properties, an exception can be raised on access to
		//  pmp fields
		//
		rc1 = RTpParseReceiveMessageProperties(
				ReceiveParams,
				pmp->cProp,
				pmp->aPropID,
				pmp->aPropVar,
				pmp->aStatus);

		if(FAILED(rc1))
		{
			TrERROR(GENERAL, "Failed to parse the message properties. %!hresult!", rc1);
			return rc1;
		}
	}

	OVERLAPPED ov = {0};
	LPOVERLAPPED pov;

	CAutoCallbackDescriptor CallbackDescriptor;

	if (fnReceiveCallback)
	{
		try
		{
			CreateAsyncRxRequest(
				CallbackDescriptor,
				hQueue,
				dwTimeout,
				dwAction,
				pmp,
				lpOverlapped,
				fnReceiveCallback,
				hCursor
				);

			pov = CallbackDescriptor.GetOverlapped();
		}
		catch(const bad_win32_error& err)
		{
			return RTpConvertToMQCode(HRESULT_FROM_WIN32(err.error()));
		}
		catch(const bad_hresult& hr)
		{
			return RTpConvertToMQCode(hr.error());
		}
		catch(const bad_alloc&)
		{
			TrERROR(GENERAL, "Failed to create callback request entry because of low resources.");
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}
		catch(const exception&)
		{
			TrERROR(GENERAL, "An exception was thrown while creating a callback request entry.");
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}
	}
	else if(lpOverlapped != 0)
	{
		//
		//  Asynchronous (event or completion port)
		//
		pov = lpOverlapped;
	}
	else
	{
		//
		//  Synchronous, uses the TLS event
		//
		hr = GetThreadEvent(ov.hEvent);
        if FAILED(hr)
        {
       		TrERROR(GENERAL, "Failed to get thread event. %!hresult!", hr);
            return hr;
        }
		pov = &ov;
	}

	//
	//  Call AC driver
	//
	ReceiveParams.Asynchronous = (pov != &ov);

	if (fUseLookupId)
	{
		ASSERT(ReceiveParams.Cursor == 0);
		ASSERT(ReceiveParams.RequestTimeout == 0);

		rc = ACReceiveMessageByLookupId(
				hQueue,
				ReceiveParams,
				pov
				);
	}
	else
	{
		rc = ACReceiveMessage(
				hQueue,
				ReceiveParams,
				pov
				);
	}

	if(FAILED(rc))
	{
		TrERROR(GENERAL, "Failed to receive message from the driver. %!hresult!", rc);
	}
	if((rc == MQ_INFORMATION_OPERATION_PENDING) && (pov == &ov))
	{
		//
		//  Wait for receive completion
		//
		DWORD dwResult;
		dwResult = WaitForSingleObject(
						ov.hEvent,
						INFINITE
						);

		//
		//  BUGBUG: MQReceiveMessage, must succeed in WaitForSingleObject
		//
		ASSERT(dwResult == WAIT_OBJECT_0);

		rc = DWORD_PTR_TO_DWORD(ov.Internal);
	}

	if(FAILED(rc))
	{
		//
		//  ACReceiveMessage failed (immidiatly or after waiting)
		//
		if (rc == MQ_ERROR_IO_TIMEOUT)
		{
			TrWARNING(GENERAL, "Failed to receive message from the driver, Erorr: MQ_ERROR_IO_TIMEOUT");
		}
		else
		{
			TrERROR(GENERAL, "Failed to receive message from the driver after waiting on an event. %!hresult!", rc);
		}
		return rc;
	}
	else if(fnReceiveCallback)
	{
		CallbackDescriptor.detach();
	}

	if (rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return rc1;
    }

	return rc;
}

//---------------------------------------------------------
//
//  MQReceiveMessage(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	if(g_fDependentClient)
		return DepReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    __try
	{
		return RtpReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction,
					0,
					false
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{		
		HRESULT rc = GetExceptionCode();
		return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 315);
	}
}


//---------------------------------------------------------
//
//  MQReceiveMessageByLookupId(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.using a lookup ID
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN HANDLE hQueue,
    IN ULONGLONG ullLookupId,
    IN DWORD dwLookupAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    )
{
	if(g_fDependentClient)
		return MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS;

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    switch (dwLookupAction)
    {
        case MQ_LOOKUP_PEEK_FIRST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0;
            dwLookupAction = MQ_LOOKUP_PEEK_NEXT;
            break;

        case MQ_LOOKUP_PEEK_LAST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0xFFFFFFFFFFFFFFFFui64;
            dwLookupAction = MQ_LOOKUP_PEEK_PREV;
            break;

        case MQ_LOOKUP_RECEIVE_FIRST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0;
            dwLookupAction = MQ_LOOKUP_RECEIVE_NEXT;
            break;

        case MQ_LOOKUP_RECEIVE_LAST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0xFFFFFFFFFFFFFFFFui64;
            dwLookupAction = MQ_LOOKUP_RECEIVE_PREV;
            break;

        default:
            NULL;
            break;
    }

    __try
	{
		return RtpReceiveMessage(
					hQueue,
					0,
					dwLookupAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					0,
					pTransaction,
					ullLookupId,
					true
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{		
		HRESULT rc = GetExceptionCode();
		return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 316);
	}
}

//---------------------------------------------------------
//
//  MQGetOverlappedResult(...)
//
//  Description:
//
//      Falcon API.
//      Translate and overlapping operation result code.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    )
{
	if(g_fDependentClient)
		return DepGetOverlappedResult(lpOverlapped);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	return LogHR(RTpConvertToMQCode(DWORD_PTR_TO_DWORD(lpOverlapped->Internal)), s_FN, 320);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\property.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    property.cxx

Abstract:



Author:

    Erez Haba (erezh) 2-Jan-96

Revision History:

    RonitH - Queue properties validation.
    BoazF (26-May-96) - Message properties validation.

--*/

#include "stdh.h"
#include <mqtime.h>
#include "rtprpc.h"
#include "authlevel.h"
#include <xml.h>
#include <ad.h>

#include "property.tmh"

#define ONE_KB 1024
#define HRESULT_SEVIRITY(hr) (((hr) >> 30) & 0x3)

static WCHAR *s_FN=L"rt/property";

extern DWORD  g_dwTimeToReachQueueDefault ;

//+----------------------------------------------
//
//  HRESULT  RTpCheckColumnsParameter()
//
//+----------------------------------------------

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns)
{
    HRESULT hr = MQ_OK;

    if (( pColumns == NULL) ||
        ( pColumns->cCol == 0))
    {
        return LogHR(MQ_ERROR_ILLEGAL_MQCOLUMNS, s_FN, 60);
    }

    __try
    {
        PROPID * pPropid = pColumns->aCol;
        for ( DWORD i = 0; i < pColumns->cCol; i++, pPropid++)
        {
            //
            //  make sure that the property id is with-in queue property ids range
            //
            if (((*pPropid) > LAST_Q_PROPID)  || ((*pPropid) <= PROPID_Q_BASE))
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 70);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing column structure");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 90); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 100);
}


static
void
SetStatus(
    HRESULT* pStatusSummary,
    HRESULT* pStatus,
    HRESULT Status
    )
{
    DWORD dwSummarySevirity = HRESULT_SEVIRITY(*pStatusSummary);
    DWORD dwStatusSevirity = HRESULT_SEVIRITY(Status);

    if (dwSummarySevirity < dwStatusSevirity)
    {
        switch(dwStatusSevirity)
        {
        case 1:
            *pStatusSummary = MQ_INFORMATION_PROPERTY;
            break;

        case 2:
            ASSERT(FALSE);
			break;

        case 3:
            *pStatusSummary = MQ_ERROR_PROPERTY;
            break;
        }
    }

    if(pStatus)
    {
        *pStatus = Status;
    }
}


typedef struct {
    PROPID  propId;
    BOOL    fAllow_VT_NULL;
    BOOL    fAllow_VT_EMPTY;
    BOOL    fMustAppear;
    BOOL    fShouldNotAppear;
    BOOL    fPossiblyIgnored;
    HRESULT (* pfValidateProperty)(PROPVARIANT * pVar, PVOID pvContext);
} propValidity;

static
DWORD
CalNumberOfMust(
    IN propValidity * ppropValidity,
    IN DWORD          dwNumberOfProps
    )
{
    DWORD dwNumberOfMust = 0;

    for ( DWORD i =0; i < dwNumberOfProps; i++, ppropValidity++ )
    {
        if (ppropValidity->fMustAppear)
        {
            dwNumberOfMust++;
        }
    }
    return(dwNumberOfMust);
}

static
HRESULT
CheckProps(
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    IN PROPID propidMinPropId,
    IN PROPID propidMaxPropId,
    IN propValidity *ppropValidity,
    IN VARTYPE *vartypePropVts,
    IN BOOL fCheckForIgnoredProps,
    IN DWORD dwNumberOfMustProps,
    IN PVOID pvContext
    )
{
    HRESULT hr = MQ_OK;
    HRESULT dummyStatus;
    BOOL fAdvanceStatusPointer;
    char duplicate[ PROPID_OBJ_GRANULARITY ];
    DWORD index;
    DWORD dwNumberOfMustPropsSupplied = 0;

    memset( duplicate, 0, sizeof(duplicate));

    if ( !pStatus )
    {
        pStatus = &dummyStatus;
        fAdvanceStatusPointer = FALSE;
    }
    else
    {
        fAdvanceStatusPointer = TRUE;
    }

    for ( DWORD i = 0;
          i < cProp;
          i++, pPropid++, pVar++, fAdvanceStatusPointer ? pStatus++ : 0)
    {
        //
        //  Is it a valid propid
        //
        if (((*pPropid) <= propidMinPropId)  || (propidMaxPropId < (*pPropid)))
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        index = (*pPropid) - propidMinPropId;

		if(ppropValidity[index].propId == 0)
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        ASSERT(ppropValidity[index].propId == *pPropid);

        //
        //  Is it a duplicate property
        //
        if ( duplicate[ index ] )
        {
            //
            //  The duplicate property is ignored, and a warning is returned
            //  in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_DUPLICATE_PROPERTY);
            continue;
        }
        duplicate[ index ] = 1;

        //
        //  Is it ok for the user to specify this property
        //
        if ( ppropValidity[index].fShouldNotAppear)
        {
            SetStatus(&hr, pStatus, MQ_ERROR_PROPERTY_NOTALLOWED);
            continue;
        }

        //
        // If an ignored property was supplied then raise a warning.
        //
        if (fCheckForIgnoredProps && (ppropValidity[index].fPossiblyIgnored))
        {
            SetStatus(&hr, pStatus, MQ_INFORMATION_PROPERTY_IGNORED);
            continue;
        }

        //
        // Checking propvariant's vartype.
        //
        if ((pVar->vt != vartypePropVts[index]) &&
            !(ppropValidity[index].fAllow_VT_NULL && pVar->vt == VT_NULL) &&
            !(ppropValidity[index].fAllow_VT_EMPTY && pVar->vt == VT_EMPTY))
        {
            SetStatus(&hr, pStatus, MQ_ERROR_ILLEGAL_PROPERTY_VT);
            continue;
        }

        //
        //  Checking propvariant's value and size
        //
        if ( ppropValidity[index].pfValidateProperty != NULL)
        {
            SetStatus(&hr, pStatus, ppropValidity[index].pfValidateProperty(pVar, pvContext));
        }
        else
        {
            *pStatus = MQ_OK;
        }

        //
        //  Count the number of "must-appear" properties
        //
        if ( (*pStatus == MQ_OK) && ppropValidity[index].fMustAppear )
        {
            dwNumberOfMustPropsSupplied++;
        }
    }

    //
    //  where all the "must appear" properties passed in
    //
    if ( dwNumberOfMustPropsSupplied < dwNumberOfMustProps )
    {
        hr = MQ_ERROR_INSUFFICIENT_PROPERTIES;
    }

    return LogHR(hr, s_FN, 110);
}

static HRESULT qJournalValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_JOURNAL) && ( pVar->bVal != MQ_JOURNAL_NONE))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 120);
    }
    return(MQ_OK);
}


static HRESULT qLabelValidation( PROPVARIANT * pVar, LPVOID )
{
    __try
    {
        if ( wcslen( pVar->pwszVal) > MQ_MAX_Q_LABEL_LEN )
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 130);
        }


    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 140);
    }

    return(MQ_OK);
}


static HRESULT qMulticastValidation( PROPVARIANT * pVar, LPVOID )
{
	if(pVar->vt == VT_EMPTY)
		return MQ_OK;

    if (wcslen( pVar->pwszVal) >= MAX_PATH)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 143);
    }

    MULTICAST_ID id;
    try
    {
        LPCWSTR p = FnParseMulticastString(pVar->pwszVal, &id);
		if(*p != L'\0')
			return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
    catch (const exception&)
    {
        return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }

    return MQ_OK;
}


static HRESULT qAuthValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_AUTHENTICATE_NONE) &&
         (pVar->bVal != MQ_AUTHENTICATE))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 150);
    }
    return(MQ_OK);
}

static HRESULT qPrivLevelValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->ulVal != MQ_PRIV_LEVEL_NONE) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_OPTIONAL) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_BODY))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 160);
    }
    return(MQ_OK);
}

static HRESULT qXactionValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_TRANSACTIONAL_NONE) &&
         (pVar->bVal != MQ_TRANSACTIONAL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 170);
    }
    return(MQ_OK);
}

static HRESULT qTypeValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 180);
    }
    return(MQ_OK);
}

static HRESULT qInstanceValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 190);
    }
    return(MQ_OK);
}

static HRESULT qmMachineIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 200);
    }
    return(MQ_OK);
}

static HRESULT qmSiteIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 210);
    }
    return(MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//
propValidity    QueueCreateValidation[] =
{
    //                                                ust
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,   TRUE,   FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qXactionValidation},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 FALSE,  TRUE,    FALSE,  FALSE,  FALSE,  qMulticastValidation},
    {PROPID_Q_ADS_PATH,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//

propValidity    QueueSetValidation[] =
{
    //                                                Must
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 FALSE,  TRUE,    FALSE,  FALSE,  FALSE,  qMulticastValidation},
    {PROPID_Q_ADS_PATH,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_Q_BASE
//

propValidity    QueueGetValidation[] =
{
    //                                                Must
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   qInstanceValidation},
    {PROPID_Q_TYPE,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qTypeValidation},
    {PROPID_Q_PATHNAME,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_QUOTA,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_CREATE_TIME,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_MODIFY_TIME,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_AUTHENTICATE,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PRIV_LEVEL,    TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_TRANSACTION,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_ADS_PATH,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE QueueVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_LPWSTR,  //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_LPWSTR,  //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_BLOB,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_LPWSTR,  //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_LPWSTR,  //PROPID_Q_NAME_SUFFIX
    VT_LPWSTR,  //PROPID_Q_PATHNAME_DNS
	VT_LPWSTR,	//PROPID_Q_MULTICAST_ADDRESS
    VT_LPWSTR   //PROPID_Q_ADS_PATH
};

VARTYPE GetQueuePropsVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_NULL,    //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_NULL,    //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_NULL,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_NULL,    //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_NULL,    //PROPID_Q_NAME_SUFFIX
    VT_NULL,    //PROPID_Q_PATHNAME_DNS
	VT_NULL,	//PROPID_Q_MULTICAST_ADDRESS
    VT_NULL     //PROPID_Q_ADS_PATH
};

static
void
RemovePropWarnings(
    IN  MQQUEUEPROPS*  pqp,
    IN  HRESULT*       aStatus,
    OUT MQQUEUEPROPS** ppGoodProps,
    OUT char**         ppTmpBuff)
{
    DWORD i;
    DWORD cGoodProps;
    char *pTmpBuff;
    MQQUEUEPROPS *pGoodProps;
    HRESULT *pStatus;
    QUEUEPROPID *pPropId;
    MQPROPVARIANT *pPropVar;

    // See how many good properties do we have.
    for (i = 0, cGoodProps = 0, pStatus = aStatus;
         i < pqp->cProp;
         i++, pStatus++)
    {
        if (*pStatus != MQ_OK)
        {
            ASSERT(!FAILED(*pStatus));
        }
        else
        {
            cGoodProps++;
        }
    }

    // Allocate the temporary buffer, the buffer contains everything in it.
    // It contains the MQQUEUEPROPS structure, the QUEUEPROPID and
    // MQPROPVARIANT arrays.
    pTmpBuff = new char[sizeof(MQQUEUEPROPS) +
                        cGoodProps * sizeof(QUEUEPROPID) +
                        cGoodProps * sizeof(MQPROPVARIANT)];
    *ppTmpBuff = pTmpBuff;

    pGoodProps = (MQQUEUEPROPS*)pTmpBuff;
    *ppGoodProps = pGoodProps;

    //
    // Initialize the MQQUEUEPROPS structure.
    //
    // N.B. To avoid alignment fault the MQPROPVARIANT array is alocated before
    //      The QUEUEPROPID.
    //
    pGoodProps->cProp = cGoodProps;
    pGoodProps->aPropID = (QUEUEPROPID*)(pTmpBuff + sizeof(MQQUEUEPROPS) + cGoodProps * sizeof(MQPROPVARIANT));
    pGoodProps->aPropVar = (MQPROPVARIANT*)(pTmpBuff + sizeof(MQQUEUEPROPS));

    // Copy the array entries of the good properties to the arrays in the
    // temporary buffer.
    for (i = 0, cGoodProps = 0, pStatus = aStatus,
            pPropId = pqp->aPropID, pPropVar = pqp->aPropVar;
         i < pqp->cProp;
         i++, pStatus++, pPropId++, pPropVar++)
    {
        if (*pStatus == MQ_OK)
        {
            pGoodProps->aPropID[cGoodProps] = *pPropId;
            pGoodProps->aPropVar[cGoodProps] = *pPropVar;
            cGoodProps++;
        }
    }
}

static DWORD g_dwNumberOfMustPropsInCreate = 0xffff;
static DWORD g_dwNumberOfMustPropsInSet = 0xffff;

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS*  pqp,
    IN  DWORD          dwOp,
    IN  BOOL           fPrivateQueue,
    OUT MQQUEUEPROPS** ppGoodQP,
    OUT char**         ppTmpBuff
    )
{
    HRESULT hr = MQ_OK;
    propValidity *ppropValidity = 0;
    DWORD dwNumberOfMustProps = 0;
    VARTYPE *QueuePropVars = 0;

    if (!pqp)
    {
        return LogHR(MQ_ERROR_ILLEGAL_MQQUEUEPROPS, s_FN, 220);
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    switch (dwOp)
    {
    case QUEUE_CREATE:
        ppropValidity = QueueCreateValidation;
        if (g_dwNumberOfMustPropsInCreate == 0xffff)
        {
            g_dwNumberOfMustPropsInCreate =
                CalNumberOfMust( QueueCreateValidation,
                                 LAST_Q_PROPID - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInCreate;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_SET_PROPS:
        ppropValidity = QueueSetValidation;
        if (g_dwNumberOfMustPropsInSet == 0xffff)
        {
            g_dwNumberOfMustPropsInSet =
                CalNumberOfMust( QueueSetValidation,
                                 LAST_Q_PROPID - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSet;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_GET_PROPS:
        {
            //
            //  Clear all the pointers of VT_NULL variants
            //  and make the structure ready for RPC call
            //
            for (UINT i = 0; i < pqp->cProp; i++)
            {
                if (pqp->aPropVar[i].vt == VT_NULL)
                {
                    memset(&pqp->aPropVar[i].caub, 0, sizeof(CAUB));
                }
            }
        }

        ppropValidity = QueueGetValidation;
        dwNumberOfMustProps = 0;
        QueuePropVars = GetQueuePropsVarTypes;
        break;

    default:
        ASSERT(0);
        return MQ_ERROR;
    }

    HRESULT *aLocalStatus_buff = NULL;

    __try
    {
        __try
        {
            HRESULT *aLocalStatus;

            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            if (!pqp->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pqp->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pqp->aStatus;
            }

            hr = CheckProps(pqp->cProp,
                            pqp->aPropID,
                            pqp->aPropVar,
                            aLocalStatus,
                            PROPID_Q_BASE,
                            LAST_Q_PROPID,
                            ppropValidity,
                            QueuePropVars,
                            fPrivateQueue,
                            dwNumberOfMustProps,
                            NULL);

            if (SUCCEEDED(hr))
            {
                if (hr != MQ_OK)
                {
                    // We have wornings, copy all the good properties to a temporary
                    // buffer so the DS will not have to handle duplicate properties etc.
                    RemovePropWarnings(pqp, aLocalStatus, ppGoodQP, ppTmpBuff);
                }
                else
                {
                    // All is perfectly well, we do not need a temporary buffer and all
                    // that overhead.
                    *ppGoodQP = pqp;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TrERROR(GENERAL, "Exception while parsing MQQUEUEPROPS structure");
            DWORD dw = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(dw), s_FN, 230); 
            hr = dw;
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }

    return LogHR(hr, s_FN, 240);
}

#define VALIDATION_SEND_FLAG_MASK           1
#define VALIDATION_SECURITY_CONTEXT_MASK    2
#define VALIDATION_RESP_QUEUE_MASK          4
#define VALIDATION_ADMIN_QUEUE_MASK         8
#define VALIDATION_RESP_FORMAT_MASK         16

#define SEND_FLAG ((PVALIDATION_CONTEXT)pvContext)->GetSendFlag()
#define SECURITY_CONTEXT_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)

#define FLAGS (((PVALIDATION_CONTEXT)pvContext)->dwFlags)
#define PMP (((PVALIDATION_CONTEXT)pvContext)->GetMessageProperties())
#define PSENDP (((PVALIDATION_CONTEXT)pvContext)->pSendParams)
#define PRECEIVEP (((PVALIDATION_CONTEXT)pvContext)->pReceiveParams)

#define PSECCTX (((PVALIDATION_CONTEXT)pvContext)->pSecCtx)

class VALIDATION_CONTEXT
{
public:
    VALIDATION_CONTEXT();
    PMQSECURITY_CONTEXT pSecCtx;
    DWORD dwFlags;

    BOOL GetSendFlag()
    {
        return dwFlags & VALIDATION_SEND_FLAG_MASK;
    }

    CACMessageProperties *GetMessageProperties()
    {
        if (GetSendFlag())
        {
            ASSERT(pSendParams);
            return &pSendParams->MsgProps;
        }
        else
        {
            ASSERT(pReceiveParams);
            return &pReceiveParams->MsgProps;
        }
    }

    union
    {
        //
        // Send
        //
        struct
        {
            CACSendParameters *pSendParams;
            CStringsToFree * pResponseStringsToFree;
            CStringsToFree * pAdminStringsToFree;
        };

        //
        // Receive
        //
        CACReceiveParameters *pReceiveParams;
    };

};

typedef VALIDATION_CONTEXT *PVALIDATION_CONTEXT;

VALIDATION_CONTEXT::VALIDATION_CONTEXT() :
    dwFlags(0)
{
}

static HRESULT ParseMsgClass( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        //
        // Check if legal calss
        //
        if(!MQCLASS_IS_VALID(pVar->uiVal))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 250);
        }
    }
    else
    {
        pVar->vt = VT_UI2;
    }
    PMP->pClass = &pVar->uiVal;

    return (MQ_OK);
}

static HRESULT ParseMsgId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_MSGID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 260);
    }

    PMP->ppMessageID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgCorrelationId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_CORRELATIONID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 270);
    }

    PMP->ppCorrelationID = &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgPrio( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal < MQ_MIN_PRIORITY) || (MQ_MAX_PRIORITY < pVar->bVal))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 280);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pPriority = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSentTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pSentTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgVersion( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pulVersion = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgArrivedTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pArrivedTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDelivery( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal != MQMSG_DELIVERY_EXPRESS) &&
            (pVar->bVal != MQMSG_DELIVERY_RECOVERABLE))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 290);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pDelivery = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAck( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if(!MQMSG_ACKNOWLEDGMENT_IS_VALID(pVar->bVal))
        {
            //
            // Unknown ACK bits are on.
            //
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 300);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pAcknowledge = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgJoural( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_JOURNAL_NONE | MQMSG_DEADLETTER | MQMSG_JOURNAL))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 310);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pAuditing = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAppSpec( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PMP->pApplicationTag = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgBody( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppBody = &pVar->caub.pElems;
    PMP->ulBodyBufferSizeInBytes = pVar->caub.cElems;
    PMP->ulAllocBodyBufferInBytes = PMP->ulBodyBufferSizeInBytes;

    return (MQ_OK);
}

static HRESULT ParseMsgBodySize( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pBodySize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelSend( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    if (NULL == pVar->pwszVal)
		return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 329);
    
	DWORD dwSize = wcslen(pVar->pwszVal) +1;
    if ( dwSize > MQ_MAX_MSG_LABEL_LEN)
    {
        return LogHR(MQ_ERROR_LABEL_TOO_LONG, s_FN, 330);
    }

    PMP->ulTitleBufferSizeInWCHARs = dwSize;
    PMP->ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}


static HRESULT ParseMsgLabelReceive( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    PMP->ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulTitleBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static 
HRESULT 
RtpParseMsgFormatNamesSend(
    PROPVARIANT* pVar,
    QUEUE_FORMAT **ppMqf,
    DWORD   *pnQueues,
    CStringsToFree &strsToFree,
    BOOL fSupportMqf
    )
{
    if(NULL == pVar->pwszVal)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 340);
    }
    
	AP<QUEUE_FORMAT> pMqf;
    DWORD nQueues;
	BOOL fSuccess;
    fSuccess = FnMqfToQueueFormats(
                    pVar->pwszVal,
                    pMqf,
                    &nQueues,
                    strsToFree
                    );

    if(!fSuccess)
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 341);
    }

    if (!fSupportMqf && nQueues > 1)
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 345);
    }

    if (!fSupportMqf && (pMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL || pMqf[0].GetType() == QUEUE_FORMAT_TYPE_MULTICAST))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 346);
    }

    for (DWORD i = 0; i < nQueues; i++)
    {
        QUEUE_FORMAT_TYPE qft = pMqf[i].GetType();
        if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
            (pMqf[i].Suffix() != QUEUE_SUFFIX_TYPE_NONE)
           )
        {
            return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 350);
        }
    }

    *ppMqf = pMqf.detach();
    *pnQueues = nQueues;

    return(MQ_OK);
}

static HRESULT ParseMsgRespFormatSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    if (FLAGS & VALIDATION_RESP_QUEUE_MASK)
    {
        //
        // PROPID_M_RESP_QUEUE and PROPID_M_RESP_FORMAT_NAME both exist
        //
        return LogHR(MQ_ERROR_PROPERTIES_CONFLICT, s_FN, 335);
    }

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->ResponseMqf,
                    &PSENDP->nResponseMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    TRUE
                    );

    if FAILED(hr)
    {
        return hr;
    }
 
    FLAGS |= VALIDATION_RESP_FORMAT_MASK;
    return MQ_OK;
}

static HRESULT ParseMsgRespQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    if (FLAGS & VALIDATION_RESP_FORMAT_MASK)
    {
        //
        // PROPID_M_RESP_QUEUE and PROPID_M_RESP_FORMAT_NAME both exist
        //
        return LogHR(MQ_ERROR_PROPERTIES_CONFLICT, s_FN, 800);
    }

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->ResponseMqf,
                    &PSENDP->nResponseMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    FALSE
                    );

    if FAILED(hr)
    {
        return hr;
    }
 
    FLAGS |= VALIDATION_RESP_QUEUE_MASK;
    return MQ_OK;
}

static HRESULT ParseMsgRespQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppResponseFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulResponseFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespFormatReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppResponseMqf = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespFormatLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulResponseMqfLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->AdminMqf,
                    &PSENDP->nAdminMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    FALSE
                    );

    if FAILED(hr)
    {
        return hr;
    }

    FLAGS |= VALIDATION_ADMIN_QUEUE_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgAdminQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppAdminFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulAdminFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppDestFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulDestFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestFormatReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppDestMqf = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestFormatLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulDestMqfLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLookupId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI8;
    PMP->pLookupId = &pVar->uhVal.QuadPart;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppOrderingFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulOrderingFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSrcMachineId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;
    PMP->ppSrcQMID = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgTimeToLive( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        PMP->ulRelativeTimeToLive = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PMP->pulRelativeTimeToLive = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTimeToQueue( PROPVARIANT * pVar, PVOID pvContext )
{
    if(SEND_FLAG)
    {
        PMP->ulAbsoluteTimeToQueue = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PMP->pulRelativeTimeToQueue = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTrace( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_TRACE_NONE | MQMSG_SEND_ROUTE_TO_REPORT_QUEUE))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 375);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pTrace = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKey( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSymmKeys = &pVar->caub.pElems;
    PMP->ulSymmKeysSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKeyLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSymmKeysSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSignature( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSignature = &pVar->caub.pElems;
    PMP->ulSignatureSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSignatureLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSignatureSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderId( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSenderID = &pVar->caub.pElems;
    PMP->uSenderIDLen = (WORD)((pVar->caub.cElems > 0xffff) ? 0xffff : pVar->caub.cElems);

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSenderIDLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->ulVal != MQMSG_SENDERID_TYPE_NONE) &&
            (pVar->ulVal != MQMSG_SENDERID_TYPE_SID))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 380);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulSenderIDType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCert( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSenderCert = &pVar->caub.pElems;
    PMP->ulSenderCertLen = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCertLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSenderCertLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgPrivLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case MQMSG_PRIV_LEVEL_NONE:
        case MQMSG_PRIV_LEVEL_BODY_BASE:
        case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 400);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulPrivLevel = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgEncryptAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case CALG_RC2:
        case CALG_RC4:
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 410);
            break;
        }
    }

    PMP->pulEncryptAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

	
	if((!IS_VALID_AUTH_LEVEL(pVar->ulVal)) ||
	   (IS_AUTH_LEVEL_ALWAYS_BIT(pVar->ulVal) && (pVar->ulVal != MQMSG_AUTH_LEVEL_ALWAYS)))
	{
		//
		// Allow only AUTH_LEVEL_MASK bits to be set
		// and MQMSG_AUTH_LEVEL_ALWAYS bit can not be set with other bits
		//
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 420);
	}

    PMP->ulAuthLevel = pVar->ulVal;

    return MQ_OK;
}

static HRESULT ParseMsgHashAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->pulHashAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthenticated( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PMP->pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PMP->pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want only the m_authenticated property
    //
    *(PMP->pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED ;

    return (MQ_OK);
}

static HRESULT ParseMsgAuthenticatedEx( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PMP->pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PMP->pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want the m_authenticated_ex property
    //
    *(PMP->pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED_EX ;

    return (MQ_OK);
}

static HRESULT ParseMsgExtension( PROPVARIANT * pVar, PVOID pvContext)
{
    PMP->ppMsgExtension = &pVar->caub.pElems;
    PMP->ulMsgExtensionBufferInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgExtensionLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pMsgExtensionSize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSecurityContext( PROPVARIANT *pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    // NULL security context is ignored...
    if (pVar->ulVal == NULL) {
      return LogHR(MQ_INFORMATION_PROPERTY_IGNORED, s_FN, 430);
    }

    PMQSECURITY_CONTEXT pSecCtx;
    try
    {
        pSecCtx = (PMQSECURITY_CONTEXT)
            GET_FROM_CONTEXT_MAP(g_map_RT_SecCtx, pVar->ulVal);
    }
    catch(const exception&)
    {
        return LogHR(MQ_ERROR_BAD_SECURITY_CONTEXT, s_FN, 435);
    }

    if (pSecCtx->dwVersion != SECURITY_CONTEXT_VER)
    {
        return LogHR(MQ_ERROR_BAD_SECURITY_CONTEXT, s_FN, 440);
    }

    PSECCTX = pSecCtx;
    FLAGS |= VALIDATION_SECURITY_CONTEXT_MASK;

    return(MQ_OK);
}

static HRESULT ParseMsgConnectorType( PROPVARIANT * pVar, PVOID pvContext )
{
	if (NULL == pVar->puuid)
	{
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 445);
	}
    PMP->ppConnectorType = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgBodyType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PMP->pulBodyType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulProvType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderName( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_LPWSTR;
    }

    PMP->ppwcsProvName = &pVar->pwszVal;
    return (MQ_OK);
}

static HRESULT ParseMsgProviderNameLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulAuthProvNameLenProp = &pVar->ulVal;
    PMP->ulProvNameLen = pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgFirstInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PMP->pbFirstInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLastInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PMP->pbLastInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    if (pVar->caub.cElems != PROPID_M_XACTID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 450);
    }

    PMP->ppXactID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}
  
static HRESULT ParseMsgEnvelopeReceive(PROPVARIANT * pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PMP->ppSrmpEnvelope = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgEnvelopeLenReceive(PROPVARIANT * pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pSrmpEnvelopeBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseCompoundMessageReceive(PROPVARIANT *pVar, PVOID pvContext)
{
    PMP->ppCompoundMessage = &pVar->caub.pElems;
    PMP->CompoundMessageSizeInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseCompoundMessageSizeReceive(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pCompoundMessageSizeInBytes = &pVar->ulVal;

    return (MQ_OK);
}


static HRESULT ValidateXmlFormat(LPCWSTR pStr)
{
    CAutoXmlNode pTree;
    try
    {
       int len  = wcslen(pStr);
       XmlParseDocument(xwcs_t(pStr, len), &pTree);
       return MQ_OK;
    }
    catch(const bad_document& )
    {
        return MQ_ERROR_BAD_XML_FORMAT;
    }
}


static HRESULT ParseSoapHeader(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);
    HRESULT hr = ValidateXmlFormat(pVar->pwszVal);
    if(FAILED(hr))
        return LogHR(hr, s_FN, 455);
    
    PSENDP->ppSoapHeader = &pVar->pwszVal;
    return MQ_OK;

}


static HRESULT ParseSoapBody(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);
   
    PSENDP->ppSoapBody = &pVar->pwszVal;
    return MQ_OK;

}


//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageSendValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier               VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LABEL,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelSend},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TIME_TO_REACH_QUEUE,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueSend},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueSend},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_VERSION,         FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID_TYPE,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthLevel},
    { PROPID_M_AUTHENTICATED,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_HASH_ALG,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENTTIME,        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ARRIVEDTIME,     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_M_SECURITY_CONTEXT,FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSecurityContext},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},

    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TRACE,                  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_PROV_TYPE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_FIRST_IN_XACT,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LAST_IN_XACT,           FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACTID,                 FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED_EX,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_RESP_FORMAT_NAME,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatSend},
    { PROPID_M_RESP_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { PROPID_M_DEST_FORMAT_NAME,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LOOKUPID,               FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SOAP_ENVELOPE,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_SOAP_ENVELOPE_LEN,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_COMPOUND_MESSAGE,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_COMPOUND_MESSAGE_SIZE,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_SOAP_HEADER,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseSoapHeader}, 
    { PROPID_M_SOAP_BODY,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseSoapBody},

};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageReceiveValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier               VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodySize},
    { PROPID_M_LABEL,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelReceive},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelLen},
    { PROPID_M_TIME_TO_REACH_QUEUE,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueReceive},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueLen},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueReceive},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueLen},
    { PROPID_M_VERSION,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgVersion},
    { PROPID_M_SENDERID,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdLen},
    { PROPID_M_SENDERID_TYPE,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticated},
    { PROPID_M_HASH_ALG,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCertLen},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSrcMachineId},
    { PROPID_M_SENTTIME,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSentTime},
    { PROPID_M_ARRIVEDTIME,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgArrivedTime},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestQueueReceive},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestQueueLen},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtensionLen},
    { PROPID_M_SECURITY_CONTEXT,TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueReceive},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueLen},
    { PROPID_M_TRACE,                  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKeyLen},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignatureLen},
    { PROPID_M_PROV_TYPE,              TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderNameLen},
    { PROPID_M_FIRST_IN_XACT,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgFirstInXact},
    { PROPID_M_LAST_IN_XACT,           TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLastInXact},
    { PROPID_M_XACTID,                 TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactId},
    { PROPID_M_AUTHENTICATED_EX,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticatedEx},
    { PROPID_M_RESP_FORMAT_NAME,	   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatReceive},
    { PROPID_M_RESP_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatLen},
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { PROPID_M_DEST_FORMAT_NAME,	   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestFormatReceive},
    { PROPID_M_DEST_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestFormatLen},
    { PROPID_M_LOOKUPID,               TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLookupId},
    { PROPID_M_SOAP_ENVELOPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEnvelopeReceive},
    { PROPID_M_SOAP_ENVELOPE_LEN,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEnvelopeLenReceive},
    { PROPID_M_COMPOUND_MESSAGE,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseCompoundMessageReceive},
    { PROPID_M_COMPOUND_MESSAGE_SIZE,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseCompoundMessageSizeReceive},
    { PROPID_M_SOAP_HEADER,            TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL}, 
    { PROPID_M_SOAP_BODY,              TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
};


VARTYPE MessageVarTypes[] =
{
    0,
    VT_UI2,                 //PROPID_M_CLASS
    VT_VECTOR | VT_UI1,     //PROPID_M_MSGID
    VT_VECTOR | VT_UI1,     //PROPID_M_CORRELATIONID
    VT_UI1,                 //PROPID_M_PRIORITY
    VT_UI1,                 //PROPID_M_DELIVERY
    VT_UI1,                 //PROPID_M_ACKNOWLEDGE
    VT_UI1,                 //PROPID_M_JOURNAL
    VT_UI4,                 //PROPID_M_APPSPECIFIC
    VT_VECTOR | VT_UI1,     //PROPID_M_BODY
    VT_UI4,                 //PROPID_M_BODY_SIZE
    VT_LPWSTR,              //PROPID_M_LABEL
    VT_UI4,                 //PROPID_M_LABEL_LEN  // BUGBUG not implemented yet
    VT_UI4,                 //PROPID_M_TIME_TO_REACH_QUEUE
    VT_UI4,                 //PROPID_M_TIME_TO_BE_RECEIVED
    VT_LPWSTR,              //PROPID_M_RESP_QUEUE
    VT_UI4,                 //PROPID_M_RESP_QUEUE_LEN
    VT_LPWSTR,              //PROPID_M_ADMIN_QUEUE
    VT_UI4,                 //PROPID_M_ADMIN_QUEUE_LEN
    VT_UI4,                 //PROPID_M_VERSION
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDERID
    VT_UI4,                 //PROPID_M_SENDERID_LEN
    VT_UI4,                 //PROPID_M_SENDERID_TYPE
    VT_UI4,                 //PROPID_M_PRIV_LEVEL
    VT_UI4,                 //PROPID_M_AUTH_LEVEL
    VT_UI1,                 //PROPID_M_AUTHENTICATED
    VT_UI4,                 //PROPID_M_HASH_ALG
    VT_UI4,                 //PROPID_M_ENCRYPTION_ALG
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDER_CERT
    VT_UI4,                 //PROPID_M_SENDER_CERT_LEN
    VT_CLSID,               //PROPID_M_SRC_MACHINE_ID
    VT_UI4,                 //PROPID_M_SENTTIME
    VT_UI4,                 //PROPID_M_ARRIVEDTIME
    VT_LPWSTR,              //PROPID_M_DEST_QUEUE
    VT_UI4,                 //PROPID_M_DEST_QUEUE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_EXTENSION
    VT_UI4,                 //PROPID_M_EXTENSION_LEN
    VT_UI4,                 //PROPID_M_SECURITY_CONTEXT
    VT_CLSID,               //PROPID_M_CONNECTOR_TYPE
    VT_LPWSTR,              //PROPID_M_XACT_STATUS_QUEUE
    VT_UI4,                 //PROPID_M_XACT_STATUS_QUEUE_LEN
    VT_UI1,                 //PROPID_M_TRACE
    VT_UI4,                 //PROPID_M_BODY_TYPE
    VT_VECTOR | VT_UI1,     //PROPID_M_DEST_SYMM_KEY
    VT_UI4,                 //PROPID_M_DEST_SYMM_KEY_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_SIGNATURE
    VT_UI4,                 //PROPID_M_SIGNATURE_LEN
    VT_UI4,                 //PROPID_M_PROV_TYPE
    VT_LPWSTR,              //PROPID_M_PROV_NAME
    VT_UI4,                 //PROPID_M_PROV_NAME_LEN
    VT_UI1,                 //PROPID_M_FIRST_IN_XACT
    VT_UI1,                 //PROPID_M_LAST_IN_XACT
    VT_UI1|VT_VECTOR,       //PROPID_M_XACTID
    VT_UI1,                 //PROPID_M_AUTHENTICATED_EX
    VT_LPWSTR,              //PROPID_M_RESP_FORMAT_NAME.
    VT_UI4,                 //PROPID_M_RESP_FORMAT_NAME_LEN
	0,						//Place holder for future property
	0,						//Place holder for future property
    VT_LPWSTR,              //PROPID_M_DEST_FORMAT_NAME
    VT_UI4,                 //PROPID_M_DEST_FORMAT_NAME_LEN
    VT_UI8,                 //PROPID_M_LOOKUPID
    VT_LPWSTR,              //PROPID_M_SOAP_ENVELOPE
    VT_UI4,                 //PROPID_M_SOAP_ENVELOPE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_COMPOUND_MESSAGE
    VT_UI4,                 //PROPID_M_COMPOUND_MESSAGE_SIZE
    VT_LPWSTR,              //PROPID_M_SOAP_HEADER 
    VT_LPWSTR,              //PROPID_M_SOAP_BODY 
};

#ifdef _DEBUG
//
// the following are complie time asserts, to verify the arrays size are
// correct and arrays include all properties.
//
#define _EXPECTEDSIZE  (LAST_M_PROPID - PROPID_M_BASE + 1)
#define _SENDSIZE  (sizeof(MessageSendValidation) / sizeof(propValidity))
#define _RCVSIZE   (sizeof(MessageReceiveValidation) / sizeof(propValidity))
#define _VARSIZE   (sizeof(MessageVarTypes) / sizeof(VARTYPE))
static int MyAssert1[ _SENDSIZE == _EXPECTEDSIZE ] ;
static int MyAssert2[ _RCVSIZE  == _EXPECTEDSIZE ] ;
static int MyAssert3[ _VARSIZE  == _EXPECTEDSIZE ] ;
#undef _SENDSIZE
#undef _EXPECTEDSIZE
#undef _RCVSIZE
#undef _VARSIZE

#endif // _DEBUG

static DWORD g_dwNumberOfMustPropsInSend = 0xffff;
static DWORD g_dwNumberOfMustPropsInReceive = 0xffff;

HRESULT
RTpParseSendMessageProperties(
    CACSendParameters &SendParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    CStringsToFree &ResponseStringsToFree,
    CStringsToFree &AdminStringsToFree
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;

    *ppSecCtx = NULL;

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = VALIDATION_SEND_FLAG_MASK;
    ValidationContext.pResponseStringsToFree = &ResponseStringsToFree;
    ValidationContext.pAdminStringsToFree = &AdminStringsToFree;
    ValidationContext.pSendParams = &SendParams;

    ppropValidity = MessageSendValidation;
    if (g_dwNumberOfMustPropsInSend == 0xffff)
    {
        g_dwNumberOfMustPropsInSend =
            CalNumberOfMust( MessageSendValidation,
                             LAST_M_PROPID - PROPID_M_BASE + 1);
    }
    dwNumberOfMustProps = g_dwNumberOfMustPropsInSend;

    CACMessageProperties *pmp = &SendParams.MsgProps;

    pmp->ulRelativeTimeToLive  = INFINITE ;
    pmp->ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;

    if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 460);
    }

    hr = CheckProps(cProp,
                    pPropid,
                    pVar,
                    pStatus,
                    PROPID_M_BASE,
                    LAST_M_PROPID,
                    ppropValidity,
                    MessageVarTypes,
                    TRUE,
                    dwNumberOfMustProps,
                    &ValidationContext);

    if (SUCCEEDED(hr))
    {
        //
        // Special handling for class. If the calss is specified on send the
        // Connector type property is mandatory.
        //
        if ((pmp->pClass ||  pmp->ppSenderID || pmp->ppSymmKeys || pmp->ppSignature || pmp->ppwcsProvName) &&
            !pmp->ppConnectorType)
        {
            return LogHR(MQ_ERROR_MISSING_CONNECTOR_TYPE, s_FN, 470);
        }

        if ((pmp->ppwcsProvName && !pmp->pulProvType) ||
            (!pmp->ppwcsProvName && pmp->pulProvType))
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 480);
        }
        //
        // If TimeToQueue is greater then TimeToLive then decrement
        // it to equal TimeToLive.
        //
        if ((pmp->ulAbsoluteTimeToQueue == INFINITE) ||
           (pmp->ulAbsoluteTimeToQueue == LONG_LIVED))
        {
          pmp->ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
        }

        if (pmp->ulRelativeTimeToLive != INFINITE)
        {
          if (pmp->ulAbsoluteTimeToQueue > pmp->ulRelativeTimeToLive)
          {
             pmp->ulAbsoluteTimeToQueue = pmp->ulRelativeTimeToLive ;
             pmp->ulRelativeTimeToLive = 0 ;
          }
          else
          {
             pmp->ulRelativeTimeToLive -= pmp->ulAbsoluteTimeToQueue ;
          }
        }

        //
        // Conver TimeToQueue, which was relative until now,
        // to absolute
        //
        ULONG utime = MqSysTime() ;
        if (utime > (pmp->ulAbsoluteTimeToQueue + utime))
        {
          //
          // overflow. timeout too long.
          //
          ASSERT(INFINITE == 0xffffffff) ;
          ASSERT(LONG_LIVED == 0xfffffffe) ;

          pmp->ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
        }
        else
        {
		  pmp->ulAbsoluteTimeToQueue += utime ;
        }

	
		//
		// make sure that trq or tbr(ulRelativeTimeToLive  + ulAbsoluteTimeToQueue)
		// is not more then LONG_MAX. It cause crt time api's to fail.
		//
		if( pmp->ulAbsoluteTimeToQueue  > LONG_MAX)
		{
			pmp->ulAbsoluteTimeToQueue =  LONG_MAX;
			pmp->ulRelativeTimeToLive = 0;
		}	
	 	else
		if(pmp->ulRelativeTimeToLive  + pmp->ulAbsoluteTimeToQueue > LONG_MAX)
		{
			pmp->ulRelativeTimeToLive =  LONG_MAX -  pmp->ulAbsoluteTimeToQueue;
		}




        if (ValidationContext.dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)
        {
          *ppSecCtx = ValidationContext.pSecCtx;
        }

        if (! (ValidationContext.dwFlags & (VALIDATION_RESP_FORMAT_MASK | VALIDATION_RESP_QUEUE_MASK)))
        {
           SendParams.ResponseMqf = 0;
           SendParams.nResponseMqf = 0;
        }
        if (! (ValidationContext.dwFlags & VALIDATION_ADMIN_QUEUE_MASK))
        {
           SendParams.AdminMqf = 0;
           SendParams.nAdminMqf = 0;
        }
    }

    return LogHR(hr, s_FN, 726);
}



HRESULT
RTpParseReceiveMessageProperties(
    CACReceiveParameters &ReceiveParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = 0;
    ValidationContext.pReceiveParams = &ReceiveParams;

    ppropValidity = MessageReceiveValidation;
    if (g_dwNumberOfMustPropsInReceive == 0xffff)
    {
        g_dwNumberOfMustPropsInReceive =
            CalNumberOfMust( MessageReceiveValidation,
                             LAST_M_PROPID - PROPID_M_BASE + 1);
    }
    dwNumberOfMustProps = g_dwNumberOfMustPropsInReceive;


    __try
    {
        if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
        {
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 760);
        }

        hr = CheckProps(cProp,
                        pPropid,
                        pVar,
                        pStatus,
                        PROPID_M_BASE,
                        LAST_M_PROPID,
                        ppropValidity,
                        MessageVarTypes,
                        TRUE,
                        dwNumberOfMustProps,
                        &ValidationContext);

        if (SUCCEEDED(hr))
        {
            CACMessageProperties *pmp = &ReceiveParams.MsgProps;

            if(ReceiveParams.ppResponseFormatName)
            {
                if(!ReceiveParams.pulResponseFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 490);
                }
            }

            if(ReceiveParams.ppAdminFormatName)
            {
                if(!ReceiveParams.pulAdminFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 500);
                }
            }

            if(ReceiveParams.ppDestFormatName)
            {
                if(!ReceiveParams.pulDestFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 510);
                }
            }

            if(ReceiveParams.ppOrderingFormatName)
            {
                if(!ReceiveParams.pulOrderingFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 719);
                }
            }

            if(ReceiveParams.ppDestMqf)
            {
                if(!ReceiveParams.pulDestMqfLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 721);
                }
            }

            if(ReceiveParams.ppResponseMqf)
            {
                if(!ReceiveParams.pulResponseMqfLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 723);
                }
            }

            if(pmp->ppTitle)
            {
                if(!pmp->pulTitleBufferSizeInWCHARs)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 530);
                }
            }

            if(pmp->ppSrmpEnvelope)
            {
                if(!pmp->pSrmpEnvelopeBufferSizeInWCHARs)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 724);
                }
            }

            //
            // in case the provider name is required, the provider name
            // len property is a must.
            //
            if (pmp->ppwcsProvName)
            {
                if (!pmp->pulAuthProvNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 540);
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing message properties.");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 550); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 560);
}
//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_QM_BASE
//

propValidity    GetQMValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_SITE_ID,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qmSiteIdValidation},
    { PROPID_QM_MACHINE_ID,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qmMachineIdValidation},
    { PROPID_QM_PATHNAME,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_CONNECTION,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_ENCRYPTION_PK,  TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ADDRESS,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CNS,            TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS,         TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MASTERID,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_HASHKEY,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SEQNUM,         TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_QUOTA,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_JOURNAL_QUOTA,  TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MACHINE_TYPE,   TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CREATE_TIME,    TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MODIFY_TIME,    TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FOREIGN,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OS,             TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FULL_PATH,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SITE_IDS,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS_DN,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS_DN,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_NT4ID,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_DONOTHING,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},

    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------

    { PROPID_QM_SERVICE_ROUTING,        TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DSSERVER,       TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DEPCLIENTS,     TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OLDSERVICE,             TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_BASE,     TRUE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_ENHANCED, TRUE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_PATHNAME_DNS,           TRUE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE GetQMVarTypes[] =
{
    0,
    VT_CLSID,               //PROPID_QM_SITE_ID
    VT_CLSID,               //PROPID_QM_MACHINE_ID
    VT_NULL,                //PROPID_QM_PATHNAME
    VT_NULL,                //PROPID_QM_CONNECTION
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK
    VT_BLOB,                //PROPID_QM_ADDRESS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_CNS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_OUTFRS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_INFRS
    VT_UI4,                 //PROPID_QM_SERVICE
    VT_CLSID,               //PROPID_QM_MASTERID
    VT_UI4,                 //PROPID_QM_HASHKEY
    VT_BLOB,                //PROPID_QM_SEQNUM
    VT_UI4,                 //PROPID_QM_QUOTA
    VT_UI4,                 //PROPID_QM_JOURNAL_QUOTA
    VT_LPWSTR,              //PROPID_QM_MACHINE_TYPE
    VT_I4,                  //PROPID_QM_CREATE_TIME
    VT_I4,                  //PROPID_QM_MODIFY_TIME
    VT_UI1,                 //PROPID_QM_FOREIGN
    VT_UI4,                 //PROPID_QM_OS
    VT_LPWSTR,              //PROPID_QM_FULL_PATH
    VT_CLSID|VT_VECTOR,     //PROPID_QM_SITE_IDS
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_OUTFRS_DN
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_INFRS_DN
    VT_CLSID,               //PROPID_QM_NT4ID
    VT_UI1,                 //PROPID_QM_DONOTHING
    VT_UI1,                 //PROPID_QM_SERVICE_ROUTING
    VT_UI1,                 //PROPID_QM_SERVICE_DSSERVER
    VT_UI1,                 //PROPID_QM_SERVICE_DEPCLIENTS
    VT_UI4,                 //PROPID_QM_OLDSERVICE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_BASE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_ENHANCED
    VT_NULL                 //PROPID_QM_PATHNAME_DNS
};


HRESULT
RTpCheckQMProps(
    IN      MQQMPROPS * pQMProps,
    IN OUT  HRESULT*    aStatus,
    OUT     MQQMPROPS** ppGoodQMP,
    OUT     char**      ppTmpBuff)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pQMProps == NULL) ||
             (pQMProps->cProp == 0))
        {
            return LogHR(MQ_ERROR_ILLEGAL_MQQMPROPS, s_FN, 570);
        }

        hr = CheckProps(pQMProps->cProp,
                        pQMProps->aPropID,
                        pQMProps->aPropVar,
                        aStatus,
                        PROPID_QM_BASE,
                        LAST_QM_PROPID,
                        GetQMValidation,
                        GetQMVarTypes,
                        TRUE,
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing MQQMPROPS structure");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 580); 
        hr = dw;
    }

    if (SUCCEEDED(hr))
    {
        if (hr != MQ_OK)
        {
            // We have wornings, copy all the good properties to a temporary
            // buffer so the DS will not have to handle duplicate properties etc.
            RemovePropWarnings(
                (MQQUEUEPROPS*)pQMProps,
                aStatus,
                (MQQUEUEPROPS**)ppGoodQMP,
                ppTmpBuff);
        }
        else
        {
            // All is perfectly well, we do not need a temporary buffer and all
            // that overhead.
            *ppGoodQMP = pQMProps;
        }
    }

    return LogHR(hr, s_FN, 590);

}


HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction)
{
    HRESULT hr = MQ_OK;

    if ( pRestriction == NULL)
    {
        return(MQ_OK);
    }

    __try
    {

        MQPROPERTYRESTRICTION * pPropRestriction = pRestriction->paPropRes;
        for ( DWORD i = 0; i < pRestriction->cRes; i++, pPropRestriction++)
        {
            if (( pPropRestriction->prop > LAST_Q_PROPID) || ( pPropRestriction->prop <= PROPID_Q_BASE ))
            {
                return LogHR(MQ_ERROR_ILLEGAL_RESTRICTION_PROPID, s_FN, 600);
            }
            switch ( pPropRestriction->prop)
            {
                case PROPID_Q_LABEL:
                    hr = qLabelValidation( &pPropRestriction->prval, NULL);
                    break;
                case PROPID_Q_PATHNAME:
                case PROPID_Q_ADS_PATH:
                    //
                    //  Multiple column props, not supported in restriction
                    //
                    hr =  MQ_ERROR_ILLEGAL_RESTRICTION_PROPID;
                    break;
                default:
                    break;
            }
            if (FAILED(hr))
            {
                break;
            }

            //
            // SP4- bug# 3009, SP4SS: exception on server when call MQlocatebegin
            // Fix: validate Restriction VT.
            //                      Uri Habusha, 17-Jun-98
			//
			// Enable prop vt = VT_EMPTY if Allowed VT_EMPTY by set
			// This is the case for PROPID_Q_MULTICAST_ADDRESS
			// Its enable the restriction PROPID_Q_MULTICAST_ADDRESS with vt = VT_EMPTY
			// Ilan Herbst, 15-Nov-2000
			//
            DWORD Index = pPropRestriction->prop - PROPID_Q_BASE;
            if ((pPropRestriction->prval.vt != QueueVarTypes[Index]) &&
				!((pPropRestriction->prval.vt == VT_EMPTY) && 
				  (QueueSetValidation[Index].fAllow_VT_EMPTY == TRUE))) 
            {
                hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
                break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing restriction structure");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 610); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 620);
}

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
	)
{
    HRESULT hr = MQ_OK;

    if ( pSort == NULL)
    {
        return(MQ_OK);
    }

	if((ADGetEnterprise() == eAD) && (pSort->cCol > 1))
	{
		//
		// Multiple MQSORTKEY is not supported.
		// Active Directory supports only a single sort key
		//
		return LogHR(MQ_ERROR_MULTI_SORT_KEYS, s_FN, 625);
	}

    __try
    {

        MQSORTKEY * pSortKey = pSort->aCol;
        for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
        {
            if (( pSortKey->propColumn > LAST_Q_PROPID) || ( pSortKey->propColumn <= PROPID_Q_BASE ))
            {
                return LogHR(MQ_ERROR_ILLEGAL_SORT_PROPID, s_FN, 630);
            }
            switch ( pSortKey->propColumn)
            {
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in sort
                    //
                    return LogHR(MQ_ERROR_ILLEGAL_SORT_PROPID, s_FN, 640);
                    break;
                default:
                    break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing sort structure");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 650); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 660);
}

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	)
{
	//
	//	validate that the aPropVar buffer supplied by the
	//	user match the size it had specified
	//
	HRESULT hr = MQ_OK;
    __try
    {
        if(IsBadWritePtr(aPropVar, cPropsRead * sizeof(PROPVARIANT)))
        {
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 670);
        }
	}
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while Locate Next parameters.");
        hr = MQ_ERROR_INVALID_PARAMETER;
        LogHR(hr, s_FN, 680);
    }
	return LogHR(hr, s_FN, 690);

}

//
//  The offset of property in this array must be equal to
//  PROPID value - starting with  FIRST_PRIVATE_COMPUTER_PROPID
//

propValidity    GetPrivateComputerValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_PC_VERSION,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_PC_DS_ENABLED,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
};

VARTYPE GetPrivateComputerVarTypes[] =
{
    0,
    VT_UI4,                 //PROPID_PC_VERSION
    VT_BOOL,                //PROPID_PC_DS_ENABLED
};


//---------------------------------------------------------
//
//  RTpCheckComputerProps(...)
//
//  Description:
//
//  validates pLocalProps parameter values
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pPrivateProps == NULL) ||
             (pPrivateProps->cProp == 0))
        {
            return LogHR(MQ_ERROR_ILLEGAL_MQPRIVATEPROPS, s_FN, 700);
        }

        hr = CheckProps(pPrivateProps->cProp,
                        pPrivateProps->aPropID,
                        pPrivateProps->aPropVar,
                        aStatus,
                        FIRST_PRIVATE_COMPUTER_PROPID,
                        LAST_PRIVATE_COMPUTER_PROPID,
                        GetPrivateComputerValidation,
                        GetPrivateComputerVarTypes,
                        TRUE,	// fCheckForIgnoredProps
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing MQPRIVATEPROPS structure");
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 710); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 720);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\qmrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qmrt.cpp

Abstract:



Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

--*/

#include "stdh.h"
#include "rtprpc.h"
#include "_registr.h"
#include "acdef.h"

#include "qmrt.tmh"

static WCHAR *s_FN=L"rt/qmrt";

static
void
GetSecurityDescriptorSize(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpdwSecurityDescriptorSize)
{
    if (pSecurityDescriptor)
    {
        ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));
        *lpdwSecurityDescriptorSize = GetSecurityDescriptorLength(pSecurityDescriptor);
    }
    else
    {
        *lpdwSecurityDescriptorSize = 0;
    }
}

HRESULT
RtpCreateObject(
    /* in */ DWORD dwObjectType,
    /* in */ LPCWSTR lpwcsPathName,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in */ DWORD cp,
    /* in */ PROPID aProp[],
    /* in */ PROPVARIANT apVar[])
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = R_QMCreateObjectInternal(tls_hBindRpc,
                                  dwObjectType,
                                  lpwcsPathName,
                                  dwSecurityDescriptorSize,
                                  (unsigned char *)pSecurityDescriptor,
                                  cp,
                                  aProp,
                                  apVar);

    if(FAILED(hr))
    {
    	if(hr == MQ_ERROR_QUEUE_EXISTS)
    	{
    		TrWARNING(LOG, "Failed to create %ls. The queue already exists.", lpwcsPathName);
    	}
    	else
    	{
    		TrERROR(LOG, "Failed to create %ls. hr = %!hresult!", lpwcsPathName, hr);
    	}
    }

    return hr;
}

HRESULT
RtpCreateDSObject(
    /* in  */ DWORD dwObjectType,
    /* in  */ LPCWSTR lpwcsPathName,
    /* in  */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in  */ DWORD cp,
    /* in  */ PROPID aProp[],
    /* in  */ PROPVARIANT apVar[],
    /* out */ GUID* pObjGuid
    )
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = R_QMCreateDSObjectInternal( tls_hBindRpc,
                                           dwObjectType,
                                           lpwcsPathName,
                                           dwSecurityDescriptorSize,
                                   (unsigned char *)pSecurityDescriptor,
                                           cp,
                                           aProp,
                                           apVar,
                                           pObjGuid );
    return LogHR(hr, s_FN, 20);
}

HRESULT
RtpSetObjectSecurity(
    /* in */ OBJECT_FORMAT* pObjectFormat,
    /* in */ SECURITY_INFORMATION SecurityInformation,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = R_QMSetObjectSecurityInternal(tls_hBindRpc,
                                       pObjectFormat,
                                       SecurityInformation,
                                       dwSecurityDescriptorSize,
                                       (unsigned char *)pSecurityDescriptor);
    return LogHR(hr, s_FN, 30);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\queue.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    This module contains code involved with Queue APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include <ad.h>
#include "rtprpc.h"
#include "rtsecutl.h"
#include <mqdsdef.h>
#include <rtdep.h>
#include <tr.h>
#include "rtputl.h"

#include "queue.tmh"

static WCHAR *s_FN=L"rt/queue";

#define MQ_VALID_ACCESS (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS | MQ_SEND_ACCESS | MQ_ADMIN_ACCESS)

//
// Data needed for licensing
//
extern GUID   g_QMId ;
extern DWORD  g_dwOperatingSystem;

extern BOOL	  g_fOnFailureCallServiceToCreatePublicQueue;

inline
BOOL
IsLegalDirectFormatNameOperation(
    const QUEUE_FORMAT* pQueueFormat
    )
//
// Function Description:
//      The routines checks if the queue operation is leggal with
//      the direct format name. Due "Workgroup" support, we allowed
//      direct format name for local private queue.
//
// Arguments:
//      pQueueFormat - pointer to format name object
//
// Returned value:
//      TRUE if the format name is valid, FALSE otherwise
//
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    if (pQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
        return FALSE;

	//
	// The APIs that call this function don't support HTTP format name.
	// Thus the HTTP and HTTPS types are not valid.
	//
	DirectQueueType dqt;
	FnParseDirectQueueType(pQueueFormat->DirectID(), &dqt);

	if(dqt == dtHTTP || dqt == dtHTTPS)
		return FALSE;

    //
    // check that the direct format name is for private queue. Queue
    // locallity will be checked by the QM
    //
    LPWSTR pTemp = wcschr(pQueueFormat->DirectID(), L'\\');
    ASSERT(pTemp != NULL);
    if(pTemp == NULL)
    	return FALSE;

    return (_wcsnicmp(pTemp+1,
                      PRIVATE_QUEUE_PATH_INDICATIOR,
                      PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0);
}


//
//  This function is called whenever really path name is needed.
//
//  It appears in the path of the following functions only:
//  MQDeleteQueue, MQSetQueueProperties, MQGetQueueProperties
//  MQGetQueueSecurity, MQSetQueueSecurity
//
inline BOOL IsLegalFormatNameOperation(const QUEUE_FORMAT* pQueueFormat)
{
    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_DIRECT:
            return IsLegalDirectFormatNameOperation(pQueueFormat);

        default:
            return FALSE;
    }
}

HRESULT
RtpOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT DWORD* phQueue
    )
{
    *phQueue = NULL ;
    //
    // Check validity of access mode.
    // 1. Check that only legal bits are turned on.
    // 2. Check that only legal access combinations are used.
    //
    if ((dwDesiredAccess & ~MQ_VALID_ACCESS) ||
        !(dwDesiredAccess & MQ_VALID_ACCESS))

    {
       //
       // Ilegal bits are turned on.
       //
       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
    }
    else if (dwDesiredAccess != MQ_SEND_ACCESS)
    {
       if (dwDesiredAccess & MQ_SEND_ACCESS)
       {
          //
          // A queue can't be open for both send and receive.
          //
          return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
       }
    }

   if ((dwShareMode & MQ_DENY_RECEIVE_SHARE) &&
       (dwDesiredAccess & MQ_SEND_ACCESS))
   {
       //
       // not supporting SEND_ACCESS with DENY_RECEIVE.
       //
       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
    }

	if (dwDesiredAccess & MQ_SEND_ACCESS)
    {
       if (!g_pSecCntx)
       {
          InitSecurityContext();
       }
    }

    AP<QUEUE_FORMAT> pMqf;
    DWORD        nMqf;
    CStringsToFree StringsToFree;
    if (!FnMqfToQueueFormats(
            lpwcsFormatName,
            pMqf,
            &nMqf,
            StringsToFree
            ))
    {
        LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 40);
        return MQ_ERROR_ILLEGAL_FORMATNAME;
    }

    ASSERT(nMqf > 0);

    //
    // Multiple queues or DL can be opened for send only
    //
    if ((dwDesiredAccess & MQ_SEND_ACCESS) == 0)
    {
        if (nMqf > 1 ||
            pMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
        {
            LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 45);
            return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
        }
    }

    ASSERT(tls_hBindRpc);
    CMQHResult rc;
    rc = R_QMOpenQueue(
            tls_hBindRpc,
            nMqf,
            pMqf,
            GetCurrentProcessId(),
            dwDesiredAccess,
            dwShareMode,
            phQueue
            );

    return rc;
}

EXTERN_C
HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    )
{
	if(g_fDependentClient)
		return DepOpenQueue(
					lpwcsFormatName,
					dwDesiredAccess,
					dwShareMode,
					phQueue
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    DWORD  hQueue = NULL;

    __try
    {
        rc = RtpOpenQueue(lpwcsFormatName, dwDesiredAccess, dwShareMode, &hQueue);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
       	TrERROR(GENERAL, "An exception was thrown while opening %ls. %!hresult!", lpwcsFormatName, HRESULT_FROM_WIN32(rc));   

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "MQOpenQueue for %ls failed. %!hresult!", lpwcsFormatName, rc);   
		return rc;
    }
    ASSERT(hQueue);
    *phQueue = DWORD_TO_HANDLE(hQueue); //enlarge to HANDLE
    return rc;
}

EXTERN_C
HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    )
{
	if(g_fDependentClient)
		return DepDeleteQueue(lpwcsFormatName);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {

            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 70);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 80);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = R_QMDeleteObject( tls_hBindRpc,
                                         &ObjectFormat);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADDeleteObjectGuid(
                        eQUEUE,
						MachineDomain(),     // pwcsDomainController
						false,	    // fServerName
                        &QueueFormat.PublicID()
                        );
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90);

            if(SUCCEEDED(rc)) {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 100);
}

EXTERN_C
HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    )
{
	if(g_fDependentClient)
		return DepCloseQueue(hQueue);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    //
    // do not add try except here
    // The API is implemented by NtClose() which returns an
    // error on invalid handle (we return MQ_ERROR_INVALID_HANDLE)
    // and throws exception on purpose when running under a debugger to help
    // find errors at development time.
    //
    hr = RTpConvertToMQCode(ACCloseHandle(hQueue));
    return LogHR(hr, s_FN, 110);
}


EXTERN_C
HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pqp,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	if(g_fDependentClient)
		return DepCreateQueue(
					pSecurityDescriptor,
					pqp,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc, rc1;
    LPWSTR lpwcsPathName = NULL;
    LPWSTR pStringToFree = NULL;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    char *pTmpQPBuff = NULL;

    __try
    {
        __try
        {
            //
            // check that output parameters are writeable before creating the Queue
            // we check lpwcsFormatName and lpdwFormatNameLength
            // pqp is refered before the creation and handled by the try except
            //
            if (IsBadWritePtr(lpdwFormatNameLength,sizeof(DWORD)) ||
                IsBadWritePtr(lpwcsFormatName, (*lpdwFormatNameLength) * sizeof(WCHAR)))
            {
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
            }

            // Serialize the security descriptor.
            rc = RTpMakeSelfRelativeSDAndGetSize(
                &pSecurityDescriptor,
                &pSelfRelativeSecurityDescriptor,
                NULL);
            if (!SUCCEEDED(rc))
            {
                return LogHR(rc, s_FN, 130);
            }

            lpwcsPathName = RTpGetQueuePathNamePropVar(pqp);
            if(lpwcsPathName == 0)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
            }

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE QueuePathType;
            QueuePathType = FnValidateAndExpandQueuePath(
                                lpwcsPathName,
                                &lpwcsExpandedPathName,
                                &pStringToFree
                                );

            MQQUEUEPROPS *pGoodQP;

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_CREATE,
                                     QueuePathType == PRIVATE_QUEUE_PATH_TYPE,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 150);
            }

            switch (QueuePathType)
            {
            case PRIVATE_QUEUE_PATH_TYPE:
                rc = RtpCreateObject(MQQM_QUEUE,
                                    lpwcsExpandedPathName,
                                    pSecurityDescriptor,
                                    pGoodQP->cProp,
                                    pGoodQP->aPropID,
                                    pGoodQP->aPropVar);

                if (rc == MQ_ERROR_ACCESS_DENIED)
                {
                    //
                    // See case of public queues for explanations.
                    //
                    rc = RtpCreateObject(
                                MQQM_QUEUE_LOCAL_PRIVATE,
                                lpwcsExpandedPathName,
                                pSecurityDescriptor,
                                pGoodQP->cProp,
                                pGoodQP->aPropID,
                                pGoodQP->aPropVar);
                }

                if (SUCCEEDED(rc))
                {
                    rc = MQPathNameToFormatName(lpwcsExpandedPathName,
                                                lpwcsFormatName,
                                                lpdwFormatNameLength);

                }
                break;

            case PUBLIC_QUEUE_PATH_TYPE:

                {
                    GUID QGuid;

                    rc = ADCreateObject(
								eQUEUE,
								MachineDomain(),      // pwcsDomainController
								false,	    // fServerName
								lpwcsExpandedPathName,
								pSecurityDescriptor,
								pGoodQP->cProp,
								pGoodQP->aPropID,
								pGoodQP->aPropVar,
								&QGuid
								);

                    if (SUCCEEDED(rc)                   ||
                        (rc == MQ_ERROR_NO_DS)          ||
                        (rc == MQ_ERROR_QUEUE_EXISTS)   ||
                        (rc == MQ_ERROR_UNSUPPORTED_OPERATION) ||
                        (rc == MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER) ||
                        (rc == MQ_ERROR_CANNOT_LOAD_MQAD) ||
                        (!g_fOnFailureCallServiceToCreatePublicQueue))
                    {
                        //
                        // For these errors we don't try again to call
                        // DS through the local msmq service.
                        //
                        // ERROR_NO_RESPONSE may happen when talking with a
                        // win2k msmq server that issue a write request to a
                        // nt4 MQIS server.
                        //

						//
                        // Provide appropriate tracing
                        //
                        if (!g_fOnFailureCallServiceToCreatePublicQueue && FAILED(rc))
                        {
                        	TrERROR(GENERAL,"ADCreateObject failed with error %!hresult!, We will not use the service to create the queue",HRESULT(rc));
                        }
                    }
                    else if (!RTpIsLocalPublicQueue(lpwcsExpandedPathName))
                    {
                        //
                        // Not local queue. don't call local msmq service.
                        //
                    }
                    else
                    {
                        //
                        // Calling the DS failed. We don't check the error
                        // code, and unconditionally call the local service.
                        // this is to prevent anomalies, where you can't
                        // create a local queue although you're allowed to do
                        // so (but provided a wrong parameter, like security
                        // descriptor, or had any other problem) but will be
                        // able to create it through the service is you're
                        // not allow to create directly in the DS.
                        //
                        // call local msmq service, and ask it to create
                        // the queue. default security descriptor of
                        // msmqConfiguration object on win2000 is that only
                        // object owner and local machine account can create
                        // queues.
                        //
                        HRESULT rcFail = rc ;

                        rc = RtpCreateDSObject(
                                        MQDS_LOCAL_PUBLIC_QUEUE,
                                        lpwcsExpandedPathName,
                                        pSecurityDescriptor,
                                        pGoodQP->cProp,
                                        pGoodQP->aPropID,
                                        pGoodQP->aPropVar,
                                       &QGuid );

                        if (SUCCEEDED(rc))
                        {
                            //
                            // Just assert that we called the service
                            // for the right reason...
                            //
							// Currently MQ_ERROR_INVALID_OWNER is returned when the user
							// is logon to another forest. in this case the RT failed to search
							// the computer object and MQ_ERROR_INVALID_OWNER is returned from ADCreateObject().
							// (mqad convert MQDS_OBJECT_NOT_FOUND to MQ_ERROR_INVALID_OWNER for backward compatability)
							// We get MQ_ERROR_DS_LOCAL_USER in case of Local User
							// MQ_ERROR_QUEUE_NOT_FOUND will be the case when the user doesn't have permissions in AD
							// and as a result failed to bind to AD.
							//
							TrTRACE(DS, "RtpCreateDSObject SUCCEEDED while ADCreateObject failed, hr = 0x%x", rcFail);
                            ASSERT_BENIGN((rcFail == MQ_ERROR_INVALID_OWNER) ||
								   (rcFail == MQ_ERROR_ACCESS_DENIED) ||
                        		   (rcFail == MQ_ERROR_QUEUE_NOT_FOUND) ||
                                   (rcFail == HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION)) ||
                                   (rcFail == MQ_ERROR_DS_LOCAL_USER) ||
								   ADProviderType() == eMqdscli);
							
							DBG_USED(rcFail);
                        }
                    }

                    if (SUCCEEDED(rc))
                    {
                        rc = MQInstanceToFormatName(&QGuid,
                                                    lpwcsFormatName,
                                                    lpdwFormatNameLength);

                    }
                }
                break;

            default:
                rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                break;

            }
            if ( rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
            {
                //
                //  Change into information status ( queue
                //  creation succeeded
                //
                rc = MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL;
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 160);
            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the extended path name and the serialized security descriptor.
        delete[] pStringToFree;
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete[] pTmpQPBuff;

    }

    if(FAILED(rc))
    {
    	if(rc == MQ_ERROR_QUEUE_EXISTS)
    	{
    		TrWARNING(LOG, "Failed to create %ls. The queue already exists.", lpwcsPathName);
    	}
    	else
    	{
    		TrERROR(LOG, "Failed to create %ls. hr = %!hresult!", lpwcsPathName, rc);
    	}
    }

    if (SUCCEEDED(rc) && ((ULONG)(rc) >> 30 != 1)) // no warnning
    {
        return rc1;
    }
    return rc;
}


EXTERN_C
HRESULT
APIENTRY
MQLocateBegin(
    IN  LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    )
{
	if(g_fDependentClient)
		return DepLocateBegin(
					lpwcsContext,
					pRestriction,
					pColumns,
					pSort,
					phEnum
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;

    __try
    {
        if  ( lpwcsContext != NULL)
        {
            return LogHR(MQ_ERROR_ILLEGAL_CONTEXT, s_FN, 190);
        }

        rc = RTpCheckColumnsParameter(pColumns);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 200);
        }

        // If the application passes a valid pointer to a MQRESTRICTION
        // structure with zero rescritctions, pass a null restrictios pointer
        // to the DS, this makes the DS's life much easier.
        if (pRestriction && !pRestriction->cRes)
        {
            pRestriction = NULL;
        }

        rc = RTpCheckRestrictionParameter(pRestriction);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }

        rc = RTpCheckSortParameter( pSort);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 220);
        }

        rc = ADQueryQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pRestriction,
                pColumns,
                pSort,
                phEnum
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 230);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    return LogHR(rc, s_FN, 240);
}

EXTERN_C
HRESULT
APIENTRY
MQLocateNext(
    IN HANDLE hEnum,
    OUT DWORD *pcPropsRead,
    OUT PROPVARIANT aPropVar[]
    )
{
	if(g_fDependentClient)
		return DepLocateNext(
					hEnum,
					pcPropsRead,
					aPropVar
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;

    __try
    {
		rc = RTpCheckLocateNextParameter(
				*pcPropsRead,
				aPropVar);
		if( FAILED(rc))
		{
			return LogHR(rc, s_FN, 250);
		}

        rc = ADQueryResults(
                          hEnum,
                          pcPropsRead,
                          aPropVar);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 260);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    // If failed, zero the numer of props.
    if (FAILED(rc))
    {
        __try
        {
            *pcPropsRead = 0;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // Do not modify the original error code.
        }
    }

    return LogHR(rc, s_FN, 270);
}

EXTERN_C
HRESULT
APIENTRY
MQLocateEnd(
    IN HANDLE hEnum
    )
{
	if(g_fDependentClient)
		return DepLocateEnd(hEnum);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;

    __try
    {

        rc = ADEndQuery(hEnum);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 280);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 290);
}

EXTERN_C
HRESULT
APIENTRY
MQSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	if(g_fDependentClient)
		return DepSetQueueProperties(
					lpwcsFormatName,
					pqp
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 300);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 310);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_SET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 320);
            }


            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = R_QMSetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADSetObjectPropertiesGuid(
							eQUEUE,
							MachineDomain(),      // pwcsDomainController
							false,		// fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 330);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;

    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 340);
    }
    return LogHR(rc, s_FN, 350);
}


EXTERN_C
HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	if(g_fDependentClient)
		return DepGetQueueProperties(
					lpwcsFormatName,
					pqp
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 360);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 370);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_GET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 380);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = R_QMGetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:

                rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							MachineDomain(),      // pwcsDomainController
							false,	     // fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }

            // Here we have out queue properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            if (SUCCEEDED(rc) && (pqp != pGoodQP))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQP->cProp; i++, j++)
                {
                    while(pqp->aPropID[j] != pGoodQP->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pqp->cProp);
                    }
                    pqp->aPropVar[j] = pGoodQP->aPropVar[i];
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 390);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 400);
    }
    return LogHR(rc, s_FN, 410);
}

EXTERN_C
HRESULT
APIENTRY
MQGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pInSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    )
{
    //
    // bug 8113.
    // If input buffer is NULL, replace it with 1 byte
    // temporary buffer. Otherwise, call fail with
    // error SERVICE_NOT_AVAILABLE. This is because of
    // using /robust in midl. NULL pointer is not allowed.
    //
    BYTE  tmpBuf[1] ;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL ;

    if (pInSecurityDescriptor || (nLength != 0))
    {
        pSecurityDescriptor =  pInSecurityDescriptor ;
    }
    else
    {
        //
        // this is the fix for 8113.
        //
        pSecurityDescriptor =  tmpBuf ;
    }

	if(g_fDependentClient)
		return DepGetQueueSecurity(
					lpwcsFormatName,
					RequestedInformation,
					pSecurityDescriptor,
					nLength,
					lpnLengthNeeded
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 420);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 430);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = R_QMGetObjectSecurity(tls_hBindRpc,
                                             &ObjectFormat,
                                             RequestedInformation,
                                             pSecurityDescriptor,
                                             nLength,
                                             lpnLengthNeeded);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    MQPROPVARIANT var = {{VT_NULL, 0,0,0,0}};

                    rc = ADGetObjectSecurityGuid(
                            eQUEUE,
							MachineDomain(),      // pwcsDomainController
							false,	    // fServerName
                            &QueueFormat.PublicID(),
                            RequestedInformation,
                            PROPID_Q_SECURITY,
                            &var
                            );
                    if (FAILED(rc))
                    {
                        break;
                    }

                    ASSERT( var.vt == VT_BLOB);
                    if ( var.blob.cbSize <= nLength )
                    {
                        //
                        //  Copy the buffer
                        //
                        memcpy(pSecurityDescriptor, var.blob.pBlobData, var.blob.cbSize);
                    }
                    else
                    {
                        rc = MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
                    }
                    delete [] var.blob.pBlobData;
                    *lpnLengthNeeded = var.blob.cbSize;

                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 440);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

	if(FAILED(rc))
	{
		TrERROR(GENERAL, "MQGetQueueSecurity for %ls failed. %!hresult!",lpwcsFormatName, rc);
	}

	return rc;
}

static 
bool
IsNewSecurityInformationFlags(
    IN SECURITY_INFORMATION SecurityInformation
	)
{
	//
	// Does Security Information include any of the new windows 2000 and XP flags. 
	//

	if(SecurityInformation & 
		(PROTECTED_DACL_SECURITY_INFORMATION 
		| PROTECTED_SACL_SECURITY_INFORMATION 
		| UNPROTECTED_DACL_SECURITY_INFORMATION 
		| UNPROTECTED_SACL_SECURITY_INFORMATION))
		return true;

	return false;
}

EXTERN_C
HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
	//
	// We don't support the windows 2000/XP SECURITY_INFORMATION flags:
	// PROTECTED_DACL_SECURITY_INFORMATION, 
	// PROTECTED_SACL_SECURITY_INFORMATION, 
	// UNPROTECTED_DACL_SECURITY_INFORMATION, 
	// UNPROTECTED_SACL_SECURITY_INFORMATION
	//
	if(IsNewSecurityInformationFlags(SecurityInformation))
	{
		TrERROR(GENERAL, "Security Information argument contains unsupported flags. SI == %u", SecurityInformation);
		return MQ_ERROR_INVALID_PARAMETER;
	}

	if(g_fDependentClient)
		return DepSetQueueSecurity(
					lpwcsFormatName,
					SecurityInformation,
					pSecurityDescriptor
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    LPWSTR pStringToFree = NULL;


    __try
    {

        // Serialize the security descriptor.
        rc = RTpMakeSelfRelativeSDAndGetSize(
            &pSecurityDescriptor,
            &pSelfRelativeSecurityDescriptor,
            NULL);
        if (!SUCCEEDED(rc))
        {
            return LogHR(rc, s_FN, 470);
        }

        __try
        {
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 480);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 490);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    rc = RtpSetObjectSecurity(
                            &ObjectFormat,
                            SecurityInformation,
                            pSecurityDescriptor);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    PROPID prop = PROPID_Q_SECURITY;
                    MQPROPVARIANT var;

                    var.vt = VT_BLOB;
					if(pSecurityDescriptor != NULL)
					{
						var.blob.cbSize = GetSecurityDescriptorLength( pSecurityDescriptor);
						var.blob.pBlobData = reinterpret_cast<unsigned char *>(pSecurityDescriptor);
					}
					else
					{
						var.blob.cbSize = 0;
						var.blob.pBlobData = NULL;
					}

                    rc = ADSetObjectSecurityGuid(
								eQUEUE,
								MachineDomain(),      // pwcsDomainController
								false,		// fServerName
								&QueueFormat.PublicID(),
								SecurityInformation,
								prop,
								&var
								);
                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 500);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the serialized security descriptor.
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 510);
}

EXTERN_C
HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	if(g_fDependentClient)
		return DepPathNameToFormatName(
					lpwcsPathName,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE qpt;
            qpt = FnValidateAndExpandQueuePath(
                    lpwcsPathName,
                    &lpwcsExpandedPathName,
                    &pStringToFree
                    );

            switch (qpt)
            {

                case PRIVATE_QUEUE_PATH_TYPE:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT_BENIGN(tls_hBindRpc) ;
                    rc = R_QMObjectPathToObjectFormat(
                            tls_hBindRpc,
                            lpwcsExpandedPathName,
                            &ObjectFormat
                            );
                    ASSERT(!SUCCEEDED(rc) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT));
                }
                break;

                case PUBLIC_QUEUE_PATH_TYPE:
                {
                    GUID guidPublic;
                    ULONG QueueGuidPropID[1] = {PROPID_Q_INSTANCE};
                    PROPVARIANT QueueGuidPropVar[1];

                    QueueGuidPropVar[0].vt = VT_CLSID;
                    QueueGuidPropVar[0].puuid = &guidPublic;
                    rc = ADGetObjectProperties(
                            eQUEUE,
							MachineDomain(),      // pwcsDomainController
							false,	    // fServerName
                            lpwcsExpandedPathName,
                            1,
                            QueueGuidPropID,
                            QueueGuidPropVar
                            );

                    if (FAILED(rc) &&
                        (rc != MQ_ERROR_NO_DS) &&
                        (rc != MQ_ERROR_UNSUPPORTED_OPERATION))
                    {
                        rc = MQ_ERROR_QUEUE_NOT_FOUND;
                    }

                    QueueFormat.PublicID(guidPublic);
                }
                break;

                default:
                {
                    rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                }
                break;

            }

            if (SUCCEEDED(rc))
            {
                rc = RTpQueueFormatToFormatName(
                        &QueueFormat,
                        lpwcsFormatName,
                        *lpdwFormatNameLength,
                        lpdwFormatNameLength
                        );
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        QueueFormat.DisposeString();
        delete[] pStringToFree;

    }

	if(FAILED(rc))
	{
		TrERROR(GENERAL, "MQPathNameToFormatName() Failed. Pathname = %ls, %!hresult!", lpwcsPathName, rc);
	}

    return rc;
}

EXTERN_C
HRESULT
APIENTRY
MQHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	if(g_fDependentClient)
		return DepHandleToFormatName(
					hQueue,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    rc = ACHandleToFormatName(
            hQueue,
            lpwcsFormatName,
            lpdwFormatNameLength
            );

    return LogHR(rc, s_FN, 560);
}

EXTERN_C
HRESULT
APIENTRY
MQInstanceToFormatName(
    IN GUID * pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	if(g_fDependentClient)
		return DepInstanceToFormatName(
					pGuid,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;

    __try
    {

        QUEUE_FORMAT QueueFormat(*pGuid);

        rc = RTpQueueFormatToFormatName(
                &QueueFormat,
                lpwcsFormatName,
                *lpdwFormatNameLength,
                lpdwFormatNameLength
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 570);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 580);
}

EXTERN_C
HRESULT
APIENTRY
MQPurgeQueue(
    IN QUEUEHANDLE hQueue
    )
{
	if(g_fDependentClient)
		return DepPurgeQueue(hQueue);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    rc = ACPurgeQueue(hQueue);
    return LogHR(rc, s_FN, 600);
}

EXTERN_C
HRESULT
APIENTRY
MQADsPathToFormatName(
    IN LPCWSTR lpwcsADsPath,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	if(g_fDependentClient)
		return MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS;

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;
    LPWSTR pVarStringToFree = NULL;

    __try
    {
        __try
        {
            MQPROPVARIANT var;
            eAdsClass AdsClass;
            var.vt = VT_NULL;

            rc = ADGetADsPathInfo(
                    lpwcsADsPath,
                    &var,
                    &AdsClass);
            if (FAILED(rc))
            {
                return rc;
            }

            switch( AdsClass)
            {
            case eQueue:
                ASSERT(var.vt == VT_CLSID);
                ASSERT(var.puuid != NULL);
                QueueFormat.PublicID(*var.puuid);
                delete var.puuid;
                break;
            case eGroup:
                ASSERT(var.vt == VT_CLSID);
                ASSERT(var.puuid != NULL);

                DL_ID id;
                id.m_DlGuid =*var.puuid;
                id.m_pwzDomain = RTpExtractDomainNameFromDLPath( lpwcsADsPath);

                QueueFormat.DlID(id);
                delete var.puuid;
                break;
            case eAliasQueue:
                ASSERT(var.vt == VT_LPWSTR);
                pVarStringToFree =  var.pwszVal;
                if (!FnFormatNameToQueueFormat(var.pwszVal, &QueueFormat, &pStringToFree))
                {
                    return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 3770);
                }
                if (!((QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                      (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)  ||
                      (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)))
                {
                    return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 3771);
                }

                break;
            default:
                ASSERT(("Should not get other object class types", 0));
                break;
            }
            rc = RTpQueueFormatToFormatName(
                    &QueueFormat,
                    lpwcsFormatName,
                    *lpdwFormatNameLength,
                    lpdwFormatNameLength
                    );


        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pStringToFree;
        delete[] pVarStringToFree;

    }

    return LogHR(rc, s_FN, 540);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtcert.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rtcert.cpp

Abstract:

    MQ internal certificate store management.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include "stdh.h"
#include <ad.h>
#include <mqutil.h>
#include <_secutil.h>
#include <rtcert.h>
#include <rtdepcert.h>
#include "rtputl.h"

#include "rtcert.tmh"

static WCHAR *s_FN=L"rt/rtcert";

/*************************************************************************
*
*  Function:  RTOpenInternalCertStore( HCERTSTORE *phStore )
*
*  Parameters
*      BOOL fWriteAccess - TRUE if caller want write access, i.e.,
*                   if user want to add a certificate to the store.
*
*  Descruption: Get a handle to the certificate store which contain
*               the internal certificates.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTOpenInternalCertStore( OUT CMQSigCertStore **ppStore,
                         IN  LONG            *pnCerts,
                         IN  BOOL            fWriteAccess,
                         IN  BOOL            fMachine,
                         IN  HKEY            hKeyUser )
{
	if(g_fDependentClient)
	{
		return DepOpenInternalCertStore(
					ppStore,
					pnCerts,
					fWriteAccess,
					fMachine,
					hKeyUser
					);
	}

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    struct MQSigOpenCertParams OpenParams ;
    memset(&OpenParams, 0, sizeof(OpenParams)) ;
    OpenParams.bCreate = !!fWriteAccess ;
    OpenParams.bWriteAccess = !!fWriteAccess ;
    OpenParams.bMachineStore = !!fMachine ;
    OpenParams.hCurrentUser = hKeyUser ;

    HRESULT hr = MQSigOpenUserCertStore( ppStore,
                                         MQ_INTERNAL_CERT_STORE_REG,
                                        &OpenParams ) ;
    if (FAILED(hr))
    {
    	TrERROR(SECURITY, "Failed to open user certificate store. %!hresult!" ,hr);   
        return hr;
    }

    if (pnCerts)
    {
        HCERTSTORE hStore = (*ppStore)->GetHandle() ;
        //
        // count the number of certificates in store.
        //
        *pnCerts = 0 ;

        PCCERT_CONTEXT pCertContext;
        PCCERT_CONTEXT pPrevCertContext;

        pCertContext = CertEnumCertificatesInStore(hStore, NULL);
        while (pCertContext)
        {
            pPrevCertContext = pCertContext,

            (*pnCerts)++ ;
            pCertContext = CertEnumCertificatesInStore( hStore,
                                                        pPrevCertContext ) ;
        }

        ASSERT(!pCertContext) ;
        ASSERT((*pnCerts == 0) || (*pnCerts == 1)) ;
    }

    TrTRACE(SECURITY, "rtcert: RTOpenInternalCertStore successful");

    return MQ_OK ;
}

/*************************************************************************
*
*  Function:
*    RTGetInternalCert
*
*  Parameters -
*    ppCert - On return, pointer to The certificate object.
*
*  Return value-
*    MQ_OK if successful, else an error code.
*
*  Comments -
*    Returns the internal certificate. The function fails if the
*    certificate does not exist.
*
*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser )
{
	if(g_fDependentClient)
	{
		return DepGetInternalCert(
					ppCert,
					ppStore,
					fGetForDelete,
					fMachine,
					hKeyUser
					);
	}

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    LONG nCerts = 0 ;

    *ppCert = NULL ;
    *ppStore = NULL ;

    HRESULT hr = RTOpenInternalCertStore( ppStore,
                                          &nCerts,
                                          fGetForDelete,
                                          fMachine,
                                          hKeyUser ) ;
    if (FAILED(hr) || (nCerts == 0))
    {
    	TrERROR(SECURITY, "Failed to open internal certificate store. %!hresult!" ,hr);   
        return MQ_ERROR_NO_INTERNAL_USER_CERT;
    }

    PCCERT_CONTEXT pCertContext =
                CertEnumCertificatesInStore((*ppStore)->GetHandle(), NULL);

    if (!pCertContext)
    {
        return LogHR(MQ_ERROR_NO_INTERNAL_USER_CERT, s_FN, 30) ;
    }

    hr = MQSigCreateCertificate( ppCert, pCertContext);
	if (FAILED(hr))
    {
    	TrERROR(SECURITY, "Failed to create certificate. %!hresult!" ,hr);
	}
    return LogHR(hr, s_FN, 40);
}

/*************************************************************************

  Function:
    RTRegisterUserCert

  Parameters -
    pCert - The certificate object.

  Return value-
    S_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTRegisterUserCert(
    IN CMQSigCertificate *pCert,
    IN BOOL               fMachine )
{
	if(g_fDependentClient)
		return DepRegisterUserCert(pCert, fMachine);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pCert) ;

    PROPID propIDU[] = {PROPID_U_ID, PROPID_U_SIGN_CERT, PROPID_U_DIGEST};
    PROPID propIDCom[] = {PROPID_COM_ID, PROPID_COM_SIGN_CERT, PROPID_COM_DIGEST};
    DWORD dwArraySize = sizeof(propIDU) / sizeof(propIDU[0]) ;

    PROPID *pPropIDs = propIDU ;
    if (fMachine)
    {
        pPropIDs = propIDCom ;
    }

    PROPVARIANT propVar[3];
    GUID guidCert;

    propVar[0].vt = VT_CLSID;
    propVar[0].puuid = &guidCert;
    UuidCreate(&guidCert);

    propVar[1].vt = VT_BLOB;

    DWORD dwCertSize = 0 ;
    BYTE  *pBuf = NULL ;

    HRESULT hr = pCert->GetCertBlob(&pBuf, &dwCertSize) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    propVar[1].blob.cbSize =  dwCertSize ;
    propVar[1].blob.pBlobData  = pBuf ;

    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    propVar[2].vt = VT_CLSID;
    propVar[2].puuid = &guidHash;

    switch (hr = ADCreateObject(
						eUSER,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						NULL,
						NULL,
						dwArraySize,
						pPropIDs,
						propVar,
						NULL
						))
    {
        case MQDS_CREATE_ERROR:
            hr = MQ_ERROR_INTERNAL_USER_CERT_EXIST;
            break;

        case MQ_OK:
            hr = MQ_OK;
            break;
    }

    return LogHR(hr, s_FN, 70) ;
}


bool IsWorkGroupMode(void)
/*++

Routine Description:
	Retrieve WorkGroup Mode from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	true for WorkGroup mode, false otherwise

--*/
{
	static bool s_fWorkGroupModeInitialize = false;
	static bool s_fWorkGroupMode = false;

    if (s_fWorkGroupModeInitialize)
		return s_fWorkGroupMode;

	DWORD dwWorkGroup;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwType = REG_DWORD;

	LONG rc = GetFalconKeyValue(
					MSMQ_WORKGROUP_REGNAME,
					&dwType,
					&dwWorkGroup,
					&dwSize
					);

	if ((rc == ERROR_SUCCESS) && (dwWorkGroup != 0))
	{
		s_fWorkGroupMode = true;	
	}

	s_fWorkGroupModeInitialize = true;

    TrTRACE(SECURITY, "WorkGroupMode registry status = %d", s_fWorkGroupMode);

	return s_fWorkGroupMode;
}


/*************************************************************************

  Function:
    RTGetUserCerts

  Parameters -
    ppCert - A pointer to an array that receives the ponters to the user's
        certificates.
    pnCerts - A pointer to a buffer that points to the number of entries in
        pp509. Upon return, the buffer contains the number of certificates
        that the user has.
    pSidIn - An optiona lparameter that points to a user SID. If this
        parameter equals NULL, the certificates for the user of the current
        thread are retrieved.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the array in pp509 is too small, it is being filled up until there
    is no more place in it. All certificates should be released in any
    case. If upon return pnCerts points to a value that is greater than
    the value when entering the function, it means that pp509 is too
    small.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTGetUserCerts(
    CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
    )
{
	if(g_fDependentClient)
		return DepGetUserCerts(ppCert, pnCerts, pSidIn);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    AP<BYTE> pUserSid;
    DWORD dwSidLen;
    PSID pSid;
    DWORD nCertsIn = *pnCerts;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 75);
	}

    if (pSidIn)
    {
        pSid = pSidIn;
        dwSidLen = GetLengthSid(pSid);
    }
    else
    {
        //
        // Local users are not let in.
        //
        BOOL fLocalUser;
        BOOL fLocalSystem;

        hr = RTpGetThreadUserSid( &fLocalUser,
                                  &fLocalSystem,
                                  &pUserSid,
                                  &dwSidLen );
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 80) ;
        }

        if (fLocalUser)
        {
		    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90);
        }

        pSid = pUserSid;
    }

    MQCOLUMNSET Cols;
    PROPID ColId = PROPID_U_SIGN_CERT;
    HANDLE hEnum;

    Cols.cCol = 1;
    Cols.aCol = &ColId;

    BLOB blobUserSid;
    blobUserSid.cbSize = dwSidLen;
    blobUserSid.pBlobData = (BYTE *)pSid;

    hr = ADQueryUserCert(
                NULL,       // pwcsDomainController,
				false,		// fServerName
                &blobUserSid,
                &Cols,
                &hEnum
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100) ;
    }

    DWORD nCerts = 0 ;

    while (1)
    {
        DWORD cProps = 1;
        PROPVARIANT propVar;

        propVar.vt = VT_NULL;
        hr = ADQueryResults(hEnum, &cProps, &propVar);
        if (FAILED(hr) || !cProps)
        {
            break;
        }

        if (nCerts < nCertsIn)
        {
            CMQSigCertificate *pSigCert = NULL ;
            HRESULT hr = MQSigCreateCertificate( &pSigCert,
                                                 NULL,
                                                 propVar.blob.pBlobData,
                                                 propVar.blob.cbSize ) ;
            if (SUCCEEDED(hr))
            {
                ppCert[ nCerts ] = pSigCert ;
                nCerts++;
            }
        }
        else
        {
            nCerts++;
        }

        MQFreeMemory(propVar.blob.pBlobData);
    }

    ADEndQuery(hEnum);

    *pnCerts = nCerts;

    return LogHR(hr, s_FN, 110) ;
}

/*************************************************************************

  Function:
    RTRemoveUserCert

  Parameters -

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTRemoveUserCert(
    IN CMQSigCertificate *pCert
    )
{
	if(g_fDependentClient)
		return DepRemoveUserCert(pCert);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }

    hr = ADDeleteObjectGuid(
                eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &guidHash
                );
    return LogHR(hr, s_FN, 130) ;
}

/*************************************************************************

  Function:
    RTRemoveUserCertSid

  Parameters -

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    Fix for NT bug 516098.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTRemoveUserCertSid(
    IN CMQSigCertificate *pCert,
    IN const SID         *pSid
    )
{
	if(g_fDependentClient)
		return DepRemoveUserCert(pCert);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }

    hr = ADDeleteObjectGuidSid(
                eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &guidHash,
                pSid
                );
    return LogHR(hr, s_FN, 330) ;
}

/*************************************************************************

  Function:
    GetCertInfo

  Parameters -
    ppbCert - A pointer to a pointer to a buffer that holds the cert bits.
    dwCertLen - A pointer to the length of *ppbCert.
    phProv - A pointer to a buffer that receives the handle to the cert CSP.
    wszProvName - A pointer to a buffer that receives a pointer to the name
        of the cert CSP.
    pdwProvType - A poinrter to a buffer the receives the type of the cert CSP.
    pbDefProv - A pointer to a buffer that reveices TRUE, if the cert CSP is
        the default CSP, else FALSE.
    pbInternalCert - A pointer to a buffer that receives TRUE, if the cert
        is an internl MSMQ cert, else FALSE.
    pdwPrivateKeySpec - A pointer to a buffer that receives the private key type
        AT_SIGNATURE or AT_KEYEXCHANGE.

  Return value-
    MQ_OK if successful, else error code.

  Comments -
    The function receives a buffer that contains the bits of some
    certificate and returns various information about the certificate.

*************************************************************************/

HRESULT
GetCertInfo(
    IN     BOOL        fUseCurrentUser,
	IN     BOOL        fMachine,
	IN OUT BYTE      **ppbCert,
	OUT    DWORD      *pdwCertLen,
	OUT    HCRYPTPROV *phProv,
	OUT    LPWSTR     *wszProvName,
	OUT    DWORD      *pdwProvType,
	OUT    BOOL       *pbDefProv,
	OUT    BOOL       *pbInternalCert,
	OUT	   DWORD      *pdwPrivateKeySpec
	)
{
    HRESULT hr;

    //
    // Note: it's important that pStore be defined before
    //       pCert, so it will be the last one to be released.
    //
    R<CMQSigCertStore>   pStore;
    R<CMQSigCertificate> pCert;

    ASSERT(ppbCert);

    *pbInternalCert = (*ppbCert == NULL);

    CAutoCloseRegHandle  hKeyUser (NULL) ;
    if ( fUseCurrentUser )
    {
	    ASSERT(!fMachine) ;

        LONG rc = RegOpenCurrentUser( KEY_READ,
                                     &hKeyUser ) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }
    }

    if (*pbInternalCert)
    {
		//
		// Internal Certificate are using Signature Key
		//
		*pdwPrivateKeySpec = AT_SIGNATURE;

        //
        // We should get the information for the internal certificate.
        //
        hr = RTGetInternalCert(
				&pCert.ref(),
				&pStore.ref(),
				FALSE, // fGetForDelete
				fMachine,
                hKeyUser
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 140);
        }

        BYTE  *pCertBlob = NULL;
        DWORD dwCertSize = 0;

        hr = pCert->GetCertBlob(
				&pCertBlob,
				&dwCertSize
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 150);
        }

        try
        {
            //
            // We must free b.pBlobData, so do not use memory allocation
            // faliure excpetions.
            //
            *ppbCert = new BYTE[dwCertSize];
        }
        catch(const bad_alloc&)
        {
            //
            // We failed to allocate a buffer for the cert. Free the blob and
            // return an error.
            //
            *ppbCert = NULL;
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 160);
        }

        //
        // Copy the certificate to "our" memory.
        //
        *pdwCertLen = dwCertSize;
        memcpy(*ppbCert, pCertBlob, dwCertSize);

        //
        // The CSP context for the internal certificate is always of the
        // base RSA provider.
        //
        DWORD   dwMachineFlag = 0;
        LPWSTR lpszContainerNameW = MSMQ_INTCRT_KEY_CONTAINER_W;

        if (fMachine)
        {
            lpszContainerNameW = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W;
            dwMachineFlag = CRYPT_MACHINE_KEYSET;
        }

        if (!CryptAcquireContext(
				phProv,
				lpszContainerNameW,
				MS_DEF_PROV,
				PROV_RSA_FULL,
				dwMachineFlag
				))
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CryptAcquireContext() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        *wszProvName = new WCHAR[sizeof(MS_DEF_PROV_A)];
        wcscpy((LPWSTR)*wszProvName, MS_DEF_PROV_W);

        *pdwProvType = PROV_RSA_FULL;
    }
    else
    {
        //
        // We have a "real" (non-internal) cetificate.
        //
        AP<WCHAR> wszKeySet;
        ASSERT(pdwCertLen && *pdwCertLen);

        CHCryptProv hProv;

        if (!CryptAcquireContext(
				&hProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT
				))
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CryptAcquireContext failed, gle = %!winerr!", gle);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        CHCertStore  hSysStore =  CertOpenSystemStore(
										hProv,
										x_wszPersonalSysProtocol
										);
        if (!hSysStore)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CertOpenSystemStore failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE;
        }

        BOOL fFound;
        CPCCertContext pCertContext;

        for ( fFound = FALSE,
              pCertContext = CertEnumCertificatesInStore(hSysStore, NULL);
              pCertContext && !fFound; )
        {
            PCCERT_CONTEXT pCtx = pCertContext;
            fFound = (*pdwCertLen == pCtx->cbCertEncoded) &&
                     (memcmp(
						*ppbCert,
						pCtx->pbCertEncoded,
						pCtx->cbCertEncoded
						) == 0);

            if (!fFound)
            {
				TrWARNING(GENERAL, "pCertContext didn't match, CertLen = %d, CertEncoded = %d", *pdwCertLen, pCtx->cbCertEncoded);
                pCertContext = CertEnumCertificatesInStore(
									hSysStore,
									pCtx
									);
            }
        }

        if (!pCertContext)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CertEnumCertificatesInStore failed, gle = 0x%x", gle);
            return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 200);
        }

        BYTE abShortCertInfo[256];
        DWORD dwCertInfoSize = sizeof(abShortCertInfo);
        AP<BYTE> pLongCertInfo = NULL;
        PBYTE pCertInfo = abShortCertInfo;

        if (!CertGetCertificateContextProperty(
				pCertContext,
				CERT_KEY_PROV_INFO_PROP_ID,
				pCertInfo,
				&dwCertInfoSize
				))
        {
			DWORD dwErr = GetLastError();

            if (dwErr == ERROR_MORE_DATA)
            {
                pLongCertInfo = new BYTE[dwCertInfoSize];
                pCertInfo = pLongCertInfo;
                if (!CertGetCertificateContextProperty(
						pCertContext,
						CERT_KEY_PROV_INFO_PROP_ID,
						pCertInfo,
						&dwCertInfoSize
						))
                {
                    return LogHR(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE, s_FN, 210);
                }
            }
            else
            {
				TrERROR(SECURITY, "rtcert: CertGetCertificateContextProperty failed, error = 0x%x", dwErr);

                return LogHR(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE, s_FN, 220);
            }
        }

        PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pCertInfo;

        DWORD dwKeySetLen = wcslen(pKeyProvInfo->pwszContainerName);
        wszKeySet = new WCHAR[dwKeySetLen + 1];
        wcscpy(wszKeySet, pKeyProvInfo->pwszContainerName);

        DWORD dwProvNameLen = wcslen(pKeyProvInfo->pwszProvName);
        *wszProvName = new WCHAR[dwProvNameLen + 1];
        wcscpy(*wszProvName, pKeyProvInfo->pwszProvName);

        *pdwProvType = pKeyProvInfo->dwProvType;

		//
		// For external certificate we are getting the PrivateKeySpec from the certificate	
		// bug 5626 25-June-2000 ilanh
		//
		*pdwPrivateKeySpec = pKeyProvInfo->dwKeySpec;

		//
		// *pdwPrivateKeySpec must be AT_SIGNATURE or AT_KEYEXCHANGE
		//
        ASSERT((*pdwPrivateKeySpec == AT_SIGNATURE) ||
			   (*pdwPrivateKeySpec == AT_KEYEXCHANGE));


        BOOL fAcq = CryptAcquireContext(
						phProv,
						wszKeySet,
						*wszProvName,
						*pdwProvType,
						0
						);

        if (!fAcq)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CryptAcquireContext() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    //
    // Find out whether the CSP is the default CSP.
    //
    *pbDefProv = (*pdwProvType == PROV_RSA_FULL) &&
                 (wcscmp(*wszProvName, MS_DEF_PROV_W) == 0);

#ifdef _DEBUG
    if (*pbDefProv)
    {
        static BOOL s_fAlreadyRead = FALSE;
        static BOOL s_fMakeNonDefault = FALSE;

        if (!s_fAlreadyRead)
        {
        	DWORD dwUseNonDef = 0;
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            LONG res = GetFalconKeyValue(
							USE_NON_DEFAULT_AUTHN_PROV_REGNAME,
							&dwType,
							&dwUseNonDef,
							&dwSize
							);

            if ((res == ERROR_SUCCESS) && (dwUseNonDef == 1))
            {
                s_fMakeNonDefault = TRUE;
            }
            s_fAlreadyRead = TRUE;
        }

        if (s_fMakeNonDefault)
        {
            *pbDefProv = FALSE;
            wcscpy(
				*wszProvName,
				L"MiCrOsOfT BaSe CrYpToGrApHiC PrOvIdEr v1.0"
				);
        }
    }
#endif

    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtfrebnd.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rtfrebnd.h

Abstract:
    Free binding handles

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef __FREEBIND_H
#define __FREEBIND_H

#include "cs.h"


//---------------------------------------------------------
//
//  class CFreeRPCHandles
//
//---------------------------------------------------------

class CFreeRPCHandles
{
public:
	~CFreeRPCHandles();

    void Add(handle_t hBind);
    void Remove(handle_t  hBind);

private:
    CCriticalSection      m_cs;
    std::vector<handle_t>   m_handles;
};


inline  CFreeRPCHandles::~CFreeRPCHandles()
{
	for(std::vector<handle_t>::const_iterator it = m_handles.begin(); it != m_handles.end();++it)
	{
      handle_t h = *it;
      RpcBindingFree(&h);
	}
}

inline void CFreeRPCHandles::Add(handle_t hBind)
{
    CS Lock(m_cs); 
    m_handles.push_back(hBind);
}

inline void CFreeRPCHandles::Remove(handle_t hBind)
{
    CS Lock(m_cs);
	for(std::vector<handle_t>::iterator it = m_handles.begin(); it != m_handles.end();++it)
	{
      handle_t h = *it;
      if (h == hBind)
      {
          RpcBindingFree(&h);
          m_handles.erase(it);
          break;
      }
	}
}


#endif  //  __FREEBIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtmain.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmain.cpp

Abstract:

    This module contains code involved with Dll initialization.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "cs.h"
#include "rtsecutl.h"
#include "rtprpc.h"
#include "verstamp.h"
#include "rtfrebnd.h"
//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

#include <cm.h>
#include <Xds.h>
#include <Cry.h>
#include <dld.h>

#include "rtmain.tmh"

static WCHAR *s_FN=L"rt/rtmain";



HINSTANCE g_hInstance;

//
//  Holds MSMQ version for debugging purposes
//
CHAR *g_szMsmqBuildNo = VER_PRODUCTVERSION_STR;  

void InitErrorLogging();

BOOL  g_fDependentClient = FALSE ;   // TRUE if running as dependent Client

//
// TLS index for per-thread event.
//
DWORD  g_dwThreadEventIndex = TLS_OUT_OF_INDEXES;

// QM computer name (for the client - server's name)
LPWSTR  g_lpwcsComputerName = NULL;
DWORD   g_dwComputerNameLen = 0;

//
//  Default for PROPID_M_TIME_TO_REACH_QUEUE
//
DWORD  g_dwTimeToReachQueueDefault = MSMQ_DEFAULT_LONG_LIVE ;

//
// Indicates if on failure to create a public queue we should call the qm
//
BOOL g_fOnFailureCallServiceToCreatePublicQueue = MSMQ_SERVICE_QUEUE_CREATION_DEFAULT;

//
// RPC related data.
//
CFreeRPCHandles g_FreeQmLrpcHandles;
void InitRpcGlobals() ;

//
// Type of Falcon machine (client, server)
//
DWORD  g_dwOperatingSystem;

//
// There is a separate rpc binding handle for each thread. This is necessary
// for handling impersonation, where each thread can impersonate another
// user.
//
// The handle is stored in a TLS slot because we can't use declspec(thread)
// because the dll is dynamically loaded (by LoadLibrary()).
//
// This is the index of the slot.
//
DWORD  g_hBindIndex = TLS_OUT_OF_INDEXES ;

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

//
// QMId variables
//
GUID  g_QMId;
bool g_fQMIdInit = false;


static handle_t RtpTlsGetValue(DWORD index)
{
	handle_t value = (handle_t)TlsGetValue(index);
	if(value != 0)
		return value;

	DWORD gle = GetLastError();
	if(gle == NO_ERROR)
		return 0;

    TrERROR(GENERAL, "Failed to get tls value, error %!winerr!", gle);
	throw bad_win32_error(gle);
}



static void OneTimeThreadInit()
{
	//
    //  Init per thread local RPC binding handle 
    //
	if(RtpIsThreadInit())
        return;

    handle_t hBind = RTpGetLocalQMBind();
    ASSERT(hBind != 0);
    
    //
    //  Keep handle for cleanup.
    //
	try
	{
		g_FreeQmLrpcHandles.Add(hBind);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to add rpc binding handle to cleanup list.");
		RpcBindingFree(&hBind);
		throw;
	}

    BOOL fSet = TlsSetValue(g_hBindIndex, hBind);
    if (fSet == 0)
    {
		DWORD gle = GetLastError();

		g_FreeQmLrpcHandles.Remove(hBind);

        TrERROR(GENERAL, "Failed to set TLS in thread init, error %!winerr!", gle);
		throw bad_win32_error(gle);
    }

    return;
}



static void RtpGetComputerName()
{
	if(g_lpwcsComputerName != NULL)
		return;

    g_dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> lpwcsComputerName = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
    HRESULT hr= GetComputerNameInternal(
        lpwcsComputerName,
        &g_dwComputerNameLen
        );

    if(FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to get computer name. %!hresult!", hr);
		ASSERT(0);
		throw bad_hresult(hr);
    }

    g_lpwcsComputerName = lpwcsComputerName.detach();
}




HRESULT
RtpQMGetMsmqServiceName(
    handle_t hBind,
    LPWSTR *lplpService
    )
{
	RpcTryExcept
	{
		return R_QMGetMsmqServiceName(hBind, lplpService);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		PRODUCE_RPC_ERROR_TRACING;
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}
	RpcEndExcept
}



static s_fDoneInitServiceName = false;

static void InitServiceName()
{ 
	if(s_fDoneInitServiceName)
		return;

	//
	// In multi-qm environment we want to access registry section
	// of the correct QM only. Cluster guarantees that this code runs
	// only when the correct QM is running, so we should not fail.
	// On non cluster systems it doesn't matter if we fail here. (ShaiK)
	//
	AP<WCHAR> lpServiceName;
	HRESULT hr = RtpQMGetMsmqServiceName(tls_hBindRpc, &lpServiceName );
	if (FAILED(hr))
	{
        TrERROR(GENERAL, "Failed to get service name for the msmq service, %!hresult!", hr);
		throw bad_hresult(hr);
	}

	SetFalconServiceName(lpServiceName);

	s_fDoneInitServiceName = true;
}



static 
HRESULT 
RtpQMAttachProcess(
    handle_t       hBind,
    DWORD          dwProcessId,
    DWORD          cInSid,
    unsigned char* pSid_buff,
    LPDWORD        pcReqSid)
{
	RpcTryExcept
	{
		return R_QMAttachProcess(hBind, dwProcessId, cInSid, pSid_buff, pcReqSid);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		PRODUCE_RPC_ERROR_TRACING;
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}
	RpcEndExcept
}

	
	
static void RtpGetKernelObjectSecurity(AP<char>& buff)
{
    DWORD cSD;
    HANDLE hProcess = GetCurrentProcess();

	//
	// Get the process security descriptor.
    // First see how big is the security descriptor.
	//
    GetKernelObjectSecurity(
		hProcess, 
		DACL_SECURITY_INFORMATION, 
		NULL, 
		0, 
		&cSD
		);

    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
        TrERROR(GENERAL, "Failed to get process security descriptor (NULL buffer), error %!winerr!", gle);
        LogNTStatus(gle, s_FN, 40);
		throw bad_win32_error(gle);
    }

    buff = new char[cSD];

	//
	// Get the process security descriptor.
	//
    if (!GetKernelObjectSecurity(
			hProcess, 
			DACL_SECURITY_INFORMATION, 
			(PSECURITY_DESCRIPTOR)buff.get(), 
			cSD, 
			&cSD
			))
    {
		DWORD gle = GetLastError();
        TrERROR(GENERAL, "Failed to get process security descriptor, error %!winerr!", gle);
		throw bad_win32_error(gle);
    }
}



static void ThrowGLEOnFALSE(BOOL flag)
{
	if(!flag)
	{
		DWORD gle = GetLastError();
		ASSERT(0);
		throw bad_win32_error(gle);
	}
}



static bool CanQMAccessProcess()
{
	DWORD cQMSid;
	handle_t hBindIndex = RtpTlsGetValue(g_hBindIndex);
	DWORD ProcessId = GetCurrentProcessId();

	HRESULT hr = RtpQMAttachProcess(
					hBindIndex, 
					ProcessId, 
					0, 
					(unsigned char*)&cQMSid, 
					&cQMSid
					);
	if (SUCCEEDED(hr))
	{
		//
		// This is a trick of the QM To signal us that it allready has access to this process.
		// no work to do!
		//
		return true;
	}

	if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
	{
		TrERROR(GENERAL, "Failed to get QM's sid. %!hresult!", hr);
		throw bad_hresult(hr);
	}

	return false;
}



static void GetQMSid(AP<unsigned char>& QmSid)
{
	DWORD cQMSid;
	handle_t hBindIndex = RtpTlsGetValue(g_hBindIndex);
	DWORD ProcessId = GetCurrentProcessId();

	//
	// Get the SID of the user account under which the QM is running.
	// First see how big is the SID.
	//
	HRESULT hr = RtpQMAttachProcess(
					hBindIndex, 
					ProcessId, 
					0, 
					(unsigned char*)&cQMSid, 
					&cQMSid
					);

	if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
	{
		if (SUCCEEDED(hr))
		{
			hr = MQ_ERROR_INVALID_PARAMETER; 
		}

		TrERROR(GENERAL, "Failed to get QM's sid, %!hresult!", hr);
		throw bad_hresult(hr);
	}

	QmSid = new unsigned char[cQMSid];
	
	//
	// Get the SID of the user account under which the QM is running.
	//
	hr = RtpQMAttachProcess(
			hBindIndex, 
			ProcessId, 
			cQMSid, 
			QmSid.get(), 
			&cQMSid
			);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to get QM's sid, %!hresult!", hr);
		throw bad_hresult(hr);
	}
}



void SetQMAccessToProcess()
{
	if(CanQMAccessProcess())
		return;

	//
    // Get the QM's sid.
	//
	AP<unsigned char> QmSid;
	GetQMSid(QmSid);
	
	//
	// Calculate the size of the new ACE.
	//
	DWORD dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid((PSID)QmSid.get()) - sizeof(DWORD);

	//
    // Get the process security descriptor.
	//
    AP<char> SecurityDescriptor;
    RtpGetKernelObjectSecurity(SecurityDescriptor);

	//
	// Get the DACL from the security descriptor.
	//
    BOOL fDaclPresent;
    PACL pDacl;
    BOOL fDaclDefaulted;
    BOOL bRet = GetSecurityDescriptorDacl((PSECURITY_DESCRIPTOR)SecurityDescriptor.get(), &fDaclPresent, &pDacl, &fDaclDefaulted);
    ThrowGLEOnFALSE(bRet);

    AP<char> pNewDacl;
	
	if (fDaclPresent)
    {
        ACL_SIZE_INFORMATION AclSizeInfo;
        bRet = GetAclInformation(pDacl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation);
        ThrowGLEOnFALSE(bRet);

        if (AclSizeInfo.AclBytesFree < dwAceSize)
        {
			//
            // The currect DACL is not large enough.
			//
 
			//
            // Initialize a new DACL.
			//
            DWORD dwNewDaclSize = AclSizeInfo.AclBytesInUse + dwAceSize;
			pNewDacl = new char[dwNewDaclSize];
            bRet = InitializeAcl((PACL)pNewDacl.get(), dwNewDaclSize, ACL_REVISION);
            ThrowGLEOnFALSE(bRet);

			//
            // Copy the current ACEs to the new DACL.
			//

			LPVOID pAce;
            bRet = GetAce(pDacl, 0, &pAce);
            ThrowGLEOnFALSE(bRet); 

            bRet = AddAce((PACL)pNewDacl.get(), ACL_REVISION, 0, pAce, AclSizeInfo.AclBytesInUse - sizeof(ACL));
            ThrowGLEOnFALSE(bRet);

            pDacl = (PACL)pNewDacl.get();
        }
    }
    else
    {
		//
        // The security descriptor does not contain a DACL. Prepare a new one
		//

        DWORD dwNewDaclSize = sizeof(ACL) + dwAceSize;
		pNewDacl = new char[dwNewDaclSize];

		//
        // Initialize the new DACL.
		//
        bRet = InitializeAcl((PACL)pNewDacl.get(), dwNewDaclSize, ACL_REVISION);
        ThrowGLEOnFALSE(bRet);

        pDacl = (PACL)pNewDacl.get();
    }

	//
    // Add a new ACE that gives permission for the QM to duplicatge handles for the
    // application.
	//
    bRet = AddAccessAllowedAce(pDacl, ACL_REVISION, PROCESS_DUP_HANDLE, (PSID)QmSid.get());
    ThrowGLEOnFALSE(bRet);

	//
    // Initialize a new absolute security descriptor.
	//
    SECURITY_DESCRIPTOR AbsSD;
    bRet = InitializeSecurityDescriptor(&AbsSD, SECURITY_DESCRIPTOR_REVISION);
    ThrowGLEOnFALSE(bRet);
	
	//
    // Set the DACL of the new absolute security descriptor.
	//
    bRet = SetSecurityDescriptorDacl(&AbsSD, TRUE, pDacl, FALSE);
    ThrowGLEOnFALSE(bRet);

	//
    // Set the security descriptor of the process.
	//
    HANDLE hProcess = GetCurrentProcess();
    if (!SetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, &AbsSD))
    {
		DWORD gle = GetLastError();
        TrERROR(GENERAL, "Failed to set process security descriptor, error %!winerr!", gle);
		throw bad_win32_error(gle);
    }
}



//---------------------------------------------------------
//
//  LPWSTR rtpGetComputerNameW()
//
//  Note: this function is exported, to be used by the control panel
//
//---------------------------------------------------------

LPWSTR rtpGetComputerNameW()
{
    return  g_lpwcsComputerName ;
}

//---------------------------------------------------------
//
//  FreeGlobals(...)
//
//  Description:
//
//      Release allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

extern TBYTE* g_pszStringBinding ;

static void FreeGlobals()
{
	if(g_hBindIndex != TLS_OUT_OF_INDEXES)
	{
		BOOL fFree = TlsFree( g_hBindIndex ) ;
		ASSERT(fFree) ;
		DBG_USED(fFree);
	}

	if(g_dwThreadEventIndex != TLS_OUT_OF_INDEXES)
	{
		BOOL fFree = TlsFree( g_dwThreadEventIndex ) ;
		ASSERT(fFree) ;
		DBG_USED(fFree);
	}

	if(g_pszStringBinding != NULL)
	{
		mqrpcUnbindQMService( NULL, &g_pszStringBinding) ;
	}

	if(g_hThreadIndex != TLS_OUT_OF_INDEXES)
	{
		BOOL fFree = TlsFree( g_hThreadIndex ) ;
		ASSERT(fFree) ;
		DBG_USED(fFree);
	}
  
    delete[] g_lpwcsComputerName;
    delete g_pSecCntx;
}

//---------------------------------------------------------
//
//  FreeThreadGlobals(...)
//
//  Description:
//
//      Release per-thread allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

static void  FreeThreadGlobals()
{
	if(g_dwThreadEventIndex != TLS_OUT_OF_INDEXES)
	{
	   HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
	   if (hEvent)
	   {
		  CloseHandle(hEvent) ;
	   }
	}

	if (g_hThreadIndex != TLS_OUT_OF_INDEXES)
	{
		HANDLE hThread = TlsGetValue(g_hThreadIndex);
		if ( hThread)
		{
			CloseHandle( hThread);
		}
	}

	if(g_hBindIndex != TLS_OUT_OF_INDEXES)
	{
		//
		//   Free this thread local-qm RPC binding handle
		//
		handle_t hLocalQmBind = TlsGetValue(g_hBindIndex);
		if (hLocalQmBind != 0)
		{
			g_FreeQmLrpcHandles.Remove(hLocalQmBind);
		}
	}
}

//---------------------------------------------------------
//
//  RTIsDependentClient(...)
//
//  Description:
//
//      Returns an internal indication whether this MSMQ client is a dependent client or not
//
//  Return Value:
//
//      True if a dependent client, false otherwise
//
//  Notes:
//
//      Used by mqoa.dll
// 
//---------------------------------------------------------

EXTERN_C
BOOL
APIENTRY
RTIsDependentClient()
{
    return g_fDependentClient;
}

//---------------------------------------------------------
//
//  RTpIsMsmqInstalled(...)
//
//  Description:
//
//      Check if MSMQ is installed on the local machine
//
//  Return Value:
//
//      TRUE if MSMQ is installed, FALSE otherwise
//
//---------------------------------------------------------
static
bool
RTpIsMsmqInstalled(
    void
    )
{
    WCHAR BuildInformation[255];
    DWORD type = REG_SZ;
    DWORD size = sizeof(BuildInformation) ;
    LONG rc = GetFalconKeyValue( 
                  MSMQ_CURRENT_BUILD_REGNAME,
				  &type,
				  static_cast<PVOID>(BuildInformation),
				  &size 
                  );

    return (rc == ERROR_SUCCESS);
}


void InitQMId()
{
	if(g_fQMIdInit)
		return;

	//
    // Read QMID. Needed for licensing.
    //
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue( MSMQ_QMID_REGNAME,
                            &dwValueType,
                            &g_QMId,
                            &dwValueSize);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(RPC, "Failed to read QM id. %!winerr!", rc);
		throw bad_hresult(HRESULT_FROM_WIN32(rc));
    }

    ASSERT((dwValueType == REG_BINARY) && (dwValueSize == sizeof(GUID)));

	g_fQMIdInit = true;
}

void SetAssertBenign(void)
{
#ifdef _DEBUG
    DWORD AssertBenignValue = 0;
    const RegEntry reg(L"Debug", L"AssertBenign");
    CmQueryValue(reg, &AssertBenignValue);
    g_fAssertBenign = (AssertBenignValue != 0);
#endif
}


void SetServiceQueueCreationFlag(void)
{
	//
	// g_fOnFailureCallServiceToCreatePublicQueue controls if the QM will create
	// public queues on behalf of local account. The default is FALSE
	//
    const RegEntry reg(L"", MSMQ_SERVICE_QUEUE_CREATION_REGNAME, MSMQ_SERVICE_QUEUE_CREATION_DEFAULT);
	DWORD dwValue;
    CmQueryValue(reg, &dwValue);
    g_fOnFailureCallServiceToCreatePublicQueue = (dwValue != 0);
}


static bool s_fInitCancelThread = false;

static void OneTimeInit()
{	
    //
    //  Allocate TLS index for synchronic event.
    //
	if(g_dwThreadEventIndex == TLS_OUT_OF_INDEXES)
	{
		g_dwThreadEventIndex = RtpTlsAlloc();
	}

    InitRpcGlobals();
    
	//
    // Initialize error logging
    //
    InitErrorLogging();

    //
    // RPC cancel is supported on NT only
    //
    if (!s_fInitCancelThread)
    {
		g_CancelRpc.Init();
		s_fInitCancelThread = true;
    }

    //
    // Get the cumputer name, we need this value in several places.
    //
	RtpGetComputerName();

    RTpInitXactRingBuf();

    g_dwOperatingSystem = MSMQGetOperatingSystem();

    OneTimeThreadInit();

	//
	// Service name can be initialized only after RPC binding are
	// ready. This is after OneTimeThreadInit()
	//
	InitServiceName();
    
	//
	// QMId can be correctly initialized only after service name
	// was initialized
	// 
	InitQMId();

	SetQMAccessToProcess();

    DWORD dwDef = g_dwTimeToReachQueueDefault ;
    READ_REG_DWORD(g_dwTimeToReachQueueDefault,
        MSMQ_LONG_LIVE_REGNAME,
        &dwDef ) ;

	CmInitialize(HKEY_LOCAL_MACHINE, GetFalconSectionName(), KEY_READ);
	SetAssertBenign();
	SetServiceQueueCreationFlag();
    
}

static CCriticalSection s_OneTimeInitLock(CCriticalSection::xAllocateSpinCount);
static bool s_fOneTimeInitSucceeded = false;

static void RtpOneTimeProcessInit()
{
	//
	// Singleton mechanism for OneTimeInit()
	//
	if(s_fOneTimeInitSucceeded)
		return;

	CS lock(s_OneTimeInitLock);
		
	if(s_fOneTimeInitSucceeded)
		return;

	OneTimeInit();
	s_fOneTimeInitSucceeded = true;

	return;
}


HRESULT RtpOneTimeThreadInit()
{
	ASSERT(!g_fDependentClient);

	try
	{
		RtpOneTimeProcessInit();
		OneTimeThreadInit();

		return MQ_OK;
	}
	catch(const bad_win32_error& err)
	{
		return HRESULT_FROM_WIN32(err.error());
	}
	catch(const bad_hresult& hr)
	{
		return hr.error();
	}
	catch(const bad_alloc&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}


bool 
RtpIsThreadInit()
{
    return (RtpTlsGetValue(g_hBindIndex) != 0);
}


static void RtpInitDependentClientFlag()
{
	WCHAR wszRemoteQMName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0} ;

	//
	// Read name of remote QM (if exist).
	//
	DWORD dwType = REG_SZ ;
	DWORD dwSize = sizeof(wszRemoteQMName) ;
	LONG rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
								 &dwType,
								 (PVOID) wszRemoteQMName,
								 &dwSize ) ;
	g_fDependentClient = (rc == ERROR_SUCCESS) ;
}




//---------------------------------------------------------
//
//  DllMain(...)
//
//  Description:
//
//      Main entry point to Falcon Run Time Dll.
//
//  Return Value:
//
//      TRUE on success
//
//---------------------------------------------------------

BOOL
APIENTRY
DllMain(
    HINSTANCE   hInstance,
    ULONG     ulReason,
    LPVOID            /*lpvReserved*/
    )
{
    switch (ulReason)
    {

        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            if (!RTpIsMsmqInstalled())
            {
                return FALSE;
            }

			g_hInstance = hInstance;

			//
			// Initialize static library
			//
			XdsInitialize();
			CryInitialize();
			FnInitialize();
			XmlInitialize();
			DldInitialize();

			RtpInitDependentClientFlag();

            return TRUE;
        }

        case DLL_PROCESS_DETACH:
			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			if(g_fDependentClient)
				return TRUE;

            //
            // First free whatever is free in THREAD_DETACH.
            //
            FreeThreadGlobals() ;

            FreeGlobals();

            //
            //  Terminate all working threads
            //
            if(s_fInitCancelThread)
			{
				ShutDownDebugWindow();
			}

            WPP_CLEANUP();
            
			return TRUE;

        case DLL_THREAD_ATTACH:
			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			return TRUE;

        case DLL_THREAD_DETACH:
			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			if(g_fDependentClient)
				return TRUE;

            FreeThreadGlobals() ;
            return TRUE;
    }
	return TRUE;
}

void InitErrorLogging()
{
	static bool s_fBeenHere = false;
	if(s_fBeenHere)
		return;

	s_fBeenHere = true;
	TrPRINT(GENERAL, "*** MSMQ v%s Application started as '%ls' ***", g_szMsmqBuildNo, GetCommandLine());
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, hr));
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, status));
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, status));
	TrERROR(LOG, "%ls(%u), RPC STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, b));
	TrERROR(LOG, "%ls(%u), BOOL: 0x%x", wszFileName, usPoint, b);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	KEEP_ERROR_HISTORY((wszFileName, usPoint, 0));
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}

void LogIllegalPointValue(DWORD_PTR dw3264, LPCWSTR wszFileName, USHORT usPoint)
{
	KEEP_ERROR_HISTORY((wszFileName, usPoint, 0));
	TrERROR(LOG, "%ls(%u), Illegal point Value=%Ix", wszFileName, usPoint, dw3264);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtctxex.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtctxex.cpp

Abstract:

    This module implements the MQGetSecurityContextEx().

Author:

    Doron Juster (DoronJ)  13-Apr-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <mqsec.h>
#include <rtdep.h>

#include "rtctxex.tmh"

static WCHAR *s_FN=L"rt/rtctxex";

BOOL     SameAsProcessSid( PSID pSid ) ; // from rtsecctx.cpp
HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx) ;

/***********************************************************************
*
*   Function - MQGetSecurityContextEx()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in MQSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of MQSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to MQSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call MQFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
MQGetSecurityContextEx( LPVOID  lpCertBuffer,
                        DWORD   dwCertBufferLength,
                        HANDLE *phSecurityContext )
{
	if(g_fDependentClient)
		return DepGetSecurityContextEx(lpCertBuffer, dwCertBufferLength, phSecurityContext);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    //
    // the line below may throw bad_alloc on win64, like the allocation above.
    // we return a HANDLE that can be safely cast to 32 bits (for VT_I4 property
    // PROPID_M_SECURITY_CONTEXT).
    //
    HANDLE hSecurityContext = (HANDLE) DWORD_TO_HANDLE(
        ADD_TO_CONTEXT_MAP(g_map_RT_SecCtx, (PMQSECURITY_CONTEXT)pSecCtx));

    P<BYTE>    pSid = NULL ;
    CHCryptKey hKey = NULL ;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert, lpCertBuffer, dwCertBufferLength);
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = MQSec_GetThreadUserSid( 
                FALSE, 
                reinterpret_cast<PSID*>(&pSid),
                &dwLen,
                FALSE           // fThreadTokenOnly
                ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 90);
        }

        BOOL fAsProcess = SameAsProcessSid( pSid ) ;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        hr  = GetCertInfo(  !fAsProcess,
                            pSecCtx->fLocalSystem,
		        			ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert,
                           &pSecCtx->dwPrivateKeySpec ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return LogHR(hr, s_FN, 120);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail MQGetSecurityContext().
            // MQSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return LogHR(hr, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtmgmt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rtmgmt.cpp

Abstract:

    Management.

Author:

    RaphiR

Revision History:

--*/

#include "stdh.h"
#include "fntoken.h"
#include "mgmtrpc.h"
#include "qmmgmt.h"
#include "rtprpc.h"
#include <mqutil.h>
#include <rtdep.h>

#include "rtmgmt.tmh"

static WCHAR *s_FN=L"rt/rtmgmt";

//---------------------------------------------------------
//
//  Function:
//      RTpMgmtObjectNameToMgmtObject
//
//  Description:
//      Convert a format name string to a Management Object union.
//
//    This function allocates a MGMT_OBJECT, which must
//    be free with RTpMgmtFreeMgmtObject function
//
//---------------------------------------------------------
static
BOOL
RTpMgmtObjectNameToMgmtObject(
    LPCWSTR lpwstrObjectName,
    LPWSTR* ppStringToFree,
    MGMT_OBJECT* pObj,
    QUEUE_FORMAT* pqf
    )
{

    //
    // Handle MACHINE= case
    //
    if(_wcsnicmp(lpwstrObjectName, MO_MACHINE_TOKEN, STRLEN(MO_MACHINE_TOKEN)) == 0)
    {
        pObj->type = MGMT_MACHINE;
        pObj->dwMachineInfo = 0;
        return TRUE;
    }

    //
    // Handle QUEUE= case
    // 
    if(_wcsnicmp(lpwstrObjectName, MO_QUEUE_TOKEN, STRLEN(MO_QUEUE_TOKEN)) == 0)
    {
        pObj->type = MGMT_QUEUE;
        pObj->pQueueFormat = pqf;
        return FnFormatNameToQueueFormat(
                    &lpwstrObjectName[STRLEN(MO_QUEUE_TOKEN) + 1],
                    pqf,
                    ppStringToFree
                    );
    }

    return FALSE;
}


//---------------------------------------------------------
//
//  Function:
//      GetRpcClientHandle
//
//  Description:
//      
//---------------------------------------------------------
static 
HRESULT 
GetRpcClientHandle(   
    handle_t* phBind
    )
{
	WCHAR *wcsStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,
                                                 QMMGMT_PROTOCOL,
                                                 NULL,
                                                 g_pwzQmmgmtEndpoint,
                                                 QMMGMT_OPTIONS,
                                                 &wcsStringBinding);
    if (status != RPC_S_OK)
    {
		TrERROR(RPC, "RpcStringBindingCompose failed. Error: %!winerr!", status);
    	return HRESULT_FROM_WIN32(status);
    }

    status = RpcBindingFromStringBinding(wcsStringBinding, phBind);
    
	RpcStringFree(&wcsStringBinding);
	
    if (status != RPC_S_OK)
    {
	    TrERROR(RPC, "RpcBindingFromStringBinding failed. Error: %!winerr!", status);
        return HRESULT_FROM_WIN32(status);
    }
    return MQ_OK;
}


static
HRESULT
RTpMgmtAction(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    LPCWSTR pAction
    )
{
    RpcTryExcept
    {
    	HRESULT hr = R_QMMgmtAction(
                hBind,
                pMgmtObj, 
                pAction
                );
        return LogHR(hr, s_FN, 40);
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        HRESULT rc;
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 50); 
        PRODUCE_RPC_ERROR_TRACING;

        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
	RpcEndExcept
}


HRESULT
LocalMgmtAction(
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Get local  RPC binding Handle
    //
    HRESULT hr ;
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtAction(
                hBind,
                pMgmtObj,
                pAction
                );

    RpcBindingFree(&hBind);

    return LogHR(hr, s_FN, 70);
}


HRESULT
RemoteMgmtAction(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Call remote administrator
    //
    HRESULT hr;
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtAction(hBind, pMgmtObj, pAction)
        );

    return LogHR(hr, s_FN, 80);
}


EXTERN_C
HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    )
{
	if(g_fDependentClient)
		return DepMgmtAction(pMachineName, pObjectName, pAction);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;



    ASSERT(pObjectName);
    ASSERT(pAction);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    try
    {
    	if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
	    {
	        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 90);
	    }
    }
    catch(const exception&)
    {
    	TrERROR(GENERAL, "RTpMgmtObjectNameToMgmtObject threw an exception");
    	return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    CMQHResult rc;
    if (pMachineName == NULL)
    {
        rc = LocalMgmtAction(&MgmtObj, pAction);
        return LogHR(rc, s_FN, 100);
    }
    else
    {
        rc = RemoteMgmtAction(pMachineName, &MgmtObj, pAction);
        return LogHR(rc, s_FN, 110);
    }
}


static
HRESULT
RTpMgmtGetInfo(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    MQMGMTPROPS* pMgmtProps
    )
{
    RpcTryExcept
    {
        HRESULT hr = R_QMMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps->cProp,
                pMgmtProps->aPropID,
                pMgmtProps->aPropVar
                );
        return LogHR(hr, s_FN, 120);

    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        HRESULT rc;
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 130); 
        PRODUCE_RPC_ERROR_TRACING;

        if(SUCCEEDED(rc))
        {
            return LogHR(MQ_ERROR_SERVICE_NOT_AVAILABLE, s_FN, 140);
        }

        return rc;
    }
	RpcEndExcept
}


static
HRESULT
LocalMgmtGetInfo(
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr ;

    //
    // Get local  RPC binding Handle
    //
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 150);
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps
                );

    RpcBindingFree(&hBind);

    return LogHR(hr, s_FN, 160);
}


static
HRESULT
RemoteMgmtGetInfo(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr;

    //
    // Call remote administrator
    //
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtGetInfo(hBind, pMgmtObj, pMgmtProps)
        );

    return LogHR(hr, s_FN, 170);
}


EXTERN_C
HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    )
{
	if(g_fDependentClient)
		return DepMgmtGetInfo(pMachineName, pObjectName, pMgmtProps);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;


    ASSERT(pObjectName);
    ASSERT(pMgmtProps);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    try
    {
    	if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
	    {
	        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 180);
	    }
    }
    catch(const exception&)
    {
	    TrERROR(GENERAL, "RTpMgmtObjectNameToMgmtObject threw an exception");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure the propvar is set to VT_NULL 
    // (we dont support anything else)
    //
    memset(pMgmtProps->aPropVar, 0, pMgmtProps->cProp * sizeof(PROPVARIANT));
    for (DWORD i = 0; i < pMgmtProps->cProp; ++i)
    {
        pMgmtProps->aPropVar[i].vt = VT_NULL;
    }

	CMQHResult rc;
    if (pMachineName == NULL)
    {
        rc = LocalMgmtGetInfo(&MgmtObj, pMgmtProps);
        return LogHR(rc, s_FN, 190);
    }
    else
    {
        rc = RemoteMgmtGetInfo(pMachineName, &MgmtObj, pMgmtProps);
        return LogHR(rc, s_FN, 200);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtintcrt.cpp ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    rtintcrt.h

Abstract:

    Create and delete an internal certificate.

Author:

    Original code from MSMQ1.0 rt, then MSMQ2.0 cpl.
    Doron Juster  (DoronJ)  20-Aug-1998

--*/

#include "stdh.h"
#include <mqutil.h>
#include <rtcert.h>
#include <rtdepcert.h>
#include <mqsec.h>
#include <rtdep.h>
#include "rtputl.h"

#include "rtintcrt.tmh"

static WCHAR *s_FN=L"rt/rtintcrt";

//
// exported from mqrt.dll
//
LPWSTR rtpGetComputerNameW() ;


static CAutoCloseRegHandle s_hMqUserReg;
static bool s_fInitialize = false;

static HKEY GetUserRegHandle()
/*++

Routine Description:
    Get handle to msmq user key.

Arguments:
	None

Return Value:
	HKEY
--*/
{
	if(s_fInitialize)
	{
		return s_hMqUserReg;
	}

    DWORD dwDisposition;
    LONG lRes = RegCreateKeyEx( 
						FALCON_USER_REG_POS,
						FALCON_USER_REG_MSMQ_KEY,
						0,
						TEXT(""),
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&s_hMqUserReg,
						&dwDisposition 
						);

    ASSERT(lRes == ERROR_SUCCESS);
	if(lRes == ERROR_SUCCESS)
	{
		s_fInitialize = true;
	}

	return s_hMqUserReg;
}


static 
DWORD 
GetDWORDKeyValue(
	LPCWSTR RegName
	)
/*++

Routine Description:
    Read DWORD registry key.

Arguments:
	RegName - Registry name (under HKLU\msmq)

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    DWORD dwValue = 0;
    HKEY hMqUserReg = GetUserRegHandle();
    if (hMqUserReg != NULL)
    {
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(dwValue);
        LONG lRes = RegQueryValueEx( 
						hMqUserReg,
						RegName,
						0,
						&dwType,
						(LPBYTE) &dwValue,
						&dwSize 
						);

        if (lRes != ERROR_SUCCESS)
        {
            return 0;
        }
    }
	return dwValue;
}



static 
void 
SetDWORDKeyValue(
	 LPCWSTR RegName, 
	 DWORD Value
	 )
/*++

Routine Description:
    Set DWORD registry key value.

Arguments:
	RegName - Registry name (under HKLU\msmq)
	Value - the value to set

Return Value:
	None
--*/
{
    HKEY hMqUserReg = GetUserRegHandle();
    if (hMqUserReg != NULL)
    {
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(Value);

		LONG lRes = RegSetValueEx( 
						hMqUserReg,
						RegName,
						0,
						dwType,
						(LPBYTE) &Value,
						dwSize 
						);

		DBG_USED(lRes);
		ASSERT(lRes == ERROR_SUCCESS);
		TrTRACE(SECURITY, "Set registry %ls = %d", RegName, Value);
	}
}



static bool ShouldRegisterCertInDs()
/*++

Routine Description:
    Check if SHOULD_REGISTERD_IN_DS_REGNAME is Set.

Arguments:
	None

Return Value:
	true if CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME is set.
--*/
{
	DWORD ShouldRegisterdInDs = GetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME);
	return (ShouldRegisterdInDs != 0);
}



//---------------------------------------------------------
//
//  Function:
//      _GetUserAccountNameAndDomain(
//
//  Parameters:
//     fLocalSyste - TRUE if called in the context of a localSystem service.
//     szAccountName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the account name of the user of the
//         current thread.
//     szDomainName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the domain name of the user of the
//         current thread.
//
//  Description:
//     The function allocates and fills two buffers, one for the account name
//     of the user of the current thread, and the second buffer for the
//     domain name of the user of the current thread.
//
//---------------------------------------------------------

static HRESULT
_GetUserAccountNameAndDomain( IN BOOL    fLocalSystem,
                              IN LPTSTR *szAccountName,
                              IN LPTSTR *szDomainName )
{
    HRESULT hr = MQ_OK;
    TCHAR   szLocAccountName[64];
    DWORD   dwLocAccountNameLen = sizeof(szLocAccountName) /
                                         sizeof(szLocAccountName[0]) ;
    LPTSTR  pszLocAccountName = szLocAccountName;
    P<TCHAR>  pszLocLongAccountName = NULL;
    TCHAR   szLocDomainName[64];
    DWORD   dwLocDomainNameLen = sizeof(szLocDomainName) /
                                             sizeof(szLocDomainName[0]) ;
    LPTSTR  pszLocDomainName = szLocDomainName;
    P<TCHAR>  pszLocLongDomainName = NULL;

    P<BYTE>  pbSidAR = NULL ;
    DWORD   dwSidLen;

    try
    {
        //
        // Win NT.
        //
        PSID pSid = NULL ;

        if (fLocalSystem)
        {
            pSid = MQSec_GetLocalMachineSid( FALSE, NULL ) ;
            if (!pSid)
            {
                return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 10);
            }
        }
        else
        {
            //
            // Get the SID of the user of the current thread.
            //
            hr = MQSec_GetThreadUserSid(
                        FALSE,
                        reinterpret_cast<PSID*>(&pbSidAR), 
                        &dwSidLen,
                        FALSE           // fThreadTokenOnly
                        );
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 20);
            }
            pSid = pbSidAR ;
        }

        SID_NAME_USE eUse;
        //
        //  Try to get the account and domain names in to a
        //  fixed size buffers.
        //
        if (!LookupAccountSid( NULL,
                               pSid,
                               pszLocAccountName,
                               &dwLocAccountNameLen,
                               pszLocDomainName,
                               &dwLocDomainNameLen,
                               &eUse))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // The fixed size buffer are not large enough.
                // Allocate larger buffers.
                //
                if (dwLocAccountNameLen > (sizeof(szLocAccountName) /
                                           sizeof(szLocAccountName[0])))
                {
                    pszLocLongAccountName =
                                     new TCHAR[ dwLocAccountNameLen ];
                    pszLocAccountName = pszLocLongAccountName;
                }

                if (dwLocDomainNameLen > (sizeof(szLocDomainName) /
                                          sizeof(szLocDomainName[0])))
                {
                    pszLocLongDomainName = new TCHAR[ dwLocDomainNameLen ];
                    pszLocDomainName = pszLocLongDomainName;
                }

                //
                // Re-call LookupAccountSid, now with the lrger buffer(s).
                //
                if (!LookupAccountSid(  NULL,
                                        pSid,
                                        pszLocAccountName,
                                       &dwLocAccountNameLen,
                                        pszLocDomainName,
                                       &dwLocDomainNameLen,
                                       &eUse ))
                {
                    return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 30);
                }
            }
            else
            {
                return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 40);
            }
        }

        //
        // Allocate the buffers for the returned results, and fill the
        // allocated buffer with the result strings.
        //
        *szAccountName = new TCHAR[ dwLocAccountNameLen + 1 ];
        _tcscpy(*szAccountName, pszLocAccountName);

        *szDomainName = new TCHAR[ dwLocDomainNameLen + 1 ];
        _tcscpy(*szDomainName, pszLocDomainName);
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 60);
    }

    return LogHR(hr, s_FN, 70);
}

/*************************************************************************

  Function:
     RTCreateInternalCertificate

  Parameters -
    ppCert - On return, get the certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the store already contain a certificate, the function falis.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTCreateInternalCertificate(
    OUT CMQSigCertificate **ppCert
    )
{
	if(g_fDependentClient)
		return DepCreateInternalCertificate(ppCert);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 75);
	}

    HRESULT hr;
    BOOL fLocalUser;
    BOOL fLocalSystem;
    BOOL fNetworkService;

    if (ppCert)
    {
        *ppCert = NULL;
    }

    //
    // Local users are not let in.
    //
    hr = MQSec_GetUserType( 
				NULL,
				&fLocalUser,
				&fLocalSystem,
				&fNetworkService
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }
    if (fLocalUser)
    {
	    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90);
    }

    LONG nCerts;
    R<CMQSigCertStore> pStore ;
    //
    // Get the internal certificate store.
    //
    hr = RTOpenInternalCertStore( &pStore.ref(),
                                  &nCerts,
                                  TRUE,
                                  fLocalSystem,
                                  FALSE ) ;  // fUseCurrentUser
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    if (nCerts)
    {
        return LogHR(MQ_ERROR_INTERNAL_USER_CERT_EXIST, s_FN, 110);
    }
    HCERTSTORE  hStore = pStore->GetHandle() ;

    //
    // Get the user's account name and domain name.
	// LocalSystem and NetworkService gets the machine$ name
    //
    AP<TCHAR> szAccountName;
    AP<TCHAR> szDomainName;

    hr = _GetUserAccountNameAndDomain( 
				fLocalSystem || fNetworkService,
				&szAccountName,
				&szDomainName 
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    //
    // Get the name of the computer.
	// Always get the physical node name.
    //
    #define COMPUTER_NAME_LEN  256
    WCHAR szHostNameW[COMPUTER_NAME_LEN];
    DWORD dwHostNameLen = sizeof(szHostNameW) / sizeof(szHostNameW[0]) ;

	if(!GetComputerNameEx(ComputerNamePhysicalNetBIOS, szHostNameW, &dwHostNameLen))
    {
        return LogHR(MQ_ERROR, s_FN, 190);
    }
    CharLower(szHostNameW);

    AP<TCHAR> szComputerName = new TCHAR[dwHostNameLen + 2];
#ifdef UNICODE
    wcscpy(szComputerName, szHostNameW) ;
#else
    SecConvertFromWideCharString(szHostNameW,
                                 szComputerName,
                                 (dwHostNameLen + 2)) ;
#endif

    R<CMQSigCertificate> pSigCert = NULL ;
    hr = MQSigCreateCertificate (&pSigCert.ref()) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }
    else if (pSigCert.get() == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 210);
    }

    hr = pSigCert->PutValidity( INTERNAL_CERT_DURATION_YEARS ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    hr = pSigCert->PutIssuer( MQ_CERT_LOCALITY,
                              _T("-"),
                              _T("-"),
                              szDomainName,
                              szAccountName,
                              szComputerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }

    hr = pSigCert->PutSubject( MQ_CERT_LOCALITY,
                               _T("-"),
                               _T("-"),
                               szDomainName,
                               szAccountName,
                               szComputerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }

    //
    // When renewing the internal certificate, always renew the
    // private/public keys pair.
    //
    BOOL fCreated = FALSE ;
    hr = pSigCert->PutPublicKey( TRUE,
                                 fLocalSystem,
                                &fCreated) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 250);
    }
    ASSERT(fCreated) ;

    hr = pSigCert->EncodeCert( fLocalSystem,
                               NULL,
                               NULL) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    hr = pSigCert->AddToStore(hStore) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    if (ppCert)
    {
        *ppCert = pSigCert.detach();
    }

    return(MQ_OK);
}

/*************************************************************************

  Function:
     RTDeleteInternalCert( IN CMQSigCertificate *pCert )

  Parameters -
    pCert - Certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTDeleteInternalCert(
    IN CMQSigCertificate *pCert
    )
{
	if(g_fDependentClient)
		return DepDeleteInternalCert(pCert);

	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = pCert->DeleteFromStore() ;
    return LogHR(hr, s_FN, 280);
}


static
HRESULT
MQpRegisterCertificate( 
	IN DWORD   dwFlags,
	IN PVOID   lpCertBuffer,
	IN DWORD   dwCertBufferLength 
	)
{
	if(g_fDependentClient)
		return DepRegisterCertificate(
					dwFlags, 
					lpCertBuffer, 
					dwCertBufferLength
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		TrERROR(SECURITY, "register certificate is not supported in workgroup mode");
		return MQ_ERROR_UNSUPPORTED_OPERATION;
	}

    //
    // First check validity of input parameters.
    //
    if (lpCertBuffer)
    {
        if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
        {
            //
            // The "if_not_exist" flag is relevant only for internal
            // certificate, because we create it.
            //
			TrERROR(SECURITY, "MQCERT_REGISTER_IF_NOT_EXIST flag is valid only for Internal certificate");
            return MQ_ERROR_INVALID_PARAMETER;
        }
        else if (dwCertBufferLength == 0)
        {
            //
            // Length must be specified for the external certificate.
            //
			TrERROR(SECURITY, "Invalid parameter, dwCertBufferLength = 0");
            return MQ_ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Next, check if local user. They are not let in. the SID of a local
    // user is not meaningful outside of his local machine. There is no
    // user object in the DS for a local user, so we don't have a place to
    // register his certificate.
    //
    BOOL fLocalUser =  FALSE;
    BOOL fLocalSystem = FALSE;
    BOOL fNetworkService = FALSE;

    hr = MQSec_GetUserType( 
				NULL,
				&fLocalUser,
				&fLocalSystem,
				&fNetworkService
				);

    if (FAILED(hr))
    {
		TrERROR(SECURITY, "MQSec_GetUserType failed, %!hresult!", hr);
        return hr;
    }
    else if (fLocalUser)
    {
		TrERROR(SECURITY, "register certificate is not supported for local user");
	    return MQ_ERROR_ILLEGAL_USER;
    }

	TrTRACE(SECURITY, "UserType: LocalSystem = %d, NetworkService = %d", fLocalSystem, fNetworkService);

    //
    // Next, check if an internal certificate already exist.
    //

    R<CMQSigCertStore> pStore = NULL;
    if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
    {
        LONG nCerts = 0;
        hr = RTOpenInternalCertStore( 
					&pStore.ref(),
					&nCerts,
					TRUE,
					fLocalSystem,
					FALSE   // fUseCurrectUser
					);
        if (FAILED(hr))
        {
			TrERROR(SECURITY, "Failed to open internal store, %!hresult!", hr);
            return hr;
        }
        else if ((nCerts) && !ShouldRegisterCertInDs())
        {
            //
            // OK, we already have an internal certificate and it is register in the DS.
            //
			TrTRACE(SECURITY, "internal user certificate already exist in the local store and is registered in the DS");
            return MQ_INFORMATION_INTERNAL_USER_CERT_EXIST;
        }

		TrTRACE(SECURITY, "number of certificate that were found in the local store = %d", nCerts);
        pStore.free();
    }

    BOOL fIntCreated = FALSE;
    R<CMQSigCertificate> pCert = NULL;
    if (!lpCertBuffer)
    {
        //
        // Creating an internal certificate also mean to recreate the user
        // private key. So before destroying previous keys, let's check
        // if the user has permission to register his certificate and if
        // local machine can access the DS at present. We'll do this by
        // trying to register previous internal certificate.
        //
        // Open the certificates store with write access, so we can later
        // delete the internal certificate, before creating a new one.
        //
        hr = RTGetInternalCert( 
					&pCert.ref(),
					&pStore.ref(),
					TRUE,
					fLocalSystem,
					FALSE	//  fUseCurrentUser 
					);  

        if (SUCCEEDED(hr))
        {
            //
            // Try to register in the DS.
			// LocalSystem and NetworkService consider as machine$ for the DS
            //
    		hr = RTRegisterUserCert( 
						pCert.get(),
						fLocalSystem || fNetworkService	// fMachine
						);

			if(FAILED(hr) && (hr != MQ_ERROR_INTERNAL_USER_CERT_EXIST))
	    	{
				TrERROR(SECURITY, "register user certificate in the DS failed, %!hresult!", hr);
                return hr;
    		}

            //
            // Remove the internal certificate from MQIS.
            //
            hr = RTRemoveUserCert(pCert.get()) ;
            if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
            {
				TrERROR(SECURITY, "Failed to remove user certificate from the DS, %!hresult!", hr);
                return hr;
            }
            //
            // Remove the internal certificate from the local certificate
            // store.
            //
            hr = RTDeleteInternalCert(pCert.get());
            if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
            {
				//
				// The certificate was deleted from the DS
				// but we failed to delete it from the local store
				// so we should try again to register the certificate
				// Mark that we have a certificate in the local store that is not registered in the DS
				//
				SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, true);
				TrERROR(SECURITY, "Failed to delete internal user certificate from local store, %!hresult!", hr);
                return hr;
            }

            pCert.free();
        }

        //
        // It's time to create the internal certificate.
        //
        ASSERT(pCert.get() == NULL);
        hr = RTCreateInternalCertificate(&pCert.ref());
		if (FAILED(hr))
		{
			TrERROR(SECURITY, "Failed to create internal certificate, %!hresult!", hr);
			return hr;
		}

        fIntCreated = TRUE;
    }
    else
    {
        hr = MQSigCreateCertificate( 
					&pCert.ref(),
					NULL,
					(LPBYTE) lpCertBuffer,
					dwCertBufferLength 
					);
		if (FAILED(hr))
		{
			TrERROR(SECURITY, "MQSigCreateCertificate() failed, %!hresult!", hr);
			return hr;
		}
    }

    if (lpCertBuffer == NULL)
    {
		//
		// For internal certificate, reset SHOULD_REGISTERD_IN_DS flag before 
		// the actual certificate register in the DS succeeded.
		// This is for the following rare crash scenario:
		// 1) Register the certificate in the DS completed
		// 2) SHOULD_REGISTERD_IN_DS was true
		// 3) We crashed
		// in that case setting the registry before the actual writing to the DS
		// will make sure that next time we will not create a new certificate.
		//
		SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, false);
	}

	//
	// LocalSystem and NetworkService consider as machine$ for the DS
	//
	hr = RTRegisterUserCert(
			pCert.get(), 
			fLocalSystem || fNetworkService	// fMachine
			);
    if (SUCCEEDED(hr) && (lpCertBuffer == NULL))
    {
		TrERROR(SECURITY, "Certificate registered successfully in the DS");
	    return LogHR(hr, s_FN, 395);
    }

	if (fIntCreated)
    {
		ASSERT(FAILED(hr));

        //
        // We created a new certificate in registry but failed to register
        // it in DS. delete from local registry.
        //
		TrERROR(SECURITY, "We failed to register internal certificate in the DS, hr = 0x%x", hr);
        pCert.free();
        pStore.free();

        HRESULT hr1 = RTGetInternalCert( 
							&pCert.ref(),
							&pStore.ref(),
							TRUE,
							fLocalSystem,
							FALSE   // fUseCurrentUser
							);
        if (SUCCEEDED(hr1))
        {
            hr1 = RTDeleteInternalCert(pCert.get());
        }

        ASSERT(SUCCEEDED(hr1));

		if (FAILED(hr1))
		{
			//
			// We failed to register the certificate in the DS
			// but also failed to delete it from the local store
			// so we should try again.
			// Mark that we have a certificate in the local store that is not registered in the DS
			//
			SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, true);
			TrERROR(SECURITY, "Failed to delete internal certificate from local store");
		}
    }

    return LogHR(hr, s_FN, 400);
}


//+------------------------------------------------------------------------
//
//  MQRegisterCertificate()
//
//  Description: Create an internal certificate and register it in the DS.
//
//  Input:
//      IN DWORD   dwFlags- one of the followings:
//          MQCERT_REGISTER_IF_NOT_EXIST- create a new internal certificate
//              only if there is not a previous one on local machine. The
//              test for existing certificate is local and no access to
//              remote DS server is made. So this check can be safely made
//              if machine is offline, without hanging it.
//      IN PVOID   lpCertBuffer- NULL for internal certificate.
//          Otherwise, pointer to external certificate buffer. In this case,
//          the api only register the external certificate in the DS and
//          flag "MQCERT_REGISTER_IF_NOT_EXIST" must not be specified.
//      IN DWORD   dwCertBufferLength- Size, in bytes, of buffer of external
//          certificate.
//
//+------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQRegisterCertificate( 
	IN DWORD   dwFlags,
	IN PVOID   lpCertBuffer,
	IN DWORD   dwCertBufferLength 
	)
{
	CMQHResult rc;
    __try
    {
        rc = MQpRegisterCertificate( 
		   		dwFlags,
			    lpCertBuffer,
			    dwCertBufferLength 
				);
	}
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The exception is due to invalid parameter
        //
        rc = GetExceptionCode();
    }

	if(FAILED(rc))
	{
		TrERROR(SECURITY, "Failed to register certificate. %!hresult!", rc);
	}

	return rc;
}


//+-------------------------------------------------------------------------
//
//  HRESULT RTLogOnRegisterCert()
//
//  logon register certificate operation
//  This code is called directly by the cluster that simulate "msmq logon" code
//  on every online.
//
//+-------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
RTLogOnRegisterCert(
	bool fRetryDs
	)
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup do nothing
		// This enable setup to always insert regsvr32 command in the "run" registry
		// regardless of workgroup or domain.
		//
		return MQ_OK;
	}

    //
    // First see if auto registration was disabled by user.
    //
    DWORD dwEnableRegister = DEFAULT_AUTO_REGISTER_INTCERT;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwEnableRegister);
    LONG rc = GetFalconKeyValue( 
					AUTO_REGISTER_INTCERT_REGNAME,
					&dwType,
					&dwEnableRegister,
					&dwSize 
					);

    if ((rc == ERROR_SUCCESS) && (dwEnableRegister == 0))
    {
		TrTRACE(SECURITY, "enable register internal certificate is blocked by registry key");
        return MQ_OK;
    }

    //
    // Next see if auto-registration was already done for this user
    //
    DWORD dwRegistered = GetDWORDKeyValue(CERTIFICATE_REGISTERD_REGNAME);
    if (dwRegistered == INTERNAL_CERT_REGISTERED)
    {
        //
        // Certificate already registered.
        //
		TrTRACE(SECURITY, "Internal certificate already registered");
        return MQ_OK;
    }

    //
    // Read number of 15 seconds intervals to wait for MSMQ DS server.
    //
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwDef = DEFAULT_AUTO_REGISTER_WAIT_DC;
    DWORD dwWaitIntervals = DEFAULT_AUTO_REGISTER_WAIT_DC;

    READ_REG_DWORD( 
			dwWaitIntervals,
			AUTO_REGISTER_WAIT_DC_REGNAME,
			&dwDef 
			);

    //
    // OK, now it's time to resiter the certificate.
    //
    DWORD iCount = 0;
    BOOL  fTryAgain = FALSE;
    HRESULT hr = MQ_OK;

    do
    {
        fTryAgain = FALSE;
        hr = MQRegisterCertificate( 
				MQCERT_REGISTER_IF_NOT_EXIST,
				NULL,
				0 
				);

        if (SUCCEEDED(hr))
        {
            //
            // Save success status in registry.
            //
			SetDWORDKeyValue(CERTIFICATE_REGISTERD_REGNAME, INTERNAL_CERT_REGISTERED);
        }
        else if ((hr == MQ_ERROR_NO_DS) && fRetryDs)
        {
            //
            // MSMQ DS server not yet found.
            // wait 15 seconds and try again.
            //
            if (iCount < dwWaitIntervals)
            {
                iCount++;
                Sleep(15000);
                fTryAgain = TRUE;
            }
        }
    } while (fTryAgain);

    if (FAILED(hr))
    {
		SetDWORDKeyValue(AUTO_REGISTER_ERROR_REGNAME, hr); 
		TrERROR(SECURITY, "MQRegisterCertificate failed hr = 0x%x", hr);
	}

    return MQ_OK;
}


//+-------------------------------------------------------------------------
//
//  STDAPI DllRegisterServer()
//
//  this code is run on every logon, from regsvr32. It's the reponsibility
//  of setup to insert the regsvr32 command in the "run" registry. This
//  code will register an internal certificate for each new domain user
//  that logon the machine.
//
//+-------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
	if(g_fDependentClient)
		return DepRegisterServer();

	return RTLogOnRegisterCert(
				true	// fRetryDs
				);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtprpc.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rtprpc.h

Abstract:

    RT DLL, RPC related stuff.

Author:

    Doron Juster  (DoronJ)  18-Nov-1996

--*/

#ifndef __RTPRPC_H
#define __RTPRPC_H

#include "_mqrpc.h"
#include "mqsocket.h"
#include "cancel.h"
#include <mqsec.h>

//
//  Cancel RPC globals
//
extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;
extern DWORD g_hThreadIndex;
#define tls_hThread  ((handle_t) TlsGetValue( g_hThreadIndex ))


//
// Local endpoints to QM
//
extern AP<WCHAR> g_pwzQmsvcEndpoint;
extern AP<WCHAR> g_pwzQmmgmtEndpoint;

/*====================================================

RegisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/

inline  void RegisterRpcCallForCancel(IN  HANDLE  *phThread,
                                      IN  DWORD    dwRecvTimeout )
{
    handle_t hThread = tls_hThread;
    if ( hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
            GetCurrentProcess(),
            hT,
            GetCurrentProcess(),
            &hThread,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
        ASSERT( fResult == TRUE);
        ASSERT(hThread);

        fResult = TlsSetValue( g_hThreadIndex, hThread);
        ASSERT( fResult == TRUE);

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status;
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT( status == RPC_S_OK);

    }
    *phThread = hThread;
    //
    //  Register the thread
    //
    TIME32 tPresentTime = DWORD_PTR_TO_DWORD(time(NULL)) ;
    TIME32  tTimeToWake = tPresentTime + (dwRecvTimeout / 1000) ;
    if ((dwRecvTimeout == INFINITE) || (tTimeToWake < tPresentTime))
    {
        //
        // Overflow
        // Note that time_t is a long, not unsigned. On the other hand
        // INFINITE is defined as 0xffffffff (i.e., -1). If we'll use
        // INFINITE here, then cancel routine, CCancelRpc::CancelRequests(),
        // will cancel this call immediately.
        // so use the bigest long value.
        //
        tTimeToWake = MAXLONG ;
    }
    g_CancelRpc.Add( hThread, tTimeToWake) ;
}


/*====================================================

UnregisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void UnregisterRpcCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread);
}



HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT ULONG *peAuthnLEvel
    );

handle_t RTpGetLocalQMBind(VOID);


#define  RTP_CALL_REMOTE_QM(lpServer, rc, command)			\
{                                                           \
	handle_t hBind = NULL ;                                 \
	rc = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE ;            \
                                                            \
	HRESULT rpcs =  RTpBindRemoteQMService(                 \
								lpServer,                   \
								&hBind,                     \
								&_eAuthnLevel               \
								);                          \
                                                            \
	if (rpcs == MQ_OK)                                      \
	{                                                       \
		HANDLE hThread;                                     \
		RegisterRpcCallForCancel( &hThread, 0) ;            \
                                                            \
		RpcTryExcept                                        \
		{                                                   \
			rc = command ;                                  \
		}                                                   \
		RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) \
		{                                                   \
			PRODUCE_RPC_ERROR_TRACING;						\
			rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;           \
		}                                                   \
		RpcEndExcept										\
															\
		UnregisterRpcCallForCancel( hThread);               \
	}                                                       \
                                                            \
	if (hBind)                                              \
	{                                                       \
		mqrpcUnbindQMService( &hBind, NULL ) ;              \
	}                                                       \
}

#define  CALL_REMOTE_QM(lpServer, rc, command)                          \
{                                                                       \
    BOOL  fTryAgain = FALSE ;                                           \
    ULONG _eAuthnLevel = MQSec_RpcAuthnLevel();     					\
                                                                        \
    do                                                                  \
    {                                                                   \
        fTryAgain = FALSE ;                                             \
        RTP_CALL_REMOTE_QM(lpServer, rc, command)                       \
        if (rc == MQ_ERROR_SERVICE_NOT_AVAILABLE)                       \
        {                                                               \
           if (_eAuthnLevel != RPC_C_AUTHN_LEVEL_NONE)                  \
           {                                                            \
               _eAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;                   \
               fTryAgain = TRUE ;                                       \
           }                                                            \
        }                                                               \
    } while (fTryAgain) ;                                               \
}

#endif // __RTPRPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtp.h

Abstract:

    RT DLL private internal functions

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __RTP_H
#define __RTP_H

#include "rtpsec.h"
#include "_mqrpc.h"
#include <acdef.h>
#include <fn.h>

#define SEND_PARSE  1
#define RECV_PARSE  2

#define QUEUE_CREATE    1
#define QUEUE_SET_PROPS 2
#define QUEUE_GET_PROPS 3

#define CPP_EXCEPTION_CODE 0xe06d7363

extern HINSTANCE g_hInstance;
extern DWORD g_dwThreadEventIndex;
extern LPWSTR g_lpwcsComputerName;
extern DWORD g_dwComputerNameLen;
extern BOOL  g_fDependentClient;



HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType =MQDS_QUEUE
    );

//
// The CMQHResult class is used in order to automatically convert the various
// error codes to Falcon error codes. This is done by defining the assignment
// operator of this class so it converts whatever error code that is assigned
// to objects of this class to a Falcon error code. The casting operator
// from this class to HRESULT, returns the converted error code.
//
class CMQHResult
{
public:
    CMQHResult(DWORD =MQDS_QUEUE); // Default constructor.
    CMQHResult(const CMQHResult &); // Copy constructor
    CMQHResult& operator =(HRESULT); // Assignment operator.
    operator HRESULT(); // Casting operator to HRESULT type.
    HRESULT GetReal(); // A method that returns the real error code.

private:
    HRESULT m_hr; // The converted error code.
    HRESULT m_real; // The real error code.
    DWORD m_dwObjectType; // The type of object (can be only queue, or machine).
};

//---------- CMQHResult implementation ----------------------------------

inline CMQHResult::CMQHResult(DWORD dwObjectType)
{
    ASSERT((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE));
    m_dwObjectType = dwObjectType;
}

inline CMQHResult::CMQHResult(const CMQHResult &hr)
{
    m_hr = hr.m_hr;
    m_real = hr.m_real;
    m_dwObjectType = hr.m_dwObjectType;
}

inline CMQHResult& CMQHResult::operator =(HRESULT hr)
{
    m_hr = RTpConvertToMQCode(hr, m_dwObjectType);
    m_real = hr;

    return *this;
}

inline CMQHResult::operator HRESULT()
{
    return m_hr;
}

inline HRESULT CMQHResult::GetReal()
{
    return m_real;
}

//---------- CMQHResult implementation end ------------------------------

//---------- Function declarations --------------------------------------

HRESULT
RTpParseSendMessageProperties(
    CACSendParameters &SendParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    CStringsToFree &ResponseStringsToFree,
    CStringsToFree &AdminStringsToFree
    );

HRESULT
RTpParseReceiveMessageProperties(
    CACReceiveParameters &ReceiveParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus
    );

LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    );

GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    );
                    
BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName) ;

HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize
    );

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns
    );

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS* pqp,
    IN  DWORD         dwOp,
    IN  BOOL          fPrivateQueue,
    OUT MQQUEUEPROPS **ppGoodQP,
    OUT char **ppTmpBuff
    );

HRESULT
RTpCheckQMProps(
    IN  MQQMPROPS * pQMProps,
    IN OUT HRESULT* aStatus,
    OUT MQQMPROPS **ppGoodQMP,
    OUT char      **ppTmpBuff
    );
  
HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction
    );

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
    );

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	);

HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	);


HRESULT
RTpProvideTransactionEnlist(
    ITransaction *pTrans,
    XACTUOW *pUow
    );

VOID
RTpInitXactRingBuf(
    VOID
    );

HRESULT GetThreadEvent(HANDLE& hEvent);

HRESULT 
RtpOneTimeThreadInit();

bool 
RtpIsThreadInit();

WCHAR *
RTpExtractDomainNameFromDLPath(
    LPCWSTR pwcsADsPath
    );

DWORD RtpTlsAlloc();

HRESULT
RtpCreateObject(
	DWORD dwObjectType,
    LPCWSTR lpwcsPathName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD cp,
    PROPID aProp[],
    PROPVARIANT apVar[]
    );

HRESULT
RtpCreateDSObject(
    DWORD dwObjectType,
    LPCWSTR lpwcsPathName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD cp,
    PROPID aProp[],
    PROPVARIANT apVar[],
    GUID* pObjGuid
    );

HRESULT
RtpSetObjectSecurity(
    OBJECT_FORMAT* pObjectFormat,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

//
// ------------- functions and definitions for the async receive thread ------------------------
//



class CCallbackDescriptor;



//
// An object of this class is returned from the call to CreateAsyncRxRequest(). 
// If destructed before calling detach() it will cause the cancelation of the callback request.
//
class CAutoCallbackDescriptor
{
public:
	CAutoCallbackDescriptor() : m_descriptor(NULL) {}
	~CAutoCallbackDescriptor() { if (m_descriptor != NULL) CancelAsyncRxRequest();}

	CCallbackDescriptor** ref() {return &m_descriptor;}

	CCallbackDescriptor* detach() {CCallbackDescriptor* d = m_descriptor; m_descriptor = NULL; return d;}

	OVERLAPPED* GetOverlapped();

private:
	CAutoCallbackDescriptor& operator = (const CAutoCallbackDescriptor&);
	CAutoCallbackDescriptor(const CAutoCallbackDescriptor&);

	void CancelAsyncRxRequest();

private:
	CCallbackDescriptor* m_descriptor;
};



void 
CreateAsyncRxRequest(
				CAutoCallbackDescriptor& descriptor, 
				IN HANDLE hQueue,
				IN DWORD timeout, 
				IN DWORD action,
				IN MQMSGPROPS* pmp,
				IN LPOVERLAPPED lpOverlapped,
				IN PMQRECEIVECALLBACK fnReceiveCallback,
				IN HANDLE hCursor
				);



//
// ---------------------------------------------------------------------------------------------
//



//
//  cursor information
//
struct CCursorInfo {
    HANDLE hQueue;
    HACCursor32 hCursor;
};
  

//
//  CCursorInfo to cursor handle
//
inline HACCursor32 CI2CH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hCursor;
}
  

//
//  CCursorInfo to queue handle
//
inline HANDLE CI2QH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hQueue;
}

    
extern DWORD  g_hBindIndex ;
#define tls_hBindRpc  ((handle_t) TlsGetValue( g_hBindIndex ))

extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint);
extern void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint);
extern void LogIllegalPointValue(DWORD_PTR dw3264, LPCWSTR wszFileName, USHORT usPoint);
             
#endif // __RTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtputl.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rtputl.h

Abstract:
    Utils functions header.

Author:
    Ilan Herbst (ilanh) 21-Nov-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _RTPUTL_H_
#define _RTPUTL_H_

bool IsWorkGroupMode(void);

LPCWSTR MachineDomain();


#endif // _RTPUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtpsec.h ===
//
// file:  rtpsec.h
//
#ifndef _RTPSEC_H_
#define _RTPSEC_H_

#include <mqcrypt.h>
#include <cs.h>

//
// The security context.
//

#define SECURITY_CONTEXT_VER    1

class MQSECURITY_CONTEXT
{
public:
    MQSECURITY_CONTEXT();
    ~MQSECURITY_CONTEXT();

    DWORD       dwVersion;       // The version of the security context.
    BOOL        fLocalUser;      // Indicates whether the user is a local user.
    BOOL        fLocalSystem;    // Indicates whether the user is a localSystem account.
    P<BYTE>     pUserSid;        // A pointer to the user SID. Undefined for a local user.
    DWORD       dwUserSidLen;    // The length of the user SID. Undefined for a local user.
    CHCryptProv hProv;           // A context handle to the cert CSP.
    P<BYTE>     pUserCert;       // A pointer to the user cert.
    DWORD       dwUserCertLen;   // The length of the user cert.
    P<WCHAR>    wszProvName;     // The name of the cert CSP.
    DWORD       dwProvType;      // The type of the cert CSP.
    BOOL        bDefProv;        // True if the cert CSP is the default CSP.
    BOOL        bInternalCert;   // True if the cert is an internal MSMQ cert.

    //
    // Member variable added to support all kinds of external certificate
	// and not assuming AT_KEYEXCHANGE for external certificate bug 5626 ilanh 25-June-2000
    //
    DWORD dwPrivateKeySpec;		// The Private key type, AT_SIGNATURE or AT_KEYEXCHANGE.

    //
    // Member variables added to fix MSMQ bug 2955
    //

    CCriticalSection CS ;      // critical section for multi-threaded.
    BOOL     fAlreadyImported ;  // Private key already imported.
    P<BYTE>  pPrivateKey ;       // Blob of private key.
    DWORD    dwPrivateKeySize ;  // size of private key blob.
    WCHAR    wszContainerName[ 28 ] ;  // Name of container for keys.

    //
    // hrGetCertInfo is the hr returned by GetCertInfo(). 
    // It is used to mark success or failure of initialization.
	// 
	HRESULT  hrGetCertInfo;
};

typedef MQSECURITY_CONTEXT *PMQSECURITY_CONTEXT;

PMQSECURITY_CONTEXT AllocSecurityContext() ;

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx ) ;

HRESULT
GetCertInfo(
    IN    BOOL        bUseCurrentUser,
    IN    BOOL        fMachine,
    IN OUT BYTE     **ppbCert,
    OUT   DWORD      *pdwCertLen,
    OUT   HCRYPTPROV *phProv,
    OUT   LPWSTR     *wszProvName,
    OUT   DWORD      *pdwProvType,
    OUT   BOOL       *pbDefProv,
    OUT   BOOL       *pbInternalCert,
	OUT	   DWORD     *pdwPrivateKeySpec
    );

HRESULT
RTpGetThreadUserSid( BOOL   *pfLocalUser,
                     BOOL   *pfLocalSystem,
                     LPBYTE *ppUserSid,
                     DWORD  *pdwUserSidLen ) ;

extern CContextMap g_map_RT_SecCtx; //ptr to DWORD map for PROPID_M_SECURITY_CONTEXT

#endif //_RTPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtrpc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtrpc.cpp

Abstract:

    Rpc related stuff.

Author:

    Doron Juster (DoronJ)  04-Jun-1997

Revision History:

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "mqsocket.h"
#include "rtprpc.h"
#include "mgmtrpc.h"
#include <mqsec.h>
#include <Fn.h>

#include "rtrpc.tmh"

static WCHAR *s_FN=L"rt/rtrpc";

//
// The binding string MUST be global and kept valid all time.
// If we create it on stack and free it after each use then we can't
// create more then one binding handle.
// Don't ask me (DoronJ) why, but this is the case.
//
TBYTE* g_pszStringBinding = NULL ;

//
//  Critical Section to make RPC thread safe.
//
CCriticalSection CRpcCS ;


DWORD  g_hThreadIndex = TLS_OUT_OF_INDEXES ;


//
// Local endpoints to QM
//
AP<WCHAR> g_pwzQmsvcEndpoint = 0;
AP<WCHAR> g_pwzQmmgmtEndpoint = 0;




//---------------------------------------------------------
//
//  RTpGetLocalQMBind(...)
//
//  Description:
//
//      Create RPC binding handle to a local QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetLocalQMBind()
{
	RPC_STATUS rc;
	
	if(g_pszStringBinding == NULL)
	{
	  	rc = RpcStringBindingCompose(
				0,
				RPC_LOCAL_PROTOCOL,
				0,
				g_pwzQmsvcEndpoint,
				RPC_LOCAL_OPTION,
				&g_pszStringBinding
				);

	  	if(rc != RPC_S_OK)
		{
			TrERROR(GENERAL, "RpcStringBindingCompose failed. Error: %!winerr!", rc);
		  	throw bad_win32_error(rc);
	  	}
	}

	handle_t hBind = 0;
	rc = RpcBindingFromStringBinding(g_pszStringBinding, &hBind);
	if (rc != RPC_S_OK)
	{
		ASSERT_BENIGN((rc == RPC_S_OUT_OF_MEMORY) && (hBind == NULL));
		TrERROR(GENERAL, "RpcBindingFromStringBinding failed. Error: %!winerr!", rc);
		throw bad_win32_error(rc);
	}

	rc = MQSec_SetLocalRpcMutualAuth(&hBind);
	if (rc != RPC_S_OK)
	{
		TrERROR(GENERAL, "MQSec_SetLocalRpcMutualAuth failed. Error: %!winerr!", rc);
		mqrpcUnbindQMService( &hBind, NULL ) ;
		hBind = NULL;
		throw bad_win32_error(rc);
	}

	return hBind;
}


//---------------------------------------------------------
//
//  RTpBindRemoteQMService(...)
//
//  Description:
//
//      Create RPC binding handle to a remote QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------
HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT ULONG *peAuthnLevel
    )
{
    HRESULT hr = MQ_ERROR ;

    GetPort_ROUTINE pfnGetPort = R_QMGetRTQMServerPort;


    //
    // Choose authentication service. For LocalSystem services, chose
    // "negotiate" and let mqutil select between Kerberos or ntlm.
    // For all other cases, use ntlm.
    // LocalSystem service go out to network without any credentials
    // if using ntlm, so only for it we're interested in Kerberos.
    // All other are fine with ntlm. For remote read we do not need
    // delegation, so we'll stick to ntlm.
    // The major issue here is a bug in rpc/security, whereas a nt4
    // user on a win2k machine can successfully call
    //  status = RpcBindingSetAuthInfoEx( ,, RPC_C_AUTHN_GSS_KERBEROS,,)
    // although it's clear he can't obtain any Kerberos ticket (he's
    // nt4 user, defined only in nt4 PDC).
    //
    ULONG   ulAuthnSvc = RPC_C_AUTHN_WINNT ;
    BOOL fLocalUser =  FALSE ;
    BOOL fLocalSystem = FALSE ;

    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (SUCCEEDED(hr) && fLocalSystem)
    {
        ulAuthnSvc = MSMQ_AUTHN_NEGOTIATE ;
    }

	hr = mqrpcBindQMService(
			lpwNodeName,
			NULL,
			peAuthnLevel,
			lphBind,
			IP_HANDSHAKE,
			pfnGetPort,
			ulAuthnSvc
			) ;

    return LogHR(hr, s_FN, 50);
}



DWORD RtpTlsAlloc()
{
    //
    //  Allocate TLS for  RPC connection with local QM service
    //

    DWORD index = TlsAlloc() ;
	if(index == TLS_OUT_OF_INDEXES)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to allocate tls index., error %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	return index;
}


//---------------------------------------------------------
//
//  InitRpcGlobals(...)
//
//  Description:
//
//		Function is IDEMPOTENT.
//      Initialize RPC related names and other constant data.
//
//  Return Value:
//
//---------------------------------------------------------

void InitRpcGlobals()
{
    //
    //  Allocate TLS for  RPC connection with local QM service
    //
	if(g_hBindIndex == TLS_OUT_OF_INDEXES)
	{
		g_hBindIndex = RtpTlsAlloc();
	}

    //
    //  Allocate TLS for  cancel remote-read RPC calls
    //
	if(g_hThreadIndex == TLS_OUT_OF_INDEXES)
	{
		g_hThreadIndex = RtpTlsAlloc();
	}

    //
    // Initialize local endpoints to QM
    //
	if(g_pwzQmmgmtEndpoint == NULL)
	{
		ComposeRPCEndPointName(QMMGMT_ENDPOINT, NULL, &g_pwzQmmgmtEndpoint);
	}

	if(g_pwzQmsvcEndpoint == NULL)
	{
		READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
		ComposeRPCEndPointName(wzEndpoint, NULL, &g_pwzQmsvcEndpoint);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtsecctx.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtsecctx.cpp

Abstract:

    This module implements the MQGetSecurityContext() and
    MQFreeSecurityContext() apis.

Author:

    Original version from message.cpp.
    Doron Juster (DoronJ)  12-Aug-1998
    Ilan Herbst  (ilanh)   25-June-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <mqsec.h>
#include <rtdep.h>

#include "rtsecctx.tmh"

static WCHAR *s_FN=L"rt/rtsecctx";

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for MQGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR(pt) { DWORD dwErr = GetLastError() ;  LogNTStatus(dwErr, s_FN, pt); }
#else
#define REPORT_CTX_ERROR(pt)
#endif

//
// PROPID_M_SECURITY_CONTEXT is a VT_UI4 property, but the value is
// a pointer to MQSECURITY_CONTEXT class. On win64 the ptr cannot fit
// into a VT_UI4 property, so we need to map between this PTR and a DWORD.
// The object below performs the mapping
//
CContextMap g_map_RT_SecCtx;

//+--------------------------------------------
//
// The constractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::MQSECURITY_CONTEXT() :
	dwVersion(SECURITY_CONTEXT_VER),
	dwUserSidLen(0),
	dwUserCertLen(0),
	dwProvType(0),
	bDefProv(TRUE),
	bInternalCert(TRUE),
	dwPrivateKeySpec(AT_SIGNATURE),
	fAlreadyImported(FALSE),
	dwPrivateKeySize(0),
	fLocalSystem(FALSE),
	fLocalUser(FALSE)
{
}

//+--------------------------------------------
//
// The destractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::~MQSECURITY_CONTEXT()
{
    if (fAlreadyImported)
    {
        CryptReleaseContext(hProv, 0);
        hProv = NULL;

        //
        // delete the temporary keyset which was created before
        // importing the private key.
        //
        CryptAcquireContext(
			&hProv,
			wszContainerName,
			wszProvName,
			dwProvType,
			CRYPT_DELETEKEYSET
			);
        hProv = NULL;
    }
}

//+-------------------------------
//
//  AllocSecurityContext()
//
//+-------------------------------

PMQSECURITY_CONTEXT
AllocSecurityContext()
{
    PMQSECURITY_CONTEXT pSecCtx =  new MQSECURITY_CONTEXT;
    return pSecCtx;
}

//+---------------------------------------------------------------
//
//  BOOL SameAsProcessSid( PSID pSid )
//
//  Return TRUE if input sid is equal to sid of process token.
//
//+---------------------------------------------------------------

BOOL SameAsProcessSid(PSID pSid)
{
    P<BYTE>  ptu = NULL;
    CAutoCloseHandle  hAccessToken = NULL;

    BOOL f = OpenProcessToken(
				GetCurrentProcess(),
				TOKEN_QUERY,
				&hAccessToken
				);
    if (!f)
    {
        //
        // return false.
        // if thread can't open the process token then it's probably
        // impersonating a user that don't have the permission to do that.
        // so it's not the process user.
        //
        DWORD dwErr = GetLastError();
		TrERROR(GENERAL, "OpenProcessToken() for the current process Failed. %!winerr!", dwErr);
        return FALSE;
    }

    DWORD dwLen = 0;
    GetTokenInformation(hAccessToken, TokenUser, NULL, 0, &dwLen);
    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
		TrERROR(GENERAL, "GetTokenInformation() Failed. %!winerr!", gle);
		return FALSE;
    }

    ptu = new BYTE[ dwLen ];
    f = GetTokenInformation(
			hAccessToken,
			TokenUser,
			ptu,
			dwLen,
			&dwLen
			);

    ASSERT(f);
    if (!f)
    {
    	gle = GetLastError();
		TrERROR(GENERAL, "GetTokenInformation() Failed. %!winerr!", gle);
        return FALSE;
    }

    PSID pUser = ((TOKEN_USER*)(BYTE*)ptu)->User.Sid;
    return EqualSid(pSid, pUser);
}

//+----------------------------------------------------------------
//
//  HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
//
//+----------------------------------------------------------------

HRESULT  RTpImportPrivateKey(PMQSECURITY_CONTEXT pSecCtx)
{
    CS Lock(pSecCtx->CS);

    if (pSecCtx->fAlreadyImported)
    {
        //
        // this condition may happen if two threads call MQSend() at the
        // same time, using a new security context which was not yet
        // imported.
        //
        return MQ_OK;
    }

    if (!(pSecCtx->pPrivateKey))
    {
        //
        // there is no private key to import.
        //
        REPORT_CTX_ERROR(29);
		TrERROR(SECURITY, "There is no private key to import");
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 30);
    }

    //
    // Build name of key container. Combine ProcessID with SID.
    //
    LONG lNum = InterlockedIncrement(&s_lCtxSerialNumber);
    swprintf( pSecCtx->wszContainerName,
              L"P-%lu-C-%lu", GetCurrentProcessId(), (DWORD) lNum);
    //
    // Delete key container if already exist. That's something left
    // from previous processes which didn't clean up.
    //
    HCRYPTPROV hProv = NULL;
    CryptAcquireContext(
		&hProv,
		pSecCtx->wszContainerName,
		pSecCtx->wszProvName,
		pSecCtx->dwProvType,
		CRYPT_DELETEKEYSET
		);

    //
    // Create the key container.
    //
    BOOL f = CryptAcquireContext(
				&pSecCtx->hProv,
				pSecCtx->wszContainerName,
				pSecCtx->wszProvName,
				pSecCtx->dwProvType,
				CRYPT_NEWKEYSET
				);
    if (!f)
    {
		DWORD gle = GetLastError();
        REPORT_CTX_ERROR(39);
		TrERROR(SECURITY, "CryptAcquireContext() failed, gle = 0x%x", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 40);
    }

    //
    // Import the private key into the container.
    //
    HCRYPTKEY hKey = NULL;
    f = CryptImportKey(
			pSecCtx->hProv,
			pSecCtx->pPrivateKey,
			pSecCtx->dwPrivateKeySize,
			0,
			0,
			&hKey
			);
    if (!f)
    {
		DWORD gle = GetLastError();
        REPORT_CTX_ERROR(49);
		TrERROR(SECURITY, "CryptImportKey() failed, gle = 0x%x", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 50);
    }
    CryptDestroyKey(hKey);

    pSecCtx->fAlreadyImported = TRUE;
    return MQ_OK;
}

//+--------------------------------------
//
//  HRESULT  RTpExportSigningKey()
//
//+--------------------------------------

HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx)
{
    CHCryptKey hKey = NULL ;

    BOOL f = CryptGetUserKey(
                              pSecCtx->hProv,
		                      pSecCtx->dwPrivateKeySpec,
                              &hKey
                             ) ;
    if (!f)
    {
		DWORD gle = GetLastError();
        REPORT_CTX_ERROR(99) ;
		TrERROR(SECURITY, "CryptGetUserKey() failed, gle = 0x%x", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 100);
    }

    //
    // Get size need for exporting the private key blob.
    //
    pSecCtx->dwPrivateKeySize = 0 ;
    f = CryptExportKey(
                        hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        NULL,
                        &pSecCtx->dwPrivateKeySize
                      ) ;
    if (!f)
    {
		DWORD gle = GetLastError();
        REPORT_CTX_ERROR(109) ;
		TrERROR(SECURITY, "CryptExportKey() failed, gle = 0x%x", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 110);
    }

    pSecCtx->pPrivateKey = new BYTE[ pSecCtx->dwPrivateKeySize ] ;
    f = CryptExportKey(
                        hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        pSecCtx->pPrivateKey,
                       &pSecCtx->dwPrivateKeySize
                      ) ;
    if (!f)
    {
		DWORD gle = GetLastError();
        REPORT_CTX_ERROR(119) ;
		TrERROR(SECURITY, "CryptExportKey() failed, gle = 0x%x", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 120);
    }

    //
    // Release the CSP context handle. We don't need it anymore.
    // We'll acquire it again when importing the key.
    //
    CryptReleaseContext( pSecCtx->hProv, 0 ) ;
    pSecCtx->hProv = NULL ;

    return MQ_OK ;
}

/***********************************************************************
*
*   Function - MQGetSecurityContext()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in MQSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of MQSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to MQSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call MQFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
MQGetSecurityContext(
	LPVOID  lpCertBuffer,
	DWORD   dwCertBufferLength,
	HANDLE *phSecurityContext
	)
{
	if(g_fDependentClient)
		return DepGetSecurityContext(
					lpCertBuffer,
					dwCertBufferLength,
					phSecurityContext
					);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    //
    // the line below may throw bad_alloc on win64, like the allocation above.
    // we return a HANDLE that can be safely cast to 32 bits (for VT_I4 property
    // PROPID_M_SECURITY_CONTEXT).
    //
    HANDLE hSecurityContext = (HANDLE) DWORD_TO_HANDLE(
        ADD_TO_CONTEXT_MAP(g_map_RT_SecCtx, (PMQSECURITY_CONTEXT)pSecCtx));
    P<BYTE>    pSid = NULL;
    CHCryptKey hKey = NULL;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid(
				&pSecCtx->fLocalUser,
				&pSecCtx->fLocalSystem,
				&pSecCtx->pUserSid,
				&pSecCtx->dwUserSidLen
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert, lpCertBuffer, dwCertBufferLength);
        }

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        hr  = GetCertInfo(
                    false,
					pSecCtx->fLocalSystem,
					ppUserCert,
					&pSecCtx->dwUserCertLen,
					&pSecCtx->hProv,
					&pSecCtx->wszProvName,
					&pSecCtx->dwProvType,
					&pSecCtx->bDefProv,
					&pSecCtx->bInternalCert,
					&pSecCtx->dwPrivateKeySpec	
					);

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return LogHR(hr, s_FN, 70);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail MQGetSecurityContext().
            // MQSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0;
        hr = MQSec_GetThreadUserSid(
                FALSE,
                reinterpret_cast<PSID*>(&pSid),
                &dwLen,
                FALSE           // fThreadTokenOnly
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 80);
        }

        BOOL fAsProcess = SameAsProcessSid( pSid );

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 130);
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return LogHR(hr, s_FN, 140);
}

/*************************************************************************
*
*    Function -  MQFreeSecurityContext()
*
*    Parameters -
*        lpSecurityContextBuffer - A pointer to a security context that was
*        previously allocated by MQGetSecurityContext.
*
*    Description -
*        The function frees the security context that was previously
*        allocated by MQGetSecurityContext().
*
**************************************************************************/

void
APIENTRY
MQFreeSecurityContext(
	HANDLE hSecurityContext
	)
{
	if(g_fDependentClient)
		return DepFreeSecurityContext(hSecurityContext);

	if(FAILED(RtpOneTimeThreadInit()))
		return;

    if (hSecurityContext == 0)
    {
        return;
    }

    PMQSECURITY_CONTEXT pSecCtx;
    try
    {
        pSecCtx = (PMQSECURITY_CONTEXT)
            GET_FROM_CONTEXT_MAP(g_map_RT_SecCtx, (DWORD)HANDLE_TO_DWORD(hSecurityContext));
    }
    catch(...)
    {
        return;
    }

    delete pSecCtx;
    DELETE_FROM_CONTEXT_MAP(g_map_RT_SecCtx, (DWORD)HANDLE_TO_DWORD(hSecurityContext));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtsecutl.cpp ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.cpp

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 18, 1997
	Ilan Herbst   (ilanh)   Jun 25, 2000

--*/

#include "stdh.h"
#include "cs.h"

#include "rtsecutl.tmh"

PMQSECURITY_CONTEXT g_pSecCntx = NULL ;

static WCHAR *s_FN=L"rt/rtsecutl";

static CCriticalSection s_security_cs;

void InitSecurityContext()
{

    CS lock(s_security_cs);

    if(g_pSecCntx != 0)
    {
        return;
    }

    //
    // Allocate the structure for the chached process security context.
    //
    PMQSECURITY_CONTEXT pSecCntx = new MQSECURITY_CONTEXT;
    
	//
    //  Get the user's SID and put it in the chaed process security context.
    //
    RTpGetThreadUserSid(
		&pSecCntx->fLocalUser,
		&pSecCntx->fLocalSystem,
		&pSecCntx->pUserSid,
		&pSecCntx->dwUserSidLen
		);

    //
    // Get the internal certificate of the process and place all the
    // information for this certificate in the chached process security
    // context.
    //
    HRESULT hr = GetCertInfo(
        FALSE,
		pSecCntx->fLocalSystem,
		&pSecCntx->pUserCert,
		&pSecCntx->dwUserCertLen,
		&pSecCntx->hProv,
		&pSecCntx->wszProvName,
		&pSecCntx->dwProvType,
		&pSecCntx->bDefProv,
		&pSecCntx->bInternalCert,
		&pSecCntx->dwPrivateKeySpec	
		);

	//
	// Mark the sucess (or failure) on the glogal.
	//
    pSecCntx->hrGetCertInfo = hr;
	
	if( FAILED(hr) )
	{
		TrERROR(SECURITY, "GetCertInfo() failed, Error: %!hresult!", hr);
	}
		
    //
    //  Set the global security context only after getting all information
    //  it is checked outside the critical (in other scope) seciton to get
    //  better performance
    //
    g_pSecCntx = pSecCntx;
}


HRESULT InitSecurityContextCertInfo()
{
	if(SUCCEEDED(g_pSecCntx->hrGetCertInfo))
	{
		return MQ_OK;
	}

	CS lock(s_security_cs);

	if(SUCCEEDED(g_pSecCntx->hrGetCertInfo))
	{
		return MQ_OK;
	}

	//
	// First clean old SecContext.
	//
	g_pSecCntx->pUserCert.free();
	g_pSecCntx->hProv.free();
	g_pSecCntx->wszProvName.free();
	

	//
    // Get the internal certificate of the process and place all the
    // information for this certificate in the global process security
    // context.
    //
    HRESULT hr = GetCertInfo(
        FALSE,
		g_pSecCntx->fLocalSystem,
		&g_pSecCntx->pUserCert,
		&g_pSecCntx->dwUserCertLen,
		&g_pSecCntx->hProv,
		&g_pSecCntx->wszProvName,
		&g_pSecCntx->dwProvType,
		&g_pSecCntx->bDefProv,
		&g_pSecCntx->bInternalCert,
		&g_pSecCntx->dwPrivateKeySpec	
		);

	//
	// Mark the sucess (or failure) on the glogal.
	//
	g_pSecCntx->hrGetCertInfo = hr;
	
	if( FAILED(hr) )
	{
		TrERROR(SECURITY, "GetCertInfo() failed, Error: %!hresult!", hr);
		return hr;
	}

	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\signmessagexml.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.h

Abstract:
    functions to signed via xml digital signature in the RunTime

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _SIGNMESSAGEXML_H_
#define _SIGNMESSAGEXML_H_

HRESULT  
CheckInitProv( 
	IN PMQSECURITY_CONTEXT pSecCtx
	);

HRESULT 
SignMessageXmlDSig( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN OUT CACSendParameters *pSendParams,
	OUT AP<char>& pSignatureElement
	);


#endif // _SIGNMESSAGEXML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtsecutl.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.h

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 19, 1997

--*/

extern PMQSECURITY_CONTEXT g_pSecCntx ;

extern void InitSecurityContext();
extern HRESULT InitSecurityContextCertInfo();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\signmessagexml.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.cpp

Abstract:
    functions to signed via xml in the RunTime

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "ac.h"
#include <mqsec.h>
#include <ph.h>
#include <mqformat.h>
#include "mqstl.h"
#include "Xds.h"
#include "tr.h"
#include "authlevel.h"
#include "mpnames.h"

#include "signmessagexml.tmh"

static WCHAR *s_FN=L"rt/SignMessageXml";

extern GUID  g_QMId;

HRESULT  
CheckInitProv( 
	IN PMQSECURITY_CONTEXT pSecCtx
	)
/*++
Routine Description:
	Import the private key into procss hive
	this is subset of _BeginToSignMessage() function,
	only the part that check the provider initialization.

Arguments:
	pSecCtx - pointer to the security context

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    ASSERT(pSecCtx != NULL);

    if(pSecCtx->hProv)
	    return MQ_OK;
		
    //
    // Import the private key into process hive.
    //
	HRESULT hr = RTpImportPrivateKey(pSecCtx);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    ASSERT(pSecCtx->hProv);

    return MQ_OK;
}


static
CXdsReferenceInput* 
NewXdsReference( 
	IN DWORD BufferSizeInBytes,
	IN BYTE** ppBuffer,
	IN ALG_ID HashAlg,
	IN HCRYPTPROV hCsp,
	IN LPCSTR Uri,
	IN LPCSTR Type = NULL
	)
/*++
Routine Description:
	Create XMLDSIG reference.

Arguments:
	BufferSize - buffer size in bytes
	ppBuffer - pointer to the buffer
	HashAlg - hash algoritem
    hCsp - handle to crypto service provider.
	Uri - Uri of the refernce data. 
	Type - Type of the refernce. 

Returned Value:
    pointer to CXdsReferenceInput, NULL if BufferSize = 0.

--*/
{
	if(BufferSizeInBytes == 0)
	{
	    TrTRACE(SECURITY, "RT: Reference is not created, BufferSizeInBytes = 0");
		return NULL;
	}

	ASSERT(ppBuffer != NULL);

	//
	// Message Body Digest
	//
	AP<char> pBufferHash = XdsCalcDataDigest(
								 *ppBuffer,
								 BufferSizeInBytes,
								 HashAlg,
								 hCsp
								 );

	TrTRACE(SECURITY, "RT: Reference Data BufferSizeInBytes = %d, Uri = %hs", BufferSizeInBytes, Uri);

	//
	// RefBody - Message Body Reference
	//
	return new CXdsReferenceInput(
					 HashAlg,
					 pBufferHash,
					 Uri,
					 Type
					 );

}


static
LPSTR
ComposeMimeAttachmentUri(
	LPCSTR Str
	)
/*++
Routine Description:
	Compose Mime Attacment Uri.
	cid:"Str"QmGuid

Arguments:
	Str - the constant string id of the reference (body@ or extension@)

Returned Value:
	Mime Attachment Reference Uri string

--*/
{
	ASSERT(Str != NULL);

	AP<char> pMimeUri = new char[xPrefixMimeAttachmentLen + GUID_STR_LENGTH + strlen(Str) + 1];
	sprintf(pMimeUri, "%s" MIME_ID_FMT_A, xPrefixMimeAttachment, strlen(Str), Str, GUID_ELEMENTS(&g_QMId));
	return pMimeUri.detach();
}


HRESULT 
SignMessageXmlDSig( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN OUT CACSendParameters *pSendParams,
	OUT AP<char>& pSignatureElement
	)
/*++
Routine Description:
	Sign message with XML digital signature.

Arguments:
	pSecCtx - pointer to the security context
    pSendParams - pointer to send params.
	pSignatureElement - auto pointer of char for the signature element wstring 

Returned Value:
    change the value in the transfer buffer of
	create the SignatureElement (xml digital signature) and store it 
	in the transfer buffer

	MQ_OK, if successful, else error code.

--*/
{
	ASSERT(IS_AUTH_LEVEL_XMLDSIG_BIT(pSendParams->MsgProps.ulAuthLevel));
	ASSERT(pSendParams->MsgProps.pulHashAlg != NULL);

	//
	// This check if the CSP is initialize correctly
	//
    HRESULT hr =  CheckInitProv(pSecCtx);

    if (FAILED(hr))
    {
        return hr;
    }

	//
	// Body References
	//
	AP<char> pBodyUri = ComposeMimeAttachmentUri(xMimeBodyId); 

    TrTRACE(SECURITY, "XMLDSIG, Meesage Body Reference, Uri = %hs", pBodyUri.get());

	P<CXdsReferenceInput> pRefBody = NewXdsReference( 
											pSendParams->MsgProps.ulBodyBufferSizeInBytes,
											pSendParams->MsgProps.ppBody,
											*pSendParams->MsgProps.pulHashAlg,
											pSecCtx->hProv,
											pBodyUri
											);

	//
	// Extension References
	//
	AP<char> pExtensionUri = ComposeMimeAttachmentUri(xMimeExtensionId);

    TrTRACE(SECURITY, "XMLDSIG, Meesage Extension Reference, Uri = %hs", pExtensionUri.get());

	P<CXdsReferenceInput> pRefExtension = NewXdsReference( 
												pSendParams->MsgProps.ulMsgExtensionBufferInBytes,
												pSendParams->MsgProps.ppMsgExtension,
												*pSendParams->MsgProps.pulHashAlg,
												pSecCtx->hProv,
												pExtensionUri
												);

	//
	// Create pReferenceInputs vector
	//
	ReferenceInputVectorType pReferenceInputs;

	if(pRefBody != NULL)
	{
		ASSERT(pSendParams->MsgProps.ulBodyBufferSizeInBytes != 0);
		pReferenceInputs.push_back(pRefBody);
		pRefBody.detach();
	}

	if(pRefExtension != NULL)
	{
		ASSERT(pSendParams->MsgProps.ulMsgExtensionBufferInBytes != 0);
		pReferenceInputs.push_back(pRefExtension);
		pRefExtension.detach();
	}

	//
	// Signature element with the signature value as input - no need to calucate it only to build the element
	//
	CXdsSignedInfo::SignatureAlgorithm SignatureAlg = CXdsSignedInfo::saDsa;

	CXdsSignature SignatureXds(
					  SignatureAlg,
					  NULL,		// SignedInfo Id
					  pReferenceInputs,
					  NULL,		// Signature Id
					  pSecCtx->hProv,
					  pSecCtx->dwPrivateKeySpec,
					  NULL /* KeyValue */
					  );

	ASSERT(pSignatureElement == NULL);
	pSignatureElement = SignatureXds.SignatureElement();

	TrTRACE(SECURITY, "RT: SignMessageXmlDSig() XmlDsig complete ok");
    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\signmqf.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMqf.h

Abstract:
    functions to signed Mqf format name

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _SIGNMQF_H_
#define _SIGNMQF_H_


HRESULT 
SignMqf( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters* pSendParams,
	OUT AP<BYTE>& pSignatureMqf,
	OUT DWORD* pSignatureMqfLen
	);


#endif // _SIGNMQF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\signmqf.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMqf.cpp

Abstract:
    functions to signed Mqf format name

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "ac.h"
#include <mqsec.h>
#include <ph.h>
#include <mqformat.h>
#include <mqf2format.h>
#include "tr.h"
#include "cry.h"
#include "_guid.h"
#include "SignMessageXml.h"

#include "signmqf.tmh"

extern GUID  g_QMId;

//
// A buffer that contains only zeroes. This is the default value for the
// correleation ID. The buffer is used when the passed pointer to the message
// correlation ID is NULL.
//
const BYTE xDefCorrelationId[PROPID_M_CORRELATIONID_SIZE] = {0};

static WCHAR *s_FN=L"rt/SignMqf";


static
void 
MsgBodyHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Message Body hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Body
	//
	if(pSendParams->MsgProps.ppBody != NULL)
	{
		CryHashData(
			*pSendParams->MsgProps.ppBody, 
			pSendParams->MsgProps.ulBodyBufferSizeInBytes,
			hHash
			);

        TrTRACE(SECURITY, "RT: MsgBodyHash(), BodySize = %d", pSendParams->MsgProps.ulBodyBufferSizeInBytes);
	}
}


static
void 
CorrelationIdHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	CorrelationId hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// CorrelationID
	//
	if(pSendParams->MsgProps.ppCorrelationID != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppCorrelationID), 
			PROPID_M_CORRELATIONID_SIZE,
			hHash
			);
	}
	else
	{
		CryHashData(
			xDefCorrelationId, 
			PROPID_M_CORRELATIONID_SIZE,
			hHash
			);
	}

    TrTRACE(SECURITY, "RT: CorrelationIdHash(), CorrelationIdSize = %d", PROPID_M_CORRELATIONID_SIZE);
}


static
void 
ApplicationTagHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Application Tag hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Application tag
	//
	if(pSendParams->MsgProps.pApplicationTag != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(pSendParams->MsgProps.pApplicationTag), 
			sizeof(DWORD),
			hHash
			);

        TrTRACE(SECURITY, "RT: ApplicationTagHash(), ApplicationTag = %d", *pSendParams->MsgProps.pApplicationTag);
	}
	else
	{
		ULONG ApplicationTag = DEFAULT_M_APPSPECIFIC;

		CryHashData(
			reinterpret_cast<const BYTE*>(&ApplicationTag), 
			sizeof(DWORD),
			hHash
			);

        TrTRACE(SECURITY, "RT: ApplicationTagHash(), ApplicationTag = %d", ApplicationTag);
	}
}


static
void 
TitleHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Title hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Title
	//
	if(pSendParams->MsgProps.ppTitle != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppTitle), 
			pSendParams->MsgProps.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
			hHash
			);

        TrTRACE(SECURITY, "RT: TitleHash(),  TitleLength = %d", pSendParams->MsgProps.ulTitleBufferSizeInWCHARs);

        TrTRACE(SECURITY, "RT: TitleHash(),  Title = %ls", *pSendParams->MsgProps.ppTitle);
	}
}


static
void 
MqfHash(
	IN HCRYPTHASH hHash, 	
    IN const QUEUE_FORMAT*	pqf,
	IN ULONG			    nMqf
	)
/*++
Routine Description:
	Mqf hash.

Arguments:
	hHash - hash object.
	pqf - pointer to QUEUE_FORMAT array.
	nMqf - pqf array size.

Returned Value:
	none.

--*/
{
	ULONG FormatNameLength = 0;
	AP<WCHAR> pFormatName = MQpMqfToFormatName(
								pqf, 
								nMqf, 
								&FormatNameLength 
								);

	ASSERT(("Failed to get Mqf format name", pFormatName != NULL)); 

	CryHashData(
		reinterpret_cast<const BYTE*>(pFormatName.get()), 
		FormatNameLength * sizeof(WCHAR),
		hHash
		);

	TrTRACE(SECURITY, "RT: MqfHash(),  nMqf = %d", nMqf);

	TrTRACE(SECURITY, "RT: MqfHash(),  FormatNameLength(mqf) = %d", FormatNameLength);

	TrTRACE(SECURITY, "RT: MqfHash(),  FormatName(mqf) = %ls", pFormatName.get());
}


static
void 
ResponseMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	ResponseMqf hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Get the string representation for the responce queue FormatName.
	// BUGBUG: Currently mp lib not support response mqf
 	//
	if(pSendParams->ResponseMqf != NULL)
	{
		ASSERT(pSendParams->nResponseMqf >= 1);

		TrTRACE(SECURITY, "RT: ResponseMqfHash(),  ResponseMqf:");

		MqfHash(
			hHash,
			pSendParams->ResponseMqf, 
			pSendParams->nResponseMqf
			);
	}
}


static
void 
AdminMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	AdminMqf hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
    //
    // Get the string representation for the admin queue FormatName.
    //
    if (pSendParams->AdminMqf != NULL) 
    {
		ASSERT(pSendParams->nAdminMqf >= 1);

		TrTRACE(SECURITY, "RT: AdminMqfHash(),  AdminMqf:");

		MqfHash(
			hHash,
			pSendParams->AdminMqf, 
			pSendParams->nAdminMqf 
			);
	}
}


static
void 
ExtensionHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Extension hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Extension
	//
	if(pSendParams->MsgProps.ppMsgExtension != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppMsgExtension), 
			pSendParams->MsgProps.ulMsgExtensionBufferInBytes,
			hHash
			);

        TrTRACE(SECURITY, "RT: ExtensionHash(), ExtensionLen = %d", pSendParams->MsgProps.ulMsgExtensionBufferInBytes);
	}
}


static
void 
TargetFormatNameHash(
	IN HCRYPTHASH hHash, 	
	IN LPCWSTR pwszTargetFormatName
	)
/*++
Routine Description:
	TargetFormatName hash.

Arguments:
	hHash - hash object
	pwszTargetFormatName - Target queue format name (LPWSTR)

Returned Value:
	none.

--*/
{
	//
	// Target queue Format Name
	//
	CryHashData(
		reinterpret_cast<const BYTE*>(pwszTargetFormatName), 
		(1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR),
		hHash
		);

    TrTRACE(SECURITY, "RT: TargetFormatNameHash(), TargetFormatNameLen = %d", (1 + wcslen(pwszTargetFormatName))) ;

    TrTRACE(SECURITY, "RT: TargetFormatNameHash(), TargetFormatName = %ls", pwszTargetFormatName) ;
}


static
void 
SourceQmHash(
	IN HCRYPTHASH hHash
	)
/*++
Routine Description:
	Source Qm hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
    // Guid of local qm.
    //
    GUID *pGuidQM = &g_QMId;

	CryHashData(
		reinterpret_cast<const BYTE*>(pGuidQM), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(SECURITY, "RT: SourceQmHash(), SourceGuid = %!guid!", pGuidQM);
}


static
void 
MsgAckFlag(
	IN const CACSendParameters* pSendParams,
	OUT struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Message Ack Flag.

Arguments:
    pSendParams - pointer to send params.
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
    if (pSendParams->MsgProps.pAcknowledge) 
    {
        pUserFlags->bAck = *(pSendParams->MsgProps.pAcknowledge);
    }
}


static
void 
MsgFlags(
	IN const CACSendParameters* pSendParams,
	OUT struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Prepare Message Flags.

Arguments:
    pSendParams - pointer to send params.
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
    pUserFlags->bDelivery = DEFAULT_M_DELIVERY;
    pUserFlags->bPriority = DEFAULT_M_PRIORITY;
    pUserFlags->bAuditing = DEFAULT_M_JOURNAL;
    pUserFlags->bAck      = DEFAULT_M_ACKNOWLEDGE;
    pUserFlags->usClass   = MQMSG_CLASS_NORMAL;

    if (pSendParams->MsgProps.pDelivery)
    {
        pUserFlags->bDelivery = *(pSendParams->MsgProps.pDelivery);
    }

    if (pSendParams->MsgProps.pPriority)
    {
        pUserFlags->bPriority = *(pSendParams->MsgProps.pPriority);
    }

    if (pSendParams->MsgProps.pAuditing)
    {
        pUserFlags->bAuditing = *(pSendParams->MsgProps.pAuditing);
    }

    if (pSendParams->MsgProps.pClass)
    {
        pUserFlags->usClass = *(pSendParams->MsgProps.pClass);
    }

    if (pSendParams->MsgProps.pulBodyType)
    {
        pUserFlags->ulBodyType = *(pSendParams->MsgProps.pulBodyType);
    }
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
	CryHashData(
		reinterpret_cast<const BYTE*>(pUserFlags), 
		sizeof(_MsgFlags),
		hHash
		);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), bDelivery = %d", pUserFlags->bDelivery);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), bPriority = %d", pUserFlags->bPriority);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), bAuditing = %d",  pUserFlags->bAuditing);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), bAck = %d", pUserFlags->bAck);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), usClass = %d", pUserFlags->usClass);

    TrTRACE(SECURITY, "RT: MsgFlagsHash(), ulBodyType = %d", pUserFlags->ulBodyType);
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

	MsgFlags(pSendParams, &sUserFlags);
	MsgAckFlag(pSendParams, &sUserFlags);
	MsgFlagsHash(hHash, &sUserFlags);
}


static
void 
ConnectorHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Connector hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Connector Type
	//
    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;
    if (pSendParams->MsgProps.ppConnectorType)
    {
        pConnectorGuid = *(pSendParams->MsgProps.ppConnectorType);
    }

	CryHashData(
		reinterpret_cast<const BYTE*>(pConnectorGuid), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(SECURITY, "RT: CalcPropHash(), ConnectorGuid = %!guid!", pConnectorGuid);
}


static
void 
CalcPropHash(
	IN HCRYPTHASH hHash, 	
	IN LPCWSTR pwszTargetFormatName,
	IN const CACSendParameters *pSendParams
	)
/*++
Routine Description:
	Calc the hash value of Message property

Arguments:
	hHash - hash object
	pwszTargetFormatName - Target queue format name (LPWSTR)
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	MsgBodyHash(hHash, pSendParams); 
	CorrelationIdHash(hHash, pSendParams);
	ApplicationTagHash(hHash, pSendParams);
	TitleHash(hHash, pSendParams);
	ResponseMqfHash(hHash, pSendParams);
	AdminMqfHash(hHash, pSendParams);
	ExtensionHash(hHash, pSendParams);
	TargetFormatNameHash(hHash, pwszTargetFormatName);
	SourceQmHash(hHash);
	MsgFlagsHash(hHash, pSendParams);
	ConnectorHash(hHash, pSendParams);
}


HRESULT 
SignMqf( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters* pSendParams,
	OUT AP<BYTE>& pSignatureMqf,
	OUT DWORD* pSignatureMqfLen
	)
/*++
Routine Description:
	Sign message with XML digital signature.

Arguments:
	pSecCtx - pointer to the security context
	pwszTargetFormatName - Target queue format name (LPWSTR)
    pSendParams - pointer to send params.
	pSignatureMqf - auto pointer of bytes for the mqf signature 
	pSignatureMqfLen - length of mqf signature

Returned Value:
    change the value in the transfer buffer of
	create the SignatureElement (xml digital signature) and store it 
	in the transfer buffer

	MQ_OK, if successful, else error code.

--*/
{
	//
	// This check if the CSP is initialize correctly
	//
    HRESULT hr = CheckInitProv(pSecCtx);

    if (FAILED(hr))
    {
        return hr;
    }
	

	try
	{
		//
		// Sign properies
		//

		CHashHandle hHash = CryCreateHash(
								pSecCtx->hProv, 
								*pSendParams->MsgProps.pulHashAlg
								);

		CalcPropHash(
			 hHash, 
			 pwszTargetFormatName,
			 pSendParams
			 );

		BYTE** ppSignatureMqf = &pSignatureMqf;
		pSignatureMqf = CryCreateSignature(
							hHash,
							pSecCtx->dwPrivateKeySpec,
							pSignatureMqfLen
							);

		pSendParams->ppSignatureMqf = ppSignatureMqf;

		TrTRACE(SECURITY, "RT: SignMqf() SignatureMqf (MSMQ30 signature) complete ok");
		return MQ_OK;
	}
	catch (const bad_CryptoApi& exp)
	{
        TrERROR(SECURITY, "RT: SignMqf(), bad Crypto Class Api Excption ErrorCode = %x", exp.error());
		DBG_USED(exp);

		return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 50);
	}
	catch (const bad_alloc&)
	{
        TrTRACE(SECURITY, "RT: SignMqf(), bad_alloc Excption");
		return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 60);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\rtutil.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtutil.cpp

Abstract:

    Contains various utility functions.

Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

    Erez Haba (erezh) 17-Jan-1997

--*/

#include "stdh.h"
#include "ac.h"
#include <mqdbmgr.h>
#include <mqsec.h>

#include "rtutil.tmh"

static WCHAR *s_FN=L"rt/rtutil";


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePropVar
//
//  Description:
//      Find a queue property in the properties array
//
//---------------------------------------------------------
PROPVARIANT*
RTpGetQueuePropVar(
    PROPID PropID,
    MQQUEUEPROPS *pqp
    )
{
    DWORD i;
    DWORD cProp;
    PROPID *aPropID;

    for (i = 0, cProp = pqp->cProp, aPropID = pqp->aPropID;
         i < cProp;
         i++, aPropID++) {

        if (*aPropID == PropID) {
            return(&(pqp->aPropVar[i]));
        }

    }

    return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathNamePropVar
//
//  Description:
//      Find a the queue path name property in the properties array
//
//---------------------------------------------------------
LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_PATHNAME, pqp)) != NULL)
        return(p->pwszVal);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueueGuidPropVar
//
//  Description:
//      Find the queue guid (instance) property in the properties array
//
//---------------------------------------------------------
GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_INSTANCE, pqp)) != NULL)
        return(p->puuid);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpMakeSelfRelativeSDAndGetSize
//
//  Parameters:
//      pSecurityDescriptor - The input security descriptor.
//      pSelfRelativeSecurityDescriptor - A pointer to a temporary buffer
//          that holds the converted security descriptor.
//      pSDSize - A pointer to a variable that receives the length of the
//          self relative security descriptor. This is an optional parameter.
//
//  Description:
//      Convert an absolute security descriptor to a self relative security
//      descriptor and get the size of the self relative security descriptor.
//      This function should be call before passing a security descriptor to
//      a function that passes the security descriptor to an RPC function.
//
//      If the input security descriptor is already a self relative security
//      descriptor, the function only computes the length of the security
//      descriptor and returns. If the input security descriptor is an absolute
//      security descriptor, the function allocates a buffer large enough to
//      accomodate the self relative security descripr, converts the absolute
//      security descriptor to a self relative security descriptor and modifies
//      the pointer of the input security descriptor to point to the self relative
//      security descriptor.
//
//      The temporar buffer that is being allocated for the self relative
//      security descriptor should be freed by the calling code.
//
//---------------------------------------------------------
HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize)
{
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD dwSDRevision;

    ASSERT(pSecurityDescriptor);
    ASSERT(pSelfRelativeSecurityDescriptor);

    *pSelfRelativeSecurityDescriptor = NULL;

    if (!*pSecurityDescriptor)
    {
        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = 0;
        }
        return(MQ_OK);
    }

    // Verify that this is a valid security descriptor.
    if (!IsValidSecurityDescriptor(*pSecurityDescriptor))
    {
        return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 10);
    }

    // Check whether this is a self relative or absolute security
    // descriptor.
    if (!GetSecurityDescriptorControl(*pSecurityDescriptor,
                                      &sdcSDControl,
                                      &dwSDRevision))
    {
        ASSERT(FALSE);
    }

    if (!(sdcSDControl & SE_SELF_RELATIVE))
    {
        // This is an absolute security descriptor, we should convert it
        // to a self relative one.
        DWORD dwBufferLength = 0;

#ifdef _DEBUG
        SetLastError(0);
#endif
        // Get the buffer size.
        MakeSelfRelativeSD(*pSecurityDescriptor, NULL, &dwBufferLength);
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        // Allocate the buffer for the self relative security descriptor.
        *pSelfRelativeSecurityDescriptor =
            (PSECURITY_DESCRIPTOR) new char[dwBufferLength];

        // Convert the security descriptor.
        if (!MakeSelfRelativeSD(
                *pSecurityDescriptor,
                *pSelfRelativeSecurityDescriptor,
                &dwBufferLength))
        {
            ASSERT(FALSE);
        }
        ASSERT(IsValidSecurityDescriptor(*pSelfRelativeSecurityDescriptor));
        *pSecurityDescriptor = *pSelfRelativeSecurityDescriptor;

        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = dwBufferLength;
        }

    }
    else
    {

        // The security descriptor is already in self relative format, just
        // set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = GetSecurityDescriptorLength(*pSecurityDescriptor);
        }

    }

    return(MQ_OK);
}


//---------------------------------------------------------
//
//  Function:
//     RTpConvertToMQCode
//
//  Parameters:
//      hr - Error vode that is generated by any kind of module.
//
// Return value:
//      The imput parameter convetrted to some equivalent MQ_ERROR constant.
//
//---------------------------------------------------------
HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType
    )
{

    if ((hr == MQ_OK)                                   ||
        (hr == MQ_INFORMATION_REMOTE_OPERATION)         ||
        (hr == MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED)   ||
        ((MQ_E_BASE <= hr) && (hr < MQ_E_BASE + 0x100)) ||
        ((MQ_I_BASE <= hr) && (hr < MQ_I_BASE + 0x100)))
    {
        // This is our codes, do not modify it.
        return hr;
    }

    if (hr == MQDS_OK_REMOTE)
    {
        //
        // success - we use MQDS_OK_REMOTE for internal use, e.g. explorer
        //
        return(MQ_OK);
    }

    if (HRESULT_FACILITY(MQ_E_BASE) == HRESULT_FACILITY(hr))
    {
        switch (hr)
        {
        case MQDB_E_NO_MORE_DATA:
        case MQDS_GET_PROPERTIES_ERROR:
        case MQDS_OBJECT_NOT_FOUND:
            hr = (dwObjectType ==  MQDS_QUEUE) ?
                    MQ_ERROR_QUEUE_NOT_FOUND :
                    MQ_ERROR_MACHINE_NOT_FOUND;
            break;

        case MQDS_NO_RSP_FROM_OWNER:
            hr = MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER;
            break;

        case MQDS_OWNER_NOT_REACHED:
            hr = MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE;
            break;

        case MQDB_E_NON_UNIQUE_SORT:
            hr = MQ_ERROR_ILLEGAL_SORT;
            break;

        default:
            // Some DS error occured. This should not happen, but anyway...
            TrWARNING(GENERAL, "A DS error (%x) has propagated to the RT DLL. Converting to MQ_ERROR_DS_ERROR", hr);
            hr = MQ_ERROR_DS_ERROR;
            break;
        }

        return hr;
    }

    if (hr == CPP_EXCEPTION_CODE)
    {
        // A C++ exception occured. This can happen only when in an allocation failure.
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 40);
    }

    // Now we hope that we know how to convert an NTSTATUS to some of our error
    // codes. Good luck...
    switch(hr)
    {
    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
    case STATUS_HANDLE_NOT_CLOSABLE:
        hr = MQ_ERROR_INVALID_HANDLE;
        break;

    case STATUS_ACCESS_DENIED:
        hr = MQ_ERROR_ACCESS_DENIED;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_PARAMETER:
        hr = MQ_ERROR_INVALID_PARAMETER;
        break;

    case STATUS_SHARING_VIOLATION:
        hr = MQ_ERROR_SHARING_VIOLATION;
        break;

    case STATUS_PENDING:
        hr = MQ_INFORMATION_OPERATION_PENDING;
        break;

    case STATUS_CANCELLED:
        hr = MQ_ERROR_OPERATION_CANCELLED;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        break;

    default:
       TrWARNING(GENERAL, "Unfamiliar error code:%x, not converted to a MQ error", hr);
       break;
    }

    return hr;
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetThreadUserSid
//
//  Parameters:
//      pUserSid - A pointer to a buffer that receives the address of a buffer
//          that contains the SID of the user of the current thread.
//      pdwUserSidLen - A pointer to a DWORD that receives the length of the
//          SID.
//
//  Description:
//      The function allocates the buffer for the SID and fils it with the SID
//      of the user of the current thread. The calling code is responsible for
//      freeing the allocated buffer.
//
//---------------------------------------------------------

HRESULT
RTpGetThreadUserSid( BOOL    *pfLocalUser,
                     BOOL    *pfLocalSystem,
                     LPBYTE  *pUserSid,
                     DWORD   *pdwUserSidLen )
{
    HRESULT hr;

	BOOL fNetworkService = FALSE;
    hr = MQSec_GetUserType( 
			NULL,
			pfLocalUser,
			pfLocalSystem,
			&fNetworkService
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    if (*pfLocalSystem || fNetworkService)
    {
		//
		// LocalSystem and NetworkService need to be send as machine$ sid.
		//
        *pUserSid = (LPBYTE) MQSec_GetLocalMachineSid( TRUE, // allocate
                                                       pdwUserSidLen ) ;
        if (!(*pUserSid))
        {
            //
            // this may happen if the machine belong to a NT4 domain
            // and it doesn't have any computer account and sid.
            // In that case, make it a local user.
            //
            ASSERT(*pdwUserSidLen == 0) ;
            *pdwUserSidLen = 0 ;

            *pfLocalSystem = FALSE ;
            if (pfLocalUser)
            {
                ASSERT(!(*pfLocalUser)) ;
                *pfLocalUser = TRUE ;
            }
        }
    }
    else if (!(*pfLocalUser))
    {
        hr = MQSec_GetThreadUserSid(
                    FALSE, 
                    reinterpret_cast<PSID*>(pUserSid),
                    pdwUserSidLen,
                    FALSE           // fThreadTokenOnly
                    );
    }

    return LogHR(hr, s_FN, 70);
}

//---------------------------------------------------------
//
//  Function:
//      RTpExtractDomainNameFromDLPath
//
//  Parameters:
//      pwcsADsPath - string containg ADS path of an object
//
//  Description:
//      The function extracts the domain name from the ADS path
//      for the purpose of building DL format name
//      
//
//---------------------------------------------------------
WCHAR * RTpExtractDomainNameFromDLPath(
            LPCWSTR pwcsADsPath
            )
{
    //
    //  ASSUMPTION - pwcsADsPath contains valid ADS path string
    //               otherwise this routine is not called
    //
const WCHAR x_LdapProvider[] = L"LDAP";
const DWORD x_LdapProviderLen = (sizeof(x_LdapProvider)/sizeof(WCHAR)) - 1;
const WCHAR x_MiddleDcPrefix[] = L",DC=";
const DWORD x_MiddleDcPrefixLength = (sizeof( x_MiddleDcPrefix)/sizeof(WCHAR)) - 1;

    //
    //  Does the ADsPath starts with LDAP:
    //
    if (0 != _wcsnicmp( pwcsADsPath, x_LdapProvider, x_LdapProviderLen))
    {
        //
        //  For ADsPath that start with GC: we don't add the domain name.
        //
        return NULL;
    }
    DWORD len = wcslen(pwcsADsPath);
    AP<WCHAR> pwcsUpperCaseADsPath = new WCHAR[ len +1];
    wcscpy( pwcsUpperCaseADsPath, pwcsADsPath);
    CharUpper(pwcsUpperCaseADsPath);
    WCHAR * pszFirst = wcsstr(pwcsUpperCaseADsPath, x_MiddleDcPrefix);
    if (pszFirst == NULL)
    {
        return NULL;
    }
    bool fAddDelimiter = false;

    AP<WCHAR> pwcsDomainName = new WCHAR[ wcslen(pwcsADsPath) + 1];
    WCHAR* pwcsNextToFill =  pwcsDomainName;
    //
    // skip the DC=
    //
    pszFirst += x_MiddleDcPrefixLength;

    while (true)
    {
        WCHAR * pszLast = wcsstr(pszFirst, x_MiddleDcPrefix);
        if ( pszLast == NULL)
        {
            //
            //  Copy the last section of domain name
            //
            if ( fAddDelimiter)
            {
                *pwcsNextToFill = L'.';
                pwcsNextToFill++;
            }
            *pwcsNextToFill = L'\0';  
            wcscat( pwcsNextToFill, pszFirst);
            break;
        }
        //
        // Copy this section of the domain name
        //
        if ( fAddDelimiter)
        {
            *pwcsNextToFill = L'.';  
            pwcsNextToFill++;
        }
        wcsncpy( pwcsNextToFill, pszFirst, (pszLast - pszFirst));
        pwcsNextToFill +=  (pszLast - pszFirst);
        fAddDelimiter = true;
        pszFirst =  pszLast + x_MiddleDcPrefixLength;
    }

    return( pwcsDomainName.detach());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
 
#define   INITGUID
#include "initguid.h"
 
#define _MTX_NOFORCE_LIBS 
#include "comsvcs.h"
#include "TXDTC.H"
 
#include "xactmq.h"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include <rt.h>

#include "rtp.h"

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\machdomain.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.cpp

Abstract:

	Handle machine domain

Author:		 

    Ilan  Herbst  (ilanh)  4-Sep-2001

--*/

#include "stdh.h"
#include "rtputl.h"
#include "autoreln.h"
#include <Dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include "ad.h"

#include "machdomain.tmh"


static LPWSTR FindMachineDomain()
/*++
Routine Description:
	Find local machine domain

Arguments:
	None

Returned Value:
	machine domain, NULL if not found

--*/
{
	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					NULL, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		//
		// This will be the case in NT4 domain
		//
		TrERROR(GENERAL, "Failed to find local machine domain, DsGetDcName failed, gle = %!winerr!", dw);
		return NULL;
	}

	ASSERT(pDcInfo->DomainName != NULL);
	TrTRACE(GENERAL, "Local machine doamain = %ls", pDcInfo->DomainName);
	AP<WCHAR> pMachineDomain = new WCHAR[wcslen(pDcInfo->DomainName) + 1];
    wcscpy(pMachineDomain, pDcInfo->DomainName);
	return pMachineDomain.detach();
}


static AP<WCHAR> s_pMachineDomain; 

LPCWSTR MachineDomain()
/*++
Routine Description:
	find local machine domain.

Arguments:
	None

Returned Value:
	return machine domain

--*/
{
	if(ADGetEnterprise() == eMqis)
	{
		//
		// mqdscli doesn't need the domain name only mqad
		//
		return NULL;
	}
	
	static bool s_fInitialize = false;

	if(s_fInitialize)
	{
		TrTRACE(GENERAL, "local machine domain = %ls", s_pMachineDomain.get());
		return s_pMachineDomain;
	}

	//
	// Get local computer domain
	//
	AP<WCHAR> pMachineDomain = FindMachineDomain();

	if(NULL != InterlockedCompareExchangePointer(
					&s_pMachineDomain.ref_unsafe(), 
					pMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fInitialize);
		ASSERT(s_pMachineDomain != NULL);
		return s_pMachineDomain;
	}

	//
	// The exchange was done
	//
	s_fInitialize = true;
	ASSERT(s_pMachineDomain == pMachineDomain);
	pMachineDomain.detach();

	TrTRACE(GENERAL, "local machine domain = %ls", s_pMachineDomain.get());
	return s_pMachineDomain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\xactmq.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.cpp

Abstract:
    This module implements CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "txdtc.h"
#include "rtprpc.h"
#include "XactMq.h"
#include <rtdep.h>

#include "xactmq.tmh"

static WCHAR *s_FN=L"rt/XactMq";

//---------------------------------------------------------------------
// CMQTransaction::CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::CMQTransaction()
{
    m_cRefs = 1;
    m_fCommitedOrAborted = FALSE;
    m_hXact = NULL;
    UuidCreate((UUID *)&m_Uow);
}

//---------------------------------------------------------------------
// CMQTransaction::~CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::~CMQTransaction(void)
{
    if (!m_fCommitedOrAborted)
    {
        Abort(NULL, FALSE, FALSE);
    }
}

//---------------------------------------------------------------------
// CMQTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CMQTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {
        *ppv = (IUnknown *)((ITransaction *)this);
    }
    else if (IID_ITransaction == i_iid)
    {
        *ppv = (ITransaction *)this;
    }
    else if (IID_IMSMQTransaction == i_iid)
    {
        *ppv = (IMSMQTransaction *)this;
    }


    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return E_NOINTERFACE;       // from winerror.h
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CMQTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);               // Increment interface usage count.
}


//---------------------------------------------------------------------
// CMQTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::Release(void)
{
    // Is anyone using the interface?
    if (InterlockedDecrement(&m_cRefs))
    {                               // The interface is in use.
        return m_cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}

//+--------------------------------------------------------
//
//    CMQTransaction::CannotUseThisTransaction()
//
//  return TRUE if this transaction object cannot be used anymore for
//  send and receive operations. Bug 4741.
//
//+--------------------------------------------------------

inline BOOL  CMQTransaction::CannotUseThisTransaction()
{
    if (m_fCommitedOrAborted)
    {
        //
        // The transaction object can not be used after commit/abort.
        // It must be released and new one created and initialized.
        //
        return TRUE ;
    }

    return FALSE ;
}

//---------------------------------------------------------------------
// CMQTransaction::Commit
//---------------------------------------------------------------------
HRESULT CMQTransaction::Commit(BOOL fRetaining, DWORD grfTC, DWORD grfRM)
{
   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

   if ((grfTC != 0 && grfTC != XACTTC_SYNC) ||
        grfRM != 0 || fRetaining != FALSE)
   {
       return LogHR(XACT_E_NOTSUPPORTED, s_FN, 10);
   }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

	RpcTryExcept
	{
		rc = R_QMCommitTransaction(&m_hXact);
		m_fCommitedOrAborted = TRUE;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		LogIllegalPoint(s_FN, 20);
		PRODUCE_RPC_ERROR_TRACING;
		rc = (RpcExceptionCode() == RPC_S_CALL_FAILED)? XACT_E_INDOUBT : E_FAIL;
	}
	RpcEndExcept

	return LogHR(rc, s_FN, 30);
}

//---------------------------------------------------------------------
// CMQTransaction::Abort
//---------------------------------------------------------------------
HRESULT CMQTransaction::Abort(BOID* /*pboidReason*/, BOOL fRetaining, BOOL fAsync)
{
   if (fAsync || fRetaining)
   {
       return LogHR(XACT_E_NOTSUPPORTED, s_FN, 40);
   }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

	RpcTryExcept
	{
		rc = R_QMAbortTransaction(&m_hXact);
		m_fCommitedOrAborted = TRUE;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		LogIllegalPoint(s_FN, 50);
		PRODUCE_RPC_ERROR_TRACING;
		rc = E_FAIL;
	}
	RpcEndExcept

	return LogHR(rc, s_FN, 60);
}

//---------------------------------------------------------------------
// CMQTransaction::GetTransactionInfo
//---------------------------------------------------------------------
HRESULT CMQTransaction::GetTransactionInfo(XACTTRANSINFO *pinfo)
{
    ZeroMemory((PVOID)pinfo, sizeof(XACTTRANSINFO));
    CopyMemory((PVOID)&pinfo->uow, (PVOID)&m_Uow, sizeof(XACTUOW));
    return MQ_OK;
}

//---------------------------------------------------------------------
// CMQTransaction::EnlistTransaction
//---------------------------------------------------------------------
HRESULT CMQTransaction::EnlistTransaction(XACTUOW *pUow)
{

    HRESULT hr;

    // No need for several enlistments
    if (m_hXact)
    {
        return MQ_OK;
    }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

    // RPC call to QM for enlistment
    RpcTryExcept
    {
        ASSERT( tls_hBindRpc ) ;
        hr = R_QMEnlistInternalTransaction(tls_hBindRpc, pUow, &m_hXact);
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
       DWORD rc = GetExceptionCode();
       TrERROR(XACT_GENERAL, "CMQTransaction::EnlistTransaction failed: RPC code=%x ", rc);

       LogHR(HRESULT_FROM_WIN32(rc), s_FN, 70);
       PRODUCE_RPC_ERROR_TRACING;
       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
       m_hXact = NULL;
    }
	RpcEndExcept

    if(FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QMEnlistInternalTransaction failed: %x ", hr);
    }
    return LogHR(hr, s_FN, 80);
}


//---------------------------------------------------------------------
//    MQBeginTransaction() - Generates new MSMQ internal transaction
//---------------------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQBeginTransaction(OUT ITransaction **ppTransaction)
{
	if(g_fDependentClient)
		return DepBeginTransaction(ppTransaction);

	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    hr = MQ_OK;
	ITransaction* pTransaction = NULL;
    try
    {
        pTransaction = new CMQTransaction;
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 90);
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }


    if (SUCCEEDED(hr))
    {
        // We are not obliged to enlist immediately, but otherwise Commit for empty xact will fail
        XACTUOW Uow;

        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        if(FAILED(hr))
        {
		    delete pTransaction;
            TrERROR(XACT_GENERAL, "RTpProvideTransactionEnlist failed: %x ", hr);
        }
		else
		{
			*ppTransaction = pTransaction;
		}
    }

    return LogHR(hr, s_FN, 100);
}

//---------------------------------------------------------------------
//    MQGetTmWhereabouts() - brings controlling DTC whereabouts
//    This is a private non-published function which we need outside of the DLL
//---------------------------------------------------------------------
HRESULT
MQGetTmWhereabouts(IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts)
{
    HRESULT hr = MQ_OK;

    // RPC call to QM for getting whereabouts
    RpcTryExcept
    {
        ASSERT( tls_hBindRpc ) ;
        hr = R_QMGetTmWhereabouts(tls_hBindRpc,
                                cbBufSize,
                                pbWhereabouts,
                                pcbWhereabouts);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
       DWORD rc = GetExceptionCode();
       TrERROR(XACT_GENERAL, "MQGetTmWhereabouts failed: RPC code=%x ", rc);

       LogHR(HRESULT_FROM_WIN32(rc), s_FN, 110);
       PRODUCE_RPC_ERROR_TRACING;
       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
	RpcEndExcept

    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QMGetTmWhereabouts failed: %x ", hr);
    }
    return LogHR(hr, s_FN, 120);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\acrpc.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acrpc.cpp

Abstract:
    Simulate AC interface using RPC to QM

Author:
    Erez Haba (erezh) 1-Oct-96

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include "rtp.h"
#include "_mqrpc.h"
#include "rtprpc.h"
#include <acdef.h>

#include "acrpc.tmh"

static WCHAR *s_FN=L"rtdep/acrpc";


#define ONE_KB 1024


inline
HRESULT
DeppExceptionFilter(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}

HRESULT
ACDepCloseHandle(
    HANDLE hQueue
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        //
        //  Use address of hQueue rather than hQueue, since it is an
        //
        LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
        HANDLE hContext = ph95->hContext ;

        hr = rpc_ACCloseHandle(&hContext);

        //
        // Free the binding handle
        //
        mqrpcUnbindQMService( &ph95->hBind,
                              NULL ) ;
        delete ph95 ;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
    RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}


HRESULT
ACDepCreateCursor(
    HANDLE hQueue,
    CACCreateRemoteCursor& cc
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        hr = rpc_ACCreateCursorEx(
                    HRTQUEUE(hQueue),
                    &cc
                    );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepCloseCursor(
    HANDLE hQueue,
    ULONG hCursor
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        hr = rpc_ACCloseCursor(
                    HRTQUEUE(hQueue),
                    hCursor
                    );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepSetCursorProperties(
    HANDLE hProxy,
    ULONG hCursor,
    ULONG  hRemoteCursor
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        hr = rpc_ACSetCursorProperties(
                    HRTQUEUE(hProxy),
                    hCursor,
                    hRemoteCursor
                    );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepSendMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED /*lpOverlapped*/
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        OBJECTID* pMessageID = 0;
        if(tb.old.ppMessageID)
        {
            pMessageID = *tb.old.ppMessageID;
        }

        hr = rpc_ACSendMessageEx(HRTQUEUE(hQueue), &tb, pMessageID);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
    	DWORD gle = GetExceptionCode();
    	PRODUCE_RPC_ERROR_TRACING;
    	TrERROR(SECURITY, "Failed to send message from Dependent client. %!winerr!", gle);
        hr = DeppExceptionFilter(gle);
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

struct AR_CONTEXT {
    HANDLE hEvent;
    HANDLE hQueue;
    CACTransferBufferV2* ptb;
    LPOVERLAPPED lpOverlapped;
};

DWORD
APIENTRY
DeppAsynchronousReceiverThread(
    PVOID pContext
    )
{
    AR_CONTEXT* par = static_cast<AR_CONTEXT*>(pContext);

    HANDLE hQueue = par->hQueue;
    CACTransferBufferV2 tb = *par->ptb;
    LPOVERLAPPED lpOverlapped = par->lpOverlapped;

    //
    //  initialization completed. Release the dispatcher thread
    //
    SetEvent(par->hEvent);

    HANDLE hThread ;
    //
    // note that the cancel routine add five more minutes to this timeout.
    // The five minutes will be applied if server side die and client side
    // has to cancel the rpc call.
    //
    RegisterRpcCallForCancel( &hThread, tb.old.Receive.RequestTimeout) ;

    HRESULT rc = MQ_ERROR;
    RpcTryExcept
    {
        LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
        rc = rpc_ACReceiveMessageEx(ph95->hBind, ph95->hQMContext, &tb);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        rc = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;

    //
    //  The next code can cause exception, if the user release the overlapped
    //  structure; or due to incorrect release order of DLLs in Win95. it may
    //  happen that msvcrt is released before we do freeing the heap, thus
    //  causing the exception on process shut down.
    //
    __try
    {
        lpOverlapped->Internal = rc;
        if(lpOverlapped->hEvent)
        {
            SetEvent(lpOverlapped->hEvent);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return rc;
}

HRESULT
ACDepReceiveMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    )
{
    if (tb.old.Receive.Asynchronous == FALSE)
    {
        //
        //  Synchronous recieve, no need to create thread
        //
        HRESULT hr ;
        HANDLE hThread ;
        //
        // note that the cancel routine add five more minutes to this wake
        // time.
        //
        RegisterRpcCallForCancel( &hThread, tb.old.Receive.RequestTimeout) ;

        RpcTryExcept
        {
            LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
            hr = rpc_ACReceiveMessageEx(ph95->hBind, ph95->hQMContext, &tb);
        }
	    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        	DWORD gle = GetExceptionCode();
        	PRODUCE_RPC_ERROR_TRACING;
        	TrERROR(SECURITY, "Failed to receive message on dependent client. %!winerr!.", gle);
            hr = DeppExceptionFilter(gle);
        }
		RpcEndExcept

        UnregisterRpcCallForCancel( hThread ) ;
        return hr ;
    }

    __try
    {
        //
        //  Asynchronous recieve, init context and create receving thread
        //
        AR_CONTEXT ar = {GetThreadEvent(), hQueue, &tb, lpOverlapped};
        ResetEvent(ar.hEvent);

        if(lpOverlapped->hEvent)
        {
            ResetEvent(lpOverlapped->hEvent);
        }

        HANDLE hThread;
        DWORD dwThreadID;
        hThread = CreateThread(
                    0,
                    0,
                    DeppAsynchronousReceiverThread,
                    &ar,
                    0,
                    &dwThreadID
                    );

        if(hThread == 0)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Wait for thread initalization
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ar.hEvent,
                        INFINITE
                        );

        ASSERT(dwResult == WAIT_OBJECT_0);
        CloseHandle(hThread);

        return STATUS_PENDING;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return DeppExceptionFilter(GetExceptionCode());
    }
}

HRESULT
ACDepHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        hr = rpc_ACHandleToFormatName(
                    HRTQUEUE(hQueue),
                    min( *lpdwFormatNameLength, ONE_KB),
                    lpwcsFormatName,
                    lpdwFormatNameLength
                    );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepPurgeQueue(
    HANDLE hQueue,
    BOOL /*fDelete*/
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    RpcTryExcept
    {
        hr = rpc_ACPurgeQueue(HRTQUEUE(hQueue));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        hr = DeppExceptionFilter(GetExceptionCode());
        PRODUCE_RPC_ERROR_TRACING;
    }
	RpcEndExcept

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\acrt.h ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Module Name:
    acrt.h

Abstract:
    wrapper functions for calling driver or RPC on NT

Author:
    Doron Juster  (DoronJ)  07-Apr-1997   Created

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#ifndef _ACRT_H_
#define _ACRT_H_

#include <acdef.h>

#include <acioctl.h>
#include <acdef.h>

//
// RPC between RT and local QM is used on Win95 and on NT clients.
// The following macro check for this condition.
//

#define IF_USING_RPC  \
   if ((g_fDependentClient) || (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))

//
// On Win95 and on NT client, a queue handle which is returned to
// application is a pointer to this structure. The reason we keep the three
// handles is that doing RPC with context handle serialzes the calls. This is
// OK for all calls except MQReceive(). (a pending receive will block all
// future calls with the same handle, so we can't even close the queue).
// So, MQReceive() uses the binding handle and give the QM the context it
// expects as a DWORD.  Rt get this QM context when opening the queue.
//
typedef struct _tagMQWIN95_QHANDLE {
  handle_t hBind ;
  HANDLE   hContext ;
  DWORD    hQMContext ;
} MQWIN95_QHANDLE, *LPMQWIN95_QHANDLE ;


HRESULT
ACDepCloseHandle(
    HANDLE hQueue
    );

HRESULT
ACDepCreateCursor(
    HANDLE hQueue,
    CACCreateRemoteCursor& tb
    );

HRESULT
ACDepCloseCursor(
    HANDLE hQueue,
    ULONG hCursor
    );

HRESULT
ACDepSetCursorProperties(
    HANDLE hProxy,
    ULONG hCursor,
    ULONG hRemoteCursor
    );

HRESULT
ACDepSendMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    );

HRESULT
ACDepReceiveMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    );

HRESULT
ACDepHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
ACDepPurgeQueue(
    HANDLE hQueue,
    BOOL fDelete
    );

#define HRTQUEUE(hQueue)  (((LPMQWIN95_QHANDLE)hQueue)->hContext)




#endif // _ACRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\xactmq.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.h

Abstract:
    This module defines CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTMQ_H__
#define __XACTMQ_H__

//IID_IMSMQTransaction 2f221ca0-d1de-11d0-9215-0060970536a0
DEFINE_GUID(IID_IMSMQTransaction,
		    0x2f221ca0,
		    0xd1de,
		    0x11d0,
		    0x92, 0x15, 0x00, 0x60, 0x97, 0x05, 0x36, 0xa0);

interface IMSMQTransaction : public IUnknown
{
public:
    virtual HRESULT __stdcall EnlistTransaction(XACTUOW *pUow) = 0;
};


//---------------------------------------------------------------------
// CMQTransaction: Transaction Object in Falcon RT
//---------------------------------------------------------------------
class CMQTransaction: public ITransaction,
                      public IMSMQTransaction
{
public:

    // Construction and COM
    //
    CMQTransaction();
    ~CMQTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    STDMETHODIMP Commit(
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);

    STDMETHODIMP Abort(
            /* [in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);

    STDMETHODIMP  GetTransactionInfo(
            /* [out] */ XACTTRANSINFO *pinfo);

    STDMETHODIMP   EnlistTransaction(
            /* in]  */  XACTUOW *pUow);

private:
    LONG    m_cRefs;
    BOOL    m_fCommitedOrAborted;
    XACTUOW m_Uow;

    RPC_INT_XACT_HANDLE m_hXact;

    BOOL  CannotUseThisTransaction() ;
};

#endif __XACTMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rt\xactrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    XactRT.cpp

Abstract:

    This module contains RT code involved with transactions.

Author:

    Alexander Dadiomov (alexdad) 19-Jun-96

Revision History:

--*/

#include "stdh.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "cs.h"
#include "mqutil.h"
#include "rtprpc.h"
#include "xactmq.h"
#include <rtdep.h>

#include "xactrt.tmh"

static WCHAR *s_FN=L"rt/XactRT";

//RT transactions cache:  ring buffer of transaction UOWs
#define XACT_RING_BUF_SIZE   16                        // size of the transactions ring buffer

static  XACTUOW  s_uowXactRingBuf[XACT_RING_BUF_SIZE];   // transaction ring buffer

ULONG   s_ulXrbFirst =  XACT_RING_BUF_SIZE;  // First used element in transaction ring buffer
ULONG   s_ulXrbLast  =  XACT_RING_BUF_SIZE;  // Last  used element in transaction ring buffer

static CCriticalSection s_RingBufCS;
static CCriticalSection s_WhereaboutsCS;

// Whereabouts of the controlling DTC for the QM
ULONG     g_cbQmTmWhereabouts = 0;      // length of DTC whereabouts
AP<BYTE>  g_pbQmTmWhereabouts;   // DTC whereabouts

extern HRESULT MQGetTmWhereabouts(
                   IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts);

//---------------------------------------------------------
//  BOOL FindTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  *not* adds
//    returns TRUE if xaction was found, FALSE - if not
//---------------------------------------------------------
static BOOL FindTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//---------------------------------------------------------
//  BOOL RememberTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  adds there if not found;
//    returns TRUE if xaction was found, FALSE - if it was added
//---------------------------------------------------------
static BOOL RememberTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    // No check for ring buffer overflow, because it is not dangerous (maximum RT will go to QM)

    // adding transaction to the ring buffer

    if (s_ulXrbFirst == XACT_RING_BUF_SIZE)
    {
        // Ring buffer is empty
        s_ulXrbFirst = s_ulXrbLast = 0;
        memcpy(&s_uowXactRingBuf[s_ulXrbFirst], pUow, sizeof(XACTUOW));
    }
    else
    {
        s_ulXrbLast = (s_ulXrbLast == XACT_RING_BUF_SIZE-1 ? 0 : s_ulXrbLast+1);
        memcpy(&s_uowXactRingBuf[s_ulXrbLast], pUow, sizeof(XACTUOW));
    }

    return FALSE;
}

//---------------------------------------------------------
// HRESULT RTpGetExportObject
//
//  Description:
//
//    Creates and caches the DTC export object
//---------------------------------------------------------
HRESULT RTpGetExportObject(IUnknown  *punkDtc,
                           ULONG     cbTmWhereabouts,
                           BYTE      *pbTmWhereabouts,
						   ITransactionExport **ppExport)
{
	HRESULT                          hr = MQ_OK;
    R<ITransactionExportFactory>     pTxExpFac   = NULL;

    // Get the DTC's ITransactionExportFactory interface
    hr = punkDtc->QueryInterface (IID_ITransactionExportFactory, (void **)(&pTxExpFac.ref()));
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QueryInterface failed: %x ", hr);
       return LogHR(hr, s_FN, 20);
    }


    // Create Export object
	R<ITransactionExport> pExport;
    hr = pTxExpFac->Create (cbTmWhereabouts, pbTmWhereabouts, &pExport.ref());
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "Create Export Object failed: %x ", hr);
       return LogHR(hr, s_FN, 30);
    }

	*ppExport = pExport.detach();

    return(MQ_OK);
}

//---------------------------------------------------------
// HRESULT RTpBuildTransactionCookie
//
//  Description:
//
//    Builds transaction Cookie
//---------------------------------------------------------
HRESULT RTpBuildTransactionCookie(ITransactionExport *pExport,
								  ITransaction		 *pTrans,
                                  ULONG				 *pcbCookie,
                                  BYTE				**ppbCookie)
{
    HRESULT                          hr = MQ_OK;
    ULONG                            cbUsed;
    R<IUnknown>                      punkTx = NULL;

    *pcbCookie = 0;
    *ppbCookie = NULL;

    // Get transaction's Unknown
    hr = pTrans->QueryInterface (IID_IUnknown, (void **)(&punkTx.ref()));
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QueryInterface failed: %x ", hr);
       return LogHR(hr, s_FN, 40);
    }

	// Get transaction cookie size
	hr = pExport->Export (punkTx.get(), pcbCookie);
	if (FAILED(hr) || *pcbCookie == 0)
	{
	   TrERROR(XACT_GENERAL, "Export failed: %x ", hr);
	   return LogHR(hr, s_FN, 50);
	}
	// Allocate memory for transaction Cookie
	try
	{
		*ppbCookie =  new BYTE[*pcbCookie];
	}
	catch(const bad_alloc&)
	{
		TrERROR(XACT_GENERAL, "Allocation failed: %x ", hr);
		LogIllegalPoint(s_FN, 60);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	// Get transaction Cookie itself
	hr = pExport->GetTransactionCookie(punkTx.get(), *pcbCookie, *ppbCookie, &cbUsed);
	if (FAILED(hr))
	{
	   TrERROR(XACT_GENERAL, "GetTransactionCookie failed: %x ", hr);
	   return LogHR(hr, s_FN, 70);
	}

    return(MQ_OK);
}


//---------------------------------------------------------
// HRESULT RTXactGetDTC
//
//  Description:
//
//  Obtains DTC transaction manager.  Defers to mqutil
//
//  Outputs:
//    ppunkDTC      pointers to DTC transaction manager
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
RTXactGetDTC(
    IUnknown **ppunkDTC
    )
{
	if(g_fDependentClient)
		return DepXactGetDTC(ppunkDTC);
	
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr =  MQ_ERROR;

    hr = XactGetDTC(ppunkDTC);
    LogHR(hr, s_FN, 80);

    return (SUCCEEDED(hr) ? MQ_OK : hr);
}


//---------------------------------------------------------
// HRESULT EnlistTransaction
//
//  Description:
//
//		Helper function to Enlist Transaction.
//		this function use OLD C STYLE EXCEPTIONS
//		therefore we can not use this code in the main function
//---------------------------------------------------------
HRESULT EnlistTransaction(XACTUOW *pUow, ULONG cbCookie, BYTE* pbCookie)
{
    // RPC CALL
	HRESULT hr;
	RpcTryExcept
    {
        ASSERT( tls_hBindRpc ) ;
        hr = R_QMEnlistTransaction(tls_hBindRpc, pUow, cbCookie, pbCookie);
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
       DWORD rc = GetExceptionCode();
       TrERROR(XACT_GENERAL, "RTpProvideTransactionEnlist failed: RPC code=%x ", rc);
       LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90); 

       PRODUCE_RPC_ERROR_TRACING;

       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
	RpcEndExcept
		
	return hr;
}


//---------------------------------------------------------
// HRESULT RTpGetWhereabouts
//
//  Description:
//
//    Creates and caches the Whereabout data
//---------------------------------------------------------
HRESULT RTpGetWhereabouts (ULONG *pcbTmWhereabouts, BYTE **ppbTmWhereabouts)
{
	BYTE* pbTempWhereaboutsBuf;
	ULONG nTempWhereaboutSize;

	{
		CS lock (s_WhereaboutsCS);
		pbTempWhereaboutsBuf = g_pbQmTmWhereabouts.get();
		nTempWhereaboutSize = g_cbQmTmWhereabouts;
	}

	if (NULL == pbTempWhereaboutsBuf)
    {
		nTempWhereaboutSize = 128;
		pbTempWhereaboutsBuf  = new BYTE[128];
		DWORD cbNeeded;

		HRESULT hr = MQGetTmWhereabouts(nTempWhereaboutSize, pbTempWhereaboutsBuf, &cbNeeded);

		if (hr == MQ_ERROR_USER_BUFFER_TOO_SMALL)
		{
			delete[] pbTempWhereaboutsBuf;
			nTempWhereaboutSize = cbNeeded;
			pbTempWhereaboutsBuf = new BYTE[cbNeeded];
			hr = MQGetTmWhereabouts(nTempWhereaboutSize, pbTempWhereaboutsBuf, &cbNeeded);
		}

		if (FAILED(hr))
		{
			delete[] pbTempWhereaboutsBuf;	
			TrERROR(XACT_GENERAL, "MQGetTmWhereabouts failed: %x ", hr);
			return LogHR(hr, s_FN, 104);

		}

		//
		// Notice that the global Whereabouts never deleted, Values are for ever so we dont need to sync again.
		//

		CS lock(s_WhereaboutsCS);
		if (NULL == g_pbQmTmWhereabouts.get())
		{
			g_pbQmTmWhereabouts = pbTempWhereaboutsBuf; 
			g_cbQmTmWhereabouts = nTempWhereaboutSize;
		}
		else
		{
			delete[] pbTempWhereaboutsBuf;
		}
    }

	*ppbTmWhereabouts = g_pbQmTmWhereabouts;
	*pcbTmWhereabouts = g_cbQmTmWhereabouts;

	return MQ_OK;
}


//---------------------------------------------------------
// HRESULT RTpProvideTransactionEnlist
//
//  Description:
//
//    Provides that QM is enlisted in this transaction,
//    checks the transaction state
//---------------------------------------------------------
HRESULT RTpProvideTransactionEnlist(ITransaction *pTrans, XACTUOW *pUow)
{
    //
    // Get the transaction info. UOW resides there.
    //
    XACTTRANSINFO                   xinfo;
    HRESULT hr = pTrans->GetTransactionInfo(&xinfo);
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "GetTransactionInfo failed: %x ", hr);
        hr = MQ_ERROR_TRANSACTION_ENLIST; 
        return LogHR(hr, s_FN, 101);
    }

    // Put pointer to UOW in the output parameter
    CopyMemory(pUow, &xinfo.uow, sizeof(XACTUOW));

    //
    // Is it internal transaction?
    //
    R<IMSMQTransaction>            pIntXact;
    pTrans->QueryInterface (IID_IMSMQTransaction, (void **)(&pIntXact));

    if (pIntXact.get())
    {
       // Internal transactions
       //------------------------
       hr = pIntXact->EnlistTransaction(pUow);
       if (FAILED(hr))
       {
            TrERROR(XACT_GENERAL, "EnlistTransaction failed: %x ", hr);
       }
	   return LogHR(hr, s_FN, 100);
	}
	   
	// External transactions
    //------------------------

    // Look for the transaction in the cache
    //
    if (FindTransaction(pUow))     // this xaction is known already; QM must have been enlisted
    {
        hr = MQ_OK;
        return LogHR(hr, s_FN, 102);
    }

    // Get the DTC IUnknown and TM whereabouts
    //
	R<IUnknown>                    punkDtc;
    hr = XactGetDTC(&punkDtc.ref());
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "XactGetDTC failed: %x ", hr);
        return LogHR(hr, s_FN, 103);
    }

    //
	// Get the QM's controlling DTC whereabouts
    //
	BYTE* pbTempWhereaboutsBuf;
	ULONG nTempWhereaboutSize;
	hr = RTpGetWhereabouts(&nTempWhereaboutSize, &pbTempWhereaboutsBuf);
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "RTpGetWhereabouts failed: %x ", hr);
		return LogHR(MQ_ERROR_TRANSACTION_ENLIST, s_FN, 105);
	}

	//
	// Get and cache Export object
	//
	
	R<ITransactionExport> pTempExport;
	hr = RTpGetExportObject(
				   punkDtc.get(),
				   nTempWhereaboutSize,
				   pbTempWhereaboutsBuf,
				   &pTempExport.ref());
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "RTpGetExportObject failed: %x ", hr);
		return LogHR(MQ_ERROR_TRANSACTION_ENLIST, s_FN, 106);
	}

	//
	// Prepare the transaction Cookie
	//
	ULONG     cbCookie;
	AP<BYTE>  pbCookie;
	hr = RTpBuildTransactionCookie(
				pTempExport.get(),
				pTrans,
				&cbCookie,
				&pbCookie);
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "RTpBuildTransactionCookie failed: %x ", hr);
		return LogHR(MQ_ERROR_TRANSACTION_ENLIST, s_FN, 107);
	}
    //
    // RPC call to QM for enlistment
    //
	hr = EnlistTransaction(pUow, cbCookie, pbCookie);

    //Now that transaction is actually enlisted we remember it in ring buffer
    if (SUCCEEDED(hr))
    {
        RememberTransaction(pUow);
    }
    else
    {
        TrTRACE(XACT_GENERAL, "QMEnlistTransaction failed: %x ", hr);
    }

    return LogHR(hr, s_FN, 108);
}


//---------------------------------------------------------
// void RTpInitXactRingBuf()
//
//  Description:
//
//    Initiates the ring buffer data
//---------------------------------------------------------
void RTpInitXactRingBuf()
{
    CS lock(s_RingBufCS);

    s_ulXrbFirst =  XACT_RING_BUF_SIZE;
    s_ulXrbLast  =  XACT_RING_BUF_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\qmmgmt_c_.c ===
#pragma warning(push, 3)
#include <qmmgmt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\cursor.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cursor.cpp

Abstract:

    This module contains code involved with Cursor APIs.

Author:

    Erez Haba (erezh) 21-Jan-96
    Doron Juster  16-apr-1996, added MQFreeMemory.
    Doron Juster  30-apr-1996, added support for remote reading.

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include "rtprpc.h"
#include <acdef.h>

#include "cursor.tmh"

static WCHAR *s_FN=L"rtdep/cursor";


extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

inline
HRESULT
MQpExceptionTranslator(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}


//
// Asnyc RPC related functions
//

static HRESULT GetResetThreadEvent(HANDLE& hEvent)
/*++
Routine Description:
	Get And reset Thread event.
	Since thread events are created with bManualReset = TRUE.
	And rpc async call does not reset the event before using it,
	we must use ResetEvent before using them to ensure they are not signaled.

Arguments:
	hEvent - event to be initialize (and reset) from thread event.

Returned Value:
	HRESULT

--*/
{
	//
	// Thread event for sync mechanism 
	//
	hEvent = GetThreadEvent();		
	if(hEvent == NULL)
		return MQ_ERROR_INSUFFICIENT_RESOURCES;

	//
	// rpc async does not reset the event,
	// It is the application responsibility.
	// Reset the event before using it.
	//
	if(!ResetEvent(hEvent))
	{
		DWORD gle = GetLastError();
		return HRESULT_FROM_WIN32(gle);
	}
	
	return MQ_OK;
}


static 
HRESULT	
RtdeppInitAsyncHandle(
	PRPC_ASYNC_STATE pAsync 
	)
/*++
Routine Description:
	Initialize RPC async statse structure.
	Use event is sync mechanism.

Arguments:
	pAsync - pointer to RPC async statse structure.

Returned Value:
	HRESULT

--*/
{
	//
	// Get and reset Thread event for sync mechanism 
	//
	HANDLE hEvent = NULL;
	HRESULT hr = GetResetThreadEvent(hEvent);		
	if(FAILED(hr))			
		return hr;

	RPC_STATUS rc = RpcAsyncInitializeHandle(pAsync, sizeof(RPC_ASYNC_STATE));
	if (rc != RPC_S_OK)
	{
		TrERROR(RPC, "RpcAsyncInitializeHandle failed, gle = %!winerr!", rc);
		return HRESULT_FROM_WIN32(rc);
	}

	pAsync->UserInfo = NULL;
	pAsync->NotificationType = RpcNotificationTypeEvent;
	pAsync->u.hEvent = hEvent;
	return MQ_OK;
}


static 
HRESULT 
RtdeppClientRpcAsyncCompleteCall(	
	PRPC_ASYNC_STATE pAsync
	)
/*++
Routine Description:
	Client side complete async call.
	The client wait on the Event with timeout.
	In case of failure, except for server routine returning error code,
	an exception is thrown.

Arguments:
	pAsync - pointer to RPC async statse structure.
	
Returned Value:
	HRESULT

--*/
{
	DWORD res = WaitForSingleObject(pAsync->u.hEvent, g_CancelRpc.RpcCancelTimeout());

	if(res != WAIT_OBJECT_0)
	{
		//
		// Timeout, or failures in WaitForSingleObject.
		//
		TrERROR(RPC, "WaitForSingleObject failed, res = %d", res);

		//
		// Cancel Async rpc call
		// fAbortCall = TRUE
		// the call is cancelled immediately
		// after the function returns, the event will not be signaled.
		//
		RPC_STATUS rc = RpcAsyncCancelCall(
							pAsync, 
							TRUE	// fAbortCall
							);
		ASSERT(rc == RPC_S_OK);
		DBG_USED(rc);

		RaiseException(res, 0, 0, 0);
	}
	
	HRESULT hr = MQ_OK;
    RPC_STATUS rc = RpcAsyncCompleteCall(pAsync, &hr);
    if(rc != RPC_S_OK)
	{
		//
		// Failed to get returned value from server
		//
		TrERROR(RPC, "RpcAsyncCompleteCall failed, gle = %!winerr!", rc);
	    RaiseException(rc, 0, 0, 0);
    }
    
    if(FAILED(hr))
    {
		TrERROR(RPC, "Server RPC function failed, hr = %!hresult!", hr);
    }

    return hr;
}


static
HRESULT
DeppCreateRemoteCursor(
	handle_t hBind,
	DWORD  hQueue,
	DWORD* phRCursor
	)
{
	ASSERT(phRCursor != NULL);
    *phRCursor = 0;

	RPC_ASYNC_STATE Async;
	HRESULT hr = RtdeppInitAsyncHandle(&Async);
	if (FAILED(hr))
	{
		return hr;
	}

    //
    // Pass the old TransferBuffer to Create Remote Cursor
    // for MSMQ 1.0 compatibility.
    //
    CACTransferBufferV1 tb;
    ZeroMemory(&tb, sizeof(tb));
    tb.uTransferType = CACTB_CREATECURSOR;

	RpcTryExcept
	{
		R_QMCreateRemoteCursor(&Async, hBind, &tb, hQueue, phRCursor);
		hr = RtdeppClientRpcAsyncCompleteCall(&Async);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		hr = RpcExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
        TrERROR(RPC, "R_QMCreateRemoteCursor failed, gle = %!winerr!", hr);
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}
	RpcEndExcept

	return hr;
}


static 
HRESULT 
RtdeppBindAndCreateRemoteCursor(
	LPCWSTR lpRemoteQueueName,
	DWORD  hQueue,
	DWORD* phRCursor,
	ULONG* pAuthnLevel
	)
/*++
Routine Description:
	Bind remote Qm and Create Remote Cursor

Arguments:
	lpRemoteQueueName - Remote queue Name.
    hQueue - Remote queue handle.
    phRCursor - pointer to remote cursor handle.
	pAuthnLevel - RPC authentication level

Returned Value:
	HRESULT

--*/
{
	handle_t hBind = NULL;                                  
	HRESULT hr =  RTpBindRemoteQMService(                  
							const_cast<LPWSTR>(lpRemoteQueueName),                       
							&hBind,                         
							pAuthnLevel                   
							);
	if(FAILED(hr))
	{
		ASSERT(hBind == NULL);
		return MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE;
	}

	hr = DeppCreateRemoteCursor(
			hBind,
			hQueue,
			phRCursor
			);

	ASSERT(hBind != NULL);
	mqrpcUnbindQMService(&hBind, NULL);                        

	return hr;

}


static 
HRESULT 
RtdeppCreateRemoteCursor(
	LPCWSTR lpRemoteQueueName,
	DWORD  hQueue,
	DWORD* phRCursor
	)
/*++
Routine Description:
	Create Remote Cursor
	This function tries first with PKT_INTEGRITY and fall back to LEVEL_NONE.

Arguments:
	lpRemoteQueueName - Remote queue Name.
    hQueue - Remote queue handle.
    phRCursor - pointer to remote cursor handle.

Returned Value:
	HRESULT

--*/
{
	bool fTry = true;
	ULONG AuthnLevel = MQSec_RpcAuthnLevel();
	HRESULT hr = MQ_OK;

    while(fTry)
	{
		fTry = false;

		//
		// Call remote QM to OpenRemoteQueue.
		//
		hr = RtdeppBindAndCreateRemoteCursor(
				lpRemoteQueueName,
				hQueue,
				phRCursor,
				&AuthnLevel
				);

        if((hr == MQ_ERROR_SERVICE_NOT_AVAILABLE) && (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE))
        {                                              
			TrWARNING(RPC, "Failed for AuthnLevel = %d, retrying with RPC_C_AUTHN_LEVEL_NONE", AuthnLevel);
			AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;  
			fTry = true;                    

        }                                 
    }

	return hr;
}


EXTERN_C
HRESULT
APIENTRY
DepCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPTSTR lpRemoteQueueName = NULL;
    ULONG hCursor = 0;
    CCursorInfo* pCursorInfo = 0;

    rc = MQ_OK;

    __try
    {
        __try
        {
            __try
            {
                pCursorInfo = new CCursorInfo;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return MQ_ERROR_INSUFFICIENT_RESOURCES;
            }

            pCursorInfo->hQueue = hQueue;

            CACCreateRemoteCursor cc;

            //
            //  Call AC driver with transfer buffer
            //
            rc = ACDepCreateCursor(hQueue, cc);

            //
            //  save local cursor handle for cleanup
            //
            hCursor = cc.hCursor;

            if(rc == MQ_INFORMATION_REMOTE_OPERATION)
            {
				//
				// This code is kept for compatability
				// with supporting server older than .NET
				// .NET supporting server will perform the 
				// remote create cursor on the client behalf.
				//
				
				//
				//  For remote operation 'cc' fields are:
				//      srv_hACQueue - holds the remote queue handle
				//      cli_pQMQueue - holds the local QM queue object
				//
				// create a cursor on remote QM.
				//
				ASSERT(cc.srv_hACQueue);
				ASSERT(cc.cli_pQMQueue);

				INIT_RPC_HANDLE;

				if(tls_hBindRpc == 0)
					return MQ_ERROR_SERVICE_NOT_AVAILABLE;

				//
                // Get name of remote queue from local QM.
				//
				rc = R_QMGetRemoteQueueName(
                        tls_hBindRpc,
                        cc.cli_pQMQueue,
                        &lpRemoteQueueName
                        );

                if(SUCCEEDED(rc) && lpRemoteQueueName)
                {
                    //
                    // OK, we have a remote name. Now bind to remote machine
                    // and ask it to create a cursor.
                    //
                    DWORD hRCursor = 0;

					rc = RtdeppCreateRemoteCursor(
							lpRemoteQueueName,
							cc.srv_hACQueue,
                            &hRCursor
							);
							
                    if(SUCCEEDED(rc))
                    {
						//
                        // set remote cursor handle to local cursor
						//
                        rc = ACDepSetCursorProperties(hQueue, hCursor, hRCursor);
                        ASSERT(SUCCEEDED(rc));
                    }
                }
            }

            if(SUCCEEDED(rc))
            {
                pCursorInfo->hCursor = hCursor;
                *phCursor = pCursorInfo;
                pCursorInfo = 0;
            }
        }
        __finally
        {
            delete pCursorInfo;
            delete[] lpRemoteQueueName;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  MQpExceptionTranslator(GetExceptionCode());
    }

    if(FAILED(rc) && (hCursor != 0))
    {
        ACDepCloseCursor(hQueue, hCursor);
    }

    return rc;
}

EXTERN_C
HRESULT
APIENTRY
DepCloseCursor(
    IN HANDLE hCursor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    IF_USING_RPC
    {
        if (!tls_hBindRpc)
        {
            INIT_RPC_HANDLE ;
        }

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }

    CMQHResult rc;
    __try
    {
        rc = ACDepCloseCursor(
                CI2QH(hCursor),
                CI2CH(hCursor)
                );

        if(SUCCEEDED(rc))
        {
            //
            //  delete the cursor info only when everything is OK. we do not
            //  want to currupt user heap.
            //
            delete hCursor;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The cursor structure is invalid
        //
        return MQ_ERROR_INVALID_HANDLE;
    }

    return rc;
}


EXTERN_C
void
APIENTRY
DepFreeMemory(
    IN  PVOID pvMemory
    )
{
	ASSERT(g_fDependentClient);

	if(FAILED(DeppOneTimeInit()))
		return;

	delete[] pvMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\qmrt_c_.c ===
#pragma warning(push, 3)
#include <qmrt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\machine.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module contains code involved with Machine APIs.

Author:

    Ronit Hartmann (ronith)

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include <ad.h>
#include <mqsec.h>
#include "_registr.h"
#include <_guid.h>
#include "version.h"
#include <mqversion.h>
#include <mqnames.h>
#include "rtputl.h"

#include "machine.tmh"

static WCHAR *s_FN=L"rtdep/machine";

BOOL
IsConnectionRequested(IN MQQMPROPS * pQMProps,
                      IN DWORD* pdwIndex)
{
    for(DWORD i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_CONNECTION)
        {
            ASSERT(pQMProps-> aPropVar[i].vt == VT_NULL);

            pQMProps->aPropID[i] = PROPID_QM_SITE_IDS;
            *pdwIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

//+------------------------------------------
//
//  HRESULT  GetEncryptionPublicKey()
//
//+------------------------------------------

HRESULT
GetEncryptionPublicKey(
    IN LPCWSTR          lpwcsMachineName,
    IN const GUID *     pguidMachineId,
    IN OUT HRESULT*     aStatus,
    IN OUT MQQMPROPS   *pQMProps
    )
{
    DWORD i;
    BOOL fFirst = TRUE;
    HRESULT hr = MQ_OK;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if ((pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK) ||
            (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_BASE))
        {
            //
            // Use msmq1.0 code, because our server can be either msmq1.0
            // or msmq2.0.
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 10);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                PROPID prop =  PROPID_QM_ENCRYPT_PK;

                if (lpwcsMachineName)
                {
                    hr = ADGetObjectProperties(
								eMACHINE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,	   // fServerName
								lpwcsMachineName,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                else
                {
                    hr = ADGetObjectPropertiesGuid(
								eMACHINE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,	   // fServerName
								pguidMachineId,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                if (FAILED(hr))
                {
                    break;
                }

				//
				// PROPID_QM_ENCRYPTION_PK, PROPID_QM_ENCRYPTION_PK_BASE
				// are VT_UI1|VT_VECTOR
				// while PROPID_QM_ENCRYPT_PK is VT_BLOB
				//
                ASSERT(pQMProps-> aPropVar[i].vt == VT_BLOB);
                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20) ;
    }

    //
    // now see if caller asked for enhanced key (128 bits).
    //
    fFirst = TRUE;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_ENHANCED)
        {
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 30);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                P<BYTE> pPbKey ;
                DWORD dwReqLen;

                hr = MQSec_GetPubKeysFromDS( pguidMachineId,
                                             lpwcsMachineName,
                                             eEnhancedProvider,
                                             PROPID_QM_ENCRYPT_PKS,
                                            &pPbKey,
                                            &dwReqLen ) ;
                if (FAILED(hr))
                {
                    break;
                }

                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                pQMProps-> aPropVar[i].caub.cElems = dwReqLen;
                pQMProps-> aPropVar[i].caub.pElems = new UCHAR[dwReqLen];
                memcpy(pQMProps->aPropVar[i].caub.pElems, pPbKey.get(), dwReqLen);

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    return LogHR(hr, s_FN, 40);
}

HRESULT GetCNNameList(IN OUT MQPROPVARIANT* pVar)
{
    ASSERT(pVar->vt == (VT_CLSID|VT_VECTOR));

    //
    // pVar contains the list of sites where the machine reside
    //

    LPWSTR * pElems = new LPWSTR[(pVar->cauuid).cElems];

    for(DWORD i = 0; i < (pVar->cauuid).cElems; i++)
    {
        HRESULT hr;
        PROPID      aProp[2];
        PROPVARIANT aVar[2];
        ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

        aProp[0] = PROPID_S_FOREIGN;
        aProp[1] = PROPID_S_PATHNAME;
        aVar[0].vt = VT_UI1;
        aVar[1].vt = VT_NULL;

        hr = ADGetObjectPropertiesGuid(
                        eSITE,
						MachineDomain(),      // pwcsDomainCOntroller
						false,	    // fServerName
                        &((pVar->cauuid).pElems[i]),
                        cProps,
                        aProp,
                        aVar);   

        if (FAILED(hr))
        {
            for (DWORD j = 0 ; j < i ; j++ )
            {
                delete pElems[j] ;
            }
            delete[] pElems ;

            return LogHR(hr, s_FN, 50);
        }

        GUID_STRING wszGuid;
        MQpGuidToString(&((pVar->cauuid).pElems[i]), wszGuid);

        DWORD dwTypeSize;
        LPWSTR lpwsTypeNmae;

        switch (aVar[0].bVal)
        {
            case 0:
                //
                //  non foreign site
                //
                dwTypeSize = wcslen(L"IP_CONNECTION");
                lpwsTypeNmae = L"IP_CONNECTION";
                break;
            case 1:
                //
                // foreign site
                //
                dwTypeSize = wcslen(L"FOREIGN_CONNECTION");
                lpwsTypeNmae = L"FOREIGN_CONNECTION";
                break;
            default:
                dwTypeSize = wcslen(L"UNKNOWN_CONNECTION");
                lpwsTypeNmae = L"UNKNOWN_CONNECTION";
                break;
        }

        DWORD CNNameSize = dwTypeSize + 1 +                 // protocol id
                           wcslen(wszGuid) + 1 +            // site Guid
                           wcslen(aVar[1].pwszVal) + 1;     // site Name

        pElems[i] = new WCHAR[CNNameSize];
        wsprintf(pElems[i],L"%s %s %s",lpwsTypeNmae, wszGuid, aVar[1].pwszVal);

        delete  [] aVar[1].pwszVal;
    }

    delete [] (pVar->cauuid).pElems;
    (pVar->calpwstr).cElems = (pVar->cauuid).cElems;
    (pVar->calpwstr).pElems = pElems;

    pVar->vt = VT_LPWSTR|VT_VECTOR;

    return MQ_OK;
}

EXTERN_C
HRESULT
APIENTRY
DepGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID *    pguidMachineId,
    IN OUT MQQMPROPS * pQMProps)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc(MQDS_MACHINE), rc1(MQDS_MACHINE);
    LPWSTR lpwsPathName =  (LPWSTR)lpwcsMachineName;
    MQQMPROPS *pGoodQMProps;
    char *pTmpQPBuff = NULL;
    BOOL fGetConnection = FALSE;
    DWORD dwConnectionIndex = 0;
    HRESULT* aLocalStatus_buff = NULL;


    __try
    {
        __try
        {
            if (( lpwcsMachineName != NULL) &&
                ( pguidMachineId != NULL))
            {
                //
                //  the user cannot specify both machine name
                //  and guid
                //
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 60);
            }

            if ( pguidMachineId == NULL)
            {
                //
                //  if machine name is NULL, the calls refers to the
                //  local machine
                //
                if ( lpwcsMachineName == NULL)
                {
                    lpwsPathName = g_lpwcsComputerName;
                }
            }

            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (!pQMProps->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pQMProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pQMProps->aStatus;
            }

            //
            // See if the application wants to retrieve the key exchange
            // public key of the QM.
            //
            DWORD iPbKey;

            for (iPbKey = 0;
                 (iPbKey < pQMProps->cProp) &&
                    (pQMProps->aPropID[iPbKey] != PROPID_QM_ENCRYPTION_PK);
                 iPbKey++)
			{
				NULL;
			}

            //
            //  Check QM properties structure
            //
            rc1 = RTpCheckQMProps( pQMProps,
                                   aLocalStatus,
                                   &pGoodQMProps,
                                   &pTmpQPBuff );

            if (FAILED(rc1))
            {
                return LogHR(rc1, s_FN, 70);
            }

            if ((rc1 == MQ_INFORMATION_PROPERTY) && (iPbKey < pQMProps->cProp))
            {
                //
                // If only PROPID_QM_ENCRYPTION_PK caused the return code
                // of RTpCheckQMProps to return MQ_INFORMATION_PROPERTY, so
                // convert it to MQ_OK.
                //
                rc1 = MQ_OK;

                for (DWORD iProp = 0; iProp < pQMProps->cProp; iProp++)
                {
                    if (aLocalStatus[iProp] != MQ_OK)
                    {
                        rc1 = MQ_INFORMATION_PROPERTY;
                        break;
                    }
                }
            }

            //
            // We may get here with zero properties to retrieve, if the
            // application is only interested in PROPID_QM_ENCRYPTION_PK.
            //
            if (pGoodQMProps->cProp)
            {
                //
                // Check if CN list is requested. If yes return the Index and replace the
                // property to PROPID_QM_CNS
                //
                fGetConnection = IsConnectionRequested(pGoodQMProps,
                                                       &dwConnectionIndex);

                if (lpwsPathName)
                {
                    rc = ADGetObjectProperties(
								eMACHINE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,	   // fServerName
								lpwsPathName,
								pGoodQMProps->cProp,
								pGoodQMProps->aPropID,
								pGoodQMProps->aPropVar
								);
                }
                else
                {
                    rc = ADGetObjectPropertiesGuid(
								eMACHINE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,	   // fServerName
								pguidMachineId,
								pGoodQMProps->cProp,
								pGoodQMProps->aPropID,
								pGoodQMProps->aPropVar
								);
                }
            }
            else
            {
                rc = MQ_OK;
            }

			if ( fGetConnection	)
			{
				//
				//	Replace back the connection propid value ( also in case
				//	of failure)
				//
				pGoodQMProps->aPropID[dwConnectionIndex] = 	PROPID_QM_CONNECTION;
			}

            if (SUCCEEDED(rc))
            {
                rc = GetEncryptionPublicKey(lpwsPathName,
                                            pguidMachineId,
                                            aLocalStatus,
                                            pQMProps);
            }

            if (SUCCEEDED(rc) && fGetConnection)
            {
                rc = GetCNNameList(&(pGoodQMProps->aPropVar[dwConnectionIndex]));
            }
            //
            // Here we have out machindwConnectionIndexe properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            //
            if (SUCCEEDED(rc) && (pQMProps != pGoodQMProps))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQMProps->cProp; i++, j++)
                {
                    while(pQMProps->aPropID[j] != pGoodQMProps->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pQMProps->cProp);
                    }
                    pQMProps->aPropVar[j] = pGoodQMProps->aPropVar[i];

                }

                //
                // Check if there is a real warning or the warning came from
                // the PROPID_QM_ENCRYPTION_PK property
                //
                BOOL fWarn = FALSE;
                for (i = 0; i < pQMProps->cProp; i++)
                {
                    if (aLocalStatus[i] != MQ_OK)
                    {
                        fWarn = TRUE;
                    }
                }

                if (!fWarn && (rc1 != MQ_OK))
                {
                    rc1 = MQ_OK;
                }

            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 80); 
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete[] aLocalStatus_buff;
    }

    if (!FAILED(rc))
    {
        return LogHR(rc1, s_FN, 90);
    }

    return LogHR(rc, s_FN, 100);
}

//---------------------------------------------------------
//
//  FillPrivateComputerVersion(...)
//
//  Description:
//
//      Retrieve private computer MSMQ version
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void FillPrivateComputerVersion(
			IN OUT MQPROPVARIANT * pvar
			)
{
	struct lcversion
	{
		unsigned short buildNumber;
		unsigned char minor;
		unsigned char major;
	};

	lcversion * plcversion = (lcversion *)&pvar->ulVal;
	plcversion->major = MSMQ_RMJ;
	plcversion->minor = MSMQ_RMM;
	plcversion->buildNumber = rup;
	pvar->vt = VT_UI4;
}

//---------------------------------------------------------
//
//  FillPrivateComputerDsEnabled(...)
//
//  Description:
//
//      Retrieve private computer DS enabled state
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void  FillPrivateComputerDsEnabled(
			IN OUT MQPROPVARIANT * pvar
			)
{
    //
    // Read from registery if the machine is in WorkGroup mode
    //
	DWORD dwWorkGroup;
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;

    LONG res = GetFalconKeyValue( MSMQ_WORKGROUP_REGNAME,
                                 &dwType,
                                 &dwWorkGroup,
                                 &dwSize ) ;
    if (res != ERROR_SUCCESS)
    {
        //
        // workgroup flag not present in registry. that's OK.
        //
        dwWorkGroup = 0;
    }

	pvar->boolVal = (dwWorkGroup > 0) ? VARIANT_FALSE : VARIANT_TRUE;
	pvar->vt = VT_BOOL;
}

//---------------------------------------------------------
//
//  DepGetPrivateComputerInformation(...)
//
//  Description:
//
//      Falcon API.
//      Retrieve local computer properties (i.e. calculated properties
//      not ones that are kept in the DS).
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
DepGetPrivateComputerInformation(
    IN LPCWSTR			lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc(MQDS_MACHINE);

	//
	//	For the time being 	lpwcsComputerName must be NULL
	//
	if ( lpwcsComputerName != NULL)
	{
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
	}

    HRESULT* aLocalStatus_buff = NULL;

    __try
    {
		__try
		{
            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (pPrivateProps->aStatus == NULL)
            {
                aLocalStatus_buff = new HRESULT[pPrivateProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pPrivateProps->aStatus;
            }
            //
            //  validate props and variants
            //
			rc = RTpCheckComputerProps(
				pPrivateProps,
				aLocalStatus
				);
			if (FAILED(rc))
			{
				return LogHR(rc, s_FN, 120);
			}

			for ( DWORD i = 0; i < pPrivateProps->cProp; i++)
			{
				if ( aLocalStatus[i] != MQ_OK)
				{
					//
					//	don't fill in response for unsupported properties, or
					//  properties that are duplicate etc.
					//
					continue;
				}
				switch ( pPrivateProps->aPropID[i])
				{
				case PROPID_PC_VERSION:
					FillPrivateComputerVersion( &pPrivateProps->aPropVar[i]);
					break;
				case PROPID_PC_DS_ENABLED:
					FillPrivateComputerDsEnabled(&pPrivateProps->aPropVar[i]);
					break;
				default:
					ASSERT(0);
					return LogHR(MQ_ERROR_PROPERTY, s_FN, 130);
					break;
				}
			}

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 140); 
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }
    return LogHR(rc, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\message.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    message.cpp

Abstract:

    This module contains code involved with Message APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include <_secutil.h>
#include "mqutil.h"
#include <mqcrypt.h>
#include "rtsecutl.h"
#include "rtprpc.h"
#include "objbase.h"
#define _MTX_NOFORCE_LIBS
#include "comsvcs.h"
#include "TXDTC.H"
#include "xactmq.h"
#include <mqsec.h>
#include <ph.h>
#include <autohandle.h>

#include "message.tmh"

extern GUID  g_LicGuid ;
extern GUID  g_guidSupportQmGuid ;

// the following data is used in the async thread which handles async
// MQReceive(). The async thread is created the first time an async
// receive is performed.

#define RXTHREAD_HANDLELISTSIZE  MAXIMUM_WAIT_OBJECTS
// At present (Win32 SDK for Nt3.51) it's 64

static BOOL   s_fTerminate       = FALSE ;
static HANDLE s_hAsyncRxThread   = NULL ;
static DWORD  s_dwRxThreadId     = 0 ;
static HANDLE *s_pRxEventsHList  = NULL ;
static DWORD  s_cRxHandles       = 0 ;
static LONG   s_cRxPendingReq    = 0;
static HANDLE s_hNewAsyncRx      = NULL ;
static HANDLE s_hEndAsyncRx      = NULL ;

//
// Critical Section used to control access to structures used by the 
// async thread.
// It is initialized with the "pre-allocate resource" flag to prevent it
// from failing in EnterCriticalSection(), as one of these invocations
// occurs in a place where it cannot be handled correctly.
//
static CCriticalSection s_AsyncRxCS(0x80000000); //SpinCount.

//
// Critical section used to control initialization of the async thread, on 
// the first MQReceiveMessage() done with a callback function.
//
static CCriticalSection s_InitAsyncRxCS; 

typedef struct _MQRXASYNCDESCRIPTOR {
    QUEUEHANDLE   hSource ;
    DWORD         dwTimeout ;
    DWORD         dwAction ;
    MQMSGPROPS*   pMessageProps ;
    LPOVERLAPPED  lpOverlapped ;
    HANDLE        hCursor ;
    PMQRECEIVECALLBACK fnReceiveCallback ;
    OVERLAPPED    Overlapped ;
} MQRXASYNCDESCRIPTOR, *LPMQRXASYNCDESCRIPTOR ;

static LPMQRXASYNCDESCRIPTOR  *s_lpRxAsynDescList = NULL ;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

extern HRESULT GetMutex();

//---------------------------------------------------------
//
// static DWORD   RTpAsyncRxThread( DWORD dwP )
//
//  Description:
//
//    Thread which handles the async calls to MQReceive().
//
//---------------------------------------------------------

DWORD __stdcall  RTpAsyncRxThread( void *dwP )
{
	for(;;)
	{
		DWORD cEvents = s_cRxHandles;

		DWORD dwObjectIndex = WaitForMultipleObjects(
                                    cEvents,
                                    s_pRxEventsHList,
                                    FALSE, // return on any object
								INFINITE 
								);

      ASSERT(dwObjectIndex < (WAIT_OBJECT_0 + cEvents));

      dwObjectIndex -= WAIT_OBJECT_0 ;

      if (dwObjectIndex == 0)
      {
			//
			// dwObjectIndex == 0: 
			// The first event in the s_pRxEventsHList[] array is a special 
			// event, signaled by an MQReceiveMessage() thread to indicate 
			// that the array has been altered (grown), and we need to intiate
			// a new WaitForMultipleObjects(), or by TerminateRxAsyncThread()
			// to indicate it is time to go down.
         //

         ResetEvent(s_hNewAsyncRx) ;
         if (s_fTerminate)
         {
            // We're closing.
            // CAUTION: don't do any cleanup here. The cleanup is done in
            // "TerminateRxAsyncThread()". I don't know a reliable way
            // to assure that we even reach this point. It all depends on
            // NT scheduling and on whether this dll is implicitly loaded
            // (because of compile-time linking) or is explicitly loaded by
            // LoadLibrary().
            // On the contrary, NT assure us that "TerminateRxAsyncThread()"
            // will always be called from DllMain(PROCESS_DETACH).
            // DoronJ, 16-apr-1996.

            ASSERT(s_hEndAsyncRx) ;
            BOOL fSet = SetEvent(s_hEndAsyncRx) ;
            ASSERT(fSet) ;
			DBG_USED(fSet);

            ExitThread(0) ;
         }

			//
			// new event in array. intiate a new WaitForMultipleObjects().
			// 
			continue;
      }

         LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ dwObjectIndex ] ;
         ASSERT(lpDesc) ;
		ASSERT(s_pRxEventsHList[ dwObjectIndex ] == lpDesc->Overlapped.hEvent);

		CMQHResult hr;
		hr = (HRESULT)DWORD_PTR_TO_DWORD(lpDesc->Overlapped.Internal);

		//
         // Call the application callback.
		//
		lpDesc->fnReceiveCallback(
			hr,
                           lpDesc->hSource,
                           lpDesc->dwTimeout,
                           lpDesc->dwAction,
                           lpDesc->pMessageProps,
                           lpDesc->lpOverlapped,
			lpDesc->hCursor
			);

		// 
		// Remove Handled event from s_pRxEventsHList[] array.
		//

         ResetEvent( s_pRxEventsHList[ dwObjectIndex ] ) ;
         CloseHandle( s_pRxEventsHList[ dwObjectIndex ] ) ;
         delete lpDesc ;

		{
			CS Lock(s_AsyncRxCS);

			//
			// Shrink the handles list and decrement count of pending requests.
			//
			s_cRxHandles--;
			InterlockedDecrement(&s_cRxPendingReq);

			ASSERT(static_cast<DWORD>(s_cRxPendingReq) >= s_cRxHandles);			

			for (DWORD index = dwObjectIndex; index < s_cRxHandles; index++)
			{
				s_pRxEventsHList[ index ] = s_pRxEventsHList[ index + 1 ];
				s_lpRxAsynDescList[ index ] = s_lpRxAsynDescList[ index + 1 ];
			}
      }
   }

   dwP ;
   return 0 ;
}


//---------------------------------------------------------
//
//  static HRESULT InitRxAsyncThread()
//
//  Description:
//
//    Create the MQReceive() async thread and initialize the
//    relevant data structures.
//
//---------------------------------------------------------

static HRESULT InitRxAsyncThread()
{
    try
    {
        // Create the sync event between this api and the thread.
        // This api sets this event when it inserts a new event in
        // the events handles list. This causes the thread to exit
        // WaitForMultpleObjects and call it again with the updated
        // handles list.

        ASSERT(!s_hNewAsyncRx) ;
        s_hNewAsyncRx = CreateEvent( NULL,
                                     TRUE,  // manual reset
                                     FALSE, // initially not signalled
                                     NULL ) ;
        if (!s_hNewAsyncRx)
        {
            throw bad_alloc();
        }

        //
        // Create the "end" event which is used ONLY to terminate and
        // cleanup the thread.
        //
        ASSERT(!s_hEndAsyncRx) ;
        s_hEndAsyncRx = CreateEvent(NULL,
                                    TRUE,  // manual reset
                                    FALSE, // initially not signalled
                                    NULL ) ;
        if (!s_hEndAsyncRx)
        {
            throw bad_alloc();
        }

        // Create the events list. MQReceive() inserts new events handle
        // in this list. The async thread use this list when calling
        // WaitForMultipleObjects.

        s_pRxEventsHList = new HANDLE[ RXTHREAD_HANDLELISTSIZE ] ;
        s_pRxEventsHList[0] = s_hNewAsyncRx ;
        s_cRxHandles = 1 ;
        s_cRxPendingReq = 1 ;

        s_lpRxAsynDescList = new LPMQRXASYNCDESCRIPTOR[RXTHREAD_HANDLELISTSIZE];

        // Now create the thread. Make this call the last one in the
        // initialization, so if it fails the cleanup is simpler.

        s_hAsyncRxThread = CreateThread( NULL,
                                         0,       // stack size
                                         RTpAsyncRxThread,
                                         0,
                                         0,       // creation flag
                                         &s_dwRxThreadId ) ;
        if (!s_hAsyncRxThread)
        {
            throw bad_alloc();
        }

        return MQ_OK;
    }
    catch(const bad_alloc&)
    {
        ASSERT(!s_hAsyncRxThread) ;

        if (s_hNewAsyncRx)
        {
            CloseHandle(s_hNewAsyncRx) ;
            s_hNewAsyncRx = NULL ;
        }

        delete[] s_pRxEventsHList ;
        s_pRxEventsHList = NULL ;

        delete[] s_lpRxAsynDescList ;
        s_lpRxAsynDescList = NULL ;

        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

//---------------------------------------------------------
//
//  void  TerminateRxAsyncThread() ;
//
//  called from DllMain(PROCESS_DETACH) to cleanup the async thread.
//
//---------------------------------------------------------

#define SUSPEND_ERROR  0xffffffff

void  TerminateRxAsyncThread()
{
   if (s_hAsyncRxThread)
   {
      s_fTerminate = TRUE ;

      SetLastError(0) ;
      DWORD dwS = SuspendThread(s_hAsyncRxThread) ;
      if (dwS == SUSPEND_ERROR)
      {
         //
         // This may happen if application is linked with mqrt. when it
         // exit (the process itself exit), the thread does not run and
         // does not exist anymore. The Suspend call will success if
         // application loaded mqrt by LoadLibrary.
         //
         ASSERT(GetLastError() != 0) ;
      }
      else
      {
         DWORD dwR = ResumeThread(s_hAsyncRxThread) ;
         ASSERT(dwR != SUSPEND_ERROR) ;
		 DBG_USED(dwR);
      }

      //
      // Tell the async thread that we're closing.
      //
      BOOL fSet = SetEvent(s_hNewAsyncRx) ;
      ASSERT(fSet) ;
      DBG_USED(fSet);

      if (dwS != SUSPEND_ERROR)
      {
         //
         //  Wait (30 seconds) for async thread to terminate.
         //
         ASSERT(s_hEndAsyncRx) ;
         DWORD dwResult = WaitForSingleObject( s_hEndAsyncRx,
                                               30000 );
         ASSERT(dwResult == WAIT_OBJECT_0);
		 DBG_USED(dwResult);
      }

      //
      // cleanup the async thread global data.
      //
	  {
		  CS Lock(s_AsyncRxCS);

		  CloseHandle(s_hNewAsyncRx);
		  
		  for (DWORD index = 1; index < s_cRxHandles; index++)
      {
         ResetEvent( s_pRxEventsHList[ index ] ) ;
         CloseHandle( s_pRxEventsHList[ index ] ) ;
         LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ index ] ;
         delete lpDesc ;
      }

      delete[] s_pRxEventsHList ;
		  s_pRxEventsHList = NULL;
      delete[] s_lpRxAsynDescList ;
		  s_lpRxAsynDescList = NULL;
	  }

      //
      // finally, close the thread handle.
      //
      CloseHandle(s_hAsyncRxThread) ;
   }
}

//---------------------------------------------------------
//
//  GetThreadEvent(...)
//
//  Description:
//
//      Get RT event for this thread. Get it either from
//      The TLS or create a new one.
//
//  Return Value:
//
//      The event handle
//
//---------------------------------------------------------

HANDLE GetThreadEvent()
{
    HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
    if (hEvent == 0)
    {
        //
        //  Event was never allocated for this thread.
        //
        hEvent = CreateEvent(0, TRUE, TRUE, 0);

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

        BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
        ASSERT(fSuccess);
		DBG_USED(fSuccess);
    }
    return hEvent;
}

//---------------------------------------------------------
//
//  _ShouldSignMessage
//
//  Description:
//
//      Determines whether the message should be signed.
//
//  Return Value:
//
//      TRUE, if the message should be signed.
//
//---------------------------------------------------------

static
BOOL
_ShouldSignMessage(
    IN QUEUEHANDLE /*hQueue*/,
    IN CACTransferBufferV2 *tb,
    OUT ULONG            *pulAuthLevel )
{
    BOOL bRet;

    switch(tb->old.ulAuthLevel)
    {
    case MQMSG_AUTH_LEVEL_ALWAYS:
    {
        bRet = TRUE;

        //
        // See if registry is configured to compute only one signature.
        //
        static DWORD s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
        static BOOL  s_fAuthnAlreadyRead = FALSE ;

        if (!s_fAuthnAlreadyRead)
        {
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;

            LONG res = GetFalconKeyValue(
                                  SEND_MSG_AUTHN_REGNAME,
                                 &dwType,
                                 &s_dwAuthnLevel,
                                 &dwSize ) ;
            if (res != ERROR_SUCCESS)
            {
                s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
            }
            else if ((s_dwAuthnLevel != MQMSG_AUTH_LEVEL_MSMQ10) &&
                     (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_MSMQ20) &&
                     (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_ALWAYS))
            {
                //
                // Wrong value in registry. Use the default, to have
                // predictable results.
                //
                s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
            }
            s_fAuthnAlreadyRead = TRUE ;

            //
            // This should be the default.
            // by default, authenticate only with old style, to prevent
            // performance hit and to be backward  compatible.
            //
            ASSERT(DEFAULT_SEND_MSG_AUTHN == MQMSG_AUTH_LEVEL_MSMQ10) ;
        }
        *pulAuthLevel = s_dwAuthnLevel ;

        break;
    }

    case MQMSG_AUTH_LEVEL_MSMQ10:
    case MQMSG_AUTH_LEVEL_MSMQ20:
        bRet = TRUE;
        *pulAuthLevel = tb->old.ulAuthLevel ;
        tb->old.ulAuthLevel =  MQMSG_AUTH_LEVEL_ALWAYS ;
        break;

    case MQMSG_AUTH_LEVEL_NONE:
        bRet = FALSE;
        break;

    default:
        ASSERT(0);
        bRet = FALSE;
    }

    return(bRet);
}

//+-------------------------------------
//
//  HRESULT  _BeginToSignMessage()
//
//+-------------------------------------

static HRESULT  _BeginToSignMessage( IN CACTransferBufferV2  *tb,
                                     IN PMQSECURITY_CONTEXT pSecCtx,
                                     OUT HCRYPTHASH        *phHash )
{
    HRESULT hr;
    DWORD   dwErr ;

    ASSERT(pSecCtx);

    if (!pSecCtx->hProv)
    {
        //
        // Import the private key into process hive.
        //
        hr = RTpImportPrivateKey( pSecCtx ) ;
        if (FAILED(hr))
        {
            return hr ;
        }
    }
    ASSERT(pSecCtx->hProv) ;

    //
    // Create the hash object.
    //
    if (!CryptCreateHash(
            pSecCtx->hProv,
            *tb->old.pulHashAlg,
            0,
            0,
            phHash))
    {
        dwErr = GetLastError() ;
        TrERROR(SECURITY, "RT: _BeginToSignMessage(), fail at CryptCreateHash(), err- %lxh", dwErr);

        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    return MQ_OK ;
}

//-------------------------------------------------------------------------
//
//  HRESULT SignMessage()
//
//  Description:
//
//      Signs the messag body. compute the hash, and sign it with private
//      key. This add a signature section to the packet
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//-------------------------------------------------------------------------

static
HRESULT
SignMessage( IN CACTransferBufferV2   *tb,
             IN PMQSECURITY_CONTEXT  pSecCtx)
{
    HCRYPTHASH  hHash = NULL ;

    HRESULT hr =  _BeginToSignMessage( tb,
                                       pSecCtx,
                                      &hHash ) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    CHCryptHash hAutoRelHash = hHash ;

    hr = HashMessageProperties(
            hHash,
            tb->old.ppCorrelationID ? *tb->old.ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            tb->old.pApplicationTag ? *tb->old.pApplicationTag : DEFAULT_M_APPSPECIFIC,
            tb->old.ppBody ? *tb->old.ppBody : NULL,
            tb->old.ulBodyBufferSizeInBytes,
            tb->old.ppTitle ? *tb->old.ppTitle : NULL,
            tb->old.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            tb->old.Send.pResponseQueueFormat,
            tb->old.Send.pAdminQueueFormat
			);
    if (FAILED(hr))
    {
        return(hr);
    }

    if (!CryptSignHash(        // Sign the mesage.
            hHash,
            pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
            NULL,
            0,
            *(tb->old.ppSignature),
            &tb->old.ulSignatureSize))
    {
    	DWORD gle = GetLastError();
        TrERROR(SECURITY, "CryptSignHash() failed, err = %!winerr!", gle);
        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (tb->old.ulSignatureSize == 0)
    {
        TrERROR(SECURITY, "RT: SignMessage(), CryptSignHash return with zero signature size");

        ASSERT(tb->old.ulSignatureSize != 0) ;
        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    return(MQ_OK);
}

//---------------------------------------------------------
//
//  _SignMessageEx
//
//  Description:
//
//    Signs properties that were not signed in msmq1.0
//    Properties we sign here:
//    - target queue
//    - source qm guid
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//---------------------------------------------------------

static HRESULT _SignMessageEx( IN QUEUEHANDLE             hQueue,
                               IN OUT CACTransferBufferV2  *tb,
                               IN PMQSECURITY_CONTEXT     pSecCtx,
                               OUT BYTE                  *pSignBufIn,
                               OUT DWORD                 *pdwSignSize )
{
    //
    // Retrieve guid of local qm.
    //
    GUID *pGuidQM = NULL ;

    if (g_fDependentClient)
    {
        //
        // We can generate the "ex" signature only if supporting server
        // is win2k (rtm) and it can give us its QM guid.
        // Otherwise, return.
        //
        if (g_guidSupportQmGuid == GUID_NULL)
        {
            //
            // guid of supporting server is not available.
            //
            *pdwSignSize = 0 ;
            return MQ_OK ;
        }
        pGuidQM = &g_guidSupportQmGuid ;
    }
    else
    {
        pGuidQM = &g_LicGuid ;
    }

    //
    // First retrieve format name of the queue, from driver.
    //
    #define TARGET_NAME_SIZE  512
    WCHAR wszTargetFormatName[ TARGET_NAME_SIZE ] ;
    DWORD dwTargetFormatNameLength = TARGET_NAME_SIZE ;
    WCHAR *pwszTargetFormatName = wszTargetFormatName ;
    P<WCHAR>  pwszClean = NULL ;

    HRESULT hr = ACDepHandleToFormatName( hQueue,
                                       wszTargetFormatName,
                                      &dwTargetFormatNameLength ) ;
    if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
    {
        pwszClean = new WCHAR[ dwTargetFormatNameLength ] ;
        pwszTargetFormatName = pwszClean.get() ;

        hr = ACDepHandleToFormatName( hQueue,
                                   pwszTargetFormatName,
                                  &dwTargetFormatNameLength ) ;
        ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) ;
    }
    #undef TARGET_NAME_SIZE

    if (FAILED(hr))
    {
        return hr ;
    }
    dwTargetFormatNameLength =
                      (1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR) ;
    //
    // Prepare the necessray structers to be included in packet.
    //
    struct _SecuritySectionEx *pSecEx =
                                (struct _SecuritySectionEx *) pSignBufIn ;
    struct _SecuritySubSectionEx *pSubSecEx =
                  (struct _SecuritySubSectionEx *) (&(pSecEx->aData[0])) ;

    ULONG  ulTestLen = 0 ;
    USHORT ulTestSections = 0 ;

#ifdef _DEBUG
{
	BYTE* pSubPtr = NULL;

    //
    // Simulate subsection that precede the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPrefixCount = 0 ;
    static BOOL  s_fPreAlreadyRead = FALSE ;

    if (!s_fPreAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwType = REG_DWORD ;

        LONG res = GetFalconKeyValue(
                                  PREFIX_SUB_SECTIONS_REGNAME,
                                 &dwType,
                                 &s_dwPrefixCount,
                                 &dwSize ) ;
        if (res != ERROR_SUCCESS)
        {
            s_dwPrefixCount = 0 ;
        }
        s_fPreAlreadyRead = TRUE ;
    }

    for ( USHORT j = 0 ; j < (USHORT) s_dwPrefixCount ; j++ )
    {
        ulTestSections++ ;
        pSubSecEx->eType = e_SecInfo_Test ;
        pSubSecEx->_u.wFlags = 0 ;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 7) + 1 +
                                    sizeof(struct _SecuritySubSectionEx)) ;

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr ;
    }
}
#endif

    pSubSecEx->eType = e_SecInfo_User_Signature_ex ;
    pSubSecEx->_u.wFlags = 0 ;
    pSubSecEx->_u._UserSigEx.m_bfTargetQueue = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfSourceQMGuid = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfUserFlags = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfConnectorType = 1 ;

    BYTE *pSignBuf = (BYTE*) &(pSubSecEx->aData[0]) ;

    //
    // start signing (create the hash object).
    //
    HCRYPTHASH hHash;

    hr =  _BeginToSignMessage( tb,
                               pSecCtx,
                              &hHash ) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    CHCryptHash hAutoRelHash = hHash ;

    hr = HashMessageProperties(
            hHash,
            tb->old.ppCorrelationID ? *tb->old.ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            tb->old.pApplicationTag ? *tb->old.pApplicationTag : DEFAULT_M_APPSPECIFIC,
            tb->old.ppBody ? *tb->old.ppBody : NULL,
            tb->old.ulBodyBufferSizeInBytes,
            tb->old.ppTitle ? *tb->old.ppTitle : NULL,
            tb->old.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            tb->old.Send.pResponseQueueFormat,
            tb->old.Send.pAdminQueueFormat
			);
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags ;
    memset(&sUserFlags, 0, sizeof(sUserFlags)) ;

    sUserFlags.bDelivery = DEFAULT_M_DELIVERY;
    sUserFlags.bPriority = DEFAULT_M_PRIORITY ;
    sUserFlags.bAuditing = DEFAULT_M_JOURNAL ;
    sUserFlags.bAck      = DEFAULT_M_ACKNOWLEDGE ;
    sUserFlags.usClass   = MQMSG_CLASS_NORMAL ;

    if (tb->old.pDelivery)
    {
        sUserFlags.bDelivery = *(tb->old.pDelivery) ;
    }
    if (tb->old.pPriority)
    {
        sUserFlags.bPriority = *(tb->old.pPriority) ;
    }
    if (tb->old.pAuditing)
    {
        sUserFlags.bAuditing = *(tb->old.pAuditing) ;
    }
    if (tb->old.pAcknowledge)
    {
        sUserFlags.bAck      = *(tb->old.pAcknowledge) ;
    }
    if (tb->old.pClass)
    {
        sUserFlags.usClass   = *(tb->old.pClass) ;
    }
    if (tb->old.pulBodyType)
    {
        sUserFlags.ulBodyType = *(tb->old.pulBodyType) ;
    }

    GUID guidConnector = GUID_NULL ;
    const GUID *pConnectorGuid = &guidConnector ;
    if (tb->old.ppConnectorType)
    {
        pConnectorGuid = *(tb->old.ppConnectorType) ;
    }

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry)) ;
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[ dwStructSize ] ;

    pHashData->cEntries = 4 ;
    (pHashData->aEntries[0]).dwSize = dwTargetFormatNameLength ;
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName ;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID) ;
    (pHashData->aEntries[1]).pData = (const BYTE*) pGuidQM ;
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags) ;
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags ;
    (pHashData->aEntries[3]).dwSize = sizeof(GUID) ;
    (pHashData->aEntries[3]).pData = (const BYTE*) pConnectorGuid ;
    ASSERT(pGuidQM) ;

    hr = MQSigHashMessageProperties( hHash, pHashData.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // sign the has with private key.
    //
    if (!CryptSignHash(
            hHash,
            pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
            NULL,
            0,
            pSignBuf,
            pdwSignSize ))
    {
    	DWORD gle = GetLastError();
        TrERROR(SECURITY, "CryptSignHash() failed, err = %!winerr!", gle);
        return MQ_ERROR_CANNOT_SIGN_DATA_EX ;
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (*pdwSignSize == 0)
    {
        TrERROR(SECURITY, "_SignMessageEx(), CryptSignHash return with zero signature size");

        ASSERT(*pdwSignSize != 0) ;
        return MQ_ERROR_CANNOT_SIGN_DATA_EX ;
    }

    pSubSecEx->wSubSectionLen = (USHORT)
                    (sizeof(struct _SecuritySubSectionEx) + *pdwSignSize) ;
    ULONG ulSignExLen = ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;

#ifdef _DEBUG
{
    //
    // Simulate subsection that succeed the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPostfixCount = 0 ;
    static BOOL  s_fPostAlreadyRead = FALSE ;
	BYTE* pSubPtr = NULL;

    if (!s_fPostAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwType = REG_DWORD ;

        LONG res = GetFalconKeyValue(
                                  POSTFIX_SUB_SECTIONS_REGNAME,
                                 &dwType,
                                 &s_dwPostfixCount,
                                 &dwSize ) ;
        if (res != ERROR_SUCCESS)
        {
            s_dwPostfixCount = 0 ;
        }
        s_fPostAlreadyRead = TRUE ;
    }

    pSubPtr = ((BYTE*) pSubSecEx) + ulSignExLen ;

    for ( USHORT j = 0 ; j < (USHORT) s_dwPostfixCount ; j++ )
    {
        ulTestSections++ ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr ;
        pSubSecEx->eType = e_SecInfo_Test ;
        pSubSecEx->_u.wFlags = 0 ;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 11) + 1 +
                                   sizeof(struct _SecuritySubSectionEx)) ;

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
    }
}
#endif

    pSecEx->cSubSectionCount = (USHORT) (1 + ulTestSections) ;
    pSecEx->wSectionLen = (USHORT) ( sizeof(struct _SecuritySectionEx)   +
                                     ulSignExLen                         +
                                     ulTestLen ) ;

    *pdwSignSize = pSecEx->wSectionLen ;
    return MQ_OK ;
}

//+-------------------------------------------------------
//
//  BOOL  ShouldEncryptMessage()
//
//  Return TRUE, if the message should be encrypted.
//
//+-------------------------------------------------------

static
BOOL
ShouldEncryptMessage( IN CACTransferBufferV2  *tb,
                      OUT enum enumProvider *peProvider )
{
    BOOL bRet = FALSE ;

    if (!tb->old.ulBodyBufferSizeInBytes)
    {
        //
        // No message body, nothing to encrypt.
        //
        return(FALSE);
    }

    switch (*tb->old.pulPrivLevel)
    {
    case MQMSG_PRIV_LEVEL_NONE:
        bRet = FALSE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_BASE:
        *peProvider = eBaseProvider ;
        bRet = TRUE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        *peProvider = eEnhancedProvider ;
        bRet = TRUE;
        break;
    }

    return(bRet);
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentViperTransaction
//
// Gets current COM+ transaction if there is one...
//
// CoGetObjectContext is exported by OLE32.dll
// IObjectContextInfo is defined in the latest COM+ SDK (part of the platform SDK)
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentViperTransaction(void)
{
    ITransaction *pTransaction = NULL;
    IObjectContextInfo *pInfo  = NULL;

    HRESULT hr = CoGetObjectContext(IID_IObjectContextInfo, (void **)&pInfo);
    if (SUCCEEDED(hr) && pInfo)
    {
    	hr = pInfo -> GetTransaction((IUnknown **)&pTransaction);
	    pInfo -> Release();
        if (FAILED(hr))
        {
            pTransaction = NULL;
        }
    }

    return pTransaction;
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentXATransaction
// Gets current XA transaction if there is one...
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentXATransaction(void)
{
    IXATransLookup *pXALookup = NULL;
    HRESULT         hr = MQ_OK;
    IUnknown       *punkDtc = NULL;
    ITransaction   *pTrans;

    __try
    {
        GetMutex();  // Isolate export creation from others
        hr = XactGetDTC(&punkDtc);
    }
    __finally

    {
        ReleaseMutex(g_hMutexDTC);
    }

    if (FAILED(hr) || punkDtc==NULL)
    {
        return NULL;
    }

    // Get the DTC  ITransactionImportWhereabouts interface
    hr = punkDtc->QueryInterface (IID_IXATransLookup, (void **)(&pXALookup));
    punkDtc->Release();
    if (FAILED(hr))
    {
        return NULL;
    }
    ASSERT(pXALookup);

    hr = pXALookup->Lookup(&pTrans);
    pXALookup->Release();
    if (FAILED(hr))
    {
        return NULL;
    }

    return pTrans;
}

//+----------------------------------------------------------------------
//
// Helper code to computer size (in bytes) of provider name in packet.
//
//+----------------------------------------------------------------------

inline ULONG  OldComputeAuthProvNameSize( const IN CACTransferBufferV2  *ptb )
{
    ULONG ulSize = 0 ;

    if ( (ptb->old.ulSignatureSize != 0) && (!(ptb->old.fDefaultProvider)) )
    {
        ulSize = sizeof(ULONG) +
                 ((wcslen(*(ptb->old.ppwcsProvName)) + 1) * sizeof(WCHAR)) ;
    }

    return ulSize ;
}
//---------------------------------------------------------
//
//  DepSendMessage(...)
//
//  Description:
//
//      Falcon API.
//      Send a message to a queue
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    BYTE* pUserSid;
    BYTE* pUserCert;
    WCHAR* pProvName;

    HRESULT hr ;
    CMQHResult rc, rc1;
    LPWSTR pwcsResponseStringToFree = NULL;
    LPWSTR pwcsAdminStringToFree = NULL;
    XACTUOW Uow;
    PMQSECURITY_CONTEXT pSecCtx = NULL;
    PMQSECURITY_CONTEXT pTmpSecCtx = NULL;
    BOOL fTransactionGenerated = FALSE;

    rc = MQ_OK;
    rc1 = MQ_OK;

    __try
    {
        __try
        {
            CACTransferBufferV2 tb;
		    memset(&tb, 0, sizeof(CACTransferBufferV2));
			tb.old.uTransferType = CACTB_SEND;

            QUEUE_FORMAT ResponseQueueFormat;
            QUEUE_FORMAT AdminQueueFormat;
            BOOL         fSingleTransaction = FALSE;

            tb.old.Send.pResponseQueueFormat = &ResponseQueueFormat;
            tb.old.Send.pAdminQueueFormat = &AdminQueueFormat;

            //
            // Set defaults.
            //
            ULONG ulDefHashAlg = PROPID_M_DEFUALT_HASH_ALG;
            ULONG ulDefEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;
            ULONG ulDefPrivLevel = DEFAULT_M_PRIV_LEVEL;
            ULONG ulDefSenderIdType = DEFAULT_M_SENDERID_TYPE;
            ULONG ulSenderIdTypeNone = MQMSG_SENDERID_TYPE_NONE;

            tb.old.pulHashAlg = &ulDefHashAlg;
            tb.old.pulPrivLevel = &ulDefPrivLevel;
            tb.old.pulEncryptAlg = &ulDefEncryptAlg;
            tb.old.pulSenderIDType = &ulDefSenderIdType;
            tb.old.fDefaultProvider = TRUE;
            tb.old.ulAuthLevel = DEFAULT_M_AUTH_LEVEL;

            //
            //  Parse message properties
            //
            rc1 = RTpParseMessageProperties(
                    SEND_PARSE,
                    &tb,
                    pmp->cProp,
                    pmp->aPropID,
                    pmp->aPropVar,
                    pmp->aStatus,
                    &pSecCtx,
                    &pwcsResponseStringToFree,
                    &pwcsAdminStringToFree);

            if(FAILED(rc1))
            {
                return(rc1);
            }

            //
            // Look for Viper transaction if any
            //
            if (pTransaction == MQ_MTS_TRANSACTION)
            {
                pTransaction = GetCurrentViperTransaction();
                if (pTransaction != NULL)
                {
                    fTransactionGenerated = TRUE;
                }
            }
            else if (pTransaction == MQ_XA_TRANSACTION)
            {
                pTransaction = GetCurrentXATransaction();
                if (pTransaction != NULL)
                {
                    fTransactionGenerated = TRUE;
                }
            }
            else if (pTransaction == MQ_SINGLE_MESSAGE)
            {
                hr = DepBeginTransaction(&pTransaction);
                if(FAILED(hr))
                {
                    rc = hr;
                    __leave;
                }

                fSingleTransaction    = TRUE;
                fTransactionGenerated = TRUE;
            }

            //
            //Enlist QM in the transaction (with caching);
            //
            if (pTransaction)
            {
                hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
                tb.old.pUow = &Uow;

                if(FAILED(hr))
                {
                    rc = MQ_ERROR_TRANSACTION_ENLIST;
                    __leave;
                }
            }

            // Change values for the transaction case
            static UCHAR Delivery;
            static UCHAR Priority;

            if (pTransaction)
            {
                Delivery = MQMSG_DELIVERY_RECOVERABLE;
                Priority = 0;

                tb.old.pDelivery = &Delivery;
                tb.old.pPriority = &Priority;
            }

            //
            // Treat security
            //
            if (!g_pSecCntx)
            {
                //
                //  It might not be initialized if the queue was
                //  not opened for send;
                //
                InitSecurityContext();
            }

            BYTE abMessageSignature[ MAX_MESSAGE_SIGNATURE_SIZE_EX ];
            BYTE* pabMessageSignature = abMessageSignature;
            ULONG ulProvNameSizeAll = 0 ;
            ULONG ulAuthLevel = 0 ;

            if (tb.old.ppSignature)
            {
                if (!pSecCtx && !tb.old.ppSenderCert)
                {
                    return MQ_ERROR_INSUFFICIENT_PROPERTIES;
                }
                if (!tb.old.ppSenderCert)
                {
                    //
                    // We have a security context and no certificate. We
                    // take the certificate from the security context.
                    //
					pUserCert = pSecCtx->pUserCert.get();
                    tb.old.ppSenderCert = &pUserCert;
                    tb.old.ulSenderCertLen = pSecCtx->dwUserCertLen;
                }

                if (tb.old.ppwcsProvName)
                {
                    ASSERT(tb.old.pulProvType);
                    tb.old.fDefaultProvider = FALSE;
                }
            }
            else if (_ShouldSignMessage(hQueue, &tb, &ulAuthLevel))
            {
                BOOL bShouldGetCertInfo = TRUE;

                if (!pSecCtx)
                {
                    //
                    // Security context NOT provided by caller, in a
                    // message property.
                    //
                    if (!tb.old.ppSenderCert)
                    {
                        //
                        // Caller also did not provide a certificate in the
                        // message properties array. In this case we take the
                        // cached security context of the process.
                        //
                        if (!g_pSecCntx->pUserCert.get())
                        {
                            //
                            // The process does not have an internal
                            // certificate, there is nothing that we can do
                            // but fail.
                            //
                            return(MQ_ERROR_NO_INTERNAL_USER_CERT);
                        }
                        pUserCert = g_pSecCntx->pUserCert.get();
                        tb.old.ppSenderCert = &pUserCert;
                        tb.old.ulSenderCertLen = g_pSecCntx->dwUserCertLen;
                        pSecCtx = g_pSecCntx;
                        bShouldGetCertInfo = FALSE;
                    }
                }
                else
                {
                    if (!tb.old.ppSenderCert)
                    {
                        //
                        // Caller provided a security context, but not a
                        // certificate. We take the certificate from the
                        // security context.
                        //
                        pUserCert = pSecCtx->pUserCert.get();
                        tb.old.ppSenderCert = &pUserCert;
                        tb.old.ulSenderCertLen = pSecCtx->dwUserCertLen;
                        bShouldGetCertInfo = FALSE;
                    }
                    else
                    {
                        //
                        // We have a security context and a certificate in
                        // PROPID_M_USER_CERT. In this case, we should use
                        // the certificate in PROPID_M_USER_CERT. We can use
                        // the cashed certificate information in the security
                        // context, if the certificate in the security context
                        // is the same as in PROPID_M_USER_CERT.
                        //
                        bShouldGetCertInfo =
                            (pSecCtx->dwUserCertLen != tb.old.ulSenderCertLen) ||
                            (memcmp(
                                pSecCtx->pUserCert.get(),
                                *tb.old.ppSenderCert,
                                tb.old.ulSenderCertLen) != 0);
                    }
                }

                if (bShouldGetCertInfo)
                {
                    //
                    // Caller provided a certificate, but not a security
                    // context.  Get all the information for the certificate.
                    // We put the certificate information in a temporary
                    // security context.
                    //
                    ASSERT(tb.old.ppSenderCert);

                    pTmpSecCtx = AllocSecurityContext();

                    hr = GetCertInfo(
                             false,
                             pTmpSecCtx->fLocalSystem,
                            tb.old.ppSenderCert,
                            &tb.old.ulSenderCertLen,
                            &pTmpSecCtx->hProv,
                            &pTmpSecCtx->wszProvName,
                            &pTmpSecCtx->dwProvType,
                            &pTmpSecCtx->bDefProv,
                            &pTmpSecCtx->bInternalCert);

                    //
                    // The caller can not provide the internal certificate as
                    // a message property, only his own externel certificate.
                    // ASSERT this condition.
                    //
                    ASSERT(!(pTmpSecCtx->bInternalCert)) ;

                    if (FAILED(hr))
                    {
                        return(hr);
                    }

                    if (pSecCtx)
                    {
                        //
                        // If we got the certificate from PROPID_M_USER_CERT,
                        // but we have also a security context, we should get
                        // the sender ID from the security context. So copy
                        // the sender ID from the security context that we
                        // get from the application into the temporary
                        // security context.
                        //
                        pTmpSecCtx->fLocalUser = pSecCtx->fLocalUser;

                        if (!pSecCtx->fLocalUser)
                        {
                            pTmpSecCtx->dwUserSidLen = pSecCtx->dwUserSidLen;
                            pTmpSecCtx->pUserSid = new BYTE[pSecCtx->dwUserSidLen];
                            BOOL bRet = CopySid(
                                            pSecCtx->dwUserSidLen,
                                            pTmpSecCtx->pUserSid.get(),
                                            pSecCtx->pUserSid.get());
                            ASSERT(bRet);
							DBG_USED(bRet);
                        }
                    }
                    else
                    {
                        pTmpSecCtx->fLocalUser = g_pSecCntx->fLocalUser;
                    }

                    pSecCtx = pTmpSecCtx;
                }

                ASSERT(pSecCtx);

                //
                // Fill the tranfer buffer with the provider information for the
                // certificate.
                //
                if (pSecCtx->wszProvName.get() == NULL)
                {
                    //
                    // we don't have a provider, so we can't sign.
                    //
                    ASSERT(pSecCtx->hProv == NULL) ;
                    if (tb.old.ppSenderCert == NULL)
                    {
                        //
                        // we don't have a certificate. That's a
                        // user error.
                        //
                        rc = MQ_ERROR_CERTIFICATE_NOT_PROVIDED ;
                    }
                    else
                    {
                        rc = MQ_ERROR_CORRUPTED_SECURITY_DATA ;
                    }
                    __leave ;
                }

                pProvName = pSecCtx->wszProvName.get();
                tb.old.ppwcsProvName = &pProvName;
                tb.old.ulProvNameLen = wcslen(pProvName) + 1;
                tb.old.pulProvType = &pSecCtx->dwProvType;
                tb.old.fDefaultProvider = pSecCtx->bDefProv;

                //
                // Set the buffer for the signature.
                //
                tb.old.ppSignature = &pabMessageSignature;
                tb.old.ulSignatureSize = sizeof(abMessageSignature);
                //
                // Sign the message.
                //
                if ((ulAuthLevel == MQMSG_AUTH_LEVEL_MSMQ10) ||
                    (ulAuthLevel == MQMSG_AUTH_LEVEL_ALWAYS))
                {
                    rc = SignMessage(&tb, pSecCtx);
                    if(FAILED(rc))
                    {
                        __leave;
                    }
                    ASSERT(tb.old.ulSignatureSize != 0);
                }
                else
                {
                    //
                    // Sign only with win2k style.
                    // make the "msmq1.0" signature dummy, with a single
                    // null dword. It's too risky to have a null pointer
                    // as msmq1.0 signature, so a dummy value is better.
                    // win2k code will ignore it anyway.
                    //
                    tb.old.ulSignatureSize = 4 ;
                    memset(abMessageSignature, 0, tb.old.ulSignatureSize) ;
                }

                //
                // Now create the "Extra" signature. Sign all those
                // properties that were not signed on msmq1.0.
                //
                BYTE abMessageSignatureEx[ MAX_MESSAGE_SIGNATURE_SIZE_EX ];
                DWORD dwSignSizeEx = sizeof(abMessageSignatureEx) ;

                if (ulAuthLevel == MQMSG_AUTH_LEVEL_MSMQ10)
                {
                    //
                    // enhanced signature (win2k style) not needed.
                    //
                    dwSignSizeEx = 0 ;
                }
                else
                {
                    rc = _SignMessageEx( hQueue,
                                        &tb,
                                         pSecCtx,
                                         abMessageSignatureEx,
                                        &dwSignSizeEx );
                    if(FAILED(rc))
                    {
                        __leave;
                    }

                    if (dwSignSizeEx == 0)
                    {
                        //
                        // Signature not created.
                        // That's ok for dependent client.
                        //
                        ASSERT(g_fDependentClient) ;
                    }
                }

                //
                // Copy the Ex signature to the standard signature buffer.
                // The driver will separate them and insert them in the
                // packet in the proper place. This is necessary to keep
                // the transfer buffer without changes.
                //
                if (dwSignSizeEx == 0)
                {
                    //
                    // Signature not created. That's ok.
                    //
                }
                else if ((dwSignSizeEx + tb.old.ulSignatureSize) <=
                                             MAX_MESSAGE_SIGNATURE_SIZE_EX)
                {
                    memcpy( &(abMessageSignature[ tb.old.ulSignatureSize ]),
                            abMessageSignatureEx,
                            dwSignSizeEx ) ;
                    tb.old.ulSignatureSize += dwSignSizeEx ;

                    //
                    // Compute size of authentication "provider" field. This
                    // field contain the provider name and extra authentication
                    // data that was added for post win2k rtm.
                    //
                    ulProvNameSizeAll = dwSignSizeEx +
                                 ALIGNUP4_ULONG(OldComputeAuthProvNameSize( &tb )) ;

                    tb.old.pulAuthProvNameLenProp = &ulProvNameSizeAll ;
                }
                else
                {
                    ASSERT(0) ;
                }
            }
            else
            {
                tb.old.ulSignatureSize = 0;
            }

            if(!tb.old.ppSenderID && *tb.old.pulSenderIDType == MQMSG_SENDERID_TYPE_SID)
            {
                if ((pSecCtx && pSecCtx->fLocalUser) ||
                    (!pSecCtx && g_pSecCntx->fLocalUser))
                {
                    //
                    // In case this is a local user, we do not send the user's
                    // SID with the message, eventhough the application asked
                    // to send it.
                    //
                    tb.old.pulSenderIDType = &ulSenderIdTypeNone;
                }
                else
                {
                    //
                    // We should pass the sender ID. Either get it from the
                    // security context, if available, or get it from the
                    // cached process security context.
                    //
                    if (!pSecCtx || !pSecCtx->pUserSid.get())
                    {
                        if (!g_pSecCntx->pUserSid.get())
                        {
                            //
                            // The cahced process context does not contain the
                            // sender's SID. There is nothing that we can do but
                            // fail.
                            //
                            rc = MQ_ERROR_COULD_NOT_GET_USER_SID;
                            __leave;
                        }

                        pUserSid = (PUCHAR)g_pSecCntx->pUserSid.get();
                        tb.old.uSenderIDLen = (USHORT)g_pSecCntx->dwUserSidLen;
                    }
                    else
                    {
                        pUserSid = (PUCHAR)pSecCtx->pUserSid.get();
                        tb.old.uSenderIDLen = (USHORT)pSecCtx->dwUserSidLen;
                    }
					tb.old.ppSenderID = &pUserSid;
                }
            }

            if (tb.old.ppSymmKeys)
            {
                //
                // the application supplied the symmetric key. In such a case
                // doesn't do any encryption
                //
                //
                // When the symm key is supplied, we assume that the body is encrypted and
                // we mark it as such and ignore PROPID_M_PRIV_LEVEL.
                //
                if (tb.old.pulPrivLevel &&
                    (*(tb.old.pulPrivLevel) == MQMSG_PRIV_LEVEL_BODY_ENHANCED))
                {
                    //
                    // priv level supplied by caller.
                    //
                }
                else
                {
                    //
                    // use default.
                    //
                    ulDefPrivLevel = MQMSG_PRIV_LEVEL_BODY_BASE;
                    tb.old.pulPrivLevel = &ulDefPrivLevel;
                }
                tb.old.bEncrypted = TRUE;
            }
            else
            {
                enum enumProvider eProvider ;
                if (ShouldEncryptMessage(&tb, &eProvider))
                {
                    //
                    // If we should use a block cypher enlarge the allocated
                    // space for the message body, so it will be able to accomodate
                    // the encrypted data.
                    //

                    if (*tb.old.pulEncryptAlg == CALG_RC2)
                    {
                        //
                        // Make more room for RC2 encryption.
                        //
                        DWORD dwBlockSize ;
                        hr = MQSec_GetCryptoProvProperty( eProvider,
                                                          eBlockSize,
                                                          NULL,
                                                         &dwBlockSize ) ;
                        if (FAILED(hr))
                        {
                            return hr ;
                        }

                        tb.old.ulAllocBodyBufferInBytes +=
                                                  ((2 * dwBlockSize) - 1) ;
                        tb.old.ulAllocBodyBufferInBytes &= ~(dwBlockSize - 1) ;
                    }

                    DWORD dwSymmSize ;
                    hr = MQSec_GetCryptoProvProperty( eProvider,
                                                      eSessionKeySize,
                                                      NULL,
                                                     &dwSymmSize ) ;
                    if (FAILED(hr))
                    {
                        return hr ;
                    }

                    tb.old.ulSymmKeysSize = dwSymmSize ;
                }
            }

            //
            //  Call AC driver with transfer buffer
            //
            OVERLAPPED ov = {0};
            ov.hEvent = GetThreadEvent();

            rc = ACDepSendMessage(
                    hQueue,
                    tb,
                    &ov
                    );

            switch (rc)
            {
            case MQ_INFORMATION_OPERATION_PENDING:
                //
                //  Wait for send completion
                //
                DWORD dwResult;
                dwResult = WaitForSingleObject(
                                ov.hEvent,
                                INFINITE
                                );

                //
                //  BUGBUG: MQSendMessage, must succeed in WaitForSingleObject
                //
                ASSERT(dwResult == WAIT_OBJECT_0);

                rc = DWORD_PTR_TO_DWORD(ov.Internal);
                break;

            case STATUS_RETRY:
                //
                // This error code is returned when the message is sent
                // localy and there are security operations that should
                // be performed on the message before the it can be put
                // in the queue. These security operations can only be
                // performed by the QM. So the message is tranfered to
                // the QM, the QM will do the security operations and will
                // then call a special device driver entry point, telling
                // the device driver that the security operations were
                // done and the result of those operations.
                //
                if (!tls_hBindRpc)
                {
                    INIT_RPC_HANDLE ;
                }
                rc = DeppSendMessage(tls_hBindRpc, hQueue, &tb);
                break;
            }

            if(FAILED(rc))
            {
                //
                //  ACDepSendMessage failed (immidiatly or after waiting)
                //
                __leave;
            }


            if (fSingleTransaction)
            {
                // RPC call to QM for prepare/commit
                rc = pTransaction->Commit(0,0,0);
                if(FAILED(rc))
                {
                    __leave;
                }
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            //  The exception is due to invalid parameter
            //
            rc = GetExceptionCode();
        }
    }
    __finally
    {
        delete[] pwcsResponseStringToFree;
        delete[] pwcsAdminStringToFree;
        delete pTmpSecCtx;

        if (fTransactionGenerated)
        {
            pTransaction->Release();
        }
    }

    if(rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return(rc1);
    }


    return(rc);
}




//
// This class is used to increment a value in an abortable manner.
// If the scope where the incrementation has taken place is exited
// without calling Detach() first, the value is decremented back.
//
class CIncrementor
{
public:
	CIncrementor(LPLONG ptr) :
		m_pValue(ptr),
		m_TimesIncremented(0)
	{	
	}

	~CIncrementor()
	{
		if(m_pValue == NULL)
			return;
		
		InterlockedExchangeAdd (m_pValue, -m_TimesIncremented);
	}

	LONG Increment()
	{
		m_TimesIncremented++;
		return InterlockedIncrement(m_pValue);
	}

	void Detach()
	{
		m_TimesIncremented = 0;
		m_pValue = NULL;
	}

private:
	LPLONG m_pValue;
	LONG m_TimesIncremented;
};


static
HRESULT
DeppReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	ASSERT(g_fDependentClient);

    CMQHResult rc, rc1;
    XACTUOW Uow;
    HRESULT hr;

    R<ITransaction> TransactionGenerated;
    CHandle hCallback;
    P<MQRXASYNCDESCRIPTOR> lpDesc;
	CIncrementor PendingReqCounter = &s_cRxPendingReq;

    rc = MQ_OK;
    rc1 = MQ_OK;

    //
    // Look for Viper transaction if any
    //
    if (pTransaction == MQ_MTS_TRANSACTION)
    {
	TransactionGenerated = GetCurrentViperTransaction();
	pTransaction = TransactionGenerated.get();
    }
    else if (pTransaction == MQ_XA_TRANSACTION)
    {
	TransactionGenerated = GetCurrentXATransaction();
	pTransaction = TransactionGenerated.get();
    }
    else if (pTransaction == MQ_SINGLE_MESSAGE)
    {
        pTransaction = NULL;
    }

    if (dwAction & MQ_ACTION_PEEK_MASK)
    {
        // PEEK cannot be transacted, but can work with transacted queue
        if (pTransaction != NULL)
        {
            return MQ_ERROR_TRANSACTION_USAGE;
        }
    }

    // Check usage: transaction urges synchronous operation
    if (pTransaction)
    {
        if (lpOverlapped || (fnReceiveCallback!=NULL))  // Transacted Receive is synchronous only
        {
            return MQ_ERROR_TRANSACTION_USAGE;
        }
    }

    CACTransferBufferV2 tb;
	memset(&tb, 0, sizeof(CACTransferBufferV2));
	tb.old.uTransferType = CACTB_RECEIVE;

    tb.old.Receive.RequestTimeout = dwTimeout;
    tb.old.Receive.Action = dwAction;

	//
	// ISSUE: handle to ulong casting should be handled
	//
    tb.old.Receive.Cursor = (hCursor != 0) ? (ULONG)CI2CH(hCursor) : 0;

    // Enlist QM in the transaction (for the first time);
    // Check that the transaction state is correct
    if (pTransaction)
    {
        // Enlist QM in transaction, if it isn't enlisted already
        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        tb.old.pUow = &Uow;

        if(FAILED(hr))
        {
            return MQ_ERROR_TRANSACTION_ENLIST;
        }
    }

    //
    //  Parse properties
    //
    if(pmp !=0)
    {
        //
        //  Parse message properties, an exception can be raised on access to
        //  pmp fields
        //
        rc1 = RTpParseMessageProperties(
                RECV_PARSE,
                &tb,
                pmp->cProp,
                pmp->aPropID,
                pmp->aPropVar,
                pmp->aStatus,
                NULL,
                NULL,
                NULL);

        if(FAILED(rc1))
        {
            return(rc1);
        }
    }

    OVERLAPPED ov = {0};
    LPOVERLAPPED pov;

    if (fnReceiveCallback)
    {
        //
        //  Async Rx with Callback
        //
        //  do HERE all allocation of resources so that allocation
        //  failure won't happen after returning from ACDepReceiveMessage.
        //
	
	{
		CS Lock(s_InitAsyncRxCS);
        // This critical section prevent two threads from running the
        // initialization twice.
        if (!s_hAsyncRxThread)
        {
           rc = InitRxAsyncThread() ;
        }
	}

        if(FAILED(rc))
        {
           return rc;
        }

	if (PendingReqCounter.Increment() > RXTHREAD_HANDLELISTSIZE)
        {
           // Reached Async MQReceive() limit.
           //
           return MQ_ERROR_INSUFFICIENT_RESOURCES ;
        }

	*&hCallback = CreateEvent( 
						NULL,
                                 TRUE,  // manual reset
                                 FALSE, // not signalled
						NULL 
						);

	if (hCallback == NULL) 
	{
	   return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	*&lpDesc = new MQRXASYNCDESCRIPTOR;
	memset(lpDesc.get(), 0, sizeof(MQRXASYNCDESCRIPTOR));
        lpDesc->Overlapped.hEvent = hCallback ;
	pov = &(lpDesc->Overlapped);
    }
    else if(lpOverlapped != 0)
    {
        //
        //  Asynchronous (event or completion port)
        //
        pov = lpOverlapped;
    }
    else
    {
        //
        //  Synchronous, uses the TLS event
        //
        ov.hEvent = GetThreadEvent();
        pov = &ov;
    }

    //
    //  Call AC driver with transfer buffer
    //
    tb.old.Receive.Asynchronous = (pov != &ov);
    rc = ACDepReceiveMessage(
            hQueue,
            tb,
            pov
            );

    if((rc == MQ_INFORMATION_OPERATION_PENDING) && (pov == &ov))
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ov.hEvent,
                        INFINITE
                        );

        //
        //  BUGBUG: MQReceiveMessage, must succeed in WaitForSingleObject
        //
        ASSERT(dwResult == WAIT_OBJECT_0);

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    if(FAILED(rc))
    {
        //
        //  ACDepReceiveMessage failed (immidiatly or after waiting)
        //
        return rc;
    }
    else if(fnReceiveCallback)
    {
        //
        // Async Rx with callback.
        //
		ASSERT(hCallback != NULL);
		ASSERT(lpDesc.get() != NULL);

        lpDesc->hSource = hQueue ;
        lpDesc->dwTimeout = dwTimeout ;
        lpDesc->dwAction = dwAction ;
        lpDesc->pMessageProps = pmp ;
        lpDesc->lpOverlapped = lpOverlapped ;
        lpDesc->hCursor = hCursor ;

        lpDesc->fnReceiveCallback = fnReceiveCallback ;

		{
			CS Lock(s_AsyncRxCS);

			s_pRxEventsHList[ s_cRxHandles ] = hCallback.detach();
			s_lpRxAsynDescList[ s_cRxHandles ] = lpDesc.detach();
            s_cRxHandles++ ;
		}

        // Tell the async thread that there is a new async MQReceive().
        BOOL fSet = SetEvent(s_hNewAsyncRx) ;
        ASSERT(fSet) ;
		DBG_USED(fSet);

		PendingReqCounter.Detach();
    }

    if (rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return(rc1);
    }

    return(rc);
}


//---------------------------------------------------------
//
//  DepReceiveMessage(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

	__try
	{
		return DeppReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return GetExceptionCode();
	}
}



//---------------------------------------------------------
//
//  DepGetOverlappedResult(...)
//
//  Description:
//
//      Falcon API.
//      Translate and overlapping operation result code.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

	return RTpConvertToMQCode(DWORD_PTR_TO_DWORD(lpOverlapped->Internal));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    QUEUE_FORMAT <--> Format Name String conversion routines

Author:

    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#include "stdh.h"
#include <mqformat.h>
#include <fntoken.h>

#include "fnparse.tmh"

//=========================================================
//
//  QUEUE_FORMAT -> Format Name String conversion routine
//
//=========================================================

//---------------------------------------------------------
//
//  Function:
//      RTpQueueFormatToFormatName
//
//  Description:
//      Convert QUEUE_FORMAT to a format name string.
//
//---------------------------------------------------------
HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    )
{
    return MQpQueueFormatToFormatName(
            pQueueFormat,
            lpwcsFormatName,
            dwBufferLength,
            lpdwFormatNameLength,
			false
            );
}


//=========================================================
//
//  Format Name String -> QUEUE_FORMAT conversion routines
//
//=========================================================

//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
//  N.B. if no white space is needed uncomment next line
//#define skip_ws(p) (p)
inline LPCWSTR skip_ws(LPCWSTR p)
{
    //
    //  Don't skip first non white space
    //
    while(iswspace(*p))
    {
        ++p;
    }

    return p;
}


//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR FindPathNameDelimiter(LPCWSTR p)
{
	//
	// NULL return value handled by callers.
	//
    return wcschr(p, PN_DELIMITER_C);
}


//---------------------------------------------------------
//
//  Parse Format Name Type prefix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrefixString(LPCWSTR p, QUEUE_FORMAT_TYPE& qft)
{
    const int unique = 1;
    //----------------0v-------------------------
    ASSERT(L'U' == FN_PUBLIC_TOKEN    [unique]);
    ASSERT(L'R' == FN_PRIVATE_TOKEN   [unique]);
    ASSERT(L'O' == FN_CONNECTOR_TOKEN [unique]);
    ASSERT(L'A' == FN_MACHINE_TOKEN   [unique]);
    ASSERT(L'I' == FN_DIRECT_TOKEN    [unique]);
    //----------------0^-------------------------

    //
    //  accelarate token recognition by checking 3rd character
    //
    switch(towupper(p[unique]))
    {
        //  pUblic
        case L'U':
            qft = QUEUE_FORMAT_TYPE_PUBLIC;
            if(_wcsnicmp(p, FN_PUBLIC_TOKEN, FN_PUBLIC_TOKEN_LEN) == 0)
                return (p + FN_PUBLIC_TOKEN_LEN);
            break;

        //  pRivate
        case L'R':
            qft = QUEUE_FORMAT_TYPE_PRIVATE;
            if(_wcsnicmp(p, FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
                return (p + FN_PRIVATE_TOKEN_LEN);
            break;

        //  cOnnector
        case L'O':
            qft = QUEUE_FORMAT_TYPE_CONNECTOR;
            if(_wcsnicmp(p, FN_CONNECTOR_TOKEN, FN_CONNECTOR_TOKEN_LEN) == 0)
                return (p + FN_CONNECTOR_TOKEN_LEN);
            break;

        //  mAchine
        case L'A':
            qft = QUEUE_FORMAT_TYPE_MACHINE;
            if(_wcsnicmp(p, FN_MACHINE_TOKEN, FN_MACHINE_TOKEN_LEN) == 0)
                return (p + FN_MACHINE_TOKEN_LEN);
            break;

        //  dIrect
        case L'I':
            qft = QUEUE_FORMAT_TYPE_DIRECT;
            if(_wcsnicmp(p, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TOKEN_LEN);
            break;
    }

    return 0;
}


//---------------------------------------------------------
//
//  Parse a guid string, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseGuidString(LPCWSTR p, GUID* pg)
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    int n;
    UINT w2, w3, d[8];
    if(_snwscanf(
            p,
			GUID_STR_LENGTH,
            GUID_FORMAT L"%n",
            &pg->Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7],     //  Data4[4..7]
            &n                              //  number of characters scaned
            ) != 11)
    {
        //
        //  not all 11 fields where not found.
        //
        return 0;
    }

    pg->Data2 = (WORD)w2;
    pg->Data3 = (WORD)w3;
    for(int i = 0; i < 8; i++)
    {
        pg->Data4[i] = (BYTE)d[i];
    }

    return (p + n);
}


//---------------------------------------------------------
//
//  Parse private id uniquifier, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrivateIDString(LPCWSTR p, ULONG* pUniquifier)
{
    int n;
    if(_snwscanf(
            p,
			FN_PRIVATE_ID_FORMAT_LEN,
            FN_PRIVATE_ID_FORMAT L"%n",
            pUniquifier,
            &n                              //  number of characters scaned
            ) != 1)
    {
        //
        //  private id field was not found.
        //
        return 0;
    }

    return (p + n);
}

enum DIRECT_TOKEN_TYPE {
    DT_OS,
    DT_TCP,
    DT_SPX,
};


//---------------------------------------------------------
//
//  Parse direct token type infix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseDirectTokenString(LPCWSTR p, DIRECT_TOKEN_TYPE& dtt)
{
    const int unique = 0;
    //-----------------------v-------------------
    ASSERT(L'O' == FN_DIRECT_OS_TOKEN   [unique]);
    ASSERT(L'T' == FN_DIRECT_TCP_TOKEN  [unique]);
    //-----------------------^-------------------

    //
    //  accelarate token recognition by checking 1st character
    //
    switch(towupper(p[unique]))
    {
        // Os:
        case L'O':
            dtt = DT_OS;
            if(_wcsnicmp(p, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_OS_TOKEN_LEN);
            break;

        // Tcp:
        case L'T':
            dtt = DT_TCP;
            if(_wcsnicmp(p, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TCP_TOKEN_LEN);
            break;
    }

    return 0;
}

//---------------------------------------------------------
//
//  Parse queue name string, (private, public)
//  N.B. queue name must end with either format name suffix
//      delimiter aka ';' or with end of string '\0'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseQueueNameString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if(_wcsnicmp(p, SYSTEM_QUEUE_PATH_INDICATIOR, SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        p += SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH;
        *pqpt = SYSTEM_QUEUE_PATH_TYPE;
        return p;
    }

    if(_wcsnicmp(p, PRIVATE_QUEUE_PATH_INDICATIOR, PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        *pqpt = PRIVATE_QUEUE_PATH_TYPE;
        p += PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH;
    }
    else
    {
        *pqpt = PUBLIC_QUEUE_PATH_TYPE;
    }

    //
    //  Zero length queue name is illegal
    //
    if(*p == L'\0')
        return 0;

    while(
        (*p != L'\0') &&
        (*p != PN_DELIMITER_C) &&
        (*p != FN_SUFFIX_DELIMITER_C)
        )
    {
        ++p;
    }

    //
    //  Path name delimiter is illegal in queue name
    //
    if(*p == PN_DELIMITER_C)
        return 0;


    return p;
}


//---------------------------------------------------------
//
//  Parse machine name in a path name
//  N.B. machine name must end with a path name delimiter aka slash '\\'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseMachineNameString(LPCWSTR p)
{
    //
    //  Zero length machine name is illegal
    //  don't fall off the string (p++)
    //
    if(*p == PN_DELIMITER_C)
        return 0;

    if((p = FindPathNameDelimiter(p)) == 0)
        return 0;

    return (p + 1);
}


//---------------------------------------------------------
//
//  Check if this is an expandable machine path. i.e., ".\\"
//
inline BOOL IsExpandableMachinePath(LPCWSTR p)
{
    return ((p[0] == PN_LOCAL_MACHINE_C) && (p[1] == PN_DELIMITER_C));
}

//---------------------------------------------------------
//
//  Optionally expand a path name with local machine name.
//  N.B. expansion is done if needed.
//  return pointer to new/old string
//
static LPCWSTR ExpandPathName(LPCWSTR pStart, ULONG_PTR offset, LPWSTR* ppStringToFree)
{
    if((ppStringToFree == 0) || !IsExpandableMachinePath(&pStart[offset]))
        return pStart;

    int len = wcslen(pStart);
    LPWSTR pCopy = new WCHAR[len + g_dwComputerNameLen + 1 - 1];

    //
    //  copy prefix, till offset '.'
    //
    memcpy(
        pCopy,
        pStart,
        offset * sizeof(WCHAR)
        );

    //
    //  copy computer name to offset
    //
    memcpy(
        pCopy + offset,
        g_lpwcsComputerName,
        g_dwComputerNameLen * sizeof(WCHAR)
        );

    //
    //  copy rest of string not including dot '.'
    //
    memcpy(
        pCopy + offset + g_dwComputerNameLen,
        pStart + offset + 1,                        // skip dot
        (len - offset - 1 + 1) * sizeof(WCHAR)      // skip dot, include '\0'
        );

    *ppStringToFree = pCopy;
    return pCopy;
}


//---------------------------------------------------------
//
//  Parse OS direct format string. (check validity of path
//  name and optionally expand it)
//  ppDirectFormat - expended direct format string. (in out)
//  ppStringToFree - return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectOSString(
    LPCWSTR p, 
    LPCWSTR* ppDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    LPCWSTR pMachineName = p;
    LPCWSTR pStringToCopy = *ppDirectFormat;

    if((p = ParseMachineNameString(p)) == 0)
        return 0;

    if((p = ParseQueueNameString(p, pqpt)) == 0)
        return 0;


    *ppDirectFormat = ExpandPathName(pStringToCopy, (pMachineName - pStringToCopy), ppStringToFree);

    return p;
}


//---------------------------------------------------------
//
//  Parse net (tcp/spx) address part of direct format string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseNetAddressString(LPCWSTR p)
{
    //
    //  Zero length address string is illegal
    //  don't fall off the string (p++)
    //
    if(*p == PN_DELIMITER_C)
        return 0;

    if((p = FindPathNameDelimiter(p)) == 0)
        return 0;

    return (p + 1);
}


//---------------------------------------------------------
//
//  Parse net (tcp/spx) direct format string. (check validity of queue name)
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseDirectNetString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if((p = ParseNetAddressString(p)) == 0)
        return 0;

    if((p = ParseQueueNameString(p, pqpt)) == 0)
        return 0;

    return p;
}

static void RemoveSuffixFromDirect(LPCWSTR* ppDirectFormat, LPWSTR* ppStringToFree)
{
    ASSERT(ppStringToFree != NULL);

    LPCWSTR pSuffixDelimiter = wcschr(*ppDirectFormat, FN_SUFFIX_DELIMITER_C);
    //
	// ASSERT is enough since caller verifies the delimiter is there.
	//
	ASSERT(pSuffixDelimiter != NULL);

    INT_PTR len = pSuffixDelimiter - *ppDirectFormat;
    LPWSTR pCopy = new WCHAR[len + 1];
    wcsncpy(pCopy, *ppDirectFormat, len);
    pCopy[len] = '\0';

    if (*ppStringToFree != NULL)
    {
        delete [] *ppStringToFree;
    }

    *ppDirectFormat = *ppStringToFree = pCopy;
}

//---------------------------------------------------------
//
//  Parse direct format string.
//  return expended direct format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static 
LPCWSTR 
ParseDirectString(
    LPCWSTR p, 
    LPCWSTR* ppExpandedDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    *ppExpandedDirectFormat = p;

    DIRECT_TOKEN_TYPE dtt;
    if((p = ParseDirectTokenString(p, dtt)) == 0)
        return 0;

    switch(dtt)
    {
        case DT_OS:
            p = ParseDirectOSString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case DT_TCP:
        case DT_SPX:
            p = ParseDirectNetString(p, pqpt);
            break;

        default:
            ASSERT(0);
    }

	if (p == NULL)
		return p;

    p = skip_ws(p);

    //
    // Remove suffix (like ;Journal)
    //
    if(*p == FN_SUFFIX_DELIMITER_C)
    {
        RemoveSuffixFromDirect(ppExpandedDirectFormat, ppStringToFree);
    }
    return p;
}


//---------------------------------------------------------
//
//  Parse format name suffix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseSuffixString(LPCWSTR p, QUEUE_SUFFIX_TYPE& qst)
{
    const int unique = 5;
    //---------------01234v----------------------
    ASSERT(L'N' == FN_JOURNAL_SUFFIX    [unique]);
    ASSERT(L'L' == FN_DEADLETTER_SUFFIX [unique]);
    ASSERT(L'X' == FN_DEADXACT_SUFFIX   [unique]);
    ASSERT(L'O' == FN_XACTONLY_SUFFIX   [unique]);
    //---------------01234^----------------------

    //
    //  we already know that first character is ";"
    //
    ASSERT(*p == FN_SUFFIX_DELIMITER_C);

    //
    //  accelarate token recognition by checking 6th character
    //
    switch(towupper(p[unique]))
    {
        // ;jourNal
        case L'N':
            qst = QUEUE_SUFFIX_TYPE_JOURNAL;
            if(_wcsnicmp(p, FN_JOURNAL_SUFFIX, FN_JOURNAL_SUFFIX_LEN) == 0)
                return (p + FN_JOURNAL_SUFFIX_LEN);
            break;

        // ;deadLetter
        case L'L':
            qst = QUEUE_SUFFIX_TYPE_DEADLETTER;
            if(_wcsnicmp(p, FN_DEADLETTER_SUFFIX, FN_DEADLETTER_SUFFIX_LEN) == 0)
                return (p + FN_DEADLETTER_SUFFIX_LEN);
            break;

        // ;deadXact
        case L'X':
            qst = QUEUE_SUFFIX_TYPE_DEADXACT;
            if(_wcsnicmp(p, FN_DEADXACT_SUFFIX, FN_DEADXACT_SUFFIX_LEN) == 0)
                return (p + FN_DEADXACT_SUFFIX_LEN);
            break;

        // ;xactOnly
        case L'O':
            qst = QUEUE_SUFFIX_TYPE_XACTONLY;
            if(_wcsnicmp(p, FN_XACTONLY_SUFFIX, FN_XACTONLY_SUFFIX_LEN) == 0)
                return (p + FN_XACTONLY_SUFFIX_LEN);
            break;
    }

    return 0;
}


//---------------------------------------------------------
//
//  Function:
//      RTpFormatNameToQueueFormat
//
//  Description:
//      Convert a format name string to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
BOOL
RTpFormatNameToQueueFormat(
    LPCWSTR pfn,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
    LPCWSTR p = pfn;
    QUEUE_FORMAT_TYPE qft;

    if((p = ParsePrefixString(p, qft)) == 0)
        return FALSE;

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
        return FALSE;

    p = skip_ws(p);

    GUID guid;
    switch(qft)
    {
        //
        //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PUBLIC:
            if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->PublicID(guid);
            break;

        //
        //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PRIVATE:
            if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            p = skip_ws(p);

            if(*p++ != FN_PRIVATE_SEPERATOR_C)
                return FALSE;

            p = skip_ws(p);

            ULONG uniquifier;
            if((p = ParsePrivateIDString(p, &uniquifier)) == 0)
                return FALSE;

            pqf->PrivateID(guid, uniquifier);
            break;

        //
        //  "DIRECT=OS:bla-bla\0"
        //
        case QUEUE_FORMAT_TYPE_DIRECT:
            LPCWSTR pExpandedDirectFormat;
            QUEUE_PATH_TYPE qpt;
            if((p = ParseDirectString(p, &pExpandedDirectFormat, ppStringToFree, &qpt)) == 0)
                return FALSE;

            if (qpt == SYSTEM_QUEUE_PATH_TYPE)
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat), QUEUE_FORMAT_FLAG_SYSTEM);
            }
            else
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat));
            }
            break;

        //
        //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_MACHINE:
           if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->MachineID(guid);
            break;

        //
        //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_CONNECTOR:
           if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->ConnectorID(guid);
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    //  We're at end of string, return now.
    //  N.B. Machine format name *must* have a suffix
    //
    if(*p == L'\0')
        return (qft != QUEUE_FORMAT_TYPE_MACHINE);

    if(*p != FN_SUFFIX_DELIMITER_C)
        return FALSE;

    QUEUE_SUFFIX_TYPE qst;
    if((p = ParseSuffixString(p, qst)) == 0)
        return FALSE;

    p = skip_ws(p);

    //
    //  Only white space padding is allowed.
    //
    if(*p != L'\0')
        return FALSE;

    pqf->Suffix(qst);

    return pqf->Legal();
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathType
//
//  Description:
//      Validate, Expand and return type for Path Name.
//
//---------------------------------------------------------
QUEUE_PATH_TYPE
RTpValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    )
{
    ASSERT(ppStringToFree != 0);

    LPCWSTR pwcsPathNameNoSpaces = pwcsPathName;
    P<WCHAR> pStringToFree;
    *ppStringToFree = 0;

    //
    // Remove leading white spaces
    //
    while (*pwcsPathNameNoSpaces != 0 && iswspace(*pwcsPathNameNoSpaces))
    {
        pwcsPathNameNoSpaces++;
    }

    //
    // Remove trailing white spaces
    //
    DWORD dwLen = wcslen(pwcsPathNameNoSpaces);
    if (iswspace(pwcsPathNameNoSpaces[dwLen-1]))
    {
        pStringToFree = new WCHAR[dwLen+1];
        wcscpy(pStringToFree.get(), pwcsPathNameNoSpaces);
        for (DWORD i = dwLen; i-- > 0; )
        {
            if (iswspace(pStringToFree.get()[i]))
            {
                pStringToFree.get()[i] = 0;
            }
            else
            {
                break;
            }
        }
        pwcsPathNameNoSpaces = pStringToFree.get();
    }

    LPCWSTR p = pwcsPathNameNoSpaces;

    if((p = ParseMachineNameString(p)) == 0)
        return ILLEGAL_QUEUE_PATH_TYPE;

    QUEUE_PATH_TYPE qpt;
    if((p = ParseQueueNameString(p, &qpt)) == 0)
        return ILLEGAL_QUEUE_PATH_TYPE;

    //
    //  No characters are allowed at end of queue name.
    //
    if(*p != L'\0')
        return ILLEGAL_QUEUE_PATH_TYPE;

    *ppwcsExpandedPathName = ExpandPathName(pwcsPathNameNoSpaces, 0, ppStringToFree);

    //
    // if ExpandPathName does not return a string to free, we will
    // give the caller the string we allocated, so the caller will free it.
    // Otherwise, we will do nothing and "our" string will be auto-release.
    //
    if (*ppStringToFree == 0)
    {
        *ppStringToFree = pStringToFree.detach();
    }

    return (qpt);
}

//+-------------------------------------------
//
//  BOOL  RTpIsLocalPublicQueue()
//
//+-------------------------------------------

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName)
{
    WCHAR  wDelimiter = lpwcsExpandedPathName[ g_dwComputerNameLen ] ;

    if ((wDelimiter == PN_DELIMITER_C) ||
        (wDelimiter == PN_LOCAL_MACHINE_C))
    {
        //
        // Delimiter OK (either end of NETBios machine name, or dot of
        // DNS name. Continue checking.
        //
    }
    else
    {
        return FALSE ;
    }

    DWORD dwSize = g_dwComputerNameLen + 1 ;
    P<WCHAR> pQueueCompName = new WCHAR[ dwSize ] ;
    lstrcpynW( pQueueCompName.get(), lpwcsExpandedPathName, dwSize ) ;

    BOOL bRet = (lstrcmpi( g_lpwcsComputerName, pQueueCompName.get() ) == 0) ;
    return bRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\qmrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qmrt.cpp

Abstract:



Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

--*/

#include "stdh.h"
#include "rtprpc.h"
#include "_registr.h"

#include "qmrt.tmh"

static WCHAR *s_FN=L"rtdep/qmrt";

GUID g_guidSupportQmGuid = GUID_NULL ;

static
void
GetSecurityDescriptorSize(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpdwSecurityDescriptorSize)
{
    if (pSecurityDescriptor)
    {
        ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));
        *lpdwSecurityDescriptorSize = GetSecurityDescriptorLength(pSecurityDescriptor);
    }
    else
    {
        *lpdwSecurityDescriptorSize = 0;
    }
}

HRESULT
DeppCreateObject(
    /* in */ DWORD dwObjectType,
    /* in */ LPCWSTR lpwcsPathName,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in */ DWORD cp,
    /* in */ PROPID aProp[],
    /* in */ PROPVARIANT apVar[])
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

		return(R_QMCreateObjectInternal(tls_hBindRpc,
                                  dwObjectType,
                                  lpwcsPathName,
                                  dwSecurityDescriptorSize,
                                  (unsigned char *)pSecurityDescriptor,
                                  cp,
                                  aProp,
                                  apVar));
}


HRESULT
DeppSetObjectSecurity(
    /* in */ OBJECT_FORMAT* pObjectFormat,
    /* in */ SECURITY_INFORMATION SecurityInformation,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

    return(R_QMSetObjectSecurityInternal(tls_hBindRpc,
                                       pObjectFormat,
                                       SecurityInformation,
                                       dwSecurityDescriptorSize,
                                       (unsigned char *)pSecurityDescriptor));
}


static
HRESULT
DeppQueryQMInformation(
	handle_t hBind,
	DWORD QueryType,
	LPWSTR* ppString
	)
{
	RpcTryExcept
	{
		return R_QMQueryQMRegistryInternal(hBind, QueryType, ppString);
	}
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
        PRODUCE_RPC_ERROR_TRACING;
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}
	RpcEndExcept
}


//+------------------------------------------------------------
//
//  HRESULT RTpGetSupportServerInfo(BOOL *pfRemote)
//
//+------------------------------------------------------------

HRESULT RTpGetSupportServerInfo(BOOL *pfRemote)
{
	DWORD dwSize;
	DWORD dwType;
	LONG  rc;

	ASSERT(pfRemote);
	*pfRemote = g_fDependentClient;

	if (!g_fDependentClient)
	{
		return MQ_OK;
	}

	INIT_RPC_HANDLE ;

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

	LPWSTR  lpStr = NULL;
	HRESULT hr = DeppQueryQMInformation( 
					tls_hBindRpc,
					QueryRemoteQM_MQISServers,
					&lpStr 
					);

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		dwSize = wcslen(lpStr) *sizeof(WCHAR);
		dwType = REG_SZ;
		rc = SetFalconKeyValue( 
					MSMQ_DS_SERVER_REGNAME,
					&dwType,
					lpStr,
					&dwSize
					);
		ASSERT(rc == ERROR_SUCCESS);
		delete lpStr;
		lpStr = NULL;
	}

	hr = DeppQueryQMInformation( 
				tls_hBindRpc,
				QueryRemoteQM_LongLiveDefault,
				&lpStr 
				);

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		dwSize = sizeof(DWORD);
		dwType = REG_DWORD;
		DWORD dwValue = (DWORD) _wtol(lpStr);
		rc = SetFalconKeyValue( 
				MSMQ_LONG_LIVE_REGNAME,
				&dwType,
				&dwValue,
				&dwSize
				);
		ASSERT(rc == ERROR_SUCCESS);
		delete lpStr;
		lpStr = NULL;
	}

	hr = DeppQueryQMInformation( 
				tls_hBindRpc,
				QueryRemoteQM_EnterpriseGUID,
				&lpStr 
				);

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		GUID guidEnterprise;
		RPC_STATUS st = UuidFromString(lpStr, &guidEnterprise);
		if (st == RPC_S_OK)
		{
			dwSize = sizeof(GUID);
			dwType = REG_BINARY;
			rc = SetFalconKeyValue( 
					MSMQ_ENTERPRISEID_REGNAME,
					&dwType,
					&guidEnterprise,
					&dwSize
					);
			ASSERT(rc == ERROR_SUCCESS);
		}
		delete lpStr;
		lpStr = NULL;
	}

	hr = DeppQueryQMInformation( 
				tls_hBindRpc,
				QueryRemoteQM_ServerQmGUID,
				&lpStr 
				);

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		RPC_STATUS st = UuidFromString(lpStr, &g_guidSupportQmGuid);

		ASSERT(st == RPC_S_OK);
		DBG_USED(st);

		//
		// Write Supporting Server QmGuid to SUPPORT_SERVER_QMID registry.
		// This value will be used by ad to check the supporting server AD environment.
		//
		dwType = REG_BINARY;
		dwSize = sizeof(GUID);

		rc = SetFalconKeyValue( 
						MSMQ_SUPPORT_SERVER_QMID_REGNAME,
						&dwType,
						&g_guidSupportQmGuid,
						&dwSize
						);

		ASSERT(rc == ERROR_SUCCESS);

		delete lpStr;
		lpStr = NULL;
	}
	else if (hr == MQ_ERROR)
	{
		//
		// don't return error here, as this query is not supported by previous
		// versions of msmq.
		//
		hr = MQ_OK;
	}

	return hr;
}


HRESULT
DeppSendMessage(
    IN handle_t hBind,
    IN QUEUEHANDLE  hQueue,
    IN CACTransferBufferV2 *pCacTB)
{
    HRESULT hr = MQ_OK;
    LPWSTR pwcsLongFormatName = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            WCHAR pwcsShortFormatName[64];
            LPWSTR pwcsFormatName = pwcsShortFormatName;
            DWORD dwFormatNameLen = sizeof(pwcsShortFormatName) / sizeof(WCHAR);

            //
            // The format name of the queue should be passed to the QM
            // because it can't use the handle of the application. The
            // QM will then have to open the queue for each message.
            // But this shouldn't be too expansive because the queue
            // should be already opened and the queue's properties sohuld
            // be cached in the QM.
            //
            hr = DepHandleToFormatName(hQueue, pwcsFormatName, &dwFormatNameLen);
            if (FAILED(hr))
            {
                if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
                {
                    pwcsLongFormatName = new WCHAR[dwFormatNameLen];
                    pwcsFormatName = pwcsLongFormatName;
                    hr = DepHandleToFormatName(hQueue, pwcsFormatName, &dwFormatNameLen);
                    if (FAILED(hr))
                    {
                        ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
                        return hr;
                    }
                }
                else
                {
                    return hr;
                }
            }

            //
            // Convert the queue format name into a QUEUE_FORMAT
            //
            QUEUE_FORMAT QueueFormat;
            BOOL bRet;

            bRet = RTpFormatNameToQueueFormat(pwcsFormatName,
                                              &QueueFormat,
                                              &pStringToFree);
            //
            // RTpFormatNameToQueueFormat must succeed because we got
            // the format name from DepHandleToFormatName.
            //
            ASSERT(bRet);

            //
            // Now ask the QM to do the security operations and send
            // the message to the device driver.
            //
            ASSERT(hBind) ;
			OBJECTID * pMessageId = ( pCacTB->old.ppMessageID != NULL) ? *pCacTB->old.ppMessageID : NULL;
            hr = QMSendMessageInternalEx(
				hBind,
				&QueueFormat,
				pCacTB,
				pMessageId);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            hr = GetExceptionCode();
            if (SUCCEEDED(hr))
            {
                hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pwcsLongFormatName;
        delete[] pStringToFree;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtctxex.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtctxex.cpp

Abstract:

    This module implements the DepGetSecurityContextEx().

Author:

    Doron Juster (DoronJ)  13-Apr-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <mqsec.h>

#include "rtctxex.tmh"

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for DepGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CTX_ERROR
#endif

BOOL     SameAsProcessSid( PSID pSid ) ; // from rtsecctx.cpp
HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx) ;

/***********************************************************************
*
*   Function - DepGetSecurityContextEx()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in DepSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of DepSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to DepSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call DepFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
DepGetSecurityContextEx( LPVOID  lpCertBuffer,
                        DWORD   dwCertBufferLength,
                        HANDLE *hSecurityContext )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    P<BYTE>    pSid = NULL ;
    CHCryptKey hKey = NULL ;
    HRESULT hr = MQ_OK;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return(hr);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert.detach();
			pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert.get(), lpCertBuffer, dwCertBufferLength);
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = MQSec_GetThreadUserSid(
                    FALSE,
                    reinterpret_cast<PSID*>(&pSid),
                    &dwLen,
                    FALSE           // fThreadTokenOnly
                    ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        BOOL fAsProcess = SameAsProcessSid( pSid.get() ) ;

		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
        hr  = GetCertInfo(  !fAsProcess,
                            pSecCtx->fLocalSystem,
                           ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return(hr);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail DepGetSecurityContext().
            // DepSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *hSecurityContext = (HANDLE) pSecCtx.get() ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx.get()) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }

    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\property.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    property.cxx

Abstract:



Author:

    Erez Haba (erezh) 2-Jan-96

Revision History:

    RonitH - Queue properties validation.
    BoazF (26-May-96) - Message properties validation.
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include <mqtime.h>
#include "acrt.h"
#include "rtprpc.h"

#include "property.tmh"

static WCHAR *s_FN=L"rtdep/property";

#define ONE_KB 1024
#define HRESULT_SEVIRITY(hr) (((hr) >> 30) & 0x3)

extern DWORD  g_dwTimeToReachQueueDefault ;

//+-------------------------------------------------------------------
//
//   HRESULT  _SupportingServerNotMSMQ1()
//   HRESULT  _TrySupportingServer(LPWSTR *ppString)
//
// Determine if supporting server is MSMQ1.0 (NT4) or MSMQ2.0 (NT5)
// We can't do this when loading the mqrt.dll because this need RPC over
// network and we can't initialize RPC on PROCESS_ATTACH.
// For independent client always return MQ_OK ;
//
//+-------------------------------------------------------------------

static HRESULT _TrySupportingServer(LPWSTR *ppString)
{
    HRESULT hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    INIT_RPC_HANDLE ;

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

    RpcTryExcept
    {
        hr = R_QMQueryQMRegistryInternal(
        		tls_hBindRpc,
                QueryRemoteQM_QMVersion,
                ppString
                );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        PRODUCE_RPC_ERROR_TRACING;
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
    }
	RpcEndExcept

    //
    // MQ_OK is returned only if supporting server is online and is MSMQ2.0
    //
    return hr ;
}

static HRESULT  _SupportingServerNotMSMQ1()
{
    if (!g_fDependentClient)
    {
        return MQ_OK ;
    }

    static HRESULT  s_hrSupportingServerNotMSMQ1 = MQ_OK ;
    static BOOL     s_fAlreadyInitialized = FALSE ;

    if (s_fAlreadyInitialized)
    {
        return s_hrSupportingServerNotMSMQ1 ;
    }

    P<WCHAR> lpStr = NULL ;
    HRESULT hr =  _TrySupportingServer(&lpStr) ;

    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_SERVICE_NOT_AVAILABLE)
        {
            //
            // supporting server not online now, so we can't determine.
            //
            return hr ;
        }

        //
        // Supporting server is MSMQ1.0.
        // It doesn't support new properties.
        //
        s_hrSupportingServerNotMSMQ1 = MQ_ERROR_PROPERTY_NOTALLOWED ;
    }

    s_fAlreadyInitialized = TRUE ;
    return s_hrSupportingServerNotMSMQ1 ;
}

//+----------------------------------------------
//
//  HRESULT  RTpCheckColumnsParameter()
//
//+----------------------------------------------

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns)
{
    HRESULT hr = MQ_OK;

    if (( pColumns == NULL) ||
        ( pColumns->cCol == 0))
    {
        return(MQ_ERROR_ILLEGAL_MQCOLUMNS);
    }

    __try
    {
        PROPID * pPropid = pColumns->aCol;
        for ( DWORD i = 0; i < pColumns->cCol; i++, pPropid++)
        {
            //
            //  make sure that the property id is with-in queue property ids range
            //
            if (((*pPropid) > PROPID_Q_PATHNAME_DNS)  || ((*pPropid) <= PROPID_Q_BASE))
            {
                return(MQ_ERROR_ILLEGAL_PROPID);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing column structure");
        hr = GetExceptionCode();
    }

    return(hr);
}


static
void
SetStatus(
    HRESULT* pStatusSummary,
    HRESULT* pStatus,
    HRESULT Status
    )
{
    DWORD dwSummarySevirity = HRESULT_SEVIRITY(*pStatusSummary);
    DWORD dwStatusSevirity = HRESULT_SEVIRITY(Status);

    if (dwSummarySevirity < dwStatusSevirity)
    {
        switch(dwStatusSevirity)
        {
        case 1:
            *pStatusSummary = MQ_INFORMATION_PROPERTY;
            break;

        case 2:
            ASSERT(FALSE);
			break;

        case 3:
            *pStatusSummary = MQ_ERROR_PROPERTY;
            break;
        }
    }

    if(pStatus)
    {
        *pStatus = Status;
    }
}


typedef struct {
    PROPID  propId;
    BOOL    fAllow_VT_NULL;
    BOOL    fMustAppear;
    BOOL    fShouldNotAppear;
    BOOL    fPossiblyIgnored;
    HRESULT (* pfValidateProperty)(PROPVARIANT * pVar, PVOID pvContext);
} propValidity;

static
DWORD
CalNumberOfMust(
    IN propValidity * ppropValidity,
    IN DWORD          dwNumberOfProps
    )
{
    DWORD dwNumberOfMust = 0;

    for ( DWORD i =0; i < dwNumberOfProps; i++, ppropValidity++ )
    {
        if (ppropValidity->fMustAppear)
        {
            dwNumberOfMust++;
        }
    }
    return(dwNumberOfMust);
}

static
HRESULT
CheckProps(
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    IN PROPID propidMinPropId,
    IN PROPID propidMaxPropId,
    IN propValidity *ppropValidity,
    IN VARTYPE *vartypePropVts,
    IN BOOL fCheckForIgnoredProps,
    IN DWORD dwNumberOfMustProps,
    IN PVOID pvContext
    )
{
    HRESULT hr = MQ_OK;
    HRESULT dummyStatus;
    BOOL fAdvanceStatusPointer;
    char duplicate[ PROPID_OBJ_GRANULARITY ];
    DWORD index;
    DWORD dwNumberOfMustPropsSupplied = 0;

    memset( duplicate, 0, sizeof(duplicate));

    if ( !pStatus )
    {
        pStatus = &dummyStatus;
        fAdvanceStatusPointer = FALSE;
    }
    else
    {
        fAdvanceStatusPointer = TRUE;
    }

    for ( DWORD i = 0;
          i < cProp;
          i++, pPropid++, pVar++, fAdvanceStatusPointer ? pStatus++ : 0)
    {
        //
        //  Is it a valid propid
        //
        if (((*pPropid) <= propidMinPropId)  || (propidMaxPropId < (*pPropid)))
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        index = (*pPropid) - propidMinPropId;
        ASSERT(ppropValidity[index].propId == *pPropid);

        //
        //  Is it a duplicate property
        //
        if ( duplicate[ index ] )
        {
            //
            //  The duplicate property is ignored, and a warning is returned
            //  in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_DUPLICATE_PROPERTY);
            continue;
        }
        duplicate[ index ] = 1;

        //
        //  Is it ok for the user to specify this property
        //
        if ( ppropValidity[index].fShouldNotAppear)
        {
            SetStatus(&hr, pStatus, MQ_ERROR_PROPERTY_NOTALLOWED);
            continue;
        }

        //
        // If an ignored property was supplied then raise a warning.
        //
        if (fCheckForIgnoredProps && (ppropValidity[index].fPossiblyIgnored))
        {
            SetStatus(&hr, pStatus, MQ_INFORMATION_PROPERTY_IGNORED);
            continue;
        }

        //
        // Checking propvariant's vartype.
        //
        if ((pVar->vt != vartypePropVts[index]) &&
            !(ppropValidity[index].fAllow_VT_NULL && pVar->vt == VT_NULL))
        {
            SetStatus(&hr, pStatus, MQ_ERROR_ILLEGAL_PROPERTY_VT);
            continue;
        }

        //
        //  Checking propvariant's value and size
        //
        if ( ppropValidity[index].pfValidateProperty != NULL)
        {
            SetStatus(&hr, pStatus, ppropValidity[index].pfValidateProperty(pVar, pvContext));
        }
        else
        {
            *pStatus = MQ_OK;
        }

        //
        //  Count the number of "must-appear" properties
        //
        if ( (*pStatus == MQ_OK) && ppropValidity[index].fMustAppear )
        {
            dwNumberOfMustPropsSupplied++;
        }
    }

    //
    //  where all the "must appear" properties passed in
    //
    if ( dwNumberOfMustPropsSupplied < dwNumberOfMustProps )
    {
        hr = MQ_ERROR_INSUFFICIENT_PROPERTIES;
    }

    return(hr);
}

static HRESULT qJournalValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_JOURNAL) && ( pVar->bVal != MQ_JOURNAL_NONE))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}


static HRESULT qLabelValidation( PROPVARIANT * pVar, LPVOID )
{
    __try
    {
        if ( wcslen( pVar->pwszVal) > MQ_MAX_Q_LABEL_LEN )
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }


    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }

    return(MQ_OK);
}


static HRESULT qAuthValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_AUTHENTICATE_NONE) &&
         (pVar->bVal != MQ_AUTHENTICATE))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qPrivLevelValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->ulVal != MQ_PRIV_LEVEL_NONE) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_OPTIONAL) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_BODY))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qXactionValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_TRANSACTIONAL_NONE) &&
         (pVar->bVal != MQ_TRANSACTIONAL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qTypeValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qInstanceValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qmMachineIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qmSiteIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//
propValidity    QueueCreateValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  TRUE,   FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,  FALSE,  FALSE,  qXactionValidation},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//

propValidity    QueueSetValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_Q_BASE
//

propValidity    QueueGetValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      TRUE,   FALSE,  FALSE,  TRUE,   qInstanceValidation},
    {PROPID_Q_TYPE,          TRUE,   FALSE,  FALSE,  FALSE,  qTypeValidation},
    {PROPID_Q_PATHNAME,      TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_QUOTA,         TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_CREATE_TIME,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_MODIFY_TIME,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_AUTHENTICATE,  TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PRIV_LEVEL,    TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_TRANSACTION,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  TRUE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE QueueVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_LPWSTR,  //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_LPWSTR,  //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_BLOB,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_LPWSTR,  //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_LPWSTR,  //PROPID_Q_NAME_SUFFIX
    VT_LPWSTR   //PROPID_Q_PATHNAME_DNS
};

VARTYPE GetQueuePropsVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_NULL,    //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_NULL,    //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_NULL,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_NULL,    //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_NULL,    //PROPID_Q_NAME_SUFFIX
    VT_NULL     //PROPID_Q_PATHNAME_DNS
};

static
void
RemovePropWarnings(
    IN  MQQUEUEPROPS*  pqp,
    IN  HRESULT*       aStatus,
    OUT MQQUEUEPROPS** ppGoodProps,
    OUT char**         ppTmpBuff)
{
    DWORD i;
    DWORD cGoodProps;
    char *pTmpBuff;
    MQQUEUEPROPS *pGoodProps;
    HRESULT *pStatus;
    QUEUEPROPID *pPropId;
    MQPROPVARIANT *pPropVar;

    // See how many good properties do we have.
    for (i = 0, cGoodProps = 0, pStatus = aStatus;
         i < pqp->cProp;
         i++, pStatus++)
    {
        if (*pStatus != MQ_OK)
        {
            ASSERT(!FAILED(*pStatus));
        }
        else
        {
            cGoodProps++;
        }
    }

    // Allocate the temporary buffer, the buffer contains everything in it.
    // It contains the MQQUEUEPROPS structure, the QUEUEPROPID and
    // MQPROPVARIANT arrays.
    pTmpBuff = new char[sizeof(MQQUEUEPROPS) +
                        cGoodProps * sizeof(QUEUEPROPID) +
                        cGoodProps * sizeof(MQPROPVARIANT)];
    *ppTmpBuff = pTmpBuff;

    pGoodProps = (MQQUEUEPROPS*)pTmpBuff;
    *ppGoodProps = pGoodProps;

    // Initialize the MQQUEUEPROPS structure.
    pGoodProps->cProp = cGoodProps;
    pGoodProps->aPropID = (QUEUEPROPID*)(pTmpBuff + sizeof(MQQUEUEPROPS));
    pGoodProps->aPropVar = (MQPROPVARIANT*)(pTmpBuff + sizeof(MQQUEUEPROPS) +
                           cGoodProps * sizeof(QUEUEPROPID));

    // Copy the array entries of the good properties to the arrays in the
    // temporary buffer.
    for (i = 0, cGoodProps = 0, pStatus = aStatus,
            pPropId = pqp->aPropID, pPropVar = pqp->aPropVar;
         i < pqp->cProp;
         i++, pStatus++, pPropId++, pPropVar++)
    {
        if (*pStatus == MQ_OK)
        {
            pGoodProps->aPropID[cGoodProps] = *pPropId;
            pGoodProps->aPropVar[cGoodProps] = *pPropVar;
            cGoodProps++;
        }
    }
}

static DWORD g_dwNumberOfMustPropsInCreate = 0xffff;
static DWORD g_dwNumberOfMustPropsInSet = 0xffff;

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS*  pqp,
    IN  DWORD          dwOp,
    IN  BOOL           fPrivateQueue,
    OUT MQQUEUEPROPS** ppGoodQP,
    OUT char**         ppTmpBuff
    )
{
    HRESULT hr = MQ_OK;
    propValidity *ppropValidity = 0;
    DWORD dwNumberOfMustProps = 0;
    VARTYPE *QueuePropVars = 0;

    if (!pqp)
    {
        return(MQ_ERROR_ILLEGAL_MQQUEUEPROPS);
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    switch (dwOp)
    {
    case QUEUE_CREATE:
        ppropValidity = QueueCreateValidation;
        if (g_dwNumberOfMustPropsInCreate == 0xffff)
        {
            g_dwNumberOfMustPropsInCreate =
                CalNumberOfMust( QueueCreateValidation,
                                 PROPID_Q_PATHNAME_DNS - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInCreate;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_SET_PROPS:
        ppropValidity = QueueSetValidation;
        if (g_dwNumberOfMustPropsInSet == 0xffff)
        {
            g_dwNumberOfMustPropsInSet =
                CalNumberOfMust( QueueSetValidation,
                                 PROPID_Q_PATHNAME_DNS - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSet;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_GET_PROPS:
        {
            //
            //  Clear all the pointers of VT_NULL variants
            //  and make the structure ready for RPC call
            //
            for (UINT i = 0; i < pqp->cProp; i++)
            {
                if (pqp->aPropVar[i].vt == VT_NULL)
                {
                    memset(&pqp->aPropVar[i].caub, 0, sizeof(CAUB));
                }
            }
        }

        ppropValidity = QueueGetValidation;
        dwNumberOfMustProps = 0;
        QueuePropVars = GetQueuePropsVarTypes;
        break;

    default:
        ASSERT(0);
        return MQ_ERROR;
    }

    HRESULT *aLocalStatus_buff = NULL;

    __try
    {
        __try
        {
            HRESULT *aLocalStatus;

            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            if (!pqp->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pqp->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pqp->aStatus;
            }

            hr = CheckProps(pqp->cProp,
                            pqp->aPropID,
                            pqp->aPropVar,
                            aLocalStatus,
                            PROPID_Q_BASE,
                            PROPID_Q_PATHNAME_DNS,
                            ppropValidity,
                            QueuePropVars,
                            fPrivateQueue,
                            dwNumberOfMustProps,
                            NULL);

            if (SUCCEEDED(hr))
            {
                if (hr != MQ_OK)
                {
                    // We have wornings, copy all the good properties to a temporary
                    // buffer so the DS will not have to handle duplicate properties etc.
                    RemovePropWarnings(pqp, aLocalStatus, ppGoodQP, ppTmpBuff);
                }
                else
                {
                    // All is perfectly well, we do not need a temporary buffer and all
                    // that overhead.
                    *ppGoodQP = pqp;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TrERROR(GENERAL, "Exception while parsing MQQUEUEPROPS structure");
            hr = GetExceptionCode();
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }

    return(hr);
}

class VALIDATION_CONTEXT
{
public:
    VALIDATION_CONTEXT();

    DWORD dwFlags;
    LPWSTR pwcsResponseStringToFree;
    LPWSTR pwcsAdminStringToFree;
    CACTransferBufferV2 *ptb;
    PMQSECURITY_CONTEXT pSecCtx;
};

typedef VALIDATION_CONTEXT *PVALIDATION_CONTEXT;

VALIDATION_CONTEXT::VALIDATION_CONTEXT() :
    dwFlags(0)
{
}

#define VALIDATION_SEND_FLAG_MASK           1
#define VALIDATION_SECURITY_CONTEXT_MASK    2
#define VALIDATION_RESP_FORMAT_MASK         4
#define VALIDATION_ADMIN_FORMAT_MASK        8

#define SEND_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SEND_FLAG_MASK)
#define SECURITY_CONTEXT_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)

#define FLAGS (((PVALIDATION_CONTEXT)pvContext)->dwFlags)
#define PTB (((PVALIDATION_CONTEXT)pvContext)->ptb)
#define PSECCTX (((PVALIDATION_CONTEXT)pvContext)->pSecCtx)

static HRESULT ParseMsgClass( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        //
        // Check if legal calss
        //
        if(!MQCLASS_IS_VALID(pVar->uiVal))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI2;
    }
    PTB->old.pClass = &pVar->uiVal;

    return (MQ_OK);
}

static HRESULT ParseMsgId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_MSGID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->old.ppMessageID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgCorrelationId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_CORRELATIONID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->old.ppCorrelationID = &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgPrio( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal < MQ_MIN_PRIORITY) || (MQ_MAX_PRIORITY < pVar->bVal))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pPriority = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSentTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pSentTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgVersion( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pulVersion = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgArrivedTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pArrivedTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDelivery( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal != MQMSG_DELIVERY_EXPRESS) &&
            (pVar->bVal != MQMSG_DELIVERY_RECOVERABLE))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pDelivery = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAck( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if(!MQMSG_ACKNOWLEDGMENT_IS_VALID(pVar->bVal))
        {
            //
            // Unknown ACK bits are on.
            //
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pAcknowledge = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgJoural( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_JOURNAL_NONE | MQMSG_DEADLETTER | MQMSG_JOURNAL))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pAuditing = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAppSpec( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PTB->old.pApplicationTag = &pVar->ulVal;

    return (MQ_OK);
}


static HRESULT ParseMsgBody( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppBody = &pVar->caub.pElems;
    PTB->old.ulBodyBufferSizeInBytes = pVar->caub.cElems;
    PTB->old.ulAllocBodyBufferInBytes = PTB->old.ulBodyBufferSizeInBytes;

    return (MQ_OK);
}

static HRESULT ParseMsgBodySize( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pBodySize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelSend( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    DWORD dwSize = wcslen(pVar->pwszVal) +1;
    if ( dwSize > MQ_MAX_MSG_LABEL_LEN)
    {
        return MQ_ERROR_LABEL_TOO_LONG;
    }

    PTB->old.ulTitleBufferSizeInWCHARs = dwSize;
    PTB->old.ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}


static HRESULT ParseMsgLabelReceive( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    PTB->old.ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulTitleBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    BOOL fSuccess;
    fSuccess = RTpFormatNameToQueueFormat(
                    pVar->pwszVal,
                    PTB->old.Send.pResponseQueueFormat,
                    &((PVALIDATION_CONTEXT)pvContext)->pwcsResponseStringToFree
                    );

    if(!fSuccess)
    {
        return(MQ_ERROR_ILLEGAL_FORMATNAME);
    }

    QUEUE_FORMAT_TYPE qft = PTB->old.Send.pResponseQueueFormat->GetType();
    if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
        (PTB->old.Send.pResponseQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
       )
    {
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }

    FLAGS |= VALIDATION_RESP_FORMAT_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgRespQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PTB->old.Receive.ppResponseFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulResponseFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    BOOL fSuccess;
    fSuccess = RTpFormatNameToQueueFormat(
                    pVar->pwszVal,
                    PTB->old.Send.pAdminQueueFormat,
                    &((PVALIDATION_CONTEXT)pvContext)->pwcsAdminStringToFree
                    );

    if(!fSuccess)
    {
        return(MQ_ERROR_ILLEGAL_FORMATNAME);
    }

    QUEUE_FORMAT_TYPE qft = PTB->old.Send.pAdminQueueFormat->GetType();
    if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
        (PTB->old.Send.pAdminQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
       )
    {
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }

    FLAGS |= VALIDATION_ADMIN_FORMAT_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgAdminQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PTB->old.Receive.ppAdminFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulAdminFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PTB->old.Receive.ppDestFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulDestFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PTB->old.Receive.ppOrderingFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulOrderingFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSrcMachineId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;
    PTB->old.ppSrcQMID = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgTimeToLive( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        PTB->old.ulRelativeTimeToLive = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PTB->old.pulRelativeTimeToLive = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTimeToQueue( PROPVARIANT * pVar, PVOID pvContext )
{
    if(SEND_FLAG)
    {
        PTB->old.ulAbsoluteTimeToQueue = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PTB->old.pulRelativeTimeToQueue = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTrace( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_TRACE_NONE | MQMSG_SEND_ROUTE_TO_REPORT_QUEUE))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pTrace = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKey( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSymmKeys = &pVar->caub.pElems;
    PTB->old.ulSymmKeysSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKeyLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSymmKeysSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSignature( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSignature = &pVar->caub.pElems;
    PTB->old.ulSignatureSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSignatureLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSignatureSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderId( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSenderID = &pVar->caub.pElems;
    PTB->old.uSenderIDLen = (WORD)((pVar->caub.cElems > 0xffff) ? 0xffff : pVar->caub.cElems);

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSenderIDLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->ulVal != MQMSG_SENDERID_TYPE_NONE) &&
            (pVar->ulVal != MQMSG_SENDERID_TYPE_SID))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulSenderIDType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCert( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSenderCert = &pVar->caub.pElems;
    PTB->old.ulSenderCertLen = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCertLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSenderCertLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgPrivLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case MQMSG_PRIV_LEVEL_NONE:
        case MQMSG_PRIV_LEVEL_BODY_BASE:
            break;

        case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        {
            HRESULT hr = _SupportingServerNotMSMQ1() ;
            if (FAILED(hr))
            {
                return hr ;
            }
            break;
        }

        default:
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
            break;
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulPrivLevel = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgEncryptAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case CALG_RC2:
        case CALG_RC4:
            break;

        default:
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
            break;
        }
    }

    PTB->old.pulEncryptAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    switch (pVar->ulVal)
    {
    case MQMSG_AUTH_LEVEL_NONE:
    case MQMSG_AUTH_LEVEL_ALWAYS:
    case MQMSG_AUTH_LEVEL_MSMQ10:
    case MQMSG_AUTH_LEVEL_MSMQ20:
        break;

    default:
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        break;
    }

    PTB->old.ulAuthLevel = pVar->ulVal;

    return MQ_OK;
}

static HRESULT ParseMsgHashAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.pulHashAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthenticated( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PTB->old.pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PTB->old.pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want only the m_authenticated property
    //
    *(PTB->old.pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED ;

    return (MQ_OK);
}

static HRESULT ParseMsgAuthenticatedEx( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PTB->old.pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PTB->old.pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want the m_authenticated_ex property
    //
    *(PTB->old.pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED_EX ;

    return (MQ_OK);
}

static HRESULT ParseMsgExtension( PROPVARIANT * pVar, PVOID pvContext)
{
    PTB->old.ppMsgExtension = &pVar->caub.pElems;
    PTB->old.ulMsgExtensionBufferInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgExtensionLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pMsgExtensionSize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSecurityContext( PROPVARIANT *pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    //
    // RTDEP.DLL is not running on Win64 bit platform, so the fix below is just
    // for the 64 bit compiler, not to issue a warning. 
    //

    PMQSECURITY_CONTEXT pSecCtx = (PMQSECURITY_CONTEXT)(ULONG_PTR)pVar->ulVal;

    // NULL security context is ignored...
    if (pSecCtx == NULL) {
      return MQ_INFORMATION_PROPERTY_IGNORED;
    }
    else if (pSecCtx->dwVersion != SECURITY_CONTEXT_VER)
    {
        return(MQ_ERROR_BAD_SECURITY_CONTEXT);
    }

    PSECCTX = pSecCtx;
    FLAGS |= VALIDATION_SECURITY_CONTEXT_MASK;

    return(MQ_OK);
}

static HRESULT ParseMsgConnectorType( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppConnectorType = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgBodyType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PTB->old.pulBodyType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulProvType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderName( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_LPWSTR;
    }

    PTB->old.ppwcsProvName = &pVar->pwszVal;
    return (MQ_OK);
}

static HRESULT ParseMsgProviderNameLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulAuthProvNameLenProp = &pVar->ulVal;
    PTB->old.ulProvNameLen = pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgFirstInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PTB->pbFirstInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLastInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PTB->pbLastInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    if (pVar->caub.cElems != PROPID_M_XACTID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->ppXactID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageSendValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Identifier               VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LABEL,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelSend},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TIME_TO_REACH_QUEUE,FALSE,FALSE, FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,FALSE,FALSE, FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueSend},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueSend},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_VERSION,         FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID_TYPE,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAuthLevel},
    { PROPID_M_AUTHENTICATED,   FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_HASH_ALG,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENTTIME,        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ARRIVEDTIME,     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_M_SECURITY_CONTEXT,FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSecurityContext},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                          Must
    // Property                       Allow   Must    Not     Maybe   Parsing
    // Identifier                     VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TRACE,                  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_PROV_TYPE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_FIRST_IN_XACT,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LAST_IN_XACT,           FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACTID,                 FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED_EX,       FALSE,  FALSE,  FALSE,  TRUE,   NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageReceiveValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Identifier               VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgBodySize},
    { PROPID_M_LABEL,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelReceive},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelLen},
    { PROPID_M_TIME_TO_REACH_QUEUE,FALSE,FALSE,  FALSE,  FALSE, ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,FALSE,FALSE,  FALSE,  FALSE, ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueReceive},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueLen},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueReceive},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueLen},
    { PROPID_M_VERSION,         FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgVersion},
    { PROPID_M_SENDERID,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdLen},
    { PROPID_M_SENDERID_TYPE,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticated},
    { PROPID_M_HASH_ALG,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCertLen},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSrcMachineId},
    { PROPID_M_SENTTIME,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSentTime},
    { PROPID_M_ARRIVEDTIME,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgArrivedTime},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestQueueReceive},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestQueueLen},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgExtensionLen},
    { PROPID_M_SECURITY_CONTEXT,TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                          Must
    // Property                        Allow   Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueReceive},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueLen},
    { PROPID_M_TRACE,                  TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKeyLen},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSignatureLen},
    { PROPID_M_PROV_TYPE,              TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderNameLen},
    { PROPID_M_FIRST_IN_XACT,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgFirstInXact},
    { PROPID_M_LAST_IN_XACT,           TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgLastInXact},
    { PROPID_M_XACTID,                 TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgXactId},
    { PROPID_M_AUTHENTICATED_EX,       TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticatedEx}
};

VARTYPE MessageVarTypes[] =
{
    0,
    VT_UI2,                 //PROPID_M_CLASS
    VT_VECTOR | VT_UI1,     //PROPID_M_MSGID
    VT_VECTOR | VT_UI1,     //PROPID_M_CORRELATIONID
    VT_UI1,                 //PROPID_M_PRIORITY
    VT_UI1,                 //PROPID_M_DELIVERY
    VT_UI1,                 //PROPID_M_ACKNOWLEDGE
    VT_UI1,                 //PROPID_M_JOURNAL
    VT_UI4,                 //PROPID_M_APPSPECIFIC
    VT_VECTOR | VT_UI1,     //PROPID_M_BODY
    VT_UI4,                 //PROPID_M_BODY_SIZE
    VT_LPWSTR,              //PROPID_M_LABEL
    VT_UI4,                 //PROPID_M_LABEL_LEN  // BUGBUG not implemented yet
    VT_UI4,                 //PROPID_M_TIME_TO_REACH_QUEUE
    VT_UI4,                 //PROPID_M_TIME_TO_BE_RECEIVED
    VT_LPWSTR,              //PROPID_M_RESP_QUEUE
    VT_UI4,                 //PROPID_M_RESP_QUEUE_LEN
    VT_LPWSTR,              //PROPID_M_ADMIN_QUEUE
    VT_UI4,                 //PROPID_M_ADMIN_QUEUE_LEN
    VT_UI4,                 //PROPID_M_VERSION
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDERID
    VT_UI4,                 //PROPID_M_SENDERID_LEN
    VT_UI4,                 //PROPID_M_SENDERID_TYPE
    VT_UI4,                 //PROPID_M_PRIV_LEVEL
    VT_UI4,                 //PROPID_M_AUTH_LEVEL
    VT_UI1,                 //PROPID_M_AUTHENTICATED
    VT_UI4,                 //PROPID_M_HASH_ALG
    VT_UI4,                 //PROPID_M_ENCRYPTION_ALG
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDER_CERT
    VT_UI4,                 //PROPID_M_SENDER_CERT_LEN
    VT_CLSID,               //PROPID_M_SRC_MACHINE_ID
    VT_UI4,                 //PROPID_M_SENTTIME
    VT_UI4,                 //PROPID_M_ARRIVEDTIME
    VT_LPWSTR,              //PROPID_M_DEST_QUEUE
    VT_UI4,                 //PROPID_M_DEST_QUEUE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_EXTENSION
    VT_UI4,                 //PROPID_M_EXTENSION_LEN
    VT_UI4,                 //PROPID_M_SECURITY_CONTEXT
    VT_CLSID,               //PROPID_M_CONNECTOR_TYPE
    VT_LPWSTR,              //PROPID_M_XACT_STATUS_QUEUE
    VT_UI4,                 //PROPID_M_XACT_STATUS_QUEUE_LEN
    VT_UI1,                 //PROPID_M_TRACE
    VT_UI4,                 //PROPID_M_BODY_TYPE
    VT_VECTOR | VT_UI1,     //PROPID_M_DEST_SYMM_KEY
    VT_UI4,                 //PROPID_M_DEST_SYMM_KEY_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_SIGNATURE
    VT_UI4,                 //PROPID_M_SIGNATURE_LEN
    VT_UI4,                 //PROPID_M_PROV_TYPE
    VT_LPWSTR,              //PROPID_M_PROV_NAME
    VT_UI4,                 //PROPID_M_PROV_NAME_LEN
    VT_UI1,                 //PROPID_M_FIRST_IN_XACT
    VT_UI1,                 //PROPID_M_LAST_IN_XACT
    VT_UI1|VT_VECTOR,       //PROPID_M_XACTID
    VT_UI1                  //PROPID_M_AUTHENTICATED_EX
};

#ifdef _DEBUG
//
// the following are complie time asserts, to verify the arrays size are
// correct and arrays include all properties.
//
#define _EXPECTEDSIZE  (PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1)
#define _SENDSIZE  (sizeof(MessageSendValidation) / sizeof(propValidity))
#define _RCVSIZE   (sizeof(MessageReceiveValidation) / sizeof(propValidity))
#define _VARSIZE   (sizeof(MessageVarTypes) / sizeof(VARTYPE))

static int MyAssert1[ _SENDSIZE == _EXPECTEDSIZE ] ;
static int MyAssert2[ _RCVSIZE  == _EXPECTEDSIZE ] ;
static int MyAssert3[ _VARSIZE  == _EXPECTEDSIZE ] ;

#undef _SENDSIZE
#undef _EXPECTEDSIZE
#undef _RCVSIZE
#undef _VARSIZE

#endif // _DEBUG

static DWORD g_dwNumberOfMustPropsInSend = 0xffff;
static DWORD g_dwNumberOfMustPropsInReceive = 0xffff;

HRESULT
RTpParseMessageProperties(
    LONG op,
    CACTransferBufferV2* ptb,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    OUT LPWSTR* ppwcsResponseStringToFree,
    OUT LPWSTR* ppwcsAdminStringToFree
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;


    ASSERT((op == SEND_PARSE) || (op == RECV_PARSE));

    if (op == SEND_PARSE)
    {
        *ppSecCtx = NULL;
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = 0;
    ValidationContext.pwcsResponseStringToFree = 0;
    ValidationContext.pwcsAdminStringToFree = 0;
    ValidationContext.ptb = ptb;

    if (op == SEND_PARSE)
    {
        ppropValidity = MessageSendValidation;
        if (g_dwNumberOfMustPropsInSend == 0xffff)
        {
            g_dwNumberOfMustPropsInSend =
                CalNumberOfMust( MessageSendValidation,
                                 PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSend;
        ValidationContext.dwFlags |= VALIDATION_SEND_FLAG_MASK;

        ptb->old.ulRelativeTimeToLive  = INFINITE ;
        ptb->old.ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
    }
    else
    {
        ppropValidity = MessageReceiveValidation;
        if (g_dwNumberOfMustPropsInReceive == 0xffff)
        {
            g_dwNumberOfMustPropsInReceive =
                CalNumberOfMust( MessageReceiveValidation,
                                 PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInReceive;
    }

    __try
    {
        if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
        {
            return MQ_ERROR_INVALID_PARAMETER;
        }

        hr = CheckProps(cProp,
                        pPropid,
                        pVar,
                        pStatus,
                        PROPID_M_BASE,
                        PROPID_M_AUTHENTICATED_EX,
                        ppropValidity,
                        MessageVarTypes,
                        TRUE,
                        dwNumberOfMustProps,
                        &ValidationContext);

        if (SUCCEEDED(hr))
        {
            //
            //  Special handling for body size and security properties
            //
            if (op == SEND_PARSE)
            {
                ASSERT(ppwcsResponseStringToFree);
                *ppwcsResponseStringToFree = ValidationContext.pwcsResponseStringToFree;
                ASSERT(ppwcsAdminStringToFree);
                *ppwcsAdminStringToFree = ValidationContext.pwcsAdminStringToFree;

                //
                // Special handling for class. If the calss is specified on send the
                // Connector type property is mandatory.
                //
                if ((ptb->old.pClass ||  ptb->old.ppSenderID || ptb->old.ppSymmKeys || ptb->old.ppSignature || ptb->old.ppwcsProvName) &&
                    !ptb->old.ppConnectorType)
                {
                    return MQ_ERROR_MISSING_CONNECTOR_TYPE;
                }

                if ((ptb->old.ppwcsProvName && !ptb->old.pulProvType) ||
                    (!ptb->old.ppwcsProvName && ptb->old.pulProvType))
                {
                    return MQ_ERROR_INSUFFICIENT_PROPERTIES;
                }
                //
                // If TimeToQueue is greater then TimeToLive then decrement
                // it to equal TimeToLive.
                //
                if ((ptb->old.ulAbsoluteTimeToQueue == INFINITE) ||
                   (ptb->old.ulAbsoluteTimeToQueue == LONG_LIVED))
                {
                  ptb->old.ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
                }

                if (ptb->old.ulRelativeTimeToLive != INFINITE)
                {
                  if (ptb->old.ulAbsoluteTimeToQueue > ptb->old.ulRelativeTimeToLive)
                  {
                     ptb->old.ulAbsoluteTimeToQueue = ptb->old.ulRelativeTimeToLive ;
                     ptb->old.ulRelativeTimeToLive = 0 ;
                  }
                  else
                  {
                     ptb->old.ulRelativeTimeToLive -= ptb->old.ulAbsoluteTimeToQueue ;
                  }
                }

                //
                // Conver TimeToQueue, which was relative until now,
                // to absolute
                //
                ULONG utime = MqSysTime() ;
                if (utime > (ptb->old.ulAbsoluteTimeToQueue + utime))
                {
                  //
                  // overflow. timeout too long.
                  //
                  ASSERT(INFINITE == 0xffffffff) ;
                  ASSERT(LONG_LIVED == 0xfffffffe) ;

                  ptb->old.ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
                }
                else
                {
                  ptb->old.ulAbsoluteTimeToQueue += utime ;
                }

                if (ValidationContext.dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)
                {
                  *ppSecCtx = ValidationContext.pSecCtx;
                }

                if (! (ValidationContext.dwFlags & VALIDATION_RESP_FORMAT_MASK))
                {
                   ptb->old.Send.pResponseQueueFormat = 0;
                }
                if (! (ValidationContext.dwFlags & VALIDATION_ADMIN_FORMAT_MASK))
                {
                   ptb->old.Send.pAdminQueueFormat = 0;
                }

            }
            else if (op == RECV_PARSE)
            {
                if(ptb->old.Receive.ppResponseFormatName)
                {
                    if(!ptb->old.Receive.pulResponseFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulResponseFormatNameLen = min(
                            *ptb->old.Receive.pulResponseFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppAdminFormatName)
                {
                    if(!ptb->old.Receive.pulAdminFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulAdminFormatNameLen = min(
                            *ptb->old.Receive.pulAdminFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppDestFormatName)
                {
                    if(!ptb->old.Receive.pulDestFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulDestFormatNameLen = min(
                            *ptb->old.Receive.pulDestFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppOrderingFormatName)
                {
                    if(!ptb->old.Receive.pulOrderingFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulOrderingFormatNameLen = min(
                            *ptb->old.Receive.pulOrderingFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.ppTitle)
                {
                    if(!ptb->old.pulTitleBufferSizeInWCHARs)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else IF_USING_RPC
                    {
                        //
                        //  so title is allocated a buffer in
                        //  server. confine buffer size to our known limit.
                        //
                        ptb->old.ulTitleBufferSizeInWCHARs  = min(
                            *ptb->old.pulTitleBufferSizeInWCHARs,
                            MQ_MAX_MSG_LABEL_LEN
                            );
                    }
                }

                //
                // in case the provider name is required, the provider name
                // len property is a must.
                //
                if (ptb->old.ppwcsProvName)
                {
                    if (!ptb->old.pulAuthProvNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing message properties.");
        hr = GetExceptionCode();
    }

    return(hr);
}

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_QM_BASE
//

propValidity    GetQMValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_SITE_ID,        TRUE,   FALSE,  FALSE,  FALSE,  qmSiteIdValidation},
    { PROPID_QM_MACHINE_ID,     TRUE,   FALSE,  FALSE,  FALSE,  qmMachineIdValidation},
    { PROPID_QM_PATHNAME,       TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_CONNECTION,     TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_ENCRYPTION_PK,  TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ADDRESS,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CNS,            TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS,         TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MASTERID,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_HASHKEY,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SEQNUM,         TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_QUOTA,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_JOURNAL_QUOTA,  TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MACHINE_TYPE,   TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CREATE_TIME,    TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MODIFY_TIME,    TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FOREIGN,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OS,             TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FULL_PATH,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SITE_IDS,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS_DN,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS_DN,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_NT4ID,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_DONOTHING,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},

    //                                                 Must
    // Property                        Allow   Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------

    { PROPID_QM_SERVICE_ROUTING,        TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DSSERVER,       TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DEPCLIENTS,     TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OLDSERVICE,             TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_BASE,     TRUE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_ENHANCED, TRUE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_PATHNAME_DNS,           TRUE,  FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE GetQMVarTypes[] =
{
    0,
    VT_CLSID,               //PROPID_QM_SITE_ID
    VT_CLSID,               //PROPID_QM_MACHINE_ID
    VT_NULL,                //PROPID_QM_PATHNAME
    VT_NULL,                //PROPID_QM_CONNECTION
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK
    VT_BLOB,                //PROPID_QM_ADDRESS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_CNS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_OUTFRS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_INFRS
    VT_UI4,                 //PROPID_QM_SERVICE
    VT_CLSID,               //PROPID_QM_MASTERID
    VT_UI4,                 //PROPID_QM_HASHKEY
    VT_BLOB,                //PROPID_QM_SEQNUM
    VT_UI4,                 //PROPID_QM_QUOTA
    VT_UI4,                 //PROPID_QM_JOURNAL_QUOTA
    VT_LPWSTR,              //PROPID_QM_MACHINE_TYPE
    VT_I4,                  //PROPID_QM_CREATE_TIME
    VT_I4,                  //PROPID_QM_MODIFY_TIME
    VT_UI1,                 //PROPID_QM_FOREIGN
    VT_UI4,                 //PROPID_QM_OS
    VT_LPWSTR,              //PROPID_QM_FULL_PATH
    VT_CLSID|VT_VECTOR,     //PROPID_QM_SITE_IDS
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_OUTFRS_DN
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_INFRS_DN
    VT_CLSID,               //PROPID_QM_NT4ID
    VT_UI1,                 //PROPID_QM_DONOTHING
    VT_UI1,                 //PROPID_QM_SERVICE_ROUTING
    VT_UI1,                 //PROPID_QM_SERVICE_DSSERVER
    VT_UI1,                 //PROPID_QM_SERVICE_DEPCLIENTS
    VT_UI4,                 //PROPID_QM_OLDSERVICE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_BASE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_ENHANCED
    VT_NULL                 //PROPID_QM_PATHNAME_DNS
};


HRESULT
RTpCheckQMProps(
    IN      MQQMPROPS * pQMProps,
    IN OUT  HRESULT*    aStatus,
    OUT     MQQMPROPS** ppGoodQMP,
    OUT     char**      ppTmpBuff)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pQMProps == NULL) ||
             (pQMProps->cProp == 0))
        {
            return(MQ_ERROR_ILLEGAL_MQQMPROPS);
        }

        hr = CheckProps(pQMProps->cProp,
                        pQMProps->aPropID,
                        pQMProps->aPropVar,
                        aStatus,
                        PROPID_QM_BASE,
                        LAST_QM_PROPID,
                        GetQMValidation,
                        GetQMVarTypes,
                        TRUE,
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing MQQMPROPS structure");
        hr = GetExceptionCode();
    }

    if (SUCCEEDED(hr))
    {
        if (hr != MQ_OK)
        {
            // We have wornings, copy all the good properties to a temporary
            // buffer so the DS will not have to handle duplicate properties etc.
            RemovePropWarnings(
                (MQQUEUEPROPS*)pQMProps,
                aStatus,
                (MQQUEUEPROPS**)ppGoodQMP,
                ppTmpBuff);
        }
        else
        {
            // All is perfectly well, we do not need a temporary buffer and all
            // that overhead.
            *ppGoodQMP = pQMProps;
        }
    }

    return(hr);

}


HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction)
{
    HRESULT hr = MQ_OK;

    if ( pRestriction == NULL)
    {
        return(MQ_OK);
    }

    __try
    {

        MQPROPERTYRESTRICTION * pPropRestriction = pRestriction->paPropRes;
        for ( DWORD i = 0; i < pRestriction->cRes; i++, pPropRestriction++)
        {
            if (( pPropRestriction->prop > PROPID_Q_PATHNAME_DNS) || ( pPropRestriction->prop <= PROPID_Q_BASE ))
            {
                return( MQ_ERROR_ILLEGAL_RESTRICTION_PROPID);
            }
            switch ( pPropRestriction->prop)
            {
                case PROPID_Q_LABEL:
                    hr = qLabelValidation( &pPropRestriction->prval, NULL);
                    break;
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in restriction
                    //
                    hr =  MQ_ERROR_ILLEGAL_RESTRICTION_PROPID;
                    break;
                default:
                    break;
            }
            if (FAILED(hr))
            {
                break;
            }

            //
            // SP4- bug# 3009, SP4SS: exception on server when call MQlocatebegin
            // Fix: validate Restriction VT.
            //                      Uri Habusha, 17-Jun-98
            //
            DWORD Index = pPropRestriction->prop - PROPID_Q_BASE;
            if (pPropRestriction->prval.vt != QueueVarTypes[Index])
            {
                hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
                break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing restriction structure");
        hr = GetExceptionCode();
    }

    return(hr);
}

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort)
{
    HRESULT hr = MQ_OK;

    if ( pSort == NULL)
    {
        return(MQ_OK);
    }


    __try
    {

        MQSORTKEY * pSortKey = pSort->aCol;
        for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
        {
            if (( pSortKey->propColumn > PROPID_Q_PATHNAME_DNS) || ( pSortKey->propColumn <= PROPID_Q_BASE ))
            {
                return( MQ_ERROR_ILLEGAL_SORT_PROPID);
            }
            switch ( pSortKey->propColumn)
            {
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in sort
                    //
                    return(MQ_ERROR_ILLEGAL_SORT_PROPID);
                    break;
                default:
                    break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing sort structure");
        hr = GetExceptionCode();
    }

    return(hr);
}

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	)
{
	//
	//	validate that the aPropVar buffer supplied by the
	//	user match the size it had specified
	//
	HRESULT hr = MQ_OK;
    __try
    {
        if(IsBadWritePtr(aPropVar, cPropsRead * sizeof(PROPVARIANT)))
        {
            return MQ_ERROR_INVALID_PARAMETER;
        }
	}
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while Locate Next parameters.");
        hr = MQ_ERROR_INVALID_PARAMETER;
    }
	return hr;

}

//
//  The offset of property in this array must be equal to
//  PROPID value - starting with  FIRST_PRIVATE_COMPUTER_PROPID
//

propValidity    GetPrivateComputerValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_PC_VERSION,        TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_PC_DS_ENABLED,     TRUE,   FALSE,  FALSE,  FALSE,  NULL},
};

VARTYPE GetPrivateComputerVarTypes[] =
{
    0,
    VT_UI4,                 //PROPID_PC_VERSION
    VT_BOOL,                //PROPID_PC_DS_ENABLED
};


//---------------------------------------------------------
//
//  RTpCheckComputerProps(...)
//
//  Description:
//
//  validates pLocalProps parameter values
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pPrivateProps == NULL) ||
             (pPrivateProps->cProp == 0))
        {
            return(MQ_ERROR_ILLEGAL_MQPRIVATEPROPS);
        }

        hr = CheckProps(pPrivateProps->cProp,
                        pPrivateProps->aPropID,
                        pPrivateProps->aPropVar,
                        aStatus,
                        FIRST_PRIVATE_COMPUTER_PROPID,
                        LAST_PRIVATE_COMPUTER_PROPID,
                        GetPrivateComputerValidation,
                        GetPrivateComputerVarTypes,
                        TRUE,	// fCheckForIgnoredProps
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrERROR(GENERAL, "Exception while parsing MQPRIVATEPROPS structure");
        hr = GetExceptionCode();
    }

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtcert.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcert.h

Abstract:

    MQ internal certificate store management.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include "stdh.h"
#include <ad.h>
#include <mqutil.h>
#include <_secutil.h>
//#include <rtintrnl.h>
#include <mqcert.h>
#include <rtdepcert.h>

#include "rtcert.tmh"

static WCHAR *s_FN=L"rtdep/rtcert";

#ifdef _DEBUG
#define REPORT_CERT_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CERT_ERROR
#endif

/*************************************************************************
*
*  Function:  DepOpenInternalCertStore()
*
*  Parameters
*      BOOL fWriteAccess - TRUE if caller want write access, i.e.,
*                   if user want to add a certificate to the store.
*
*  Descruption: Get a handle to the certificate store which contain
*               the internal certificates.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepOpenInternalCertStore( OUT CMQSigCertStore **ppStore,
                          IN  LONG            *pnCerts,
                          IN  BOOL            fWriteAccess,
                          IN  BOOL            fMachine,
                          IN  HKEY            hKeyUser )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    struct MQSigOpenCertParams OpenParams ;
    memset(&OpenParams, 0, sizeof(OpenParams)) ;
    OpenParams.bCreate = !!fWriteAccess ;
    OpenParams.bWriteAccess = !!fWriteAccess ;
    OpenParams.bMachineStore = !!fMachine ;
    OpenParams.hCurrentUser = hKeyUser ;

    HRESULT hr = MQSigOpenUserCertStore( ppStore,
                                         MQ_INTERNAL_CERT_STORE_REG,
                                        &OpenParams ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (pnCerts)
    {
        HCERTSTORE hStore = (*ppStore)->GetHandle() ;
        //
        // count the number of certificates in store.
        //
        *pnCerts = 0 ;

        PCCERT_CONTEXT pCertContext;
        PCCERT_CONTEXT pPrevCertContext;

        pCertContext = CertEnumCertificatesInStore(hStore, NULL);
        while (pCertContext)
        {
            pPrevCertContext = pCertContext,

            (*pnCerts)++ ;
            pCertContext = CertEnumCertificatesInStore( hStore,
                                                        pPrevCertContext ) ;
        }

        ASSERT(!pCertContext) ;
        ASSERT((*pnCerts == 0) || (*pnCerts == 1)) ;
    }

    TrTRACE(SECURITY, "rtcert: DepOpenInternalCertStore successful");

    return MQ_OK ;
}

/*************************************************************************
*
*  Function:
*    DepGetInternalCert
*
*  Parameters -
*    ppCert - On return, pointer to The certificate object.
*
*  Return value-
*    MQ_OK if successful, else an error code.
*
*  Comments -
*    Returns the internal certificate. The function fails if the
*    certificate does not exist.
*
*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    LONG nCerts = 0 ;

    *ppCert = NULL ;
    *ppStore = NULL ;

    HRESULT hr = DepOpenInternalCertStore( ppStore,
                                          &nCerts,
                                          fGetForDelete,
                                          fMachine,
                                          hKeyUser ) ;
    if (FAILED(hr) || (nCerts == 0))
    {
        return MQ_ERROR_NO_INTERNAL_USER_CERT;
    }

    PCCERT_CONTEXT pCertContext =
                CertEnumCertificatesInStore((*ppStore)->GetHandle(), NULL);

    if (!pCertContext)
    {
        return MQ_ERROR_NO_INTERNAL_USER_CERT;
    }

    hr = MQSigCreateCertificate( ppCert, pCertContext) ;

    return hr ;
}

/*************************************************************************

  Function:
    DepRegisterUserCert

  Parameters -
    pCert - The certificate object.

  Return value-
    S_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepRegisterUserCert(
	IN CMQSigCertificate *pCert,
    IN BOOL fMachine
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pCert) ;

    PROPID propIDU[] = {PROPID_U_ID, PROPID_U_SIGN_CERT, PROPID_U_DIGEST};
    PROPID propIDCom[] = {PROPID_COM_ID, PROPID_COM_SIGN_CERT, PROPID_COM_DIGEST};
    DWORD dwArraySize = sizeof(propIDU) / sizeof(propIDU[0]) ;

    PROPID *pPropIDs = propIDU ;
    if (fMachine)
    {
        pPropIDs = propIDCom ;
    }

    PROPVARIANT propVar[3];
    GUID guidCert;

    propVar[0].vt = VT_CLSID;
    propVar[0].puuid = &guidCert;
    UuidCreate(&guidCert);

    propVar[1].vt = VT_BLOB;

    DWORD dwCertSize = 0 ;
    BYTE  *pBuf = NULL ;

    HRESULT hr = pCert->GetCertBlob(&pBuf, &dwCertSize) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    propVar[1].blob.cbSize =  dwCertSize ;
    propVar[1].blob.pBlobData  = pBuf ;

    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    propVar[2].vt = VT_CLSID;
    propVar[2].puuid = &guidHash;

    switch (hr = ADCreateObject( 
						eUSER,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						NULL,
						NULL,
						dwArraySize,
						pPropIDs,
						propVar,
						NULL 
						))
    {
        case MQDS_CREATE_ERROR:
            hr = MQ_ERROR_INTERNAL_USER_CERT_EXIST;
            break;

        case MQ_OK:
            hr = MQ_OK;
            break;
    }

    return LogHR(hr, s_FN, 70) ;
}


/*************************************************************************

  Function:
    DepGetUserCerts

  Parameters -
    ppCert - A pointer to an array that receives the ponters to the user's
        certificates.
    pnCerts - A pointer to a buffer that points to the number of entries in
        pp509. Upon return, the buffer contains the number of certificates
        that the user has.
    pSidIn - An optiona lparameter that points to a user SID. If this
        parameter equals NULL, the certificates for the user of the current
        thread are retrieved.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the array in pp509 is too small, it is being filled up until there
    is no more place in it. All certificates should be released in any
    case. If upon return pnCerts points to a value that is greater than
    the value when entering the function, it means that pp509 is too
    small.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepGetUserCerts(
	CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    AP<BYTE> pUserSid;
    DWORD dwSidLen;
    PSID pSid;
    DWORD nCertsIn = *pnCerts;

    if (pSidIn)
    {
        pSid = pSidIn;
        dwSidLen = GetLengthSid(pSid);
    }
    else
    {
        //
        // Local users are not let in.
        //
        BOOL fLocalUser;
        BOOL fLocalSystem;

        hr = RTpGetThreadUserSid( &fLocalUser,
                                  &fLocalSystem,
                                  &pUserSid,
                                  &dwSidLen );
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 80) ;
        }

        if (fLocalUser)
        {
            return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90) ;
        }

        pSid = pUserSid.get();
    }

    MQCOLUMNSET Cols;
    PROPID ColId = PROPID_U_SIGN_CERT;
    HANDLE hEnum;

    Cols.cCol = 1;
    Cols.aCol = &ColId;

    BLOB blobUserSid;
    blobUserSid.cbSize = dwSidLen;
    blobUserSid.pBlobData = (BYTE *)pSid;

    hr = ADQueryUserCert(
                NULL,       // pwcsDomainController,
				false,		// fServerName
                &blobUserSid,
                &Cols,
                &hEnum
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100) ;
    }

    DWORD nCerts = 0 ;

    while (1)
    {
        DWORD cProps = 1;
        PROPVARIANT propVar;

        propVar.vt = VT_NULL;
        hr = ADQueryResults(hEnum, &cProps, &propVar);
        if (FAILED(hr) || !cProps)
        {
            break;
        }

        if (nCerts < nCertsIn)
        {
            CMQSigCertificate *pSigCert = NULL ;
            HRESULT hr = MQSigCreateCertificate( &pSigCert,
                                                 NULL,
                                                 propVar.blob.pBlobData,
                                                 propVar.blob.cbSize ) ;
            if (SUCCEEDED(hr))
            {
                ppCert[ nCerts ] = pSigCert ;
                nCerts++;
            }
        }
        else
        {
            nCerts++;
        }

        DepFreeMemory(propVar.blob.pBlobData);
    }

    ADEndQuery(hEnum);

    *pnCerts = nCerts;

    return LogHR(hr, s_FN, 110) ;
}

/*************************************************************************

  Function:
    DepRemoveUserCert

  Parameters -
    p509 - A pointer to the certificate that should be removed from the DS.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepRemoveUserCert(
	IN CMQSigCertificate *pCert
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }

    hr = ADDeleteObjectGuid(
                eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &guidHash
                );
    return LogHR(hr, s_FN, 130) ;
}

/*************************************************************************

  Function:
    GetCertInfo

  Parameters -
    ppbCert - A pointer to a pointer to a buffer that holds the cert bits.
    dwCertLen - A pointer to the length of *ppbCert.
    phProv - A pointer to a buffer that receives the handle to the cert CSP.
    wszProvName - A pointer to a buffer that receives a pointer to the name
        of the cert CSP.
    pdwProvType - A poinrter to a buffer the receives the type of the cert CSP.
    pbDefProv - A pointer to a buffer that reveices TRUE, if the cert CSP is
        the default CSP, else FALSE.
    pbInternalCert - A pointer to a buffer that receives TRUE, if the cert
        is an internl MSMQ cert, else FALSE.

  Return value-
    MQ_OK if successful, else error code.

  Comments -
    The function receives a buffer that contains the bits of some
    certificate and returns various information about the certificate.

*************************************************************************/

HRESULT
GetCertInfo( IN     BOOL        fUseCurrentUser,
             IN     BOOL        fMachine,
             IN OUT BYTE      **ppbCert,
             OUT    DWORD      *pdwCertLen,
             OUT    HCRYPTPROV *phProv,
             OUT    LPWSTR     *wszProvName,
             OUT    DWORD      *pdwProvType,
             OUT    BOOL       *pbDefProv,
             OUT    BOOL       *pbInternalCert )
{
    HRESULT hr;

    //
    // Note: it's important that pStore be defined before
    //       pCert, so it will be the last one to be released.
    //
    R<CMQSigCertStore>   pStore ;
    R<CMQSigCertificate> pCert ;

    ASSERT(ppbCert);

    *pbInternalCert = (*ppbCert == NULL) ;

    CAutoCloseRegHandle  hKeyUser (NULL) ;
    if ( fUseCurrentUser )
    {
        LONG rc = RegOpenCurrentUser( KEY_READ,
                                     &hKeyUser ) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }
    }

    if (*pbInternalCert)
    {
        //
        // We should get the information for the internal certificate.
        //
        hr = DepGetInternalCert( &pCert.ref(),
                                &pStore.ref(),
                                 FALSE, // fGetForDelete
                                 fMachine,
                                 hKeyUser ) ;
        if (FAILED(hr))
        {
            return(hr);
        }

        BYTE  *pCertBlob = NULL ;
        DWORD dwCertSize = 0 ;

        hr = pCert->GetCertBlob( &pCertBlob,
                                 &dwCertSize ) ;
        if (FAILED(hr))
        {
            return(hr);
        }

        try
        {
            //
            // We must free b.pBlobData, so do not use memory allocation
            // faliure excpetions.
            //
            *ppbCert = new BYTE[ dwCertSize ] ;
        }
        catch(const bad_alloc&)
        {
            //
            // We failed to allocate a buffer for the cert. Free the blob and
            // return an error.
            //
            *ppbCert = NULL;
            return(MQ_ERROR_INSUFFICIENT_RESOURCES);
        }

        //
        // Copy the certificate to "our" memory.
        //
        *pdwCertLen = dwCertSize ;
        memcpy(*ppbCert, pCertBlob, dwCertSize) ;

        //
        // The CSP context for the internal certificate is always of the
        // base RSA provider.
        //
        DWORD   dwMachineFlag = 0 ;
        LPWSTR lpszContainerNameW = MSMQ_INTCRT_KEY_CONTAINER_W ;

        if (fMachine)
        {
            lpszContainerNameW = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W ;
            dwMachineFlag = CRYPT_MACHINE_KEYSET ;
        }

        if (!CryptAcquireContext( phProv,
                                   lpszContainerNameW,
                                   MS_DEF_PROV,
                                   PROV_RSA_FULL,
                                   dwMachineFlag ))
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CryptAcquireContext() failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        *wszProvName = new WCHAR[sizeof(MS_DEF_PROV_A)];
        wcscpy((LPWSTR)*wszProvName, MS_DEF_PROV_W);

        *pdwProvType = PROV_RSA_FULL;
    }
    else
    {
        //
        // We have a "real" (non-internal) cetificate.
        //
        AP<WCHAR> wszKeySet;
        ASSERT(pdwCertLen && *pdwCertLen);

        CHCryptProv hProv;

        if (!CryptAcquireContext( &hProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CryptAcquireContext failed, gle = %!winerr!", gle);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        CHCertStore  hSysStore =  CertOpenSystemStore(
                                                 hProv,
                                                 x_wszPersonalSysProtocol 
                                                 );
        if (!hSysStore)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "CertOpenSystemStore failed, gle = %!winerr!", gle);
            return MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE;
        }

        BOOL fFound;
        CPCCertContext pCertContext ;

        for ( fFound = FALSE,
                pCertContext = CertEnumCertificatesInStore(hSysStore, NULL);
              pCertContext && !fFound ; )
        {
            PCCERT_CONTEXT pCtx = pCertContext ;
            fFound = (*pdwCertLen == pCtx->cbCertEncoded) &&
                     (memcmp(*ppbCert,
                              pCtx->pbCertEncoded,
                              pCtx->cbCertEncoded) == 0);
            if (!fFound)
            {
                pCertContext = CertEnumCertificatesInStore( hSysStore,
                                                            pCtx ) ;
            }
        }

        if (!pCertContext)
        {
            return (MQ_ERROR_INVALID_CERTIFICATE);
        }

        BYTE abShortCertInfo[256];
        DWORD dwCertInfoSize = sizeof(abShortCertInfo);
        AP<BYTE> pLongCertInfo = NULL;
        PBYTE pCertInfo = abShortCertInfo;

        if (!CertGetCertificateContextProperty(pCertContext,
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               pCertInfo,
                                               &dwCertInfoSize))
        {
            if (GetLastError() == ERROR_MORE_DATA)
            {
                pLongCertInfo = new BYTE[dwCertInfoSize];
                pCertInfo = pLongCertInfo.get();
                if (!CertGetCertificateContextProperty(pCertContext,
                                                       CERT_KEY_PROV_INFO_PROP_ID,
                                                       pCertInfo,
                                                       &dwCertInfoSize))
                {
                    return(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE);
                }
            }
            else
            {
                return(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE);
            }
        }

        PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pCertInfo;

        DWORD dwKeySetLen = wcslen(pKeyProvInfo->pwszContainerName);
        wszKeySet = new WCHAR[dwKeySetLen + 1];
        wcscpy(wszKeySet.get(), pKeyProvInfo->pwszContainerName);

        DWORD dwProvNameLen = wcslen(pKeyProvInfo->pwszProvName);
        *wszProvName = new WCHAR[dwProvNameLen + 1];
        wcscpy(*wszProvName, pKeyProvInfo->pwszProvName);

        *pdwProvType = pKeyProvInfo->dwProvType;

        BOOL fAcq = CryptAcquireContext( phProv,
                                         wszKeySet.get(),
                                         *wszProvName,
                                         *pdwProvType,
                                         0 ) ;

        if (!fAcq)
        {
            return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
        }
    }

    //
    // Find out whether the CSP is the default CSP.
    //
    *pbDefProv = (*pdwProvType == PROV_RSA_FULL) &&
                 (wcscmp(*wszProvName, MS_DEF_PROV_W) == 0);

#ifdef _DEBUG
    if (*pbDefProv)
    {
        static BOOL s_fAlreadyRead = FALSE ;
        static BOOL s_fMakeNonDefault = FALSE ;

        if (!s_fAlreadyRead)
        {
        	DWORD dwUseNonDef = 0 ;
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;

            LONG res = GetFalconKeyValue(
                                      USE_NON_DEFAULT_AUTHN_PROV_REGNAME,
                                     &dwType,
                                     &dwUseNonDef,
                                     &dwSize ) ;
            if ((res == ERROR_SUCCESS) && (dwUseNonDef == 1))
            {
                s_fMakeNonDefault = TRUE ;
            }
            s_fAlreadyRead = TRUE ;
        }

        if (s_fMakeNonDefault)
        {
            *pbDefProv = FALSE ;
            wcscpy(*wszProvName,
                   L"MiCrOsOfT BaSe CrYpToGrApHiC PrOvIdEr v1.0") ;
        }
    }
#endif

    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtfrebnd.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rtfrebnd.h

Abstract:
    Free binding handles

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef __FREEBIND_H
#define __FREEBIND_H

#include "cs.h"

#define  MAX_NUMOF_RPC_HANDLES   512

//---------------------------------------------------------
//
//  class CFreeRPCHandles
//
//---------------------------------------------------------

class CFreeRPCHandles
{
public:
    CFreeRPCHandles() ;

    void Add(handle_t hBind) ;
    void FreeAll() ;

private:
    CCriticalSection      m_cs;

    DWORD                 m_dwIndex ;
    handle_t              m_ahBind[ MAX_NUMOF_RPC_HANDLES ] ;
};


inline  CFreeRPCHandles::CFreeRPCHandles()
{
    m_dwIndex = 0 ;
}

inline void CFreeRPCHandles::Add(handle_t hBind)
{
    CS Lock(m_cs) ;

    ASSERT(m_dwIndex < MAX_NUMOF_RPC_HANDLES);
    if (hBind && (m_dwIndex < MAX_NUMOF_RPC_HANDLES))
    {
        m_ahBind[ m_dwIndex ] = hBind ;
        m_dwIndex++ ;
    }
}

inline void CFreeRPCHandles::FreeAll()
{
    DWORD dwIndex ;

    //
    // Use of lock:
    // The "Add" method is called from THREAD_DETACH. We don't want
    // THREAD_DETACH to be locked while this thread run in the loop below.
    // Therefore, we only get the loop count inside a lock and reset it
    // only if not changed.
    //

    {
      CS Lock(m_cs) ;
      dwIndex = m_dwIndex ;
    }

    for ( DWORD i = 0 ; i < dwIndex ; i++ )
    {
        handle_t hBind = m_ahBind[ i ] ;
        if (hBind)
        {
            mqrpcUnbindQMService( &hBind,
                                  NULL ) ;
        }

        m_ahBind[ i ] = NULL ;
    }

    {
      CS Lock(m_cs) ;
      if (dwIndex == m_dwIndex)
      {
         //
         // Index not changed by calling "Add" while this thread run in the
         // above loop.
         //
         m_dwIndex = 0 ;
      }
    }
}

#endif  //  __FREEBIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\queue.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    This module contains code involved with Queue APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include <ad.h>
#include "rtprpc.h"
#include "rtsecutl.h"
#include <mqdsdef.h>
#include "rtputl.h"

#include "queue.tmh"

static WCHAR *s_FN=L"rtdep/queue";

#define MQ_VALID_ACCESS (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS | MQ_SEND_ACCESS | MQ_ADMIN_ACCESS)

//
// Data needed for licensing
//
extern GUID   g_LicGuid ;
extern BOOL   g_fLicGuidInit ;
extern DWORD  g_dwOperatingSystem;


inline
BOOL
IsLegalDirectFormatNameOperation(
    const QUEUE_FORMAT* pQueueFormat
    )
//
// Function Description:
//      The routines checks if the queue operation is leggal with
//      the direct format name. Due "Workgroup" support, we allowed
//      direct format name for local private queue.
//
// Arguments:
//      pQueueFormat - pointer to format name object
//
// Returned value:
//      TRUE if the format name is valid, FALSE otherwise
//
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    if (pQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
        return FALSE;

    //
    // check that the direct format name is for private queue. Queue
    // locallity will be checked by the QM
    //
    LPCWSTR DirectFormatname = pQueueFormat->DirectID();
    LPWSTR pTemp = wcschr(DirectFormatname, L'\\');
    ASSERT(pTemp != NULL);
	if(pTemp == NULL)
		return FALSE;

    return (_wcsnicmp(pTemp+1,
                      PRIVATE_QUEUE_PATH_INDICATIOR,
                      PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0);

}


//
//  This function is called whenever really path name is needed.
//
//  MQDeleteQueue, MQSetQueueProperties, MQGetQueueProperties
//  MQGetQueueSecurity, MQSetQueueSecurity
//
inline BOOL IsLegalFormatNameOperation(const QUEUE_FORMAT* pQueueFormat)
{
    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_DIRECT:
            return IsLegalDirectFormatNameOperation(pQueueFormat);

        default:
            return FALSE;
    }
}


HRESULT
DeppOpenQueue( handle_t      hBind,
             QUEUE_FORMAT* pQueueFormat,
             DWORD         dwDesiredAccess,
             DWORD         dwShareMode,
             HANDLE32     hRemoteQueue,
             LPWSTR*       lplpRemoteQueueName,
             DWORD*        dwpQueue,
             DWORD*            pdwQMContext,
             RPC_QUEUE_HANDLE* phQueue,
             DWORD             dwpRemoteContext = 0)
{
   if (!g_fLicGuidInit)
   {
      //
      // bad initialization. Can't open queue without guid for license.
      //
      ASSERT(0) ;
      return MQ_ERROR ;
   }

	HANDLE hThread ;
	RegisterRpcCallForCancel( &hThread, 0 ) ;

	HRESULT hr = rpc_QMOpenQueueInternal( hBind,
	                                    pQueueFormat,
	                                    dwDesiredAccess,
	                                    dwShareMode,
	                                    (DWORD)hRemoteQueue,
	                                    lplpRemoteQueueName,
	                                    dwpQueue,
	                                    &g_LicGuid,
	                                    g_lpwcsLocalComputerName,
	                                    pdwQMContext,
	                                    phQueue,
	                                    0,	// dwProtocol
	                                    dwpRemoteContext );

	UnregisterRpcCallForCancel( hThread ) ;
	return hr ;
}


EXTERN_C
HRESULT
APIENTRY
DepOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;
    LPWSTR lpRemoteQueueName = NULL;
    LPMQWIN95_QHANDLE ph95 = NULL ;
    DWORD  dwQMContext = 0 ;

    __try
    {
        __try
        {
            if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
                (g_fDependentClient))
            {
               ph95 = new MQWIN95_QHANDLE ;
               ASSERT(ph95) ;
            }

            *phQueue = NULL ;
            INIT_RPC_HANDLE ;

            //
            // Check validity of access mode.
            // 1. Check that only legal bits are turned on.
            // 2. Check that only legal access combinations are used.
            //
            if ((dwDesiredAccess & ~MQ_VALID_ACCESS) ||
                !(dwDesiredAccess & MQ_VALID_ACCESS))

            {
               //
               // Ilegal bits are turned on.
               //
               rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
               __leave ;
            }
            else if (dwDesiredAccess != MQ_SEND_ACCESS)
            {
               if (dwDesiredAccess & MQ_SEND_ACCESS)
               {
                  //
                  // A queue can't be open for both send and receive.
                  //
                  rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
                  __leave ;
               }
            }

           if ((dwShareMode & MQ_DENY_RECEIVE_SHARE) &&
               (dwDesiredAccess & MQ_SEND_ACCESS))
           {
               //
               // not supporting SEND_ACCESS with DENY_RECEIVE.
               //
               rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
               __leave ;
            }

            QUEUE_FORMAT QueueFormat;
            DWORD  dwpRemoteQueue = 0 ;

            if (dwDesiredAccess & MQ_SEND_ACCESS)
            {
               if (!g_pSecCntx)
               {
					InitSecurityContext();					
               }
            }

            if (!RTpFormatNameToQueueFormat(
                    lpwcsFormatName,
                    &QueueFormat,
                    &pStringToFree))
            {
                rc = MQ_ERROR_ILLEGAL_FORMATNAME;
                __leave ;
            }

			if(tls_hBindRpc == 0)
				return MQ_ERROR_SERVICE_NOT_AVAILABLE;

            rc = DeppOpenQueue(
						tls_hBindRpc,
						&QueueFormat,
						dwDesiredAccess,
						dwShareMode,
						NULL,
						&lpRemoteQueueName,
						&dwpRemoteQueue,
						&dwQMContext,
						phQueue
						);

            if ((rc == MQ_OK) && lpRemoteQueueName)
            {
               *phQueue = NULL ;
               //
               // remote reader. Call remote QM.
               //
               HANDLE32 hRemoteQueue = 0 ;
               PCTX_OPENREMOTE_HANDLE_TYPE phContext = NULL ;
               DWORD  dwpContext = 0 ;
               dwpRemoteQueue = 0 ;
               rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

               CALL_REMOTE_QM(lpRemoteQueueName,
                              rc, (R_QMOpenRemoteQueue(
                                         hBind,
                                         &phContext,
                                         &dwpContext,
                                         &QueueFormat,
                                         0,
                                         dwDesiredAccess,
                                         dwShareMode,
                                         &g_LicGuid,
                                         g_dwOperatingSystem,
                                         &dwpRemoteQueue,
                                         (DWORD*)&hRemoteQueue)) ) ;

               // Now open a local queue which will point to the
               // remote one.
               //
               if (rc == MQ_OK)
               {
                  ASSERT(dwpRemoteQueue) ;
                  ASSERT(hRemoteQueue) ;
                  ASSERT(dwpContext) ;

                  ASSERT(tls_hBindRpc) ;
                  rc = DeppOpenQueue( tls_hBindRpc,
                                    &QueueFormat,
                                    dwDesiredAccess,
                                    dwShareMode,
                                    hRemoteQueue,
                                    NULL,
                                    &dwpRemoteQueue,
                                    &dwQMContext,
                                    phQueue,
                                    dwpContext );

                  R_QMCloseRemoteQueueContext( &phContext ) ;
               }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] lpRemoteQueueName;
        delete[] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        ASSERT(*phQueue) ;

        if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
            (g_fDependentClient))
        {
           //
           //  Get a new binding handle for receive operations
           //  This enables rpc rundown to be called on the context handle
           //  since a different binding handles is used in receive
           //
           ph95->hBind = RTpGetQMServiceBind(TRUE);
           ph95->hContext = *phQueue ;
           ph95->hQMContext = dwQMContext ;
           ASSERT(ph95->hQMContext) ;

           *phQueue = (HANDLE) ph95 ;
        }
    }
    else
    {
        ASSERT(!(*phQueue)) ;

        if (ph95)
        {
           delete ph95 ;
        }
    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {

            INIT_RPC_HANDLE ;

            QUEUE_FORMAT QueueFormat;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 70);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 80);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;
                    
					rc = R_QMDeleteObject( tls_hBindRpc,
                                         &ObjectFormat);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADDeleteObjectGuid(
                        eQUEUE,
						MachineDomain(),      // pwcsDomainCOntroller
						false,	    // fServerName
                        &QueueFormat.PublicID()
                        );
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90);

            if(SUCCEEDED(rc)) {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 100);
}

EXTERN_C
HRESULT
APIENTRY
DepCloseQueue(
    IN QUEUEHANDLE hQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    //
    // do not add try except here
    // The API is implemented by NtClose() which returns an
    // error on invalid handle (we return MQ_ERROR_INVALID_HANDLE)
    // and throws exception on purpose when running under a debugger to help
    // find errors at development time.
    //
    return (RTpConvertToMQCode(ACDepCloseHandle(hQueue)));
}


EXTERN_C
HRESULT
APIENTRY
DepCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pqp,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    LPWSTR lpwcsPathName;
    LPWSTR pStringToFree = NULL;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    char *pTmpQPBuff = NULL;

    __try
    {
        __try
        {
            //
            // check that output parameters are writeable before creating the Queue
            // we check lpwcsFormatName and lpdwFormatNameLength
            // pqp is refered before the creation and handled by the try except
            //
            if (IsBadWritePtr(lpdwFormatNameLength,sizeof(DWORD)) ||
                IsBadWritePtr(lpwcsFormatName, (*lpdwFormatNameLength) * sizeof(WCHAR)))
            {
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
            }

            INIT_RPC_HANDLE ;

            // Serialize the security descriptor.
            rc = RTpMakeSelfRelativeSDAndGetSize(
                &pSecurityDescriptor,
                &pSelfRelativeSecurityDescriptor,
                NULL);
            if (!SUCCEEDED(rc))
            {
                return LogHR(rc, s_FN, 130);
            }

            lpwcsPathName = RTpGetQueuePathNamePropVar(pqp);
            if(lpwcsPathName == 0)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
            }

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE QueuePathType;
            QueuePathType = RTpValidateAndExpandQueuePath(
                                lpwcsPathName,
                                &lpwcsExpandedPathName,
                                &pStringToFree
                                );

            MQQUEUEPROPS *pGoodQP;

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_CREATE,
                                     QueuePathType == PRIVATE_QUEUE_PATH_TYPE,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 150);
            }

            switch (QueuePathType)
            {
            case PRIVATE_QUEUE_PATH_TYPE:
                rc = DeppCreateObject(MQQM_QUEUE,
                                    lpwcsExpandedPathName,
                                    pSecurityDescriptor,
                                    pGoodQP->cProp,
                                    pGoodQP->aPropID,
                                    pGoodQP->aPropVar);

                if (SUCCEEDED(rc))
                {
                    rc = DepPathNameToFormatName(lpwcsExpandedPathName,
                                                lpwcsFormatName,
                                                lpdwFormatNameLength);

                }
                break;

            case PUBLIC_QUEUE_PATH_TYPE:

                {
                    GUID QGuid;

                    rc = ADCreateObject(
								eQUEUE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,	    // fServerName
								lpwcsExpandedPathName,
								pSecurityDescriptor,
								pGoodQP->cProp,
								pGoodQP->aPropID,
								pGoodQP->aPropVar,
								&QGuid
								);

                   if (SUCCEEDED(rc))
                    {
                        rc = DepInstanceToFormatName(&QGuid,
                                                    lpwcsFormatName,
                                                    lpdwFormatNameLength);

                    }
                }
                break;

            default:
                rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                break;

            }
            if ( rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
            {
                //
                //  Change into information status ( queue
                //  creation succeeded
                //
                rc = MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL;
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 160);
            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the extended path name and the serialized security descriptor.
        delete[] pStringToFree;
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete[] pTmpQPBuff;

    }

    if (SUCCEEDED(rc) && ((ULONG)(rc) >> 30 != 1)) // no warnning
    {
        return LogHR(rc1, s_FN, 170);
    }
    return LogHR(rc, s_FN, 180);
}


EXTERN_C
HRESULT
APIENTRY
DepLocateBegin(
    IN  LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        if  ( lpwcsContext != NULL)
        {
            return LogHR(MQ_ERROR_ILLEGAL_CONTEXT, s_FN, 190);
        }

        rc = RTpCheckColumnsParameter(pColumns);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 200);
        }

        // If the application passes a valid pointer to a MQRESTRICTION
        // structure with zero rescritctions, pass a null restrictios pointer
        // to the DS, this makes the DS's life much easier.
        if (pRestriction && !pRestriction->cRes)
        {
            pRestriction = NULL;
        }

        rc = RTpCheckRestrictionParameter(pRestriction);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }

        rc = RTpCheckSortParameter( pSort);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 220);
        }

        rc = ADQueryQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pRestriction,
                pColumns,
                pSort,
                phEnum
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 230);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    return LogHR(rc, s_FN, 240);
}


EXTERN_C
HRESULT
APIENTRY
DepLocateNext(
    IN HANDLE hEnum,
    OUT DWORD *pcPropsRead,
    OUT PROPVARIANT aPropVar[]
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
		rc = RTpCheckLocateNextParameter(
				*pcPropsRead,
				aPropVar);
		if( FAILED(rc))
		{
			return LogHR(rc, s_FN, 250);
		}

        rc = ADQueryResults(
                          hEnum,
                          pcPropsRead,
                          aPropVar);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 260);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    // If failed, zero the numer of props.
    if (FAILED(rc))
    {
        __try
        {
            *pcPropsRead = 0;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // Do not modify the original error code.
        }
    }

    return LogHR(rc, s_FN, 270);
}

EXTERN_C
HRESULT
APIENTRY
DepLocateEnd(
    IN HANDLE hEnum
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {

        rc = ADEndQuery(hEnum);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 280);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 290);
}

EXTERN_C
HRESULT
APIENTRY
DepSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 300);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 310);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_SET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 320);
            }


            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

					rc = R_QMSetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADSetObjectPropertiesGuid(
							eQUEUE,
							MachineDomain(),      // pwcsDomainCOntroller
							false,		// fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 330);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;

    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 340);
    }
    return LogHR(rc, s_FN, 350);
}


EXTERN_C
HRESULT
APIENTRY
DepGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 360);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 370);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_GET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 380);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = R_QMGetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:

                rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							MachineDomain(),      // pwcsDomainCOntroller
							false,	   // fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }

            // Here we have out queue properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            if (SUCCEEDED(rc) && (pqp != pGoodQP))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQP->cProp; i++, j++)
                {
                    while(pqp->aPropID[j] != pGoodQP->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pqp->cProp);
                    }
                    pqp->aPropVar[j] = pGoodQP->aPropVar[i];
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 390);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 400);
    }
    return LogHR(rc, s_FN, 410);
}

EXTERN_C
HRESULT
APIENTRY
DepGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 420);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 430);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = R_QMGetObjectSecurity(tls_hBindRpc,
                                             &ObjectFormat,
                                             RequestedInformation,
                                             pSecurityDescriptor,
                                             nLength,
                                             lpnLengthNeeded);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    MQPROPVARIANT var = {{VT_NULL, 0,0,0,0}};

                    rc = ADGetObjectSecurityGuid(
                            eQUEUE,
							MachineDomain(),      // pwcsDomainCOntroller
							false,	    // fServerName
                            &QueueFormat.PublicID(),
                            RequestedInformation,
                            PROPID_Q_SECURITY,
                            &var
                            );
                    if (FAILED(rc))
                    {
                        break;
                    }

                    ASSERT( var.vt == VT_BLOB);
                    if ( var.blob.cbSize <= nLength )
                    {
                        //
                        //  Copy the buffer
                        //
                        memcpy(pSecurityDescriptor, var.blob.pBlobData, var.blob.cbSize);
                    }
                    else
                    {
                        rc = MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
                    }
                    delete [] var.blob.pBlobData;
                    *lpnLengthNeeded = var.blob.cbSize;

                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 440);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 450);
}

EXTERN_C
HRESULT
APIENTRY
DepSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    LPWSTR pStringToFree = NULL;


    __try
    {

        // Serialize the security descriptor.
        rc = RTpMakeSelfRelativeSDAndGetSize(
            &pSecurityDescriptor,
            &pSelfRelativeSecurityDescriptor,
            NULL);
        if (!SUCCEEDED(rc))
        {
            return LogHR(rc, s_FN, 470);
        }

        __try
        {
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 480);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 490);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    rc = DeppSetObjectSecurity(
                            &ObjectFormat,
                            SecurityInformation,
                            pSecurityDescriptor);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    PROPID prop = PROPID_Q_SECURITY;
                    MQPROPVARIANT var;

                    var.vt = VT_BLOB;
					if(pSecurityDescriptor != NULL)
					{
						var.blob.cbSize = GetSecurityDescriptorLength( pSecurityDescriptor);
						var.blob.pBlobData = reinterpret_cast<unsigned char *>(pSecurityDescriptor); 
					}
					else
					{
						var.blob.cbSize = 0;
						var.blob.pBlobData = NULL; 
					}
                    rc = ADSetObjectSecurityGuid(
								eQUEUE,
								MachineDomain(),      // pwcsDomainCOntroller
								false,		// fServerName
								&QueueFormat.PublicID(),
								SecurityInformation,
								prop,
								&var
								); 
                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 500);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the serialized security descriptor.
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 510);
}

EXTERN_C
HRESULT
APIENTRY
DepPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            INIT_RPC_HANDLE ;

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE qpt;
            qpt = RTpValidateAndExpandQueuePath(
                    lpwcsPathName,
                    &lpwcsExpandedPathName,
                    &pStringToFree
                    );

            switch (qpt)
            {

                case PRIVATE_QUEUE_PATH_TYPE:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = R_QMObjectPathToObjectFormat(
                            tls_hBindRpc,
                            lpwcsExpandedPathName,
                            &ObjectFormat
                            );
                    ASSERT(!SUCCEEDED(rc) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT));
                }
                break;

                case PUBLIC_QUEUE_PATH_TYPE:
                {
                    GUID guidPublic;
                    ULONG QueueGuidPropID[1] = {PROPID_Q_INSTANCE};
                    PROPVARIANT QueueGuidPropVar[1];

                    QueueGuidPropVar[0].vt = VT_CLSID;
                    QueueGuidPropVar[0].puuid = &guidPublic;
                    rc = ADGetObjectProperties(
                            eQUEUE,
							MachineDomain(),      // pwcsDomainCOntroller
							false,	   // fServerName
                            lpwcsExpandedPathName,
                            1,
                            QueueGuidPropID,
                            QueueGuidPropVar
                            );

                    if (FAILED(rc) &&
                        (rc != MQ_ERROR_NO_DS) &&
                        (rc != MQ_ERROR_UNSUPPORTED_OPERATION))
                    {
                        rc = MQ_ERROR_QUEUE_NOT_FOUND;
                    }

                    QueueFormat.PublicID(guidPublic);
                }
                break;

                default:
                {
                    rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                }
                break;

            }

            if (SUCCEEDED(rc))
            {
                rc = RTpQueueFormatToFormatName(
                        &QueueFormat,
                        lpwcsFormatName,
                        *lpdwFormatNameLength,
                        lpdwFormatNameLength
                        );
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        QueueFormat.DisposeString();
        delete[] pStringToFree;

    }

    return LogHR(rc, s_FN, 540);
}

EXTERN_C
HRESULT
APIENTRY
DepHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        rc = ACDepHandleToFormatName(
                hQueue,
                lpwcsFormatName,
                lpdwFormatNameLength
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepInstanceToFormatName(
    IN GUID * pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {

        QUEUE_FORMAT QueueFormat(*pGuid);
        rc = RTpQueueFormatToFormatName(
                &QueueFormat,
                lpwcsFormatName,
                *lpdwFormatNameLength,
                lpdwFormatNameLength
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepPurgeQueue(
    IN HANDLE hQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        rc = ACDepPurgeQueue(hQueue, FALSE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtintcrt.cpp ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    rtintcrt.h

Abstract:

    Create and delete an internal certificate.

Author:

    Original code from MSMQ1.0 rt, then MSMQ2.0 cpl.
    Doron Juster  (DoronJ)  20-Aug-1998

--*/

#include "stdh.h"
#include <ad.h>
#include <mqutil.h>
#include <rtintrnl.h>
#include <mqsec.h>
#include <rtdepcert.h>

#include "rtintcrt.tmh"

//
// exported from mqrt.dll
//
LPWSTR rtpGetComputerNameW() ;

//---------------------------------------------------------
//
//  Function:
//      _GetUserAccountNameAndDomain(
//
//  Parameters:
//     fLocalSyste - TRUE if called in the context of a localSystem service.
//     szAccountName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the account name of the user of the
//         current thread.
//     szDomainName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the domain name of the user of the
//         current thread.
//
//  Description:
//     The function allocates and fills two buffers, one for the account name
//     of the user of the current thread, and the second buffer for the
//     domain name of the user of the current thread.
//
//---------------------------------------------------------

static HRESULT
_GetUserAccountNameAndDomain( IN BOOL    fLocalSystem,
                              IN LPTSTR *szAccountName,
                              IN LPTSTR *szDomainName )
{
    HRESULT hr = MQ_OK;
    TCHAR   szLocAccountName[64];
    DWORD   dwLocAccountNameLen = sizeof(szLocAccountName) /
                                         sizeof(szLocAccountName[0]) ;
    LPTSTR  pszLocAccountName = szLocAccountName;
    P<TCHAR>  pszLocLongAccountName = NULL;
    TCHAR   szLocDomainName[64];
    DWORD   dwLocDomainNameLen = sizeof(szLocDomainName) /
                                             sizeof(szLocDomainName[0]) ;
    LPTSTR  pszLocDomainName = szLocDomainName;
    P<TCHAR>  pszLocLongDomainName = NULL;

    P<BYTE>  pbSidAR = NULL ;
    DWORD   dwSidLen;

    try
    {
        //
        // Win NT.
        //
        PSID pSid = NULL ;

        if (fLocalSystem)
        {
            pSid = MQSec_GetLocalMachineSid( FALSE, NULL ) ;
            if (!pSid)
            {
                return MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO ;
            }
        }
        else
        {
            //
            // Get the SID of the user of the current thread.
            //
            hr = MQSec_GetThreadUserSid(
                            FALSE, 
                            reinterpret_cast<PSID*>(&pbSidAR),
                            &dwSidLen,
                            FALSE           // fThreadTokenOnly
                            );
            if (FAILED(hr))
            {
                return(hr);
            }
            pSid = pbSidAR.get() ;
        }

        SID_NAME_USE eUse;
        //
        //  Try to get the account and domain names in to a
        //  fixed size buffers.
        //
        if (!LookupAccountSid( NULL,
                               pSid,
                               pszLocAccountName,
                               &dwLocAccountNameLen,
                               pszLocDomainName,
                               &dwLocDomainNameLen,
                               &eUse))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // The fixed size buffer are not large enough.
                // Allocate larger buffers.
                //
                if (dwLocAccountNameLen > (sizeof(szLocAccountName) /
                                           sizeof(szLocAccountName[0])))
                {
                    pszLocLongAccountName =
                                     new TCHAR[ dwLocAccountNameLen ];
                    pszLocAccountName = pszLocLongAccountName.get();
                }

                if (dwLocDomainNameLen > (sizeof(szLocDomainName) /
                                          sizeof(szLocDomainName[0])))
                {
                    pszLocLongDomainName = new TCHAR[ dwLocDomainNameLen ];
                    pszLocDomainName = pszLocLongDomainName.get();
                }

                //
                // Re-call LookupAccountSid, now with the lrger buffer(s).
                //
                if (!LookupAccountSid(  NULL,
                                        pSid,
                                        pszLocAccountName,
                                       &dwLocAccountNameLen,
                                        pszLocDomainName,
                                       &dwLocDomainNameLen,
                                       &eUse ))
                {
                    return(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO);
                }
            }
            else
            {
                return(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO);
            }
        }

        //
        // Allocate the buffers for the returned results, and fill the
        // allocated buffer with the result strings.
        //
        *szAccountName = new TCHAR[ dwLocAccountNameLen + 1 ];
        _tcscpy(*szAccountName, pszLocAccountName);

        *szDomainName = new TCHAR[ dwLocDomainNameLen + 1 ];
        _tcscpy(*szDomainName, pszLocDomainName);
    }
    catch(...)
    {
    }

    return hr;
}

/*************************************************************************

  Function:
     DepCreateInternalCertificate

  Parameters -
    ppCert - On return, get the certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the store already contain a certificate, the function falis.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepCreateInternalCertificate( 
	OUT CMQSigCertificate **ppCert 
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    BOOL fLocalUser;
    BOOL fLocalSystem;

    if (ppCert)
    {
        *ppCert = NULL ;
    }

    //
    // Local users are not let in.
    //
    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (FAILED(hr))
    {
        return(hr);
    }
    if (fLocalUser)
    {
        return(MQ_ERROR_ILLEGAL_USER);
    }

    LONG nCerts;
    R<CMQSigCertStore> pStore ;
    //
    // Get the internal certificate store.
    //
    hr = DepOpenInternalCertStore( &pStore.ref(),
                                  &nCerts,
                                  TRUE,
                                  fLocalSystem,
                                  FALSE ) ;  // fUseCurrentUser
    if (FAILED(hr))
    {
        return hr;
    }

    if (nCerts)
    {
        return(MQ_ERROR_INTERNAL_USER_CERT_EXIST);
    }
    HCERTSTORE  hStore = pStore->GetHandle() ;

    //
    // Get the user's account name and domain name.
    //
    AP<TCHAR> szAccountName;
    AP<TCHAR> szDomainName;

    hr = _GetUserAccountNameAndDomain( fLocalSystem,
                                      &szAccountName,
                                      &szDomainName );
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Get the name of the computer.
    //
    #define COMPUTER_NAME_LEN  256
    WCHAR szHostNameW[ COMPUTER_NAME_LEN ];
    DWORD dwHostNameLen = sizeof(szHostNameW) / sizeof(szHostNameW[0]) ;

    if (FAILED(GetComputerNameInternal(szHostNameW, &dwHostNameLen)))
    {
        return MQ_ERROR ;
    }

    AP<TCHAR> szComputerName = new TCHAR[ dwHostNameLen + 2 ] ;
#ifdef UNICODE
    wcscpy(szComputerName.get(), szHostNameW) ;
#else
    SecConvertFromWideCharString(szHostNameW,
                                 szComputerName.get(),
                                 (dwHostNameLen + 2)) ;
#endif

    R<CMQSigCertificate> pSigCert = NULL ;
    hr = MQSigCreateCertificate (&pSigCert.ref()) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    else if (pSigCert.get() == NULL)
    {
        return MQ_ERROR ;
    }

    hr = pSigCert->PutValidity( INTERNAL_CERT_DURATION_YEARS ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->PutIssuer( MQ_CERT_LOCALITY,
                              _T("-"),
                              _T("-"),
                              szDomainName.get(),
                              szAccountName.get(),
                              szComputerName.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->PutSubject( MQ_CERT_LOCALITY,
                               _T("-"),
                               _T("-"),
                               szDomainName.get(),
                               szAccountName.get(),
                               szComputerName.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // When renewing the internal certificate, always renew the
    // private/public keys pair.
    //
    BOOL fCreated = FALSE ;
    hr = pSigCert->PutPublicKey( TRUE,
                                 fLocalSystem,
                                &fCreated) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(fCreated) ;

    hr = pSigCert->EncodeCert( fLocalSystem,
                               NULL,
                               NULL) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->AddToStore(hStore) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (ppCert)
    {
        *ppCert = pSigCert.detach();
    }

    return(MQ_OK);
}

/*************************************************************************

  Function:
     DepDeleteInternalCert( IN CMQSigCertificate *pCert )

  Parameters -
    pCert - Certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepDeleteInternalCert( 
	IN CMQSigCertificate *pCert 
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = pCert->DeleteFromStore() ;
    return hr ;
}

//+------------------------------------------------------------------------
//
//  DepRegisterCertificate()
//
//  Description: Create an internal certificate and register it in the DS.
//
//  Input:
//      IN DWORD   dwFlags- one of the followings:
//          MQCERT_REGISTER_IF_NOT_EXIST- create a new internal certificate
//              only if there is not a previous one on local machine. The
//              test for existing certificate is local and no access to
//              remote DS server is made. So this check can be safely made
//              if machine is offline, without hanging it.
//      IN PVOID   lpCertBuffer- NULL for internal certificate.
//          Otherwise, pointer to external certificate buffer. In this case,
//          the api only register the external certificate in the DS and
//          flag "MQCERT_REGISTER_IF_NOT_EXIST" must not be specified.
//      IN DWORD   dwCertBufferLength- Size, in bytes, of buffer of external
//          certificate.
//
//+------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepRegisterCertificate( IN DWORD   dwFlags,
                       IN PVOID   lpCertBuffer,
                       IN DWORD   dwCertBufferLength )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = MQ_OK ;
    R<CMQSigCertStore> pStore = NULL ;
    R<CMQSigCertificate> pCert = NULL ;

    //
    // First check validity of input parameters.
    //
    if (lpCertBuffer)
    {
        if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
        {
            //
            // The "if_not_exist" flag is relevant only for internal
            // certificate, because we create it.
            //
            return MQ_ERROR_INVALID_PARAMETER ;
        }
        else if (dwCertBufferLength == 0)
        {
            //
            // Length must be specified for the external certificate.
            //
            return MQ_ERROR_INVALID_PARAMETER ;
        }
    }

    //
    // Next, check if local user. They are not let in. the SID of a local
    // user is not meaningful outside of his local machine. There is no
    // user object in the DS for a local user, so we don't have a place to
    // register his certificate.
    //
    BOOL fLocalUser =  FALSE ;
    BOOL fLocalSystem = FALSE ;

    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (FAILED(hr))
    {
        return(hr);
    }
    else if (fLocalUser)
    {
        return MQ_ERROR_ILLEGAL_USER ;
    }

    //
    // Next, check if an internal certificate already exist.
    //
    if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
    {
        LONG nCerts = 0 ;
        hr = DepOpenInternalCertStore( &pStore.ref(),
                                      &nCerts,
                                      TRUE,
                                      fLocalSystem,
                                      FALSE ) ; // fUseCurrectUser
        if (FAILED(hr))
        {
            return hr;
        }
        else if (nCerts)
        {
            //
            // OK, we already have an internal certificate.
            //
            return MQ_INFORMATION_INTERNAL_USER_CERT_EXIST ;
        }
        pStore.free() ;
    }

    BOOL fIntCreated = FALSE ;

    if (!lpCertBuffer)
    {
        //
        // Creating an internal certificate also mean to recreate the user
        // private key. So before destroying previous keys, let's check
        // if the user has permission to register his certificate and if
        // local machine can access the DS at present. We'll do this by
        // trying to register previous internal certificate.
        //
        // Open the certificates store with write access, so we can later
        // delete the internal certificate, before creating a new one.
        //
        hr = DepGetInternalCert( &pCert.ref(),
                                &pStore.ref(),
                                 TRUE,
                                 fLocalSystem,
                                 FALSE ) ;  //  fUseCurrentUser

        if (SUCCEEDED(hr))
        {
            //
            // Try to register in the DS.
            //
    		hr = DepRegisterUserCert( pCert.get(), fLocalSystem );
    		if(FAILED(hr) && (hr != MQ_ERROR_INTERNAL_USER_CERT_EXIST))
	    	{
		    	return hr ;
    		}
            //
            // Remove the internal certificate from MQIS.
            //
            hr = DepRemoveUserCert(pCert.get()) ;
            if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
            {
                return hr ;
            }
            //
            // Remove the internal certificate from the local certificate
            // store.
            //
            hr = DepDeleteInternalCert(pCert.get());
            if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
            {
                return hr ;
            }

            pCert.free();
        }

        //
        // It's time to create the internal certificate.
        //
        ASSERT(!pCert.get()) ;
        hr = DepCreateInternalCertificate( &pCert.ref() ) ;
        fIntCreated = TRUE ;
    }
    else
    {
        hr = MQSigCreateCertificate( &pCert.ref(),
                                      NULL,
                                      (LPBYTE) lpCertBuffer,
                                      dwCertBufferLength ) ;
    }

    if (FAILED(hr))
    {
        return hr ;
    }

    hr = DepRegisterUserCert( pCert.get(), fLocalSystem ) ;
    if (FAILED(hr) && fIntCreated)
    {
        //
        // We created a new certificate in registry but failed to register
        // it in DS. delete from local registry.
        //
        pCert.free();
        pStore.free();

        HRESULT hr1 = DepGetInternalCert( &pCert.ref(),
                                         &pStore.ref(),
                                          TRUE,
                                          fLocalSystem,
                                          FALSE ) ; // fUseCurrentUser
        if (SUCCEEDED(hr1))
        {
            hr1 = DepDeleteInternalCert(pCert.get());
        }
        ASSERT(SUCCEEDED(hr1)) ;
    }

    return hr ;
}

//+-------------------------------------------------------------------------
//
//  STDAPI DepRegisterServer()
//
//  this code is run on every logon, from regsvr32. It's the reponsibility
//  of setup to insert the regsvr32 command in the "run" registry. This
//  code will register an internal certificate for each new domain user
//  that logon the machine.
//
//+-------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepRegisterServer()
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    //
    // First see if auto registration was disabled by user.
    //
    DWORD dwEnableRegister = DEFAULT_AUTO_REGISTER_INTCERT ;
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(dwEnableRegister) ;
    LONG rc = GetFalconKeyValue( AUTO_REGISTER_INTCERT_REGNAME,
                                 &dwType,
                                 &dwEnableRegister,
                                 &dwSize ) ;
    if ((rc == ERROR_SUCCESS) && (dwEnableRegister == 0))
    {
        return MQ_OK ;
    }

    //
    // Next see if auto-registration was already done for this user
    //
    DWORD dwRegistered = 0 ;
    dwType = REG_DWORD ;
    dwSize = sizeof(dwRegistered) ;
    DWORD dwDisposition ;
    CAutoCloseRegHandle hMqUserReg = NULL;

    LONG lRes = RegCreateKeyEx( FALCON_USER_REG_POS,
                                FALCON_USER_REG_MSMQ_KEY,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                               &hMqUserReg,
                               &dwDisposition );
    if (lRes == ERROR_SUCCESS)
    {
        lRes = RegQueryValueEx( hMqUserReg,
                                CERTIFICATE_REGISTERD_REGNAME,
                                0,
                               &dwType,
                                (LPBYTE) &dwRegistered,
                               &dwSize ) ;

        if (lRes != ERROR_SUCCESS)
        {
            dwRegistered = 0 ;
        }
    }

    if (dwRegistered == INTERNAL_CERT_REGISTERED)
    {
        //
        // Certificate already registered.
        //
        return MQ_OK ;
    }

    //
    // Read number of 15 seconds intervals to wait for MSMQ DS server.
    //
    dwType = REG_DWORD ;
    dwSize = sizeof(DWORD) ;
    DWORD dwDef = DEFAULT_AUTO_REGISTER_WAIT_DC ;
    DWORD dwWaitIntervals = DEFAULT_AUTO_REGISTER_WAIT_DC ;

    READ_REG_DWORD( dwWaitIntervals,
                    AUTO_REGISTER_WAIT_DC_REGNAME,
                   &dwDef ) ;

    //
    // OK, now it's time to resiter the certificate.
    //
    DWORD iCount = 0 ;
    BOOL  fTryAgain = FALSE ;
    HRESULT hr = MQ_OK ;

    do
    {
        fTryAgain = FALSE ;
        hr = DepRegisterCertificate( MQCERT_REGISTER_IF_NOT_EXIST,
                                    NULL,
                                    0 ) ;
        if (SUCCEEDED(hr) && hMqUserReg)
        {
            //
            // Save success status in registry.
            //
            dwRegistered = INTERNAL_CERT_REGISTERED ;
            dwType = REG_DWORD ;
            dwSize = sizeof(dwRegistered) ;

            lRes = RegSetValueEx( hMqUserReg,
                                  CERTIFICATE_REGISTERD_REGNAME,
                                  0,
                                  dwType,
                                  (LPBYTE) &dwRegistered,
                                  dwSize ) ;
            ASSERT(lRes == ERROR_SUCCESS) ;
        }
        else if (hr == MQ_ERROR_NO_DS)
        {
            //
            // MSMQ DS server not yet found.
            // wait 15 seconds and try again.
            //
            if (iCount < dwWaitIntervals)
            {
                iCount++ ;
                Sleep(15000) ;
                fTryAgain = TRUE ;
            }
        }
    } while (fTryAgain) ;

    if (FAILED(hr) && hMqUserReg)
    {
        dwType = REG_DWORD ;
        dwSize = sizeof(hr) ;

        lRes = RegSetValueEx( hMqUserReg,
                              AUTO_REGISTER_ERROR_REGNAME,
                              0,
                              dwType,
                              (LPBYTE) &hr,
                              dwSize ) ;
        ASSERT(lRes == ERROR_SUCCESS) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtintrnl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rtintrnl.h

Abstract:
    Non public functions that are exported from MQRT.DLL

--*/


#ifndef _RT_INTERNAL_H_
#define _RT_INTERNAL_H_

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
APIENTRY
DepOpenInternalCertStore( OUT CMQSigCertStore **pStore,
                         IN LONG              *pnCerts,
                         IN BOOL               fWriteAccess,
                         IN BOOL               fMachine,
                         IN HKEY               hKeyUser ) ;

HRESULT
APIENTRY
DepGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser ) ;
 //
 // if fGetForDelete is TRUE then the certificates store is open with write
 // access. Otherwise the store is opened in read-only mode.
 //

HRESULT
APIENTRY
DepRegisterUserCert( IN CMQSigCertificate *pCert,
                    IN BOOL               fMachine ) ;

HRESULT
APIENTRY
DepGetUserCerts( CMQSigCertificate **ppCert,
                DWORD              *pnCerts,
                PSID                pSidIn) ;

HRESULT
APIENTRY
DepRemoveUserCert( IN CMQSigCertificate *pCert ) ;

#ifdef __cplusplus
}
#endif

#endif // _RT_INTERNAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtpsec.h ===
//
// file:  rtpsec.h
//
#ifndef _RTPSEC_H_
#define _RTPSEC_H_

#include <mqcrypt.h>
#include <cs.h>

//
// The security context.
//

#define SECURITY_CONTEXT_VER    1

class MQSECURITY_CONTEXT
{
public:
    MQSECURITY_CONTEXT();
    ~MQSECURITY_CONTEXT();

    DWORD       dwVersion;       // The version of the security context.
    BOOL        fLocalUser;      // Indicates whether the user is a local user.
    BOOL        fLocalSystem;    // Indicates whether the user is a localSystem account.
    P<BYTE>     pUserSid;        // A pointer to the user SID. Undefined for a local user.
    DWORD       dwUserSidLen;    // The length of the user SID. Undefined for a local user.
    CHCryptProv hProv;           // A context handle to the cert CSP.
    P<BYTE>     pUserCert;       // A pointer to the user cert.
    DWORD       dwUserCertLen;   // The length of the user cert.
    P<WCHAR>    wszProvName;     // The name of the cert CSP.
    DWORD       dwProvType;      // The type of the cert CSP.
    BOOL        bDefProv;        // True if the cert CSP is the default CSP.
    BOOL        bInternalCert;   // True if the cert is an internal MSMQ cert.

    //
    // Member variables added to fix MSMQ bug 2955
    //

    CCriticalSection CS ;      // critical section for multi-threaded.
    BOOL     fAlreadyImported ;  // Private key already imported.
    P<BYTE>  pPrivateKey ;       // Blob of private key.
    DWORD    dwPrivateKeySize ;  // size of private key blob.
    WCHAR    wszContainerName[ 28 ] ;  // Name of container for keys.

};

typedef MQSECURITY_CONTEXT *PMQSECURITY_CONTEXT;

PMQSECURITY_CONTEXT AllocSecurityContext() ;

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx ) ;

HRESULT
GetCertInfo(
    IN    BOOL        bUseCurrentUser,
    IN    BOOL        bMachine,
    IN OUT BYTE     **ppbCert,
    OUT   DWORD      *pdwCertLen,
    OUT   HCRYPTPROV *phProv,
    OUT   LPWSTR     *wszProvName,
    OUT   DWORD      *pdwProvType,
    OUT   BOOL       *pbDefProv,
    OUT   BOOL       *pbInternalCert
    );

HRESULT
RTpGetThreadUserSid( BOOL   *pfLocalUser,
                     BOOL   *pfLocalSystem,
                     LPBYTE *ppUserSid,
                     DWORD  *pdwUserSidLen ) ;

#endif //_RTPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtp.h

Abstract:

    RT DLL private internal functions

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __RTP_H
#define __RTP_H

#include "rtpsec.h"
#include "_mqrpc.h"

#define SEND_PARSE  1
#define RECV_PARSE  2

#define QUEUE_CREATE    1
#define QUEUE_SET_PROPS 2
#define QUEUE_GET_PROPS 3

#define CPP_EXCEPTION_CODE 0xe06d7363

extern DWORD g_dwThreadEventIndex;
extern LPWSTR g_lpwcsComputerName;
extern DWORD g_dwComputerNameLen;
extern LPWSTR  g_lpwcsLocalComputerName;
extern BOOL   g_fDependentClient ;
extern WCHAR g_wszRemoteQMName[] ;
extern DWORD  g_dwPlatformId ;



HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType =MQDS_QUEUE
    );

//
// The CMQHResult class is used in order to automatically convert the various
// error codes to Falcon error codes. This is done by defining the assignment
// operator of this class so it converts whatever error code that is assigned
// to objects of this class to a Falcon error code. The casting operator
// from this class to HRESULT, returns the converted error code.
//
class CMQHResult
{
public:
    CMQHResult(DWORD =MQDS_QUEUE); // Default constructor.
    CMQHResult(const CMQHResult &); // Copy constructor
    CMQHResult& operator =(HRESULT); // Assignment operator.
    operator HRESULT(); // Casting operator to HRESULT type.
    HRESULT GetReal(); // A method that returns the real error code.

private:
    HRESULT m_hr; // The converted error code.
    HRESULT m_real; // The real error code.
    DWORD m_dwObjectType; // The type of object (can be only queue, or machine).
};

//---------- CMQHResult implementation ----------------------------------

inline CMQHResult::CMQHResult(DWORD dwObjectType)
{
    ASSERT((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE));
    m_dwObjectType = dwObjectType;
}

inline CMQHResult::CMQHResult(const CMQHResult &hr)
{
    m_hr = hr.m_hr;
    m_real = hr.m_real;
    m_dwObjectType = hr.m_dwObjectType;
}

inline CMQHResult& CMQHResult::operator =(HRESULT hr)
{
    m_hr = RTpConvertToMQCode(hr, m_dwObjectType);
    m_real = hr;

    return *this;
}

inline CMQHResult::operator HRESULT()
{
    return m_hr;
}

inline HRESULT CMQHResult::GetReal()
{
    return m_real;
}

//---------- CMQHResult implementation end ------------------------------

//---------- Function declarations --------------------------------------

HRESULT
RTpParseMessageProperties(
    LONG                     op,
    CACTransferBufferV2       *ptb,
    ULONG                    cProps,
    PROPID                   aPropID[],
    PROPVARIANT              aPropVar[],
    HRESULT                  aResult[],
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    OUT LPWSTR*              ppwcsResponseStringToFree,
    OUT LPWSTR*              ppwcsAdminStringToFree
    );

LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    );

GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    );

enum QUEUE_PATH_TYPE{
    ILLEGAL_QUEUE_PATH_TYPE = 0,
    PRIVATE_QUEUE_PATH_TYPE,
    PUBLIC_QUEUE_PATH_TYPE,
    SYSTEM_QUEUE_PATH_TYPE
};

QUEUE_PATH_TYPE
RTpValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    );

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName) ;

BOOL
RTpFormatNameToQueueFormat(
    LPCWSTR lpwcsFormatName,
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR* ppStringToFree
    );

HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize
    );

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns
    );

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS* pqp,
    IN  DWORD         dwOp,
    IN  BOOL          fPrivateQueue,
    OUT MQQUEUEPROPS **ppGoodQP,
    OUT char **ppTmpBuff
    );

HRESULT
RTpCheckQMProps(
    IN  MQQMPROPS * pQMProps,
    IN OUT HRESULT* aStatus,
    OUT MQQMPROPS **ppGoodQMP,
    OUT char      **ppTmpBuff
    );

HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction
    );

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
    );

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	);

HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	);


HRESULT
RTpProvideTransactionEnlist(
    ITransaction *pTrans,
    XACTUOW *pUow
    );

VOID
RTpInitXactRingBuf(
    VOID
    );

HANDLE
GetThreadEvent(
    VOID
    );

HRESULT 
DeppOneTimeInit();


HRESULT
DeppCreateObject(
    DWORD dwObjectType,
    LPCWSTR lpwcsPathName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD cp,
    PROPID aProp[],
    PROPVARIANT apVar[]
    );

HRESULT
DeppSetObjectSecurity(
    OBJECT_FORMAT* pObjectFormat,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
DeppSendMessage(
    IN handle_t hBind,
    IN QUEUEHANDLE  hQueue,
    IN struct CACTransferBufferV2 *pCacTB
    );

HRESULT RTpGetSupportServerInfo(BOOL *pfRemote);

//
//  cursor information
//
struct CCursorInfo {
    HANDLE hQueue;
    ULONG hCursor;
};
  

//
//  CCursorInfo to cursor handle
//
inline ULONG CI2CH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hCursor;
}


//
//  CCursorInfo to queue handle
//
inline HANDLE CI2QH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hQueue;
}


//
//  Macro for extracting the explicit rpc binding handle from tls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff

extern DWORD  g_hBindIndex ;
#define tls_hBindRpc  ((handle_t) TlsGetValue( g_hBindIndex ))

#endif // __RTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtmain.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmain.cpp

Abstract:

    This module contains code involved with Dll initialization.

	The mqrtdep.dll contains the msmq3 dependent client functionality. 
	This functionality was removed from the mqrt.dll.
	It does not support msmq3's new features like mqf and http messaging.
	It is essentially a modified copy of the msmq2 runtime.

Author:
    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "cs.h"
#include "rtsecutl.h"
#include "rtprpc.h"
#include <mqexception.h>

#include "rtmain.tmh"

//
// Platform flag. Win95 binaries run on NT if we install Falcon client,
// so in some places we must check at run-time on which platform we are.
//
DWORD  g_dwPlatformId = (DWORD) -1 ;

//
// TLS index for per-thread event.
//
DWORD  g_dwThreadEventIndex = 0;

// QM computer name (for the client - server's name)
LPWSTR  g_lpwcsComputerName = NULL;
DWORD   g_dwComputerNameLen = 0;

// Local computer name (for the client - client's name)
LPWSTR  g_lpwcsLocalComputerName = NULL;

AP<char> g_pQmSid_buff;

#define g_pQmSid ((PSID)(char*)(g_pQmSid_buff.get()))

//
//  Default for PROPID_M_TIME_TO_REACH_QUEUE
//
DWORD  g_dwTimeToReachQueueDefault = MSMQ_DEFAULT_LONG_LIVE ;

//
// RPC related data.
//
BOOL InitRpcGlobals() ;

//
// Name of server for dependent client.
//
BOOL  g_fDependentClient = FALSE ;   // TRUE if running as dependent Client
WCHAR g_wszRemoteQMName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0} ;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

//
// Type of Falcon machine (client, server)
//
DWORD  g_dwOperatingSystem;

//
// There is a separate rpc binding handle for each thread. This is necessary
// for handling impersonation, where each thread can impersonate another
// user.
//
// The handle is stored in a TLS slot because we can't use declspec(thread)
// because the dll is dynamically loaded (by LoadLibrary()).
//
// This is the index of the slot.
//
DWORD  g_hBindIndex = UNINIT_TLSINDEX_VALUE ;

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

//---------------------------------------------------------
//
//  InitializeQM(...)
//
//  Description:
//
//      Per process QM initialization.
//      Currently the only initialization is to allow the QM to open the application's
//      process in order to duplicate handles for the application.
//
//  Return Value:
//
//      MQ_OK, if successful, else MQ error code.
//
//---------------------------------------------------------

static HRESULT InitializeQM(void)
{
    //
    // Get the cumputer name, we need this value in several places.
    //
    g_dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> lpwcsComputerName = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
    HRESULT hr= GetComputerNameInternal(
        lpwcsComputerName.get(),
        &g_dwComputerNameLen
        );

    ASSERT(SUCCEEDED(hr) );
    g_lpwcsComputerName = lpwcsComputerName.get();
    lpwcsComputerName.detach();
    g_lpwcsLocalComputerName = new WCHAR[wcslen(g_lpwcsComputerName) + 1];
    wcscpy(g_lpwcsLocalComputerName, g_lpwcsComputerName);

    if(g_fDependentClient)
    {
        //
        // In Client case, make the name of this computer
        // be the name of the remote machine
        //
        delete[] g_lpwcsComputerName;
        g_lpwcsComputerName = g_wszRemoteQMName;
        g_dwComputerNameLen = wcslen(g_wszRemoteQMName);
    }

    RTpInitXactRingBuf();

    g_dwOperatingSystem = MSMQGetOperatingSystem();


    if (g_fDependentClient)
    {
       return MQ_OK ;
    }

    ASSERT(tls_hBindRpc == NULL) ;
    RTpBindQMService();

    DWORD cSid;
    HANDLE hProcess = GetCurrentProcess();
    AP<char> pSD_buff;
    SECURITY_DESCRIPTOR AbsSD;
    DWORD cSD;
    AP<char> pNewDacl_buff;
    BOOL bRet;
    BOOL bPresent;
    PACL pDacl;
    BOOL bDefaulted;
    DWORD dwAceSize;

#define pSD ((PSECURITY_DESCRIPTOR)(char*)pSD_buff.get())
#define pNewDacl ((PACL)(char*)pNewDacl_buff)

    try
    {
        ASSERT( tls_hBindRpc ) ;

        //
        // In multi-qm environment we want to access registry section
        // of the correct QM only. Cluster guarantees that this code runs
        // only when the correct QM is running, so we should not fail.
        // On non cluster systems it doesn't matter if we fail here. (ShaiK)
        //
        AP<WCHAR> lpServiceName = 0;
        hr = R_QMGetMsmqServiceName( tls_hBindRpc, &lpServiceName );
		if (FAILED(hr))
		{
			return (hr);
		}

        SetFalconServiceName(lpServiceName.get());

        // Get the SID of the user that runs the QM.
        // First see how bug is the SID.
        hr = R_QMAttachProcess( tls_hBindRpc, GetCurrentProcessId(), 0, NULL, &cSid);
    }
    catch(...)
    {
        //
        //  The QM is not running, let us load, all APIs
        //  will return no QM, no DS
        //
        return MQ_OK;
    }

    if (SUCCEEDED(hr))
    {
        //
        // The QM can duplicate handles to us, no need to worry anymore!
        //
        return MQ_OK;
    }

    if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
    {
        return(hr);
    }

    // Allocate a buffer for the SID.
	g_pQmSid_buff.detach();
    g_pQmSid_buff = new char[cSid];
    // Get the SID.
    ASSERT( tls_hBindRpc ) ;
    hr = R_QMAttachProcess( tls_hBindRpc,
                          0,
                          cSid,
                          (unsigned char *)g_pQmSid,
                          &cSid);
    if (hr != MQ_OK)
    {
        return(hr);
    }

    // Get the process security descriptor.
    // First see how big is the security descriptor.
    GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, NULL, 0, &cSD);

    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
        TrERROR(GENERAL, "Failed to get process security descriptor (NULL buffer), error %d", gle);

        return(MQ_ERROR);
    }

    // Allocate a buffer for the securiy descriptor.
	pSD_buff.detach();
    pSD_buff = new char[cSD];
    // Get the security descriptor.
    if (!GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, pSD, cSD, &cSD))
    {
        TrERROR(GENERAL, "Failed to get process security descriptor, error %d", GetLastError());

        return(MQ_ERROR);
    }

    // Get the DACL from the security descriptor.
    bRet = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    ASSERT(bRet);
    // Calculate the size of the new ACE.
    dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pQmSid) - sizeof(DWORD);

    if (bPresent)
    {
        // The security descriptor contains a DACL. Append our new ACE to this DACL.

        ACL_SIZE_INFORMATION AclSizeInfo;

        bRet = GetAclInformation(pDacl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation);
        ASSERT(bRet);
        if (AclSizeInfo.AclBytesFree < dwAceSize)
        {
            // The currect DACL is not large enough.
            LPVOID pAce;
            // Calculate the size for the new DACL.
            DWORD dwNewDaclSize = AclSizeInfo.AclBytesInUse + dwAceSize;

            // Allocate a buffer for a new DACL.
			pNewDacl_buff.detach();
            pNewDacl_buff = new char[dwNewDaclSize];
            // Initialize the new DACL.
            bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
            ASSERT(bRet);
            // Copy the current ACEs to the new DACL.
            bRet = GetAce(pDacl, 0, &pAce);
            ASSERT(bRet); // Get current ACEs
            bRet = AddAce(pNewDacl, ACL_REVISION, 0, pAce, AclSizeInfo.AclBytesInUse - sizeof(ACL));
            ASSERT(bRet);
            pDacl = pNewDacl;
        }
    }
    else
    {
        // The security descriptor does not contain a DACL.
        // Calculate the size for the DACL.
        DWORD dwNewDaclSize = sizeof(ACL) + dwAceSize;

        // Allocate a buffer for the DACL.
		pNewDacl_buff.detach();
        pNewDacl_buff = new char[dwNewDaclSize];
        // Initialize the DACL.
        bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
        ASSERT(bRet);
        pDacl = pNewDacl;
    }

    // Add a new ACE that gives permission for the QM to duplicatge handles for the
    // application.
    bRet = AddAccessAllowedAce(pDacl, ACL_REVISION, PROCESS_DUP_HANDLE, g_pQmSid);
    ASSERT(bRet);

    // Initialize a new absolute security descriptor.
    bRet = InitializeSecurityDescriptor(&AbsSD, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);
    // Set the DACL of the new absolute security descriptor.
    bRet = SetSecurityDescriptorDacl(&AbsSD, TRUE, pDacl, FALSE);
    ASSERT(bRet);

    // Set the security descriptor of the process.
    if (!SetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, &AbsSD))
    {
        TrERROR(GENERAL, "Failed to set process security descriptor, error %d", GetLastError());

        return(MQ_ERROR);
    }

#undef pSD
#undef pNewDacl

    return(MQ_OK);
}

//---------------------------------------------------------
//
//  LPWSTR rtpGetComputerNameW()
//
//  Note: this function is exported, to be used by the control panel
//
//---------------------------------------------------------

LPWSTR rtpGetComputerNameW()
{
    return  g_lpwcsComputerName ;
}

//---------------------------------------------------------
//
//  FreeGlobals(...)
//
//  Description:
//
//      Release allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void  TerminateRxAsyncThread() ;
extern TBYTE* g_pszStringBinding ;
extern TBYTE* g_pszStringBinding2 ;

static void FreeGlobals()
{
    TerminateRxAsyncThread() ;
    if (g_lpwcsComputerName != g_wszRemoteQMName)
    {
       ASSERT(!g_fDependentClient) ;
       delete[] g_lpwcsComputerName;
    }
    delete [] g_lpwcsLocalComputerName;
    delete g_pSecCntx;

    BOOL fFree = TlsFree( g_hBindIndex ) ;
    ASSERT(fFree) ;
    fFree = TlsFree( g_dwThreadEventIndex ) ;
    ASSERT(fFree) ;

    mqrpcUnbindQMService( NULL, &g_pszStringBinding) ;
    mqrpcUnbindQMService( NULL, &g_pszStringBinding2);

    if (g_hMutexDTC)
    {
        CloseHandle(g_hMutexDTC);
    }

    fFree = TlsFree( g_hThreadIndex ) ;
    ASSERT(fFree) ;
}

//---------------------------------------------------------
//
//  FreeThreadGlobals(...)
//
//  Description:
//
//      Release per-thread allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

static void  FreeThreadGlobals()
{
   HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
   if (hEvent)
   {
      CloseHandle(hEvent) ;
   }

   if (g_hThreadIndex != UNINIT_TLSINDEX_VALUE)
   {
        HANDLE hThread = TlsGetValue(g_hThreadIndex);
        if ( hThread)
        {
            CloseHandle( hThread);
        }
   }

   RTpUnbindQMService() ;
}

static void OneTimeInit()
{
	//
	// Read name of remote QM (if exist).
	//
	DWORD dwType = REG_SZ ;
	DWORD dwSize = sizeof(g_wszRemoteQMName) ;
	LONG rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
								 &dwType,
								 (PVOID) g_wszRemoteQMName,
								 &dwSize ) ;

	if(rc != ERROR_SUCCESS)
	{
        TrERROR(GENERAL, "Failed to retrieve remote QM name from registry, error %!winerr!",rc);
		throw bad_win32_error(rc);
	}

	//
	// Determine platform (win95/winNT). Use the A version on NT too
	// because we don't need any string, only the platform ID.
	//
	OSVERSIONINFOA osv ;
	osv.dwOSVersionInfoSize = sizeof(osv) ;

	BOOL f = GetVersionExA(&osv) ;
	ASSERT(f) ;
	DBG_USED(f);

	g_dwPlatformId = osv.dwPlatformId ;

	//
	//  Allocate TLS index for synchronic event.
	//
	g_dwThreadEventIndex = TlsAlloc();
	ASSERT(g_dwThreadEventIndex != UNINIT_TLSINDEX_VALUE) ;

	//
	// RPC cancel is supported on NT only
	//
	g_CancelRpc.Init();

	//
	// Initialize  RPC related data.
	//
	BOOL fRet = InitRpcGlobals() ;
	if (!fRet)
	{
        TrERROR(GENERAL, "Failed inside RpcGlobals(), error %d", GetLastError());
		throw bad_alloc();
	}

	//
	//  Initialize the QM per this process.
	//  Call this ONLY after initializing the RPC globals.
	//
	HRESULT hr = InitializeQM();
	if(FAILED(hr))
	{
        TrERROR(GENERAL, "Failed inside InitializeQM(), error %d", GetLastError());
		throw bad_hresult(hr);
	}

	DWORD dwDef = g_dwTimeToReachQueueDefault ;
	READ_REG_DWORD(g_dwTimeToReachQueueDefault,
		MSMQ_LONG_LIVE_REGNAME,
		&dwDef ) ;
}

static CCriticalSection s_OneTimeInitLock(CCriticalSection::xAllocateSpinCount);
static bool s_fOneTimeInitSucceeded = false;

HRESULT DeppOneTimeInit()
{
	if(s_fOneTimeInitSucceeded)
		return MQ_OK;

	CS lock(s_OneTimeInitLock);
		
	try
	{
		if(s_fOneTimeInitSucceeded)
			return MQ_OK;

		OneTimeInit();
		s_fOneTimeInitSucceeded = true;

		return MQ_OK;
	}
	catch(const bad_hresult& hr)
	{
		return hr.error();
	}
	catch(const bad_win32_error& err)
	{
		return HRESULT_FROM_WIN32(err.error());
	}
	catch(const bad_alloc&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//---------------------------------------------------------
//
//  DllMain(...)
//
//  Description:
//
//      Main entry point to Falcon Run Time Dll.
//
//  Return Value:
//
//      TRUE on success
//
//---------------------------------------------------------

BOOL
APIENTRY
DllMain(
    HINSTANCE   /*hInstance */,
    ULONG     ulReason,
    LPVOID            /*lpvReserved*/
    )
{
    switch (ulReason)
    {

        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

			g_fDependentClient = TRUE;

            break ;
        }

        case DLL_PROCESS_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            //
            // First free whatever is free in THREAD_DETACH.
            //
            FreeThreadGlobals() ;

            FreeGlobals();

            //
            //  Terminate all working threads
            //
            ShutDownDebugWindow();

            WPP_CLEANUP();
            break;

        case DLL_THREAD_ATTACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
            break;

        case DLL_THREAD_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            FreeThreadGlobals() ;
            break;

    }
    return TRUE;
}

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtprpc.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rtprpc.h

Abstract:

    RT DLL, RPC related stuff.

Author:

    Doron Juster  (DoronJ)  18-Nov-1996

--*/

#ifndef __RTPRPC_H
#define __RTPRPC_H

#include "_mqrpc.h"
#include "mqsocket.h"
#include "cancel.h"
#include <mqsec.h>

//
//  Cancel RPC globals
//
extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;
extern DWORD g_hThreadIndex;
#define tls_hThread  ((handle_t) TlsGetValue( g_hThreadIndex ))

//
// Local endpoints to QM
//
extern AP<WCHAR> g_pwzQmsvcEndpoint;
extern AP<WCHAR> g_pwzQmmgmtEndpoint;

/*====================================================

RegisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/

inline  void RegisterRpcCallForCancel(IN  HANDLE  *phThread,
                                      IN  DWORD    dwRecvTimeout )
{
    handle_t hThread = tls_hThread;
    if ( hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
            GetCurrentProcess(),
            hT,
            GetCurrentProcess(),
            &hThread,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
        ASSERT( fResult == TRUE);
        ASSERT(hThread);

        fResult = TlsSetValue( g_hThreadIndex, hThread);
        ASSERT( fResult == TRUE);

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status;
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT( status == RPC_S_OK);

    }
    *phThread = hThread;
    //
    //  Register the thread
    //
    TIME32 tPresentTime = DWORD_PTR_TO_DWORD(time(NULL)) ;
    TIME32  tTimeToWake = tPresentTime + (dwRecvTimeout / 1000) ;

    if ((dwRecvTimeout == INFINITE) || (tTimeToWake < tPresentTime))
    {
        //
        // Overflow
        // Note that time_t is a long, not unsigned. On the other hand
        // INFINITE is defined as 0xffffffff (i.e., -1). If we'll use
        // INFINITE here, then cancel routine, CCancelRpc::CancelRequests(),
        // will cancel this call immediately.
        // so use the bigest long value.
        //
        tTimeToWake = MAXLONG ;
    }
    g_CancelRpc.Add( hThread, tTimeToWake) ;
}


/*====================================================

UnregisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void UnregisterRpcCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread);
}


void RTpUnbindQMService();
void RTpBindQMService();
HRESULT RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT ULONG *peAuthnLEvel,
    IN  BOOL       fAlternate = FALSE
    );

handle_t RTpGetQMServiceBind(BOOL fAlternate = FALSE);
HRESULT  GetMachineIpxAddress(LPWSTR lpwszMachine, LPWSTR lpwszAddr) ;


#define  RTP_CALL_REMOTE_QM(lpServer, rc, command)				\
{                                                               \
       handle_t hBind = NULL ;                                  \
                                                                \
       rc = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE ;             \
                                                                \
       HRESULT rpcs =  RTpBindRemoteQMService(                  \
                                lpServer,                       \
                                &hBind,                         \
                                &_eAuthnLevel                   \
                                );                              \
                                                                \
       if (rpcs == MQ_OK)                                       \
       {                                                        \
          HANDLE hThread;                                       \
          RegisterRpcCallForCancel( &hThread, 0) ;              \
                                                                \
          RpcTryExcept                                          \
          {                                                     \
             rc = command ;                                     \
          }                                                     \
		  RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))   \
          {                                                     \
          	 PRODUCE_RPC_ERROR_TRACING;							\
             rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;              \
          }                                                     \
		  RpcEndExcept											\
		  														\
          UnregisterRpcCallForCancel( hThread);                 \
       }                                                        \
                                                                \
       if (hBind)                                               \
       {                                                        \
          mqrpcUnbindQMService( &hBind,                         \
                                NULL ) ;                        \
       }                                                        \
}

#define  CALL_REMOTE_QM(lpServer, rc, command)                          \
{                                                                       \
    BOOL  fTryAgain = FALSE ;                                           \
    ULONG _eAuthnLevel = MQSec_RpcAuthnLevel();     					\
                                                                        \
    do                                                                  \
    {                                                                   \
        fTryAgain = FALSE ;                                             \
        RTP_CALL_REMOTE_QM(lpServer, rc, command)						\
        if (rc == MQ_ERROR_SERVICE_NOT_AVAILABLE)                       \
        {                                                               \
           if (_eAuthnLevel != RPC_C_AUTHN_LEVEL_NONE)                  \
           {                                                            \
               _eAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;                   \
               fTryAgain = TRUE ;                                       \
           }                                                            \
        }                                                               \
    } while (fTryAgain) ;                                               \
}

#define INIT_RPC_HANDLE                      \
{                                            \
    RTpUnbindQMService() ;                   \
    RTpBindQMService() ;                     \
}

#endif // __RTPRPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtputl.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rtputl.h

Abstract:
    Utils functions header.

Author:
    Ilan Herbst (ilanh) 21-Nov-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _RTPUTL_H_
#define _RTPUTL_H_


LPCWSTR MachineDomain();


#endif // _RTPUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtmgmt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rtmgmt.cpp

Abstract:

    Management.

Author:

    RaphiR

Revision History:

--*/

#include "stdh.h"
#include "fntoken.h"
#include "mgmtrpc.h"
#include "qmmgmt.h"
#include "rtprpc.h"
#include <mqutil.h>

#include "rtmgmt.tmh"

static WCHAR *s_FN=L"rtdep/rtmgmt";


//---------------------------------------------------------
//
//  Function:
//      RTpMgmtObjectNameToMgmtObject
//
//  Description:
//      Convert a format name string to a Management Object union.
//
//    This function allocates a MGMT_OBJECT, which must
//    be free with RTpMgmtFreeMgmtObject function
//
//---------------------------------------------------------
static
BOOL
RTpMgmtObjectNameToMgmtObject(
    LPCWSTR lpwstrObjectName,
    LPWSTR* ppStringToFree,
    MGMT_OBJECT* pObj,
    QUEUE_FORMAT* pqf
    )
{

    //
    // Handle MACHINE= case
    //
    if(_wcsnicmp(lpwstrObjectName, MO_MACHINE_TOKEN, STRLEN(MO_MACHINE_TOKEN)) == 0)
    {
        pObj->type = MGMT_MACHINE;
        pObj->dwMachineInfo = 0;
        return TRUE;
    }

    //
    // Handle QUEUE= case
    // 
    if(_wcsnicmp(lpwstrObjectName, MO_QUEUE_TOKEN, STRLEN(MO_QUEUE_TOKEN)) == 0)
    {
        pObj->type = MGMT_QUEUE;
        pObj->pQueueFormat = pqf;
        return RTpFormatNameToQueueFormat(
                    &lpwstrObjectName[STRLEN(MO_QUEUE_TOKEN) + 1],
                    pqf,
                    ppStringToFree
                    );
    }

    return FALSE;
}


static
HRESULT
RTpMgmtAction(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    LPCWSTR pAction
    )
{
    RpcTryExcept
    {
    	return R_QMMgmtAction(
                hBind,
                pMgmtObj, 
                pAction
                );

    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        HRESULT rc;
        rc = GetExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;;

        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
	RpcEndExcept
}


HRESULT
RemoteMgmtAction(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Call remote administrator
    //
    HRESULT hr;
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtAction(hBind, pMgmtObj, pAction)
        );

    return hr;
}


EXTERN_C
HRESULT
APIENTRY
DepMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pObjectName);
    ASSERT(pAction);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    try
    {
    	if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
	    {
	        return MQ_ERROR_ILLEGAL_FORMATNAME;
	    }
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "RTpMgmtObjectNameToMgmtObject threw an exception");
    	return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

	CMQHResult rc;
    if (pMachineName == NULL)
    {
       return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    else
    {
        rc = RemoteMgmtAction(pMachineName, &MgmtObj, pAction);
        return rc;
    }
}


static
HRESULT
RTpMgmtGetInfo(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    MQMGMTPROPS* pMgmtProps
    )
{
    RpcTryExcept
    {
    	return R_QMMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps->cProp,
                pMgmtProps->aPropID,
                pMgmtProps->aPropVar
                );

    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        HRESULT rc;
        rc = GetExceptionCode();
		PRODUCE_RPC_ERROR_TRACING;
		
        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
	RpcEndExcept
}


static
HRESULT
RemoteMgmtGetInfo(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr;

    //
    // Call remote administrator
    //
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtGetInfo(hBind, pMgmtObj, pMgmtProps)
        );

    return hr;
}


EXTERN_C
HRESULT
APIENTRY
DepMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pObjectName);
    ASSERT(pMgmtProps);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    try
    {
	    if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
	    {
	        return MQ_ERROR_ILLEGAL_FORMATNAME;
	    }
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "RTpMgmtObjectNameToMgmtObject threw an exception");
    	return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure the propvar is set to VT_NULL 
    // (we dont support anything else)
    //
    memset(pMgmtProps->aPropVar, 0, pMgmtProps->cProp * sizeof(PROPVARIANT));
    for (DWORD i = 0; i < pMgmtProps->cProp; ++i)
    {
        pMgmtProps->aPropVar[i].vt = VT_NULL;
    }

	CMQHResult rc;
    if (pMachineName == NULL)
    {
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    else
    {
        rc = RemoteMgmtGetInfo(pMachineName, &MgmtObj, pMgmtProps);
        return rc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtrpc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtrpc.cpp

Abstract:

    Rpc related stuff.

Author:

    Doron Juster (DoronJ)  04-Jun-1997

Revision History:

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "mqsocket.h"
#include "ad.h"
#include "rtfrebnd.h"
#include "rtprpc.h"
#include "mgmtrpc.h"
#include "acrt.h"
#include <mqsec.h>

#include "rtrpc.tmh"

CFreeRPCHandles  g_cFreeRpcHandles ;

//
// Fix rpc ports (debug mode), read from registry.
//
#define  MAX_RPC_PORT_LEN  12
static TCHAR   s_wszRpcIpPort[ MAX_RPC_PORT_LEN ] ;
static TCHAR   s_wszRpcIpxPort[ MAX_RPC_PORT_LEN ] ;

static TCHAR   s_wszRpcIpPort2[ MAX_RPC_PORT_LEN ] ;
static TCHAR   s_wszRpcIpxPort2[ MAX_RPC_PORT_LEN ] ;

//
// The binding string MUST be global and kept valid all time.
// If we create it on stack and free it after each use then we can't
// create more then one binding handle.
// Don't ask me (DoronJ) why, but this is the case.
//
TBYTE* g_pszStringBinding = NULL ;
TBYTE* g_pszStringBinding2= NULL ;

//
//  Critical Section to make RPC thread safe.
//
CCriticalSection CRpcCS ;

//
//  License related data.
//
GUID  g_LicGuid ;
BOOL  g_fLicGuidInit = FALSE ;

//
//  Tls index for canceling RPC calls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff
DWORD  g_hThreadIndex = UNINIT_TLSINDEX_VALUE ;


//
// Local endpoints to QM
//
AP<WCHAR> g_pwzQmsvcEndpoint = 0;
AP<WCHAR> g_pwzQmsvcEndpoint2 = 0;
AP<WCHAR> g_pwzQmmgmtEndpoint = 0;


//---------------------------------------------------------
//
//  RTpUnbindQMService(...)
//
//  Description:
//
//      Set RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void RTpUnbindQMService()
{
   handle_t hBind = tls_hBindRpc;
   g_cFreeRpcHandles.Add(hBind);
   BOOL fSet = TlsSetValue( g_hBindIndex, NULL);
   ASSERT(fSet);
   DBG_USED(fSet);
}

//---------------------------------------------------------
//
//  RTpGetLocalQMBind(...)
//
//  Description:
//
//      Create RPC binding handle to a local QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetLocalQMBind( TBYTE** ppStringBinding,
                            LPTSTR  pEndpoint)
{
      RPC_STATUS rc;
      if(!*ppStringBinding)
      {
          rc = RpcStringBindingCompose(
              0,
              RPC_LOCAL_PROTOCOL,
              0,
              pEndpoint,
              RPC_LOCAL_OPTION,
              ppStringBinding
              );

          ASSERT(rc == RPC_S_OK);
      }

      handle_t hBind = 0;
      rc = RpcBindingFromStringBinding(*ppStringBinding, &hBind);
      ASSERT(rc == RPC_S_OK);

      return hBind;
}

//---------------------------------------------------------
//
//  RTpGetQMServiceBind(...)
//
//  Description:
//
//      Create RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetQMServiceBind(BOOL fAlternate /*= FALSE*/)
{
    handle_t hBind = 0;
    CS Lock(CRpcCS);

    g_cFreeRpcHandles.FreeAll();

    if (g_fDependentClient)
    {
        HRESULT hr ;
        LPWSTR lpServer = &g_wszRemoteQMName[0];
        ULONG _eAuthnLevel = MQSec_RpcAuthnLevel();

        hr =  RTpBindRemoteQMService(
                       lpServer,
                       &hBind,
                       &_eAuthnLevel,
                       fAlternate
                       );

        if (FAILED(hr))
        {
           ASSERT(hBind == 0);
           hBind = 0;
        }
    }
    else
    {
        if(fAlternate)
        {
            //
            //  Alternate End point is used for receives on win95, so we will
            //  get the correct rundown when the application crashes.
            //  Work only with DCOM95.
            //
            hBind = RTpGetLocalQMBind(&g_pszStringBinding2, g_pwzQmsvcEndpoint2.get());
        }
        else
        {
            hBind = RTpGetLocalQMBind(&g_pszStringBinding, g_pwzQmsvcEndpoint.get());
        }
    }

    return hBind;
}

//---------------------------------------------------------
//
//  RTpBindQMService(...)
//
//  Description:
//
//      Set RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void RTpBindQMService()
{
    handle_t hBind = RTpGetQMServiceBind();

    BOOL fSet = TlsSetValue(g_hBindIndex, hBind);
    ASSERT(fSet) ;
	DBG_USED(fSet);
}

enum DirectQueueType
{
    dqtNONE = 0,
    dqtTCP  = 1,
    dqtSPX  = 2,
    dqtANY  = 3
};

DirectQueueType
GetDirectQueueType (
    LPWSTR* lpwsDirectQueuePath
    )
{

    if (!_wcsnicmp(*lpwsDirectQueuePath, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN))
    {
        *lpwsDirectQueuePath += FN_DIRECT_TCP_TOKEN_LEN;
        return dqtTCP;
    }
    if (!_wcsnicmp(*lpwsDirectQueuePath, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN))
    {
        *lpwsDirectQueuePath += FN_DIRECT_OS_TOKEN_LEN;
        return dqtANY;
    }

    return (dqtNONE);

}

static
HRESULT ExtractMachineName(
    LPWSTR pQueue,
    AP<WCHAR> &pMachine
    )
{
    //
    // If the remote queue is a direct queue, the routine removes
    // the direct queue type from the queue name. (it keeps with the
    // direct type in the QM to distinguish between different queues).
    // The routine below extract the machine name from the queue name
    // and create the RPC call. If the direct queue type is "TCP" or "SPX"
    // the routine also return the protocol type;
    //
    switch(GetDirectQueueType(&pQueue))
    {
        case dqtTCP:
        case dqtANY:
        case dqtNONE:
            {
                LPWSTR lpwcsSlash = wcschr(pQueue, L'\\') ;
                size_t MachineNameLen = 0 ;
                if (lpwcsSlash)
                {
                    MachineNameLen = lpwcsSlash - pQueue;
                }
                else
                {
                    MachineNameLen = wcslen(pQueue);
                }
                pMachine = new WCHAR[MachineNameLen + 1];
                wcsncpy(pMachine, pQueue, MachineNameLen) ;
                pMachine[MachineNameLen] = '\0';

                return MQ_OK;
            }

        case dqtSPX:
            {

                //
                // For SPX address, remove the ':' from the name
                // need for direct read from SPX direct format name
                //                   Uri Habusha (urih), 15-Sep-98
                //
                LPWSTR pSeparator  = wcschr(pQueue, L':');
				if(pSeparator == NULL)
				{
					TrERROR(GENERAL, "Bad queue name. Missing ':' in SPX address, %ls", pQueue);
					ASSERT(("Bad queue name. Missing ':' in SPX address", 0));
					return MQ_ERROR_INVALID_PARAMETER;
				}

                size_t size = pSeparator - pQueue;

                LPWSTR pQueue2 = pSeparator + 1;
                LPWSTR pSeparator2 = wcschr(pQueue2, L'\\') ;
				if(pSeparator2 == NULL)
				{
					TrERROR(GENERAL, "Bad queue name. Missing '\\' in SPX address, %ls", pQueue);
					ASSERT(("Bad queue name. Missing '\\' in SPX address", 0));
					return MQ_ERROR_INVALID_PARAMETER;
				}
                
				size_t size2 = pSeparator2 - pQueue2;

                pMachine = new WCHAR[wcslen(pQueue) + 2];

                LPWSTR pTempMachine = pMachine;

                wcscpy(pTempMachine, L"~");
                pTempMachine += 1;

                wcsncpy(pTempMachine, pQueue, size);
                pTempMachine += size;

                wcsncpy(pTempMachine, pQueue2, size2);
                pTempMachine += size2;

                *pTempMachine = L'\0';

                return MQ_OK;
            }

		default:
			ASSERT(0);
			return MQ_ERROR;
    }
}

//---------------------------------------------------------
//
//  RTpBindRemoteQMService(...)
//
//  Description:
//
//      Create RPC binding handle to a remote QM service.
//      First try IP then IPx.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT ULONG *peAuthnLevel,
    IN  BOOL       fAlternate /*= FALSE*/
    )
{
    AP<WCHAR> wszServer = NULL ;

    HRESULT hr = ExtractMachineName(lpwNodeName, wszServer) ;
	if(FAILED(hr))
		return hr;

    PORTTYPE PortType = IP_HANDSHAKE;

    if (fAlternate)
    {
       PortType = IP_READ;
    }
    else
    {
       PortType = IP_HANDSHAKE;
    }

	GetPort_ROUTINE pfnGetPort = R_QMGetRTQMServerPort;
	
    //
    // Choose authentication service. For LocalSystem services, chose
    // "negotiate" and let mqutil select between Kerberos or ntlm.
    // For all other cases, use ntlm.
    // LocalSystem service go out to network without any credentials
    // if using ntlm, so only for it we're interested in Kerberos.
    // All other are fine with ntlm. For remote read we do not need
    // delegation, so we'll stick to ntlm.
    // The major issue here is a bug in rpc/security, whereas a nt4
    // user on a win2k machine can successfully call
    //  status = RpcBindingSetAuthInfoEx( ,, RPC_C_AUTHN_GSS_KERBEROS,,)
    // although it's clear he can't obtain any Kerberos ticket (he's
    // nt4 user, defined only in nt4 PDC).
    //
    ULONG   ulAuthnSvc = RPC_C_AUTHN_WINNT ;
    BOOL fLocalUser =  FALSE ;
    BOOL fLocalSystem = FALSE ;

    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem );
    if (SUCCEEDED(hr) && fLocalSystem)
    {
        ulAuthnSvc = MSMQ_AUTHN_NEGOTIATE;
    }

	hr = mqrpcBindQMService(wszServer,
                            NULL,
                            peAuthnLevel,
                            lphBind,
                            PortType,
                            pfnGetPort,
                            ulAuthnSvc ) ;

    return hr ;
}



//---------------------------------------------------------
//
//  InitRpcGlobals(...)
//
//  Description:
//
//      Initialize RPC related names and other constant data
//
//  Return Value:
//
//---------------------------------------------------------

BOOL InitRpcGlobals()
{
    //
    //  Allocate TLS for  RPC connection with local QM service
    //
    g_hBindIndex = TlsAlloc() ;
    ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hBindIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }

	BOOL fSet = TlsSetValue( g_hBindIndex, NULL ) ;
	if(!fSet)
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to store a value in TLS. %!winerr!", gle);
		return FALSE;
	}
	
    if (g_fDependentClient)
    {
		HRESULT hr1 = ADInit(
			NULL,
			RTpGetSupportServerInfo,
			false,
			false,
			false,
            false   // fDisableDownlevelNotifications
            );

		if FAILED(hr1)
		{
			TrERROR(GENERAL, "Failed to init AD. %!hresult!", hr1);
			return FALSE;
		}
    }


    //
    // Initialize local endpoints to QM
    //

    ComposeRPCEndPointName(QMMGMT_ENDPOINT, NULL, &g_pwzQmmgmtEndpoint);

    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
    ComposeRPCEndPointName(wzEndpoint, NULL, &g_pwzQmsvcEndpoint);

    if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
        (g_fDependentClient))
    {
        READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME2, RPC_LOCAL_EP2);
        ComposeRPCEndPointName(wzEndpoint, NULL, &g_pwzQmsvcEndpoint2);
    }


    //
    // Read QMID. Needed for licensing.
    //
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue( MSMQ_QMID_REGNAME,
                            &dwValueType,
                            &g_LicGuid,
                            &dwValueSize);

    if (rc == ERROR_SUCCESS)
    {
        g_fLicGuidInit = TRUE ;
        ASSERT((dwValueType == REG_BINARY) &&
               (dwValueSize == sizeof(GUID)));
    }

    //
    //  Allocate TLS for  cancel remote-read RPC calls
    //
    g_hThreadIndex = TlsAlloc() ;
    ASSERT(g_hThreadIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hThreadIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }

    fSet = TlsSetValue( g_hThreadIndex, NULL ) ;
    if(!fSet)
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to store a value in TLS. %!winerr!", gle);
		return FALSE;
	}

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtsecutl.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.h

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 19, 1997

--*/

extern PMQSECURITY_CONTEXT g_pSecCntx ;

extern void InitSecurityContext() ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <rtdep.h>
#include <mqlog.h>

#include "rtp.h"

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtsecutl.cpp ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.cpp

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 18, 1997

--*/

#include "stdh.h"
#include "cs.h"

#include "rtsecutl.tmh"

PMQSECURITY_CONTEXT g_pSecCntx = NULL ;

static CCriticalSection s_security_cs;

void InitSecurityContext()
{

    CS lock(s_security_cs);

    if(g_pSecCntx != 0)
    {
        return;
    }

    //
    // Allocate the structure for the chached process security context.
    //
	PMQSECURITY_CONTEXT pSecCntx = new MQSECURITY_CONTEXT;

    //
    //  Get the user's SID and put it in the chaed process security context.
    //
    RTpGetThreadUserSid(&pSecCntx->fLocalUser,
                        &pSecCntx->fLocalSystem,
                        &pSecCntx->pUserSid,
                        &pSecCntx->dwUserSidLen);

    //
    // Get the internal certificate of the process and place all the
    // information for this certificate in the chached process security
    // context.
    //
    HRESULT hr = GetCertInfo( FALSE,
                 pSecCntx->fLocalSystem,
                &pSecCntx->pUserCert,
                &pSecCntx->dwUserCertLen,
                &pSecCntx->hProv,
                &pSecCntx->wszProvName,
                &pSecCntx->dwProvType,
                &pSecCntx->bDefProv,
                &pSecCntx->bInternalCert ) ;
  
		
	if( FAILED(hr) )
	{	
        TrERROR(SECURITY, "GetCertInfo() failed, Error: %!hresult!", hr);
	}
	
	
    //
    //  Set the global security context only after getting all information
    //  it is checked outside the critical (in other scope) seciton to get
    //  better performance
    //
    g_pSecCntx = pSecCntx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#define   INITGUID	
#include "initguid.h"

#define _MTX_NOFORCE_LIBS 
#include "comsvcs.h"
#include "TXDTC.H"

#include "xactmq.h"
#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtsecctx.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtsecctx.cpp

Abstract:

    This module implements the DepGetSecurityContext() and
    DepFreeSecurityContext() apis.

Author:

    Original version from message.cpp.
    Doron Juster (DoronJ)  12-Aug-1998

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <mqsec.h>

#include "rtsecctx.tmh"

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for DepGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CTX_ERROR
#endif

//+--------------------------------------------
//
// The constractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::MQSECURITY_CONTEXT() :
                dwVersion(SECURITY_CONTEXT_VER),
                dwUserSidLen(0),
                dwUserCertLen(0),
                dwProvType(0),
                bDefProv(TRUE),
                bInternalCert(TRUE),
                fAlreadyImported(FALSE),
                dwPrivateKeySize(0),
                fLocalSystem(FALSE),
                fLocalUser(FALSE)
{
}

//+--------------------------------------------
//
// The destractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::~MQSECURITY_CONTEXT()
{
    if (fAlreadyImported)
    {
        CryptReleaseContext( hProv, 0 ) ;
        hProv = NULL ;

        //
        // delete the temporary keyset which was created before
        // importing the private key.
        //
        CryptAcquireContext( &hProv,
                              wszContainerName,
                              wszProvName.get(),
                              dwProvType,
                              CRYPT_DELETEKEYSET ) ;
        hProv = NULL ;
    }
}

//+-------------------------------
//
//  AllocSecurityContext()
//
//+-------------------------------

PMQSECURITY_CONTEXT
AllocSecurityContext()
{
    PMQSECURITY_CONTEXT pSecCtx =  new MQSECURITY_CONTEXT;
    return pSecCtx ;
}

//+---------------------------------------------------------------
//
//  BOOL SameAsProcessSid( PSID pSid )
//
//  Return TRUE if input sid is equal to sid of process token.
//
//+---------------------------------------------------------------

BOOL SameAsProcessSid( PSID pSid )
{
    AP<BYTE>  ptu = NULL ;
    CAutoCloseHandle  hAccessToken = NULL ;

    BOOL f = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hAccessToken ) ;
    if (!f)
    {
        //
        // return false.
        // if thread can't open the process token then it's probably
        // impersonating a user that don't have the permission to do that.
        // so it's not the process user.
        //
        return FALSE ;
    }

    DWORD dwLen = 0 ;
    GetTokenInformation(hAccessToken, TokenUser, NULL, 0, &dwLen);
    DWORD dwErr = GetLastError() ;

    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        ptu = new BYTE[ dwLen ] ;
        f = GetTokenInformation( hAccessToken,
                                 TokenUser,
                                 ptu.get(),
                                 dwLen,
                                 &dwLen) ;
        ASSERT(f) ;
        if (!f)
        {
            return FALSE ;
        }

        PSID pUser = ((TOKEN_USER*)(BYTE*)(ptu.get()))->User.Sid;
        f = EqualSid(pSid, pUser) ;
        return f ;
    }

    return FALSE ;
}

//+----------------------------------------------------------------
//
//  HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
//
//+----------------------------------------------------------------

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
{
    CS Lock(pSecCtx->CS) ;

    if (pSecCtx->fAlreadyImported)
    {
        //
        // this condition may happen if two threads call MQSend() at the
        // same time, using a new security context which was not yet
        // imported.
        //
        return MQ_OK ;
    }

    if (!(pSecCtx->pPrivateKey.get()))
    {
        //
        // there is no private key to import.
        //
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Build name of key container. Combine ProcessID with SID.
    //
    LONG lNum = InterlockedIncrement(&s_lCtxSerialNumber) ;
    swprintf( pSecCtx->wszContainerName,
              L"P-%lu-C-%lu", GetCurrentProcessId(), (DWORD) lNum) ;
    //
    // Delete key container if already exist. That's something left
    // from previous processes which didn't clean up.
    //
    HCRYPTPROV hProv = NULL ;
    CryptAcquireContext( &hProv,
                          pSecCtx->wszContainerName,
                          pSecCtx->wszProvName.get(),
                          pSecCtx->dwProvType,
                          CRYPT_DELETEKEYSET ) ;

    //
    // Create the key container.
    //
    BOOL f = CryptAcquireContext( &pSecCtx->hProv,
                                   pSecCtx->wszContainerName,
                                   pSecCtx->wszProvName.get(),
                                   pSecCtx->dwProvType,
                                   CRYPT_NEWKEYSET ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Import the private key into the container.
    //
    HCRYPTKEY hKey = NULL ;
    f = CryptImportKey( pSecCtx->hProv,
                        pSecCtx->pPrivateKey,
                        pSecCtx->dwPrivateKeySize,
                        0,
                        0,
                        &hKey ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }
    CryptDestroyKey(hKey) ;

    pSecCtx->fAlreadyImported = TRUE ;
    return MQ_OK ;
}

//+--------------------------------------
//
//  HRESULT  RTpExportSigningKey()
//
//+--------------------------------------

HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx)
{
    CHCryptKey hKey = NULL ;

    BOOL f = CryptGetUserKey( pSecCtx->hProv,
         pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
                              &hKey ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Get size need for exporting the private key blob.
    //
    pSecCtx->dwPrivateKeySize = 0 ;
    f = CryptExportKey( hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        NULL,
                        &pSecCtx->dwPrivateKeySize ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    pSecCtx->pPrivateKey = new BYTE[ pSecCtx->dwPrivateKeySize ] ;
    f = CryptExportKey( hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        pSecCtx->pPrivateKey.get(),
                        &pSecCtx->dwPrivateKeySize ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Release the CSP context handle. We don't need it anymore.
    // We'll acquire it again when importing the key.
    //
    CryptReleaseContext( pSecCtx->hProv, 0 ) ;
    pSecCtx->hProv = NULL ;

    return MQ_OK ;
}

/***********************************************************************
*
*   Function - DepGetSecurityContext()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in DepSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of DepSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to DepSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call DepFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
DepGetSecurityContext( LPVOID  lpCertBuffer,
                      DWORD   dwCertBufferLength,
                      HANDLE *hSecurityContext )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    P<BYTE>    pSid = NULL ;
    HRESULT hr = MQ_OK;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return(hr);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert.detach();
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert.get(), lpCertBuffer, dwCertBufferLength);
        }

		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
        hr  = GetCertInfo(  false,
                            pSecCtx->fLocalSystem,
                           ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return(hr);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail DepGetSecurityContext().
            // DepSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = MQSec_GetThreadUserSid(
                        FALSE,
                        reinterpret_cast<PSID*>(&pSid),
                        &dwLen,
                        FALSE           // fThreadTokenOnly
                        ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        BOOL fAsProcess = SameAsProcessSid( pSid.get() ) ;

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *hSecurityContext = (HANDLE) pSecCtx.get() ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx.get()) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return(hr);
}

/*************************************************************************
*
*    Function -  DepFreeSecurityContext()
*
*    Parameters -
*        lpSecurityContextBuffer - A pointer to a security context that was
*        previously allocated by DepGetSecurityContext.
*
*    Description -
*        The function frees the security context that was previously
*        allocated by DepGetSecurityContext().
*
**************************************************************************/

void APIENTRY
DepFreeSecurityContext( HANDLE hSecurityContext )
{
	ASSERT(g_fDependentClient);

	if(FAILED(DeppOneTimeInit()))
		return;

    PMQSECURITY_CONTEXT pSecCtx = (PMQSECURITY_CONTEXT)hSecurityContext;
    delete pSecCtx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\rtutil.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtutil.cpp

Abstract:

    Contains various utility functions.

Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

    Erez Haba (erezh) 17-Jan-1997

--*/

#include "stdh.h"
#include "acrt.h"
#include <mqdbmgr.h>
#include <ad.h>
#include <mqsec.h>

#include "rtutil.tmh"

//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePropVar
//
//  Description:
//      Find a queue property in the properties array
//
//---------------------------------------------------------
PROPVARIANT*
RTpGetQueuePropVar(
    PROPID PropID,
    MQQUEUEPROPS *pqp
    )
{
    DWORD i;
    DWORD cProp;
    PROPID *aPropID;

    for (i = 0, cProp = pqp->cProp, aPropID = pqp->aPropID;
         i < cProp;
         i++, aPropID++) {

        if (*aPropID == PropID) {
            return(&(pqp->aPropVar[i]));
        }

    }

    return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathNamePropVar
//
//  Description:
//      Find a the queue path name property in the properties array
//
//---------------------------------------------------------
LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_PATHNAME, pqp)) != NULL)
        return(p->pwszVal);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueueGuidPropVar
//
//  Description:
//      Find the queue guid (instance) property in the properties array
//
//---------------------------------------------------------
GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_INSTANCE, pqp)) != NULL)
        return(p->puuid);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpMakeSelfRelativeSDAndGetSize
//
//  Parameters:
//      pSecurityDescriptor - The input security descriptor.
//      pSelfRelativeSecurityDescriptor - A pointer to a temporary buffer
//          that holds the converted security descriptor.
//      pSDSize - A pointer to a variable that receives the length of the
//          self relative security descriptor. This is an optional parameter.
//
//  Description:
//      Convert an absolute security descriptor to a self relative security
//      descriptor and get the size of the self relative security descriptor.
//      This function should be call before passing a security descriptor to
//      a function that passes the security descriptor to an RPC function.
//
//      If the input security descriptor is already a self relative security
//      descriptor, the function only computes the length of the security
//      descriptor and returns. If the input security descriptor is an absolute
//      security descriptor, the function allocates a buffer large enough to
//      accomodate the self relative security descripr, converts the absolute
//      security descriptor to a self relative security descriptor and modifies
//      the pointer of the input security descriptor to point to the self relative
//      security descriptor.
//
//      The temporar buffer that is being allocated for the self relative
//      security descriptor should be freed by the calling code.
//
//---------------------------------------------------------
HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize)
{
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD dwSDRevision;

    ASSERT(pSecurityDescriptor);
    ASSERT(pSelfRelativeSecurityDescriptor);

    *pSelfRelativeSecurityDescriptor = NULL;

    if (!*pSecurityDescriptor)
    {
        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = 0;
        }
        return(MQ_OK);
    }

    // Verify that this is a valid security descriptor.
    if (!IsValidSecurityDescriptor(*pSecurityDescriptor))
    {
        return(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR);
    }

    // Check whether this is a self relative or absolute security
    // descriptor.
    if (!GetSecurityDescriptorControl(*pSecurityDescriptor,
                                      &sdcSDControl,
                                      &dwSDRevision))
    {
        ASSERT(FALSE);
    }

    if (!(sdcSDControl & SE_SELF_RELATIVE))
    {
        // This is an absolute security descriptor, we should convert it
        // to a self relative one.
        DWORD dwBufferLength = 0;

#ifdef _DEBUG
        SetLastError(0);
#endif
        // Get the buffer size.
        MakeSelfRelativeSD(*pSecurityDescriptor, NULL, &dwBufferLength);
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        // Allocate the buffer for the self relative security descriptor.
        *pSelfRelativeSecurityDescriptor =
            (PSECURITY_DESCRIPTOR) new char[dwBufferLength];

        // Convert the security descriptor.
        if (!MakeSelfRelativeSD(
                *pSecurityDescriptor,
                *pSelfRelativeSecurityDescriptor,
                &dwBufferLength))
        {
            ASSERT(FALSE);
        }
        ASSERT(IsValidSecurityDescriptor(*pSelfRelativeSecurityDescriptor));
        *pSecurityDescriptor = *pSelfRelativeSecurityDescriptor;

        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = dwBufferLength;
        }

    }
    else
    {

        // The security descriptor is already in self relative format, just
        // set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = GetSecurityDescriptorLength(*pSecurityDescriptor);
        }

    }

    return(MQ_OK);
}


//---------------------------------------------------------
//
//  Function:
//     RTpConvertToMQCode
//
//  Parameters:
//      hr - Error vode that is generated by any kind of module.
//
// Return value:
//      The imput parameter convetrted to some equivalent MQ_ERROR constant.
//
//---------------------------------------------------------
HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType
    )
{

    if ((hr == MQ_OK)                                   ||
        (hr == MQ_INFORMATION_REMOTE_OPERATION)         ||
        (hr == MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED)   ||
        ((MQ_E_BASE <= hr) && (hr < MQ_E_BASE + 0x100)) ||
        ((MQ_I_BASE <= hr) && (hr < MQ_I_BASE + 0x100)))
    {
        // This is our codes, do not modify it.
        return(hr);
    }

    if (hr == MQDS_OK_REMOTE)
    {
        //
        // success - we use MQDS_OK_REMOTE for internal use, e.g. explorer
        //
        return(MQ_OK);
    }

    if (HRESULT_FACILITY(MQ_E_BASE) == HRESULT_FACILITY(hr))
    {
        switch (hr)
        {
        case MQDB_E_NO_MORE_DATA:
        case MQDS_GET_PROPERTIES_ERROR:
        case MQDS_OBJECT_NOT_FOUND:
            hr = (dwObjectType ==  MQDS_QUEUE) ?
                    MQ_ERROR_QUEUE_NOT_FOUND :
                    MQ_ERROR_MACHINE_NOT_FOUND;
            break;

        case MQDS_NO_RSP_FROM_OWNER:
            hr = MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER;
            break;

        case MQDS_OWNER_NOT_REACHED:
            hr = MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE;
            break;

        case MQDB_E_NON_UNIQUE_SORT:
            hr = MQ_ERROR_ILLEGAL_SORT;
            break;

        default:
            // Some DS error occured. This should not happen, but anyway...
            TrWARNING(GENERAL, "A DS error (%x) has propagated to the RT DLL. Converting to MQ_ERROR_DS_ERROR", hr);
            hr = MQ_ERROR_DS_ERROR;
            break;
        }

        return(hr);
    }

    if (hr == CPP_EXCEPTION_CODE)
    {
        // A C++ exception occured. This can happen only when in an allocation failure.
        return(MQ_ERROR_INSUFFICIENT_RESOURCES);
    }

    // Now we hope that we know how to convert an NTSTATUS to some of our error
    // codes. Good luck...
    switch(hr)
    {
    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        hr = MQ_ERROR_INVALID_HANDLE;
        break;

    case STATUS_ACCESS_DENIED:
        hr = MQ_ERROR_ACCESS_DENIED;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_PARAMETER:
        hr = MQ_ERROR_INVALID_PARAMETER;
        break;

    case STATUS_SHARING_VIOLATION:
        hr = MQ_ERROR_SHARING_VIOLATION;
        break;

    case STATUS_PENDING:
        hr = MQ_INFORMATION_OPERATION_PENDING;
        break;

    case STATUS_CANCELLED:
        hr = MQ_ERROR_OPERATION_CANCELLED;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        break;

    default:
       TrWARNING(GENERAL, "Unfamiliar error code:%x, not converted to a MQ error", hr);
       break;
    }

    return(hr);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetThreadUserSid
//
//  Parameters:
//      pUserSid - A pointer to a buffer that receives the address of a buffer
//          that contains the SID of the user of the current thread.
//      pdwUserSidLen - A pointer to a DWORD that receives the length of the
//          SID.
//
//  Description:
//      The function allocates the buffer for the SID and fils it with the SID
//      of the user of the current thread. The calling code is responsible for
//      freeing the allocated buffer.
//
//---------------------------------------------------------

HRESULT
RTpGetThreadUserSid( BOOL    *pfLocalUser,
                     BOOL    *pfLocalSystem,
                     LPBYTE  *pUserSid,
                     DWORD   *pdwUserSidLen )
{
    HRESULT hr;

    hr = MQSec_GetUserType( NULL,
                            pfLocalUser,
                            pfLocalSystem );
    if (FAILED(hr))
    {
        return(hr);
    }

    if (*pfLocalSystem)
    {
        *pUserSid = (LPBYTE) MQSec_GetLocalMachineSid( TRUE, // allocate
                                                       pdwUserSidLen ) ;
        if (!(*pUserSid))
        {
            //
            // this may happen if the machine belong to a NT4 domain
            // and it doesn't have any computer account and sid.
            // In that case, make it a local user.
            //
            ASSERT(*pdwUserSidLen == 0) ;
            *pdwUserSidLen = 0 ;

            *pfLocalSystem = FALSE ;
            if (pfLocalUser)
            {
                ASSERT(!(*pfLocalUser)) ;
                *pfLocalUser = TRUE ;
            }
        }
    }
    else if (!(*pfLocalUser))
    {
        hr = MQSec_GetThreadUserSid(
                        FALSE,
                        reinterpret_cast<PSID*>(pUserSid),
                        pdwUserSidLen,
                        FALSE           // fThreadTokenOnly
                        );
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\xactmq.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.h

Abstract:
    This module defines CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTMQ_H__
#define __XACTMQ_H__

//IID_IMSMQTransaction 2f221ca0-d1de-11d0-9215-0060970536a0
DEFINE_GUID(IID_IMSMQTransaction,
		    0x2f221ca0,
		    0xd1de,
		    0x11d0,
		    0x92, 0x15, 0x00, 0x60, 0x97, 0x05, 0x36, 0xa0);

interface IMSMQTransaction : public IUnknown
{
public:
    virtual HRESULT __stdcall EnlistTransaction(XACTUOW *pUow) = 0;
};


//---------------------------------------------------------------------
// CMQTransaction: Transaction Object in Falcon RT
//---------------------------------------------------------------------
class CMQTransaction: public ITransaction, 
                      public IMSMQTransaction
{
public:

    // Construction and COM
    //
    CMQTransaction();
    ~CMQTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    STDMETHODIMP Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
    STDMETHODIMP Abort( 
            /* [in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
    STDMETHODIMP  GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO *pinfo);

    STDMETHODIMP   EnlistTransaction(
            /* in]  */  XACTUOW *pUow);

private:
    LONG    m_cRefs;
    BOOL    m_fCommitedOrAborted;       
    XACTUOW m_Uow;

    RPC_INT_XACT_HANDLE m_hXact;
};

#endif __XACTMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\xactmq.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.cpp

Abstract:
    This module implements CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "txdtc.h"
#include "rtprpc.h"
#include "XactMq.h"

#include "xactmq.tmh"

static WCHAR *s_FN=L"rtdep/xactmq";

extern    BOOL g_fClient;

//---------------------------------------------------------------------
// CMQTransaction::CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::CMQTransaction()
{
    m_cRefs = 1;
    m_fCommitedOrAborted = FALSE;
    m_hXact = NULL;
    UuidCreate((UUID *)&m_Uow);
}

//---------------------------------------------------------------------
// CMQTransaction::~CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::~CMQTransaction(void)
{
    if (!m_fCommitedOrAborted)
    {
        Abort(NULL, FALSE, FALSE);
    }
}

//---------------------------------------------------------------------
// CMQTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CMQTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {
        *ppv = (IUnknown *)((ITransaction *)this);
    }
    else if (IID_ITransaction == i_iid)
    {
        *ppv = (ITransaction *)this;
    }
    else if (IID_IMSMQTransaction == i_iid)
    {
        *ppv = (IMSMQTransaction *)this;
    }


    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return E_NOINTERFACE;       // from winerror.h
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CMQTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);               // Increment interface usage count.
}


//---------------------------------------------------------------------
// CMQTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::Release(void)
{
    // Is anyone using the interface?
    if (InterlockedDecrement(&m_cRefs))
    {                               // The interface is in use.
        return m_cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}


//---------------------------------------------------------------------
// CMQTransaction::Commit
//---------------------------------------------------------------------
HRESULT CMQTransaction::Commit(BOOL fRetaining, DWORD grfTC, DWORD grfRM)
{
   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
	HRESULT rc;

	if ((grfTC != 0 && grfTC != XACTTC_SYNC) ||
		grfRM != 0 || fRetaining != FALSE)
	{
		return XACT_E_NOTSUPPORTED;
	}

	RpcTryExcept
	{
		rc = R_QMCommitTransaction(&m_hXact);
		m_fCommitedOrAborted = TRUE;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		PRODUCE_RPC_ERROR_TRACING;
		rc = (RpcExceptionCode() == RPC_S_CALL_FAILED)? XACT_E_INDOUBT : E_FAIL;
	}
	RpcEndExcept

	return rc;
}

//---------------------------------------------------------------------
// CMQTransaction::Abort
//---------------------------------------------------------------------
HRESULT CMQTransaction::Abort(BOID* /*pboidReason*/, BOOL fRetaining, BOOL fAsync)
{
	if (fAsync || fRetaining)
	{
		return XACT_E_NOTSUPPORTED;
	}

	//------------------------------------------------------------
	// RPC call to QM for prepare/commit
	//------------------------------------------------------------
	HRESULT rc;

	RpcTryExcept
	{
		rc = R_QMAbortTransaction(&m_hXact);
		m_fCommitedOrAborted = TRUE;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		PRODUCE_RPC_ERROR_TRACING;
		rc = E_FAIL;
	}
	RpcEndExcept

	return rc;
}

//---------------------------------------------------------------------
// CMQTransaction::GetTransactionInfo
//---------------------------------------------------------------------
HRESULT CMQTransaction::GetTransactionInfo(XACTTRANSINFO *pinfo)
{
    ZeroMemory((PVOID)pinfo, sizeof(XACTTRANSINFO));
    CopyMemory((PVOID)&pinfo->uow, (PVOID)&m_Uow, sizeof(XACTUOW));
    return MQ_OK;
}

//---------------------------------------------------------------------
// CMQTransaction::EnlistTransaction
//---------------------------------------------------------------------
HRESULT CMQTransaction::EnlistTransaction(XACTUOW *pUow)
{

    HRESULT hr;

    // No need for several enlistments
    if (m_hXact)
    {
        return MQ_OK;
    }

    // RPC call to QM for enlistment
    RpcTryExcept
    {
        INIT_RPC_HANDLE ;

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;

        hr = R_QMEnlistInternalTransaction(tls_hBindRpc, pUow, &m_hXact);
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
       DWORD rc = GetExceptionCode();
       TrERROR(XACT_GENERAL, "CMQTransaction::EnlistTransaction failed: RPC code=%x ", rc);
	   DBG_USED(rc);

	   PRODUCE_RPC_ERROR_TRACING;

       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
       m_hXact = NULL;
    }
	RpcEndExcept

    if(FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QMEnlistInternalTransaction failed: %x ", hr);
    }
    return hr;
}


//---------------------------------------------------------------------
//    DepBeginTransaction() - Generates new MSMQ internal transaction
//---------------------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
DepBeginTransaction(OUT ITransaction **ppTransaction)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = MQ_OK;
    ITransaction* pTransaction = NULL;
    try
    {
        pTransaction = new CMQTransaction;
    }
    catch(const bad_alloc&)
    {
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }


    if (SUCCEEDED(hr))
    {
        // We are not obliged to enlist immediately, but otherwise Commit for empty xact will fail
        XACTUOW Uow;

        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        if(FAILED(hr))
        {
           delete pTransaction;	
           TrERROR(XACT_GENERAL, "RTpProvideTransactionEnlist failed: %x ", hr);
           hr = MQ_ERROR_TRANSACTION_ENLIST;
        }
        else
        {
			*ppTransaction = pTransaction;
        }
    }

    return hr;
}

//---------------------------------------------------------------------
//    DepGetTmWhereabouts() - brings controlling DTC whereabouts
//    This is a private non-published function which we need outside of the DLL
//---------------------------------------------------------------------
HRESULT
DepGetTmWhereabouts(IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts)
{
	ASSERT(g_fDependentClient);

    HRESULT hr = MQ_OK;

    // RPC call to QM for getting whereabouts
    RpcTryExcept
    {
        INIT_RPC_HANDLE ;

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;

        hr = R_QMGetTmWhereabouts(tls_hBindRpc,
                                cbBufSize,
                                pbWhereabouts,
                                pcbWhereabouts);
    }
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
       DWORD rc = GetExceptionCode();
       TrERROR(XACT_GENERAL, "MQGetTmWhereabouts failed: RPC code=%x ", rc);
	   DBG_USED(rc);

	   PRODUCE_RPC_ERROR_TRACING;

       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
	RpcEndExcept

    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QMGetTmWhereabouts failed: %x ", hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\security\ui\mqcertui\certinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certinfo.cpp

Abstract:

    A dialog that shows the details of a certificate.

Author:

    Boaz Feldbaum (BoazF)   15-Oct-1996
    Doron Juster  (DoronJ)  15-Dec-1997, replace digsig with crypto2.0

--*/

#include <windows.h>
#include "prcertui.h"
#include "mqcertui.h"
#include "certres.h"
#include <winnls.h>
#include <cryptui.h>

#include <rt.h>
#include "automqfr.h"


extern "C"
void
ShowCertificate( HWND                hParentWnd,
                 CMQSigCertificate  *pCert,
                 DWORD               dwFlags)
{
    CRYPTUI_VIEWCERTIFICATE_STRUCT cryptView ;
    memset(&cryptView, 0, sizeof(cryptView)) ;

    cryptView.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT) ;
    cryptView.pCertContext = pCert->GetContext() ;

    cryptView.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
                        CRYPTUI_DISABLE_ADDTOSTORE ;

	cryptView.hwndParent = hParentWnd;

    switch (dwFlags)
    {
        case CERT_TYPE_INTERNAL:
            cryptView.dwFlags |= ( CRYPTUI_IGNORE_UNTRUSTED_ROOT |
                                   CRYPTUI_HIDE_HIERARCHYPAGE ) ;
            break;

        default:
            break ;
    }

    BOOL fChanged = FALSE ;
	CryptUIDlgViewCertificate( &cryptView, &fChanged ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\rtdep\xactrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    XactRT.cpp

Abstract:

    This module contains RT code involved with transactions.

Author:

    Alexander Dadiomov (alexdad) 19-Jun-96

Revision History:

--*/

#include "stdh.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "cs.h"
#include "mqutil.h"
#include "rtprpc.h"
#include "xactmq.h"

#include "xactrt.tmh"

static WCHAR *s_FN=L"rtdep/xactrt";


//RT transactions cache:  ring buffer of transaction UOWs
#define XACT_RING_BUF_SIZE   16                        // size of the transactions ring buffer

static  XACTUOW  s_uowXactRingBuf[XACT_RING_BUF_SIZE];   // transaction ring buffer

ULONG   s_ulXrbFirst =  XACT_RING_BUF_SIZE;  // First used element in transaction ring buffer
ULONG   s_ulXrbLast  =  XACT_RING_BUF_SIZE;  // Last  used element in transaction ring buffer

static BOOL             g_DtcInit = FALSE;
static ULONG            g_StubRmCounter = 0;

static CCriticalSection s_RingBufCS;

// Whereabouts of the controlling DTC for the QM
// For the dependent client it will be non-local
ULONG     g_cbQmTmWhereabouts = 0;      // length of DTC whereabouts
BYTE     *g_pbQmTmWhereabouts = NULL;   // DTC whereabouts

static ITransactionExport *g_pExport = NULL;  // cached DTC export object

HANDLE g_hMutexDTC = NULL;   // Serializes calls to DTC

extern HRESULT DepGetTmWhereabouts(
                   IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts);

/*====================================================
GetMutex
    Internal: creates/opens global mutex and waits for it
=====================================================*/
HRESULT GetMutex()
{
    if (!g_hMutexDTC)
    {
        HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
		if (InterlockedCompareExchangePointer (&g_hMutexDTC, hMutex, NULL))
			CloseHandle(hMutex);
    }

    if (!g_hMutexDTC)
    {
        TrERROR(XACT_GENERAL, "CreateMutex failed: %x ", 0);
        return MQ_ERROR_DTC_CONNECT;
    }

    WaitForSingleObject(g_hMutexDTC, 5 * 60 * 1000);
    return MQ_OK;
}

//---------------------------------------------------------
//  BOOL FindTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  *not* adds
//    returns TRUE if xaction was found, FALSE - if not
//---------------------------------------------------------
static BOOL FindTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//---------------------------------------------------------
//  BOOL RememberTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  adds there if not found;
//    returns TRUE if xaction was found, FALSE - if it was added
//---------------------------------------------------------
static BOOL RememberTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    // No check for ring buffer overflow, because it is not dangerous (maximum RT will go to QM)

    // adding transaction to the ring buffer

    if (s_ulXrbFirst == XACT_RING_BUF_SIZE)
    {
        // Ring buffer is empty
        s_ulXrbFirst = s_ulXrbLast = 0;
        memcpy(&s_uowXactRingBuf[s_ulXrbFirst], pUow, sizeof(XACTUOW));
    }
    else
    {
        s_ulXrbLast = (s_ulXrbLast == XACT_RING_BUF_SIZE-1 ? 0 : s_ulXrbLast+1);
        memcpy(&s_uowXactRingBuf[s_ulXrbLast], pUow, sizeof(XACTUOW));
    }

    return FALSE;
}

//---------------------------------------------------------
// HRESULT RTpGetExportObject
//
//  Description:
//
//    Creates and caches the DTC export object
//---------------------------------------------------------
HRESULT RTpGetExportObject(IUnknown  *punkDtc,
                           ULONG     cbTmWhereabouts,
                           BYTE      *pbTmWhereabouts)
{
    HRESULT                          hr = MQ_OK;
    R<ITransactionExportFactory>     pTxExpFac   = NULL;

    if (g_pExport)
    {
        g_pExport->Release();
        g_pExport = NULL;
    }

    // Get the DTC's ITransactionExportFactory interface
    hr = punkDtc->QueryInterface (IID_ITransactionExportFactory, (void **)(&pTxExpFac.ref()));
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QueryInterface failed: %x ", hr);
       return hr;
    }


    // Create Export object
    hr = pTxExpFac->Create (cbTmWhereabouts, pbTmWhereabouts, &g_pExport);
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "Create Export Object failed: %x ", hr);
       return hr;
    }

    return(MQ_OK);
}

//---------------------------------------------------------
// HRESULT RTpBuildTransactionCookie
//
//  Description:
//
//    Builds transaction Cookie
//---------------------------------------------------------
HRESULT RTpBuildTransactionCookie(ITransaction *pTrans,
                                  ULONG        *pcbCookie,
                                  BYTE        **ppbCookie)
{
    HRESULT                          hr = MQ_OK;
    ULONG                            cbUsed;
    R<IUnknown>                      punkTx = NULL;

    *pcbCookie = 0;
    *ppbCookie = NULL;

    // Get transaction's Unknown
    hr = pTrans->QueryInterface (IID_IUnknown, (void **)(&punkTx.ref()));
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "QueryInterface failed: %x ", hr);
       return hr;
    }
    // Get transaction cookie size
    hr = g_pExport->Export (punkTx.get(), pcbCookie);
    if (FAILED(hr) || *pcbCookie == 0)
    {
       TrERROR(XACT_GENERAL, "Export failed: %x ", hr);
       return hr;
    }

    // Allocate memory for transaction Cookie
    try
    {
        *ppbCookie =  new BYTE[*pcbCookie];
    }
    catch(const bad_alloc&)
    {
        TrERROR(XACT_GENERAL, "Allocation failed: %x ", hr);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    // Get transaction Cookie itself
    hr = g_pExport->GetTransactionCookie (punkTx.get(), *pcbCookie, *ppbCookie, &cbUsed);
    if (FAILED(hr))
    {
       TrERROR(XACT_GENERAL, "GetTransactionCookie failed: %x ", hr);
       return hr;
    }

    return(MQ_OK);
}


//---------------------------------------------------------
// HRESULT RTXactGetDTC
//
//  Description:
//
//  Obtains DTC transaction manager.  Defers to mqutil
//
//  Outputs:
//    ppunkDTC      pointers to DTC transaction manager
//---------------------------------------------------------
HRESULT APIENTRY DepXactGetDTC(IUnknown **ppunkDTC)
{
    HRESULT hr =  MQ_ERROR;

    __try
    {
        GetMutex();  // Isolate export creation from others
        hr = XactGetDTC(ppunkDTC);//, g_fDependentClient);
    }
    __finally
    {
        ReleaseMutex(g_hMutexDTC);
    }
    return (SUCCEEDED(hr) ? MQ_OK : hr);
}


//---------------------------------------------------------
// HRESULT RTpProvideTransactionEnlist
//
//  Description:
//
//    Provides that QM is enlisted in this transaction,
//    checks the transaction state
//---------------------------------------------------------
HRESULT RTpProvideTransactionEnlist(ITransaction *pTrans, XACTUOW *pUow)
{
    HRESULT                         hr = MQ_OK;
    IUnknown                       *punkDtc  = NULL;
    IMSMQTransaction               *pIntXact = NULL;
    ULONG                           cbCookie;
    BYTE                           *pbCookie = NULL;
    XACTTRANSINFO                   xinfo;
    BOOL                            fMutexTaken = FALSE;

    __try
    {
        //
        // Get the transaction info. UOW resides there.
        //
        hr = pTrans->GetTransactionInfo(&xinfo);
        if (FAILED(hr))
        {
            TrERROR(XACT_GENERAL, "GetTransactionInfo failed: %x ", hr);
            __leave;
        }

        // Put pointer to UOW in the output parameter
        CopyMemory(pUow, &xinfo.uow, sizeof(XACTUOW));

        //
        // Is it internal transaction?
        //
        pTrans->QueryInterface (IID_IMSMQTransaction, (void **)(&pIntXact));

        if (pIntXact)
        {
           // Internal transactions
           //------------------------
           hr = pIntXact->EnlistTransaction(pUow);
           if (FAILED(hr))
           {
                TrERROR(XACT_GENERAL, "EnlistTransaction failed: %x ", hr);
           }
        }
        else
        {
            // External transactions
            //------------------------

            // Look for the transaction in the cache
            //
            if (FindTransaction(pUow))     // this xaction is known already; QM must have been enlisted
            {
                hr = MQ_OK;
                __leave;
            }

            // Get global mutex to isolate enlistment
            //
            GetMutex();  // Isolate export creation from others
            fMutexTaken = TRUE;

            //
            // Get the DTC IUnknown and TM whereabouts
            //
            hr = XactGetDTC(&punkDtc);//, g_fDependentClient);
            if (FAILED(hr))
            {
                TrERROR(XACT_GENERAL, "XactGetDTC failed: %x ", hr);
                __leave;
            }

            // XactGetDTC could return success code of 1 if it reconnected to DTC
            if (hr == 1)
            {
                // No Release: DTC object is not alive anymore
                g_pExport = NULL;
            }

            // Get the QM's controlling DTC whereabouts
            //
            if (!g_pbQmTmWhereabouts)
            {
                g_cbQmTmWhereabouts = 128;
                g_pbQmTmWhereabouts = new BYTE[128];
                DWORD cbNeeded;

                hr = DepGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);

                if (hr == MQ_ERROR_USER_BUFFER_TOO_SMALL)
                {
                    delete [] g_pbQmTmWhereabouts;
                    g_cbQmTmWhereabouts = cbNeeded;
                    g_pbQmTmWhereabouts = new BYTE[cbNeeded];

                    hr = DepGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);
                }

                if (FAILED(hr))
                {
                    delete [] g_pbQmTmWhereabouts;
                    g_cbQmTmWhereabouts = 0;
                    g_pbQmTmWhereabouts = NULL;

                    TrERROR(XACT_GENERAL, "DepGetTmWhereabouts failed: %x ", hr);
                    __leave;
                }
                else
                {
                    g_cbQmTmWhereabouts = cbNeeded;
                }
            }

            //
            // Get and cache Export object
            //

            if (g_pExport == NULL)
            {
                hr = RTpGetExportObject(
                               punkDtc,
                               g_cbQmTmWhereabouts,
                               g_pbQmTmWhereabouts);
                if (FAILED(hr))
                {
                    TrERROR(XACT_GENERAL, "RTpGetExportObject failed: %x ", hr);
                    __leave;
                }
            }

            //
            // Prepare the transaction Cookie
            //
            hr = RTpBuildTransactionCookie(
                        pTrans,
                        &cbCookie,
                        &pbCookie);
            if (FAILED(hr))
            {
                TrERROR(XACT_GENERAL, "RTpBuildTransactionCookie failed: %x ", hr);
                __leave;
            }

            //
            // RPC call to QM for enlistment
            //
            RpcTryExcept
            {
                INIT_RPC_HANDLE ;

				if(tls_hBindRpc == 0)
					return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                hr = R_QMEnlistTransaction(tls_hBindRpc, pUow, cbCookie, pbCookie);
            }
			RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
               DWORD rc = GetExceptionCode();
               TrERROR(XACT_GENERAL, "RTpProvideTransactionEnlist failed: RPC code=%x ", rc);
			   DBG_USED(rc);

			   PRODUCE_RPC_ERROR_TRACING;
               hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
			RpcEndExcept

            //Now that transaction is actually enlisted we remember it in ring buffer
            if (SUCCEEDED(hr))
            {
                RememberTransaction(pUow);
            }
            else
            {
                TrERROR(XACT_GENERAL, "QMEnlistTransaction failed: %x ", hr);
            }
        }

        if (FAILED(hr)) {
            __leave;
        }
        hr = MQ_OK;
    }

    __finally

    {
        if (SUCCEEDED(hr) && AbnormalTermination())
            hr = MQ_ERROR;

        #ifdef _DEBUG
        DWORD cRef = 0;
        if (punkDtc)
            cRef = punkDtc->Release();
        #else
        if (punkDtc)
            punkDtc->Release();
        #endif

        if (pIntXact)
            pIntXact->Release();

        if (pbCookie)
            delete pbCookie;

        if (fMutexTaken)
            ReleaseMutex(g_hMutexDTC);
    }

    return(hr);
}


//---------------------------------------------------------
// void RTpInitXactRingBuf()
//
//  Description:
//
//    Initiates the ring buffer data
//---------------------------------------------------------
void RTpInitXactRingBuf()
{
    CS lock(s_RingBufCS);

    s_ulXrbFirst =  XACT_RING_BUF_SIZE;
    s_ulXrbLast  =  XACT_RING_BUF_SIZE;
    g_DtcInit    = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\cluster.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cluster.h

Abstract:
                                                        
    Declarations for cluster related classes and functions.

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#ifndef _MQUPGRD_CLUSTER_H_
#define _MQUPGRD_CLUSTER_H_


VOID
APIENTRY
CleanupOnCluster(
    LPCWSTR pwzMsmqDir
    );

#endif //_MQUPGRD_CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\security\ui\mqcertui\prcertui.h ===
//
// prcertui.h
//

#ifndef _PRCERTUI_H_
#define _PRCERTUI_H_

#include <assert.h>

#define ASSERT(x)  assert(x)

#include <mqwin64a.h>

#include <mqcert.h>

#define INTERNAL_CERT_INDICATOR 0xffff

extern HMODULE		g_hResourceMod;

INT_PTR CALLBACK CertSelDlgProc( HWND   hwndDlg,
                                 UINT   uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam );

struct CertInfoDlgProcStruct
{
    CMQSigCertificate  *pCert;
    DWORD              dwFlags;
};

struct CertSelDlgProcStruct
{
    CMQSigCertificate  **pCertList;
    DWORD              nCerts;
    CMQSigCertificate  **ppCert;
    DWORD              dwType;
};

INT_PTR CALLBACK CertInfoDlgProc( HWND   hwndDlg,
                                  UINT   uMsg,
                                  WPARAM wParam,
                                  LPARAM lParam );

LPWSTR AllocAndLoadString( HINSTANCE hInst,
                           UINT      uID );

#endif //   _PRCERTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\security\ui\mqcertui\mqcertui.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcertui.cpp

Abstract:

    Dialogs for certificate related user interface.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include <windows.h>
#include "certres.h"
#include <commctrl.h>

#include "prcertui.h"
#include "mqcertui.h"
#include "snapres.h"  // include snapres.h for IDS_SHOWCERTINSTR
#include "_mqres.h"	  // include function for the function to use mqutil.dll


//
// get the handle to the resource only dll, i.e. mqutil.dll
//
HMODULE		g_hResourceMod = MQGetResourceHandle();

BOOL WINAPI DllMain(
    HINSTANCE /*hInst*/,
    ULONG ul_reason_for_call,
    LPVOID /*lpReserved*/
    )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        InitCommonControls();
        break;
    }

	return TRUE;
}

//+-------------------------------------------------------------------------
//
// Function -
//      ShowPersonalCertificates
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects. The user can also
//      view the details of any cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL ShowPersonalCertificates( HWND                hWndParent,
                               CMQSigCertificate  *pCertList[],
                               DWORD               nCerts)
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = NULL;
    Param.dwType = IDS_SHOWCERTINSTR;

    return DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK ;
}

//+-------------------------------------------------------------------------
//
// Function -
//      SelectPersonalCertificateForRemoval
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//      pp509 - A pointrer to a buffer that receives the address of the
//          selected cert. The application is responsible for releasing
//          the cert.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects.  The user selectes
//      a cert. If the user presses Remove, *pp509 points to the selected
//      certificate. The user can also view the details of any cert. The
//      certificate is not removed. The calling code can choose whatever
//      it wants to do with the cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL SelectPersonalCertificateForRemoval( HWND                hWndParent,
                                          CMQSigCertificate  *pCertList[],
                                          DWORD               nCerts,
                                          CMQSigCertificate **ppCert )
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = ppCert;
    Param.dwType = IDS_REMOVECERTINSTR;

    return ((DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK) &&
             (*ppCert != NULL));
}

//+-------------------------------------------------------------------------
//
// Function -
//      SelectPersonalCertificateForRegister
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//      pp509 - A pointrer to a buffer that receives the address of the
//          selected cert. The application is responsible for releasing
//          the cert.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects.  The user selectes
//      a cert. If the user presses Save, *pp509 points to the selected
//      certificate. The user can also view the details of any cert. The
//      certificate is not saved. The calling code can choose whatever
//      it wants to do with the cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL SelectPersonalCertificateForRegister(
                                       HWND                hWndParent,
                                       CMQSigCertificate  *pCertList[],
                                       DWORD               nCerts,
                                       CMQSigCertificate **ppCert )
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = ppCert;
    Param.dwType = IDS_SAVECERTINSTR;

    return ((DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK) &&
             (*ppCert != NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\security\ui\mqcertui\certsel.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certsel.cpp

Abstract:

    Certificate selection dialog.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/


#include <windows.h>
#include <winnls.h>
#include <crtdbg.h>
#include "prcertui.h"
#include <mqcertui.h>
#include <rt.h>
#include <rtcert.h>
#include "automqfr.h"
#include "mqmacro.h"
#include <strsafe.h>

#include "certres.h"
#include "snapres.h"  // include snapres.h for IDS_SHOWCERTINSTR

//
// Function -
//     AllocAndLoadString
//
// Parameters
//      hInst - The module instance.
//      uID - The string ID.
//
// Description-
//      Load a string from the string table. the function allocates the memory
//      required for holding the string. the calling code should free the memory.
//
LPWSTR AllocAndLoadString(HINSTANCE hInst, UINT uID)
{
    AP<WCHAR> pwszTmp;
	DWORD dwBuffLen = 512;
	DWORD dwStrLen;
	
	for(;;)
	{
		pwszTmp.free();
		pwszTmp = new WCHAR[dwBuffLen];
		dwStrLen = LoadString(hInst, uID, pwszTmp, dwBuffLen);

		if (!dwStrLen)
		{
			return NULL;
		}

		if ((dwStrLen+1) < dwBuffLen)
			break;

		dwBuffLen *= 2;
	}

    LPWSTR pwszRet = new WCHAR[dwStrLen + 1];
	StringCchCopy(pwszRet, dwStrLen + 1, pwszTmp);

    return pwszRet;
}

//
// Function -
//      FillCertsList
//
// Parameters -
//      p509list - A pointer to an array. Each array entry points to an X509
//          certificate. If this parameter is NULL, the certificates are taken
//          from the personal certificate store in the local machine.
//      nCerts - The number of entries in p509List. this parameter is ignored if
//          p509List is NULL.
//      hListBox - A list box handle in which the names are to be filled.
//
// Description -
//      Goes over the entries in p509List, for each entry puts the common name
//      of the X509 cert subject in the list box.
//
static
BOOL
FillCertsList(
    CMQSigCertificate  *pCertList[],
    DWORD              nCerts,
    HWND               hListBox)
{
    if (!pCertList)
    {
        //
        // Enumerate all certificate in personal store.
        //
        CHCryptProv  hMyProv = NULL ;
        CHCertStore  hMyStore = NULL ;

        if (CryptAcquireContext( &hMyProv,
                                  NULL,
                                  NULL,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT))
        {
            hMyStore = CertOpenSystemStore( hMyProv, &x_wszPersonalSysProtocol[0] ) ;
        }

        if (hMyStore)
        {
            LONG iCert = 0 ;
            PCCERT_CONTEXT pCertContext;
			PCCERT_CONTEXT pCertContextDuplicate;
            PCCERT_CONTEXT pPrevCertContext;

            pCertContext = CertEnumCertificatesInStore(hMyStore, NULL);

            while (pCertContext)
            {
                pCertContextDuplicate = CertDuplicateCertificateContext(pCertContext);

				R<CMQSigCertificate> pCert = NULL ;
                HRESULT hr = MQSigCreateCertificate( &pCert.ref(),
                                                     pCertContextDuplicate,
                                                     NULL,
                                                     0 ) ;
                if (SUCCEEDED(hr))
                {
                    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
                    if (SUCCEEDED(pCert->GetSubjectInfo( &pNameInfo )))
                    {
                        //
                        // Make sure this is not an Encrypted File System (EFS)
                        // certificate. We don't want these to be displayed
                        // (yoela - 6-17-98 - fix bug 3074)
                        //
                        const WCHAR x_szEncriptedFileSystemLocality[] = L"EFS";
                        BOOL fEfsCertificate = FALSE;
                        CAutoMQFree<WCHAR> wszLocality = NULL ;
                        if (SUCCEEDED(pCert->GetNames(pNameInfo,
                                                      &wszLocality,
                                                      NULL,
                                                      NULL,
                                                      NULL ))
                             && (wszLocality != NULL) )
                        {
                             fEfsCertificate =
                                 (wcscmp(wszLocality, x_szEncriptedFileSystemLocality) == 0);
                        }

                        CAutoMQFree<WCHAR> wszCommonName = NULL ;
                        if (!fEfsCertificate
                            && SUCCEEDED(pCert->GetNames( pNameInfo,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          &wszCommonName) )
                            && (wszCommonName != NULL) )
                        {
                            //
                            // Send the common name to the list box.
                            //
                            LRESULT i = SendMessage( hListBox,
                                                     LB_ADDSTRING,
                                                     0,
													 (LPARAM)(LPCWSTR)wszCommonName);
                            if (i != LB_ERR)
                            {
                                //
                                // Set the cert index as the list box item
                                // data.
                                //
                                SendMessage( hListBox,
                                             LB_SETITEMDATA,
                                             (WPARAM)i,
                                             (LPARAM)iCert);
                            }
                        }
                    }
                }

                //
                // Get next certificate
                //
                pPrevCertContext = pCertContext,
                pCertContext = CertEnumCertificatesInStore( hMyStore,
                                                        pPrevCertContext ) ;

                iCert++ ;
            }
        }

        //
        // Put the internal Falcon cert in the list box.
        // Note: it's important that pIntStore be defined before
        //       pIntCert, so it will be the last one to be released.
        //
        R<CMQSigCertStore> pIntStore = NULL ;
        R<CMQSigCertificate> pIntCert = NULL ;

        HRESULT hr = RTGetInternalCert( &pIntCert.ref(),
                                        &pIntStore.ref(),
                                         FALSE,
                                         FALSE,
                                         NULL ) ;
        if (SUCCEEDED(hr) && pIntCert.get())
        {
            CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
            if (SUCCEEDED(pIntCert->GetSubjectInfo( &pNameInfo )))
            {
                CAutoMQFree<WCHAR> wszCommonName = NULL ;
                if (SUCCEEDED(pIntCert->GetNames( pNameInfo,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &wszCommonName) )
                     && (wszCommonName != NULL) )
                {

					LRESULT i = SendMessage( hListBox,
                                             LB_ADDSTRING,
                                             0,
                                             (LPARAM)(LPCWSTR)wszCommonName);
                    if (i != LB_ERR)
                    {
                        SendMessage( hListBox,
                                     LB_SETITEMDATA,
                                     (WPARAM)i,
                                     (LPARAM)INTERNAL_CERT_INDICATOR);
                    }
                }
            }
        }
    }
    else
    {
        DWORD i;
        CMQSigCertificate  *pCert ;

        for (i = 0; i < nCerts; i++ )
        {
			pCert = pCertList[i];
            CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
            if (SUCCEEDED(pCert->GetSubjectInfo( &pNameInfo )))
            {
                CAutoMQFree<WCHAR> wszCommonName = NULL ;
                if (SUCCEEDED(pCert->GetNames( pNameInfo,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &wszCommonName) )
                     && (wszCommonName != NULL) )
                {

                    LRESULT j = SendMessage( hListBox,
                                             LB_ADDSTRING,
                                             0,
                                             (LPARAM)(LPCWSTR)wszCommonName);
                    if (j != LB_ERR)
                    {
                        SendMessage( hListBox,
                                     LB_SETITEMDATA,
                                     (WPARAM)j,
                                     (LPARAM)i);
                    }
                }
            }
        }
    }
    //
    // Set the selected item to be the first item in the list box.
    //
    SendMessage(hListBox, LB_SETCURSEL, 0, 0);

    return TRUE;
}

//
// The dialog procedure of the certificate selection dialog.
//
INT_PTR CALLBACK CertSelDlgProc( HWND   hwndDlg,
                                 UINT   uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam )
{
    static CMQSigCertificate **ppCert = NULL ;
    static CMQSigCertificate **pCertList;
    static DWORD dwType;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            struct CertSelDlgProcStruct *pParam =
                                  (struct CertSelDlgProcStruct *) lParam ;

            pCertList = pParam->pCertList ;
            ppCert = pParam->ppCert ;
            dwType = pParam->dwType;
            //
            // Set the instruction field.
            //
            AP<WCHAR> wszCertInstr = AllocAndLoadString(g_hResourceMod, dwType);

            SetWindowText( GetDlgItem(hwndDlg, IDC_CERTSINSTR),
                           wszCertInstr ) ;
            //
            // Get handles to windows in the dialog.
            //
            HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
            HWND hWndShowCert = GetDlgItem(hwndDlg, IDC_SHOWCERT);
            HWND hWndOK = GetDlgItem(hwndDlg, IDOK);
            //
            // Fill the certificate list box.
            //
            FillCertsList(pCertList, pParam->nCerts, hListBox);

            // If there are no certificates, disable some of the buttons.
            if (SendMessage(hListBox, LB_GETCOUNT, 0, 0) == 0)
            {
                if (dwType != IDS_SHOWCERTINSTR)
                {
                    EnableWindow(hWndOK, FALSE);
                }

                EnableWindow(hWndShowCert, FALSE);
            }

            // Do some special initialization acording to the type of dialog.
            switch(dwType)
            {
            case IDS_SHOWCERTINSTR:
                {
                    WINDOWPLACEMENT wp;
                    HWND hCancelWnd = GetDlgItem(hwndDlg, IDCANCEL);

                    // Hide the "Cancel" button and move up the "View Certificate" button.
                    wp.length = sizeof(WINDOWPLACEMENT);
                    GetWindowPlacement(hCancelWnd, &wp);
                    SetWindowPlacement(hWndShowCert, &wp);
                    ShowWindow(hCancelWnd, SW_HIDE);
                }
                break;

            case IDS_REMOVECERTINSTR:
                {
                    // Modify the text of the "OK" button to "Remove"
                    AP<WCHAR> wszRemove = AllocAndLoadString(g_hResourceMod, IDS_REMOVE);
                    SetWindowText(hWndOK, wszRemove);
                }
                break;

            case IDS_SAVECERTINSTR:
                {
                    // Modify the text of the "OK" button to "Remove"
                    AP<WCHAR> wszSave = AllocAndLoadString(g_hResourceMod, IDS_SAVE);
                    SetWindowText(hWndOK, wszSave);
                }
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
            if (ppCert)
            {
                //
                // Copy the selected certificate to the out parameter.
                //
                HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
                INT_PTR i = SendMessage( hListBox, LB_GETCURSEL, 0, 0);
                LONG iCert = INT_PTR_TO_INT (SendMessage( hListBox,
                                                          LB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          0 )) ;

                CMQSigCertificate *pSelCert = NULL;
                *ppCert = NULL;

                //
                // Set pSelCert to point to the selected cert.
                //
                HRESULT hr ;
                if (!pCertList)
                {
                    if (iCert == INTERNAL_CERT_INDICATOR)
                    {
                        //
                        // In this case pSelCert should remain set to NULL.
                        //
                        hr = MQSigCloneCertFromReg(
                                              ppCert,
                                              MQ_INTERNAL_CERT_STORE_REG,
                                              0 ) ;
                    }
                    else
                    {
                        //
                        // The selected cert is in the personal cert store.
                        //
                        hr = MQSigCloneCertFromSysStore(
									&pSelCert,
									x_wszPersonalSysProtocol,
									iCert 
									);
                    }
                }
                else
                {
                    pSelCert = pCertList[iCert];
                }
                //
                // Copy the selected cert to the out parameter.
                //
                if (pSelCert)
                {
                    *ppCert = pSelCert ;
                }
            }
            EndDialog(hwndDlg, IDOK);
            return TRUE;
            break;

        case IDCANCEL:
            // No cert was selected.
            if (ppCert)
            {
                *ppCert = NULL;
            }
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;
            break;

        case IDC_SHOWCERT:
            {
                HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
                INT_PTR i = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );
                LONG iCert = INT_PTR_TO_INT( SendMessage( hListBox,
                                                          LB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          0));

                R<CMQSigCertificate> pTmpCert = NULL;
                CMQSigCertificate *pCertSel = NULL;
                BOOL bInternal = TRUE ;
                HRESULT hr ;
                //
                // Set pCertSel to point to the cert that should be shown.
                //
                if (!pCertList)
                {
                    if (iCert == INTERNAL_CERT_INDICATOR)
                    {
                        hr = MQSigCloneCertFromReg(
                                              &pTmpCert.ref(),
                                              MQ_INTERNAL_CERT_STORE_REG,
                                              0 ) ;
                    }
                    else
                    {
                        //
                        // The selected cert is in the personal cert store.
                        //
                        bInternal = FALSE ;
                        hr = MQSigCloneCertFromSysStore(
								&pTmpCert.ref(),
								x_wszPersonalSysProtocol,
								iCert 
								);
                    }

                    if (FAILED(hr))
                    {
                        AP<WCHAR> wszCantGetCert =
                             AllocAndLoadString(g_hResourceMod, IDS_CANT_GET_CERT);
                        AP<WCHAR> wszError =
                                     AllocAndLoadString(g_hResourceMod, IDS_ERROR);
                        MessageBox( hwndDlg,
                                    wszCantGetCert,
                                    wszError,
                                    (MB_OK | MB_ICONEXCLAMATION)) ;
                    }
                    else
                    {
                        pCertSel = pTmpCert.get();
                    }
                }
                else
                {
                    //
                    // See whether this is an internal cert according to the
                    // subject's locality. If it is "MSMQ", this is an
                    // internal certificate.
                    //
                    bInternal = FALSE ;
                    pCertSel = pCertList[iCert];

                    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
                    if (SUCCEEDED(pCertSel->GetSubjectInfo( &pNameInfo )))
                    {
                        CAutoMQFree<WCHAR> wszLocality = NULL ;
                        if (SUCCEEDED(pCertSel->GetNames(pNameInfo,
                                                         &wszLocality,
                                                         NULL,
                                                         NULL,
                                                         NULL ))
                             && (wszLocality != NULL) )
                        {
                            bInternal =
                                    (wcscmp(wszLocality, L"MSMQ") == 0);
                        }
                    }
                }

                // Call the cert info dialog.
                if (pCertSel)
                {
                    ShowCertificate( hwndDlg,
                                     pCertSel,
                                     bInternal ? CERT_TYPE_INTERNAL :
                                                 CERT_TYPE_PERSONAL );
                }
            }
           return TRUE;
            break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\cluster.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cluster.cpp

Abstract:
                                                        
    handle upgrade on cluster

Author:

    Shai Kariv  (ShaiK)  14-Sep-98

--*/


#include "stdh.h"
#include "cluster.h"
#include "_autorel.h"

#include "ocmnames.h"
#include "setupdef.h"
#include "comreg.h"


VOID
APIENTRY
CleanupOnCluster(
    LPCWSTR pwzMsmqDir
    )
/*++

Routine Description:

    Deletes MSMQ 1.0 old files on shared disk

Arguments:

    pwzMsmqDir - Points to msmq directory on shared disk.

Return Value:

    None.

--*/
{
    //
    // Get the names of the directories to delete from
    //

    wstring szMsmqDir = pwzMsmqDir;
    wstring szMsmqSetupDir = szMsmqDir + OCM_DIR_SETUP;
    wstring szMsmqSdkDebugBinDir = szMsmqDir + OCM_DIR_SDK_DEBUG;
    wstring szMsmqSetupExchconnDir = szMsmqDir + OCM_DIR_MSMQ_SETUP_EXCHN;

    //
    // List of files to delete is in msmqocm.inf
    //

    const wstring x_wcsInf(L"MSMQOCM.INF");
    CAutoCloseInfHandle hInf = SetupOpenInfFile(
                                   x_wcsInf.c_str(),
                                   NULL,
                                   INF_STYLE_WIN4,
                                   NULL
                                   );
    if (INVALID_HANDLE_VALUE == hInf)
    {
        return;
    }

    //
    // Call SetupAPIs to do the work
    //

    if (!SetupSetDirectoryId(hInf, idMsmqDir, szMsmqDir.c_str())                      ||
        !SetupSetDirectoryId(hInf, idMsmq1SetupDir, szMsmqSetupDir.c_str())           ||
        !SetupSetDirectoryId(hInf, idMsmq1SDK_DebugDir, szMsmqSdkDebugBinDir.c_str()) ||
        !SetupSetDirectoryId(hInf, idExchnConDir, szMsmqSetupExchconnDir.c_str())
        )
    {
        return;
    }

    CAutoCloseFileQ hQueue = SetupOpenFileQueue();
    if (INVALID_HANDLE_VALUE == hQueue)
    {
        return;
    }
                                 
    if (!SetupInstallFilesFromInfSection(
            hInf,
            0,
            hQueue,
            UPG_DEL_PROGRAM_SECTION,
            NULL, 
            0 
            ))
    {
        return;
    }

    PVOID context = SetupInitDefaultQueueCallbackEx(NULL,static_cast<HWND>(INVALID_HANDLE_VALUE),0,0,0);
    if (NULL == context)
    {
        return;
    }

    if (!SetupCommitFileQueue(
             NULL,                       // optional; parent window
             hQueue,                     // handle to the file queue
             SetupDefaultQueueCallback,  // callback routine to use
             context                     // passed to callback routine
             ))
    {
        return;
    }

} //CleanupOnCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\creatobj.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    creatobj.cpp

Abstract:

    Create msmqConfiguration object, first time msmq service boot
    after setup.

Author:

    Doron Juster (DoronJ)  08-Mar-1999
    ilan herbst  (ilanh)   27-Aug-2000

--*/

#include "stdh.h"
#include <mqupgrd.h>
#include <autorel.h>
#include <mqprops.h>
#include <mqsec.h>
#include <mqnames.h>
#include "..\..\ds\h\mqdsname.h"
#include <ad.h>
#include "Ev.h"

#include "creatobj.tmh"

static WCHAR *s_FN=L"mqupgrd/creatobj";


//+------------------------------------------------
//
//  HRESULT _UpdateMachineSecurityReg()
//
//  Write security properties if newly created
//  msmqConfiguration object in local registry.
//
//+------------------------------------------------

static 
HRESULT 
_UpdateMachineSecurityReg( 
	IN WCHAR       *pwszMachineName,
	IN PSID         pUserSid,
	IN GUID        *pMachineGuid 
	)
{
    //
    // cache machine account sid in registry.
    //
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;
    AP<BYTE> pSid;

    HRESULT hr = ADGetObjectProperties(
						eCOMPUTER,
						NULL,  // pwcsDomainController
						false, // fServerName
						pwszMachineName,
						1,
						&propidSid,
						&PropVarSid
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    pSid = PropVarSid.blob.pBlobData;
    ASSERT(IsValidSid(pSid));

    DWORD dwSize = GetLengthSid(pSid);
    DWORD dwType = REG_BINARY;

    LONG rc = SetFalconKeyValue( 
					MACHINE_ACCOUNT_REGNAME,
					&dwType,
					pSid,
					&dwSize
					);
    ASSERT(rc == ERROR_SUCCESS);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 30);
    }

	MQSec_UpdateLocalMachineSid(pSid);

    //
    // Write security descriptor of msmqConfiguration in Registry.
    //
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwSDSize;
    P<BYTE> pReleaseSD = NULL ;

    SECURITY_INFORMATION RequestedInformation =
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION;

	//
	// The cached security descriptor in registry is in NT4 format.
	// For that reason we use PROPID_QM_SECURITY.
	//
    PROPVARIANT varSD;
    varSD.vt = VT_NULL;
    hr = ADGetObjectSecurityGuid(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				pMachineGuid,
				RequestedInformation,
				PROPID_QM_SECURITY,
				&varSD
				);

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // This may happen because of replication delay.
        // Create a default security descriptor and cache it in registry.
        // Anyway, each time the msmq service boot it updates this value.
        //
        // Build a security descriptor that include only owner and group.
        // Owner is needed to build the DACL.
        //
        pSD = NULL;
        P<BYTE> pDefaultSD = NULL;

        hr = MQSec_GetDefaultSecDescriptor( 
					MQDS_MACHINE,
					(PSECURITY_DESCRIPTOR*) &pDefaultSD,
					FALSE, /*fImpersonate*/
					NULL,
					DACL_SECURITY_INFORMATION,
					e_UseDefaultDacl 
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50);
        }

        PSID pOwner = NULL;
        BOOL bOwnerDefaulted = FALSE ;
        BOOL bRet = GetSecurityDescriptorOwner( 
						pDefaultSD,
						&pOwner,
						&bOwnerDefaulted
						);
        ASSERT(bRet);

        PSID pWorldSid = MQSec_GetWorldSid();

        PSID pComputerSid = pSid;

        //
        // Build the default machine DACL.
        //
        DWORD dwAclSize = sizeof(ACL)                            +
              (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pComputerSid)                         +
              GetLengthSid(pOwner);

        if (pUserSid)
        {
            dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                         GetLengthSid(pUserSid);
        }

        AP<char> DACL_buff = new char[dwAclSize];
        PACL pDacl = (PACL)(char*)DACL_buff;
        InitializeAcl(pDacl, dwAclSize, ACL_REVISION);

        DWORD dwWorldAccess = MQSEC_MACHINE_WORLD_RIGHTS;

        BOOL fAdd = AddAccessAllowedAce( 
						pDacl,
						ACL_REVISION,
						dwWorldAccess,
						pWorldSid 
						);
        ASSERT(fAdd);

        //
        // Add the owner with full control.
        //
        fAdd = AddAccessAllowedAce( 
					pDacl,
					ACL_REVISION,
					MQSEC_MACHINE_GENERIC_ALL,
					pOwner
					);
        ASSERT(fAdd);

        //
        // Add the computer account.
        //
        fAdd = AddAccessAllowedAce( 
					pDacl,
					ACL_REVISION,
					MQSEC_MACHINE_SELF_RIGHTS,
					pComputerSid
					);
        ASSERT(fAdd);

        if (pUserSid)
        {
            fAdd = AddAccessAllowedAce( 
						pDacl,
						ACL_REVISION,
						MQSEC_MACHINE_GENERIC_ALL,
						pUserSid
						);
            ASSERT(fAdd);
        }

        //
        // build absolute security descriptor.
        //
        SECURITY_DESCRIPTOR  sd;
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
        ASSERT(bRet);

        PSID pGroup = NULL;
        BOOL bGroupDefaulted = FALSE;

        bRet = GetSecurityDescriptorGroup( 
					pDefaultSD,
					&pGroup,
					&bGroupDefaulted
					);
        ASSERT(bRet && IsValidSid(pGroup));

        bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
        ASSERT(bRet);

        //
        // Convert the descriptor to a self relative format.
        //
        dwSDSize = 0;

        hr = MQSec_MakeSelfRelative( 
				(PSECURITY_DESCRIPTOR) &sd,
				&pSD,
				&dwSDSize 
				);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
        ASSERT(dwSDSize != 0);
        pReleaseSD = (BYTE*) pSD;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else
    {
        ASSERT(SUCCEEDED(hr));
        ASSERT(varSD.vt == VT_BLOB);
        pReleaseSD = varSD.blob.pBlobData;
        pSD = varSD.blob.pBlobData;
        dwSDSize = varSD.blob.cbSize;
    }

    dwType = REG_BINARY;

    rc = SetFalconKeyValue(
				MSMQ_DS_SECURITY_CACHE_REGNAME,
				&dwType,
				(PVOID) pSD,
				&dwSDSize
				);
    ASSERT(rc == ERROR_SUCCESS);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 80);
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT _RegisterMachine()
//
//  Query machine properties from ADS and write them in registry.
//
//+-----------------------------------------------------------------------

static 
HRESULT 
_RegisterMachine( 
	IN WCHAR       *pwszMachineName,
	IN GUID        *pMachineGuid,
	IN BOOL         fSupportDepClient,
    IN const GUID * pguidSiteIdOfCreatedObject
	)
{
    //
    // Lookup the GUID of the object
    //
    PROPID columnsetPropertyIDs[] = {PROPID_E_ID};
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    HRESULT hr = ADGetObjectProperties(
						eENTERPRISE,
						NULL,   // pwcsDomainController
						false,	// fServerName
						L"msmq",
						1,
						columnsetPropertyIDs,
						&propVariant
						);
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to get enterpriseID, in ADGetObjectProperties(), hr- %lxh", hr);

        return LogHR(hr, s_FN, 120);
    }

    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);
    LONG rc = ERROR_SUCCESS;

    if (propVariant.vt == VT_CLSID)
    {
        rc = SetFalconKeyValue( 
				MSMQ_ENTERPRISEID_REGNAME,
				&dwType,
				propVariant.puuid,
				&dwSize
				);
        ASSERT(rc == ERROR_SUCCESS);
        delete propVariant.puuid;
    }
    else
    {
        ASSERT(0);
    }
    //
    // Get back properties of object that was just created.
    // These properties are generated by the server side.
    //
    GUID guidSite = GUID_NULL;

    const UINT x_nMaxProps = 3;
    PROPID      propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD       iProperty = 0;

    propIDs[iProperty] = PROPID_QM_MACHINE_ID;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pMachineGuid;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SITE_ID;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = &guidSite;
    iProperty++;
      
    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    DWORD dwDepClProp = iProperty;
    iProperty++;


    ASSERT(iProperty == x_nMaxProps);
    DWORD dwSupportDepClient = fSupportDepClient;

    if (memcmp(pMachineGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
        //
        // In normal case, we expect to get the machine guid from the
        // "CreateObject" call. But if object was already created, then
        // we'll query the DS for the guid and other data. In normal case,
        // it's OK to set the other data to null. The msmq service will
        // update it on initialization.
        //
        hr = ADGetObjectProperties(
					eMACHINE,
					NULL,  // pwcsDomainController
					false, // fServerName
					pwszMachineName,
					iProperty,
					propIDs,
					propVariants 
					);
        if (FAILED(hr))
        {
            //
            // We don't wait for replication delays.
            // In the normal case, the call to DSCreateObject() will return
            // the machine guid and we won't call DSGetObjectProperties().
            // Reaching this point in code, and calling DSGet(), means that
            // the msmq service boot, created the configuration object and
            // then crashd. So user must run it manually. So we can safely
            // assume that user waited for replication to complete. Anyway,
            // the event below mention that user must wait for replication.
            //
            WCHAR wBuf[128];
            swprintf(wBuf, L"%lxh", hr);
            EvReport(GetMsmqConfig_ERR, 1, wBuf);

            return LogHR(hr, s_FN, 150);
        }
        dwSupportDepClient = propVariants[dwDepClProp].bVal;
    }
    else    // a newly created msmqConfiguration
    {
        //
        //  Write the site-id that was found while creating the object
        //
        guidSite = *pguidSiteIdOfCreatedObject;
    }

    //
    // Write properties to registry.
    //

    dwType = REG_BINARY;
    dwSize = sizeof(GUID);

    rc = SetFalconKeyValue( 
			MSMQ_SITEID_REGNAME,
			&dwType,
			&guidSite,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DEPCLINTS_REGNAME,
			&dwType,
			&dwSupportDepClient,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    //
    // Set same value, 0, in all MQS fields in registry. Automatic setup
    // is applicable only to msmq independent clients.
    //
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwVal = 0;

    rc = SetFalconKeyValue( 
			MSMQ_MQS_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DSSERVER_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_ROUTING_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);         

    return MQ_OK;

} // _RegisterMachine

//+----------------------------
//
//   HRESULT _GetSites()
//
//+----------------------------

static  
HRESULT  
_GetSites( 
	IN WCHAR      *pwszMachineName,
	OUT CACLSID   *pcauuid 
	)
{
    DWORD   dwNumSites = 0;
    GUID   *pguidSites;

    HRESULT hResult = ADGetComputerSites( 
							pwszMachineName,
							&dwNumSites,
							&pguidSites 
							);


	if (FAILED(hResult))
    {
        return LogHR(hResult, s_FN, 190);
    }

    ASSERT(dwNumSites); // Must be > 0
    pcauuid->cElems = dwNumSites;
    pcauuid->pElems = pguidSites;

    return MQ_OK;

} // _GetSites

//+-----------------------------------------------------
//
//  HRESULT  _VerifyComputerObject()
//
//+-----------------------------------------------------

HRESULT _VerifyComputerObject(IN LPCWSTR   pComputerName)
{
    PROPID propId  = PROPID_COM_SID;
    PROPVARIANT propVar;
    propVar.vt = VT_NULL;
    
    HRESULT hr = ADGetObjectProperties(
						eCOMPUTER,
						NULL,    // pwcsDomainController
						false,   // fServerName
						pComputerName,
						1,
						&propId,
						&propVar
						);

    if (FAILED(hr))
    {
        EvReport(ADS_COMPUTER_OBJECT_NOT_FOUND_ERR);
        return LogHR(hr, s_FN, 500);
    }

    delete propVar.blob.pBlobData;
    return MQ_OK;

} // _VerifyComputerObject

//+-----------------------------------------------------
//
//  HRESULT  _CreateTheConfigurationObject()
//
//+-----------------------------------------------------

HRESULT  
_CreateTheConfigurationObject( 
	IN  WCHAR      *pwszMachineName,
	OUT GUID       *pMachineGuid,
	OUT PSID       *ppUserSid,
	OUT BOOL       *pfSupportDepClient,
    OUT GUID       *pguidSiteId
	)
{
    //
    // Prepare the properties for object creation.
    //
    const UINT x_nMaxProps = 10;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty =0;

    propIDs[iProperty] = PROPID_QM_OLDSERVICE;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = SERVICE_NONE;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal =  0;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal =  0;
    iProperty++;

    DWORD dwOsType;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwOsType);
    DWORD dwDefaultOS = MSMQ_OS_NTW;

    LONG rc = GetFalconKeyValue( 
					MSMQ_OS_TYPE_REGNAME,
					&dwType,
					static_cast<PVOID>(&dwOsType),
					&dwSize,
					(LPCWSTR) &dwDefaultOS 
					);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 210);
    }

    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwOsType;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
   
	//
    // By Default, MSMQ on server doesn't supports Dep. Clients
    //
    propVariants[iProperty].bVal =  0;       

    *pfSupportDepClient = propVariants[iProperty].bVal;
    iProperty++;

    BLOB blobEncrypt;
    blobEncrypt.cbSize    = 0;
    blobEncrypt.pBlobData = NULL;

    BLOB blobSign;
    blobSign.cbSize       = 0;
    blobSign.pBlobData    = NULL;

    HRESULT hr;
    hr = MQSec_StorePubKeys( 
			FALSE,
			eBaseProvider,
			eEnhancedProvider,
			&blobEncrypt,
			&blobSign 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }

    P<BYTE> pCleaner1            = blobEncrypt.pBlobData;
    P<BYTE> pCleaner2            = blobSign.pBlobData;

    propIDs[iProperty]           = PROPID_QM_ENCRYPT_PKS;
    propVariants[iProperty].vt   = VT_BLOB;
    propVariants[iProperty].blob = blobEncrypt;
    iProperty++;

    propIDs[iProperty]           = PROPID_QM_SIGN_PKS;
    propVariants[iProperty].vt   = VT_BLOB;
    propVariants[iProperty].blob = blobSign;
    iProperty++;

    //
    // Get sites of this machine.
    //
    CACLSID cauuid;
    hr = _GetSites( 
			pwszMachineName,
			&cauuid
			);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }
    if (cauuid.cElems > 0)
    {
        //
        //  Save one of the site-ids, to be written later to registry
        //
        *pguidSiteId = cauuid.pElems[0];
    }

    propIDs[iProperty] = PROPID_QM_SITE_IDS;
    propVariants[iProperty].vt = (VT_CLSID | VT_VECTOR);
    propVariants[iProperty].cauuid.pElems = cauuid.pElems;
    propVariants[iProperty].cauuid.cElems = cauuid.cElems;
    DWORD iSitesIndex = iProperty;
    iProperty++;

    BYTE bSidBuf[256]; // should be enough for every possible SID.
    dwType = REG_BINARY;
    dwSize = sizeof(bSidBuf);

    DWORD ixQmOwnerSid = 0;

    //
    // Read user SID from registry. We'll send it to server, and server
    // add it with full-control to DACL of the msmqConfiguration object.
    //
    rc = GetFalconKeyValue( 
			MSMQ_SETUP_USER_SID_REGNAME,
			&dwType,
			static_cast<PVOID>(bSidBuf),
			&dwSize 
			);

    if (rc != ERROR_SUCCESS)
    {
        //
        // See if setup from local user.
        //
        DWORD dwLocal = 0;
        dwSize = sizeof(dwLocal);

        rc = GetFalconKeyValue( 
				MSMQ_SETUP_USER_LOCAL_REGNAME,
				&dwType,
				&dwLocal,
				&dwSize 
				);

        if ((rc == ERROR_SUCCESS) && (dwLocal == 1))
        {
            // Ok, Local user.
        }
        else
        {
			//
			// Ok, This is the case we JoinDomain from Workgroup, 
			// or move domains when initial installation was workgroup.
            // in that case both MSMQ_SETUP_USER_SID_REGNAME, MSMQ_SETUP_USER_LOCAL_REGNAME
			// are not set 
			// in This case we will give no specific user right like in w2k
            // ilanh 27-Aug-2000
			// 
			TrWARNING(GENERAL, "setup\\UserSid and setup\\LocalUser not found, assuming JoinDomain from workgroup, or first installation was workgroup");
		}
    }
    else
    {
        PSID pSid = (PSID) bSidBuf;
        ASSERT(IsValidSid(pSid));

        //
        // Caution: This propid is known only to Win2000
        // RTM msmq servers and above (not win2k beta3).
        // So if we fail to create the object, we try again w/o it.
        // This propid should be the last one in the list.
        //
        ULONG ulSidSize = GetLengthSid(pSid);
        ASSERT(ulSidSize <= dwSize);

        propIDs[iProperty] = PROPID_QM_OWNER_SID;
        propVariants[iProperty].vt = VT_BLOB;
        propVariants[iProperty].blob.pBlobData = (BYTE*) bSidBuf;
        propVariants[iProperty].blob.cbSize = ulSidSize;
        ixQmOwnerSid = iProperty;
        iProperty++;

        if (ppUserSid)
        {
            *ppUserSid = (PSID) new BYTE[ulSidSize];
            memcpy(*ppUserSid, bSidBuf, ulSidSize);
        }
    }

	ASSERT(iProperty <= x_nMaxProps);

    //
    // Create the msmq Configuration object !
    //
    hr = ADCreateObject(
			eMACHINE,
			NULL,       // pwcsDomainController
			false,	    // fServerName
			pwszMachineName,
			NULL,
			iProperty,
			propIDs,
			propVariants,
			pMachineGuid 
			);

    if (FAILED(hr) && (ixQmOwnerSid > 0))
    {
        ASSERT(("PROPID_QM_OWNDER_SID should be the last propid!",
                    ixQmOwnerSid == (iProperty - 1))) ;
        //
        // If OWNER_SID was used, then try again without it, because this
        // propid is not known to win2k beta3 msmq server (and maybe our
        // server is beta3).
        //
        iProperty--;

        hr = ADCreateObject(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				pwszMachineName,
				NULL,
				iProperty,
				propIDs,
				propVariants,
				pMachineGuid
				);
    }

    delete propVariants[iSitesIndex].cauuid.pElems;
    if (FAILED(hr))
    {
        if (hr == MQDS_OBJECT_NOT_FOUND)
        {
            //
            // We can verify computer object 
            //
            HRESULT hr1 = _VerifyComputerObject(pwszMachineName);
            if (FAILED(hr1))
            {
                return LogHR(hr1, s_FN, 380);
            }
        }
        
        return LogHR(hr, s_FN, 230);
    }

    return hr ;
}

//+------------------------------------------
//
//   HRESULT  _PostCreateProcessing()
//
//+------------------------------------------

static 
HRESULT  
_PostCreateProcessing( 
	IN HRESULT    hrCreate,                                       
	IN GUID      *pMachineGuid,
	IN WCHAR     *pwszMachineName,
	IN BOOL       fSupportDepClient,
    IN const GUID * pguidSiteIdOfCreatedObject
	)
{
    if (hrCreate == MQ_ERROR_MACHINE_EXISTS)
    {
        //
        // that's OK. the msmqConfiguration object already exist.
        // Register it locally.
        //
        *pMachineGuid = GUID_NULL;
    }
    else if (FAILED(hrCreate))
    {
        WCHAR wBuf[128];
        swprintf(wBuf, L"%lxh", hrCreate);
        EvReport(CreateMsmqConfig_ERR, 1, wBuf);

        return LogHR(hrCreate, s_FN, 330);
    }
    else if (memcmp(pMachineGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
        //
        // That may happen if client on  Win2000 RTM is setting up
        // agsinst a beta3 Win2000 server. Explicitely query the
        // server for machine guid. On win2000 rtm, the machine guid
        // is returned by call to CreateObject().
        //
    }

    HRESULT hr = _RegisterMachine( 
					pwszMachineName,
					pMachineGuid,
					fSupportDepClient,
                    pguidSiteIdOfCreatedObject
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }

    //
    // update QM guid in registry. We don't need previous values.
    //
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);

    LONG rc = SetFalconKeyValue( 
					MSMQ_QMID_REGNAME,
					&dwType,
					pMachineGuid,
					&dwSize
					);
    DBG_USED(rc);
    ASSERT(rc == ERROR_SUCCESS);

    return MQ_OK;
}

//+-------------------------------------------------------------------------
//
//  HRESULT APIENTRY  MqCreateMsmqObj()
//
//  Create the msmqConfiguration object in ADS.
//
//  Parameters:
//
// Algorithm:
//   For Setup - the name of the msmq server is
//   already saved in registry. It was found by the setup process or was
//   given by user. For setup it's enough to use any msmq server (on domain
//   controller) in the client's site as there are no special restrictions
//   on the create process.
//
//+-------------------------------------------------------------------------

extern HINSTANCE  g_hMyModule;

HRESULT APIENTRY  MqCreateMsmqObj()
{
#ifdef _DEBUG
    TCHAR tszFileName[MAX_PATH * 2] = L"";
    DWORD dwGet = GetModuleFileName( 
						g_hMyModule,
						tszFileName,
						STRLEN(tszFileName) 
						);
    if (dwGet)
    {
        DWORD dwLen = lstrlen(tszFileName);
        lstrcpy(&tszFileName[dwLen - 3], TEXT("ini"));

        UINT uiDbg = GetPrivateProfileInt( 
						TEXT("Debug"),
						TEXT("StopBeforeRun"),
						0,
						tszFileName 
						);
        if (uiDbg)
        {
            ASSERT(0);
        }
    }
#endif

	//
	// Ignore WorkGroup registry
	//
    HRESULT hr = ADInit (
					NULL,   // pLookDS,
					NULL,   // pGetServers
					true,   // fSetupMode
					false,  // fQMDll
					true,   // fIgnoreWorkGroup
                    true    // fDisableDownlevelNotifications
					);  
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 320);
    }

    //
    // Get name of local machine.
    //
    BOOL  fUsingDNS = TRUE;
    DWORD dwNumChars = 0;
    AP<WCHAR> pwszMachineName;
    BOOL fGet = GetComputerNameExW( 
					ComputerNameDnsFullyQualified,
					pwszMachineName,
					&dwNumChars 
					);
    if (dwNumChars > 0)
    {
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameExW( 
					ComputerNameDnsFullyQualified,
					pwszMachineName,
					&dwNumChars 
					);
    }

    if (!fGet || (dwNumChars == 0))
    {
        ASSERT(!fGet && (dwNumChars == 0));
        //
        // DNS name not available. Retrieve NetBIOS name.
        //
		pwszMachineName.free();
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameW( 
					pwszMachineName,
					&dwNumChars 
					);
        fUsingDNS = FALSE;
    }
    ASSERT(fGet && (dwNumChars > 0));

    hr = MQ_OK;
    GUID MachineGuid = GUID_NULL;
    BOOL fSupportDepClient = 0;
    P<BYTE> pUserSid = NULL;
    GUID guidSiteId = GUID_NULL;

    hr = _CreateTheConfigurationObject(
				pwszMachineName,
				&MachineGuid,
				(PSID*) &pUserSid,
				&fSupportDepClient,
                &guidSiteId
				);

    if ((hr == MQDS_OBJECT_NOT_FOUND) && fUsingDNS)
    {
        //
        // This problem may happen if attribute dnsHostName is not set
        // in the computer object.
        //
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        pwszMachineName.free();
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameW( 
					pwszMachineName,
					&dwNumChars 
					);
        ASSERT(fGet && (dwNumChars > 0));
        fUsingDNS = FALSE;

        if (fGet && (dwNumChars > 0))
        {
            if (pUserSid)
            {
                delete pUserSid.detach();
            }
            MachineGuid = GUID_NULL ;

            hr = _CreateTheConfigurationObject(
						pwszMachineName,
						&MachineGuid,
						(PSID*) &pUserSid,
						&fSupportDepClient,
                        &guidSiteId
						);
        }
    }

    hr = _PostCreateProcessing( 
				hr,
				&MachineGuid,
				pwszMachineName,
				fSupportDepClient,
                &guidSiteId
				);

    if (SUCCEEDED(hr))
    {
        hr = _UpdateMachineSecurityReg( 
					pwszMachineName,
					pUserSid,
					&MachineGuid 
					);
    }

    return LogHR(hr, s_FN, 370);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\mqupgrd.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mqupgrd.cpp

Abstract:

    Helper DLL for mqqm.dll. 

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#include "stdh.h"
#include "cluster.h"
#include "mqupgrd.h"
#include "..\msmqocm\setupdef.h"
#include <autorel2.h>
#include <shlobj.h>
#include "_mqres.h"

#include <Cm.h>
#include <Tr.h>
#include <Ev.h>


#include "mqupgrd.tmh"

static WCHAR *s_FN=L"mqupgrd/mqupgrd";

HINSTANCE g_hMyModule = NULL;


BOOL
WINAPI
DllMain(
    HANDLE hDll,
    DWORD  Reason,
    LPVOID  //Reserved
    )
{
    if (Reason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

       	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ", KEY_READ);
		TrInitialize();
		EvInitialize(QM_DEFAULT_SERVICE_NAME);

        g_hMyModule = (HINSTANCE) hDll;
    }

    if (Reason == DLL_PROCESS_DETACH)
    {
        WPP_CLEANUP();
    }

    return TRUE;

} //DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\stdh.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file to MQUPGRD

Author:

    Shai Kariv (ShaiK) 14-Sep-1998.

--*/


#ifndef _MQUPGRD_STDH_H_
#define _MQUPGRD_STDH_H_


#include "upgrdres.h"
#include <_stdh.h>
#include <mqutil.h>
#include <_mqdef.h>
#include <mqreport.h>
#include <mqlog.h>


//
//  STL include files are using placment format of new
//
#ifdef new
#undef new
#endif

#include <string>
using std::wstring;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


extern HINSTANCE g_hMyModule;

extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);

#endif //_MQUPGRD_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\creatobj.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    creatobj.h

Abstract:

    Create msmqConfiguration object, first time msmq service boot
    after setup.

Author:

    Doron Juster (DoronJ)  08-Mar-1999

--*/

#define NUMOF_CREATE_OBJ_EVENTS  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\util.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    util.cpp

Abstract:
                                                        
    general utilities and misc

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#include "stdh.h"

#include "util.tmh"

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\dscomm_c_.c ===
#pragma warning(push, 3)
#pragma warning(disable: 4701)
#include <dscomm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqcomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msmqcomp.rc
//
#define IDS_Description                 1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqcomp\msmqcomp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msmqcomp.cpp

Abstract:

    Entry point for NT 5.0 upgrade compatibility check

Author:

    Shai Kariv  (ShaiK)  08-Apr-98

--*/

#include <windows.h>
#include <winuser.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>
#include <assert.h>

#include <mqmacro.h>

#include "uniansi.h"
#include "mqtypes.h"
#include "_mqdef.h"
#include "_mqini.h"
#include "mqprops.h"

#include "..\msmqocm\setupdef.h"
#include "..\msmqocm\comreg.h"
#include "resource.h"

#define COMPFLAG_USE_HAVEDISK 0x00000001

typedef struct _COMPATIBILITY_ENTRY {
	LPTSTR Description;
	LPTSTR HtmlName;
	LPTSTR TextName;       OPTIONAL
	LPTSTR RegKeyName;     OPTIONAL
	LPTSTR RegValName;     OPTIONAL
	DWORD  RegValDataSize; OPTIONAL
	LPVOID RegValData;     OPTIONAL
	LPVOID SaveValue;
	DWORD  Flags;
    LPTSTR InfName;
    LPTSTR InfSection;
} COMPATIBILITY_ENTRY, *PCOMPATIBILITY_ENTRY;

typedef BOOL
(CALLBACK *PCOMPAIBILITYCALLBACK)(
	PCOMPATIBILITY_ENTRY CompEntry,
	LPVOID Context
    );

HMODULE s_hMyModule;

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL 
DllMain(
    IN const HANDLE DllHandle,
    IN const DWORD  Reason,
    IN const LPVOID Reserved 
    )
{
	UNREFERENCED_PARAMETER(Reserved);

	switch (Reason)
	{
	    case DLL_PROCESS_ATTACH:
            s_hMyModule = (HINSTANCE)DllHandle;
			break;

		case DLL_PROCESS_DETACH:
			break;

		default:
			break;
	}

    return TRUE;

} //DllMain


//+-------------------------------------------------------------------------
//
//  Function:    MqReadRegistryValue
//
//  Description: Reads values from MSMQ registry section
//
//--------------------------------------------------------------------------
static
LONG
MqReadRegistryValue(
    IN     const LPCTSTR szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData
	)
{
	// 
	// Parse the entry to detect key name and value name
	//
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    TCHAR szValueName[256] = {_T("")};
	lstrcpy(szValueName, _tcsinc(pLastBackslash));
	lstrcpy(pLastBackslash, TEXT(""));

	//
	// Open the key for read
	//
	HKEY  hRegKey;
	LONG rc = RegOpenKeyEx(
		          HKEY_LOCAL_MACHINE,
				  szKeyName,
				  0,
				  KEY_READ,
				  &hRegKey
				  );
	if (ERROR_SUCCESS != rc)
	{
		return rc;
	}

	//
	// Get the value data
	//
    rc = RegQueryValueEx( 
		     hRegKey, 
			 szValueName, 
			 0, 
			 NULL,
             (PBYTE)pValueData, 
			 &dwNumBytes
			 );

	RegCloseKey(hRegKey);
    return rc;

} // MqReadRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqAcmeDsServer
//
//  Description: Detetcs ACME installation of MSMQ 1.0 DS Server
//
//  Parameters:  OUT BOOL *pfDsServer - set to TRUE iff MSMQ1 DS Server found
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqAcmeDsServer(
	OUT BOOL   *pfDsServer
	)
{

    *pfDsServer = FALSE;

    //
    // Open ACME registry key for read
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_READ,
                  &hKey 
                  );
	if (rc != ERROR_SUCCESS)
    {
		//
		// MSMQ 1.0 (ACME) not installed.
		// Get out of here.
		//
		return rc;
	}

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile ;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            assert(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            pFile = CharNext(pFile);
            if (OcmStringsEqual(pFile, ACME_STF_NAME))
            {
                bFound = TRUE;
            }
        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found (there's no ACME installation
		// of MSMQ 1.0 on this machine).
        //
        return ERROR_NOT_INSTALLED;
    }

    //
    // Get MSMQ type
    //
    DWORD dwMsmqType, dwServerType;
    rc = MqReadRegistryValue(
             MSMQ_ACME_TYPE_REG,
			 sizeof(DWORD),
			 (PVOID) &dwMsmqType
			 );
    if (ERROR_SUCCESS != rc)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        // Consider ACME installation to be corrupted (not completed successfully).
        //
        return rc;
    }

    if (MSMQ_ACME_TYPE_SRV == dwMsmqType)
    {
        //
        // MSMQ 1.0 (ACME) Server is installed.
        // Check type of server (FRS, PEC, etc.)
        //
        rc = MqReadRegistryValue(
                 MSMQ_MQS_REGNAME,
                 sizeof(DWORD),
                 (PVOID) &dwServerType
                 );
        if (ERROR_SUCCESS != rc)
        {
            //
            // Failed to read server type.
            //
            return rc;
        }

        if (SERVICE_PEC == dwServerType || SERVICE_PSC == dwServerType)
        {
            *pfDsServer = TRUE;
        }
    }

    return ERROR_SUCCESS;

} // CheckMsmqAcmeDsServer


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqDsServer
//
//  Description: Detects installation of MSMQ 1.0 (K2) DS Server
// 
//  Parameters:  OUT BOOL *pfDsServer - set to TRUE iff MSMQ1 DS Server found
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqDsServer(
	OUT BOOL   *pfDsServer
	)
{
    *pfDsServer = FALSE;

    //
    // Look in MSMQ registry section for InstalledComponents value.
    // If it exists, MSMQ 1.0 (K2) or MSMQ 2.0 is installed.
    //
	DWORD dwOriginalInstalled;
	LONG rc = MqReadRegistryValue( 
      		      OCM_REG_MSMQ_SETUP_INSTALLED,
				  sizeof(DWORD),
				  (PVOID) &dwOriginalInstalled
				  );

    if (ERROR_SUCCESS != rc)
    {
        //
		// MSMQ 1.0 (K2) not installed.
        // Check if MSMQ 1.0 (ACME) is installed.
        //
        return CheckMsmqAcmeDsServer(pfDsServer);
    }

    //
    // MSMQ 1.0 (K2) or MSMQ 2.0 is installed. 
    // For MSMQ 2.0 we don't have anything to do.
    //
    TCHAR szMsmqVersion[MAX_STRING_CHARS] = {0};
    rc = MqReadRegistryValue(
        OCM_REG_MSMQ_PRODUCT_VERSION,
        sizeof(szMsmqVersion),
        (PVOID) szMsmqVersion
        );
    if (ERROR_SUCCESS == rc)
    {
        //
        // The ProductVersion value was successfully read from registry,
        // i.e. MSMQ 2.0 is installed on the machine.
        // i.e. MSMQ 1.0 is NOT installed on the machine.
        //
        return ERROR_NOT_INSTALLED;
    }
    
    //
    // Check type of MSMQ 1.0 (K2)
    //
    if (OCM_MSMQ_SERVER_INSTALLED == (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK))
    {
        //
        // Server. Check type of server.
        //
        DWORD dwServerType = dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK;
        if (OCM_MSMQ_SERVER_TYPE_PEC == dwServerType ||
            OCM_MSMQ_SERVER_TYPE_PSC == dwServerType)
        {
            *pfDsServer = TRUE;
        }
    }

	return ERROR_SUCCESS;

} // CheckMsmqDsServer


//+-------------------------------------------------------------------------
//
//  Function:   CompatibilityProblemFound
//
//  Returns:    TRUE iff MSMQ 1.0 DS Server found on the machine.
//
//--------------------------------------------------------------------------
static
BOOL
CompatibilityProblemFound()
{
    BOOL fDsServer = FALSE;
    LONG rc = CheckMsmqDsServer(&fDsServer);
    UNREFERENCED_PARAMETER(rc);

    return fDsServer;

} // CompatibilityProblemFound


//+-------------------------------------------------------------------------
//
//  Function:   MsmqComp
//
//--------------------------------------------------------------------------
BOOL
MsmqComp(
	PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    if (CompatibilityProblemFound())
    {
        COMPATIBILITY_ENTRY CompEntry;
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        TCHAR szDescription[1024];
        LoadString(  
            s_hMyModule,
            IDS_Description,
            szDescription,
            sizeof(szDescription)/sizeof(szDescription[0])
            );
        CompEntry.Description = szDescription;
        CompEntry.TextName    = L"CompData\\msmqcomp.txt";

        return CompatibilityCallback(
                   &CompEntry,
                   Context
                   );
    }

    return TRUE;

} // MsmqComp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\mqupgrd\_autorel.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    _autorel.h

Abstract:

    My auto release classes

Author:

    Shai Kariv (ShaiK) 20-Sep-1998.

--*/

#ifndef _MQUPGRD_AUTOREL_H_
#define _MQUPGRD_AUTOREL_H_

#include <setupapi.h>


class CAutoCloseInfHandle
{
public:
    CAutoCloseInfHandle(HINF h = INVALID_HANDLE_VALUE):m_h(h) {};
    ~CAutoCloseInfHandle() { if (INVALID_HANDLE_VALUE != m_h) SetupCloseInfFile(m_h); };

public:
    CAutoCloseInfHandle & operator =(HINF h) { m_h = h; return(*this); };
    HINF * operator &() { return &m_h; };
    operator HINF() { return m_h; };

private:
    HINF m_h;
};


class CAutoCloseFileQ
{
public:
    CAutoCloseFileQ(HSPFILEQ h = INVALID_HANDLE_VALUE):m_h(h) {};
    ~CAutoCloseFileQ() { if (INVALID_HANDLE_VALUE != m_h) SetupCloseFileQueue(m_h); };

public:
    CAutoCloseFileQ & operator =(HSPFILEQ h) { m_h = h; return(*this); };
    HSPFILEQ * operator &() { return &m_h; };
    operator HSPFILEQ() { return m_h; };

private:
    HSPFILEQ m_h;
};




#endif  //_MQUPGRD_AUTOREL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\activex.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    activex.cpp

Abstract:

    Code to install Falcon activeX dll.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "activex.tmh"

//+--------------------------------------------------------------
//
// Function: RegisterActiveX
//
// Synopsis: Installs or uninstalls MSMQ ActiveX DLL
//
//+--------------------------------------------------------------
void 
RegisterActiveX( 
	bool bRegister
	)
{
    //
    // do native registration (e.g. 32 bit on win32, 64 bit on win64)
    //
    try
    {
        RegisterDll(
            bRegister,
            false,
            ACTIVEX_DLL
            );
#ifdef _WIN64
    //
    // do wow64 registration (e.g. 32 bit on win64)
    //
     
        RegisterDll(
            bRegister,
            TRUE,
            ACTIVEX_DLL
            );

#endif //_WIN64

    }
    catch(bad_win32_error e)
    {
        MqDisplayError(
            NULL, 
            IDS_ACTIVEXREGISTER_ERROR,
            e.error(),
            ACTIVEX_DLL
            );
    }
} //Register ActiveX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\devdrvr.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    devdrvr.cpp

Abstract:

    Code to install Falcon device driver.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
extern "C"{
#include <wsasetup.h>
}

#include "devdrvr.tmh"


//+--------------------------------------------------------------
//
// Function: InstallDeviceDriver
//
// Synopsis: Installs driver
//
//+--------------------------------------------------------------
BOOL 
InstallDeviceDriver(
        LPCWSTR pszDisplayName,
        LPCWSTR pszDriverPath,
        LPCWSTR pszDriverName
        )
{
    try
    {
        SC_HANDLE hService = CreateService(
                    		    g_hServiceCtrlMgr, 
                    		    pszDriverName,
                                pszDisplayName, 
                    		    SERVICE_ALL_ACCESS,
                                SERVICE_KERNEL_DRIVER, 
                    		    SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL, 
		                        pszDriverPath, 
		                        NULL, 
                                NULL, 
                                NULL, 
                                NULL, 
                                NULL
                                );
        if (hService != NULL)
        {
            CloseServiceHandle(hService);
            return TRUE;
        }
    
        //
        // CreateService failed.
        //
    
        DWORD err = GetLastError();
        if (err != ERROR_SERVICE_EXISTS)
        {
            throw bad_win32_error(err);
        }

        //
        // Service already exists.
        //
        // This should be ok. But just to be on the safe side,
        // reconfigure the service (ignore errors here).
        //

        hService = OpenService(g_hServiceCtrlMgr, pszDriverName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
            return TRUE;

    
        ChangeServiceConfig(
                hService,
                SERVICE_KERNEL_DRIVER,
                SERVICE_DEMAND_START,
                SERVICE_ERROR_NORMAL,
                pszDriverPath,
                NULL, 
                NULL, 
                NULL, 
                NULL, 
                NULL,
                pszDisplayName
                );
    
        //
        // Close the device driver handle
        //
        CloseServiceHandle(hService);
        return TRUE;

    }
    catch(const bad_win32_error& err)
    {

        if (err.error() == ERROR_SERVICE_MARKED_FOR_DELETE)
        {
            MqDisplayError(
                NULL, 
                IDS_DRIVERCREATE_MUST_REBOOT_ERROR, 
                ERROR_SERVICE_MARKED_FOR_DELETE, 
                pszDriverName
                );
            return FALSE;
        }
        
        MqDisplayError(
            NULL, 
            IDS_DRIVERCREATE_ERROR, 
            err.error(), 
            pszDriverName
            );
        return FALSE;
    }
} //InstallDeviceDriver


//+--------------------------------------------------------------
//
// Function: InstallMQACDeviceDriver
//
// Synopsis: Installs MQAC service
//
//+--------------------------------------------------------------
BOOL 
InstallMQACDeviceDriver()
{      
    DebugLogMsg(eAction, L"Installing the Message Queuing Access Control service (" MSMQ_DRIVER_NAME L")");

    //
    // Form the path to the device driver
    //
	std::wstring  DriverFullPath = g_szSystemDir + L"\\" + MSMQ_DRIVER_PATH;

    //
    // Create the device driver
    //
	CResString strDisplayName(IDS_MSMQ_DRIVER_DESPLAY_NAME);
    BOOL f = InstallDeviceDriver(
                strDisplayName.Get(),
                DriverFullPath.c_str(),
                MSMQ_DRIVER_NAME
                );
    
    return f;

} //InstallMQACDeviceDriver


//+--------------------------------------------------------------
//
// Function: InstallDeviceDrivers
//
// Synopsis: Installs all needed drivers
//
//+--------------------------------------------------------------
BOOL 
InstallDeviceDrivers()
{ 
	DebugLogMsg(eAction, L"Installing all needed device drivers");
    BOOL f = InstallMQACDeviceDriver();
    if (!f)
    {
        return f;
    }
    g_fDriversInstalled = TRUE;
    
    f = InstallPGMDeviceDriver();
   
    return f;
} //InstallDeviceDrivers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\dslibs.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dslibs.cpp

Abstract:

    Initialize DS libraries.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "dslibs.tmh"


bool WriteDsEnvRegistry(DWORD dwDsEnv)
/*++
Routine Description:
    Write DsEnvironment registry

Arguments:
	dwDsEnv - value to put in registry

Returned Value:
    true iff successful

--*/
{
	ASSERT(dwDsEnv != MSMQ_DS_ENVIRONMENT_UNKNOWN);
    if (!MqWriteRegistryValue(MSMQ_DS_ENVIRONMENT_REGNAME, sizeof(DWORD), REG_DWORD, &dwDsEnv))
    {
        return false;
    }

    DebugLogMsg(eAction, L"Setting the DS environment to %d", dwDsEnv); 
	return true;
}


bool DsEnvSetDefaults()
/*++
Routine Description:
    Detect DS environment and initialize DsEnvironment registry

Arguments:
	None

Returned Value:
    true iff successful

--*/
{
    if (g_fWorkGroup || g_fDsLess || g_fInstallMSMQOffline)
	{
		//
		// For workgroup the environment 
		// putting a default value of PURE_AD
		// we are not supporting join domain to MQIS environment.
		//
	    DebugLogMsg(eAction, L"Setting the DsEnvironment registry value for workgroup or offline mode");
		return WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_PURE_AD);
	}

	if(g_fUpgrade)
	{
		DWORD dwDsEnv = MSMQ_DS_ENVIRONMENT_UNKNOWN;
		if(MqReadRegistryValue( 
				MSMQ_DS_ENVIRONMENT_REGNAME,
				sizeof(dwDsEnv),
				(PVOID) &dwDsEnv 
				))
		{
			//
			// DsEnvironment registry already exist.
			// This is the case when we upgrade from XP or .NET
			// Don't overrun DsEnvironment value.
			// We already performed DS detection. 
			//
			ASSERT(dwDsEnv != MSMQ_DS_ENVIRONMENT_UNKNOWN);
			return true;
		}

		//
		// Every upgrade from NT4\win9x\w2k will start as MQIS environment
		//
	    DebugLogMsg(eAction, L"Setting the DsEnvironment registry value for upgrade");
		return WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_MQIS);
	}

	if(g_fDependentClient)
	{
		//
		// For dependent client - perform raw detection to decide ds environment
		//
	    DebugLogMsg(eAction, L"Setting the DsEnvironment registry value for dependent client");
		return WriteDsEnvRegistry(ADRawDetection());
	}

#ifdef _DEBUG

	//
	// Raw Ds environment detection was done earlier in setup
	// check that the registry is indeed initialize 
	//
    DWORD dwDsEnv = MSMQ_DS_ENVIRONMENT_UNKNOWN;
    if(!MqReadRegistryValue( 
			MSMQ_DS_ENVIRONMENT_REGNAME,
            sizeof(dwDsEnv),
            (PVOID) &dwDsEnv 
			))
	{
		ASSERT(("could not read DsEnvironment registry", 0));
	}

	ASSERT(dwDsEnv != MSMQ_DS_ENVIRONMENT_UNKNOWN);
#endif

	return true;

}

//+--------------------------------------------------------------
//
// Function: DSLibInit
//
// Synopsis: Loads and initializes DS client DLL
//
//+--------------------------------------------------------------
static
BOOL
DSLibInit()
{
	//
    // Initialize the DLL to setup mode.
    //

    HRESULT hResult = ADInit(
						  NULL,  // pLookDS
						  NULL,   // pGetServers
						  true,   // fSetupMode
						  false,  //  fQMDll
						  false,  // fIgnoreWorkGroup
						  true    // fDisableDownlevelNotifications
						  );

    if FAILED(hResult)                                     
    {                                                      
        MqDisplayError(NULL, IDS_DSCLIENTINITIALIZE_ERROR, hResult);
        return FALSE;
    }
    return TRUE;

} //DSLibInit

//+--------------------------------------------------------------
//
// Function: BOOL LoadDSLibrary()
//
// Synopsis: Loads and initializes DS client or server DLL
//
//+--------------------------------------------------------------
BOOL LoadDSLibrary()
{
	return DSLibInit();
} //LoadDSLibrary
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\getrelax.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: getrelax.cpp

Abstract:
    Read nt4 relaxation flag from ADS.

Author:
    Doron Juster (DoronJ)

--*/

#include "msmqocm.h"
#include "mqattrib.h"
#include "mqdsname.h"
#include "dsutils.h"
#include <adsiutl.h>

//+-------------------------------------------------------
//
//  HRESULT  GetNt4RelaxationStatus(ULONG *pulRelax)
//
//+-------------------------------------------------------

HRESULT APIENTRY  GetNt4RelaxationStatus(ULONG *pulRelax)
{
    //
    // Bind to RootDSE to get configuration DN
    //
    HRESULT hr;
    R<IADs> pRootDSE;
	
	hr = ADsOpenObject( 
				const_cast<LPWSTR>(x_LdapRootDSE),
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, 
				IID_IADs,
				(void **)&pRootDSE
				);	

    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // Get configuration DN
    //
    CAutoVariant varRootDN;
    BS bstrTmp = L"rootDomainNamingContext" ;
    hr = pRootDSE->Get(bstrTmp, &varRootDN);
    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT * pvarRootDN = &varRootDN;
    ASSERT(pvarRootDN->vt == VT_BSTR);
    ASSERT(pvarRootDN->bstrVal);


    DWORD len = wcslen( pvarRootDN->bstrVal );
    if ( len == 0)
    {
        return(MQ_ERROR);
    }

	std::wstringstream MsmqServices;
	MsmqServices <<x_LdapProvider <<x_MsmqServiceContainerPrefix <<L"," <<pvarRootDN->bstrVal;

    R<IDirectoryObject> pDirObj ;
	AP<WCHAR> pEscapeAdsPathNameToFree;
	
	hr = ADsOpenObject(
				UtlEscapeAdsPathName(MsmqServices.str().c_str(), pEscapeAdsPathNameToFree),
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, 
				IID_IDirectoryObject,
				(void **)&pDirObj
				);
    

    if (FAILED(hr))
    {
        return hr ;
    }

    LPWSTR  ppAttrNames[] = {const_cast<LPWSTR> (MQ_E_NAMESTYLE_ATTRIBUTE)} ;
    DWORD   dwAttrCount = 0 ;
    ADS_ATTR_INFO *padsAttr ;

    hr = pDirObj->GetObjectAttributes( ppAttrNames,
                             (sizeof(ppAttrNames) / sizeof(ppAttrNames[0])),
                                       &padsAttr,
                                       &dwAttrCount ) ;
    if (dwAttrCount != 0)
    {
        ASSERT(dwAttrCount == 1) ;

        ADS_ATTR_INFO adsInfo = padsAttr[0] ;
        if (adsInfo.dwADsType == ADSTYPE_BOOLEAN)
        {
            ADSVALUE *pAdsVal = adsInfo.pADsValues ;
            *pulRelax = (ULONG) pAdsVal->Boolean ;
        }
        else
        {
            ASSERT(0) ;
            *pulRelax = MQ_E_RELAXATION_DEFAULT ;
        }
    }
    else
    {
        *pulRelax = MQ_E_RELAXATION_DEFAULT ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\comreg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    comreg.h

Abstract:

    Common registry definition.

Author:

    Doron Juster  (DoronJ)  26-Aug-97

--*/

//
// Names of registry values.
//
#define  OCM_REG_STORAGE_XACT_LOG       TEXT("StoreXactLogPath")
#define  OCM_REG_STORAGE_JOURNAL        TEXT("StoreJournalPath")
#define  OCM_REG_STORAGE_LOG            TEXT("StoreLogPath")
#define  OCM_REG_STORAGE_PERSISTENT     TEXT("StorePersistentPath")
#define  OCM_REG_STORAGE_RELIABLE       TEXT("StoreReliablePath")

#define  OCM_REG_LASTPRIVATEQ           TEXT("LastPrivateQueueId")

#define  FALCON_REG_POS_DESC            TEXT("HKLM")
#define  HKLM_DESC                      TEXT("HKLM")

#define  WELCOME_TODOLIST_MSMQ_KEY      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\MSMQ")
#define  WELCOME_TITLE_NAME             TEXT("Title")
#define  WELCOME_CONFIG_COMMAND_NAME    TEXT("ConfigCommand")
#define  WELCOME_CONFIG_ARGS_NAME       TEXT("ConfigArgs")

#define  MSMQ_FILES_COPIED_REGNAME      TEXT("FilesAlreadyCopied")

//
// Names of MSMQ 1.0 registry values
//
#define  OCM_REG_MSMQ_SHORTCUT_DIR      TEXT("OCMsetup\\ShortcutDirectory")
#define  ACME_KEY   TEXT("SOFTWARE\\Microsoft\\MS Setup (ACME)\\Table Files")
#define  ACME_STF_NAME                  TEXT("MSMQ.STF")
#define  ACME_SETUP_DIR_NAME            TEXT("setup")
#define  MSMQ_ACME_TYPE_REG             TEXT("setup\\Type")
#define  MSMQ_ACME_TYPE_IND             0
#define  MSMQ_ACME_TYPE_SRV             1
#define  MSMQ_ACME_TYPE_RAS             2
#define  MSMQ_ACME_TYPE_DEP             3

//
// MSMQ 1.0 K2 and MSMQ 2.0 Beta 2 values
//
#define  OCM_REG_MSMQ_SETUP_INSTALLED   TEXT("OCMsetup\\InstalledComponents")
#define  OCM_REG_MSMQ_DIRECTORY         TEXT("OCMsetup\\Directory")

//
// MSMQ 2.0 Beta 2 registry values
//
#define  OCM_REG_MSMQ_PRODUCT_VERSION   TEXT("OCMsetup\\ProductVersion")
#define  OCM_REG_MSMQ_BUILD_DESCRIPTION TEXT("OCMsetup\\BuildDescription")

//
// MSMQ 2.0 Beta 3 registry values
//
#define  REG_INSTALLED_COMPONENTS       TEXT("InstalledComponents")
#define  REG_DIRECTORY                  TEXT("Directory")

//
// These values indicate what type of MSMQ 2.0 / MSMQ 1.0 (K2) is installed
//
#define OCM_MSMQ_INSTALLED_TOP_MASK    0xe0000000
#define OCM_MSMQ_SERVER_INSTALLED      0xe0000000
#define OCM_MSMQ_RAS_SERVER_INSTALLED  0xc0000000
#define OCM_MSMQ_IND_CLIENT_INSTALLED  0xa0000000
#define OCM_MSMQ_DEP_CLIENT_INSTALLED  0x80000000
#define OCM_MSMQ_SERVER_TYPE_MASK      0x1e000000
#define OCM_MSMQ_SERVER_TYPE_PEC       0x1e000000
#define OCM_MSMQ_SERVER_TYPE_PSC       0x1c000000
#define OCM_MSMQ_SERVER_TYPE_BSC       0x1a000000
#define OCM_MSMQ_SERVER_TYPE_SUPPORT   0x18000000


#define TCPIP_REG_PARAM     TEXT("System\\CurrentControlSet\\Services\\TCPIP\\Parameters")
#define TCPIP_RESERVED_PORT_REGNAME TEXT("ReservedPorts")
#define MSMQ_RESERVED_TCPPORT_RANGE	TEXT("1801-1801")



//
// Registry key to hide setup tracing: it is located under MSMQ\Setup
//
#define WITHOUT_TRACING_REGKEY      TEXT("SetupWithoutTracing")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\inifile.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    inifile.cpp

Abstract:

     Handles INI files manipulations.

Author:


Revision History:

    Shai Kariv    (ShaiK)   22-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "inifile.tmh"

static
std::wstring
GetPrivateProfileStringInternal(
	std::wstring AppName,
    std::wstring KeyName
    )
{
	WCHAR buffer[MAX_STRING_CHARS + 1];
	int n = GetPrivateProfileString(
				AppName.c_str(), 
				KeyName.c_str(), 
				TEXT(""),
				buffer, 
				TABLE_SIZE(buffer), 
				g_ComponentMsmq.UnattendFile.c_str()
				);

	if(n >= TABLE_SIZE(buffer) - 1)
	{
		//
		// The string in unattended file is too long.
		//
		DebugLogMsg(eError, L"The string for %s in the unattended setup answer file is too long. The maximal length is %d.", KeyName.c_str(), TABLE_SIZE(buffer));
		throw exception();
	}
	return buffer;
}


std::wstring
ReadINIKey(
    LPCWSTR szKey
    )
/*++

	Read a key value from unattended answer file.
--*/
{
    //
    // Try obtaining the key value from the machine-specific section
    //
	std::wstring value = GetPrivateProfileStringInternal(
								g_wcsMachineName, 
								szKey 
								);
	if(!value.empty())
	{
		DebugLogMsg(eInfo, L"%s was found in the answer file. Its value is %s.", szKey, value.c_str());  
		return value;
	}

    //
    // Otherwise, obtain the key value from the MSMQ component section
    //
	value = GetPrivateProfileStringInternal(
					g_ComponentMsmq.ComponentId, 
					szKey
					);
	if(!value.empty())
	{
		DebugLogMsg(eInfo, L"%s was found in the answer file. Its value is %s.", szKey, value.c_str());  
		return value;
	}
	
	//
	// Value not found.
	//
	DebugLogMsg(eWarning, L"%s was NOT found in the answer file.", szKey);  
	return L"";    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\comerror.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    comerror.cpp

Abstract:

    Error handling code.

Author:

    Doron Juster  (DoronJ)  26-Jul-97  

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmerr.h>
#include <sstream>
#include <string>
#include <autohandle.h>
#include <strsafe.h>

#include "comerror.tmh"


static
std::wstring
FormatTime()
/*++
	Constructs and returnes a string for the current time.
--*/
{

	SYSTEMTIME time;
    GetLocalTime(&time);
	std::wstringstream OutSream;
	OutSream <<L"" <<time.wMonth <<L"-" <<time.wDay <<L"-" <<time.wYear <<L" "
		<<time.wHour <<L":" <<time.wMinute <<L":" <<time.wSecond <<L":" <<time.wMilliseconds;
	
	return OutSream.str();
}


static
std::wstring
GetLogFilePath()
/*++
    Returns the path to msmqinst.log under %WINDIR%.
--*/
{
	WCHAR buffer[MAX_PATH + 1] = L"";
    GetSystemWindowsDirectory(buffer, sizeof(buffer)/sizeof(buffer[0])); 
	std::wstringstream OutSream;
	OutSream << buffer << L"\\" << LOG_FILENAME;
	return OutSream.str();
}


static
std::wstring
GetHeader()
/*++
    Constructs and returns the header of the log file.
--*/
{
	CResString strMsg(IDS_SETUP_START_LOG); 

	std::wstringstream title;
	title<< L"| "<< strMsg.Get()<< L" ("<< FormatTime()<< L") |";
	std::wstring line(title.str().length(), L'-');

	std::wstringstream OutSream;
	OutSream<< L"\r\n"<< line<< L"\r\n"<< title.str()<< L"\r\n"<< line;
	return OutSream.str();
}


static
void
SignFile(
	HANDLE hLogFile
	)
{
	// 
	// Put this unicode signature at the head of the file.
	// This tells editors how the file is encoded.
	//
	WCHAR szUnicode[] = {0xfeff, 0x00};
	DWORD dwNumBytes =  sizeof(szUnicode);
    WriteFile(
		hLogFile, 
		szUnicode, 
		dwNumBytes, 
		&dwNumBytes, 
		NULL
		);
}


static
HANDLE
OpenOrCreateLogFile()
{
    static std::wstring LogFilePath; 
	if (LogFilePath.empty())
	{
		//
		// Get file path first time, store in static member.
		//
		LogFilePath = GetLogFilePath();
	}

	//
	// Try to open the file.
	//
    HANDLE hLogFile = CreateFile(
	                          LogFilePath.c_str(),
	                          GENERIC_WRITE, 
	                          FILE_SHARE_READ, 
	                          NULL, 
	                          OPEN_EXISTING,
	                          FILE_ATTRIBUTE_NORMAL, 
	                          NULL
	                          );

	if(hLogFile != INVALID_HANDLE_VALUE)
	{
		return hLogFile;
	}

	//
	// The file doese not exist. Create and sign it.
	//

    hLogFile = CreateFile(
                          LogFilePath.c_str(),
                          GENERIC_WRITE, 
                          FILE_SHARE_READ, 
                          NULL, 
                          CREATE_NEW,
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL
                          );

	SignFile(hLogFile);
	
	return hLogFile;
}

//+--------------------------------------------------------------
//
// Function: LogMessage
//
// Synopsis: Writes a message to the log file 
//
//+--------------------------------------------------------------
static
void
LogMessage(
    std::wstring pszMessage
    )
{
	std::wstringstream OutSream;
	CHandle hLogFile = 	OpenOrCreateLogFile();

	//
	// The header is printed only the first time this function is called.
	//
	static bool s_fFirstTime = true;
	if(s_fFirstTime)
	{
		OutSream << GetHeader();
		s_fFirstTime = false;
	}

    OutSream <<pszMessage <<L"\r\n";

    //
    // Append the message to the end of the log file
    //
	SetFilePointer(hLogFile, 0, NULL, FILE_END);

	std::wstring str(OutSream.str());
    DWORD dwNumBytes =  (DWORD)str.size() * sizeof(WCHAR);
    WriteFile(
		hLogFile, 
		str.c_str(), 
		dwNumBytes, 
		&dwNumBytes, 
		NULL
		);
}


//+--------------------------------------------------------------
//
// Function: GetErrorDescription
//
// Synopsis: Translates error code to description string
//
//+--------------------------------------------------------------
static
std::wstring
GetErrorDescription(
    const DWORD  dwErr
    )
{
    CResString strErrCode(IDS_ERRORCODE_MSG);

	std::wstringstream OutSream;
	OutSream << L"\r\n\r\n" << strErrCode.Get() << L"0x"<< std::hex << dwErr;

    //
    // Note: Don't use StpLoadDll() in this routine since it can fail and
    // we could be back here, causing an infinite loop!
    //
    // For MSMQ error code, we will take the message from MQUTIL.DLL based on the full
    // HRESULT. For Win32 error codes, we get the message from the system..
    // For other error codes, we assume they are DS error codes, and get the code
    // from ACTIVEDS dll.
    //

    DWORD dwErrorCode = dwErr;
    HMODULE hLib = 0;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;
    TCHAR szDescription[MAX_STRING_CHARS] = {0};
    DWORD dwResult = 1;

    switch (HRESULT_FACILITY(dwErr))
    {
        case FACILITY_MSMQ:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(MQUTIL_DLL);
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
            dwErrorCode = HRESULT_CODE(dwErr);
            break;

        default:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("ACTIVEDS.DLL"));
            break;
    }
    
    dwResult = FormatMessage( 
                   dwFlags,
                   hLib,
                   dwErr,
                   0,
                   szDescription,
                   sizeof(szDescription)/sizeof(szDescription[0]),
                   NULL 
                   );

    if (hLib)
	{
        FreeLibrary( hLib );
	}

    if (dwResult)
    {
        CResString strErrDesc(IDS_ERRORDESC_MSG);
		OutSream << L"\r\n" << strErrDesc.Get() << szDescription;
    }
	return OutSream.str();

} // AppendErrorDescription


static 
void 
LogUserSelection(
	int selection
	)
{
	std::wstring strSelection;
	switch(selection)
	{
		case  IDOK:
			strSelection = L"OK";
			break;

		case IDCANCEL:            
			strSelection = L"CANCEL";
			break;

		case IDABORT:
			strSelection = L"ABORT";
			break;

		case IDRETRY:            
			strSelection = L"RETRY";
			break;

		case IDIGNORE:
			strSelection = L"IGNORE";
			break;

		case IDYES:               
			strSelection = L"YES";
			break;

		case IDNO:               
			strSelection = L"NO";
			break;
		default:
			strSelection = L"???";
			break;
	}
	
	DebugLogMsg(eUser, strSelection.c_str());
}


//+--------------------------------------------------------------
//
// Function: vsDisplayMessage
//
// Synopsis: Used internally in this module to show message box
//
//+--------------------------------------------------------------
int 
vsDisplayMessage(
    IN const HWND    hdlg,
    IN const UINT    uButtons,
    IN const UINT    uTitleID,
    IN const UINT    uErrorID,
    IN const DWORD   dwErrorCode,
    IN const va_list argList
    )
{
    UNREFERENCED_PARAMETER(hdlg);
        
    if (REMOVE == g_SubcomponentMsmq[eMSMQCore].dwOperation && 
        !g_fMSMQAlreadyInstalled)
    {
        //
        // Special case. Successful installation of MSMQ is NOT registered in 
        // the registry, but nevertheless MSMQ is being "removed". All operations
        // are performed as usual, except for error messages - no point to 
        // show them. So in this case, don't message box (ShaiK, 8-Jan-98),
        //
        return IDOK;
    }
    else    
    {
        CResString strTitle(uTitleID);
        CResString strFormat(uErrorID);
        LPTSTR szTmp = NULL;
        DWORD dw = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING,
            strFormat.Get(),
            0,
            0,
            (LPTSTR)&szTmp,
            0,
            (va_list *)&argList
            );
        ASSERT(("FormatMessage failed", dw));
        UNREFERENCED_PARAMETER(dw);

        //
        // Append the error code and description
        //

		std::wstringstream OutSream;
		OutSream << szTmp;
        LocalFree(szTmp);

        if (dwErrorCode)
        {
            OutSream << GetErrorDescription(dwErrorCode);
        }

        //
        // Display the error message (or log it in unattended setup)
        //
        if (g_fBatchInstall)
        {
        	DebugLogMsg(eUI, OutSream.str().c_str());
        	DebugLogMsg(eUser, L"Unattended setup selected OK.");
            return IDOK; // Must be != IDRETRY here .
        }
        
       	DebugLogMsg(eUI, OutSream.str().c_str());
        int selection = MessageBox(/*hdlg*/g_hPropSheet, OutSream.str().c_str(), strTitle.Get(), uButtons) ;
        LogUserSelection(selection);        
        return selection;
    }

} //vsDisplayMessage


//+--------------------------------------------------------------
//
// Function: MqDisplayError
//
// Synopsis: Displays error message
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayError(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode);

    return vsDisplayMessage(
        hdlg,
        (MB_OK | MB_TASKMODAL | MB_ICONHAND),
        g_uTitleID,
        uErrorID,
        dwErrorCode,
        argList
        );
} //MqDisplayError


//+--------------------------------------------------------------
//
// Function: MqDisplayErrorWithRetry
//
// Synopsis: Displays error message with Retry option
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayErrorWithRetry(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode );

    return vsDisplayMessage(
				        NULL,
				        MB_RETRYCANCEL | MB_TASKMODAL | MB_ICONHAND,
				        g_uTitleID,
				        uErrorID,
				        dwErrorCode,
				        argList
						);
} //MqDisplayErrorWithRetry

//+--------------------------------------------------------------
//
// Function: MqDisplayErrorWithRetryIgnore
//
// Synopsis: Displays error message with Retry and Ignore option
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayErrorWithRetryIgnore(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode );

    return vsDisplayMessage(
        NULL,
        MB_ABORTRETRYIGNORE | MB_TASKMODAL | MB_ICONHAND,
        g_uTitleID,
        uErrorID,
        dwErrorCode,
        argList
		);        

} //MqDisplayErrorWithRetryIgnore


//+--------------------------------------------------------------
//
// Function: MqAskContinue
//
// Synopsis: Asks user if she wants to continue
//
//+--------------------------------------------------------------
BOOL 
_cdecl 
MqAskContinue(
    IN const UINT uProblemID, 
    IN const UINT uTitleID, 
    IN const BOOL bDefaultContinue, 
	IN const MsgBoxStyle eMsgBoxStyle,
    ...)
{
    //
    // Form the problem message using the variable arguments
    //

    CResString strFormat(uProblemID);
    CResString strTitle(uTitleID);        
    CResString strContinue(IDS_CONTINUE_QUESTION);

    va_list argList;
    va_start(argList, bDefaultContinue);

    LPTSTR szTmp;
    DWORD dw = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_STRING,
        strFormat.Get(),
        0,
        0,
        (LPTSTR)&szTmp,
        0,
        (va_list *)&argList
        );
    UNREFERENCED_PARAMETER(dw);
    ASSERT(("FormatMessage failed", dw));
  
	std::wstringstream OutSream;
	OutSream << szTmp << L"\r\n\r\n" << strContinue.Get();
    LocalFree(szTmp);

    //
    // In unattended mode, log the problem and the default behaviour of Setup
    //
    if (g_fBatchInstall)
    {
        CResString strDefaultMsg(IDS_DEFAULT_MSG);
        CResString strDefault(IDS_DEFAULT_YES_MSG);
        if (!bDefaultContinue)
		{
            strDefault.Load(IDS_DEFAULT_NO_MSG);
		}
		OutSream << L"\r\n" << strDefaultMsg.Get() << strDefault.Get();  
        DebugLogMsg(eUI, OutSream.str().c_str());
        DebugLogMsg(eUser,L"Unattended setup selected to continue.");
        return bDefaultContinue;
    }
    else
    {
		UINT uMsgBoxStyle = MB_YESNO | MB_DEFBUTTON1 | MB_ICONEXCLAMATION;
		INT iExpectedResultForContinue = IDYES;
		if( eMsgBoxStyle == eOkCancelMsgBox )
		{
			//
			// Display OK/Cancle 
			// 
			uMsgBoxStyle = MB_OKCANCEL|MB_DEFBUTTON1;
			iExpectedResultForContinue = IDOK;
		}
		DebugLogMsg(eUI, OutSream.str().c_str());
        int selection = MessageBox(
				g_hPropSheet ? g_hPropSheet: GetActiveWindow(), 
				OutSream.str().c_str(), 
				strTitle.Get(),
	            uMsgBoxStyle 
				);
        LogUserSelection(selection);        
        return(selection == iExpectedResultForContinue);        	
    }
} //MqAskContinue

//+--------------------------------------------------------------
//
// Function: MqDisplayWarning
//
// Synopsis: Displays warning
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayWarning(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode);

    return vsDisplayMessage(
        hdlg,
        (MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION),
        IDS_WARNING_TITLE, //Message Queuing Setup Warning
        uErrorID,
        dwErrorCode,
        argList
		);

} //MqDisplayWarning


static 
bool
ToLogOrNotToLog()
//
// Returns true iff WITHOUT_TRACING_REGKEY regkey exists.
//
{
    static bool s_fIsInitialized = FALSE;
    static bool s_fWithTracing = TRUE;
    if (!s_fIsInitialized)
    {
        s_fIsInitialized = TRUE;
        //
        // check if we need to hide setup tracing
        //
        DWORD dwState = 0;
        if (MqReadRegistryValue(
                    WITHOUT_TRACING_REGKEY,                
                    sizeof(DWORD),
                    (PVOID) &dwState,
                    /* bSetupRegSection = */TRUE
                    ))
        {
            //
            // registry key is found, it means that we have to hide setup tracing
            //
            s_fWithTracing = FALSE;
        }    
    }
	return s_fWithTracing; 
}


void
DebugLogMsg(
	TraceLevel tl,
    LPCWSTR psz,
	...
    )
/*++
Routine Description:
	This is the main logging function for setup. 
	It works like printf, and outputs to msmqinst.log (in %windir%)

--*/

{
    if (!ToLogOrNotToLog())
	{
		return;
	}

 
	va_list marker;
	va_start(marker, psz);
	WCHAR szMessageBuffer[MAX_STRING_CHARS];
	HRESULT hr = StringCchVPrintf(szMessageBuffer, MAX_STRING_CHARS, psz, marker);
	if(FAILED(hr))
	{
		//
		// An error has ocured, no way to give error messages.
		//
		return;
	}
	std::wstringstream OutStream;
	switch(tl)
	{
		case eInfo:
			OutStream<< L"Info      "<< szMessageBuffer;
			break;

		case eAction:
			OutStream<< L"Action    "<< szMessageBuffer<<L"...";
			break;
			
		case eWarning:
			OutStream<< L"Warning   "<< szMessageBuffer;
			break;

		case eError:
			OutStream<< L"Error     "<< szMessageBuffer;
			break;

		case eUI:
			OutStream<< L"UI        "<< szMessageBuffer;
			break;

		case eUser:
			OutStream<<L"User      "<< szMessageBuffer;
			break;

		case eHeader:
			{
				std::wstringstream text;
				text<< L"*"<< szMessageBuffer<< L"  ("<< FormatTime()<< L")";
				std::wstring underline(text.str().length(), L'-');
				OutStream<< L"\r\n"<< text.str()<< L"\r\n"<< underline; 
				break;
			}
		default:
			ASSERT(0);
	}			
    LogMessage(OutStream.str()); 
}

//+-------------------------------------------------------------------------
//
//  Function:   LogMsgHR
//
//  Synopsis:   Allows LogHR use in linked libraries (like ad.lib)
//
//--------------------------------------------------------------------------
void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	std::wstringstream OutSream;
	OutSream << L"This Error is from the"<< wszFileName<< L"Library. Point: "<< usPoint<< L"HR: 0x"<< std::hex << hr; 
	DebugLogMsg(eError, OutSream.str().c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\iisexten.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisexten.cpp

Abstract:

    Code to handle iis extension.

Author:

    Tatiana Shubin  (TatianaS)  25-May-00

--*/

#include "msmqocm.h"
#include "initguid.h"
#include <coguid.h>
#include <iadmw.h>
#include <iiscnfg.h>

#pragma warning(disable: 4268)
// error C4268: 'IID_IWamAdmin' : 'const' static/global data initialized 
// with compiler generated default constructor fills the object with zeros
 
#include <iwamreg.h>

#include "iisexten.tmh"

//
// Forwarding function
//
static void PermitISExtention();

//
// pointers to IIS interfaces
//
IMSAdminBase    *g_pIMSAdminBase;
IWamAdmin       *g_pIWamAdmin;

class CIISPtr 
{
public:
    CIISPtr ()
    {
        g_pIMSAdminBase = NULL;
        g_pIWamAdmin = NULL;
        if (SUCCEEDED(CoInitialize(NULL)))
        {
            m_fNeedUninit = TRUE;
        }
        else
        {
            m_fNeedUninit = FALSE;
        }

    }
    ~CIISPtr()
    {
        if (g_pIMSAdminBase) g_pIMSAdminBase->Release();
        if (g_pIWamAdmin) g_pIWamAdmin->Release();
        if (m_fNeedUninit) CoUninitialize();       
    }    
private:
    BOOL m_fNeedUninit;
};

//
// auto class for meta data handle
//
class CAutoCloseMetaHandle
{
public:    
    CAutoCloseMetaHandle(METADATA_HANDLE h =NULL)
    {
        m_h = h;
    };
    
    ~CAutoCloseMetaHandle() 
    { 
        if (m_h) g_pIMSAdminBase->CloseKey(m_h); 
    };

public:    
    METADATA_HANDLE * operator &() { return &m_h; };
    operator METADATA_HANDLE() { return m_h; };

private:
    METADATA_HANDLE m_h;    
};

//
// Full path in IIS metabase to msmq key.
// /LM/W3Svc/1/Root/MSMQ
// 
LPCWSTR g_wcsFullPath = PARENT_PATH MSMQ_IISEXT_NAME;

std::wstring g_MSMQAppMap;

std::wstring g_MsmqWebDir;

static const DWORD g_dwIsolatedFlag = 0; //it was 2; 0 for in-process, 2 for pooled process

static void InitIWamAdmin()
/*++
Routine Description:
	Init IWamAdmin pointer.

Arguments:
	None

Returned Value:
	HRESULT

--*/
{
    //
    // get a pointer to the IWamAdmin Object
    //
	HRESULT hr = CoCreateInstance(
					CLSID_WamAdmin, 
					NULL, 
					CLSCTX_ALL, 
					IID_IWamAdmin, 
					(void **) &g_pIWamAdmin
					);  

    if(FAILED(hr))
    {
        DebugLogMsg(eError, L"CoCreateInstance for IID_IWamAdmin failed. hr = 0x%x.", hr);        
		throw bad_hresult(hr);
    }
}


static void InitIMSAdminBase()
/*++
Routine Description:
	Init IMSAdminBase pointer.

Arguments:
	None

Returned Value:
	HRESULT

--*/
{
    //
    // get a pointer to the IMSAdmin Object
    //    
    HRESULT hr = CoCreateInstance(
					CLSID_MSAdminBase,
					NULL,
					CLSCTX_ALL,
					IID_IMSAdminBase,
					(void**) &g_pIMSAdminBase
					);

    if (FAILED(hr))
    {
        DebugLogMsg(eError, L"CoCreateInstance for IID_IMSAdminBase failed. hr = 0x%x.", hr);
		throw bad_hresult(hr);
    }
}


//+--------------------------------------------------------------
//
// Function: Init
//
// Synopsis: Init COM and pointer to Interfaces
//
//+--------------------------------------------------------------

static void Init()
{
    //
    // get a pointer to the IWamAdmin Object
    //
	InitIWamAdmin();
    
    //
    // get a pointer to the IMSAdmin Object
    //    
    InitIMSAdminBase();

    //
    // init globals here
    //
    DebugLogMsg(eInfo, L"The full path to the Message Queuing IIS extension is %s.", g_wcsFullPath);
    
    //
    // construct MSMQ mapping
    //
    WCHAR wszMapFlag[10];
    _itow(MD_SCRIPTMAPFLAG_SCRIPT, wszMapFlag, 10);
    
	g_MSMQAppMap = g_MSMQAppMap + L"*," + g_szSystemDir + L"\\" + MQISE_DLL + L"," + wszMapFlag + L"," + L"POST";
}

//+--------------------------------------------------------------
//
// Function: IsExtensionExist
//
// Synopsis: Return TRUE if MSMQ IIS Extension already exist
//
//+--------------------------------------------------------------

static BOOL IsExtensionExist()
{
    CAutoCloseMetaHandle metaHandle;
    HRESULT hr = g_pIMSAdminBase->OpenKey(
									METADATA_MASTER_ROOT_HANDLE,
									g_wcsFullPath,
									METADATA_PERMISSION_READ,
									5000,
									&metaHandle
									);    

    if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {        
        DebugLogMsg(eInfo, L"The Message Queuing IIS extension does not exist.");
        return FALSE;
    }
        
    DebugLogMsg(eInfo, L"The Message Queuing IIS extension exists.");
    return TRUE;
}


static 
void 
OpenRootKey(
	METADATA_HANDLE *pmetaHandle,
	DWORD dwMDAccessRequested
	)
/*++
Routine Description:
	Open Root Key for the required access

Arguments:
	metaHandle - handle to metadata

Returned Value:
	HRESULT

--*/
{
    HRESULT hr = g_pIMSAdminBase->OpenKey(
						METADATA_MASTER_ROOT_HANDLE,
						ROOT,
						dwMDAccessRequested,
						5000,                            
						pmetaHandle
						);

    if (FAILED(hr))
    {               
        DebugLogMsg(eError, L"IMSAdminBase::OpenKey failed. AccessRequested = %d, hr = 0x%x", dwMDAccessRequested, hr); 
		throw bad_hresult(hr);
    }
}


static 
void 
OpenRootKeyForRead(
	METADATA_HANDLE* pmetaHandle
	)
/*++
Routine Description:
	Open Root Key for read.

Arguments:
	metaHandle - handle to metadata

Returned Value:
	HRESULT

--*/
{
	OpenRootKey(
		pmetaHandle,
		METADATA_PERMISSION_READ
		);
}


static 
void 
OpenRootKey(
	METADATA_HANDLE* pmetaHandle
	)
/*++
Routine Description:
	Open Root Key for read/write.

Arguments:
	metaHandle - handle to metadata

Returned Value:
	HRESULT

--*/
{
	OpenRootKey(
		pmetaHandle,
		METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ
		);
}


static
std::wstring 
GetDefaultWebSitePhysicalPath()
/*++
Routine Description:
	Get Extension Physical Path (MD_VR_PATH) property.

Arguments:
	metaHandle - handle to metadata.
	pPhysicalPath - AP<WHAR> for the Physical Path string

Returned Value:
	HRESULT

--*/
{
    CAutoCloseMetaHandle metaHandle;
    OpenRootKeyForRead(&metaHandle);
	//
	// Get physical path 
	//

    METADATA_RECORD MDRecord;

    MDRecord.dwMDIdentifier = MD_VR_PATH;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = 0;
    MDRecord.pbMDData = NULL;
    DWORD dwSize = 0;

    HRESULT hr = g_pIMSAdminBase->GetData(
								metaHandle,
								PARENT_PATH,                      
								&MDRecord,
								&dwSize
								);

	std::wstring strPhysicalPath = L"";
	if(dwSize > 0)
	{
		AP<WCHAR> pPhysicalPath = new WCHAR[dwSize];    
        MDRecord.dwMDDataLen = sizeof(WCHAR) * dwSize;
        MDRecord.pbMDData = (UCHAR *)pPhysicalPath.get();
		hr = g_pIMSAdminBase->GetData(
								metaHandle,
								PARENT_PATH,                      
								&MDRecord,
								&dwSize
								);

		strPhysicalPath = pPhysicalPath; 

	}
    if (FAILED(hr))
    {        
		DebugLogMsg(eError, L"IMSAdminBase::GetData() failed. hr = 0x%x", hr);
        DebugLogMsg(eError, L"The physical path of the virtual directory " PARENT_PATH L" could not obtained.");               
		throw bad_hresult(hr);
    }    

    DebugLogMsg(eInfo, L"The physical path for the virtual directory " PARENT_PATH L" is '%ls'.", strPhysicalPath.c_str());               
	return strPhysicalPath;
}


static
std::wstring 
GetAnonymousUserName()
/*++
Routine Description:
	Get Anonymous user name (MD_ANONYMOUS_USER_NAME) property.

Returned Value:
	A stirng with the user name.

--*/
{
    CAutoCloseMetaHandle metaHandle;
    OpenRootKeyForRead(&metaHandle);
	//
	// Default web ANONYMOUS_USER_NAME 
	//

    METADATA_RECORD MDRecord;

    MDRecord.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = 0;
    MDRecord.pbMDData = NULL;
    DWORD dwSize = 0;
    
    HRESULT hr = g_pIMSAdminBase->GetData(
								metaHandle,
								PARENT_PATH,                      
								&MDRecord,
								&dwSize
								);

	std::wstring strAnonymousUserName = L"";
	if(dwSize > 0)
	{
        AP<WCHAR> pAnonymousUserName = new WCHAR[dwSize];    

        MDRecord.dwMDDataLen = sizeof(WCHAR) * dwSize;
        MDRecord.pbMDData = (UCHAR *)pAnonymousUserName.get();
		hr = g_pIMSAdminBase->GetData(
								metaHandle,
								PARENT_PATH,                      
								&MDRecord,
								&dwSize
								);

		strAnonymousUserName = pAnonymousUserName.get();
	}

    if (FAILED(hr))
    {        
		DebugLogMsg(eError, L"IMSAdminBase::GetData() failed to get IIS ANONYMOUS_USER_NAME. hr = 0x%x", hr);               
        throw bad_hresult(hr);
    }    

	DebugLogMsg(eInfo, L"IIS ANONYMOUS_USER_NAME is %ls.", strAnonymousUserName.c_str());               
    return  strAnonymousUserName;
}


//+--------------------------------------------------------------
//
// Function: CommitChanges
//
// Synopsis: Commit Changes
//
//+--------------------------------------------------------------
static void CommitChanges()
{
    //
    // Commit the changes
    //    
    HRESULT hr = g_pIMSAdminBase->SaveData();
    if (FAILED(hr))
    {        
        if (hr != HRESULT_FROM_WIN32(ERROR_PATH_BUSY))
        {
			DebugLogMsg(eError, L"IMSAdminBase::SaveData() failed while committing changes. hr = 0x%x", hr);
			throw bad_hresult(hr);
		}
    }  

    DebugLogMsg(eInfo, L"The changes for the IIS extension have been committed.");
}


//+--------------------------------------------------------------
//
// Function: StartDefWebServer
//
// Synopsis: Start default web server if not yet started
//
//+--------------------------------------------------------------
static void StartDefaultWebServer()
{
	DebugLogMsg(eAction, L"Starting the default web server");
    CAutoCloseMetaHandle metaHandle;
	OpenRootKey(&metaHandle);
    
	METADATA_RECORD MDRecord;

    //
    // check server status
    //
    DWORD dwValue;
    MDRecord.dwMDIdentifier = MD_SERVER_STATE;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_SERVER;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;
    DWORD dwSize;
    HRESULT hr = g_pIMSAdminBase->GetData(
                            metaHandle,
                            DEFAULT_WEB_SERVER_PATH,                      
                            &MDRecord,
                            &dwSize
                            );

    if (SUCCEEDED(hr))
    {
        if ((DWORD)(*MDRecord.pbMDData) == MD_SERVER_STATE_STARTED)
        {
            //
            // server started, do nothing
            //
           	DebugLogMsg(eInfo, L"The default Web server is already started.");
            return;
        }
    }
    
    //
    // We are here iff GetData failed or server is not started.
    // Try to start it.
    //

    //
    // send start command
    //
    dwValue = MD_SERVER_COMMAND_START;
    MDRecord.dwMDIdentifier = MD_SERVER_COMMAND;  
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(
							metaHandle,
							DEFAULT_WEB_SERVER_PATH,
							&MDRecord
							);
	if(FAILED(hr))
	{
        DebugLogMsg(eError, L"IMSAdminBase::SetData() failed (hr = 0x%x). The default Web server did not start.", hr);
		throw bad_hresult(hr);
	}
    
    //
    // Commit the changes
    //
    CommitChanges();

	DebugLogMsg(eInfo, L"The default Web server started.");
}


//+--------------------------------------------------------------
//
// Function: CreateApplication
//
// Synopsis: Create Application for MSMQ IIS Extension.
//			 This will create a new key for msmq in IIS Metabase.
//
//+--------------------------------------------------------------
static void CreateApplication()
{
	DebugLogMsg(eAction, L"Creating a web application for the Message Queuing IIS extension");
	
    //
    // create application
    //
    HRESULT hr  = g_pIWamAdmin->AppCreate( 
									g_wcsFullPath,
									FALSE       //in process
									);
    if (FAILED(hr))
    {       
        MqDisplayError(NULL, IDS_EXTEN_APPCREATE_ERROR, hr, g_wcsFullPath);
       
        DebugLogMsg(
        	eError,
			L"The application for the IIS extension with the path %s could not be created. hr = 0x%x",
			g_wcsFullPath, 
			hr
			);
		throw bad_hresult(hr); 
    }
}

//+--------------------------------------------------------------
//
// Function: UnloadApplication
//
// Synopsis: Unload Application for MSMQ IIS Extension
//
//+--------------------------------------------------------------
static void UnloadApplication()
{
    //
    // unload application
    //    
    HRESULT hr = g_pIWamAdmin->AppUnLoad( 
                            g_wcsFullPath,
                            TRUE       //recursive
                            );    
	if(FAILED(hr))
	{
		DebugLogMsg(eError, L"IWamAdmin::AppUnLoad() for %s failed. hr = 0x%x", g_wcsFullPath, hr);
		throw bad_hresult(hr);
	}
}


//+--------------------------------------------------------------
//
// Function: GetApplicationMapping
//
// Synopsis: Get existing application mapping
//
//+--------------------------------------------------------------
static 
CMultiString
GetApplicationMapping()
{
	DebugLogMsg(eAction, L"Getting the application mapping");
    CAutoCloseMetaHandle metaHandle;
    OpenRootKey(&metaHandle);
    
    //
    // get default application mapping
    //
    METADATA_RECORD mdDef;

    mdDef.dwMDIdentifier = MD_SCRIPT_MAPS;
    mdDef.dwMDAttributes = METADATA_INHERIT;
    mdDef.dwMDUserType = IIS_MD_UT_FILE;
    mdDef.dwMDDataType = MULTISZ_METADATA;
    mdDef.dwMDDataTag = 0;
    mdDef.dwMDDataLen = 0;
    mdDef.pbMDData = NULL;
    DWORD size = 0;

    //
	// Call first to get the size.
	//
	HRESULT hr = g_pIMSAdminBase->GetData(
                            metaHandle,
                            g_wcsFullPath,                      
                            &mdDef,
                            &size
                            );
	if(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		DebugLogMsg(
			eError, 
			L"The default application mapping for the IIS extension could not be obtained. IMSAdminBase::GetData for %s failed. hr = 0x%x", 
			g_wcsFullPath, 
			hr
			);
		throw bad_hresult(hr);
	}

	mdDef.dwMDDataLen = size; 
	AP<BYTE> buff = new BYTE[size];
	mdDef.pbMDData = buff;
	DWORD s;
    hr = g_pIMSAdminBase->GetData(
                            metaHandle,
                            g_wcsFullPath,                      
                            &mdDef,
                            &s
                            );        
    if (FAILED(hr))
    {        
        DebugLogMsg(
        	eError, 
        	L"The default application mapping for the IIS extension could not be obtained. IMSAdminBase::GetData for %s failed. hr = 0x%x", 
        	g_wcsFullPath, 
			hr
			);

        throw bad_hresult(hr);
    }    
    DebugLogMsg(eInfo, L"The default application mapping for the IIS extension was obtained.");

	CMultiString multi((LPCWSTR)(buff.get()), size / sizeof(WCHAR));
	return multi;
}

//+--------------------------------------------------------------
//
// Function: AddMSMQToMapping
//
// Synopsis: Add MSMQ to application mapping
//
//+--------------------------------------------------------------   
static 
void 
AddMSMQToMapping(
	CMultiString& multi
	)
{
	DebugLogMsg(eAction, L"Adding MSMQ to the application mapping");
    CAutoCloseMetaHandle metaHandle;
    OpenRootKey(&metaHandle);
	multi.Add(g_MSMQAppMap);
    
    METADATA_RECORD MDRecord;    
    MDRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE ;
    MDRecord.dwMDDataType = MULTISZ_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD>(multi.Size() * sizeof(WCHAR));
    MDRecord.pbMDData = (BYTE*)(multi.Data());  

    HRESULT hr = g_pIMSAdminBase->SetData(
							metaHandle,
							g_wcsFullPath,
							&MDRecord
							);   
    
    if(FAILED(hr))
    {        
        DebugLogMsg(
        	eError,  
        	L"The application mapping for the IIS extension could not be set. IMSAdminBase::SetData for %s failed. hr = 0x%x", 
        	g_wcsFullPath, 
        	hr
        	);
        throw bad_hresult(hr);
    }           
    DebugLogMsg(eInfo, L"The application mapping for the IIS extension was set.");
}


//+--------------------------------------------------------------
//
// Function: SetApplicationProperties
//
// Synopsis: Set application properties
//
//+--------------------------------------------------------------
static void SetApplicationProperties()
{
	DebugLogMsg(eAction, L"Setting properties for the Message Queuing web application");
    CAutoCloseMetaHandle metaHandle;
    OpenRootKey(&metaHandle);
    
    METADATA_RECORD MDRecord;

    //
    // friendly application name
    //       
    MDRecord.dwMDIdentifier = MD_APP_FRIENDLY_NAME;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_WAM;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD>(sizeof(WCHAR) * (wcslen(MSMQ_IISEXT_NAME) + 1));
    MDRecord.pbMDData = (UCHAR *)MSMQ_IISEXT_NAME;

    HRESULT hr = g_pIMSAdminBase->SetData(
							metaHandle,
							g_wcsFullPath,
							&MDRecord
							);    
    if (FAILED(hr))
    {        
        DebugLogMsg(eError,	L"The application's friendly name could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }  
    DebugLogMsg(eInfo, L"The application's friendly name was set.");

    //
    // isolated