y information
        {
            FormatRasError(hr, szErr, DimensionOf(szErr));
        }
        AddLowLevelErrorString(szErr);
        
        // If there is no high level error string, add a
        // generic error string.  This will be used if no other
        // high level error string is set.
        SetDefaultHighLevelErrorStringId(IDS_ERR_GENERIC_ERROR);
        
        DisplayTFSErrorMessage(NULL);
    }
    return hr;
}

#ifdef KSL_IPINIP
/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnNewTunnel
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::OnNewTunnel()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT        hr = hrOK;
    SPIConsole    spConsole;
    SPIInterfaceInfo    spIfInfo;
    int            idsErr = 0;
    RouterVersionInfo    routerVersion;
    TunnelDialog    tunnel;
    GUID        guidNew;
    TCHAR       szGuid[128];

    if (!EnableAddInterface())
    {
        idsErr = IDS_ERR_TEMPNOADD;
        CORg( E_FAIL );
    }

    // Get the version info.  Needed later on.
    // ----------------------------------------------------------------
    m_spRouterInfo->GetRouterVersionInfo(&routerVersion);


    m_spTFSCompData->GetConsole(&spConsole);

    
    // For now, popup a dialog asking for the tunnel information
    // ----------------------------------------------------------------
    if (tunnel.DoModal() == IDOK)
    {
        // We need to create a GUID for this tunnel.
        // ------------------------------------------------------------
        CORg( CoCreateGuid(&guidNew) );

        // Convert the GUID into a string
        // ------------------------------------------------------------
        Verify( StringFromGUID2(guidNew, szGuid, DimensionOf(szGuid)) );

        
        CORg( CreateInterfaceInfo(&spIfInfo,
                                  szGuid,
                                  ROUTER_IF_TYPE_TUNNEL1) );
        
        CORg( spIfInfo->SetTitle(tunnel.m_stName) );
        CORg( spIfInfo->SetMachineName(m_spRouterInfo->GetMachineName()) );
        
        CORg( m_spRouterInfo->AddInterface(spIfInfo) );

        // Need to add the IP Specific data
        
        ForceGlobalRefresh(m_spRouterInfo);
    }
    

Error:
    if (!FHrSucceeded(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
    {
        TCHAR    szErr[2048];
        
        if (idsErr)
            AddHighLevelErrorStringId(idsErr);

        FormatRasError(hr, szErr, DimensionOf(szErr));
        AddLowLevelErrorString(szErr);
        
        DisplayTFSErrorMessage(NULL);
    }
    return hr;
}

#endif //KSL_IPINIP

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::AddRouterManagerToInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::AddRouterManagerToInterface(IInterfaceInfo *pIf,
    IRouterInfo *pRouter,
    DWORD dwTransportId)
{
    HRESULT        hr = hrOK;
    SPIRtrMgrInfo    spRm;
    SPIRtrMgrInterfaceInfo    spRmIf;
    SPIInfoBase        spInfoBase;
    
    // Get the router manager
    hr = pRouter->FindRtrMgr(dwTransportId, &spRm);

    // If this cannot find the RtrMgr, then just exit out.
    if (!FHrOK(hr))
        goto Error;
        
    // Construct a new CRmInterfaceInfo object
    CORg( CreateRtrMgrInterfaceInfo(&spRmIf,
                                    spRm->GetId(),
                                    spRm->GetTransportId(),
                                    pIf->GetId(),
                                    pIf->GetInterfaceType()) );

    CORg( spRmIf->SetTitle(pIf->GetTitle()) );
    CORg( spRmIf->SetMachineName(pRouter->GetMachineName()) );
        
    // Add this interface to the router-manager
    CORg( pIf->AddRtrMgrInterface(spRmIf, NULL) );

    // get/create the infobase for this interface
    CORg( spRmIf->Load(pIf->GetMachineName(), NULL, NULL, NULL) );    
    CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );
    
    if (!spInfoBase)
        CORg( CreateInfoBase(&spInfoBase) );

    if (dwTransportId == PID_IP)
        CORg( AddIpPerInterfaceBlocks(pIf, spInfoBase) );
    else
    {
        Assert(dwTransportId == PID_IPX);
        CORg( AddIpxPerInterfaceBlocks(pIf, spInfoBase) );
    }

    // Save the infobase
    CORg( spRmIf->Save(pIf->GetMachineName(),
                       NULL, NULL, NULL, spInfoBase, 0) );

    // Mark this interface (it can now be synced with the router)
    spRmIf->SetFlags( spRmIf->GetFlags() | RouterSnapin_InSyncWithRouter );

    // Notify RM of a new interface
    spRm->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);

Error:
    if (!FHrSucceeded(hr))
    {
        // Cleanup
        pIf->DeleteRtrMgrInterface(dwTransportId, TRUE);
    }
    
    return hr;
}


/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnUseDemandDialWizard
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::OnUseDemandDialWizard()
{
    HRESULT    hr = hrOK;
    DWORD    dwWiz;
    
    hr = GetDemandDialWizardRegKey(OLE2CT(m_spRouterInfo->GetMachineName()),
                                                &dwWiz);

    if (FHrSucceeded(hr))
    {
        // Ok, now toggle the switch
        SetDemandDialWizardRegKey(OLE2CT(m_spRouterInfo->GetMachineName()),
                                       !dwWiz);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::SynchronizeNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
    Assert(pThisNode);
    
    SPITFSNodeEnum    spEnum;
    SPITFSNode        spNode;
    DWORD            dwStatus;
    DWORD            dwConnState;
    DWORD            dwUnReachabilityReason;
    int                i;
    
    HRESULT    hr = hrOK;
    InterfaceNodeData    *pData;
    SPMprAdminBuffer    spIf0Table;
    SPMprServerHandle    sphMprServer;
    MPR_INTERFACE_0 *    if0Table = NULL;
    DWORD                if0Count = 0;
    DWORD                dwTotal;
    DWORD                dwErr;

    // Get the status data from the running router
    dwErr = ConnectRouter(m_spRouterInfo->GetMachineName(), &sphMprServer);

    if (dwErr == NO_ERROR)
    {
        ::MprAdminInterfaceEnum(sphMprServer,
                                0,
                                (BYTE **) &spIf0Table,
                                (DWORD) -1,
                                &if0Count,
                                &dwTotal,
                                NULL);
        if0Table = (MPR_INTERFACE_0 *) (BYTE *) spIf0Table;
    }
    
    pThisNode->GetEnum(&spEnum);
    spEnum->Reset();
    
    while (spEnum->Next(1, &spNode, NULL) == hrOK)
    {
        pData = GET_INTERFACENODEDATA(spNode);
        Assert(pData);

        // default status/connection states
        dwConnState = ROUTER_IF_STATE_UNREACHABLE;
        dwUnReachabilityReason = MPR_INTERFACE_NOT_LOADED;
        pData->dwLastError = 0;

        // Match the status we find to the actual status
        for (i=0; i<(int) if0Count; i++)
        {
            // There could be a client interface with the same name
            // as a router interface, so filter the client interfaces
            if ((if0Table[i].dwIfType != ROUTER_IF_TYPE_CLIENT) &&
                !StriCmpW(pData->spIf->GetId(), if0Table[i].wszInterfaceName))
            {
                break;
            }
        }

        // If we found an entry in the table, pull the data out
        if (i < (int) if0Count)
        {
            dwConnState = if0Table[i].dwConnectionState;
            dwUnReachabilityReason = if0Table[i].fUnReachabilityReasons;

            if (dwUnReachabilityReason & MPR_INTERFACE_CONNECTION_FAILURE)
                pData->dwLastError = if0Table[i].dwLastError;
        }

        dwStatus = pData->spIf->IsInterfaceEnabled();

        // Place the data into the per-node data area
        pData->m_rgData[IFADMIN_SUBITEM_TITLE].m_stData = pData->spIf->GetTitle();
        pData->m_rgData[IFADMIN_SUBITEM_DEVICE_NAME].m_stData =
                    pData->spIf->GetDeviceName();
        pData->m_rgData[IFADMIN_SUBITEM_TYPE].m_stData =
                    InterfaceTypeToCString(pData->spIf->GetInterfaceType());
        pData->m_rgData[IFADMIN_SUBITEM_STATUS].m_stData = StatusToCString(dwStatus);
        pData->m_rgData[IFADMIN_SUBITEM_CONNECTION_STATE].m_stData =
                    ConnectionStateToCString(dwConnState);
        pData->dwUnReachabilityReason = dwUnReachabilityReason;
        pData->dwConnectionState = dwConnState;

        pData->fIsRunning = ::MprAdminIsServiceRunning((LPWSTR) pData->spIf->GetMachineName());

        // Force MMC to redraw the nodes
        spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

        // Cleanup
        spNode.Release();
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::EnableAddInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IfAdminNodeHandler::EnableAddInterface()
{
    return m_hInstRasDlg != 0;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::GetPhoneBookPath
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::GetPhoneBookPath(LPCTSTR pszMachine, CString *pstPath)
{
    CString str = _T(""), stPath;
    CString    stRouter = pszMachine;

    if (pszMachine && StrLen(pszMachine))
    {
        // add on the two slashes to the beginning of the machine name
        if (stRouter.Left(2) != _T("\\\\"))
        {
            stRouter = _T("\\\\");
            stRouter += pszMachine;
        }

        // If this is not the local machine, use this string
        if (stRouter.GetLength() &&
            StriCmp(stRouter, CString(_T("\\\\")) + GetLocalMachineName()))
            str = stRouter;
    }

    Verify( FHrSucceeded(::GetRouterPhonebookPath(str, &stPath)) );
    *pstPath = stPath;
    return hrOK;
}




ImplementEmbeddedUnknown(IfAdminNodeHandler, IRtrAdviseSink)

STDMETHODIMP IfAdminNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
    DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    InitPThis(IfAdminNodeHandler, IRtrAdviseSink);
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    SPITFSNode                spThisNode;
    SPITFSNode                spNode;
    SPITFSNodeEnum            spEnumNode;
    InterfaceNodeData *        pNodeData;
    BOOL                    fFound, fAdded;
    HRESULT    hr = hrOK;

    pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);
    
    if (dwObjectType == ROUTER_OBJ_If)
    {
        // Force a data refresh of the current result pane
        if (dwChangeType == ROUTER_CHILD_DELETE)
        {            
            // Go through the list of nodes, if we cannot find this
            // node in the list of interfaces, delete the node
            
            spThisNode->GetEnum(&spEnumNode);
            spEnumNode->Reset();
            while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
            {
                // Get the node data, look for the interface
                pNodeData = GET_INTERFACENODEDATA(spNode);
                pThis->m_spRouterInfo->FindInterface(pNodeData->spIf->GetId(),
                                              &spIf);
                if (spIf == NULL)
                {
                    // cannot find the interface, release this node!
                    spThisNode->RemoveChild(spNode);
                    spNode->Destroy();
                }
                spNode.Release();
                spIf.Release();
            }
        }
        else if (dwChangeType == ROUTER_CHILD_ADD)
        {
            // Enumerate through the list of interfaces
            // if we cannot find this interface in our current
            // set of nodes, then add it.
            spThisNode->GetEnum(&spEnumNode);
            
            CORg( pThis->m_spRouterInfo->EnumInterface(&spEnumIf) );

            fAdded = FALSE;
            spEnumIf->Reset();
            while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
            {
                // Look for this interface in our list of nodes
                fFound = FALSE;
                
                spEnumNode->Reset();
                while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
                {
                    pNodeData = GET_INTERFACENODEDATA(spNode);
                    Assert(pNodeData);
                    
                    if (StriCmpW(pNodeData->spIf->GetId(),spIf->GetId()) == 0)
                    {
                        fFound = TRUE;
                        break;
                    }
                    spNode.Release();
                }

                //
                // If the interface was not found in the list of nodes,
                // then we should add the interface to the UI.
                //
                if (!fFound)
                {
                    pThis->AddInterfaceNode(spThisNode, spIf);

                    fAdded = TRUE;
                }

                spNode.Release();
                spIf.Release();
            }

            // Now that we have all of the nodes, update the data for
            // all of the nodes
            if (fAdded)
                pThis->SynchronizeNodeData(spThisNode);

            // Windows NT Bug : 288247
            // Set this here, so that we can avoid the nodes being
            // added in the OnExpand().
            pThis->m_bExpanded = TRUE;
        }

        // Determine what nodes were deleted, changed, or added
        // and do the appropriate action
    }
    else if (dwChangeType == ROUTER_REFRESH)
    {
        // Ok, just call the synchronize on this node
        pThis->SynchronizeNodeData(spThisNode);
    }
Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::CompareItems
        Implementation of ITFSResultHandler::CompareItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IfAdminNodeHandler::CompareItems(
                                ITFSComponent * pComponent,
                                MMC_COOKIE cookieA,
                                MMC_COOKIE cookieB,
                                int nCol)
{
    // Get the strings from the nodes and use that as a basis for
    // comparison.
    SPITFSNode    spNode;
    SPITFSResultHandler    spResult;

    m_spNodeMgr->FindNode(cookieA, &spNode);
    spNode->GetResultHandler(&spResult);
    return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::AddMenuItems
        Implementation of ITFSResultHandler::AddMenuItems
        Use this to add commands to the context menu of the blank areas
        of the result pane.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::AddMenuItems(ITFSComponent *pComponent,
                                              MMC_COOKIE cookie,
                                              LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pCallback,
                                              long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    SPITFSNode    spNode;
    CString        stMenu;
    LONG        lMenuText;
    HRESULT        hr = hrOK;

    m_spNodeMgr->FindNode(cookie, &spNode);
    hr = OnAddMenuItems(spNode,
                        pCallback,
                        pDataObject,
                        CCT_RESULT,
                        TFS_COMPDATA_CHILD_CONTEXTMENU,
                        pInsertionAllowed);
    CORg( hr );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::Command(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           int nCommandID,
                                           LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    SPITFSNode    spNode;
    HRESULT        hr = hrOK;

    m_spNodeMgr->FindNode(cookie, &spNode);
    hr = OnCommand(spNode,
                   nCommandID,
                   CCT_RESULT,
                   pDataObject,
                   TFS_COMPDATA_CHILD_CONTEXTMENU);
    return hr;
}





typedef DWORD (APIENTRY* PRASRPCCONNECTSERVER)(LPTSTR, HANDLE *);
typedef DWORD (APIENTRY* PRASRPCDISCONNECTSERVER)(HANDLE);
typedef DWORD (APIENTRY* PRASRPCREMOTEGETUSERPREFERENCES)(HANDLE, PBUSER *, DWORD);
typedef DWORD (APIENTRY* PRASRPCREMOTESETUSERPREFERENCES)(HANDLE, PBUSER *, DWORD);

/*!--------------------------------------------------------------------------
    GetDemandDialWizardRegKey
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetDemandDialWizardRegKey(LPCTSTR szMachine, DWORD *pfWizard)
{
    ASSERT(pfWizard);
    BOOL    fUnload = FALSE;
    DWORD    dwErr;
    PBUSER    pbUser;
    PRASRPCCONNECTSERVER pRasRpcConnectServer;
    PRASRPCDISCONNECTSERVER pRasRpcDisconnectServer;
    PRASRPCREMOTEGETUSERPREFERENCES pRasRpcRemoteGetUserPreferences;
    PRASRPCREMOTESETUSERPREFERENCES pRasRpcRemoteSetUserPreferences;
    HINSTANCE hrpcdll = NULL;
    HANDLE hConnection = NULL;

    if (!(hrpcdll = LoadLibrary(TEXT("rasman.dll"))) ||
        !(pRasRpcConnectServer =
                          (PRASRPCCONNECTSERVER)GetProcAddress(
                                        hrpcdll, "RasRpcConnectServer"
                                        )) ||
        !(pRasRpcDisconnectServer =
                            (PRASRPCDISCONNECTSERVER)GetProcAddress(
                                        hrpcdll, "RasRpcDisconnectServer"
                                        )) ||
        !(pRasRpcRemoteGetUserPreferences =
                            (PRASRPCREMOTEGETUSERPREFERENCES)GetProcAddress(
                    hrpcdll, "RasRpcRemoteGetUserPreferences"
                    )) ||
        !(pRasRpcRemoteSetUserPreferences =
                            (PRASRPCREMOTESETUSERPREFERENCES)GetProcAddress(
                    hrpcdll, "RasRpcRemoteSetUserPreferences"
                    )))
        {

            if (hrpcdll) { FreeLibrary(hrpcdll); }
            return HRESULT_FROM_WIN32(GetLastError());
        }

    dwErr = pRasRpcConnectServer((LPTSTR) szMachine, &hConnection);
    if (dwErr)
        goto Error;
    fUnload = TRUE;

    dwErr = pRasRpcRemoteGetUserPreferences(hConnection, &pbUser, UPM_Router);
    if (dwErr)
        goto Error;

    *pfWizard = pbUser.fNewEntryWizard;

    // Ignore error codes for these calls, we can't do
    // anything about them if they fail.
    pRasRpcRemoteSetUserPreferences(hConnection, &pbUser, UPM_Router);
    DestroyUserPreferences((PBUSER *) &pbUser);
    
Error:
    if (fUnload)
        pRasRpcDisconnectServer(hConnection);

    if (hrpcdll)
        FreeLibrary(hrpcdll);

    return HRESULT_FROM_WIN32(dwErr);
}

/*!--------------------------------------------------------------------------
    SetDemandDialWizardRegistyKey
        This is a function that was added for Beta1 of Steelhead.  We want
        to allow the user to use the wizard even though it was turned off.

        So we have added this hack for the beta where we set the registry
        key for the user/
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetDemandDialWizardRegKey(LPCTSTR szMachine, DWORD fEnableWizard)
{
    DWORD    dwErr;
    PBUSER    pbUser;
    BOOL    fUnload = FALSE;
    PRASRPCCONNECTSERVER pRasRpcConnectServer;
    PRASRPCDISCONNECTSERVER pRasRpcDisconnectServer;
    PRASRPCREMOTEGETUSERPREFERENCES pRasRpcRemoteGetUserPreferences;
    PRASRPCREMOTESETUSERPREFERENCES pRasRpcRemoteSetUserPreferences;
    HINSTANCE hrpcdll = NULL;
    HANDLE hConnection = NULL;

    if (!(hrpcdll = LoadLibrary(TEXT("rasman.dll"))) ||
        !(pRasRpcConnectServer =
                          (PRASRPCCONNECTSERVER)GetProcAddress(
                                        hrpcdll, "RasRpcConnectServer"
                                        )) ||
        !(pRasRpcDisconnectServer =
                            (PRASRPCDISCONNECTSERVER)GetProcAddress(
                                        hrpcdll, "RasRpcDisconnectServer"
                                        )) ||
        !(pRasRpcRemoteGetUserPreferences =
                            (PRASRPCREMOTEGETUSERPREFERENCES)GetProcAddress(
                    hrpcdll, "RasRpcRemoteGetUserPreferences"
                    )) ||
        !(pRasRpcRemoteSetUserPreferences =
                            (PRASRPCREMOTESETUSERPREFERENCES)GetProcAddress(
                    hrpcdll, "RasRpcRemoteSetUserPreferences"
                    )))
        {

            if (hrpcdll) { FreeLibrary(hrpcdll); }
            return HRESULT_FROM_WIN32(GetLastError());
        }

    dwErr = pRasRpcConnectServer((LPTSTR) szMachine, &hConnection);
    if (dwErr)
        goto Error;
    fUnload = TRUE;
    
    dwErr = pRasRpcRemoteGetUserPreferences(hConnection, &pbUser, UPM_Router);
    if (dwErr)
        goto Error;

    pbUser.fNewEntryWizard = fEnableWizard;
    pbUser.fDirty = TRUE;

    // Ignore error codes for these calls, we can't do
    // anything about them if they fail.
    pRasRpcRemoteSetUserPreferences(hConnection, &pbUser, UPM_Router);
    DestroyUserPreferences((PBUSER *) &pbUser);
    
Error:    
    if (fUnload)
        pRasRpcDisconnectServer(hConnection);

    if (hrpcdll)
        FreeLibrary(hrpcdll);

    return HRESULT_FROM_WIN32(dwErr);
}



/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::AddInterfaceNode
        Adds an interface to the UI.  This will create a new result item
        node for each interface.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf)
    {
    InterfaceNodeHandler *    pHandler;
    SPITFSResultHandler        spHandler;
    SPITFSNode                spNode;
    HRESULT                    hr = hrOK;

    pHandler = new InterfaceNodeHandler(m_spTFSCompData);
    spHandler = pHandler;
    CORg( pHandler->Init(pIf, pParent) );
    
    CORg( CreateLeafTFSNode(&spNode,
                            NULL,
                            static_cast<ITFSNodeHandler *>(pHandler),
                            static_cast<ITFSResultHandler *>(pHandler),
                            m_spNodeMgr) );
    CORg( pHandler->ConstructNode(spNode, pIf) );
    
    // Make the node immediately visible
    CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
    CORg( pParent->AddChild(spNode) );
Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::FLookForRoutingEnabledPorts
        Returns TRUE if we find at least on routing-enabled port.
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IfAdminNodeHandler::FLookForRoutingEnabledPorts(LPCTSTR pszMachineName)
{
    PortsDataEntry        portsData;
    PortsDeviceList        portsList;
    PortsDeviceEntry *    pPorts = NULL;
    BOOL                fReturn = FALSE;
    HRESULT                hr = hrOK;
    POSITION            pos;

    COM_PROTECT_TRY
    {

        CORg( portsData.Initialize(pszMachineName) );

        CORg( portsData.LoadDevices(&portsList) );

        // Now go through the list, looking for a routing-enabled port
        pos = portsList.GetHeadPosition();
        while (pos)
        {    
            pPorts = portsList.GetNext(pos);
            
            if ((pPorts->m_dwEnableRouting) ||
                (pPorts->m_dwEnableOutboundRouting))
            {
                fReturn = TRUE;
                break;
            }
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    while (!portsList.IsEmpty())
        delete portsList.RemoveHead();
        
    return fReturn;
}

#ifdef KSL_IPINIP
/*---------------------------------------------------------------------------
    TunnelDialog implementation
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
    TunnelDialog::TunnelDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TunnelDialog::TunnelDialog()
    : CBaseDialog(TunnelDialog::IDD)
{
}

/*!--------------------------------------------------------------------------
    TunnelDialog::~TunnelDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TunnelDialog::~TunnelDialog()
{
}

BEGIN_MESSAGE_MAP(TunnelDialog, CBaseDialog)
    //{{AFX_MSG_MAP(TunnelDialog)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    RadiusServerDialog::DoDataExchange
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void TunnelDialog::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(TunnelDialog)
    //}}AFX_DATA_MAP
}


/*!--------------------------------------------------------------------------
    TunnelDialog::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL TunnelDialog::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    return TRUE;
}


/*!--------------------------------------------------------------------------
    TunnelDialog::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void TunnelDialog::OnOK()
{
    CString        stLocal, stRemote;

    GetDlgItemText(IDC_TUNNEL_EDIT_NAME, m_stName);
    m_stName.TrimLeft();
    m_stName.TrimRight();
    
    if (m_stName.IsEmpty())
    {
        AfxMessageBox(IDS_ERR_TUNNEL_NEEDS_A_NAME);
        GetDlgItem(IDC_TUNNEL_EDIT_NAME)->SetFocus();
        goto Error;
    }

    // Truncate the interface ID to MAX_INTERFACE_NAME_LEN characters
    if (m_stName.GetLength() > MAX_INTERFACE_NAME_LEN)
    {
        m_stName.GetBufferSetLength(MAX_INTERFACE_NAME_LEN+1);
        m_stName.ReleaseBuffer(MAX_INTERFACE_NAME_LEN);
    }
    
    CBaseDialog::OnOK();

Error:
    return;
}

#endif //KSL_IPINIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\info.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    info.cpp
        
    FILE HISTORY:
        Wei Jiang : 10/27/98 --- Add SetExternalRefreshObject to
                            IRouterInfo and RouterInfo implementation
                            to allow multiple router info the share
                            the same AutoRefresh settings.
*/

#include "stdafx.h"
#include "lsa.h"
#include "infoi.h"
#include "rtrstr.h"            // common router strings
#include "refresh.h"        // RouterRefreshObject
#include "routprot.h"
#include "rtrutilp.h"

long    s_cConnections = 1;    // use for AdviseSink connection ids



TFSCORE_API(HRESULT) CreateRouterInfo(IRouterInfo **ppRouterInfo, HWND hWndSync, LPCWSTR szMachine)
{
    Assert(ppRouterInfo);
    
    HRESULT    hr = hrOK;
    RouterInfo *    pRouterInfo = NULL;
    
    COM_PROTECT_TRY
    {
        pRouterInfo = new RouterInfo(hWndSync, szMachine);
        *ppRouterInfo = pRouterInfo;
    }
    COM_PROTECT_CATCH;

    return hr;
}

IMPLEMENT_WEAKREF_ADDREF_RELEASE(RouterInfo);

STDMETHODIMP RouterInfo::QueryInterface(REFIID iid,void **ppv)
{ 
    *ppv = 0; 
    if (iid == IID_IUnknown)
        *ppv = (IUnknown *) (IRouterInfo *) this;
    else if (iid == IID_IRouterInfo)
        *ppv = (IRouterInfo *) this;
    else if (iid == IID_IRouterRefreshAccess)
        *ppv = (IRouterRefreshAccess *) this;
    else if (iid == IID_IRouterAdminAccess)
        *ppv = (IRouterAdminAccess *) this;
    else
        return E_NOINTERFACE;
    
    ((IUnknown *) *ppv)->AddRef(); 
    return hrOK;
}

DEBUG_DECLARE_INSTANCE_COUNTER(RouterInfo)

RouterInfo::RouterInfo(HWND hWndSync, LPCWSTR machineName)
    : m_bDisconnect(FALSE),
    m_hWndSync(hWndSync),
    m_dwRouterType(0),
    m_dwFlags(0),
    m_hMachineConfig(NULL),
    m_hMachineAdmin(NULL),
    m_fIsAdminInfoSet(FALSE),
    m_pbPassword(NULL),
    m_stMachine(machineName),
    m_cPassword(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(RouterInfo);

    InitializeCriticalSection(&m_critsec);

    m_VersionInfo.dwRouterVersion = 0;
    m_VersionInfo.dwOsMajorVersion = 0;
    m_VersionInfo.dwOsMinorVersion = 0;
    m_VersionInfo.dwOsServicePack = 0;
    m_VersionInfo.dwOsBuildNo = 0;
    m_VersionInfo.dwOsFlags = 0;
    m_VersionInfo.dwRouterFlags = 0;
}

RouterInfo::~RouterInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(RouterInfo);
    Unload();

    DeleteCriticalSection(&m_critsec);

    ::SecureZeroMemory(m_pbPassword, m_cPassword);
    delete m_pbPassword;
    m_pbPassword = NULL;
    m_cPassword = 0;
}

STDMETHODIMP_(DWORD) RouterInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP RouterInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RouterInfo::Load
        Implementation of IRouterInfo::Load
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::Load(LPCOLESTR   pszMachine,
                              HANDLE      hMachine
                             )
{
    HRESULT    hr = hrOK;
     RtrCriticalSection    rtrCritSec(&m_critsec);
    TCHAR* psz;
    POSITION pos;
    DWORD dwErr, dwType, dwSize, dwRouterType;
    WCHAR* pwsz, wszMachine[MAX_PATH+3];
    HKEY    hkMachine = NULL;
    USES_CONVERSION;

    COM_PROTECT_TRY
    {

        // Unload any existing information
        // ------------------------------------------------------------
        Unload();

        if (!pszMachine)
        {
            m_stMachine = TEXT("");
            pwsz = NULL;
        }
        else
        {
            m_stMachine = pszMachine;
            pwsz = StrnCpyWFromT(wszMachine, pszMachine, MAX_PATH);
        }

        // Get the version info
        // ------------------------------------------------------------
        CWRg( ConnectRegistry(GetMachineName(), &hkMachine) );
        
        CORg( QueryRouterVersionInfo(hkMachine, &m_VersionInfo) );

        // Get the router type
        // ------------------------------------------------------------
        CORg( QueryRouterType(hkMachine, &dwRouterType, &m_VersionInfo) );        
        m_dwRouterType = dwRouterType;

        
        // If 'hmachine' was not specified, connect
        // ------------------------------------------------------------
        CORg( TryToConnect(pwsz, hMachine) );
        Assert(m_hMachineConfig);
        hMachine = m_hMachineConfig;
        MprConfigServerRefresh(m_hMachineConfig);
                
        // If the caller did not specify a list of LAN adapters,
        // load a list of the LAN adapters from HKLM\Soft\MS\NT\NetworkCards
        // ------------------------------------------------------------
        CORg( RouterInfo::LoadInstalledInterfaceList(OLE2CT(pszMachine),
                                                        &m_IfCBList) );

        // This will fix a lot of weird bugs.
        // If the router has not been configured (if the configured flag
        // has not been set), then we can skip the rest of the
        // configuration section.
        // ------------------------------------------------------------
        
//        if (!(m_VersionInfo.dwRouterFlags & RouterSnapin_IsConfigured))
//        {
//            hr = hrOK;
//            goto Error;
//        }

        if (m_VersionInfo.dwRouterFlags & RouterSnapin_IsConfigured)
        {
            // If the caller did not specify a list of router-managers,
            // load a list of the router-managers from HKLM\Soft\MS\Router
            // ------------------------------------------------------------
            CORg( RouterInfo::LoadInstalledRtrMgrList(pszMachine,
                &m_RmCBList) );
            
            // Load a list with the routing-protocols for each router-manager
            // ------------------------------------------------------------
            pos = m_RmCBList.GetHeadPosition();
            while (pos)
            {
                SRtrMgrCB* pcb = m_RmCBList.GetNext(pos);
                
                CORg( RouterInfo::LoadInstalledRtrMgrProtocolList(
                    pszMachine, pcb->dwTransportId,
                    &m_RmProtCBList,
                    this));
            }
            
            // Load router-level info
            // ------------------------------------------------------------
            MPR_SERVER_0* pInfo;
            
            dwErr = ::MprConfigServerGetInfo(m_hMachineConfig,
                                             0,
                                             (LPBYTE *) &pInfo
                                         ); 
            if (dwErr == NO_ERROR)
            {
                m_SRouterCB.dwLANOnlyMode = pInfo->fLanOnlyMode;
                ::MprConfigBufferFree(pInfo);
            }
            
            // Load the router-managers
            // ------------------------------------------------------------
            CORg( LoadRtrMgrList() );
        }
            
        // Load the interfaces
        // ------------------------------------------------------------
        CORg( LoadInterfaceList() );

        hr = hrOK;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (hkMachine)
        DisconnectRegistry( hkMachine );

    if (!FHrSucceeded(hr))
        Unload();
    
    return hr;
}

                 
/*!--------------------------------------------------------------------------
    RouterInfo::Save
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::Save(LPCOLESTR     pszMachine,
                                 HANDLE      hMachine )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return hrOK;
}


/*!--------------------------------------------------------------------------
    RouterInfo::Unload
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::Unload( )
{
    HRESULT    hr = hrOK;
    RtrCriticalSection    rtrCritSec(&m_critsec);
    
    COM_PROTECT_TRY
    {
        // Destroy all COM objects, this includes interface and
        // router-manager objects
        // ------------------------------------------------------------
        Destruct();
        
        // Empty the list loaded using RouterInfo::LoadInstalledRtrMgrList
        // ------------------------------------------------------------
        while (!m_RmCBList.IsEmpty())
            delete m_RmCBList.RemoveHead();

        // Empty the list loaded using RouterInfo::LoadInstalledRmProtList
        // ------------------------------------------------------------
        while (!m_RmProtCBList.IsEmpty())
            delete m_RmProtCBList.RemoveHead();
        
        // Empty the list loaded using RouterInfo::LoadInstalledInterfaceList
        // ------------------------------------------------------------
        while (!m_IfCBList.IsEmpty())
            delete m_IfCBList.RemoveHead();

        
        DoDisconnect();

        m_dwRouterType = 0;

    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RouterInfo::Merge
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::Merge(IRouterInfo *pNewRouter)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT                hr = hrOK;
    RouterCB            routerCB;

    COM_PROTECT_TRY
    {

        // There are several steps to this process, we need to sync
        // up the CBs and then the objects.  However, we should also
        // do a sanity check to see that all of the objects have CBs
        // but not vice versa (there may be CBs that don't running
        // objects associated with them).
        // ------------------------------------------------------------

        // Merge the basic router dta
        // ------------------------------------------------------------
        pNewRouter->CopyCB(&routerCB);
        m_SRouterCB.LoadFrom(&routerCB);

        // Copy over the version information
        // ------------------------------------------------------------
        pNewRouter->GetRouterVersionInfo(&m_VersionInfo);
        
        // Sync up the RtrMgrCB
        // ------------------------------------------------------------
        CORg( MergeRtrMgrCB(pNewRouter) );
        
        // Sync up the InterfaceCB
        // ------------------------------------------------------------
        CORg( MergeInterfaceCB(pNewRouter) );
        
        // Sync up the RtrMgrProtocolCB
        // ------------------------------------------------------------
        CORg( MergeRtrMgrProtocolCB(pNewRouter) );
        
        // Sync up the RtrMgrs
        // ------------------------------------------------------------
        CORg( MergeRtrMgrs(pNewRouter) );

        // Sync up the Interfaces
        // ------------------------------------------------------------
        CORg( MergeInterfaces(pNewRouter) );
        
        m_dwRouterType = pNewRouter->GetRouterType();
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hrOK;
}


/*!--------------------------------------------------------------------------
    RouterInfo::GetRefreshObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::GetRefreshObject(IRouterRefresh **ppRefresh)
{
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        // ------------------------------------------------------------
        if ((IRouterRefresh*)m_spRefreshObject && ppRefresh)
        {
            *ppRefresh = m_spRefreshObject;
            (*ppRefresh)->AddRef();
        }
        else
        {
            if (ppRefresh)
                *ppRefresh = NULL;
            hr = E_FAIL;
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::SetExternalRefreshObject
        -
        To make multiple RouterInfo share the same AutoRefresh Object, use this
        function.
    Author: WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::SetExternalRefreshObject(IRouterRefresh *pRefresh)
{
    HRESULT    hr = hrOK;

    m_spRefreshObject.Release();
        
    // set to nothing is also allowed
    m_spRefreshObject.Set(pRefresh);

    return hr;
}
    
    
/*!--------------------------------------------------------------------------
    RouterInfo::CopyCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::CopyCB(RouterCB *pRouterCB)
{
    Assert(pRouterCB);
    
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        pRouterCB->dwLANOnlyMode = m_SRouterCB.dwLANOnlyMode;
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RouterInfo::GetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RouterInfo::GetMachineName()
{
    //$UNICODE : kennt, assumes that we are native UNICODE
    // Assumes OLE == W
    // ----------------------------------------------------------------
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return (LPCTSTR) m_stMachine;
}


/*!--------------------------------------------------------------------------
    RouterInfo::SetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::SetMachineName(LPCOLESTR pszMachineName)
{
    //$UNICODE : kennt, assumes that we are native UNICODE
    // Assumes OLE == W
    // ----------------------------------------------------------------

    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_stMachine = pszMachineName;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::GetRouterType
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RouterInfo::GetRouterType()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwRouterType;
}

STDMETHODIMP    RouterInfo::GetRouterVersionInfo(RouterVersionInfo *pVerInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT                hr = hrOK;

    COM_PROTECT_TRY
    {
        *pVerInfo = m_VersionInfo;
        pVerInfo->dwSize = sizeof(RouterVersionInfo);
    }
    COM_PROTECT_CATCH;
    
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::EnumRtrMgrCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::EnumRtrMgrCB( IEnumRtrMgrCB **ppEnumRtrMgrCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromSRmCBList(&m_RmCBList, ppEnumRtrMgrCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::EnumInterfaceCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::EnumInterfaceCB( IEnumInterfaceCB **ppEnumInterfaceCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromSIfCBList(&m_IfCBList, ppEnumInterfaceCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::EnumRtrMgrProtocolCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::EnumRtrMgrProtocolCB(IEnumRtrMgrProtocolCB **ppEnumRmProtCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromSRmProtCBList(&m_RmProtCBList, ppEnumRmProtCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::EnumRtrMgrInterfaceCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::EnumRtrMgrInterfaceCB(IEnumRtrMgrInterfaceCB **ppEnumRmIfCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return E_NOTIMPL;
}

/*!--------------------------------------------------------------------------
    EnumRtrMgrProtocolInterfaceCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::EnumRtrMgrProtocolInterfaceCB(IEnumRtrMgrProtocolInterfaceCB **ppEnumRmProtIfCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return E_NOTIMPL;
}

    
/*!--------------------------------------------------------------------------
    RouterInfo::EnumRtrMgr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::EnumRtrMgr( IEnumRtrMgrInfo **ppEnumRtrMgr)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromRmList(&m_RmList, ppEnumRtrMgr);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::FindRtrMgr
        S_OK is returned if a RtrMgrInfo is found.
        S_FALSE is returned if a RtrMgrInfo was NOT found.
        error codes returned otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::FindRtrMgr( DWORD dwTransportId,
                        IRtrMgrInfo **ppInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIRtrMgrInfo    sprm;
    SRmData        rmData;
    
    COM_PROTECT_TRY
    {
        if (ppInfo)
            *ppInfo = NULL;
        
        // Look through the list of rtr mgrs for the one that matches
        // ------------------------------------------------------------
        pos = m_RmList.GetHeadPosition();
        while (pos)
        {
            rmData = m_RmList.GetNext(pos);
            sprm.Set( rmData.m_pRmInfo );
            Assert(sprm);
            if (sprm->GetTransportId() == dwTransportId)
            {
                hr = hrOK;
                if (ppInfo)
                {
                    *ppInfo = sprm.Transfer();
                }
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::AddRtrMgr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::AddRtrMgr( IRtrMgrInfo *pInfo,
                       IInfoBase *pGlobalInfo,
                       IInfoBase *pClientInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD    dwConnection = 0;
    SRmData    rmData;

    Assert(pInfo);
    
    COM_PROTECT_TRY
    {
        // Fail if there is a duplicate
        // ------------------------------------------------------------
        if (FHrOK(FindRtrMgr(pInfo->GetTransportId(), NULL)))
            CORg(E_INVALIDARG);

        //$ Review: kennt, if any of these calls fail, how do we
        // clean up correctly?
        // ------------------------------------------------------------
        
        // save the new structure
        // ------------------------------------------------------------
        CORg( pInfo->Save(GetMachineName(),
                          m_hMachineConfig,
                          NULL,
                          pGlobalInfo,
                          pClientInfo,
                          0) );
        
        // add the new structure to our list
        // ------------------------------------------------------------
        rmData.m_pRmInfo = pInfo;
        m_RmList.AddTail(rmData);
        
        pInfo->AddWeakRef();
        pInfo->SetParentRouterInfo(this);
        
        m_AdviseList.NotifyChange(ROUTER_CHILD_ADD, ROUTER_OBJ_Rm, 0);
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::DeleteRtrMgr
        -
        This function deletes a router-manager from the router.
        A side-effect of this deletion is that all RtrMgrInterfaceInfo
        objects which refer to this router-manager are also deleted.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::DeleteRtrMgr( DWORD dwTransportId, BOOL fRemove )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT            hr = hrOK;
    HRESULT            hrIf;
    POSITION        pos;
    POSITION        posRM;
    POSITION        posIf;
    SPIRtrMgrInfo    sprm;
    SPIInterfaceInfo    spIf;
    SRmData            rmData;
    
    COM_PROTECT_TRY
    {
        pos = m_RmList.GetHeadPosition();
        while (pos)
        {
            posRM = pos;
            rmData = m_RmList.GetNext(pos);
            sprm.Set( rmData.m_pRmInfo );
            Assert(sprm);

            if (sprm->GetTransportId() == dwTransportId)
                break;
            sprm.Release();
        }

        // did we find a router-manager?
        // ------------------------------------------------------------
        if (sprm)
        {
            // get a list of the InterfaceInfo objects for
            // interfaces over which this router-manager is configured
            // --------------------------------------------------------
            posIf = m_IfList.GetHeadPosition();
            while (posIf)
            {
                spIf.Set( m_IfList.GetNext(posIf) );
                hrIf = spIf->FindRtrMgrInterface(dwTransportId, NULL);
                
                // go through the list and remove the router-manager from
                // each interface
                // ----------------------------------------------------
                if (hrIf == hrFalse)
                {
                    spIf->DeleteRtrMgrInterface(dwTransportId, fRemove);
                }
            }

            // remove the router-manager from our list
            // --------------------------------------------------------
            Assert(rmData.m_pRmInfo == sprm);
            SRmData::Destroy( &rmData );
            m_RmList.RemoveAt(posRM);

            // finally, remove the router-manger itself
            // --------------------------------------------------------
            if (fRemove)
                sprm->Delete(GetMachineName(), NULL);
            
            m_AdviseList.NotifyChange(ROUTER_CHILD_DELETE, ROUTER_OBJ_Rm, 0);
        
        }
        else
            hr = E_INVALIDARG;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::ReleaseRtrMgr
        This function will release the AddRef() that this object has
        on the child.  This allows us to transfer child objects from
        one router to another.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::ReleaseRtrMgr( DWORD dwTransportId )
{
    HRESULT     hr = hrOK;
    POSITION    pos, posRm;
    SRmData            rmData;
    
    COM_PROTECT_TRY
    {
        pos = m_RmList.GetHeadPosition();
        while (pos)
        {
            // Save the position (so that we can delete it)
            posRm = pos;
            rmData = m_RmList.GetNext(pos);

            if (rmData.m_pRmInfo &&
                (rmData.m_pRmInfo->GetTransportId() == dwTransportId))
            {
                // When releasing, we need to disconnect (since the
                // main handle is controlled by the router info).
                rmData.m_pRmInfo->DoDisconnect();
        
                rmData.m_pRmInfo->ReleaseWeakRef();
                rmData.m_pRmInfo = NULL;
                
                // release this node from the list
                m_RmList.RemoveAt(posRm);
                break;
            }

        }        
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::EnumInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::EnumInterface(IEnumInterfaceInfo **ppEnumInterface)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromInterfaceList(&m_IfList, ppEnumInterface);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::FindInterface
        S_OK is returned if an InterfaceInfo is found.
        S_FALSE is returned if an InterfaceInfo was NOT found.
        error codes returned otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::FindInterface(LPCOLESTR pszInterface,
                           IInterfaceInfo **ppInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIInterfaceInfo    spIf;
    
    COM_PROTECT_TRY
    {
        if (ppInfo)
            *ppInfo = NULL;
        
        // Look through the list of rtr mgrs for the one that matches
        // ------------------------------------------------------------
        pos = m_IfList.GetHeadPosition();
        while (pos)
        {
            spIf.Set(m_IfList.GetNext(pos));
            Assert(spIf);
            if (StriCmpW(spIf->GetId(), pszInterface) == 0)
            {
                hr = hrOK;
                if (ppInfo)
                {
                    *ppInfo = spIf.Transfer();
                }
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::FindInterfaceByName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::FindInterfaceByName(LPCOLESTR pszName,
                                             IInterfaceInfo **ppInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIInterfaceInfo    spIf;
    
    COM_PROTECT_TRY
    {
        if (ppInfo)
            *ppInfo = NULL;
        
        // Look through the list of rtr mgrs for the one that matches
        // ------------------------------------------------------------
        pos = m_IfList.GetHeadPosition();
        while (pos)
        {
            spIf.Set(m_IfList.GetNext(pos));
            Assert(spIf);
            if (StriCmpW(spIf->GetTitle(), pszName) == 0)
            {
                hr = hrOK;
                if (ppInfo)
                {
                    *ppInfo = spIf.Transfer();
                }
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::AddInterfaceInternal
        fForce - if this is TRUE, then we require that the Save succeeded.
                else, we ignore the error.
        fAddToRouter - if this is TRUE, we call the InterfaceInfo::Save,
                else, we do not call it (and do not change router state).
        fMoveRmIf - if this is TRUE, we have to convert the RtrMgrIf's to
                point to the one's in THIS router info.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::AddInterfaceInternal(IInterfaceInfo *pInfo,
                                         BOOL fForce,
                                         BOOL fAddToRouter)                   
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    Assert(pInfo);
    
    COM_PROTECT_TRY
    {
        // Fail if there is a duplicate
        // ------------------------------------------------------------
        if (FHrOK(FindInterface(pInfo->GetId(), NULL)))
            CORg(E_INVALIDARG);

        // Also need to check that the friendly name is unique.
        // ------------------------------------------------------------
        if (FHrOK(FindInterfaceByName(pInfo->GetTitle(), NULL)))
            CORg(E_INVALIDARG);

        //$ Review: kennt, if any of these calls fail, how do we
        // clean up correctly?
        // ------------------------------------------------------------

        if (fAddToRouter)
        {
            // save the new structure
            // --------------------------------------------------------
            hr = pInfo->Save(GetMachineName(), m_hMachineConfig, NULL);
            if (fForce)
                CORg( hr );
        }

        // add the new structure to our list
        // ------------------------------------------------------------
        m_IfList.AddTail(pInfo);
        pInfo->AddWeakRef();
        pInfo->SetParentRouterInfo(this);

        m_AdviseList.NotifyChange(ROUTER_CHILD_ADD, ROUTER_OBJ_If, 0);

        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::NotifyRtrMgrInterfaceOfMove
        Notify the appropriate RouterManagers that a new interface
        has been added.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::NotifyRtrMgrInterfaceOfMove(IInterfaceInfo *pIf)
{
    HRESULT     hr = hrOK;
    SPIEnumRtrMgrInterfaceInfo  spEnumRmIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    SPIEnumRtrMgrProtocolInterfaceInfo  spEnumRmProtIf;
    SPIRtrMgrInfo           spRm;
    SPIRtrMgrProtocolInterfaceInfo  spRmProtIf;
    SPIRtrMgrProtocolInfo   spRmProt;

    pIf->EnumRtrMgrInterface(&spEnumRmIf);

    while (spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK)
    {
        // Find the appropriate router manager and have them
        // send a notification.
        // ------------------------------------------------------------
        FindRtrMgr(spRmIf->GetTransportId(), &spRm);

        if (spRm)
        {
            spRm->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);

            // Now for each router-manager, enumerate the protocols
            // --------------------------------------------------------

            spRmIf->EnumRtrMgrProtocolInterface(&spEnumRmProtIf);
            while (spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK)
            {
                spRm->FindRtrMgrProtocol(spRmProtIf->GetProtocolId(),
                                         &spRmProt);
                if (spRmProt)
                {
                    spRmProt->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmProtIf,
                                        0);
                }
                spRmProt.Release();
                spRmProtIf.Release();
            }
        }
        spEnumRmProtIf.Release();
        spRm.Release();
        spRmIf.Release();
        
    }
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::AddInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::AddInterface(IInterfaceInfo *pInfo)
{
    return AddInterfaceInternal(pInfo,
                                TRUE /* bForce */,
                                TRUE /* fAddToRouter */);
}


/*!--------------------------------------------------------------------------
    RouterInfo::DeleteInterface
        -
        This function deletes the named CInterfaceInfo from the router.
        As a side-effect, all the contained CRmInterfaceInfo objects
        are also deleted.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP    RouterInfo::DeleteInterface(LPCOLESTR pszInterface, BOOL fRemove)
{
    return RemoveInterfaceInternal(pszInterface, fRemove);
}


/*!--------------------------------------------------------------------------
    RouterInfo::ReleaseInterface
        This function will release the AddRef() that this object has
        on the child.  This allows us to transfer child objects from
        one router to another.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::ReleaseInterface( LPCOLESTR pszInterface )
{
    HRESULT     hr = hrOK;
    POSITION    pos, posIf;
    SPIInterfaceInfo    spIf;
    
    COM_PROTECT_TRY
    {
        pos = m_IfList.GetHeadPosition();
        while (pos)
        {
            // Save the position (so that we can delete it)
            posIf = pos;
            spIf.Set( m_IfList.GetNext(pos) );

            if (spIf &&
                (StriCmpW(spIf->GetId(), pszInterface) == 0))
            {
                // When releasing, we need to disconnect (since the
                // main handle is controlled by the router info).
                spIf->DoDisconnect();
        
                spIf->ReleaseWeakRef();
                spIf.Release();

                // release this node from the list
                m_IfList.RemoveAt(posIf);
                break;
            }
            spIf.Release();
        }        
    }
    COM_PROTECT_CATCH;
    return hr;    
}

HRESULT RouterInfo::RemoveInterfaceInternal(LPCOLESTR pszIf, BOOL fRemoveFromRouter)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT            hr = hrOK;
    POSITION        pos, posIf;
    SPIInterfaceInfo    spIf;
    
    COM_PROTECT_TRY
    {
        pos = m_IfList.GetHeadPosition();
        while (pos)
        {
            posIf = pos;
            spIf.Set( m_IfList.GetNext(pos) );
            if (StriCmpW(spIf->GetId(), pszIf) == 0)
                break;
            spIf.Release();
        }

        if (!spIf)
            hr = E_INVALIDARG;
        else
        {
            // Remove the interface from our list
            // --------------------------------------------------------
            spIf->Destruct();
            spIf->ReleaseWeakRef();            // remove list addref
            m_IfList.RemoveAt(posIf);

            // Need to remove the RtrMgrInterfaceInfos from the list.
            // --------------------------------------------------------
            SPIEnumRtrMgrInterfaceInfo  spEnumRmIf;
            SPIRtrMgrInterfaceInfo      spRmIf;
            spIf->EnumRtrMgrInterface(&spEnumRmIf);

            for (spEnumRmIf->Reset();
                 hrOK == spEnumRmIf->Next(1, &spRmIf, NULL);
                 spRmIf.Release())
            {
                DWORD   dwTransportId = spRmIf->GetTransportId();
                spRmIf.Release();
                
                spIf->DeleteRtrMgrInterface(dwTransportId, fRemoveFromRouter);
            }

            if (fRemoveFromRouter)
            {
                // Delete the interface from the router
                // ----------------------------------------------------
                spIf->Delete(GetMachineName(), NULL);

                // If this is a WAN interface, delete it from the
                // phonebook-file

                // version # greater than Win2K, this will be done in MprAdminInterfaceDelete, which is called in Delete
                // fix 91331

                DWORD    dwMajor = 0, dwMinor = 0, dwBuildNo = 0;
                HKEY    hkeyMachine = NULL;

                // Ignore the failure code, what else can we do?
                // ------------------------------------------------------------
                DWORD    dwErr = ConnectRegistry(GetMachineName(), &hkeyMachine);
                if (dwErr == ERROR_SUCCESS)
                {
                    dwErr = GetNTVersion(hkeyMachine, &dwMajor, &dwMinor, &dwBuildNo)
;            
                    DisconnectRegistry(hkeyMachine);
                }

                DWORD    dwVersionCombine = MAKELONG( dwBuildNo, MAKEWORD(dwMinor, dwMajor));
                DWORD    dwVersionCombineNT50 = MAKELONG ( VER_BUILD_WIN2K, MAKEWORD(VER_MINOR_WIN2K, VER_MAJOR_WIN2K));

                // if the version is greater than Win2K release
                if(dwVersionCombine > dwVersionCombineNT50)
                    ;    // skip 
                else
                // end if fix 91331
                {

                // ----------------------------------------------------
                if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_FULL_ROUTER)
                    hr = RasPhoneBookRemoveInterface(GetMachineName(),
                        pszIf);
                }
            }
            
            m_AdviseList.NotifyChange(ROUTER_CHILD_DELETE, ROUTER_OBJ_If, 0);
        
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}


STDMETHODIMP RouterInfo::RtrAdvise(IRtrAdviseSink *pRtrAdviseSink,
                                   LONG_PTR *pulConnection,
                                   LPARAM lUserParam)
{
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    RtrCriticalSection    rtrCritSec(&m_critsec);
    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

STDMETHODIMP RouterInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}


STDMETHODIMP RouterInfo::RtrUnadvise(LONG_PTR dwConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(dwConnection);
}



//---------------------------------------------------------------------------
// Function:    CRouterInfo::LoadInstalledRtrMgrList
//
// This function builds a list of the router manager's available
// for installation. The list contains RtrMgrCB structures.
//---------------------------------------------------------------------------

HRESULT RouterInfo::LoadInstalledRtrMgrList(LPCTSTR     pszMachine,
                                            SRtrMgrCBList *pRmCBList)
{
    DWORD            dwErr;
    HKEY            hkeyMachine = 0;
    RegKey            regkey;
    RegKey            regkeyRM;
    RegKey::CREGKEY_KEY_INFO    regKeyInfo;
    RegKeyIterator    regkeyIter;
    HRESULT            hr, hrIter;
    CString            stKey;
    DWORD            dwData;
    DWORD            cchValue;
    SPSZ            spszValue;
    SPSRtrMgrCB        spSRtrMgrCB;
        
    // connect to the registry
    // ----------------------------------------------------------------
    CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

    // open HKLM\Software\Microsoft\Router\CurrentVersion\RouterManagers
    // ----------------------------------------------------------------
    CWRg( regkey.Open(hkeyMachine, c_szRouterManagersKey, KEY_READ) );

    // enumerate the keys
    // ----------------------------------------------------------------
    CORg( regkeyIter.Init(&regkey) );

    for (hrIter = regkeyIter.Next(&stKey); hrIter == hrOK; hrIter = regkeyIter.Next(&stKey))
    {
        // cleanup from the previous loop
        // ------------------------------------------------------------
        regkeyRM.Close();
        
        // open the key
        // ------------------------------------------------------------
        dwErr = regkeyRM.Open(regkey, stKey, KEY_READ);
        
        if (dwErr == ERROR_SUCCESS)
        {
            // Get this information so that we can be more efficient
            // at allocating space.
            // --------------------------------------------------------
            dwErr = regkeyRM.QueryKeyInfo(&regKeyInfo);
        }

        
        if (dwErr != ERROR_SUCCESS)
        {
            continue;
        }

        // Allocate a space for the largest value (we're reading
        // in strings).
        // ------------------------------------------------------------
        spszValue.Free();
        cchValue = MaxCchFromCb( regKeyInfo.dwMaxValueData );
        spszValue = new TCHAR[ MinTCharNeededForCch(cchValue) ];
        Assert(spszValue);
                
        do {
            // read the ProtocolId value
            // --------------------------------------------------------
            dwErr = regkeyRM.QueryValue(c_szProtocolId, dwData);
            if (dwErr != ERROR_SUCCESS) { break; }            

#if (WINVER >= 0x0501)
            if(dwData == PID_IPX) { break; }
#endif

            // allocate a new structure for this router-manager
            // --------------------------------------------------------
            spSRtrMgrCB = new SRtrMgrCB;
            Assert(spSRtrMgrCB);
            
            spSRtrMgrCB->stId = stKey;
            spSRtrMgrCB->dwTransportId = dwData;

            // read the DLLPath value
            // --------------------------------------------------------
            dwErr = regkeyRM.QueryValue(c_szDLLPath, spszValue, cchValue,TRUE);
            if (dwErr != ERROR_SUCCESS) { break; }
            spSRtrMgrCB->stDLLPath = spszValue;

            //
            // read the ConfigDLL value
            //
            //dwErr = regkeyRM.QueryValue(c_szConfigDLL,spszValue,cchValue,TRUE);
            //if (dwErr != ERROR_SUCCESS) { break; }            
            //spSRtrMgrCB->stConfigDLL = spszValue;

            // read the Title value
            // --------------------------------------------------------
            dwErr = regkeyRM.QueryValue(c_szTitle, spszValue, cchValue, FALSE);
            if (dwErr != ERROR_SUCCESS)
                spSRtrMgrCB->stTitle = spSRtrMgrCB->stId;
            else
                spSRtrMgrCB->stTitle = spszValue;
            
            // add the object to our list
            // --------------------------------------------------------
            pRmCBList->AddTail(spSRtrMgrCB);

            // Release the pointer, it belongs to pRmCBList now.
            // --------------------------------------------------------
            spSRtrMgrCB.Transfer();
            
        } while(FALSE);

        // If there was an error with the registry values, we
        // ignore it and go onto the nextkey.
        // ------------------------------------------------------------

        regkeyRM.Close();        
    }

    if (!FHrSucceeded(hrIter))
        hr = hrIter;
    
Error:
    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);

    return hr;
}

HRESULT RouterInfo::LoadInstalledRtrMgrProtocolList(LPCTSTR pszMachine,
        DWORD dwTransportId, SRtrMgrProtocolCBList *pRmProtCBList, RouterInfo * pRouter)
{
    WCHAR    *        pszPassword = NULL;
    int                nPasswordLen = 0;
    UCHAR            ucSeed = 0x83;            //why?
    HRESULT            hr = hrOK;

    if ( pRouter->IsAdminInfoSet() )
    {
        pRouter->GetUserPassword(NULL, &nPasswordLen );

        pszPassword = (WCHAR *) new WCHAR [(nPasswordLen /sizeof(WCHAR)) + 1 ];
        pRouter->GetUserPassword( (BYTE *)pszPassword, &nPasswordLen  );
        pszPassword[nPasswordLen/sizeof(WCHAR) ] = 0;
        RtlDecodeW(ucSeed, pszPassword);

        hr = RouterInfo::LoadInstalledRtrMgrProtocolList(    pszMachine, 
                                                            dwTransportId, 
                                                            pRmProtCBList, 
                                                            pRouter->GetUserName(), 
                                                            pszPassword, 
                                                            pRouter->GetDomainName() );
        if ( pszPassword )
        {
            ::SecureZeroMemory ( pszPassword, nPasswordLen );
            delete pszPassword;
        }
    }
    else
    {
        hr = RouterInfo::LoadInstalledRtrMgrProtocolList(    pszMachine, 
                                                            dwTransportId, 
                                                            pRmProtCBList, 
                                                            NULL, 
                                                            NULL, 
                                                            NULL );
    }
    return hr;
}
HRESULT RouterInfo::LoadInstalledRtrMgrProtocolList(LPCTSTR pszMachine,
        DWORD dwTransportId, SRtrMgrProtocolCBList *pRmProtCBList, IRouterInfo * pRouter)
{
    WCHAR    *                pszPassword = NULL;
    int                        nPasswordLen = 0;
    UCHAR                    ucSeed = 0x83;            //why?
    HRESULT                    hr = hrOK;
    SPIRouterAdminAccess    spAdmin;


    spAdmin.HrQuery(pRouter);
    if (spAdmin && spAdmin->IsAdminInfoSet())
    {

        spAdmin->GetUserPassword(NULL, &nPasswordLen );

        pszPassword = (WCHAR *) new WCHAR [(nPasswordLen /sizeof(WCHAR)) + 1 ];
        spAdmin->GetUserPassword( (BYTE *)pszPassword, &nPasswordLen  );
        pszPassword[nPasswordLen/sizeof(WCHAR) ] = 0;
        RtlDecodeW(ucSeed, pszPassword);

        hr = RouterInfo::LoadInstalledRtrMgrProtocolList(    pszMachine, 
                                                            dwTransportId, 
                                                            pRmProtCBList, 
                                                            spAdmin->GetUserName(), 
                                                            pszPassword, 
                                                            spAdmin->GetDomainName() );
        if ( pszPassword )
        {
            ::SecureZeroMemory ( pszPassword, nPasswordLen );
            delete pszPassword;
        }
    }
    else
    {
        hr = RouterInfo::LoadInstalledRtrMgrProtocolList(    pszMachine, 
                                                            dwTransportId, 
                                                            pRmProtCBList, 
                                                            NULL, 
                                                            NULL, 
                                                            NULL );

    }
    return hr;
}

//---------------------------------------------------------------------------
// Function:    CRouterInfo::QueryInstalledRmProtList
//
// This function builds a list of the routing protocols which can be added
// to the specified router manager.
//---------------------------------------------------------------------------

HRESULT    RouterInfo::LoadInstalledRtrMgrProtocolList(
    LPCTSTR     pszMachine,
    DWORD       dwTransportId,
    SRtrMgrProtocolCBList *    pSRmProtCBList,
    LPCWSTR lpwszUserName, 
    LPCWSTR lpwszPassword , 
    LPCWSTR lpwszDomain
    )
{
    Assert(pSRmProtCBList);
    
    DWORD            dwErr;
    HKEY            hkey, hkrm, hkeyMachine = 0;
    HRESULT            hr = hrOK;
    RegKey            regkeyRM;
    RegKey            regkeyProt;
    RegKey::CREGKEY_KEY_INFO    regKeyInfo;
    RegKeyIterator    regkeyIter;
    HRESULT            hrIter;
    SPSZ            spszValue;
    SPSZ            spszRm;
    ULONG            cchValue;
    CString            stKey;
    SPSRtrMgrProtocolCB    spSRmProtCB;
    DWORD            dwData;
    BOOL            f64BitAdmin = FALSE;
    BOOL            f64BitLocal = FALSE;
    TCHAR           szLocalMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD           dwLocalMachineNameSize = MAX_COMPUTERNAME_LENGTH + 1;



    if ( lpwszUserName )
        CWRg( IsWindows64Bit(pszMachine, lpwszUserName, lpwszPassword, lpwszDomain, &f64BitAdmin) );
    else
        CWRg( IsWindows64Bit(pszMachine, NULL, NULL, NULL, &f64BitAdmin) );

    
    GetComputerName ( szLocalMachineName, &dwLocalMachineNameSize );

    if ( !lstrcmp ( szLocalMachineName, pszMachine ) )
    {
        f64BitLocal = f64BitAdmin;
    }
    else
    {
        CWRg( IsWindows64Bit(szLocalMachineName, NULL, NULL, NULL, &f64BitLocal) );
    }
    // connect to the registry
    // ----------------------------------------------------------------
    CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

    // open the key for the specified router-manager
    // under HKLM\Software\Microsoft\Router\RouterManagers
    // ----------------------------------------------------------------
    CWRg( FindRmSoftwareKey(hkeyMachine, dwTransportId, &hkrm, &spszRm) );

    // The transport was found, so its registry key is in 'hkrm'
    // ----------------------------------------------------------------
    regkeyRM.Attach(hkrm);

    // enumerate the keys
    // ----------------------------------------------------------------

    CORg( regkeyIter.Init(&regkeyRM) );

    for (hrIter=regkeyIter.Next(&stKey); hrIter==hrOK; hrIter=regkeyIter.Next(&stKey))
    {
        // Cleanup from the previous loop
        // ------------------------------------------------------------
        regkeyProt.Close();
        
        // open the key
        // ------------------------------------------------------------
        dwErr = regkeyProt.Open(regkeyRM, stKey, KEY_READ);
        if (dwErr != ERROR_SUCCESS)
        {
            continue;
        }
        
        do {

            // allocate a new structure for this protocol
            // --------------------------------------------------------
            spSRmProtCB.Free();
            spSRmProtCB = new SRtrMgrProtocolCB;
            Assert(spSRmProtCB);

            spSRmProtCB->stId = stKey;
            spSRmProtCB->dwTransportId = dwTransportId;
            spSRmProtCB->stRtrMgrId = spszRm;

            // get information about the key's values
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryKeyInfo(&regKeyInfo);
            if (dwErr != ERROR_SUCCESS) { break; }

            // allocate space to hold the longest of the values
            // --------------------------------------------------------
            spszValue.Free();
            cchValue = (regKeyInfo.dwMaxValueData)/sizeof(TCHAR);
            spszValue = new TCHAR[cchValue * (2/sizeof(TCHAR))];
            Assert(spszValue);

            // read the ProtocolId value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szProtocolId, dwData);
            if (dwErr != ERROR_SUCCESS) { break; }
//#if IA64
            //OSPF node should be shown iff we are a 32 bit machine administering
            //a 32 bit machine
            if ( f64BitAdmin  || f64BitLocal )
                if( dwData == PROTO_IP_OSPF ) {break;}

            
//#endif
            spSRmProtCB->dwProtocolId = dwData;

            // read the Flags value
            //
            dwErr = regkeyProt.QueryValue(c_szFlags, dwData);
            if (dwErr != ERROR_SUCCESS)
                spSRmProtCB->dwFlags = 0;
            else
                spSRmProtCB->dwFlags = dwData;

            //
            // read the DLLName value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szDLLName, spszValue, cchValue,
                                          TRUE);
            if (dwErr != ERROR_SUCCESS)
                spSRmProtCB->stDLLName.Empty();
            else
                spSRmProtCB->stDLLName = (LPCTSTR)spszValue;

            //
            // read the ConfigDLL value
            //
            //dwErr = regkeyProt.QueryValue(c_szConfigDLL, spszValue, cchValue,
            //                              TRUE);
            //if (dwErr != ERROR_SUCCESS) { break; }
            //spSRmProtCB->stConfigDLL = (LPCTSTR)spszValue;

            
            // read the ConfigCLSID value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szConfigCLSID, spszValue, cchValue, FALSE);
            
            // Ignore the error code, if there is no CLSID, just NULL out
            // the GUID, note that we can't depend on the key necessarily
            // being there (for NT4 reasons).
            // --------------------------------------------------------
            ::ZeroMemory(&(spSRmProtCB->guidConfig), sizeof(GUID));
            if ((dwErr != ERROR_SUCCESS) ||
                !FHrSucceeded(CLSIDFromString(T2OLE((LPTSTR)(LPCTSTR) spszValue),
                                             &(spSRmProtCB->guidConfig))))
                memset(&(spSRmProtCB->guidConfig), 0xff, sizeof(GUID));

            
            // read the AdminUICLSID value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szAdminUICLSID, spszValue, cchValue, FALSE);

            // Ignore the error code, if there is no CLSID, just NULL out
            // the GUID, note that we can't depend on the key necessarily
            // being there (for NT4 reasons).
            // --------------------------------------------------------
            ::ZeroMemory(&(spSRmProtCB->guidAdminUI), sizeof(GUID));
            if ((dwErr != ERROR_SUCCESS) ||
                !FHrSucceeded(CLSIDFromString(T2OLE((LPTSTR)(LPCTSTR) spszValue),
                                             &(spSRmProtCB->guidAdminUI))))
                memset(&(spSRmProtCB->guidAdminUI), 0xff, sizeof(GUID));

            // read the VendorName value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szVendorName, spszValue, cchValue, FALSE);
            
            // Ignore the error code, if there is no value, just NULL out
            // the value, note that we can't depend on the key necessarily
            // being there (for NT4 reasons).
            // --------------------------------------------------------
            if (dwErr == ERROR_SUCCESS)
                spSRmProtCB->stVendorName = spszValue;

            // read the Title value
            // --------------------------------------------------------
            dwErr = regkeyProt.QueryValue(c_szTitle, spszValue, cchValue,
                                          FALSE);
            if (dwErr != ERROR_SUCCESS)
                spSRmProtCB->stTitle = spSRmProtCB->stId;
            else
                spSRmProtCB->stTitle = (LPCTSTR)spszValue;

            // add the object to our list
            // --------------------------------------------------------
            pSRmProtCBList->AddTail(spSRmProtCB);

            // Let this go, it's under the control of the protList
            // --------------------------------------------------------
            spSRmProtCB.Transfer();

            dwErr = ERROR_SUCCESS;

        } while(FALSE);

    }

Error:

    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);

    return hr;
}


//---------------------------------------------------------------------------
// Function:    CRouterInfo::LoadInstalledInterfaceList
//
// This function builds a list of network cards available for addition
// to the router manager.
//---------------------------------------------------------------------------

HRESULT RouterInfo::LoadInstalledInterfaceList(LPCTSTR     pszMachine,
                                               SInterfaceCBList *pSIfCBList)
{
    DWORD            dwErr;
    HKEY            hkeyMachine = 0;
    RegKey            regkeyNC;
    RegKey            regkeyCard;
    CStringList        ipCardList;
    CStringList        ipxCardList;
    RegKeyIterator    regkeyIter;
    HRESULT            hrIter;
    CString            stKey;
    SPSInterfaceCB    spSIfCB;
    HRESULT            hr = hrOK;
    BOOL            fNT4;
    LPCTSTR            pszKey;
    CString            stServiceName;
    CNetcardRegistryHelper    ncreghelp;
    DWORD           ifBindFlags = 0;

    
    // connect to the registry
    // ----------------------------------------------------------------
    CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

    
    //$NT5: kennt, changes made to read NT5 specific information
    // ----------------------------------------------------------------
    CWRg( IsNT4Machine(hkeyMachine, &fNT4) );

    
    // open HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards
    // ----------------------------------------------------------------
    pszKey = fNT4 ? c_szNetworkCardsKey : c_szNetworkCardsNT5Key;
    CWRg( regkeyNC.Open(hkeyMachine, pszKey, KEY_READ) );

    
    // get the netcards that IP and IPX are bound to
    // ----------------------------------------------------------------
    CORg( ::LoadLinkageList(pszMachine, hkeyMachine, TEXT("tcpip"),
                             &ipCardList) );
    CORg( ::LoadLinkageList(pszMachine, hkeyMachine, TEXT("nwlnkipx"),
                             &ipxCardList) );

    
    // enumerate the subkeys, and for each key,
    // make an addition to our list
    // ----------------------------------------------------------------
    CWRg( regkeyIter.Init(&regkeyNC) );

    hrIter = regkeyIter.Next(&stKey);

    for (; hrIter == hrOK; hrIter=regkeyIter.Next(&stKey))
    {
        ifBindFlags = 0;
        regkeyCard.Close();
        
        // now open the key
        // ------------------------------------------------------------
        dwErr = regkeyCard.Open(regkeyNC, stKey, KEY_READ);
        if (dwErr != ERROR_SUCCESS)
            continue;

        
        // setup the helper class
        // ------------------------------------------------------------
        ncreghelp.Initialize(fNT4, regkeyCard, stKey,
                             pszMachine);

        do {
            // read the ServiceName
            // --------------------------------------------------------

            //$NT5: the service name is not in the same format as NT4
            // this will need to be done differently.
            // --------------------------------------------------------
            if (fNT4)
            {
                dwErr = ncreghelp.ReadServiceName();
                if (dwErr != ERROR_SUCCESS)
                    break;
                stServiceName = ncreghelp.GetServiceName();
            }
            else
                stServiceName = stKey;

            // if the service name is not in the IP or IPX adapter list,
            // then ignore this netcard because it is not a real netcard
            // --------------------------------------------------------
            if (ipCardList.Find((LPCTSTR) stServiceName))
            {
                ifBindFlags |= InterfaceCB_BindToIp;
            }


            // Now check IPX
            // ------------------------------------------------
            {
                BOOL    fFound = TRUE;
                CString    stNewServiceName;
                
                do
                {
                    if (ipxCardList.Find((LPCTSTR) stServiceName))
                        break;
                    
                    stNewServiceName = stServiceName + c_szEthernetSNAP;
                    if (ipxCardList.Find((LPCTSTR) stNewServiceName))
                        break;
                    
                    stNewServiceName = stServiceName + c_szEthernetII;
                    if (ipxCardList.Find((LPCTSTR) stNewServiceName))
                        break;
                    
                    stNewServiceName = stServiceName + c_szEthernet8022;
                    if (ipxCardList.Find((LPCTSTR) stNewServiceName))
                        break;
                    
                    stNewServiceName = stServiceName + c_szEthernet8023;
                    if (ipxCardList.Find((LPCTSTR) stNewServiceName))
                        break;
                    
                    fFound = FALSE;
                } while (FALSE);

                if (fFound)
                    ifBindFlags |= InterfaceCB_BindToIpx;
                
            }

            // If we didn't find it in IP or IPX
            // break out of the loop
            // ----------------------------------------------------
            if (ifBindFlags == 0)
                break;                

            
            // ignore NdisWan adapters
            // --------------------------------------------------------
            if (_wcsnicmp( (const wchar_t *)stServiceName, 
                           L"NdisWan", 
                           (sizeof(L"NdisWan")-1)/sizeof (WCHAR)) == 0 ) {
                break;
            }
            
            // allocate an SSInterfaceCB
            // --------------------------------------------------------
            spSIfCB = new SInterfaceCB;
            Assert(spSIfCB);

            spSIfCB->stId = (LPCTSTR) stServiceName;
            spSIfCB->dwIfType = ROUTER_IF_TYPE_DEDICATED;
            spSIfCB->dwBindFlags = ifBindFlags;

            // read the title
            // --------------------------------------------------------
            dwErr = ncreghelp.ReadTitle();
            if (dwErr != ERROR_SUCCESS)
                spSIfCB->stTitle = spSIfCB->stId;
            else
                spSIfCB->stTitle = (LPCTSTR) ncreghelp.GetTitle();

            // read the device
            // --------------------------------------------------------
            dwErr = ncreghelp.ReadDeviceName();
            if (dwErr != ERROR_SUCCESS)
                spSIfCB->stDeviceName = spSIfCB->stTitle;
            else
                spSIfCB->stDeviceName = (LPCTSTR) ncreghelp.GetDeviceName();

            // add the SSInterfaceCB to the callers list
            // --------------------------------------------------------
            pSIfCBList->AddTail(spSIfCB);
            spSIfCB.Transfer();

            dwErr = NO_ERROR;

        } while (FALSE);

        if (dwErr != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

    }

Error:
    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);

    return dwErr;
}

//---------------------------------------------------------------------------
// Function:    CRouterInfo::LoadRtrMgrList
//---------------------------------------------------------------------------

HRESULT RouterInfo::LoadRtrMgrList()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    BOOL        bFound = TRUE;
    SPIRtrMgrInfo    spRmInfo;
    BYTE*        pItemTable = NULL;
    MPR_TRANSPORT_0* ptransport;
    DWORD dwErr, i, dwEntries, dwTotal;
    HRESULT        hr = hrOK;
    USES_CONVERSION;

    // Enumerate the transports configured
    // ----------------------------------------------------------------
    dwErr = ::MprConfigTransportEnum(
                m_hMachineConfig,
                0,
                &pItemTable,
                (DWORD)-1,
                &dwEntries,
                &dwTotal,
                NULL
                );

    if (dwErr != NO_ERROR && dwErr != ERROR_NO_MORE_ITEMS)
        return HRESULT_FROM_WIN32(dwErr);

    // Create router-manager objects for each transport
    // ----------------------------------------------------------------

    for (i = 0, ptransport = (MPR_TRANSPORT_0*)pItemTable;
         i < dwEntries;
         i++, ptransport++) {

#if (WINVER >= 0x0501)
        if (ptransport->dwTransportId == PID_IPX) {continue;}
#endif

        // See if the transport is already in our list,
        // and if not create an object for it.
        // ------------------------------------------------------------
        FindRtrMgr(ptransport->dwTransportId, &spRmInfo);

        if (spRmInfo == NULL)
        {
            // Construct a CRmInfo object on this transport
            // --------------------------------------------------------
            spRmInfo = new RtrMgrInfo(ptransport->dwTransportId,
                                  W2T(ptransport->wszTransportName), this);
            spRmInfo->SetFlags( RouterSnapin_InSyncWithRouter );
            Assert(spRmInfo);
            bFound = FALSE;
        }
        else
            bFound = TRUE;


        // Load the information for the transport,
        // including its list of protocols
        // ------------------------------------------------------------
        hr = spRmInfo->Load(GetMachineName(),
                            m_hMachineConfig,
                            ptransport->hTransport);
        if (!FHrSucceeded(hr))
        {
            spRmInfo->Destruct();
            spRmInfo.Release();
            continue;
        }

        // Add the router manager object to our list
        // ------------------------------------------------------------
        if (bFound == FALSE)
        {
            SRmData    rmData;
            
            rmData.m_pRmInfo = spRmInfo;
            m_RmList.AddTail(rmData);
            
            CONVERT_TO_WEAKREF(spRmInfo);
            spRmInfo.Transfer();
        }

    }

//Error:
    if (pItemTable)
        ::MprConfigBufferFree(pItemTable);

    return hr;
}


//---------------------------------------------------------------------------
// Function:    RouterInfo::LoadInterfaceList
//---------------------------------------------------------------------------

HRESULT RouterInfo::LoadInterfaceList()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    BOOL                bAdd;
    BYTE*                pItemTable = NULL;
    SPIInterfaceInfo    spIfInfo;
    MPR_INTERFACE_0*    pinterface;
    DWORD                dwErr, i;
    DWORD                dwEntries = 0, dwTotal = 0;
    HRESULT                hr = hrOK;
    HRESULT                tmpHr = hrOK;
    SPMprServerHandle    sphMprServer;
    BOOL                fMprAdmin = TRUE;   // was MprAdminInterfaceEnum used?
    USES_CONVERSION;

    // Windows NT Bug : 180752
    // Should try to enumerate with MprAdminInterfaceEnum first.
    dwErr = ConnectRouter(GetMachineName(), &sphMprServer);
    if (dwErr == NO_ERROR)
    {
        dwErr = ::MprAdminInterfaceEnum(sphMprServer,    
                                        0,
                                        (BYTE **) &pItemTable,
                                        (DWORD) -1,
                                        &dwEntries,
                                        &dwTotal,
                                        NULL);
    }

    if (dwErr != NO_ERROR)
    {
        Assert(pItemTable == NULL);

        // MprConfigInterfaceEnum is used, not MprAdminIntefaceEnum
        // ------------------------------------------------------------
        fMprAdmin = FALSE;
        
        // Enumerate the interfaces configured
        // ------------------------------------------------------------
        dwErr = ::MprConfigInterfaceEnum(
                                         m_hMachineConfig,
                                         0,
                                         &pItemTable,
                                         (DWORD)-1,
                                         &dwEntries,
                                         &dwTotal,
                                         NULL
                                        );
    }

    if (dwErr != NO_ERROR && dwErr != ERROR_NO_MORE_ITEMS)
        return HRESULT_FROM_WIN32(dwErr);

    // Delete interface-objects for interfaces which don't exist anymore
    // ----------------------------------------------------------------
    POSITION pos = m_IfList.GetHeadPosition();

    while (pos) {

        POSITION postemp = pos;

        spIfInfo.Set( m_IfList.GetNext(pos) );
        
        // See if the interface is in the new table
        // ------------------------------------------------------------
        for (i = 0, pinterface = (MPR_INTERFACE_0*)pItemTable;
             i < dwEntries;
             i++, pinterface++)
        {
            if (StriCmpW(OLE2CW(spIfInfo->GetId()), pinterface->wszInterfaceName) == 0)
                break;
        }

        // Go on if the interface was found
        // ------------------------------------------------------------
        if (i < dwEntries)
        {
            // Update the interface's settings
            // --------------------------------------------------------
            spIfInfo->SetInterfaceEnabledState( pinterface->fEnabled );
            continue;
        }

        // The interface-object was not found and is obsolete; delete it
        // ------------------------------------------------------------
        m_IfList.RemoveAt(postemp);
        spIfInfo->Destruct();
        spIfInfo->ReleaseWeakRef();    // remove list addref
        
        spIfInfo.Release();    // this will release the sp addref
    }


    // Create interface objects for each new interface
    // ----------------------------------------------------------------

    for (i = 0, pinterface = (MPR_INTERFACE_0*)pItemTable;
         i < dwEntries;
         i++, pinterface++)
    {

        spIfInfo.Release();

        // See if the interface exists,
        // and if not create a new interface object
        // ------------------------------------------------------------
        FindInterface(W2OLE(pinterface->wszInterfaceName), &spIfInfo);

        if (spIfInfo == NULL)
        {
            SInterfaceCB *  pSIfCB = NULL;
            bAdd = TRUE;

            // Find the CB that corresponds to this interface
            // --------------------------------------------------------
            pSIfCB = FindInterfaceCB(pinterface->wszInterfaceName);

            // Construct a CInterfaceInfo object on this interface
            // --------------------------------------------------------
            spIfInfo = new InterfaceInfo(W2T(pinterface->wszInterfaceName),
                                         pinterface->dwIfType,
                                         pinterface->fEnabled,
                                         pSIfCB ? pSIfCB->dwBindFlags :
                                           (InterfaceCB_BindToIp | InterfaceCB_BindToIpx),
                                         this);
            spIfInfo->SetFlags( RouterSnapin_InSyncWithRouter );
            Assert(spIfInfo);
        }
        else
            bAdd = FALSE;


        // Load the information for the interface
        // ------------------------------------------------------------
        tmpHr = spIfInfo->Load(GetMachineName(),
                            m_hMachineConfig, NULL);

        if (!FHrSucceeded(tmpHr))
        {
            spIfInfo->Destruct();
            spIfInfo.Release();
            continue;
        }

        // add the object to our interface list
        // ------------------------------------------------------------
        if (bAdd)
        {
            m_IfList.AddTail(spIfInfo);
            CONVERT_TO_WEAKREF(spIfInfo);
            spIfInfo.Transfer();
        }
    }

//Error:
    if (pItemTable)
    {
        if (fMprAdmin)
            ::MprAdminBufferFree(pItemTable);
        else
            ::MprConfigBufferFree(pItemTable);
    }

    return hr;
}



/*!--------------------------------------------------------------------------
    RouterInfo::ReviveStrongRef
        Override of CWeakRef::ReviveStrongRef
    Author: KennT
 ---------------------------------------------------------------------------*/
void RouterInfo::ReviveStrongRef()
{
    // Don't need to do anything
}

/*!--------------------------------------------------------------------------
    RouterInfo::OnLastStrongRef
        Override of CWeakRef::OnLastStrongRef

        On the last strong reference for the router info indicates that
        there are no strong pointers to any object in the hierarchy.  Thus
        we are free to remove all of our internal pointers.
    Author: KennT
 ---------------------------------------------------------------------------*/
void RouterInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    Destruct();
}

/*!--------------------------------------------------------------------------
    RouterInfo::Destruct
        Implementation of IRouterInfo::Destruct
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IInterfaceInfo *    pIf;
    SRmData                rmData;
    
    // Destroy the interface objects
    // ----------------------------------------------------------------
    while (!m_IfList.IsEmpty())
    {
        pIf = m_IfList.RemoveHead();
        pIf->Destruct();
        pIf->ReleaseWeakRef();
    }
    
    // Destroy the router-manager objects
    // ----------------------------------------------------------------
    while (!m_RmList.IsEmpty())
    {
        rmData = m_RmList.RemoveHead();
        SRmData::Destroy( &rmData );
    }
    
    return hrOK; 
}

/*!--------------------------------------------------------------------------
    RouterInfo::TryToConnect
        If we are already connected, then the handle passed in is
        ignored.

        Otherwise, if "hMachine" was not specified, connect to the
        config on the specified machine.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::TryToConnect(LPCWSTR pswzMachine, HANDLE hMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    if (m_hMachineConfig == NULL)
    {
        if (hMachine)
        {
            m_hMachineConfig = hMachine;
            m_bDisconnect = FALSE;            
        }
        else
        {
            CWRg( ::MprConfigServerConnect((LPWSTR) pswzMachine,
                                           &m_hMachineConfig) );
            m_bDisconnect = TRUE;
        }
    }

Error:
    return hr;
}

STDMETHODIMP RouterInfo::OnChange(LONG_PTR ulConnection,
                                  DWORD dwChangeType,
                                  DWORD dwObjectType,
                                  LPARAM lUserParam,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::MergeRtrMgrCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterInfo::MergeRtrMgrCB(IRouterInfo *pNewRouter)
{
    HRESULT            hr = hrOK;
    SPIEnumRtrMgrCB    spRmCB;
    RtrMgrCB        rmCB;
    SRtrMgrCB *        pSRmCB;
    POSITION        pos, posDelete;

    // Set the internal data on the SRtrMgrCBs to 0
    // ----------------------------------------------------------------
    pos = m_RmCBList.GetHeadPosition();
    while (pos)
    {
        pSRmCB = m_RmCBList.GetNext(pos);
        Assert(pSRmCB);
        pSRmCB->dwPrivate = 0;
    }

    CORg( pNewRouter->EnumRtrMgrCB(&spRmCB) );

    while (spRmCB->Next(1, &rmCB, NULL) == hrOK)
    {
        // Now look for this rmCB in our current list
        // If we find it, mark the CB
        // If we do not find it, add this RmCB
        // ------------------------------------------------------------

        pSRmCB = FindRtrMgrCB(rmCB.dwTransportId);
        if (pSRmCB)
        {
            pSRmCB->dwPrivate = 1;
        }
        else
        {
            // Add this CB to the internal list
            // --------------------------------------------------------
            SRtrMgrCB *    pNewSRmCB = new SRtrMgrCB;

            pNewSRmCB->LoadFrom(&rmCB);
            pNewSRmCB->dwPrivate = 1;
            
            m_RmCBList.AddTail(pNewSRmCB);
        }
        
    }

    // Now go through the internal list and delete all items that we
    // didn't find in the new list
    // ----------------------------------------------------------------
    pos = m_RmCBList.GetHeadPosition();
    while (pos)
    {
        pSRmCB = m_RmCBList.GetNext(pos);
        Assert(pSRmCB);
        if (pSRmCB->dwPrivate == 0)
        {
            posDelete = m_RmCBList.Find(pSRmCB);
            m_RmCBList.RemoveAt(posDelete);
            delete pSRmCB;
        }
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::MergeInterfaceCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT    RouterInfo::MergeInterfaceCB(IRouterInfo *pNewRouter)
{
    HRESULT            hr = hrOK;
    SPIEnumInterfaceCB    spIfCB;
    InterfaceCB        IfCB;
    SInterfaceCB *        pSIfCB;
    POSITION        pos, posDelete;

    // Set the internal data on the SInterfaceCBs to 0
    // ----------------------------------------------------------------
    pos = m_IfCBList.GetHeadPosition();
    while (pos)
    {
        pSIfCB = m_IfCBList.GetNext(pos);
        Assert(pSIfCB);
        pSIfCB->dwPrivate = 0;
    }

    CORg( pNewRouter->EnumInterfaceCB(&spIfCB) );

    while (spIfCB->Next(1, &IfCB, NULL) == hrOK)
    {
        // Now look for this IfCB in our current list
        // If we find it, mark the CB
        // If we do not find it, add this IfCB
        // ------------------------------------------------------------

        pSIfCB = FindInterfaceCB(IfCB.szId);
        if (pSIfCB)
        {
            // We found it, update the internal data
            // --------------------------------------------------------
            pSIfCB->bEnable = IfCB.bEnable;
            pSIfCB->dwPrivate = 1;
        }
        else
        {
            // Add this CB to the internal list
            // --------------------------------------------------------
            SInterfaceCB *    pNewSIfCB = new SInterfaceCB;

            pNewSIfCB->LoadFrom(&IfCB);
            pNewSIfCB->dwPrivate = 1;
            
            m_IfCBList.AddTail(pNewSIfCB);
        }
        
    }

    // Now go through the internal list and delete all items that we
    // didn't find in the new list
    // ----------------------------------------------------------------
    pos = m_IfCBList.GetHeadPosition();
    while (pos)
    {
        pSIfCB = m_IfCBList.GetNext(pos);
        Assert(pSIfCB);
        if (pSIfCB->dwPrivate == 0)
        {
            posDelete = m_IfCBList.Find(pSIfCB);
            m_IfCBList.RemoveAt(posDelete);
            delete pSIfCB;
        }
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::MergeRtrMgrProtocolCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT    RouterInfo::MergeRtrMgrProtocolCB(IRouterInfo *pNewRouter)
{
    HRESULT            hr = hrOK;
    SPIEnumRtrMgrProtocolCB    spRmProtCB;
    RtrMgrProtocolCB        RmProtCB;
    SRtrMgrProtocolCB *        pSRmProtCB;
    POSITION        pos, posDelete;

    // Set the internal data on the SRtrMgrProtocolCBs to 0
    // ----------------------------------------------------------------
    pos = m_RmProtCBList.GetHeadPosition();
    while (pos)
    {
        pSRmProtCB = m_RmProtCBList.GetNext(pos);
        Assert(pSRmProtCB);
        pSRmProtCB->dwPrivate = 0;
    }

    CORg( pNewRouter->EnumRtrMgrProtocolCB(&spRmProtCB) );

    while (spRmProtCB->Next(1, &RmProtCB, NULL) == hrOK)
    {
        // Now look for this RmProtCB in our current list
        // If we find it, mark the CB
        // If we do not find it, add this RmProtCB
        // ------------------------------------------------------------

        pSRmProtCB = FindRtrMgrProtocolCB(RmProtCB.dwTransportId,
                                          RmProtCB.dwProtocolId);
        if (pSRmProtCB)
        {
            pSRmProtCB->dwPrivate = 1;
        }
        else
        {
            // Add this CB to the internal list
            // --------------------------------------------------------
            SRtrMgrProtocolCB *    pNewSRmProtCB = new SRtrMgrProtocolCB;

            pNewSRmProtCB->LoadFrom(&RmProtCB);
            pNewSRmProtCB->dwPrivate = 1;
            
            m_RmProtCBList.AddTail(pNewSRmProtCB);
        }
        
    }

    // Now go through the internal list and delete all items that we
    // didn't find in the new list
    // ----------------------------------------------------------------
    pos = m_RmProtCBList.GetHeadPosition();
    while (pos)
    {
        pSRmProtCB = m_RmProtCBList.GetNext(pos);
        Assert(pSRmProtCB);
        if (pSRmProtCB->dwPrivate == 0)
        {
            posDelete = m_RmProtCBList.Find(pSRmProtCB);
            m_RmProtCBList.RemoveAt(posDelete);
            delete pSRmProtCB;
        }
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::MergeRtrMgrs
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT    RouterInfo::MergeRtrMgrs(IRouterInfo *pNewRouter)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    SPIEnumRtrMgrInfo    spEnumRm;
    SPIRtrMgrInfo        spRm;
    HRESULT                hr = hrOK;
    CDWordArray            oldDWArray;
    CDWordArray            newDWArray;
    int                    cOld, cNew;
    int                    i, j;
    DWORD                dwTemp;

    Assert(pNewRouter);

    COM_PROTECT_TRY
    {
        // Need to sync up RtrMgrInfo
        
        //
        // The general algorithm is to build up two arrays
        // the first array contains the transport ids for this object
        // the second array contains the ids for the new object
        //
        // We then go through and remove all transports that are in
        // BOTH lists.
        //
        // This will leave us with the first array containing the
        // ids of the transports that need to be deleted from this object.
        //
        // The second array will have the list of ids of transports that
        // have to be added to this object from the second object.
        // ------------------------------------------------------------

        // Get the list of transports that are in the new object
        // ------------------------------------------------------------
        CORg( pNewRouter->EnumRtrMgr(&spEnumRm) );
        spEnumRm->Reset();
        while (spEnumRm->Next(1, &spRm, NULL) == hrOK)
        {
            newDWArray.Add(spRm->GetTransportId());
            spRm.Release();
        }

        spEnumRm.Release();
        spRm.Release();


        // Get the list of transports that are in this object
        // ------------------------------------------------------------
        CORg( this->EnumRtrMgr(&spEnumRm) );
        spEnumRm->Reset();
        while (spEnumRm->Next(1, &spRm, NULL) == hrOK)
        {
            oldDWArray.Add(spRm->GetTransportId());
            spRm.Release();
        }

        spEnumRm.Release();
        spRm.Release();


        // Ok now go through both lists, removing from the lists
        // transports that are in both lists.
        // ------------------------------------------------------------
        cOld = oldDWArray.GetSize();
        cNew = newDWArray.GetSize();
        for (i=cOld; --i>=0; )
        {
            dwTemp = oldDWArray.GetAt(i);
            for (j=cNew; --j>=0; )
            {
                if (dwTemp == newDWArray.GetAt(j))
                {
                    SPIRtrMgrInfo    spRm1;
                    SPIRtrMgrInfo    spRm2;

                    this->FindRtrMgr(dwTemp, &spRm1);
                    pNewRouter->FindRtrMgr(dwTemp, &spRm2);

                    Assert(spRm1);
                    Assert(spRm2);
                    spRm1->Merge(spRm2);
                                        
                    // remove both instances
                    // ------------------------------------------------
                    newDWArray.RemoveAt(j);
                    oldDWArray.RemoveAt(i);

                    // Need to update the size of the new array
                    // ------------------------------------------------
                    cNew--;
                    break;
                }
            }
        }

        // oldDWArray now contains the transports that should be
        // removed.
        // ------------------------------------------------------------
        if (oldDWArray.GetSize())
        {
            for (i=oldDWArray.GetSize(); --i>=0; )
            {
                DeleteRtrMgr(oldDWArray.GetAt(i), FALSE);
            }
        }

        // newDWArray contains the transports that should be added
        // ------------------------------------------------------------
        if (newDWArray.GetSize())
        {
            for (i=newDWArray.GetSize(); --i>= 0; )
            {
                hr = pNewRouter->FindRtrMgr(newDWArray.GetAt(i), &spRm);
                Assert(hr == hrOK);
                Assert(spRm);

                // Do a sanity check, make sure that this RtrMgr is
                // in the RtrMgrCB list
                // ----------------------------------------------------
                Assert(FindRtrMgrCB(spRm->GetTransportId()));

                
                // Add this router manager, to the router info.
                // ----------------------------------------------------
                if (spRm)
                {
                    AddRtrMgr(spRm, NULL, NULL);

                    // Remove this router manager from its previous router
                    // ------------------------------------------------
                    pNewRouter->ReleaseRtrMgr(spRm->GetTransportId());
                }

                spRm.Release();
            }
        }
        
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterInfo::MergeInterfaces
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT    RouterInfo::MergeInterfaces(IRouterInfo *pNewRouter)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    HRESULT                hr = hrOK;
    CStringArray        oldStArray;
    CStringArray        newStArray;
    int                    cOld, cNew;
    int                    i, j;
    CString                stTemp;

    Assert(pNewRouter);

    COM_PROTECT_TRY
    {
        // Need to sync up InterfaceInfo
        // ------------------------------------------------------------
        
        //
        // The general algorithm is to build up two arrays
        // the first array contains the protocol ids for this object
        // the second array contains the ids for the new object
        //
        // We then go through and remove all protocols that are in
        // BOTH lists.
        //
        // This will leave us with the first array containing the
        // ids of the protocols that need to be deleted from this object.
        //
        // The second array will have the list of ids of protocols that
        // have to be added to this object from the second object.
        // ------------------------------------------------------------

        // Get the list of protocols that are in the new object
        // ------------------------------------------------------------
        CORg( pNewRouter->EnumInterface(&spEnumIf) );
        spEnumIf->Reset();
        while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
        {
            newStArray.Add(spIf->GetId());
            spIf.Release();
        }

        spEnumIf.Release();
        spIf.Release();


        // Get the list of protocols that are in this object
        // ------------------------------------------------------------
        CORg( this->EnumInterface(&spEnumIf) );
        spEnumIf->Reset();
        while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
        {
            oldStArray.Add(spIf->GetId());
            spIf.Release();
        }

        spEnumIf.Release();
        spIf.Release();


        // Ok now go through both lists, removing from the lists
        // protocols that are in both lists.
        // ------------------------------------------------------------
        cOld = oldStArray.GetSize();
        cNew = newStArray.GetSize();
        for (i=cOld; --i>=0; )
        {
            stTemp = oldStArray.GetAt(i);
            for (j=cNew; --j>=0; )
            {
                if (stTemp == newStArray.GetAt(j))
                {
                    SPIInterfaceInfo    spIf1;
                    SPIInterfaceInfo    spIf2;

                    this->FindInterface(stTemp, &spIf1);
                    pNewRouter->FindInterface(stTemp, &spIf2);

                    Assert(spIf1);
                    Assert(spIf2);
                    spIf1->Merge(spIf2);
                                        
                    // remove both instances
                    // ------------------------------------------------
                    newStArray.RemoveAt(j);
                    oldStArray.RemoveAt(i);

                    // Need to update the size of the new array
                    // ------------------------------------------------
                    cNew--;
                    break;
                }
            }
        }

        // oldStArray now contains the protocols that should be
        // removed.
        // ------------------------------------------------------------
        if (oldStArray.GetSize())
        {
            for (i=oldStArray.GetSize(); --i>=0; )
            {
                RemoveInterfaceInternal(oldStArray.GetAt(i),
                                        FALSE /* fRemoveFromRouter */ );
            }
        }

        // newStArray contains the protocols that should be added
        // ------------------------------------------------------------
        if (newStArray.GetSize())
        {
            for (i=newStArray.GetSize(); --i>= 0; )
            {
                hr = pNewRouter->FindInterface(newStArray.GetAt(i), &spIf);
                Assert(hr == hrOK);
                Assert(spIf);

                // Do a sanity check, make sure that this Interface is
                // in the InterfaceCB list
                // This is only true if this is a LAN adapter.
                // Assert(FindInterfaceCB(spIf->GetId()));

                // We allow errors to not affect whether or not
                // the interface is added to the UI (this allows us
                // to stay in sync with the merged routerinfo).
                // ----------------------------------------------------
                if (spIf)
                {
                    hr = AddInterfaceInternal(spIf, FALSE, FALSE);

                    // Send the RmIf notifications
                    // ------------------------------------------------
                    if (FHrOK(hr))
                        NotifyRtrMgrInterfaceOfMove(spIf);
                    
                    // Remove this interface from its previous router
                    // ------------------------------------------------
                    pNewRouter->ReleaseInterface(spIf->GetId());
                }
                spIf.Release();
            }
        }
        
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::FindRtrMgrCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
SRtrMgrCB *    RouterInfo::FindRtrMgrCB(DWORD dwTransportId)
{
    POSITION    pos;
    SRtrMgrCB *    pSRmCB = NULL;

    pos = m_RmCBList.GetHeadPosition();

    while (pos)
    {
        pSRmCB = m_RmCBList.GetNext(pos);
        Assert(pSRmCB);
        if (pSRmCB->dwTransportId == dwTransportId)
            return pSRmCB;
    }
    return NULL;
}

/*!--------------------------------------------------------------------------
    RouterInfo::FindRtrMgrProtocolCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
SRtrMgrProtocolCB * RouterInfo::FindRtrMgrProtocolCB(DWORD dwTransportId, DWORD dwProtocolId)
{
    POSITION    pos;
    SRtrMgrProtocolCB *    pSRmProtCB = NULL;

    pos = m_RmProtCBList.GetHeadPosition();

    while (pos)
    {
        pSRmProtCB = m_RmProtCBList.GetNext(pos);
        Assert(pSRmProtCB);
        if ((pSRmProtCB->dwTransportId == dwTransportId) &&
            (pSRmProtCB->dwProtocolId == dwProtocolId))
            return pSRmProtCB;
    }
    return NULL;
}

/*!--------------------------------------------------------------------------
    RouterInfo::FindInterfaceCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
SInterfaceCB *    RouterInfo::FindInterfaceCB(LPCTSTR pszInterfaceId)
{
    POSITION    pos;
    SInterfaceCB *    pSIfCB = NULL;

    pos = m_IfCBList.GetHeadPosition();

    while (pos)
    {
        pSIfCB = m_IfCBList.GetNext(pos);
        Assert(pSIfCB);
        if (StriCmp(pSIfCB->stTitle, pszInterfaceId) == 0)
            return pSIfCB;
    }
    return NULL;
}


/*!--------------------------------------------------------------------------
    RouterInfo::Disconnect
        Removes connections made by this object.
    Author: KennT
 ---------------------------------------------------------------------------*/
void RouterInfo::Disconnect()
{
        if (m_bDisconnect)
            ::MprConfigServerDisconnect(m_hMachineConfig);
        
        m_bDisconnect = FALSE;
        m_hMachineConfig = NULL;
}

/*!--------------------------------------------------------------------------
    RouterInfo::DoDisconnect
        We are to disconnect our connections from the server.
        This means calling MprConfigServerDisconnect() on our
        connections.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;
    SPIEnumRtrMgrInfo    spEnumRm;
    SPIRtrMgrInfo        spRm;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo    spIf;

    COM_PROTECT_TRY
    {
        // Disconnect ourselves
        // ------------------------------------------------------------
        Disconnect();


        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);


        // Now tell all child objects to disconnect.
        // ------------------------------------------------------------
        HRESULT            hrIter = hrOK;

        
        // Tell each of the router-managers to disconnect.
        // ------------------------------------------------------------
        EnumRtrMgr(&spEnumRm);
        spEnumRm->Reset();
        while (spEnumRm->Next(1, &spRm, NULL) == hrOK)
        {
            spRm->DoDisconnect();
            spRm.Release();
        }


        // Tell each interface to disconnect.
        // ------------------------------------------------------------
        EnumInterface(&spEnumIf);
        spEnumIf->Reset();
        while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
        {
            spIf->DoDisconnect();
            spIf.Release();
        }
        
        
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterInfo::IsAdminInfoSet
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) RouterInfo::IsAdminInfoSet()
{
    return m_fIsAdminInfoSet;
}

STDMETHODIMP_(LPCOLESTR) RouterInfo::GetUserName()
{
    if (m_fIsAdminInfoSet)
        return (LPCOLESTR) m_stUserName;
    else
        return NULL;
}

STDMETHODIMP_(LPCOLESTR) RouterInfo::GetDomainName()
{
    if (m_fIsAdminInfoSet && !m_stDomain.IsEmpty())
        return (LPCOLESTR) m_stDomain;
    else
        return NULL;
}

STDMETHODIMP RouterInfo::GetUserPassword(BYTE *pPassword, int *pcPassword)
{
    HRESULT     hr = hrOK;

    if (pPassword == NULL)
    {
        Assert(pcPassword);
        *pcPassword = m_cPassword;
        return hr;
    }

    Assert(pPassword);
    Assert(pcPassword);

    COM_PROTECT_TRY
    {
        if (!m_fIsAdminInfoSet)
        {
            *pcPassword = 0;
        }
        else
        {
            CopyMemory(pPassword, m_pbPassword, m_cPassword);
            *pcPassword = m_cPassword;
        }
    }
    COM_PROTECT_CATCH;

    return hr;       
}

STDMETHODIMP RouterInfo::SetInfo(LPCOLESTR pszName,
                                 LPCOLESTR pszDomain,
                                 LPBYTE pPassword,
                                 int cPassword)
{
    HRESULT     hr = hrOK;

    Assert(pszName);

    COM_PROTECT_TRY
    {
        m_stUserName = pszName;
        m_stDomain = pszDomain;

        // Allocate space for the password
        delete m_pbPassword;
        m_pbPassword = NULL;
        m_cPassword = 0;
        
        if (cPassword)
        {
            m_pbPassword = new BYTE[cPassword];
            CopyMemory(m_pbPassword, pPassword, cPassword);
            m_cPassword = cPassword;
        }
        
        m_fIsAdminInfoSet = TRUE;
    }
    COM_PROTECT_CATCH;

    return hr;       
}





/*---------------------------------------------------------------------------
    RtrMgrInfo implementation
 ---------------------------------------------------------------------------*/


IMPLEMENT_WEAKREF_ADDREF_RELEASE(RtrMgrInfo);

IMPLEMENT_SIMPLE_QUERYINTERFACE(RtrMgrInfo, IRtrMgrInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrInfo)

RtrMgrInfo::RtrMgrInfo(DWORD dwTransportId,
                       LPCTSTR pszTransportName,
                       RouterInfo *pRouterInfo)
    : m_hMachineConfig(NULL),
    m_hTransport(NULL),
    m_bDisconnect(FALSE),
    m_dwFlags(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrInfo);
    
    m_cb.dwTransportId = dwTransportId;
    m_cb.stId = pszTransportName;

    // There is a case in the old code where pRouterInfo == NULL
    // It is in the CAddRouterManager dialog, however this is
    // not called from anywhere in the code.
    // ----------------------------------------------------------------
    Assert(pRouterInfo);
    
    m_pRouterInfoParent = static_cast<IRouterInfo *>(pRouterInfo);
    if (m_pRouterInfoParent)
        m_pRouterInfoParent->AddRef();

    InitializeCriticalSection(&m_critsec);
}

RtrMgrInfo::~RtrMgrInfo()
{
    Assert(m_pRouterInfoParent == NULL);
    Assert(m_AdviseList.IsEmpty());
    Destruct();
    DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrInfo);

    DeleteCriticalSection(&m_critsec);
}

void RtrMgrInfo::ReviveStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRouterInfoParent)
    {
        CONVERT_TO_STRONGREF(m_pRouterInfoParent);
    }
}

void RtrMgrInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRouterInfoParent)
    {
        CONVERT_TO_WEAKREF(m_pRouterInfoParent);
    }
    if (m_fDestruct)
        Destruct();
}

STDMETHODIMP RtrMgrInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRouterInfo *    pParent;
    
    m_fDestruct = TRUE;
    if (!m_fStrongRef)
    {
        // Release the parent pointer
        // ------------------------------------------------------------
        pParent = m_pRouterInfoParent;
        m_pRouterInfoParent = NULL;
        if (pParent)
            pParent->ReleaseWeakRef();

        // Release the data
        // ------------------------------------------------------------
        Unload();
    }
    return hrOK;
}

STDMETHODIMP_(DWORD) RtrMgrInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP RtrMgrInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::Load
        -
        Loads a CRmInfo structure from the registry
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::Load(LPCOLESTR         pszMachine,
                              HANDLE          hMachine,
                              HANDLE          hTransport
                             )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    SPIEnumRtrMgrCB    spEnumRmCB;
    IEnumRtrMgrCB *    pEnumRmCB;
    BOOL            bFound;
    RtrMgrCB        RmCBTemp;
    USES_CONVERSION;
        

    COM_PROTECT_TRY
    {
        // Discard any existing information
        // ------------------------------------------------------------
        Unload();
        
        m_stMachine = (pszMachine ? pszMachine : TEXT(""));

        // if 'hMachine' was not specified, connect to the config
        // on the specified machine
        // ------------------------------------------------------------
        Assert(m_hMachineConfig == NULL);
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );

        // if 'hTransport' was not specified, connect to the transport
        // ------------------------------------------------------------
        if (hTransport)
            m_hTransport = hTransport;
        else
        {
            CWRg( ::MprConfigTransportGetHandle(hMachine,
                                                GetTransportId(),
                                                &hTransport));
            m_hTransport = hTransport;
        }


        // Retrieve the title, dll-path, and config-dll from the Software key;
        // ------------------------------------------------------------
        Assert(m_pRouterInfoParent);
        CORg( m_pRouterInfoParent->EnumRtrMgrCB(&pEnumRmCB) );
        spEnumRmCB = pEnumRmCB;

        // Find the control-block for the router-manager being loaded
        // ------------------------------------------------------------
        bFound = FALSE;
        pEnumRmCB->Reset();
        while (pEnumRmCB->Next(1, &RmCBTemp, NULL) == hrOK)
        {            
            // Get the next control-block
            // --------------------------------------------------------
            if (RmCBTemp.dwTransportId != GetTransportId())
                continue;

            m_cb.stTitle = OLE2CT(RmCBTemp.szId);
            m_cb.stDLLPath= OLE2CT(RmCBTemp.szTitle);
            //m_cb.stConfigDLL = OLE2CT(RmCBTemp.szConfigDLL);

            bFound = TRUE;
            break;
        }

        if (!bFound)
            m_cb.stTitle = m_cb.stId;

        // Load the list of routing-protocols for this router-manager
        // ------------------------------------------------------------
        CWRg( LoadRtrMgrInfo(hMachine,
                             hTransport) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (!FHrSucceeded(hr))
        Unload();
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::Save
        -
        This function saves the information for a CRmInfo in the registry.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::Save(LPCOLESTR        pszMachine,
                              HANDLE          hMachine,
                              HANDLE          hTransport,
                              IInfoBase *        pGlobalInfo,
                              IInfoBase *     pClientInfo,
                              DWORD           dwDeleteProtocolId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    LPWSTR pwsz = NULL;
    WCHAR wszTransport[MAX_TRANSPORT_NAME_LEN+1];
    SPWSZ    spwszDll;
    
    COM_PROTECT_TRY
    {
        // If we are already connected (i.e. 'm_hMachineConfig' is non-NULL)
        // then the handle passed in is ignored.
        //
        // Otherwise, if 'hMachine' was not specified, connect to the config
        // on the specified machine
        // ------------------------------------------------------------
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );
        
        
        // If we are already connected (i.e. 'm_hTransport' is non-NULL)
        // then the handle passed in is ignored.
        //
        // Otherwise, if 'hTransport' wasn't passed in, try to get a handle
        // to the transport; if that fails, create the transport.
        // ------------------------------------------------------------
        if (m_hTransport)
            hTransport = m_hTransport;
        else if (hTransport)
            m_hTransport = hTransport;
        else
        {
            // Get a handle to the transport
            // --------------------------------------------------------
            dwErr = ::MprConfigTransportGetHandle(hMachine,
                                    m_cb.dwTransportId, &hTransport);            
            if (dwErr != NO_ERROR)
            {
                // We couldn't get a handle to the transport,
                // so now attempt to create it.
                //
                // Convert transport-name to Unicode
                // ----------------------------------------------------
                if (!m_cb.stId.GetLength())
                    pwsz = NULL;
                else
                    pwsz = StrCpyWFromT(wszTransport, m_cb.stId);
                
                // Convert the DLL path to Unicode
                // ----------------------------------------------------
                spwszDll = StrDupWFromT(m_cb.stDLLPath);
                                
                // Create the transport
                // ----------------------------------------------------
                CWRg( ::MprConfigTransportCreate(hMachine,
                                                GetTransportId(),
                                                pwsz,
                                                NULL,
                                                0,
                                                NULL,
                                                0,
                                                spwszDll,
                                                &hTransport
                                                ));
            }
        }
                
        // Now save the global info for the transport
        // ------------------------------------------------------------
        CWRg( SaveRtrMgrInfo(hMachine,
                             hTransport,
                             pGlobalInfo,
                             pClientInfo,
                             dwDeleteProtocolId) );
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::Unload
        Implementation of IRtrMgrInfo::Unload
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::Unload( )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    IRtrMgrProtocolInfo    * pRmProt;
    
    COM_PROTECT_TRY
    {
        while (!m_RmProtList.IsEmpty())
        {
            pRmProt = m_RmProtList.RemoveHead();
            pRmProt->Destruct();
            pRmProt->ReleaseWeakRef();
        }

        DoDisconnect();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::Delete
        -
        This function removes the information associated with a router-manager
        from the registry.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::Delete(LPCOLESTR    pszMachine,
                                HANDLE      hMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    HANDLE hTransport = NULL;
    
    COM_PROTECT_TRY
    {
        //
        // If already connected, the handle passed in is ignored;
        //
        // Otherwise, if 'hMachine' was not specified, connect to the config
        // on the specified machine
        //
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );

        //
        // Attempt to get a handle for the transport
        //
        CWRg( ::MprConfigTransportGetHandle(hMachine,
                                            m_cb.dwTransportId,
                                            &hTransport
                                           ) );

        //
        // Delete the transport
        //
        CWRg( ::MprConfigTransportDelete(hMachine, hTransport) );

        m_hTransport = NULL;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}
        
/*!--------------------------------------------------------------------------
    RtrMgrInfo::SetInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::SetInfoBase(IInfoBase*      pGlobalInfo,
                                     IInfoBase*      pClientInfo )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    MPR_SERVER_HANDLE    hRouter = NULL;
    BYTE* pGlobalInfoData = NULL, *pClientInfoData = NULL;
    DWORD dwGlobalInfoDataSize = 0, dwClientInfoDataSize = 0;
    DWORD    dwErr;

    COM_PROTECT_TRY
    {
        //
        // Format the router-manager's data as an opaque block
        //
        if (pGlobalInfo)
            CORg( pGlobalInfo->WriteTo(&pGlobalInfoData, &dwGlobalInfoDataSize) );

        //
        // Format the client-interface's data as an opaque block
        //
        if (pClientInfo)
            CORg( pClientInfo->WriteTo(&pClientInfoData, &dwClientInfoDataSize) );
        
        //
        // Connect to the router
        //
        CORg( ConnectRouter(GetMachineName(), &hRouter) );

        //
        // Set the new info for the router-manager
        //
        dwErr = MprAdminTransportSetInfo(hRouter,
                                         GetTransportId(),
                                         pGlobalInfoData,
                                         dwGlobalInfoDataSize,
                                         pClientInfoData,
                                         dwClientInfoDataSize
                                        );

        if ((dwErr == RPC_S_SERVER_UNAVAILABLE) ||
            (dwErr == RPC_S_UNKNOWN_IF))
            dwErr = NO_ERROR;
        CWRg( dwErr );
    
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    CoTaskMemFree( pGlobalInfoData );
    CoTaskMemFree( pClientInfoData );

    if (hRouter)
        ::MprAdminServerDisconnect(hRouter);
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::GetInfoBase(HANDLE        hMachine,
                                     HANDLE        hTransport,
                                     IInfoBase **ppGlobalInfo,
                                     IInfoBase **ppClientInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrOK;
    COM_PROTECT_TRY
    {
        CORg( TryToGetAllHandles(m_stMachine,
                                 &hMachine,
                                 &hTransport) );
        hr = ::LoadInfoBase(hMachine ? hMachine : m_hMachineConfig,
                            hTransport ? hTransport : m_hTransport,
                            ppGlobalInfo, ppClientInfo);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::Merge
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::Merge(IRtrMgrInfo *pNewRm)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    SPIEnumRtrMgrProtocolInfo    spEnumRmProt;
    SPIRtrMgrProtocolInfo        spRmProt;
    HRESULT                hr = hrOK;
    CDWordArray            oldDWArray;
    CDWordArray            newDWArray;
    int                    cOld, cNew;
    int                    i, j;
    DWORD                dwTemp;
    RtrMgrCB            rmCB;

    Assert(pNewRm);
    Assert(pNewRm->GetTransportId() == GetTransportId());

    COM_PROTECT_TRY
    {
        pNewRm->CopyRtrMgrCB(&rmCB);
        m_cb.LoadFrom(&rmCB);
        
        //
        // The general algorithm is to build up two arrays
        // the first array contains the protocol ids for this object
        // the second array contains the ids for the new object
        //
        // We then go through and remove all protocols that are in
        // BOTH lists.
        //
        // This will leave us with the first array containing the
        // ids of the protocols that need to be deleted from this object.
        //
        // The second array will have the list of ids of protocols that
        // have to be added to this object from the second object.
        //

        // Get the list of protocols that are in the new object
        CORg( pNewRm->EnumRtrMgrProtocol(&spEnumRmProt) );
        spEnumRmProt->Reset();
        while (spEnumRmProt->Next(1, &spRmProt, NULL) == hrOK)
        {
            newDWArray.Add(spRmProt->GetProtocolId());
            spRmProt.Release();
        }

        spEnumRmProt.Release();
        spRmProt.Release();


        // Get the list of protocols that are in this object
        CORg( this->EnumRtrMgrProtocol(&spEnumRmProt) );
        spEnumRmProt->Reset();
        while (spEnumRmProt->Next(1, &spRmProt, NULL) == hrOK)
        {
            oldDWArray.Add(spRmProt->GetProtocolId());
            spRmProt.Release();
        }

        spEnumRmProt.Release();
        spRmProt.Release();


        // Ok now go through both lists, removing from the lists
        // protocols that are in both lists.
        cOld = oldDWArray.GetSize();
        cNew = newDWArray.GetSize();
        for (i=cOld; --i>=0; )
        {
            dwTemp = oldDWArray.GetAt(i);
            for (j=cNew; --j>=0; )
            {
                if (dwTemp == newDWArray.GetAt(j))
                {
                    // remove both instances
                    newDWArray.RemoveAt(j);
                    oldDWArray.RemoveAt(i);

                    // Need to update the size of the new array
                    cNew--;
                    break;
                }
            }
        }

        // oldDWArray now contains the protocols that should be
        // removed.
        if (oldDWArray.GetSize())
        {
            for (i=oldDWArray.GetSize(); --i>=0; )
            {
                DeleteRtrMgrProtocol(oldDWArray.GetAt(i), FALSE);
            }
        }

        // newDWArray contains the protocols that should be added
        if (newDWArray.GetSize())
        {
            for (i=newDWArray.GetSize(); --i>= 0; )
            {
                hr = pNewRm->FindRtrMgrProtocol(
                                        newDWArray.GetAt(i), &spRmProt);
                Assert(hr == hrOK);

                if (spRmProt)
                {
                    AddRtrMgrProtocol(spRmProt, NULL, NULL);

                    // Remove this rmprot from its old router
                    // ------------------------------------------------
                    pNewRm->ReleaseRtrMgrProtocol(spRmProt->GetProtocolId());
                }

                
                spRmProt.Release();
            }
        }
        
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInfo::GetId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.stId;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::SetId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::SetId(LPCOLESTR pszId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.stId = pszId;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetTransportId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrInfo::GetTransportId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwTransportId;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInfo::GetTitle()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE
    // This assumes that we are native UNICODE
    // and that OLECHAR == WCHAR
    return m_cb.stTitle;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::CopyRtrMgrCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::CopyRtrMgrCB(RtrMgrCB *pRmCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.SaveTo(pRmCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}

    

/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
LPCOLESTR RtrMgrInfo::GetMachineName()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE
    // This assumes that we are native UNICODE and that
    // OLECHAR == WCHAR
    return m_stMachine;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::EnumRtrMgrProtocol
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::EnumRtrMgrProtocol(IEnumRtrMgrProtocolInfo ** ppEnumRmProt)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromRtrMgrProtocolList(&m_RmProtList, ppEnumRmProt);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::FindRtrMgrProtocol
        S_OK is returned if a RtrMgrInfo is found.
        S_FALSE is returned if a RtrMgrInfo was NOT found.
        error codes returned otherwise.
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::FindRtrMgrProtocol(DWORD dwProtocolId,
                                            IRtrMgrProtocolInfo **ppRmProtInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIRtrMgrProtocolInfo    spRmProt;
    
    COM_PROTECT_TRY
    {
        if (ppRmProtInfo)
            *ppRmProtInfo = NULL;
        
        // Look through the list of rtr mgrs for the one that matches
        pos = m_RmProtList.GetHeadPosition();
        while (pos)
        {
            spRmProt.Set(m_RmProtList.GetNext(pos));
            Assert(spRmProt);
            if (spRmProt->GetProtocolId() == dwProtocolId)
            {
                hr = hrOK;
                if (ppRmProtInfo)
                {
                    // The spRmProt::Set, does a strong reference
                    // so we don't need to convert to a strong reference
                    *ppRmProtInfo = spRmProt.Transfer();
                }
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}
    
/*!--------------------------------------------------------------------------
    RtrMgrInfo::AddRtrMgrProtocol
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::AddRtrMgrProtocol(IRtrMgrProtocolInfo *pInfo,
                                           IInfoBase * pGlobalInfo,
                                           IInfoBase * pClientInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    Assert(pInfo);
    
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        //
        // Fail if there is a duplicate
        //
        if (FHrOK(FindRtrMgrProtocol(pInfo->GetProtocolId(), NULL)))
            CORg(E_INVALIDARG);

        //
        // Save the router-manager's data
        //
        if (pGlobalInfo || pClientInfo)
        {
            CORg( Save(GetMachineName(),
                       m_hMachineConfig,
                       m_hTransport,
                       pGlobalInfo,
                       pClientInfo,
                       0) );
        }
        
        //
        // Add the routing-protocol to the list
        //
        m_RmProtList.AddTail(pInfo);
        pInfo->AddWeakRef();
        pInfo->SetParentRtrMgrInfo(this);

        m_AdviseList.NotifyChange(ROUTER_CHILD_ADD, ROUTER_OBJ_RmProt, 0);
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::DeleteRtrMgrProtocol
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::DeleteRtrMgrProtocol( DWORD dwProtocolId, BOOL fRemove )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    SPIRtrMgrProtocolInfo    spRmProt;
    POSITION            pos, posRmProt;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIEnumRtrMgrInterfaceInfo    spEnumRmIf;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo    spRmIf;
    
    COM_PROTECT_TRY
    {

        //
        // Find the routing-protocol to be deleted
        //
        pos = m_RmProtList.GetHeadPosition();
        while (pos)
        {
            posRmProt = pos;
            spRmProt.Set( m_RmProtList.GetNext(pos) );
            Assert(spRmProt);

            if (spRmProt->GetProtocolId() == dwProtocolId)
                break;
            spRmProt.Release();
        }

        if (!spRmProt)
            CORg( E_INVALIDARG );

        // We should also go through and remove the protocols
        // from any interfaces that use the protocols
        if (m_pRouterInfoParent)
        {
            // Ask the parent for its list of interfaces
            m_pRouterInfoParent->EnumInterface(&spEnumIf);

            for (;spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
            {
                // Now enumerate through all of the RtrMgrs on this interface
                spEnumRmIf.Release();
                spRmIf.Release();
                
                spIf->EnumRtrMgrInterface(&spEnumRmIf);
                for (;spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK;
                     spRmIf.Release())
                {
                    if (spRmIf->GetTransportId() == GetTransportId())
                    {
                        // Call this on all interfaces, it should just
                        // fail if the protocol is not on that interface
                        spRmIf->DeleteRtrMgrProtocolInterface(dwProtocolId,
                            fRemove);
                        break;
                    }
                }
            }
        }
        
        //
        // save the updated information, removing any block
        // belonging to the deleted routing-protocol
        //
        if (fRemove)
            CORg( Save(GetMachineName(),
                       m_hMachineConfig,
                       m_hTransport,
                       NULL,
                       NULL,
                       dwProtocolId) );

        //
        // remove the protocol from our list
        //
        spRmProt->Destruct();
        spRmProt->ReleaseWeakRef();
//        spRmProt.Transfer();
        m_RmProtList.RemoveAt(posRmProt);

        m_AdviseList.NotifyChange(ROUTER_CHILD_DELETE, ROUTER_OBJ_RmProt, 0);
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::ReleaseRtrMgrProtocol
        This function will release the AddRef() that this object has
        on the child.  This allows us to transfer child objects from
        one router to another.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::ReleaseRtrMgrProtocol( DWORD dwProtocolId )
{
    HRESULT     hr = hrOK;
    POSITION    pos, posRmProt;
    SPIRtrMgrProtocolInfo    spRmProt;
    
    COM_PROTECT_TRY
    {
        pos = m_RmProtList.GetHeadPosition();
        while (pos)
        {
            // Save the position (so that we can delete it)
            posRmProt = pos;
            spRmProt.Set( m_RmProtList.GetNext(pos) );

            if (spRmProt &&
                (spRmProt->GetProtocolId() == dwProtocolId))
            {
                // When releasing, we need to disconnect (since the
                // main handle is controlled by the router info).
                spRmProt->DoDisconnect();
        
                spRmProt->ReleaseWeakRef();
                spRmProt.Release();
                
                // release this node from the list
                m_RmProtList.RemoveAt(posRmProt);
                break;
            }
            spRmProt.Release();
        }        
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RtrMgrInfo::RtrAdvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::RtrAdvise(IRtrAdviseSink *pRtrAdviseSink,
                                   LONG_PTR *pulConnection,
                                   LPARAM lUserParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}



/*!--------------------------------------------------------------------------
    RtrMgrInfo::RtrNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::RtrUnadvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::RtrUnadvise(LONG_PTR ulConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(ulConnection);
}


    
/*!--------------------------------------------------------------------------
    RtrMgrInfo::LoadRtrMgrInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInfo::LoadRtrMgrInfo(HANDLE    hMachine,
                                   HANDLE    hTransport)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT            hr = hrOK;
    SPIInfoBase        spGlobalInfo;
    SPIEnumInfoBlock    spEnumInfoBlock;
    SPIEnumRtrMgrProtocolCB    spEnumRmProtCB;
    InfoBlock *        pBlock;
    RtrMgrProtocolCB    RmProtCB;
    RtrMgrProtocolInfo *pRmProt = NULL;

    //
    // If reloading, always load the global info, whether or not
    // the caller has requested that it be loaded, since it will be needed
    // to build the list of installed protocols.
    //

    //$ Review: kennt, what do we do with an error? This case was not
    // checked previously.
    GetInfoBase(hMachine, hTransport, &spGlobalInfo, NULL);

    //
    // We are reloading, so we need to rebuild the list of protocols.
    // Get a list of the installed routing-protocols;
    //
    CORg( m_pRouterInfoParent->EnumRtrMgrProtocolCB(&spEnumRmProtCB) );

    //
    // Go through the list of blocks in the global info
    // constructing a CRmProtInfo for each one that corresponds
    // to a routing-protocol
    //

    CORg( spGlobalInfo->QueryBlockList(&spEnumInfoBlock) );

    spEnumInfoBlock->Reset();

    while (spEnumInfoBlock->Next(1, &pBlock, NULL) == hrOK)
    {
        //
        // When a routing protocol is removed, its block is left in place,
        // but with zero-length data.
        // We skip such blocks since they don't represent installed protocols.
        //
        if (!pBlock->dwSize)
            continue;

        //
        // Try to find a routing protocol whose protocol-ID
        // is the same as this block's type
        //

        spEnumRmProtCB->Reset();

        while (spEnumRmProtCB->Next(1, &RmProtCB, NULL) == hrOK)
        {
            //
            // If this isn't the protocol's control block, continue
            //
            if (RmProtCB.dwProtocolId != pBlock->dwType)
                continue;

            //
            // This is the control block, so construct a new CRmProtInfo
            //
            pRmProt = new RtrMgrProtocolInfo(RmProtCB.dwProtocolId,
                                             RmProtCB.szId,
                                             GetTransportId(),
                                             m_cb.stId,
                                             this);
            Assert(pRmProt);

            pRmProt->SetCB(&RmProtCB);

            //
            // Add the new protocol to our list
            //
            m_RmProtList.AddTail(pRmProt);
            CONVERT_TO_WEAKREF(pRmProt);
            pRmProt = NULL;

            break;
        }
    }

Error:
    if (pRmProt)
        pRmProt->Release();
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::SaveRtrMgrInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInfo::SaveRtrMgrInfo(HANDLE hMachine,
                                   HANDLE hTransport,
                                   IInfoBase *pGlobalInfo,
                                   IInfoBase *pClientInfo,
                                   DWORD dwDeleteProtocolId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrOK;
    SPIInfoBase    spGlobalInfoTemp;
    SPIInfoBase    spClientInfoTemp;
    DWORD dwGlobalBytesSize, dwClientBytesSize;
    LPBYTE pGlobalBytes = NULL, pClientBytes = NULL;

    COM_PROTECT_TRY
    {
        //
        // If asked to delete a protocol, delete it now
        //
        if (dwDeleteProtocolId)
        {
            //
            // If either global-info or client info was not given
            // load the unspecified parameters so that they can be updated
            // after the protocol to be deleted has been removed
            //
            if (!pGlobalInfo || !pClientInfo)
            {

                GetInfoBase(hMachine, hTransport,
                            pGlobalInfo ? NULL : &spGlobalInfoTemp,
                            pClientInfo ? NULL : &spClientInfoTemp
                           );
                if (pGlobalInfo == NULL)
                    pGlobalInfo = spGlobalInfoTemp;
                if (pClientInfo == NULL)
                    pClientInfo = spClientInfoTemp;                
            }

            //
            // Now remove the protocol specified
            //
            pGlobalInfo->SetData(dwDeleteProtocolId, 0, NULL, 0, 0);
            pClientInfo->SetData(dwDeleteProtocolId, 0, NULL, 0, 0);
        }

        //
        // Now update the information in the registry
        // Convert the global-info to raw bytes
        //
        if (pGlobalInfo)
            CORg( pGlobalInfo->WriteTo(&pGlobalBytes, &dwGlobalBytesSize) );

        //
        // Now convert the client-info to raw bytes
        //
        if (pClientInfo)
            CORg( pClientInfo->WriteTo(&pClientBytes, &dwClientBytesSize) );

        //
        // Save the information to the persistent store
        //
        CWRg( ::MprConfigTransportSetInfo(hMachine,
                                          hTransport,
                                          pGlobalBytes,
                                          dwGlobalBytesSize,
                                          pClientBytes,
                                          dwClientBytesSize,
                                          NULL
                                         ) );
        
        //
        // Finally, update the info of the running router-manager if possible
        //
        CORg( SetInfoBase(pGlobalInfo, pClientInfo) );


        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    CoTaskMemFree( pGlobalBytes );
    CoTaskMemFree( pClientBytes );
    
    return hrOK;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::TryToConnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInfo::TryToConnect(LPCWSTR pswzMachine, HANDLE *phMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    
    if (m_hMachineConfig)
        *phMachine = m_hMachineConfig;
    else if (*phMachine)
    {
        m_hMachineConfig = *phMachine;
        m_bDisconnect = FALSE;
    }
    else
    {
        //$ Review: kennt, this function does not take a LPCWSTR,
        // is this a mistake or does it modify the parameters?
        CWRg( ::MprConfigServerConnect((LPWSTR) pswzMachine, phMachine) );
        m_hMachineConfig = *phMachine;
        m_bDisconnect = TRUE;
    }

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::GetParentRouterInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInfo::GetParentRouterInfo(IRouterInfo **ppParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    *ppParent = m_pRouterInfoParent;
    if (*ppParent)
        (*ppParent)->AddRef();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    RtrMgrInfo::SetParentRouterInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInfo::SetParentRouterInfo(IRouterInfo *pParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRouterInfo *    pTemp;
    
    pTemp = m_pRouterInfoParent;
    m_pRouterInfoParent = NULL;
    
    if (m_fStrongRef)
    {
        if (pTemp)
            pTemp->Release();
        if (pParent)
            pParent->AddRef();
    }
    else
    {
        if (pTemp)
            pTemp->ReleaseWeakRef();
        if (pParent)
            pParent->AddWeakRef();
    }
    m_pRouterInfoParent = pParent;

    return hrOK;
}


/*!--------------------------------------------------------------------------
    RtrMgrInfo::Disconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrMgrInfo::Disconnect()
{
    if (m_bDisconnect && m_hMachineConfig)
        ::MprConfigServerDisconnect(m_hMachineConfig);
    
    m_bDisconnect = FALSE;
    m_hMachineConfig = NULL;
    m_hTransport = NULL;
}
    


/*!--------------------------------------------------------------------------
    RtrMgrInfo::DoDisconnect
        Removes the connections held by this object.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;
    SPIEnumRtrMgrProtocolInfo    spEnumRmProt;
    SPIRtrMgrProtocolInfo        spRmProt;

    COM_PROTECT_TRY
    {

        // Disconnect our data.
        // ------------------------------------------------------------
        Disconnect();

        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);

        // Now tell all child objects to disconnect.
        // ------------------------------------------------------------
        HRESULT            hrIter = hrOK;

        EnumRtrMgrProtocol(&spEnumRmProt);
        spEnumRmProt->Reset();
        while (spEnumRmProt->Next(1, &spRmProt, NULL) == hrOK)
        {
            spRmProt->DoDisconnect();
            spRmProt.Release();
        }
        
    }
    COM_PROTECT_CATCH;
    return hr;
}


HRESULT RtrMgrInfo::TryToGetAllHandles(LPCOLESTR pszMachine,
                                       HANDLE *phMachine,
                                       HANDLE *phTransport)
{
    HRESULT     hr = hrOK;


    Assert(phMachine);
    Assert(phTransport);
    
    //
    // If already loaded, the handle passed in is ignored.
    //
    // Otherwise, if 'hMachine' was not specified, connect to the config
    // on the specified machine
    //
    CORg( TryToConnect(pszMachine, phMachine) );
        
    //
    // Get a handle to the interface-transport
    //

    //
    // If 'hIfTransport' was not specified, connect
    //
    if (phTransport)
    {
        if (m_hTransport)
            *phTransport = m_hTransport;
        else if (*phTransport)
            m_hTransport = *phTransport;
        else
        {
            //
            // Get a handle to the interface-transport
            //
            CWRg( ::MprConfigTransportGetHandle(
                                                *phMachine,
                                                GetTransportId(),
                                                phTransport
                                               ) );
            m_hTransport = *phTransport;
        }
    }

Error:
    return hr;
}






/*---------------------------------------------------------------------------
    RtrMgrProtocolInfo Implementation
 ---------------------------------------------------------------------------*/

TFSCORE_API(HRESULT)    CreateRtrMgrProtocolInfo(
                            IRtrMgrProtocolInfo **ppRmProtInfo,
                            const RtrMgrProtocolCB *pRmProtCB)
{
    Assert(ppRmProtInfo);
    Assert(pRmProtCB);

    HRESULT    hr = hrOK;
    IRtrMgrProtocolInfo *    pRmProt = NULL;
    RtrMgrProtocolInfo *    prmp;
    USES_CONVERSION;

    COM_PROTECT_TRY
    {
        prmp = new RtrMgrProtocolInfo(pRmProtCB->dwProtocolId,
                                      W2CT(pRmProtCB->szId),
                                      pRmProtCB->dwTransportId,
                                      W2CT(pRmProtCB->szRtrMgrId),
                                      NULL);
        
        prmp->SetCB(pRmProtCB);
        *ppRmProtInfo = prmp;
    }
    COM_PROTECT_CATCH;

    return hr;
}



IMPLEMENT_WEAKREF_ADDREF_RELEASE(RtrMgrProtocolInfo);

IMPLEMENT_SIMPLE_QUERYINTERFACE(RtrMgrProtocolInfo, IRtrMgrProtocolInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrProtocolInfo)

RtrMgrProtocolInfo::RtrMgrProtocolInfo(DWORD dwProtocolId,
                                       LPCTSTR         lpszId,
                                       DWORD           dwTransportId,
                                       LPCTSTR         lpszRm,
                                       RtrMgrInfo *        pRmInfo)
    : m_dwFlags(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrProtocolInfo);
    
    m_cb.dwProtocolId = dwProtocolId;
    m_cb.stId = lpszId;
    m_cb.dwTransportId = dwTransportId;
    m_cb.stRtrMgrId = lpszRm;

    m_pRtrMgrInfoParent = pRmInfo;
    if (m_pRtrMgrInfoParent)
        m_pRtrMgrInfoParent->AddRef();

    InitializeCriticalSection(&m_critsec);
}

RtrMgrProtocolInfo::~RtrMgrProtocolInfo()
{
    Assert(m_pRtrMgrInfoParent == NULL);
    Destruct();
    DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrProtocolInfo);
    DeleteCriticalSection(&m_critsec);
}

void RtrMgrProtocolInfo::ReviveStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRtrMgrInfoParent)
    {
        CONVERT_TO_STRONGREF(m_pRtrMgrInfoParent);
    }
}

void RtrMgrProtocolInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRtrMgrInfoParent)
    {
        CONVERT_TO_WEAKREF(m_pRtrMgrInfoParent);
    }
    if (m_fDestruct)
        Destruct();
}

STDMETHODIMP RtrMgrProtocolInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRtrMgrInfo *    pParent;
    
    m_fDestruct = TRUE;
    if (!m_fStrongRef)
    {
        // Release the parent pointer
        pParent = m_pRtrMgrInfoParent;
        m_pRtrMgrInfoParent = NULL;
        if (pParent)
            pParent->ReleaseWeakRef();

        // release any data        
    }
    return hrOK;
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP RtrMgrProtocolInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::GetProtocolId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrProtocolInfo::GetProtocolId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwProtocolId;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::GetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInfo::GetTitle()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes OLECHAR == WCHAR and that
    // we are native UNICODE
    return m_cb.stTitle;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::GetTransportId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrProtocolInfo::GetTransportId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwTransportId;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::CopyCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::CopyCB(RtrMgrProtocolCB *pRmProtCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.SaveTo(pRmProtCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::SetCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT    RtrMgrProtocolInfo::SetCB(const RtrMgrProtocolCB *pcb)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    m_cb.LoadFrom(pcb);
    return hrOK;
}


/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::GetParentRtrMgrInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::GetParentRtrMgrInfo(IRtrMgrInfo **ppParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    *ppParent = m_pRtrMgrInfoParent;
    if (*ppParent)
        (*ppParent)->AddRef();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::SetParentRtrMgrInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::SetParentRtrMgrInfo(IRtrMgrInfo *pParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRtrMgrInfo *    pTemp;
    
    pTemp = m_pRtrMgrInfoParent;
    m_pRtrMgrInfoParent = NULL;
    
    if (m_fStrongRef)
    {
        if (pTemp)
            pTemp->Release();
        if (pParent)
            pParent->AddRef();
    }
    else
    {
        if (pTemp)
            pTemp->ReleaseWeakRef();
        if (pParent)
            pParent->AddWeakRef();
    }
    m_pRtrMgrInfoParent = pParent;

    return hrOK;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::RtrAdvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::RtrAdvise(IRtrAdviseSink *pRtrAdviseSink,
                                           LONG_PTR *pulConnection,
                                           LPARAM lUserParam)
{
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    RtrCriticalSection    rtrCritSec(&m_critsec);
    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::RtrNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::RtrUnadvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::RtrUnadvise(LONG_PTR ulConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(ulConnection);
}


/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::Disconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrMgrProtocolInfo::Disconnect()
{
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInfo::DoDisconnect
        Implementation of IRtrMgrProtocolInfo::DoDisconnect
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;

    COM_PROTECT_TRY
    {
        // Disconnect our data.
        // ------------------------------------------------------------
        Disconnect();

        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);
    }
    COM_PROTECT_CATCH;
    return hr;
}






/*---------------------------------------------------------------------------
    InterfaceInfo Implementation
 ---------------------------------------------------------------------------*/

TFSCORE_API(HRESULT) CreateInterfaceInfo(IInterfaceInfo **ppInterfaceInfo,
                                         LPCWSTR pswzInterfaceId,
                                         DWORD dwInterfaceType)
{
    Assert(ppInterfaceInfo);
    
    HRESULT    hr = hrOK;
    InterfaceInfo *    pInterfaceInfo = NULL;
    USES_CONVERSION;
    
    COM_PROTECT_TRY
    {
        pInterfaceInfo = new InterfaceInfo(W2CT(pswzInterfaceId),
                                           dwInterfaceType,
                                           TRUE,
                                           InterfaceCB_BindToIp | InterfaceCB_BindToIpx,
                                           NULL);
        *ppInterfaceInfo = pInterfaceInfo;
    }
    COM_PROTECT_CATCH;

    return hr;
}

IMPLEMENT_WEAKREF_ADDREF_RELEASE(InterfaceInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(InterfaceInfo, IInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(InterfaceInfo)

InterfaceInfo::InterfaceInfo(LPCTSTR pszId,
                             DWORD dwIfType,
                             BOOL bEnable,
                             DWORD dwBindFlags,
                             RouterInfo *pRouterInfo)
    : m_hMachineConfig(NULL),
    m_hInterface(NULL),
    m_bDisconnect(FALSE),
    m_dwFlags(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(InterfaceInfo);

    m_cb.stId = pszId;
    m_cb.dwIfType = dwIfType;
    m_cb.bEnable = bEnable;
    m_cb.dwBindFlags = dwBindFlags;

    m_pRouterInfoParent = pRouterInfo;
    if (m_pRouterInfoParent)
        m_pRouterInfoParent->AddRef();

    InitializeCriticalSection(&m_critsec);
}

InterfaceInfo::~InterfaceInfo()
{
    Assert(m_pRouterInfoParent == NULL);
    Destruct();
    DEBUG_DECREMENT_INSTANCE_COUNTER(InterfaceInfo);
    DeleteCriticalSection(&m_critsec);
}

void InterfaceInfo::ReviveStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRouterInfoParent)
    {
        CONVERT_TO_STRONGREF(m_pRouterInfoParent);
    }
}

void InterfaceInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRouterInfoParent)
    {
        CONVERT_TO_WEAKREF(m_pRouterInfoParent);
    }
    if (m_fDestruct)
        Destruct();
}

STDMETHODIMP InterfaceInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRouterInfo *    pParent;

    m_fDestruct = TRUE;
    if (!m_fStrongRef)
    {
        pParent = m_pRouterInfoParent;
        m_pRouterInfoParent = NULL;
        if (pParent)
            pParent->ReleaseWeakRef();

        // release any data
        Unload();
    }
    return hrOK;
}

STDMETHODIMP_(DWORD) InterfaceInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP InterfaceInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::Load
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::Load(LPCOLESTR   pszMachine,
                                 HANDLE      hMachine,
                                 HANDLE      hInterface)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwSize = 0;
    MPR_INTERFACE_0 *pinterface = NULL;
    SPIEnumInterfaceCB    spEnumInterfaceCB;
    InterfaceCB        ifCB;
    SPSZ            spszTitle;
    CString            stTitle;
    DWORD            dwIfType;
    BOOL            bFound = FALSE;

    COM_PROTECT_TRY
    {
        //
        // Discard any existing information
        //
        Unload();

        m_stMachine = OLE2CT(pszMachine ? pszMachine : TEXT(""));

        //
        // If 'hMachine' was not specified, connect to the config
        // on the specified machine
        //
        Assert(m_hMachineConfig == NULL);
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );

        //
        // If 'hInterface' was not specified, connect to the interface
        //
        CORg( TryToGetIfHandle(hMachine, OLE2CW(GetId()), &hInterface) );

        //
        // Get information for the interface
        //        
        CWRg( ::MprConfigInterfaceGetInfo(
                                          hMachine,
                                          hInterface,
                                          0,
                                          (LPBYTE*)&pinterface,
                                          &dwSize
                                         ) );

        // Windows NT Bug ?
        // If this interface is a removed adapter, do not show it.
        // This check needs to be made only for MprConfigInterfacEnum
        // ------------------------------------------------------------
        if ((pinterface->dwConnectionState == ROUTER_IF_STATE_UNREACHABLE) &&
            (pinterface->fUnReachabilityReasons == MPR_INTERFACE_NO_DEVICE))
        {
            CORg( E_INVALIDARG );
        }
            
        //
        // Save the interface type and enabled/disabled status
        //
        m_cb.dwIfType = (DWORD)pinterface->dwIfType;
        m_cb.bEnable  = pinterface->fEnabled;

        ::MprConfigBufferFree(pinterface);

        if (m_pRouterInfoParent)
        {
            //
            // The caller has supplied a list of LAN adapters ('pifcbList'),
            // or this object is contained in a 'CRouterInfo' which will have
            // already loaded the LAN interface control-blocks;
            // search through the list to find our title,
            //
            m_pRouterInfoParent->EnumInterfaceCB(&spEnumInterfaceCB);

            spEnumInterfaceCB->Reset();
            while (spEnumInterfaceCB->Next(1, &ifCB, NULL) == hrOK)
            {
                if (StriCmp(ifCB.szId, OLE2CT(GetId())) == 0)
                {
                    m_cb.stTitle = ifCB.szTitle;
                    m_cb.stDeviceName = ifCB.szDevice;
                    bFound = TRUE;
                    break;
                }
                else
                {
                    // Windows NT bug 103770
                    // Need to check to see if the pcb->sID is a prefix
                    // of the Id string (if so it may be the IPX case
                    // so use that ID).
                    stTitle = GetId();
                    if (stTitle.Find((LPCTSTR) ifCB.szId) == 0)
                    {
                        // Need to check to see that the extension
                        // is what we think it is.
                        LPCTSTR    pszExt = ((LPCTSTR) stTitle +
                                          lstrlen(ifCB.szId));

                        if ((*pszExt == 0) ||
                            (lstrcmpi(pszExt, c_szEthernetSNAP) == 0) ||
                            (lstrcmpi(pszExt, c_szEthernetII) == 0) ||
                            (lstrcmpi(pszExt, c_szEthernet8022) == 0) ||
                            (lstrcmpi(pszExt, c_szEthernet8023) == 0))
                        {
                            m_cb.stTitle = ifCB.szTitle;
                            m_cb.stTitle += _T(" (");
                            m_cb.stTitle += pszExt + 1; // add 1 to skip over /
                            m_cb.stTitle += _T(")");
                            bFound = TRUE;
                            break;
                        }
                    }
                }
            }
        }
        
        if (!bFound)
        {
            //
            // Read the title directly from the registry
            //
            hr = InterfaceInfo::FindInterfaceTitle(OLE2CT(GetMachineName()),
                                       OLE2CT(GetId()),
                                       &spszTitle);
            if (FHrOK(hr))
                m_cb.stTitle = spszTitle;
            else
                m_cb.stTitle = OLE2CT(GetId());
            hr = hrOK;
        }
        
        //
        // Load the list of router-managers on this interface
        //
        CORg( LoadRtrMgrInterfaceList() );

        COM_PROTECT_ERROR_LABEL;

    }
    COM_PROTECT_CATCH;

    if (!FHrSucceeded(hr))
        Unload();
    
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::Save
        -
        Saves the changes to a CInterfaceInfo to the registry.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::Save(LPCOLESTR     pszMachine,
                                 HANDLE      hMachine,
                                 HANDLE      hInterface)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    MPR_INTERFACE_0 mprInterface;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
    MPR_SERVER_HANDLE hrouter = NULL;

#ifdef KSL_IPINIP    
    MPR_IPINIP_INTERFACE_0  mprTunnelInterface;
#endif //KSL_IPINIP


    COM_PROTECT_TRY
    {
        //
        // If already connected, the handle passed in is ignored;
        //
        // Otherwise, if 'hMachine' was not specified, connect to the config
        // on the specified machine
        //
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );

        //
        // Convert the interface name to Unicode
        //
        StrCpyWFromOle(wszInterface, GetId());

        ZeroMemory(&mprInterface, sizeof(mprInterface));

        StrCpyW(mprInterface.wszInterfaceName, wszInterface);
        mprInterface.dwIfType = (ROUTER_INTERFACE_TYPE) GetInterfaceType();
        mprInterface.fEnabled = IsInterfaceEnabled();

        //
        // If already connected, use the existing interface-handle.
        //
        // Otherwise, if the interface-handle wasn't passed in,
        // try to get a handle to the interface; if that fails,
        // create the interface.
        //
        hr = TryToGetIfHandle(hMachine, wszInterface, &hInterface);
        if (!FHrSucceeded(hr))
        {

#ifdef KSL_IPINIP
            if (GetInterfaceType() == ROUTER_IF_TYPE_TUNNEL1)
            {
                //
                // If we are creating a tunnel, we need to register
                // the GUID-to-friendly name mapping.
                //
                ::ZeroMemory(&mprTunnelInterface,
                             sizeof(mprTunnelInterface));
                StrnCpyW(mprTunnelInterface.wszFriendlyName,
                         GetTitle(),
                         MAX_INTERFACE_NAME_LEN);
                CORg( CLSIDFromString(wszInterface,
                                      &(mprTunnelInterface.Guid)) );
                
                CWRg( MprSetupIpInIpInterfaceFriendlyNameCreate(
                    (LPOLESTR) GetMachineName(),
                    &mprTunnelInterface
                    ) );

                // The mapping was created.
                // If we get an error, we need to delete the mapping.
                fIpInIpMapping = TRUE;
            }
#endif //KSL_IPINIP            
            //
            // We couldn't get a handle to the interface,
            // so now attempt to create it.
            //
            CWRg( ::MprConfigInterfaceCreate(
                                             hMachine,
                                             0,
                                             (LPBYTE)&mprInterface,
                                             &hInterface
                                            ) );
            m_hInterface = hInterface;            
        }

        //
        // Save the current settings for the interface.
        //
        CWRg( ::MprConfigInterfaceSetInfo(
                    hMachine,
                    hInterface,
                    0,
                    (LPBYTE)&mprInterface
                    ) );
        
        //
        // Now notify the router-service of the new interface
        //
        
 
        //
        // Attempt to connect to the router-service
        //
        //$ Review: kennt, what happens if the call to ConnectRouter()
        // fails, we don't have an error code
        if (ConnectRouter(OLE2CT(GetMachineName()), (HANDLE*)&hrouter) == NO_ERROR)
        {
            //
            // The router is running; attempt to get a handle to the interface
            //            
            dwErr = ::MprAdminInterfaceGetHandle(hrouter,
                                wszInterface,
                                &hInterface,
                                FALSE
                                );
            
            if (dwErr != NO_ERROR)
            {    
                //
                // We couldn't get a handle to the interface,
                // so try creating it.
                //                
                dwErr = ::MprAdminInterfaceCreate(
                                hrouter,
                                0,
                                (BYTE*)&mprInterface,
                                &hInterface
                                );
            }
            else
            {    
                //
                // Save the current settings for the interface.
                //                
                dwErr = ::MprAdminInterfaceSetInfo(hrouter,
                                                hInterface,
                                                0,
                                                (LPBYTE)&mprInterface
                                                );
            }
            
            ::MprAdminServerDisconnect(hrouter);
            
            if ((dwErr == RPC_S_SERVER_UNAVAILABLE) ||
                (dwErr == RPC_S_UNKNOWN_IF))
                dwErr = NO_ERROR;

            if (dwErr != NO_ERROR)
                hr = HRESULT_FROM_WIN32(dwErr);
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;


#ifdef KSL_IPINIP
    if (!FHrSucceeded(hr) && fIpInIpMapping)
    {
        // Assume : that the the mprTunnelInterface.Guid was
        // initialized, since to reach there they would have had
        // to gone through the CLSIDFromString() call.
        MprSetupIpInIpInterfaceFriendlyNameDelete((LPOLESTR) GetMachineName(),
            &(mprTunnelInterface.Guid)
            );
    }
#endif //KSL_IPINIP

    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::Delete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::Delete(LPCOLESTR     pszMachine,
                                   HANDLE      hMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    HANDLE hInterface;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
    MPR_SERVER_HANDLE hrouter = NULL;

#ifdef KSL_IPINIP
    GUID    guidTunnel;
#endif //KSL_IPINIP


    COM_PROTECT_TRY
    {
        // If already connected, the handle passed in is ignored;
        //
        // Otherwise, if 'hMachine' was not specified, connect to the config
        // on the specified machine
        // ------------------------------------------------------------
        CORg( TryToConnect(OLE2CW(pszMachine), &hMachine) );

        StrCpyWFromOle(wszInterface, GetId());

        // Try to get a handle to the interface
        // ------------------------------------------------------------
        CWRg( ::MprConfigInterfaceGetHandle(hMachine,
                                            wszInterface,
                                            &hInterface
                                           ) );
        // Delete the interface
        // ------------------------------------------------------------
        dwErr = ::MprConfigInterfaceDelete(
                                           hMachine,                                           hInterface
                                          );
        m_hInterface = NULL;
        CWRg( dwErr );

#ifdef KSL_IPINIP
        // If this interface is a tunnel, we need to remove the
        // GUID-to-Friendly name mapping
        // ------------------------------------------------------------
        if (GetInterfaceType() == ROUTER_IF_TYPE_TUNNEL1)
        {
            if (FHrOK(CLSIDFromString((LPTSTR) GetId(),
                                          &guidTunnel)))
            {
                // If this call fails, we can't do anything about it
                // ----------------------------------------------------
                MprSetupIpInIpInterfaceFriendlyNameDelete((LPTSTR) pszMachine,
                    &guidTunnel);
            }
        }
#endif //KSL_IPINIP


        // Remove the interface from the router if it is running
        // ------------------------------------------------------------

        if (ConnectRouter(OLE2CT(GetMachineName()), (HANDLE*)&hrouter) == NO_ERROR)
        {
            // The router is running; get a handle to the interface
            // --------------------------------------------------------
            dwErr = ::MprAdminInterfaceGetHandle(
                                                hrouter,
                                                wszInterface,
                                                &hInterface,
                                                FALSE
                                                );
            if (dwErr == NO_ERROR)
            {
                // Delete the interface
                // ----------------------------------------------------
                dwErr = ::MprAdminInterfaceDelete(
                    hrouter,
                    hInterface
                    );
            }
            
            ::MprAdminServerDisconnect(hrouter);
            
            if ((dwErr == RPC_S_SERVER_UNAVAILABLE) ||
                (dwErr == RPC_S_UNKNOWN_IF))
                dwErr = NO_ERROR;
            
            hr = HRESULT_FROM_WIN32(dwErr);
        }


        // Windows NT Bug: 138738
        // Need to remove the interface from the router managers
        // when deleting the interface.
        // ------------------------------------------------------------
        
        // Clear out all information for this interface
        // ------------------------------------------------------------
        if (FHrSucceeded(hr))
        {
            SPIEnumRtrMgrInterfaceInfo spEnumRmIf;
            SPIRtrMgrInterfaceInfo    spRmIf;
            
            // Remove the Router Managers from this interface
            // --------------------------------------------------------
            EnumRtrMgrInterface(&spEnumRmIf);

            while (spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK)
            {
                DWORD    dwTransportId = spRmIf->GetTransportId();
                spRmIf.Release();
                
                DeleteRtrMgrInterface(dwTransportId, TRUE);
            }
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::Unload
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::Unload( )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    IRtrMgrInterfaceInfo *    pRmIf;
    COM_PROTECT_TRY
    {
        //
        // Free all the contained router-manager structures in our list
        //
        while (!m_RmIfList.IsEmpty())
        {
            pRmIf = m_RmIfList.RemoveHead();
            pRmIf->Destruct();
            pRmIf->ReleaseWeakRef();
        }

        DoDisconnect();
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::Merge
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::Merge(IInterfaceInfo *pNewIf)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT                hr = hrOK;
    HRESULT                hrT;
    SPIEnumRtrMgrInterfaceInfo    spEnumRmIf;
    SPIRtrMgrInterfaceInfo        spRmIf;
    SPIRtrMgrInfo        spRm;
    SPIRtrMgrProtocolInfo    spRmProt;
    SPIRtrMgrProtocolInterfaceInfo    spRmProtIf;
    SPIEnumRtrMgrProtocolInterfaceInfo    spEnumRmProtIf;
    CDWordArray            oldDWArray;
    CDWordArray            newDWArray;
    int                    cOld, cNew;
    int                    i, j;
    DWORD                dwTemp;
    InterfaceCB            ifCB;

    Assert(pNewIf);
    Assert(lstrcmpi(pNewIf->GetId(), GetId()) == 0);

    COM_PROTECT_TRY
    {
        // Need to sync up the interface CB Data
        pNewIf->CopyCB(&ifCB);
        m_cb.LoadFrom(&ifCB);

        // Need to sync up the RtrMgrInterface list
        // They are identified by transport ids, so we can
        // use the two array method used by
        // IRtrMgrInterfaceInfo::Merge
        
        // Get the list of RtrMgrs that are in the new object
        CORg( pNewIf->EnumRtrMgrInterface(&spEnumRmIf) );
        spEnumRmIf->Reset();
        while (spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK)
        {
            newDWArray.Add(spRmIf->GetTransportId());
            spRmIf.Release();
        }

        spEnumRmIf.Release();
        spRmIf.Release();


        // Get the list of interfaces that are in this object
        CORg( this->EnumRtrMgrInterface(&spEnumRmIf) );
        spEnumRmIf->Reset();
        while (spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK)
        {
            oldDWArray.Add(spRmIf->GetTransportId());
            spRmIf.Release();
        }

        spEnumRmIf.Release();
        spRmIf.Release();


        // Ok now go through both lists, removing from the lists
        // interfaces that are in both lists.
        cOld = oldDWArray.GetSize();
        cNew = newDWArray.GetSize();
        for (i=cOld; --i>=0; )
        {
            dwTemp = oldDWArray.GetAt(i);
            for (j=cNew; --j>=0; )
            {
                if (dwTemp == newDWArray.GetAt(j))
                {
                    SPIRtrMgrInterfaceInfo    spRmIf1;
                    SPIRtrMgrInterfaceInfo    spRmIf2;

                    this->FindRtrMgrInterface(dwTemp, &spRmIf1);
                    pNewIf->FindRtrMgrInterface(dwTemp, &spRmIf2);

                    Assert(spRmIf1);
                    Assert(spRmIf2);
                    spRmIf1->Merge(spRmIf2);
                                        
                    // remove both instances
                    newDWArray.RemoveAt(j);
                    oldDWArray.RemoveAt(i);

                    // Need to update the size of the new array
                    cNew--;
                    break;
                }
            }
        }

        // oldDWArray now contains the interfaces that should be
        // removed.
        if (oldDWArray.GetSize())
        {
            for (i=oldDWArray.GetSize(); --i>=0; )
            {
                // Windows NT Bug: 132993, if this interface
                // is one that is purely local (mostly because
                // it is a new interface), then we should not
                // delete it.
                SPIRtrMgrInterfaceInfo    spRmIfTemp;
                
                FindRtrMgrInterface(oldDWArray.GetAt(i),
                                    &spRmIfTemp);
                Assert(spRmIfTemp);
                if (spRmIfTemp->GetFlags() & RouterSnapin_InSyncWithRouter)
                    DeleteRtrMgrInterface(oldDWArray.GetAt(i), FALSE);
            }
        }

        // newDWArray contains the interfaces that should be added
        if (newDWArray.GetSize())
        {
            for (i=newDWArray.GetSize(); --i>= 0; )
            {
                hr = pNewIf->FindRtrMgrInterface(
                            newDWArray.GetAt(i), &spRmIf);
                Assert(hr == hrOK);

                if (spRmIf)
                {
                    AddRtrMgrInterface(spRmIf, NULL);

                    // Remove this rmif from its old interface
                    // ------------------------------------------------
                    pNewIf->ReleaseRtrMgrInterface(spRmIf->GetTransportId());
                    
                    // We need to do the notify ourselves (because
                    // of the NULL infobase) the notifications won't
                    // get sent.
                    spRmIf->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);

                    if (m_pRouterInfoParent)
                    {
                        spRm.Release();
                        hrT = m_pRouterInfoParent->FindRtrMgr(spRmIf->GetTransportId(), &spRm);
                        if (FHrOK(hrT))
                        {
                            spRm->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);

                            // In addition, we will have to let the objects
                            // know that the interfaces are also being added
                            spEnumRmProtIf.Release();
                            spRmProtIf.Release();
                            
                            spRmIf->EnumRtrMgrProtocolInterface(&spEnumRmProtIf);
                            for(; spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK; spRmProtIf.Release())
                            {
                                spRmProt.Release();
                                spRm->FindRtrMgrProtocol(spRmProtIf->GetProtocolId(),
                                    &spRmProt);
                                if (spRmProt)
                                    spRmProt->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmProtIf, 0);
                            }
                        }
                    }
                        
                }
                spRmIf.Release();
            }
        }
        
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::GetId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) InterfaceInfo::GetId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_cb.stId;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::GetInterfaceType
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) InterfaceInfo::GetInterfaceType()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwIfType;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::GetDeviceName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) InterfaceInfo::GetDeviceName()
{
    RtrCriticalSection rtrCritSec(&m_critsec);
    return m_cb.stDeviceName;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::GetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) InterfaceInfo::GetTitle()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_cb.stTitle;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::SetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::SetTitle(LPCOLESTR pszTitle)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.stTitle = pszTitle;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::IsInterfaceEnabled
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL)    InterfaceInfo::IsInterfaceEnabled()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.bEnable;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::SetInterfaceEnabledState
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::SetInterfaceEnabledState( BOOL bEnabled)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    m_cb.bEnable = bEnabled;
    return hrOK;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::CopyCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::CopyCB(InterfaceCB *pifcb)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.SaveTo(pifcb);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::FindInterfaceTitle
        -
        This function retrieves the title of the given interface.
        The argument 'LpszIf' should contain the ID of the interface,
        for instance "EPRO1".
    Author: WeiJiang
 ---------------------------------------------------------------------------*/

HRESULT InterfaceInfo::FindInterfaceTitle(LPCTSTR pszMachine,
                                   LPCTSTR pszInterface,
                                   LPTSTR *ppszTitle)
{
    HRESULT    hr = hrOK;
    DWORD        dwErr = ERROR_SUCCESS;
    HKEY        hkeyMachine = NULL;
    BOOL        fNT4;
    
    COM_PROTECT_TRY
    {

        //
        // connect to the registry
        //
        CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

        CWRg( IsNT4Machine(hkeyMachine, &fNT4) );

        if (hkeyMachine)
            DisconnectRegistry(hkeyMachine);
            

        if(fNT4)
            hr = RegFindInterfaceTitle(pszMachine, pszInterface, ppszTitle);
        else
        {

            //$NT5
            SPMprConfigHandle    sphConfig;
            LPWSTR                pswz;
            CString                stMachineName = pszMachine;
            TCHAR                szDesc[1024];

        
            if (stMachineName.IsEmpty())
                pswz = NULL;
            else
                pswz = (LPTSTR) (LPCTSTR) stMachineName;

            dwErr = ::MprConfigServerConnect(pswz,
                                         &sphConfig);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = ::MprConfigGetFriendlyName(sphConfig,
                                               (LPTSTR)pszInterface,
                                               szDesc,
                                               sizeof(szDesc));
                if(dwErr == ERROR_SUCCESS)
                    *ppszTitle = StrDup((LPCTSTR) szDesc);
            }

            hr = HRESULT_FROM_WIN32(dwErr);

            
            // If we can't find the title by using the Mpr APIS,
            // try to access the registry directly (using the setup APIs)
            // --------------------------------------------------------
            if (dwErr != ERROR_SUCCESS)
            {
                hr = SetupFindInterfaceTitle(pswz, pszInterface,
                                             ppszTitle);
            }


        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::GetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) InterfaceInfo::GetMachineName()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_stMachine;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::SetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::SetMachineName(LPCOLESTR pszMachineName)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_stMachine = pszMachineName;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::GetParentRouterInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::GetParentRouterInfo(IRouterInfo **ppRouterInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        *ppRouterInfo = m_pRouterInfoParent;
        if (*ppRouterInfo)
            (*ppRouterInfo)->AddRef();
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::SetParentRouterInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceInfo::SetParentRouterInfo(IRouterInfo *pParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRouterInfo *    pTemp;
    
    pTemp = m_pRouterInfoParent;
    m_pRouterInfoParent = NULL;
    
    if (m_fStrongRef)
    {
        if (pTemp)
            pTemp->Release();
        if (pParent)
            pParent->AddRef();
    }
    else
    {
        if (pTemp)
            pTemp->ReleaseWeakRef();
        if (pParent)
            pParent->AddWeakRef();
    }
    m_pRouterInfoParent = pParent;

    return hrOK;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::EnumRtrMgrInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::EnumRtrMgrInterface( IEnumRtrMgrInterfaceInfo **ppEnumRmIf)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromRtrMgrInterfaceList(&m_RmIfList, ppEnumRmIf);
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::AddRtrMgrInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::AddRtrMgrInterface( IRtrMgrInterfaceInfo *pRmIf,
                                    IInfoBase *pIfInfo)
{
    Assert(pRmIf);
    
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT                hr = hrOK;
    HRESULT                hrT;
    SPIRtrMgrInfo        spRm;
    
    COM_PROTECT_TRY
    {
        //
        // Fail if there is a duplicate
        //
        if (FHrOK(FindRtrMgrInterface(pRmIf->GetTransportId(), NULL)))
            CORg( E_INVALIDARG );
            
        //
        // Save the new router-manager
        //

        CORg( pRmIf->Save(GetMachineName(),
                          m_hMachineConfig, m_hInterface, NULL, pIfInfo, 0) );

        //
        // Add the new router-manager structure to the list
        //
        m_RmIfList.AddTail(pRmIf);
        pRmIf->AddWeakRef();
        pRmIf->SetParentInterfaceInfo(this);

        // We don't notify of a new interface since we haven't
        // actually saved the interface back down to the router
        if (pIfInfo)
        {
            m_AdviseList.NotifyChange(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);

            if (m_pRouterInfoParent)
            {
                hrT = m_pRouterInfoParent->FindRtrMgr(pRmIf->GetTransportId(), &spRm);
                if (FHrOK(hrT))
                    spRm->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);
            }
        }
            
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::DeleteRtrMgrInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::DeleteRtrMgrInterface(DWORD dwTransportId, BOOL fRemove)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK, hrT;
    SPIRtrMgrInterfaceInfo    spRmIf;
    POSITION        pos, posRmIf;
    SPIRtrMgrInfo    spRm;
    SPIEnumRtrMgrProtocolInterfaceInfo    spEnumRmProtIf;
    SPIRtrMgrProtocolInterfaceInfo        spRmProtIf;
    
    COM_PROTECT_TRY
    {
        //
        // Find the router-manager to be deleted
        //
        pos = m_RmIfList.GetHeadPosition();
        while (pos)
        {
            posRmIf = pos;

            spRmIf.Set( m_RmIfList.GetNext(pos) );

            if (spRmIf->GetTransportId() == dwTransportId)
                break;
            spRmIf.Release();
        }

        if (!spRmIf)
            CORg( E_INVALIDARG );

        // Delete all RtrMgrProtocolInterfaces from the router manager
        spRmIf->EnumRtrMgrProtocolInterface(&spEnumRmProtIf);
        while (spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK)
        {
            DWORD    dwProtocolId = spRmProtIf->GetProtocolId();
            spRmProtIf.Release();
            spRmIf->DeleteRtrMgrProtocolInterface(dwProtocolId, fRemove);
        }

        //
        // Remove the router-manager from our list
        //
        m_RmIfList.RemoveAt(posRmIf);
        spRmIf->Destruct();
        spRmIf->ReleaseWeakRef();

        //
        // Remove the router-manager from the registry and the router
        //
        if (fRemove)
            spRmIf->Delete(GetMachineName(), NULL, NULL);

        m_AdviseList.NotifyChange(ROUTER_CHILD_DELETE, ROUTER_OBJ_RmIf, 0);
        
        if (m_pRouterInfoParent)
        {
            hrT = m_pRouterInfoParent->FindRtrMgr(spRmIf->GetTransportId(), &spRm);
            if (FHrOK(hrT))
                spRm->RtrNotify(ROUTER_CHILD_DELETE, ROUTER_OBJ_RmIf, 0);
        }
        
        spRmIf.Release();

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::ReleaseRtrMgrInterface
        This function will release the AddRef() that this object has
        on the child.  This allows us to transfer child objects from
        one router to another.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::ReleaseRtrMgrInterface( DWORD dwTransportId )
{
    HRESULT     hr = hrOK;
    POSITION    pos, posRmIf;
    SPIRtrMgrInterfaceInfo    spRmIf;
    
    COM_PROTECT_TRY
    {
        pos = m_RmIfList.GetHeadPosition();
        while (pos)
        {
            // Save the position (so that we can delete it)
            posRmIf = pos;
            spRmIf.Set( m_RmIfList.GetNext(pos) );

            if (spRmIf &&
                (spRmIf->GetTransportId() == dwTransportId))
            {
                // When releasing, we need to disconnect (since the
                // main handle is controlled by the router info).
                spRmIf->DoDisconnect();
        
                spRmIf->ReleaseWeakRef();
                spRmIf.Release();
                
                // release this node from the list
                m_RmIfList.RemoveAt(posRmIf);
                break;
            }
            spRmIf.Release();
        }        
    }
    COM_PROTECT_CATCH;
    return hr;
}

    


/*!--------------------------------------------------------------------------
    InterfaceInfo::FindRtrMgrInterface
        S_OK is returned if a RtrMgrInfo is found.
        S_FALSE is returned if a RtrMgrInfo was NOT found.
        error codes returned otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::FindRtrMgrInterface( DWORD dwTransportId,
                                    IRtrMgrInterfaceInfo **ppInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIRtrMgrInterfaceInfo    spRmIf;
    
    COM_PROTECT_TRY
    {
        if (ppInfo)
            *ppInfo = NULL;
        
        pos = m_RmIfList.GetHeadPosition();

        while (pos)
        {
            spRmIf.Set( m_RmIfList.GetNext(pos) );

            if (spRmIf->GetTransportId() == dwTransportId)
            {
                hr = hrOK;
                if (ppInfo)
                    *ppInfo = spRmIf.Transfer();
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    InterfaceInfo::RtrAdvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
                       LONG_PTR *pulConnection, LPARAM lUserParam)
{
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    RtrCriticalSection    rtrCritSec(&m_critsec);
    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::RtrNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::RtrUnadvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::RtrUnadvise( LONG_PTR ulConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(ulConnection);
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::LoadRtrMgrInterfaceList
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceInfo::LoadRtrMgrInterfaceList()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    BOOL bAdd;
    LPBYTE pItemTable = NULL;
    SPIRtrMgrInterfaceInfo    spRmIf;
    DWORD dwErr, i, dwEntries, dwTotal;
    HRESULT        hr = hrOK;
    MPR_IFTRANSPORT_0 *piftransport;
    TCHAR szTransport[MAX_TRANSPORT_NAME_LEN+1];
    USES_CONVERSION;

    //
    // Now enumerate the transports on this interface
    //
    dwErr = ::MprConfigInterfaceTransportEnum(
                m_hMachineConfig,
                m_hInterface,
                0,
                &pItemTable,
                (DWORD)-1,
                &dwEntries,
                &dwTotal,
                NULL
                );

    if (dwErr != NO_ERROR && dwErr != ERROR_NO_MORE_ITEMS)
        CWRg( dwErr );

    //
    // Construct a CRmInterfaceInfo for each transport enumerated
    //
    for (i = 0, piftransport = (MPR_IFTRANSPORT_0*)pItemTable;
         i < dwEntries;
         i++, piftransport++)
    {
#if (WINVER >= 0x0501)
        if (piftransport->dwTransportId == PID_IPX) {continue;}
#endif
        FindRtrMgrInterface(piftransport->dwTransportId, &spRmIf);

        if (spRmIf)
            bAdd = FALSE;
        else
        {
            bAdd = TRUE;

            StrCpyTFromW(szTransport, piftransport->wszIfTransportName);

            //
            // Construct a CRmInterfaceInfo object for this transport
            //
            spRmIf = new RtrMgrInterfaceInfo(piftransport->dwTransportId,
                                             szTransport,
                                             OLE2CT(GetId()),
                                             GetInterfaceType(),
                                             this);

            spRmIf->SetFlags(RouterSnapin_InSyncWithRouter);
        }

        //
        // Load the information for this CRmInterfaceInfo,
        // indicating to it that it should load its list of protocols.
        //
        hr = spRmIf->Load(GetMachineName(), m_hMachineConfig, m_hInterface,
                          piftransport->hIfTransport );
        if (!FHrSucceeded(hr))
        {
            spRmIf->Destruct();
            spRmIf.Release();
            continue;
        }

        //
        // Add the router-manager interface to our list
        //
        if (bAdd)
        {
            m_RmIfList.AddTail(spRmIf);
            CONVERT_TO_WEAKREF(spRmIf);
            spRmIf.Transfer();
        }
    }

Error:
    if (pItemTable)
        ::MprConfigBufferFree(pItemTable);

    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::TryToConnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceInfo::TryToConnect(LPCWSTR pswzMachine, HANDLE *phMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    
    if (m_hMachineConfig)
        *phMachine = m_hMachineConfig;
    else if (*phMachine)
    {
        m_hMachineConfig = *phMachine;
        m_bDisconnect = FALSE;
    }
    else
    {
        //$ Review: kennt, this function does not take a LPCWSTR,
        // is this a mistake or does it modify the parameters?
        CWRg( ::MprConfigServerConnect((LPWSTR) pswzMachine, phMachine) );
        m_hMachineConfig = *phMachine;
        m_bDisconnect = TRUE;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::TryToGetIfHandle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceInfo::TryToGetIfHandle(HANDLE hMachine,
                                        LPCWSTR pswzInterface,
                                        HANDLE *phInterface)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    
    if (m_hInterface)
        *phInterface = m_hInterface;
    else if (*phInterface)
        m_hInterface = *phInterface;
    else
    {
        //
        // Get a handle to the interface
        //
        CWRg(::MprConfigInterfaceGetHandle(hMachine,
                                           (LPWSTR) pswzInterface,
                                           phInterface
                                          ) );
        m_hInterface = *phInterface;
    }
Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    InterfaceInfo::Disconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void InterfaceInfo::Disconnect()
{
    if (m_bDisconnect && m_hMachineConfig)
        ::MprConfigServerDisconnect(m_hMachineConfig);
    
    m_bDisconnect = FALSE;
    m_hMachineConfig = NULL;
    m_hInterface = NULL;
}

/*!--------------------------------------------------------------------------
    InterfaceInfo::DoDisconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;
    SPIEnumRtrMgrInterfaceInfo    spEnumRmIf;
    SPIRtrMgrInterfaceInfo        spRmIf;

    COM_PROTECT_TRY
    {
        // Disconnect our data.
        // ------------------------------------------------------------
        Disconnect();

        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);

        // Now tell all child objects to disconnect.
        // ------------------------------------------------------------
        HRESULT            hrIter = hrOK;

        EnumRtrMgrInterface(&spEnumRmIf);
        spEnumRmIf->Reset();
        while (spEnumRmIf->Next(1, &spRmIf, NULL) == hrOK)
        {
            spRmIf->DoDisconnect();
            spRmIf.Release();
        }
        
    }
    COM_PROTECT_CATCH;
    return hr;
}






/*---------------------------------------------------------------------------
    IRtrMgrInterfaceInfo Implementation
 ---------------------------------------------------------------------------*/

TFSCORE_API(HRESULT) CreateRtrMgrInterfaceInfo(IRtrMgrInterfaceInfo **ppRmIf,
                                              LPCWSTR pszId,
                                              DWORD dwTransportId,
                                              LPCWSTR pswzInterfaceId,
                                              DWORD dwIfType)
{
    Assert(ppRmIf);

    HRESULT hr = hrOK;
    IRtrMgrInterfaceInfo *    pRmIf = NULL;
    USES_CONVERSION;

    COM_PROTECT_TRY
    {
        pRmIf = new RtrMgrInterfaceInfo(dwTransportId,
                                       W2CT(pszId),
                                       W2CT(pswzInterfaceId),
                                       dwIfType,
                                       NULL);
        *ppRmIf = pRmIf;
    }
    COM_PROTECT_CATCH;

    return hr;
}

IMPLEMENT_WEAKREF_ADDREF_RELEASE(RtrMgrInterfaceInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(RtrMgrInterfaceInfo, IRtrMgrInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrInterfaceInfo)

RtrMgrInterfaceInfo::RtrMgrInterfaceInfo(DWORD dwTransportId,
                                        LPCTSTR pszId,
                                        LPCTSTR pszIfId,
                                        DWORD dwIfType,
                                        InterfaceInfo *pInterfaceInfo)
    : m_hMachineConfig(NULL),
    m_hInterface(NULL),
    m_hIfTransport(NULL),
    m_bDisconnect(FALSE),
    m_dwFlags(0)
{
    m_cb.dwTransportId = dwTransportId;
    m_cb.stId = pszId;
    m_cb.stInterfaceId = pszIfId;
    m_cb.dwIfType = dwIfType;
    
    DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrInterfaceInfo);

    m_pInterfaceInfoParent = pInterfaceInfo;
    if (m_pInterfaceInfoParent)
        m_pInterfaceInfoParent->AddRef();
    InitializeCriticalSection(&m_critsec);
}

RtrMgrInterfaceInfo::~RtrMgrInterfaceInfo()
{
    Assert(m_pInterfaceInfoParent == NULL);
    Destruct();
    DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrInterfaceInfo);
    DeleteCriticalSection(&m_critsec);
}

void RtrMgrInterfaceInfo::ReviveStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pInterfaceInfoParent)
    {
        CONVERT_TO_STRONGREF(m_pInterfaceInfoParent);
    }
}

void RtrMgrInterfaceInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pInterfaceInfoParent)
    {
        CONVERT_TO_WEAKREF(m_pInterfaceInfoParent);
    }
    if (m_fDestruct)
        Destruct();
}

STDMETHODIMP RtrMgrInterfaceInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IInterfaceInfo *    pParent;
    m_fDestruct = TRUE;
    if (!m_fStrongRef)
    {
        pParent = m_pInterfaceInfoParent;
        m_pInterfaceInfoParent = NULL;
        if (pParent)
            pParent->ReleaseWeakRef();

        Unload();
    }
    return hrOK;
}

STDMETHODIMP_(DWORD) RtrMgrInterfaceInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP RtrMgrInterfaceInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Load
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::Load(LPCOLESTR   pszMachine,
                                       HANDLE      hMachine,
                                       HANDLE      hInterface,
                                       HANDLE      hIfTransport)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    DWORD dwSize = 0;
    MPR_INTERFACE_0 *pinterface = NULL;
    SPIInterfaceInfo    spIf;
    SPIRouterInfo        spRouter;
    SPIEnumInterfaceCB    spEnumIfCB;
    InterfaceCB            ifCB;
    SPSZ                spsz;

    COM_PROTECT_TRY
    {
        //
        // Discard any information already loaded
        //
        Unload();

        m_stMachine = (pszMachine ? pszMachine : TEXT(""));

        //
        // If 'hMachine' was not specified, connect to the config
        // on the specified machine
        //
        Assert(m_hMachineConfig == NULL);

        CORg( TryToGetAllHandles(T2CW((LPTSTR)(LPCTSTR) m_stMachine),
                                 &hMachine, &hInterface, &hIfTransport) );

        //
        // Get information about the interface
        //
        CWRg(::MprConfigInterfaceGetInfo(
                    hMachine,
                    hInterface,
                    0,
                    (LPBYTE*)&pinterface,
                    &dwSize
                    ) );

        //
        // Save the interface type
        //
        m_cb.dwIfType = (DWORD)pinterface->dwIfType;

        
        //
        // If this isn't a LAN card, the interface-ID is the title;
        // otherwise, retrieve the title from the Software key
        //
        if (GetInterfaceType() != (DWORD)ROUTER_IF_TYPE_DEDICATED)
        {
            m_cb.stTitle = OLE2CT(GetInterfaceId());
        }
        else
        {
            // Can we get to the router info object?
            if (m_pInterfaceInfoParent)
                m_pInterfaceInfoParent->GetParentRouterInfo(&spRouter);

            if (spRouter)
            {
                //
                // This object is contained in a 'CRouterInfo',
                // which will have already loaded the LAN interface
                // control-blocks search through that list to find our title,
                //

                BOOL bFound = FALSE;
                
                CORg( spRouter->EnumInterfaceCB(&spEnumIfCB) );

                spEnumIfCB->Reset();

                while (spEnumIfCB->Next(1, &ifCB, NULL) == hrOK)
                {
                    if (StriCmpW(ifCB.szId, GetInterfaceId()) == 0)
                    {
                        m_cb.stTitle = OLE2CT(ifCB.szId);
                        bFound = TRUE;
                        break;
                    }
                }

                if (!bFound)
                {
                    hr = InterfaceInfo::FindInterfaceTitle(OLE2CT(GetMachineName()),
                                           OLE2CT(GetInterfaceId()),
                                           &spsz);
                    if (FHrOK(hr))
                        m_cb.stTitle = spsz;
                    else
                        m_cb.stTitle = OLE2CT(GetInterfaceId());
                    hr = hrOK;
                }
            }
            else
            {
                //
                // Read the title directly from the registry
                //
                hr = InterfaceInfo::FindInterfaceTitle(OLE2CT(GetMachineName()),
                                           OLE2CT(GetInterfaceId()),
                                           &spsz);
                if (FHrOK(hr))
                    m_cb.stTitle = spsz;
                else
                    m_cb.stTitle = OLE2CT(GetInterfaceId());
                hr = hrOK;
            }

        }
        //
        // Load the list of routing-protocols active on this interface
        //
        CORg( LoadRtrMgrInterfaceInfo(hMachine, hInterface, hIfTransport) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    if (pinterface)
        ::MprConfigBufferFree(pinterface);

    return hr;
}
    

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Save
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::Save(
                                       LPCOLESTR     pszMachine,
                                       HANDLE      hMachine,
                                       HANDLE      hInterface,
                                       HANDLE      hIfTransport,
                                       IInfoBase*  pInterfaceInfo,
                                       DWORD       dwDeleteProtocolId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    
    COM_PROTECT_TRY
    {

        //$ OPT : We reuse the handles (if they exist), so why
        // do we pass in the machine name?  What we should do is
        // to release all the handles first.

        Assert(m_stMachine.CompareNoCase(pszMachine) == 0);

        hr = TryToGetAllHandles(pszMachine,
                                &hMachine,
                                &hInterface,
                                &hIfTransport);
        
        if (!FHrSucceeded(hr) && (hIfTransport == NULL))
        {
            dwErr = ::MprConfigInterfaceTransportGetHandle(hMachine,
                        hInterface, GetTransportId(), &hIfTransport);
            if (dwErr != NO_ERROR)
            {
                //
                // We couldn't connect so try creating the interface-transport;
                // First convert the transport-name to Unicode
                //
                WCHAR wszTransport[MAX_TRANSPORT_NAME_LEN+1];
                StrCpyWFromT(wszTransport, m_cb.stId);

                //
                // Create the interface-transport
                //
                CWRg( ::MprConfigInterfaceTransportAdd(hMachine, hInterface,
                            GetTransportId(), wszTransport,
                            NULL, 0, &hIfTransport) );
            }
            m_hIfTransport = hIfTransport;
        }


        //
        // Update the registry and our infobase with the current information
        //
        CORg( SaveRtrMgrInterfaceInfo(
                    hMachine, hInterface, hIfTransport, pInterfaceInfo,
                    dwDeleteProtocolId
                    ) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Unload
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::Unload( )
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    IRtrMgrProtocolInterfaceInfo *    pRmProtIf;
    COM_PROTECT_TRY
    {

        while (!m_RmProtIfList.IsEmpty())
        {
            pRmProtIf = m_RmProtIfList.RemoveHead();
            pRmProtIf->Destruct();
            pRmProtIf->ReleaseWeakRef();
        }

        DoDisconnect();

    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Delete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::Delete(LPCOLESTR     pszMachine,
                                         HANDLE      hMachine,
                                         HANDLE      hInterface)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    MPR_SERVER_HANDLE hrouter = NULL;
    HRESULT    hr = hrOK;
    DWORD dwErr;
    HANDLE hIfTransport = NULL;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
    USES_CONVERSION;
    
    COM_PROTECT_TRY
    {

        //
        //$ OPT, kennt : why is the machine name passed in here?
        //
        
        CORg( TryToGetAllHandles(pszMachine,
                                 &hMachine,
                                 &hInterface,
                                 NULL) );
        do
        {

            //
            // Get a handle to the interface-transport
            //
            dwErr = ::MprConfigInterfaceTransportGetHandle(
                                hMachine,
                                hInterface,
                                GetTransportId(),
                                &hIfTransport
                                );
            if (dwErr == NO_ERROR)
            {
                //
                // Remove the interface-transport
                //
                dwErr = ::MprConfigInterfaceTransportRemove(
                                hMachine,
                                hInterface,
                                hIfTransport
                                );
            }

            m_hIfTransport = NULL;
            
        } while(FALSE);

        //
        // Now remove the router-manager from the interface
        // with the currently running router
        //
        if (ConnectRouter(OLE2CT(pszMachine), (HANDLE*)&hrouter) == NO_ERROR)
        {
            //
            // Convert ID into Unicode
            //
            StrnCpyWFromOle(wszInterface, GetInterfaceId(),
                            DimensionOf(wszInterface));

            //
            // The router is running; if the interface exists, remove it
            //
            dwErr = ::MprAdminInterfaceGetHandle(
                            hrouter,
                            wszInterface,
                            &hInterface,
                            FALSE
                            );

            if (dwErr == NO_ERROR)
            {
                //
                // Remove the interface-transport
                //                
                dwErr = ::MprAdminInterfaceTransportRemove(
                                    hrouter,
                                    hInterface,
                                    GetTransportId()
                                    );
            }

            ::MprAdminServerDisconnect(hrouter);

            if ((dwErr == RPC_S_SERVER_UNAVAILABLE) ||
                (dwErr == RPC_S_UNKNOWN_IF))
                dwErr = NO_ERROR;
            
            CWRg( dwErr );
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Merge
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::Merge(IRtrMgrInterfaceInfo *pNewRmIf)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    SPIEnumRtrMgrProtocolInterfaceInfo    spEnumRmProtIf;
    SPIRtrMgrProtocolInterfaceInfo        spRmProtIf;
    HRESULT                hr = hrOK;
    CDWordArray            oldDWArray;
    CDWordArray            newDWArray;
    int                    cOld, cNew;
    int                    i, j;
    DWORD                dwTemp;
    RtrMgrInterfaceCB    rmIfCB;

    Assert(pNewRmIf);
    Assert(pNewRmIf->GetTransportId() == GetTransportId());
    Assert(lstrcmpi(pNewRmIf->GetId(), GetId()) == 0);

    COM_PROTECT_TRY
    {
        // Need to sync up RtrMgrInterfaceInfo
        pNewRmIf->CopyCB(&rmIfCB);
        m_cb.LoadFrom(&rmIfCB);
        
        //
        // The general algorithm is to build up two arrays
        // the first array contains the protocol ids for this object
        // the second array contains the ids for the new object
        //
        // We then go through and remove all protocols that are in
        // BOTH lists.
        //
        // This will leave us with the first array containing the
        // ids of the protocols that need to be deleted from this object.
        //
        // The second array will have the list of ids of protocols that
        // have to be added to this object from the second object.
        //

        // Get the list of protocols that are in the new object
        CORg( pNewRmIf->EnumRtrMgrProtocolInterface(&spEnumRmProtIf) );
        spEnumRmProtIf->Reset();
        while (spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK)
        {
            newDWArray.Add(spRmProtIf->GetProtocolId());
            spRmProtIf.Release();
        }

        spEnumRmProtIf.Release();
        spRmProtIf.Release();


        // Get the list of protocols that are in this object
        CORg( this->EnumRtrMgrProtocolInterface(&spEnumRmProtIf) );
        spEnumRmProtIf->Reset();
        while (spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK)
        {
            oldDWArray.Add(spRmProtIf->GetProtocolId());
            spRmProtIf.Release();
        }

        spEnumRmProtIf.Release();
        spRmProtIf.Release();


        // Ok now go through both lists, removing from the lists
        // protocols that are in both lists.
        cOld = oldDWArray.GetSize();
        cNew = newDWArray.GetSize();
        for (i=cOld; --i>=0; )
        {
            dwTemp = oldDWArray.GetAt(i);
            for (j=cNew; --j>=0; )
            {
                if (dwTemp == newDWArray.GetAt(j))
                {
                    // remove both instances
                    newDWArray.RemoveAt(j);
                    oldDWArray.RemoveAt(i);

                    // Need to update the size of the new array
                    cNew--;
                    break;
                }
            }
        }

        // oldDWArray now contains the protocols that should be
        // removed.
        if (oldDWArray.GetSize())
        {
            for (i=oldDWArray.GetSize(); --i>=0; )
            {
                // Windows NT Bug: 132993, we need to make sure that
                // we don't delete the local interfaces
                SPIRtrMgrProtocolInterfaceInfo    spRmProtIfTemp;

                FindRtrMgrProtocolInterface(oldDWArray.GetAt(i),
                                            &spRmProtIfTemp);
                Assert(spRmProtIfTemp);
                if (spRmProtIfTemp->GetFlags() & RouterSnapin_InSyncWithRouter)
                    DeleteRtrMgrProtocolInterface(oldDWArray.GetAt(i), FALSE);
            }
        }

        // newDWArray contains the protocols that should be added
        if (newDWArray.GetSize())
        {
            for (i=newDWArray.GetSize(); --i>= 0; )
            {
                hr = pNewRmIf->FindRtrMgrProtocolInterface(
                                        newDWArray.GetAt(i), &spRmProtIf);
                Assert(hr == hrOK);

                if (spRmProtIf)
                {
                    AddRtrMgrProtocolInterface(spRmProtIf, NULL);
                    
                    // Remove this rmprotif from its old RMinterface
                    // ------------------------------------------------
                    pNewRmIf->ReleaseRtrMgrProtocolInterface(
                        spRmProtIf->GetProtocolId());
                }
                    
                spRmProtIf.Release();
            }
        }
        
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetInfo
        -
        This function updates the information in use by the router-manager
        if it is currently running.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetInfo(DWORD dwIfInfoSize,
                                          PBYTE pInterfaceInfoData)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    DWORD dwErr;
    MPR_SERVER_HANDLE hrouter = NULL;
    HANDLE hinterface = NULL;
    
    COM_PROTECT_TRY
    {
        //
        // Connect to the router
        //

        CWRg( ConnectRouter(OLE2CT(GetMachineName()), (HANDLE*)&hrouter) );

        do {
            //
            // Get the handle to the interface
            //
            WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
            StrCpyWFromT(wszInterface, GetInterfaceId());

            dwErr = ::MprAdminInterfaceGetHandle(
                                                hrouter,
                                                wszInterface,
                                                &hinterface,
                                                FALSE
                                                );

            if (dwErr != NO_ERROR) { hinterface = NULL; break; }

            //
            // Set the new info for the router-manager
            //
            dwErr = ::MprAdminInterfaceTransportSetInfo(
                    hrouter,
                    hinterface,
                    m_cb.dwTransportId,
                    pInterfaceInfoData,
                    dwIfInfoSize
                    );

            //
            // If that failed, we assume that the router-manager
            // has not been added, and we attempt an add;
            // otherwise, we set the new information
            //

            if (dwErr != NO_ERROR && dwErr != RPC_S_SERVER_UNAVAILABLE)
            {
                //
                // Attempt to add the router-manager on the interface
                //
                DWORD dwErr1 = ::MprAdminInterfaceTransportAdd(
                        hrouter,
                        hinterface,
                        m_cb.dwTransportId,
                        pInterfaceInfoData,
                        dwIfInfoSize
                        );
                if (dwErr1 == NO_ERROR)
                    dwErr = dwErr1;
            }

        } while (FALSE);

        if ((dwErr == RPC_S_SERVER_UNAVAILABLE) ||
            (dwErr == RPC_S_UNKNOWN_IF))
            dwErr = NO_ERROR;
        
        CWRg(dwErr);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    // If we fail to contact the server, then we will get these
    // errors.  The most common occurrence is that the router is
    // not running.
    if ((hr == HResultFromWin32(RPC_S_SERVER_UNAVAILABLE)) ||
        (hr == HResultFromWin32(RPC_S_UNKNOWN_IF)))
        hr = hrOK;

    if (hrouter)
        ::MprAdminServerDisconnect(hrouter);
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetInfoBase(HANDLE hMachine,
                                              HANDLE hInterface,
                                              HANDLE hIfTransport,
                                              IInfoBase *pInfoBase)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrOK;
    LPBYTE pIfBytes = NULL;
    DWORD dwIfBytesSize = 0;

    COM_PROTECT_TRY
    {
        if (pInfoBase)
        {
            //
            // If already loaded, the handles passed in are ignored.
            //
            // Otherwise, if not specified, a connection will be made.
            //
            CORg( TryToGetAllHandles(T2CW((LPTSTR)(LPCTSTR) m_stMachine),
                                     &hMachine, &hInterface, &hIfTransport) );

            //
            // Convert the CInfoBase to a byte-array
            //
            CWRg( pInfoBase->WriteTo(&pIfBytes, &dwIfBytesSize) );
        
            //
            // Save the information to the persistent store
            //    
            CWRg( ::MprConfigInterfaceTransportSetInfo(
                hMachine,
                hInterface,
                hIfTransport,
                pIfBytes,
                dwIfBytesSize
                ) );
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    CoTaskMemFree( pIfBytes );

    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::GetInfoBase(HANDLE hMachine,
                                              HANDLE hInterface,
                                              HANDLE hIfTransport,
                                              IInfoBase **ppInfoBase)
{
    Assert(ppInfoBase);
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    LPBYTE        pIfBytes = NULL;
    DWORD        dwIfBytesSize;
    SPIInfoBase    spInfoBase;
    
    COM_PROTECT_TRY
    {
        *ppInfoBase = NULL;

        //
        // If already loaded, the handles passed in are ignored.
        //
        // Otherwise, if not specified, a connection will be made.
        //
        CORg( TryToGetAllHandles(T2CW((LPTSTR)(LPCTSTR) m_stMachine),
                                 &hMachine, &hInterface, &hIfTransport) );

        CORg( CreateInfoBase(&spInfoBase) );

        //
        // Retrieve the info for the interface transport
        //
        CWRg( ::MprConfigInterfaceTransportGetInfo(
            hMachine, hInterface, hIfTransport,
            &pIfBytes,
            &dwIfBytesSize
            ));
        //
        // Parse the interface info for the router-manager
        //
        CORg( spInfoBase->LoadFrom(dwIfBytesSize, pIfBytes) );

        *ppInfoBase = spInfoBase.Transfer();

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    if (pIfBytes) { ::MprConfigBufferFree(pIfBytes); }
    
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfo::GetId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.stId;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetId(LPCOLESTR pszId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.stId = pszId;
    }
    COM_PROTECT_CATCH;
    return hr;
}
        
/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetTransportId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrInterfaceInfo::GetTransportId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwTransportId;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetInterfaceId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfo::GetInterfaceId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_cb.stInterfaceId;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetInterfaceType
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrInterfaceInfo::GetInterfaceType()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwIfType;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfo::GetTitle()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_cb.stTitle;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetTitle(LPCOLESTR pszTitle)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_cb.stTitle = pszTitle;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::CopyCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::CopyCB(RtrMgrInterfaceCB *pRmIfCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.SaveTo(pRmIfCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfo::GetMachineName()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    //$UNICODE : kennt, assumes native unicode and OLECHAR==WCHAR
    return m_stMachine;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetMachineName(LPCOLESTR pszMachineName)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_stMachine = pszMachineName;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::EnumRtrMgrProtocolInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::EnumRtrMgrProtocolInterface( IEnumRtrMgrProtocolInterfaceInfo **ppEnumRmProtIf)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        hr = CreateEnumFromRtrMgrProtocolInterfaceList(&m_RmProtIfList,
                            ppEnumRmProtIf);
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::FindRtrMgrProtocolInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::FindRtrMgrProtocolInterface( DWORD dwProtocolId,
    IRtrMgrProtocolInterfaceInfo **ppInfo)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrFalse;
    POSITION    pos;
    SPIRtrMgrProtocolInterfaceInfo    spRmProtIf;
    
    COM_PROTECT_TRY
    {
        if (ppInfo)
            *ppInfo = NULL;
        
        // Look through the list of rtr mgrs for the one that matches
        pos = m_RmProtIfList.GetHeadPosition();
        while (pos)
        {
            spRmProtIf.Set(m_RmProtIfList.GetNext(pos));
            Assert(spRmProtIf);
            if (spRmProtIf->GetProtocolId() == dwProtocolId)
            {
                hr = hrOK;
                if (ppInfo)
                    *ppInfo = spRmProtIf.Transfer();
                break;
            }
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::AddRtrMgrProtocolInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::AddRtrMgrProtocolInterface( IRtrMgrProtocolInterfaceInfo *pInfo,
    IInfoBase *pInterfaceInfo)
{
    Assert(pInfo);
    
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        //
        // Fail if there is a duplicate
        //
        if (FHrOK(FindRtrMgrProtocolInterface(pInfo->GetProtocolId(), NULL)))
            CORg( E_INVALIDARG );

        //
        // Save the new information if specified
        //
        if (pInterfaceInfo)
        {
            CORg( Save(GetMachineName(),
                       m_hMachineConfig,
                       m_hInterface,
                       m_hIfTransport,
                       pInterfaceInfo,
                       0) );
        }


        //
        // Add the new routing-protocol to our list
        //
        m_RmProtIfList.AddTail(pInfo);
        pInfo->AddWeakRef();
        pInfo->SetParentRtrMgrInterfaceInfo(this);

        NotifyOfRmProtIfAdd(pInfo, m_pInterfaceInfoParent);
            
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::DeleteRtrMgrProtocolInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::DeleteRtrMgrProtocolInterface( DWORD dwProtocolId, BOOL fRemove)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    SPIRtrMgrProtocolInterfaceInfo    spRmProtIf;
    SPIRtrMgrProtocolInfo            spRmProt;
    SPIRouterInfo                    spRouterInfo;
    POSITION    pos;
    POSITION    posRmProtIf;
    HRESULT        hrT;
    
    COM_PROTECT_TRY
    {
        //
        // Find the routing-protocol to be deleted
        //
        pos = m_RmProtIfList.GetHeadPosition();
        while (pos)
        {
            posRmProtIf = pos;

            spRmProtIf.Set( m_RmProtIfList.GetNext(pos) );

            if (spRmProtIf->GetProtocolId() == dwProtocolId)
                break;
            spRmProtIf.Release();
        }

        if (spRmProtIf == NULL)
            CORg( E_INVALIDARG );

        //
        // Save the updated information, removing the protocol's block
        //
        if (fRemove)
        {
            hr= Save(GetMachineName(),
                     m_hMachineConfig,
                     m_hInterface,
                     m_hIfTransport,
                     NULL,
                     dwProtocolId) ;
            
            if (!FHrSucceeded(hr) &&
                (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE)))
            CORg(hr);
        }
        
        //
        // Remove the protocol from our list
        //
        m_RmProtIfList.RemoveAt(posRmProtIf);
        spRmProtIf->Destruct();
        spRmProtIf->ReleaseWeakRef();

        m_AdviseList.NotifyChange(ROUTER_CHILD_DELETE, ROUTER_OBJ_RmProtIf, 0);

        // Also need to advise the RmProt
        if (m_pInterfaceInfoParent)
        {
            hrT = m_pInterfaceInfoParent->GetParentRouterInfo(&spRouterInfo);

            if (FHrOK(hrT))
                hrT = LookupRtrMgrProtocol(spRouterInfo,
                                           spRmProtIf->GetTransportId(),
                                           spRmProtIf->GetProtocolId(),
                                           &spRmProt);

            if (FHrOK(hrT))
                spRmProt->RtrNotify(ROUTER_CHILD_DELETE, ROUTER_OBJ_RmProtIf, 0);
        }

        Assert(FindRtrMgrProtocolInterface(dwProtocolId, NULL) != hrOK);
        
        COM_PROTECT_ERROR_LABEL;

    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::ReleaseRtrMgrProtocolInterface
        This function will release the AddRef() that this object has
        on the child.  This allows us to transfer child objects from
        one router to another.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::ReleaseRtrMgrProtocolInterface( DWORD dwProtocolId )
{
    HRESULT     hr = hrOK;
    POSITION    pos, posRmProtIf;
    SPIRtrMgrProtocolInterfaceInfo    spRmProtIf;
    
    COM_PROTECT_TRY
    {
        pos = m_RmProtIfList.GetHeadPosition();
        while (pos)
        {
            // Save the position (so that we can delete it)
            posRmProtIf = pos;
            spRmProtIf.Set( m_RmProtIfList.GetNext(pos) );

            if (spRmProtIf &&
                (spRmProtIf->GetProtocolId() == dwProtocolId))
            {
                
                // When releasing, we need to disconnect (since the
                // main handle is controlled by the router info).
                spRmProtIf->DoDisconnect();
        
                spRmProtIf->ReleaseWeakRef();
                spRmProtIf.Release();
                
                // release this node from the list
                m_RmProtIfList.RemoveAt(posRmProtIf);
                break;
            }
            spRmProtIf.Release();
        }        
    }
    COM_PROTECT_CATCH;
    return hr;
}

    

    
/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::RtrAdvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
                                             LONG_PTR *pulConnection,
                                             LPARAM lUserParam)
{
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    RtrCriticalSection    rtrCritSec(&m_critsec);
    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::RtrNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::RtrUnadvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::RtrUnadvise( LONG_PTR ulConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(ulConnection);
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::LoadRtrMgrInterfaceInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::LoadRtrMgrInterfaceInfo(HANDLE hMachine,
                                                    HANDLE hInterface,
                                                    HANDLE hIfTransport)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    DWORD        dwErr;
    SPIInfoBase    spInterfaceInfoBase;
    HRESULT        hr = hrOK;
    SPIEnumInfoBlock    spEnumBlock;
    SPIRouterInfo        spRouterInfo;
    SPIEnumRtrMgrProtocolCB    spEnumRmProtCB;
    SRtrMgrProtocolCBList    SRmProtCBList;
    InfoBlock *            pInfoBlock;
    RtrMgrProtocolCB    rmprotCB;
    SPIRtrMgrProtocolInterfaceInfo    spRmProtIf;


    //
    // If the caller doesn't want the data for the router-manager,
    // and we need to reload, use the infobase on the stack.
    // Otherwise, create an infobase to be loaded and returned to the caller
    //
    CORg( GetInfoBase(hMachine, hInterface, hIfTransport, &spInterfaceInfoBase) );

    //
    // Now we need to build the list of protocols active on this interface,
    // by examining the blocks in the interface's data.
    //
    // Get a list of the blocks in the interface info
    //
    CORg( spInterfaceInfoBase->QueryBlockList(&spEnumBlock) );

    //
    // Get a list of the routing-protocols installed
    //
    // If possible, we use the routing-protocol control-block list
    // loaded by our containing 'CRouterInfo', to save us from
    // having to load our own in order to interpret the protocols' blocks
    // inside the 'GlobalInfo'.
    //

    // Traverse back through the object hierarchy to get our RouterInfo
    // object
    if (m_pInterfaceInfoParent)
    {
        m_pInterfaceInfoParent->GetParentRouterInfo(&spRouterInfo);
    }

    if (spRouterInfo)
    {
        CORg( spRouterInfo->EnumRtrMgrProtocolCB(&spEnumRmProtCB) );
    }
    else
    {
        CORg( RouterInfo::LoadInstalledRtrMgrProtocolList(GetMachineName(),
                                              GetTransportId(),
                                              &SRmProtCBList,
                                              spRouterInfo) );
        CORg( CreateEnumFromSRmProtCBList(&SRmProtCBList, &spEnumRmProtCB) );
    }

    //
    // Go through the blocks and for each one, see if the block type
    // is the same as the protocol ID for some protocol
    //

    spEnumBlock->Reset();
    while (spEnumBlock->Next(1, &pInfoBlock, NULL) == hrOK)
    {
        //
        // When a routing protocol is removed, its block is left in place,
        // but with zero-length data.
        // We skip such blocks since they don't represent installed protocols.
        //
        if (pInfoBlock->dwSize == 0)
            continue;

        //
        // Look through the installed protocols for a protocol
        // whose ID is the same as this block's type
        //
        spEnumRmProtCB->Reset();
        while (spEnumRmProtCB->Next(1, &rmprotCB, NULL) == hrOK)
        {
            //
            // If this isn't what we're looking for, continue
            //
            if ((pInfoBlock->dwType != rmprotCB.dwProtocolId) ||
                (GetTransportId() != rmprotCB.dwTransportId))
                continue;

            //
            // This is the block we're looking for;
            // construct a CRmProtInterfaceInfo using the control block
            //
            RtrMgrProtocolInterfaceInfo *pRmProtIf = new
                RtrMgrProtocolInterfaceInfo(rmprotCB.dwProtocolId,
                                            rmprotCB.szId,
                                            GetTransportId(),
                                            rmprotCB.szRtrMgrId,
                                            GetInterfaceId(),
                                            GetInterfaceType(),
                                            this);
            spRmProtIf = pRmProtIf;
            spRmProtIf->SetFlags(RouterSnapin_InSyncWithRouter);
            pRmProtIf->m_cb.stTitle = rmprotCB.szTitle;

            //
            // Add the new protocol to our list
            //
            m_RmProtIfList.AddTail(pRmProtIf);
            pRmProtIf->AddWeakRef();
            spRmProtIf.Release();

            NotifyOfRmProtIfAdd(pRmProtIf, m_pInterfaceInfoParent);

            break;
        }
    }


Error:

    //
    // Empty the list if we got data for it
    //
    if (!SRmProtCBList.IsEmpty())
    {
        while (!SRmProtCBList.IsEmpty())
            delete SRmProtCBList.RemoveHead();        
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SaveRtrMgrInterfaceInfo
        -
        This function saves a router-manager's interface information,
        removing blocks for protocols which have been deleted,
        given an infobase derived from CInfoBase.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::SaveRtrMgrInterfaceInfo(HANDLE hMachine,
                                    HANDLE hInterface,
                                    HANDLE hIfTransport,
                                    IInfoBase *pInterfaceInfoBase,
                                    DWORD dwDeleteProtocolId)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT        hr = hrOK;
    SPIInfoBase    spIfInfoBase;
    LPBYTE pIfBytes = NULL;
    DWORD dwIfBytesSize = 0;

    //
    // If the caller wants a protocol's block to be deleted first,
    // do so before saving the data.
    //    
    if (dwDeleteProtocolId)
    {    
        //
        // If no data was given but we've been asked to delete a protocol,
        // we need to load the existing data, so that the protocol's block
        // can be removed from the infobase.
        //
        if (pInterfaceInfoBase == NULL)
        {
            CORg( CreateInfoBase(&spIfInfoBase) );
            pInterfaceInfoBase = spIfInfoBase;
            
            //
            // Retrieve the existing data
            //
            CWRg( ::MprConfigInterfaceTransportGetInfo(
                            hMachine,
                            hInterface,
                            hIfTransport,
                            &pIfBytes,
                            &dwIfBytesSize
                            ) );
            //
            // Parse the data into a list of blocks
            //
            CWRg( pInterfaceInfoBase->LoadFrom(dwIfBytesSize, pIfBytes) );
        }

        //
        // Delete the protocol specified
        //
        pInterfaceInfoBase->SetData(dwDeleteProtocolId, 0, NULL, 0, 0);
    }

    //
    // Convert the CInfoBase to a byte-array
    //
    if (pInterfaceInfoBase)
        CWRg( pInterfaceInfoBase->WriteTo(&pIfBytes, &dwIfBytesSize) );
        
    //
    // Save the information to the persistent store
    //    
    CWRg( ::MprConfigInterfaceTransportSetInfo(
                                               hMachine,
                                               hInterface,
                                               hIfTransport,
                                               pIfBytes,
                                               dwIfBytesSize
                                              ) );
    //
    // Update the info of the running router-manager
    //
    if (pInterfaceInfoBase)    
        CWRg( SetInfo(dwIfBytesSize, pIfBytes) );


    // We have now saved the information to the registry and to
    // the running router.  We now mark it as such.
    m_dwFlags |= RouterSnapin_InSyncWithRouter;
                
Error:
    CoTaskMemFree( pIfBytes );

    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::TryToConnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::TryToConnect(LPCWSTR pswzMachine, HANDLE *phMachine)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    
    if (m_hMachineConfig)
        *phMachine = m_hMachineConfig;
    else if (*phMachine)
    {
        m_hMachineConfig = *phMachine;
        m_bDisconnect = FALSE;
    }
    else
    {
        //$ Review: kennt, this function does not take a LPCWSTR,
        // is this a mistake or does it modify the parameters?
        CWRg( ::MprConfigServerConnect((LPWSTR) pswzMachine, phMachine) );
        m_hMachineConfig = *phMachine;
        m_bDisconnect = TRUE;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::NotifyOfRmProtIfAdd
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::NotifyOfRmProtIfAdd(IRtrMgrProtocolInterfaceInfo *pRmProtIf,
    IInterfaceInfo *pParentIf)
{
    HRESULT     hr = hrOK;
    
    m_AdviseList.NotifyChange(ROUTER_CHILD_ADD, ROUTER_OBJ_RmProtIf, 0);

    // Also notify the RtrMgrProtocol object that interfaces have
    // been added.
    if (pParentIf)
    {
        SPIRouterInfo    spRouterInfo;
        SPIRtrMgrProtocolInfo    spRmProtInfo;
        HRESULT            hrT;    // this hr is ignored
        
        // If these calls fail, it doesn't matter the operation still
        // is considered successful
        hrT = pParentIf->GetParentRouterInfo(&spRouterInfo);
        
        if (FHrSucceeded(hrT))
        {
            hrT = LookupRtrMgrProtocol(spRouterInfo,
                                       pRmProtIf->GetTransportId(),
                                       pRmProtIf->GetProtocolId(),
                                       &spRmProtInfo);
        }
        if (FHrOK(hrT))
            hrT = spRmProtInfo->RtrNotify(ROUTER_CHILD_ADD,
                                          ROUTER_OBJ_RmProtIf, 0);
    }

    return hr;
    
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::TryToGetIfHandle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::TryToGetIfHandle(HANDLE hMachine,
                                              LPCWSTR pswzInterface,
                                              HANDLE *phInterface)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    
    if (m_hInterface)
        *phInterface = m_hInterface;
    else if (*phInterface)
        m_hInterface = *phInterface;
    else
    {
        //
        // Get a handle to the interface
        //
        CWRg(::MprConfigInterfaceGetHandle(hMachine,
                                           (LPWSTR) pswzInterface,
                                           phInterface
                                          ) );
        m_hInterface = *phInterface;
    }
Error:
    return hr;
}
                                        



/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::GetParentInterfaceInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::GetParentInterfaceInfo(IInterfaceInfo **ppParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    *ppParent = m_pInterfaceInfoParent;
    if (*ppParent)
        (*ppParent)->AddRef();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::SetParentInterfaceInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::SetParentInterfaceInfo(IInterfaceInfo *pParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IInterfaceInfo *    pTemp;
    
    pTemp = m_pInterfaceInfoParent;
    m_pInterfaceInfoParent = NULL;
    
    if (m_fStrongRef)
    {
        if (pTemp)
            pTemp->Release();
        if (pParent)
            pParent->AddRef();
    }
    else
    {
        if (pTemp)
            pTemp->ReleaseWeakRef();
        if (pParent)
            pParent->AddWeakRef();
    }
    m_pInterfaceInfoParent = pParent;

    return hrOK;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::Disconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrMgrInterfaceInfo::Disconnect()
{
    if (m_bDisconnect && m_hMachineConfig)
        ::MprConfigServerDisconnect(m_hMachineConfig);
    
    m_bDisconnect = FALSE;
    m_hMachineConfig = NULL;
    m_hInterface = NULL;
    m_hIfTransport = NULL;
}

/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::DoDisconnect
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrInterfaceInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;
    SPIEnumRtrMgrProtocolInterfaceInfo    spEnumRmProtIf;
    SPIRtrMgrProtocolInterfaceInfo        spRmProtIf;

    COM_PROTECT_TRY
    {
        // Disconnect our data.
        // ------------------------------------------------------------
        Disconnect();

        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);

        // Now tell all child objects to disconnect.
        // ------------------------------------------------------------
        HRESULT            hrIter = hrOK;

        EnumRtrMgrProtocolInterface(&spEnumRmProtIf);
        spEnumRmProtIf->Reset();
        while (spEnumRmProtIf->Next(1, &spRmProtIf, NULL) == hrOK)
        {
            spRmProtIf->DoDisconnect();
            spRmProtIf.Release();
        }
        
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RtrMgrInterfaceInfo::TryToGetAllHandles
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrMgrInterfaceInfo::TryToGetAllHandles(LPCOLESTR pszMachine,
                                                HANDLE *phMachine,
                                                HANDLE *phInterface,
                                                HANDLE *phTransport)
{
    HRESULT     hr = hrOK;


    Assert(phMachine);
    Assert(phInterface);
    
    //
    // If already loaded, the handle passed in is ignored.
    //
    // Otherwise, if 'hMachine' was not specified, connect to the config
    // on the specified machine
    //
    CORg( TryToConnect(pszMachine, phMachine) );
        
    //
    // If already loaded, the handle passed in is ignored;
    //
    // Otherwise, if 'hInterface' was not specified,
    // get the interface handle
    //
    CORg( TryToGetIfHandle(*phMachine, GetInterfaceId(), phInterface) );
    
    //
    // Get a handle to the interface-transport
    //

    //
    // If 'hIfTransport' was not specified, connect
    //
    if (phTransport)
    {
        if (m_hIfTransport)
            *phTransport = m_hIfTransport;
        else if (*phTransport)
            m_hIfTransport = *phTransport;
        else
        {
            //
            // Get a handle to the interface-transport
            //
            CWRg( ::MprConfigInterfaceTransportGetHandle(
                *phMachine,
                *phInterface,
                GetTransportId(),
                phTransport
                ) );
            m_hIfTransport = *phTransport;
        }
    }

Error:
    return hr;
}



/*---------------------------------------------------------------------------
    IRtrMgrProtocolInterfaceInfo Implementation
 ---------------------------------------------------------------------------*/

TFSCORE_API(HRESULT)    CreateRtrMgrProtocolInterfaceInfo(
                            IRtrMgrProtocolInterfaceInfo **ppRmProtIfInfo,
                            const RtrMgrProtocolInterfaceCB *pRmProtIfCB)
{
    Assert(ppRmProtIfInfo);
    Assert(pRmProtIfCB);

    HRESULT    hr = hrOK;
    IRtrMgrProtocolInterfaceInfo *    pRmProtIf = NULL;
    USES_CONVERSION;

    COM_PROTECT_TRY
    {
        *ppRmProtIfInfo = new RtrMgrProtocolInterfaceInfo(
                                pRmProtIfCB->dwProtocolId,
                                W2CT(pRmProtIfCB->szId),
                                pRmProtIfCB->dwTransportId,
                                W2CT(pRmProtIfCB->szRtrMgrId),
                                W2CT(pRmProtIfCB->szInterfaceId),
                                pRmProtIfCB->dwIfType,
                                NULL);
    }
    COM_PROTECT_CATCH;

    return hr;
}


IMPLEMENT_WEAKREF_ADDREF_RELEASE(RtrMgrProtocolInterfaceInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(RtrMgrProtocolInterfaceInfo, IRtrMgrProtocolInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfo)

RtrMgrProtocolInterfaceInfo::RtrMgrProtocolInterfaceInfo(DWORD dwProtocolId,
                                        LPCTSTR pszId,
                                        DWORD dwTransportId,
                                        LPCTSTR pszRmId,
                                        LPCTSTR pszIfId,
                                        DWORD dwIfType,
                                        RtrMgrInterfaceInfo *pRmIf)
    : m_dwFlags(0)
{
    m_cb.dwProtocolId = dwProtocolId;
    m_cb.stId = pszId;
    m_cb.dwTransportId = dwTransportId;
    m_cb.stRtrMgrId = pszRmId;
    m_cb.stInterfaceId = pszIfId;
    m_cb.dwIfType = dwIfType;
    
    DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfo);

    m_pRtrMgrInterfaceInfoParent = pRmIf;
    if (m_pRtrMgrInterfaceInfoParent)
        m_pRtrMgrInterfaceInfoParent->AddRef();

    InitializeCriticalSection(&m_critsec);
}

RtrMgrProtocolInterfaceInfo::~RtrMgrProtocolInterfaceInfo()
{
    Assert(m_pRtrMgrInterfaceInfoParent == NULL);
    Destruct();
    DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfo);

    DeleteCriticalSection(&m_critsec);
}

void RtrMgrProtocolInterfaceInfo::ReviveStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRtrMgrInterfaceInfoParent)
    {
        CONVERT_TO_STRONGREF(m_pRtrMgrInterfaceInfoParent);
    }
}

void RtrMgrProtocolInterfaceInfo::OnLastStrongRef()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    if (m_pRtrMgrInterfaceInfoParent)
    {
        CONVERT_TO_WEAKREF(m_pRtrMgrInterfaceInfoParent);
    }
    if (m_fDestruct)
        Destruct();
}

STDMETHODIMP RtrMgrProtocolInterfaceInfo::Destruct()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRtrMgrInterfaceInfo *    pParent;
    m_fDestruct = TRUE;
    if (!m_fStrongRef)
    {
        pParent = m_pRtrMgrInterfaceInfoParent;
        m_pRtrMgrInterfaceInfoParent = NULL;
        if (pParent)
            pParent->ReleaseWeakRef();

//        Unload();
    }
    return hrOK;
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfo::GetFlags()
{
     RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_dwFlags;
}

STDMETHODIMP RtrMgrProtocolInterfaceInfo::SetFlags(DWORD dwFlags)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_dwFlags = dwFlags;
    }
    COM_PROTECT_CATCH;
    return hr;    
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetProtocolId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfo::GetProtocolId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwProtocolId;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetTransportId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfo::GetTransportId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwTransportId;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetInterfaceId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInterfaceInfo::GetInterfaceId()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.stInterfaceId;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetInterfaceType
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfo::GetInterfaceType()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.dwIfType;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInterfaceInfo::GetTitle()
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_cb.stTitle;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::SetTitle
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::SetTitle(LPCOLESTR pszTitle)
{
    //$UNICODE
    // This assumes that we are native UNICODE
    // and that OLECHAR == WCHAR
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        m_cb.stTitle = pszTitle;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::CopyCB
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::CopyCB(RtrMgrProtocolInterfaceCB * pRmProtCB)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_cb.SaveTo(pRmProtCB);
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::RtrAdvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
                       LONG_PTR *pulConnection, LPARAM lUserParam)
{
    Assert(pRtrAdviseSink);
    Assert(pulConnection);

    RtrCriticalSection    rtrCritSec(&m_critsec);
    LONG_PTR    ulConnId;
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        ulConnId = (LONG_PTR) InterlockedIncrement(&s_cConnections);

        CORg( m_AdviseList.AddConnection(pRtrAdviseSink, ulConnId, lUserParam) );
        
        *pulConnection = ulConnId;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::RtrNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::RtrNotify(DWORD dwChangeType, DWORD dwObjectType,
                                  LPARAM lParam)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        m_AdviseList.NotifyChange(dwChangeType, dwObjectType, lParam);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::RtrUnadvise
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::RtrUnadvise( LONG_PTR ulConnection)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    return m_AdviseList.RemoveConnection(ulConnection);
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::GetParentRtrMgrInterfaceInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::GetParentRtrMgrInterfaceInfo( IRtrMgrInterfaceInfo **ppParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    HRESULT    hr = hrOK;
    COM_PROTECT_TRY
    {
        *ppParent = m_pRtrMgrInterfaceInfoParent;
        if (*ppParent)
            (*ppParent)->AddRef();
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrMgrProtocolInterfaceInfo::SetParentRtrMgrInterfaceInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RtrMgrProtocolInterfaceInfo::SetParentRtrMgrInterfaceInfo(IRtrMgrInterfaceInfo *pParent)
{
    RtrCriticalSection    rtrCritSec(&m_critsec);
    IRtrMgrInterfaceInfo *    pTemp;
    
    pTemp = m_pRtrMgrInterfaceInfoParent;
    m_pRtrMgrInterfaceInfoParent = NULL;
    
    if (m_fStrongRef)
    {
        if (pTemp)
            pTemp->Release();
        if (pParent)
            pParent->AddRef();
    }
    else
    {
        if (pTemp)
            pTemp->ReleaseWeakRef();
        if (pParent)
            pParent->AddWeakRef();
    }
    m_pRtrMgrInterfaceInfoParent = pParent;

    return hrOK;
}

void RtrMgrProtocolInterfaceInfo::Disconnect()
{
}

STDMETHODIMP RtrMgrProtocolInterfaceInfo::DoDisconnect()
{
    HRESULT        hr = hrOK;

    COM_PROTECT_TRY
    {
        // Disconnect our data.
        // ------------------------------------------------------------
        Disconnect();

        // Notify the advise sinks of a disconnect.
        // ------------------------------------------------------------
        RtrNotify(ROUTER_DO_DISCONNECT, 0, 0);
    }
    COM_PROTECT_CATCH;
    return hr;
}





/*!--------------------------------------------------------------------------
    LoadInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) LoadInfoBase(HANDLE        hMachine,
                                  HANDLE        hTransport,
                                  IInfoBase **ppGlobalInfo,
                                  IInfoBase **ppClientInfo)
{
    HRESULT        hr = hrOK;
    SPIInfoBase    spGlobalInfo;
    SPIInfoBase    spClientInfo;
    DWORD        dwGlobalBytesSize, dwClientBytesSize;
    BYTE *        pGlobalBytes = NULL;
    BYTE *        pClientBytes = NULL;
    
    COM_PROTECT_TRY
    {
        if (ppGlobalInfo)
            CORg( CreateInfoBase(&spGlobalInfo) );

        if (ppClientInfo)
            CORg( CreateInfoBase(&spClientInfo) );

        
        //
        // Retrieve information for the transport
        //
        CWRg( ::MprConfigTransportGetInfo(
                                    hMachine,
                                    hTransport,
                                    spGlobalInfo ? &pGlobalBytes : NULL,
                                    spGlobalInfo ? &dwGlobalBytesSize : NULL,
                                    spClientInfo ? &pClientBytes : NULL,
                                    spClientInfo ? &dwClientBytesSize : NULL,
                                    NULL
                                    ));

        //
        // Load the global info for the router-manager
        //
        if (spGlobalInfo)
        {
            CWRg( spGlobalInfo->LoadFrom(dwGlobalBytesSize, pGlobalBytes) );
        }

        //
        // Load the client info for the router-manager
        //
        if (spClientInfo)
        {
            CWRg( spClientInfo->LoadFrom(dwClientBytesSize, pClientBytes) );
        }

        if (ppGlobalInfo)
            *ppGlobalInfo = spGlobalInfo.Transfer();

        if (ppClientInfo)
            *ppClientInfo = spClientInfo.Transfer();

        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    
    if (pGlobalBytes) { ::MprConfigBufferFree(pGlobalBytes); }
    if (pClientBytes) { ::MprConfigBufferFree(pClientBytes); }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ifadmin.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ifadmin.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _IFADMIN_H
#define _IFADMIN_H


#include <iprtrmib.h>
#include <ipinfoid.h>
#include <rtmv2.h>

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H_
#include "handlers.h"
#endif

#ifndef _ROUTER_H
#include "router.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"
#endif

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef __IPCTRL_H
#include "ipctrl.h"
#endif

#include "rasdlg.h"



#define MPR_INTERFACE_NOT_LOADED		0x00010000


#ifdef UNICODE
    #define SZROUTERENTRYDLG    "RouterEntryDlgW"
#else
    #define SZROUTERENTRYDLG    "RouterEntryDlgA"
#endif


//
//These structures are same as in rasdlg ifw.c
//Eventually they need to move into a common header
//file.
//


#define SROUTEINFO struct tagSROUTEINFO
SROUTEINFO
{
    TCHAR * pszDestIP;
    TCHAR * pszNetworkMask;
    TCHAR * pszMetric;
};

#define SROUTEINFOLIST struct tagSROUTEINFOLIST
SROUTEINFOLIST
{
    SROUTEINFOLIST * pNext;
    SROUTEINFO       RouteInfo;
};

HRESULT AddStaticRoute(MIB_IPFORWARDROW * pNewForwardRow,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock,
                                       DWORD dwItemCount);


// forward declarations
class RouterAdminConfigStream;
interface IRouterInfo;
struct ColumnData;

/*---------------------------------------------------------------------------
	Things needed for the Add Interface command
 ---------------------------------------------------------------------------*/
typedef DWORD (APIENTRY * PROUTERENTRYDLG) (LPTSTR, LPTSTR, LPTSTR, LPRASENTRYDLG);



/*---------------------------------------------------------------------------
	Struct:	IfAdminNodeData
	This is information related to the set of interfaces (not per-interface),
	this is intended for SHARED data.

	Put data in here that needs to be accessed by the child nodes.  All other
	private data should go in the handler.
 ---------------------------------------------------------------------------*/

struct IfAdminNodeData
{
	IfAdminNodeData();
	~IfAdminNodeData();
#ifdef DEBUG
	char	m_szDebug[32];	// for iding structures
#endif

	// The following pieces of data are needed for adding/configuring
	// an interface.  This is a COPY of the data kept in the IfAdminNodeHandler,
	// do NOT free these up! 
	HINSTANCE		m_hInstRasDlg;
	PROUTERENTRYDLG	m_pfnRouterEntryDlg;

	static	HRESULT InitAdminNodeData(ITFSNode *pNode, RouterAdminConfigStream *pConfigStream);
	static	HRESULT	FreeAdminNodeData(ITFSNode *pNode);
};

#define GET_IFADMINNODEDATA(pNode) \
						((IfAdminNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_IFADMINNODEDATA(pNode, pData) \
						pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	This is the list of columns available for the Interfaces node
		- Title, "[1] DEC DE500 Fast Ethernet PCI Adapter" or friendly name
		- Device Name, see above
		- Type, "Dedicated"
		- Status, "Enabled"
		- Connection State, "Connected"
 ---------------------------------------------------------------------------*/
enum
{
	IFADMIN_SUBITEM_TITLE = 0,
	IFADMIN_SUBITEM_TYPE = 1,
	IFADMIN_SUBITEM_STATUS = 2,
	IFADMIN_SUBITEM_CONNECTION_STATE = 3,
	IFADMIN_SUBITEM_DEVICE_NAME = 4,
	IFADMIN_MAX_COLUMNS = 5,
};



/*---------------------------------------------------------------------------
	Class:	IfAdminNodeHandler

 ---------------------------------------------------------------------------*/
class IfAdminNodeHandler :
   public BaseContainerHandler
{
public:
	IfAdminNodeHandler(ITFSComponentData *pCompData);

	HRESULT	Init(IRouterInfo *pInfo, RouterAdminConfigStream *pConfigStream);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_DestroyHandler();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_OnCreateDataObject();

	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();

	// override handler notifications
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseResultHandlerNotify_OnResultShow();

	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode);

	// User-initiated commands
	HRESULT OnAddInterface();
	
#ifdef KSL_IPINIP
    HRESULT OnNewTunnel();
#endif //KSL_IPINIP

	HRESULT OnUseDemandDialWizard();

	// Helper function to add interfaces to the UI
	HRESULT	AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf);

	// Causes a sync action (synchronizes data not the structure)
	HRESULT SynchronizeNodeData(ITFSNode *pNode);

	static HRESULT	GetPhoneBookPath(LPCTSTR pszMachine, CString* pstPath);
protected:
	SPIDataObject	m_spDataObject;	// cachecd data object
	CString			m_stTitle;		// holds the title of the node
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId; // id for refresh notifications
	BOOL			m_bExpanded;	// is the node expanded?
	MMC_COOKIE		m_cookie;		// cookie for the node

	// Necessary for adding interfaces
	// Keep these in sync with the values in the IfAdminNodeData!
	HINSTANCE		m_hInstRasDlg;
	PROUTERENTRYDLG	m_pfnRouterEntryDlg;

	BOOL			EnableAddInterface();

	// Helper function to add an interface to a router-manager
	HRESULT			AddRouterManagerToInterface(IInterfaceInfo *pIf,
												IRouterInfo *pRouter,
												DWORD dwTransportId);

	// returns TRUE if there is at least one routing-enabled port
	// on the router.
	BOOL			FLookForRoutingEnabledPorts(LPCTSTR pszMachineName);

	RouterAdminConfigStream *	m_pConfigStream;

};


HRESULT GetDemandDialWizardRegKey(LPCTSTR szMachine, DWORD *pfWizard);
HRESULT SetDemandDialWizardRegKey(LPCTSTR szMachine, DWORD fEnableWizard);

#ifdef KSL_IPINIP
/*---------------------------------------------------------------------------
	Class :	TunnelDialog
 ---------------------------------------------------------------------------*/

class TunnelDialog : public CBaseDialog
{
public:
	TunnelDialog();
	~TunnelDialog();

// Dialog Data
	//{{AFX_DATA(TunnelDialog)
	enum { IDD = IDD_TUNNEL };
//	IPControl		m_ipLocal;
//	IPControl		m_ipRemote;
//	CSpinButtonCtrl	m_spinTTL;
	//}}AFX_DATA

//	DWORD	m_dwLocal;
//	DWORD	m_dwRemote;
//	BYTE	m_byteTTL;
	CString	m_stName;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(TunnelDialog)
public:
	virtual void OnOK();
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(TunnelDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
};

#endif //KSL_IPINIP


#endif _IFADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\infobase.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    infobase.cpp
//
// History:
//  Abolade Gbadegesin      Feb. 10, 1996   Created.
//
//  V. Raman                Nov. 1, 1996
//                          Fixed alignment code in
//                          CInfoBase::BlockListToArray
//
//	Kenn Takara				June 3, 1997
//							Wrapped code with a COM object wrapper.
//
// This file contains code for the CInfoBase class as well as
// the Router registry-parsing classes.
//============================================================================

#include "stdafx.h"
#include "globals.h"		// holds the various string constants

extern "C" {
#include <rtinfo.h>
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//----------------------------------------------------------------------------
// Class:   CInfoBase
//
// This function handles loading and saving of multi-block structures
// stored in the registry by the router managers.
//
// The data are saved as REG_BINARY values, and are manipulated using
// the RTR_INFO_BLOCK_HEADER structure as a template.
//----------------------------------------------------------------------------

class CInfoBase : public CObject {

    protected:

        IfDebug(DECLARE_DYNAMIC(CInfoBase))

    public:

        CInfoBase();
        ~CInfoBase();

        //--------------------------------------------------------------------
        // Registry-access methods
        //
        //--------------------------------------------------------------------

        //--------------------------------------------------------------------
        // Function:    Load
        //
        // Loads value named 'pszValue' from subkey 'pszKey' of 'hkey'
        //--------------------------------------------------------------------

        HRESULT
        Load(
            IN      HKEY    hkey,
            IN      LPCTSTR pszKey,
            IN      LPCTSTR pszValue );


        //--------------------------------------------------------------------
        // Function:    Save
        //
        // saves value named 'pszValue' to subkey 'pszKey' of 'hkey';
        // 'pszKey' cannot be a path
        //--------------------------------------------------------------------

        HRESULT
        Save(
            IN      HKEY    hkey,
            IN      LPCTSTR pszKey,
            IN      LPCTSTR pszValue );


        //--------------------------------------------------------------------
        // Function:    Unload
        //
        // unloads current infobase contents
        //--------------------------------------------------------------------

        HRESULT
        Unload( );



        //--------------------------------------------------------------------
        // Function:    CopyFrom
        //
        // copies contents of infobase 'src'
        //--------------------------------------------------------------------

        HRESULT
        CopyFrom(
                 IN IInfoBase *pSrc);


        //--------------------------------------------------------------------
        // Function:    LoadFrom
        //
        // loads from byte-array 'pBase'
        //--------------------------------------------------------------------

        HRESULT
        LoadFrom(
            IN      PBYTE   pBase,
            IN      DWORD   dwSize = 0 )
            { Unload(); return ArrayToBlockList(pBase, dwSize); }


        //--------------------------------------------------------------------
        // Function:    WriteTo
        //
        // sets 'pBase' to point to allocated memory into which
        // opaque info is written; saves size of '*pBase' in 'dwSize'
        //--------------------------------------------------------------------

        HRESULT
        WriteTo(
            OUT     PBYTE&  pBase,
            OUT     DWORD&  dwSize )
            {
			return BlockListToArray(pBase, dwSize);
			}


        //--------------------------------------------------------------------
        // Structure manipulation methods
        //
        //--------------------------------------------------------------------

        //--------------------------------------------------------------------
        // Function:    GetBlock
        //
        // retrieves 'dwNth' block of type 'dwType' from the list of blocks
        //--------------------------------------------------------------------

        HRESULT
        GetBlock(
            IN      DWORD           dwType,
            OUT     InfoBlock*&    pBlock,
            IN      DWORD           dwNth = 0 );


        //--------------------------------------------------------------------
        // Function:    SetBlock
        //
        // Replaces 'dwNth' block of type 'dwType' with a copy of 'pBlock'.
        // Note that this copies the data for the block from 'pBlock->pData'.
        //--------------------------------------------------------------------

        HRESULT
        SetBlock(
            IN      DWORD       dwType,
            IN      InfoBlock* pBlock,
            IN      DWORD       dwNth = 0 );


        //--------------------------------------------------------------------
        // Function:    AddBlock
        //
        // Add's a new block of type 'dwType' to the list of blocks
        //--------------------------------------------------------------------

        HRESULT
        AddBlock(
            IN      DWORD       dwType,
            IN      DWORD       dwSize,
            IN      PBYTE       pData,
            IN      DWORD       dwCount = 1,
            IN      BOOL        bRemoveFirst    = FALSE );


        //--------------------------------------------------------------------
        // Function:    GetData
        //
        // Retrieves the data for the 'dwNth' block of type 'dwType'.
        //--------------------------------------------------------------------

        PBYTE
        GetData(
            IN      DWORD       dwType,
            IN      DWORD       dwNth = 0 );


        //--------------------------------------------------------------------
        // Function:    SetData
        //
        // Replaces the data for the 'dwNth' block of type 'dwType'.
        // Note that this does not copy 'pData'; the block is changed
        // to point to 'pData', and thus 'pData' should not be a pointer
        // to data on the stack, and it should not be deleted.
        // Furthermore, it must have been allocated using 'new'.
        //--------------------------------------------------------------------

        HRESULT
        SetData(
            IN      DWORD       dwType,
            IN      DWORD       dwSize,
            IN      PBYTE       pData,
            IN      DWORD       dwCount = 1,
            IN      DWORD       dwNth = 0 );


        //--------------------------------------------------------------------
        // Function:    RemoveBlock
        //
        // Removes the 'dwNth' block of type 'dwType' from the list of blocks.
        //--------------------------------------------------------------------

        HRESULT
        RemoveBlock(
            IN      DWORD       dwType,
            IN      DWORD       dwNth = 0 );


        //--------------------------------------------------------------------
        // Function:    BlockExists
        //
        // Returns TRUE is a block of the specified type is in the block-list,
        // FALSE otherwise
        //--------------------------------------------------------------------

        BOOL
        BlockExists(
            IN      DWORD       dwType
            ) {

            InfoBlock *pblock;

            return (GetBlock(dwType, pblock) == NO_ERROR);
        }



        //--------------------------------------------------------------------
        // Function:    ProtocolExists
        //
        // Returns TRUE if the given routing-protocol exists in the info-base;
        // this is so if the block is present and non-empty.
        //--------------------------------------------------------------------

        BOOL
        ProtocolExists(
            IN      DWORD       dwProtocol
            ) {

            InfoBlock *pblock;

            return (!GetBlock(dwProtocol, pblock) && pblock->dwSize);
        }



        //--------------------------------------------------------------------
        // Function:    RemoveAllBlocks
        //
        // Removes all blocks from the list of blocks.
        //--------------------------------------------------------------------

        HRESULT
        RemoveAllBlocks( ) { return Unload(); }


        //--------------------------------------------------------------------
        // Function:    QueryBlockList
        //
        // Returns a reference to the list of blocks;
        // the returned list contains items of type 'InfoBlock',
        // and the list must not be modified.
        //--------------------------------------------------------------------

        CPtrList&
        QueryBlockList( ) { return m_lBlocks; }


        //--------------------------------------------------------------------
        // Function:    GetInfo
        //
		// Returns information about the infobase.  This is useful for
		// determining if this is a new infobase or not.
		//
		// Returns the size (in bytes) of the InfoBase as well as the
		// number of blocks.
        //--------------------------------------------------------------------
		HRESULT
		GetInfo(DWORD *pcSize, int *pcBlocks);

    protected:

        PBYTE           m_pBase;        // opaque block of bytes loaded
        DWORD           m_dwSize;       // size of m_pBase
        CPtrList        m_lBlocks;      // list of blocks of type InfoBlock


        //--------------------------------------------------------------------
        // Functions:   BlockListToArray
        //              ArrayToBlockList
        //
        // These functions handle parsing opaque data into block-lists
        // and combining blocks into opaque data.
        //--------------------------------------------------------------------

        HRESULT
        BlockListToArray(
            IN      PBYTE&  pBase,
            IN      DWORD&  dwSize );

        HRESULT
        ArrayToBlockList(
            IN      PBYTE   pBase,
            IN      DWORD   dwSize );

#ifdef _DEBUG
		BOOL			m_fLoaded;	// TRUE if data was loaded
#endif
};



//---------------------------------------------------------------------------
// Class:       CInfoBase
//---------------------------------------------------------------------------

IfDebug(IMPLEMENT_DYNAMIC(CInfoBase, CObject));


//---------------------------------------------------------------------------
// Function:    CInfoBase::CInfoBase
//
// minimal contructor
//---------------------------------------------------------------------------

CInfoBase::CInfoBase()
: m_pBase(NULL), m_dwSize(0)
#ifdef _DEBUG
	, m_fLoaded(FALSE)
#endif
{ }



//---------------------------------------------------------------------------
// Function:    CInfoBase::CInfoBase
//
// destructor.
//---------------------------------------------------------------------------

CInfoBase::~CInfoBase() { Unload(); }



//---------------------------------------------------------------------------
// Function:    CInfoBase::CopyFrom
//
// Copies the contents of the given CInfoBase
//---------------------------------------------------------------------------

HRESULT
CInfoBase::CopyFrom(
                    IN IInfoBase *pSrc
    ) {
    SPIEnumInfoBlock    spEnumInfoBlock;
    InfoBlock * pbsrc = NULL;
    InfoBlock * pbdst = NULL;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		// Unload the current information, if any
		Unload();

		// go through the source's blocks copying each one
        pSrc->QueryBlockList(&spEnumInfoBlock);
        if (spEnumInfoBlock == NULL)
            goto Error;

        spEnumInfoBlock->Reset();

        while (hrOK == spEnumInfoBlock->Next(1, &pbsrc, NULL))
        {
			// allocate space for the copy
			pbdst = new InfoBlock;
			Assert(pbdst);
			
			// copy the fields from the source
			pbdst->dwType = pbsrc->dwType;
			pbdst->dwSize = pbsrc->dwSize;
			pbdst->dwCount = pbsrc->dwCount;
			
			// allocate space for a copy of the data
			pbdst->pData = NULL;
			pbdst->pData = new BYTE[pbsrc->dwSize * pbsrc->dwCount];
			Assert(pbdst->pData);
			
			// copy the data
			::CopyMemory(pbdst->pData, pbsrc->pData,
						 pbsrc->dwSize * pbsrc->dwCount);
			
			// add the copy to our list of blocks
			m_lBlocks.AddTail(pbdst);
			pbdst = NULL;
		}

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
		
	// if something went wrong, make certain we're unloaded
	if (!FHrSucceeded(hr))
	{
		if (pbdst)
			delete pbdst->pData;
		delete pbdst;
		Unload();
	}

#ifdef _DEBUG
	if (FHrSucceeded(hr))
		m_fLoaded = TRUE;
#endif

    return hr;
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::Load
//
// Loads the infobase from the specified registry path.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::Load(
    IN  HKEY    hkey,
    IN  LPCTSTR pszSubKey,
    IN  LPCTSTR pszValue
    ) {

    PBYTE pBase = NULL;
    DWORD dwErr, dwSize, dwType;
	RegKey	regsubkey;			// hold subkey that has to be freed
	RegKey	regkey;				// holds key, must NOT be closed
	HRESULT		hr = hrOK;

    if (pszSubKey && StrLen(pszSubKey))
	{
        HKEY hkTemp = hkey;

		dwErr = regsubkey.Open(hkTemp, pszSubKey, KEY_READ);
        if (dwErr != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(dwErr);

		// We use this as THE key.  However, since this key is attached
		// to a RegKey, it will get cleaned up on exit/thrown exception.
		hkey = (HKEY) regsubkey;
    }

	COM_PROTECT_TRY
	{
		do {
			// This regkey is used to utilize the class. Do NOT
			// close this regkey (it may be the key that was passed into us).
			regkey.Attach(hkey);
			
			// query the value specified for its size and type
			dwSize = 0;
			dwType = 0;
			dwErr = regkey.QueryTypeAndSize(pszValue, &dwType, &dwSize);
			if (dwErr != ERROR_SUCCESS)
				break;
			
			//$ Review: kennt, if the key is not the correct type
			// what error code do we want to return?
			if (dwErr != ERROR_SUCCESS || dwType != REG_BINARY)
				break;
			
			pBase = new BYTE[dwSize];
			Assert(pBase);

			// get the actual data
			dwErr = regkey.QueryValue(pszValue, (LPVOID) pBase, dwSize);
			if (dwErr != ERROR_SUCCESS)
				break;
			
			// convert the infobase into a list of blocks
			dwErr = ArrayToBlockList(pBase, dwSize);
			
		} while(FALSE);

		hr = HRESULT_FROM_WIN32(dwErr);
		
	}
	COM_PROTECT_CATCH;

	// free the memory allocated for the block
	delete [] pBase;

	// we do NOT want this key closed
	regkey.Detach();
		
    return hr;
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::Unload
//
// frees resources used by infoblocks.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::Unload(
    ) {


    //
    // go through the list of blocks, deleting each one
    //

    while (!m_lBlocks.IsEmpty()) {

        InfoBlock *pBlock = (InfoBlock *)m_lBlocks.RemoveHead();
        if (pBlock->pData) { delete [] pBlock->pData; }
        delete pBlock;
    }


    //
    // if we have a copy of the opaque data, free that too
    //

    if (m_pBase) { delete [] m_pBase; m_pBase = NULL; m_dwSize = 0; }

    return HRESULT_FROM_WIN32(NO_ERROR);
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::Save
//
// Saves the list of blocks as an infobase in the registry.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::Save(
    IN  HKEY    hkey,
    IN  LPCTSTR pszSubKey,
    IN  LPCTSTR pszValue
    ) {
    PBYTE pBase = NULL;
    DWORD dwErr, dwSize;
	RegKey	regsubkey;			// hold subkey that has to be freed
	RegKey	regkey;				// holds key, must NOT be closed
	HRESULT	hr = hrOK;

    // create/open the key specified
    if (pszSubKey && lstrlen(pszSubKey))
	{
		dwErr = regsubkey.Create(hkey, pszSubKey,
								 REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (dwErr != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(dwErr);

		// This subkey will get closed by the regsubkey destructor
		hkey = (HKEY) regsubkey;
    }


	COM_PROTECT_TRY
	{
		do {

			regkey.Attach(hkey);

			// convert our list of blocks into one block of data
			dwErr = BlockListToArray(pBase, dwSize);
			if (dwErr != NO_ERROR) { pBase = NULL; break; }

			if (!pBase || !dwSize) { break; }
			
			// attempt to set the value
			dwErr = regkey.SetValue(pszValue, (LPVOID) pBase, dwSize);
			if (dwErr != ERROR_SUCCESS) { break; }
						
		} while(FALSE);

		hr = HRESULT_FROM_WIN32(dwErr);
	}
	COM_PROTECT_CATCH;

	regkey.Detach();
		
	delete [] pBase;

    return hr;
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::GetBlock
//
// Retrieves a block of data of the specified type
// from the currently loaded infobase.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::GetBlock(
    IN  DWORD           dwType,
    OUT InfoBlock*&    pBlock,
    IN  DWORD           dwNth
    ) {

    POSITION pos;
    InfoBlock *pib;

    // start at the head of the list, and look for the block requested
    pos = m_lBlocks.GetHeadPosition();

    while (pos)
	{
        // retrieve the next block
        pib = (InfoBlock *)m_lBlocks.GetNext(pos);

        if (pib->dwType != dwType) { continue; }

        if (dwNth-- != 0) { continue; }

        // this is the block requested
        pBlock = pib;

        return HRESULT_FROM_WIN32(NO_ERROR);
    }

	pBlock = NULL;
    return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::SetBlock
//
// Sets a block of data of the specified type to a copy of the given data
// in the currently loaded infobase.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::SetBlock(
    IN  DWORD       dwType,
    IN  InfoBlock* pBlock,
    IN  DWORD       dwNth
    ) {

    DWORD dwErr;
	HRESULT	hr;
    PBYTE pData;
    InfoBlock *pib;

    // retrieve the block to be modified
    hr = GetBlock(dwType, pib, dwNth);
	if (!FHrSucceeded(hr))
		return hr;

    // modify the contents
    if (pBlock->dwSize == 0) { pData = NULL; }
    else
	{
        // allocate space for the new data
        pData = new BYTE[pBlock->dwSize * pBlock->dwCount];
		Assert(pData);

        ::CopyMemory(pData, pBlock->pData, pBlock->dwSize * pBlock->dwCount);
    }


    // if any space was allocated before, free it now
    if (pib->pData) { delete [] pib->pData; }

    // set the blocks new contents
    *pib = *pBlock;
    pib->pData = pData;

    return HRESULT_FROM_WIN32(NO_ERROR);
}


//--------------------------------------------------------------------
// Function:    GetData
//
// Retrieves the data for the 'dwNth' block of type 'dwType'.
//--------------------------------------------------------------------

PBYTE
CInfoBase::GetData(
    IN  DWORD   dwType,
    IN  DWORD   dwNth
    ) {

    InfoBlock* pblock;

	if (!FHrSucceeded(GetBlock(dwType, pblock, dwNth)))
		return NULL;

    return pblock->pData;
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::SetData
//
// Sets the data for an existing block.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::SetData(
    IN  DWORD   dwType,
    IN  DWORD   dwSize,
    IN  PBYTE   pData,
    IN  DWORD   dwCount,
    IN  DWORD   dwNth
    ) {

    DWORD dwErr;
    InfoBlock *pib;
	HRESULT	hr;

    //
    // retrieve the block to be modified
    //

    hr = GetBlock(dwType, pib, dwNth);
	
	if (!FHrSucceeded(hr)) { return hr; }


    //
    // modify the data
    //

    if (pib->pData) { delete [] pib->pData; }

    pib->dwSize = dwSize;
    pib->dwCount = dwCount;
    pib->pData = pData;

    return HRESULT_FROM_WIN32(NO_ERROR);
}


//---------------------------------------------------------------------------
// Function:    CInfoBase::AddBlock
//
// Adds a block with the given values to the end of the block list.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::AddBlock(
    IN  DWORD   dwType,
    IN  DWORD   dwSize,
    IN  PBYTE   pData,
    IN  DWORD   dwCount,
    IN  BOOL    bRemoveFirst
    ) {

    InfoBlock *pBlock = NULL;
	HRESULT		hr = hrOK;

    if (bRemoveFirst) { RemoveBlock(dwType); }

	COM_PROTECT_TRY
	{
		// allocate space for the block
		pBlock = new InfoBlock;
		Assert(pBlock);

		// initialize member fields with values passed in
		pBlock->dwType = dwType;
		pBlock->dwSize = dwSize;
		pBlock->dwCount = dwCount;

		// initialize the data field, copying the data passed in
	
		if (dwSize == 0 || dwCount == 0)
			pBlock->pData = NULL;
		else
		{
			pBlock->pData = NULL;
			pBlock->pData = new BYTE[dwSize * dwCount];
			Assert(pBlock->pData);
						
			::CopyMemory(pBlock->pData, pData, dwSize * dwCount);
		}

		// add the new block to the end of the list
		m_lBlocks.AddTail(pBlock);
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		if (pBlock)
			delete pBlock->pData;
		delete pBlock;
	}

    return hr;
}



//---------------------------------------------------------------------------
// Function:    CInfoBase::RemoveBlock
//
// Removes a block of the gievn type from the list
//---------------------------------------------------------------------------

HRESULT
CInfoBase::RemoveBlock(
    IN  DWORD   dwType,
    IN  DWORD   dwNth
    ) {

    POSITION pos;
    InfoBlock *pBlock;


    //
    // find the block
    //

    pos = m_lBlocks.GetHeadPosition();

    while (pos) {

        POSITION postemp = pos;

        pBlock = (InfoBlock *)m_lBlocks.GetNext(pos);

        if (pBlock->dwType != dwType) { continue; }

        if (dwNth-- != 0) { continue; }


        //
        // this is the block, remove it from the list
        //

        m_lBlocks.RemoveAt(postemp);


        //
        // free the block's memory as well
        //

        if (pBlock->pData) { delete [] pBlock->pData; }

        delete pBlock;

        return HRESULT_FROM_WIN32(NO_ERROR);
    }


    //
    // the block wasn't found
    //

    return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
}

HRESULT CInfoBase::GetInfo(DWORD *pdwSize, int *pcBlocks)
{
	if (pdwSize)
		*pdwSize = m_dwSize;
	if (pcBlocks)
		*pcBlocks = (int) m_lBlocks.GetCount();
	return hrOK;
}


//---------------------------------------------------------------------------
// Function:    CInfoBase::BlockListToArray
//
// Converts a list of blocks into an array.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::BlockListToArray(
    OUT PBYTE&  pBase,
    OUT DWORD&  dwSize
    ) {

    PBYTE pdata;
    DWORD dwCount;
    POSITION pos;
    RTR_INFO_BLOCK_HEADER *prtrbase;
    RTR_TOC_ENTRY *prtrblock;
    InfoBlock *pblock;
	HRESULT	hr = hrOK;


	COM_PROTECT_TRY
	{
		// Compute the total size occupied by the infobase's blocks

		// base structure
		dwCount = 0;
		dwSize = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);

		// Table Of Contents Entries
		pos = m_lBlocks.GetHeadPosition();
		while (pos) {
			
			pblock = (InfoBlock *)m_lBlocks.GetNext(pos);
			
			dwSize += sizeof(RTR_TOC_ENTRY);
			++dwCount;
		}
		

		// information blocks
		pos = m_lBlocks.GetHeadPosition();
		while (pos) {
			
			pblock = (InfoBlock *)m_lBlocks.GetNext(pos);

			dwSize += ALIGN_SHIFT;
			dwSize &= ALIGN_MASK;

			dwSize += pblock->dwSize * pblock->dwCount;
		}


		//
		// Allocate enough memory to hold the converted infobase
		//
		
		pBase = new BYTE[dwSize];
		Assert(pBase);
		
		ZeroMemory(pBase, dwSize);
		
		
		//
		// Initialize the header
		//
		
		prtrbase = (RTR_INFO_BLOCK_HEADER *)pBase;
		prtrbase->Size = dwSize;
		prtrbase->Version = RTR_INFO_BLOCK_VERSION;
		prtrbase->TocEntriesCount = dwCount;
		

		//
		// Now walk the list again, this time copying blocks over
		// along with their data
		//
		
		prtrblock = prtrbase->TocEntry;
		pdata = pBase + FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry) +
				dwCount * sizeof(RTR_TOC_ENTRY);
		
		
		pos = m_lBlocks.GetHeadPosition();
		while (pos) {
			
			pdata += ALIGN_SHIFT;
			pdata = (PBYTE)((LONG_PTR)pdata & ALIGN_MASK);
			
			pblock = (InfoBlock *)m_lBlocks.GetNext(pos);
			
			prtrblock->InfoType = pblock->dwType;
			prtrblock->Count = pblock->dwCount;
			prtrblock->InfoSize = pblock->dwSize;
			prtrblock->Offset = (ULONG)(pdata - pBase);
			
			
			if (pblock->pData) {
				::CopyMemory(pdata, pblock->pData, pblock->dwSize * pblock->dwCount);
			}
			
			pdata += pblock->dwSize * pblock->dwCount;
			
			++prtrblock;
		}
	}
	COM_PROTECT_CATCH;
				
	return hr;
}
	
	

//---------------------------------------------------------------------------
// Function:    CInfoBase::ArrayToBlockList
//
// This functions converts an array to a list of InfoBlock structures.
//---------------------------------------------------------------------------

HRESULT
CInfoBase::ArrayToBlockList(
    IN  PBYTE   pBase,
    IN  DWORD   dwSize
    ) {

    PBYTE pdata;
    DWORD dwCount, dwErr;
    RTR_TOC_ENTRY *prtrblock;
    RTR_INFO_BLOCK_HEADER *prtrbase;
	HRESULT	hr = hrOK;

    if (!pBase) { return HRESULT_FROM_WIN32(NO_ERROR); }


    //
    // Walk the infobase converting each block to an InfoBlock
    //

    prtrbase = (RTR_INFO_BLOCK_HEADER *)pBase;
    dwCount = prtrbase->TocEntriesCount;
    prtrblock = prtrbase->TocEntry;

    for ( ; dwCount > 0; dwCount--) {

        //
        // Get the next entry in the array
        //

        pdata = pBase + prtrblock->Offset;


        //
        // Add the array-entry to the list of blocks
        //

        hr = AddBlock(
					  prtrblock->InfoType, prtrblock->InfoSize,
					  pdata, prtrblock->Count
					 );
		if (!FHrSucceeded(hr))
		{
			Unload();
			return hr;
		}

        ++prtrblock;
    }

    return HRESULT_FROM_WIN32(NO_ERROR);
}




//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// 
// This section is for the actual implementation of the various
// COM objects, which wrap the previous C++ implementation.
// 
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------



/*---------------------------------------------------------------------------
	Class:	InfoBase

	This is an interface wrapper around the CInfoBase class.
 ---------------------------------------------------------------------------*/
class InfoBase :
   public IInfoBase
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIInfoBaseMembers(IMPL)

	InfoBase();
	~InfoBase();

protected:
	CInfoBase	m_cinfobase;
	LONG		m_cRef;
};

/*---------------------------------------------------------------------------
	Class:	InfoBlockEnumerator
 ---------------------------------------------------------------------------*/
class InfoBlockEnumerator :
   public IEnumInfoBlock
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIEnumInfoBlockMembers(IMPL)

	InfoBlockEnumerator(IInfoBase *pInfoBase, CPtrList* pPtrList);
	~InfoBlockEnumerator();

protected:
	SPIInfoBase	m_spInfoBase;
	CPtrList *	m_pPtrList;
	POSITION	m_pos;
	LONG		m_cRef;
};




/*---------------------------------------------------------------------------
	InfoBase implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(InfoBase)

InfoBase::InfoBase()
	: m_cRef(1)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(InfoBase);
}

InfoBase::~InfoBase()
{
	Unload();
	DEBUG_DECREMENT_INSTANCE_COUNTER(InfoBase);
}

IMPLEMENT_ADDREF_RELEASE(InfoBase);

HRESULT InfoBase::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IInfoBase)
		*ppv = (IInfoBase *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}

/*!--------------------------------------------------------------------------
	InfoBase::Load
		Implementation of IInfoBase::Load
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::Load(HKEY hKey, 
							LPCOLESTR pszKey, 
							LPCOLESTR pszValue)
{
	HRESULT	hr;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.Load(hKey, OLE2CT(pszKey), OLE2CT(pszValue));
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::Save
		Implementation of IInfoBase::Save
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::Save(HKEY hKey, 
						 LPCOLESTR pszKey, 
						 LPCOLESTR pszValue)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.Save(hKey,	OLE2CT(pszKey), OLE2CT(pszValue));
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::Unload
		Implementation of IInfoBase::Unload
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::Unload()  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.Unload();
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::CopyFrom
		Implementation of IInfoBase::CopyFrom
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::CopyFrom(IInfoBase * pSrc)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.CopyFrom(pSrc);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::LoadFrom
		Implementation of IInfoBase::LoadFrom
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::LoadFrom(DWORD dwSize, PBYTE pBase)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.LoadFrom(pBase, dwSize);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::WriteTo
		Implementation of IInfoBase::WriteTo
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::WriteTo(PBYTE *ppBase, 
							DWORD *pdwSize)  
{
	HRESULT	hr = hrOK;
	PBYTE	pBaseT = NULL;
	DWORD	dwSizeT;

	Assert(ppBase);
	Assert(pdwSize);
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.WriteTo(pBaseT, dwSizeT);

		if (FHrSucceeded(hr))
		{
			*ppBase = (PBYTE) CoTaskMemAlloc(dwSizeT);
			if (*ppBase == NULL)
				hr = E_OUTOFMEMORY;
			else
			{
				::CopyMemory(*ppBase, pBaseT, dwSizeT);
				*pdwSize = dwSizeT;
				delete pBaseT;
			}
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::GetBlock		
		Implementation of IInfoBase::GetBlock
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::GetBlock(DWORD dwType, 
							 InfoBlock **ppBlock, 
							 DWORD dwNth)  
{
	HRESULT	hr = hrOK;
	Assert(ppBlock);
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.GetBlock(dwType, *ppBlock, dwNth);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::SetBlock
		Implementation of IInfoBase::SetBlock
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::SetBlock(DWORD dwType, 
							 InfoBlock *pBlock, 
							 DWORD dwNth)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.SetBlock(dwType, pBlock, dwNth);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::AddBlock
		Implementation of IInfoBase::AddBlock
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::AddBlock(DWORD	dwType, 
							 DWORD	dwSize, 
							 PBYTE	pData, 
							 DWORD	dwCount, 
							 BOOL	bRemoveFirst)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.AddBlock(dwType, dwSize, pData, dwCount, bRemoveFirst);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::GetData
		Implementation of IInfoBase::GetData
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::GetData(DWORD	dwType, 
							DWORD	dwNth, 
							PBYTE *	ppData)  
{
	HRESULT	hr = hrOK;
	PBYTE	pb = NULL;

	Assert(ppData);
	
	COM_PROTECT_TRY
	{
		pb = m_cinfobase.GetData(dwType, dwNth);
		*ppData = pb;
	}
	COM_PROTECT_CATCH;
	
	return *ppData ? hr : E_INVALIDARG;
}

/*!--------------------------------------------------------------------------
	InfoBase::SetData
		Implementation of IInfoBase::SetData
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::SetData(DWORD	dwType, 
							DWORD	dwSize, 
							PBYTE	pData, 
							DWORD	dwCount, 
							DWORD	dwNth)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.SetData(dwType, dwSize, pData, dwCount, dwNth);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::RemoveBlock
		Implementation of IInfoBase::RemoveBlock
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::RemoveBlock(DWORD	dwType, 
								DWORD	dwNth)  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.RemoveBlock(dwType, dwNth);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::BlockExists
		Implementation of IInfoBase::BlockExists
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::BlockExists(DWORD	dwType )  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.BlockExists(dwType) ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::ProtocolExists
		Implementation of IInfoBase::ProtocolExists
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::ProtocolExists(DWORD dwProtocol )  
{
	HRESULT	hr = hrOK;
	BOOL	bResult;
	
	COM_PROTECT_TRY
	{
		bResult = m_cinfobase.ProtocolExists(dwProtocol);
		hr = (bResult ? S_OK : S_FALSE);
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::RemoveAllBlocks
		Implementation of IInfoBase::RemoveAllBlocks
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::RemoveAllBlocks()  
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		hr = m_cinfobase.RemoveAllBlocks();
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	InfoBase::QueryBlockList
		Implementation of IInfoBase::QueryBlockList
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBase::QueryBlockList(IEnumInfoBlock **ppBlockEnum)  
{
	HRESULT	hr = hrOK;
	InfoBlockEnumerator	*pIBEnum = NULL;
	
	COM_PROTECT_TRY
	{
		pIBEnum = new InfoBlockEnumerator(this, &m_cinfobase.QueryBlockList());
		Assert(pIBEnum);
	}
	COM_PROTECT_CATCH;

	*ppBlockEnum = static_cast<IEnumInfoBlock *>(pIBEnum);
	
	return hr;
}


STDMETHODIMP InfoBase::GetInfo(DWORD *pdwSize, int *pcBlocks)
{
	return m_cinfobase.GetInfo(pdwSize, pcBlocks);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CreateInfoBase
		Creates an IInfoBase object.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateInfoBase(IInfoBase **ppInfoBase)
{
	HRESULT	hr = hrOK;
	InfoBase *	pinfobase = NULL;

	Assert(ppInfoBase);

	COM_PROTECT_TRY
	{
		pinfobase = new InfoBase;
		*ppInfoBase = static_cast<IInfoBase *>(pinfobase);
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*---------------------------------------------------------------------------
	InfoBlockEnumerator implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(InfoBlockEnumerator);

InfoBlockEnumerator::InfoBlockEnumerator(IInfoBase *pInfoBase, CPtrList *pPtrList)
	: m_cRef(1)
{
	m_spInfoBase.Set(pInfoBase);
	m_pPtrList = pPtrList;

	DEBUG_INCREMENT_INSTANCE_COUNTER(InfoBlockEnumerator);
}

InfoBlockEnumerator::~InfoBlockEnumerator()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(InfoBlockEnumerator);
}

IMPLEMENT_ADDREF_RELEASE(InfoBlockEnumerator);

HRESULT InfoBlockEnumerator::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IEnumInfoBlock)
		*ppv = (IEnumInfoBlock *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}

/*!--------------------------------------------------------------------------
	InfoBlockEnumerator::Next
		Implementation of IEnumInfoBlock::Next
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBlockEnumerator::Next(ULONG uNum, InfoBlock **ppBlock,
									ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(m_pPtrList);
	Assert(ppBlock);

	if (ppBlock)
		*ppBlock = NULL;
	
	if (!m_pos)
	{
		if (pNumReturned)
			*pNumReturned = 0;
		return S_FALSE;
	}
	
	*ppBlock = (InfoBlock *) m_pPtrList->GetNext(m_pos);
	if (pNumReturned)
		*pNumReturned = 1;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	InfoBlockEnumerator::Skip
		Implementation of IEnumInfoBlock::Skip
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBlockEnumerator::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	Assert(m_pPtrList);

	if (!m_pos)
		return S_FALSE;
	
	m_pPtrList->GetNext(m_pos);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	InfoBlockEnumerator::Reset
		Implementation of IEnumInfoBlock::Reset
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBlockEnumerator::Reset()
{
	Assert(m_pPtrList);
	m_pos = m_pPtrList->GetHeadPosition();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	InfoBlockEnumerator::Clone
		Implementation of IEnumInfoBlock::Clone
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InfoBlockEnumerator::Clone(IEnumInfoBlock **ppBlockEnum)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\infoi.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    info.h
//
// History:
//  Abolade Gbadegesin      Feb. 10, 1996   Created.
//
// This file contains declarations for InfoBase parsing code.
// Also including are classes for loading and saving the Router's
// configuration tree (CRouterInfo, CRmInfo, etc.)
//
// The classes are as follows
// (in the diagrams, d => derives, c => contains-list-of):
//
//
//  CInfoBase
//     |
//     c---SInfoBlock
//
//
//  CInfoBase               holds block of data broken up into a list
//                          of SInfoBlock structures using RTR_INFO_BLOCK_HEADER
//                          as a template (see rtinfo.h).
//
//  CRouterInfo                                     // router info
//      |
//      c---CRmInfo                                 // router-manager info
//      |    |
//      |    c---CRmProtInfo                        // protocol info
//      |
//      c---CInterfaceInfo                          // router interface info
//           |
//           c---CRmInterfaceInfo                   // router-manager interface
//                |
//                c---CRmProtInterfaceInfo          // protocol info
//
//  CRouterInfo             top-level container for Router registry info.
//                          holds list of router-managers and interfaces.
//
//  CRmInfo                 global information for a router-manager,
//                          holds list of routing-protocols.
//
//  CRmProtInfo             global information for a routing-protocol.
//
//  CInterfaceInfo          global information for a router-interface.
//                          holds list of CRmInterfaceInfo structures,
//                          which hold per-interface info for router-managers.
//
//  CRmInterfaceInfo        per-interface info for a router-manager.
//                          holds list of CRmProtInterfaceInfo structures,
//                          which hold per-interface info for protocols.
//
//  CRmProtInterfaceInfo    per-interface info for a routing-protocol.
//
//============================================================================


#ifndef _INFOI_H_
#define _INFOI_H_

#include "router.h"

#ifndef _INFOPRIV_H
#include "infopriv.h"
#endif

#ifndef _RTRLIST_H
#include "rtrlist.h"
#endif


//
// Forward declarations of router-information classes.
//
class CRmInfo;
class CRmProtInfo;
class CInterfaceInfo;
class CRmInterfaceInfo;
class CRmProtInterfaceInfo;
class RouterRefreshObject;


typedef struct _SRouterCB
{
	DWORD	dwLANOnlyMode;		// 0 or 1

	void	LoadFrom(const RouterCB *pcb);
	void	SaveTo(RouterCB *pcb);
} SRouterCB;



typedef struct _SRtrMgrCB
{
    DWORD       dwTransportId;			// e.g. PID_IP (mprapi.h)
	CString		stId;		// e.g. "Tcpip"
	CString		stTitle;	// e.g. "TCP/IP Router Manager"
	CString		stDLLPath;	// e.g. "%systemroot%\system32\iprtrmgr.dll"
	//CString		stConfigDLL;	// e.g. "rtrui.dll"

	// Internal data
	DWORD		dwPrivate;	// private data (for use internally)

	void	LoadFrom(const RtrMgrCB *pcb);
	void	SaveTo(RtrMgrCB *pcb);
} SRtrMgrCB;



typedef struct _SRtrMgrProtocolCB
{
    DWORD   dwProtocolId;   // e.g. IP_RIP (routprot.h)
    CString	stId;			// e.g. "IPRIP"
    DWORD   dwFlags;
    DWORD   dwTransportId;  // e.g. PID_IP
    CString	stRtrMgrId;     // e.g. "Tcpip"
    CString	stTitle;        // e.g. "RIP for Internet Protocol"
    CString	stDLLName;		// e.g. "iprip2.dll"
    //CString	stConfigDLL;	        // e.g. "rtrui.dll"
	GUID	guidConfig;		// CLSID for config object
	GUID	guidAdminUI;	// CLSID for snapin
	CString	stVendorName;
	
	// Internal data
	DWORD		dwPrivate;	// private data (for use internally)

	void	LoadFrom(const RtrMgrProtocolCB *pcb);
	void	SaveTo(RtrMgrProtocolCB *pcb);
} SRtrMgrProtocolCB;



typedef struct _SInterfaceCB
{
    CString	stId;		// e.g. "EPRO1"
    DWORD   dwIfType;	// e.g. ROUTER_IF_TYPE_CLIENT (mprapi.h)
    BOOL    bEnable;	// e.g. Enabled or Disabled
	CString	stTitle;	// e.g. friendly name(NT5) or the device name(NT4)
	CString	stDeviceName;	// e.g. "[1] Intel EtherPro"
    DWORD   dwBindFlags;    // e.g. Bound to IP or IPX
	
	// Internal data
	DWORD		dwPrivate;	// private data (for use internally)

	void	LoadFrom(const InterfaceCB *pcb);
	void	SaveTo(InterfaceCB *pcb);
} SInterfaceCB;



typedef struct _SRtrMgrInterfaceCB
{
    DWORD       dwTransportId;  // e.g. PID_IP (mprapi.h)
    CString		stId;			// e.g. "Tcpip"
	CString		stInterfaceId;	// e.g. "EPRO1"
    DWORD       dwIfType;       // e.g. ROUTER_IF_TYPE_CLIENT (mprapi.h)
	CString		stTitle;		// e.g. "[1] Intel Etherexpress PRO"
	
	// Internal data
	DWORD		dwPrivate;	// private data (for use internally)

	void	LoadFrom(const RtrMgrInterfaceCB *pcb);
	void	SaveTo(RtrMgrInterfaceCB *pcb);
} SRtrMgrInterfaceCB;



typedef struct _SRtrMgrProtocolInterfaceCB
{
    DWORD   dwProtocolId;       // e.g. IP_RIP (routprot.h)
	CString	stId;				// e.g. "IPRIP"
    DWORD   dwTransportId;      // e.g. PID_IP
    CString	stRtrMgrId;			// e.g. "Tcpip"
    CString	stInterfaceId;		// e.g. "EPRO1"
    DWORD   dwIfType;           // e.g. ROUTER_IF_TYPE_CLIENT (mprapi.h)
	CString	stTitle;			// e.g. "[1] Intel Etherexpress PRO"
	
	// Internal data
	DWORD		dwPrivate;	// private data (for use internally)

	void	LoadFrom(const RtrMgrProtocolInterfaceCB *pcb);
	void	SaveTo(RtrMgrProtocolInterfaceCB *pcb);
} SRtrMgrProtocolInterfaceCB;




/*---------------------------------------------------------------------------
	CList classes for the external structures
 ---------------------------------------------------------------------------*/
typedef CList<RtrMgrCB *, RtrMgrCB *> RtrMgrCBList;
typedef CList<RtrMgrProtocolCB *, RtrMgrProtocolCB *> RtrMgrProtocolCBList;
typedef CList<InterfaceCB *, InterfaceCB *> InterfaceCBList;
typedef CList<RtrMgrInterfaceCB *, RtrMgrInterfaceCB *> RtrMgrInterfaceCBList;
typedef CList<RtrMgrProtocolInterfaceCB *, RtrMgrProtocolInterfaceCB *> RtrMgrProtocolInterfaceCBList;



/*---------------------------------------------------------------------------
	CList classes for the various internal structures
 ---------------------------------------------------------------------------*/
typedef CList<SRtrMgrCB *, SRtrMgrCB *>	SRtrMgrCBList;
typedef CList<SRtrMgrProtocolCB *, SRtrMgrProtocolCB *> SRtrMgrProtocolCBList;
typedef CList<SInterfaceCB *, SInterfaceCB *> SInterfaceCBList;
typedef CList<SRtrMgrInterfaceCB *, SRtrMgrInterfaceCB *> SRtrMgrInterfaceCBList;
typedef CList<SRtrMgrProtocolInterfaceCB *, SRtrMgrProtocolInterfaceCB *> SRtrMgrProtocolInterfaceCBList;

/*---------------------------------------------------------------------------
	Smart pointers for the various structures
 ---------------------------------------------------------------------------*/
DeclareSP(SRouterCB, SRouterCB)
DeclareSP(SRtrMgrCB, SRtrMgrCB)
DeclareSP(SRtrMgrProtocolCB, SRtrMgrProtocolCB)
DeclareSP(SInterfaceCB, SInterfaceCB)
DeclareSP(SRtrMgrInterfaceCB, SRtrMgrInterfaceCB)
DeclareSP(SRtrMgrProtocolInterfaceCB, SRtrMgrProtocolInterfaceCB)

struct SRmData
{
	IRtrMgrInfo *	m_pRmInfo;

	SRmData() : m_pRmInfo(NULL){};

	// Do this instead of using a destructor to avoid problems with
	// destruction of temporaries.
	static void Destroy(SRmData *pRmData);
};
typedef CList<SRmData, SRmData> RmDataList;


struct SIfData
{
	IInterfaceInfo *	pIfInfo;
	DWORD			dwConnection;

	SIfData() : pIfInfo(NULL), dwConnection(0) {};

};
typedef CList<SIfData, SIfData> IfList;

/*---------------------------------------------------------------------------
	CreateEnum for the various CBs
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSRmCBList(SRtrMgrCBList *pRmCBList,
								IEnumRtrMgrCB **ppEnum);
HRESULT CreateEnumFromSRmProtCBList(SRtrMgrProtocolCBList *pRmProtCBList,
									IEnumRtrMgrProtocolCB **ppEnum);
HRESULT CreateEnumFromSIfCBList(SInterfaceCBList *pIfCBList,
								IEnumInterfaceCB **ppEnum);
HRESULT CreateEnumFromSRmIfCBList(SRtrMgrInterfaceCBList *pRmIfCBList,
								  IEnumRtrMgrInterfaceCB **ppEnum);
HRESULT CreateEnumFromSRmProtIfCBList(SRtrMgrProtocolInterfaceCBList *pRmIfProtCBList,
									  IEnumRtrMgrProtocolInterfaceCB **ppEnum);


/*---------------------------------------------------------------------------
	CreateEnum for the various interface lists
 ---------------------------------------------------------------------------*/

// These lists are assumed to have arrays of WEAK references!
HRESULT CreateEnumFromRmList(RmDataList *pRmList,
							 IEnumRtrMgrInfo **ppEnum);
HRESULT CreateEnumFromRtrMgrProtocolList(PRtrMgrProtocolInfoList *pRmProtList,
										 IEnumRtrMgrProtocolInfo **ppEnum);
HRESULT CreateEnumFromInterfaceList(PInterfaceInfoList *pIfList,
									IEnumInterfaceInfo **ppEnum);
HRESULT CreateEnumFromRtrMgrInterfaceList(PRtrMgrInterfaceInfoList *pRmIfList,
										  IEnumRtrMgrInterfaceInfo **ppEnum);
HRESULT CreateEnumFromRtrMgrProtocolInterfaceList(PRtrMgrProtocolInterfaceInfoList *pRmProtIfList,
	IEnumRtrMgrProtocolInterfaceInfo **ppEnum);




/*---------------------------------------------------------------------------
	Struct:	SAdviseData
	Helper class for management of advise connections.
 ---------------------------------------------------------------------------*/
struct SAdviseData
{
	IRtrAdviseSink *m_pAdvise;
	LONG_PTR		m_ulConnection;
	LPARAM			m_lUserParam;

    // This m_ulFlags parameter is used by the AdviseDataList.
    ULONG           m_ulFlags;

	SAdviseData() : m_pAdvise(NULL), m_ulConnection(0) {};

	static void Destroy(SAdviseData *pAdviseData);
};
typedef CList<SAdviseData, SAdviseData> _SAdviseDataList;


// Possible values for the m_ulFlags
#define ADVISEDATA_DELETED      (1)

class AdviseDataList : public _SAdviseDataList
{
public:
	HRESULT AddConnection(IRtrAdviseSink *pAdvise,
						  LONG_PTR ulConnection,
						  LPARAM lUserParam);
	HRESULT RemoveConnection(LONG_PTR ulConnection);

	HRESULT NotifyChange(DWORD dwChange, DWORD dwObj, LPARAM lParam);

protected:
    // Need to have a private list to handle the notifies.
    // This list is created while in a NotifyChange().  Any calls
    // to RemoveConnection() DURING a notify, will mark entries as
    // invalid (and are thus not called during the NotifyChange()).
    _SAdviseDataList    m_listNotify;
};


/*---------------------------------------------------------------------------
	Class:	RtrCriticalSection

	This class is used to support entering/leaving of critical sections.
	Put this class at the top of a function that you want protected.
 ---------------------------------------------------------------------------*/

class RtrCriticalSection
{
public:
	RtrCriticalSection(CRITICAL_SECTION *pCritSec)
			: m_pCritSec(pCritSec)
	{
		IfDebug(m_cEnter=0;)
		Assert(m_pCritSec);
		Enter();
	}
	
	~RtrCriticalSection()
	{
		Detach();
	}

	void	Enter()
	{
		if (m_pCritSec)
		{
			IfDebug(m_cEnter++;)
			EnterCriticalSection(m_pCritSec);
			AssertSz(m_cEnter==1, "EnterCriticalSection called too much!");
		}
	}
	
	BOOL	TryToEnter()
	{
		if (m_pCritSec)
			return TryEnterCriticalSection(m_pCritSec);
		return TRUE;
	}
	
	void	Leave()
	{
		if (m_pCritSec)
		{
			IfDebug(m_cEnter--;)
			LeaveCriticalSection(m_pCritSec);
			Assert(m_cEnter==0);
		}
	}

	void	Detach()
	{
		Leave();
		m_pCritSec = NULL;
	}
	
private:
	CRITICAL_SECTION *	m_pCritSec;
	IfDebug(int m_cEnter;)
};



/*---------------------------------------------------------------------------
	Class:	RouterInfo
 ---------------------------------------------------------------------------*/

class RouterInfo :
   public CWeakRef,
   public IRouterInfo,
   public IRouterAdminAccess
{
public:
	DeclareIUnknownMembers(IMPL)
    DeclareIRouterRefreshAccessMembers(IMPL)
	DeclareIRouterInfoMembers(IMPL)
	DeclareIRtrAdviseSinkMembers(IMPL)
    DeclareIRouterAdminAccessMembers(IMPL)


    // Constructor
	RouterInfo(HWND hWndSync, LPCWSTR machineName);

	// If you are releasing ANY interface pointers do it in
	// the Destruct() call instead.
	virtual ~RouterInfo();

    // Internal calls to help out with adding/removing interfaces
    // ----------------------------------------------------------------
	HRESULT AddInterfaceInternal(IInterfaceInfo *pInfo, BOOL fForce,
                                 BOOL fAddToRouter);
    HRESULT RemoveInterfaceInternal(LPCOLESTR pszIf, BOOL fRemoveFromRouter);
    HRESULT RemoteRtrMgrInternal(DWORD dwTransportId, BOOL fRemoveFromRouter);
    HRESULT FindInterfaceByName(LPCOLESTR pszIfName, IInterfaceInfo **ppInfo);
    HRESULT NotifyRtrMgrInterfaceOfMove(IInterfaceInfo *pInfo);

    // Functions to load up static information about the router.
    // This will return information about the INSTALLED protocols/rms,
    // not necessarily the RUNNING protocols/rms.
    // ----------------------------------------------------------------
	static HRESULT LoadInstalledRtrMgrList(LPCTSTR pszMachine,
										   SRtrMgrCBList *pRmCBList);
	static HRESULT LoadInstalledInterfaceList(LPCTSTR pszMachine,
											  SInterfaceCBList *pIfCBList);
	static HRESULT LoadInstalledRtrMgrProtocolList(LPCTSTR pszMachine,
		DWORD dwTransportId, SRtrMgrProtocolCBList *pRmProtCBList,
		LPCWSTR lpwszUserName, LPCWSTR lpwszPassword , LPCWSTR lpwszDomain );
	static HRESULT LoadInstalledRtrMgrProtocolList(LPCTSTR pszMachine,
		DWORD dwTransportId, SRtrMgrProtocolCBList *pRmProtCBList, RouterInfo * pRouter);
	static HRESULT LoadInstalledRtrMgrProtocolList(LPCTSTR pszMachine,
		DWORD dwTransportId, SRtrMgrProtocolCBList *pRmProtCBList, IRouterInfo * pRouter);
	
protected:
    
    // The router control block for this router.  There's not too much
    // information here.
    // ----------------------------------------------------------------
	SRouterCB		m_SRouterCB;

    
    // List of Router-Managers that are running on the router.
    // ----------------------------------------------------------------
	RmDataList		m_RmList;

    
    // List of interfaces that have been added to the router.
    // WEAK-REF ptrs to IInterfaceInfo objects.
    // ----------------------------------------------------------------
	PInterfaceInfoList	m_IfList;

    
    // Name of this machine.
    // ----------------------------------------------------------------
	CString         m_stMachine;

    
    // MPR_CONFIG_HANDLE to the router
    // Obtained by MprAdminServerConnect();
    // ----------------------------------------------------------------
    MPR_CONFIG_HANDLE   m_hMachineConfig;

    
    // MPR_SERVER_HANDLE to the router
    // Obtained by MprAdminServerConnect();
    // ----------------------------------------------------------------
    MPR_SERVER_HANDLE   m_hMachineAdmin;


    // This is set to TRUE if we are to disconnect the machine handles.
    // ----------------------------------------------------------------
	BOOL            m_bDisconnect;


    // This is the router type (LAN, WAN, RAS);
    // ----------------------------------------------------------------
	DWORD			m_dwRouterType;

    
    // Version info for the router and machine.
    // ----------------------------------------------------------------
	RouterVersionInfo	m_VersionInfo;

    
    // Pointer to the refresh object connected with this machine.
    // ----------------------------------------------------------------
	SPIRouterRefresh m_spRefreshObject;

    
	HWND			m_hWndSync;	// hwnd of the background hidden window
	
	SRtrMgrCBList	m_RmCBList; // contains ptrs to RtrMgrCB objects
	SRtrMgrProtocolCBList	m_RmProtCBList;	// ptrs to RtrMgrProtocolCB objects
	SInterfaceCBList m_IfCBList; // ptrs to InterfaceCB objects
	
	AdviseDataList	m_AdviseList;	// list of advises

	DWORD			m_dwFlags;

	HRESULT LoadRtrMgrList();
	HRESULT LoadInterfaceList();
	HRESULT TryToConnect(LPCWSTR pswzMachine, HANDLE hMachine);

	// Functions for merge support
	HRESULT	MergeRtrMgrCB(IRouterInfo *pNewRouter);
	HRESULT	MergeInterfaceCB(IRouterInfo *pNewRouter);
	HRESULT	MergeRtrMgrProtocolCB(IRouterInfo *pNewRouter);
	HRESULT	MergeRtrMgrs(IRouterInfo *pNewRouter);
	HRESULT	MergeInterfaces(IRouterInfo *pNewRouter);

	SRtrMgrCB *		FindRtrMgrCB(DWORD dwTransportId);
	SInterfaceCB *	FindInterfaceCB(LPCTSTR pszInterfaceId);
	SRtrMgrProtocolCB * FindRtrMgrProtocolCB(DWORD dwTransportId, DWORD dwProtocolId);

	// Disconnect
	void	Disconnect();

	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();

	// Critical section support
	CRITICAL_SECTION	m_critsec;

    // Information for IRouterAdminAccess
    BOOL    m_fIsAdminInfoSet;
    CString m_stUserName;
    CString m_stDomain;
    BYTE *  m_pbPassword;
    int     m_cPassword;
};



/*---------------------------------------------------------------------------
	Class:	RtrMgrInfo
 ---------------------------------------------------------------------------*/

class RtrMgrInfo :
   public IRtrMgrInfo,
   public CWeakRef
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrInfoMembers(IMPL)

	RtrMgrInfo(DWORD dwTransportId, LPCTSTR pszTransportName,
			   RouterInfo *pRouterInfo);
	virtual ~RtrMgrInfo();

protected:
	SRtrMgrCB	m_cb;           // router-manager control block
	PRtrMgrProtocolInfoList	m_RmProtList;	// list of routing-protocols
//	CObList         m_protList;     // list of routing-protocols
	CString         m_stMachine;     // machine whose config is loaded
	HANDLE          m_hMachineConfig;     // handle to machine's router-config
	HANDLE          m_hTransport;   // handle to transport's config
	BOOL            m_bDisconnect;

	AdviseDataList	m_AdviseList;	// list of advises

	DWORD			m_dwFlags;

	// This will contain a weak/strong ref on the parent
	IRouterInfo *	m_pRouterInfoParent;

	//--------------------------------------------------------------------
	// Functions:   LoadRtrMgrInfo
	//              SaveRtrMgrInfo
	//
	// The following handle loading and saving the routing-protocol list
	// for the router-manager in the correct format in the registry.
	//--------------------------------------------------------------------
 	HRESULT LoadRtrMgrInfo(HANDLE	hMachine,
						   HANDLE	hTransport
						   );
	HRESULT	SaveRtrMgrInfo(HANDLE hMachine,
						   HANDLE hTransport,
						   IInfoBase *pGlobalInfo,
						   IInfoBase *pClientInfo,
						   DWORD dwDeleteProtocolId);
	HRESULT TryToConnect(LPCWSTR pswzMachine, HANDLE *phMachine);
    HRESULT TryToGetAllHandles(LPCOLESTR pszMachine,
                               HANDLE *phMachine,
                               HANDLE *phTransport);

	// Disconnects this object
	void Disconnect();
	
	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();
	
	// Critical section support
	CRITICAL_SECTION	m_critsec;
};



/*---------------------------------------------------------------------------
	Class:	RtrMgrProtocolInfo
 ---------------------------------------------------------------------------*/

class RtrMgrProtocolInfo :
   public IRtrMgrProtocolInfo,
   public CWeakRef
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrProtocolInfoMembers(IMPL)

	RtrMgrProtocolInfo(DWORD dwProtocolId,
					   LPCTSTR      lpszId,
					   DWORD        dwTransportId,
					   LPCTSTR      lpszRm,
					   RtrMgrInfo *	pRmInfo);
	virtual ~RtrMgrProtocolInfo();
	
	HRESULT	SetCB(const RtrMgrProtocolCB *pcb);

protected:
	// This will contain a weak/strong ref on the parent
	IRtrMgrInfo *			m_pRtrMgrInfoParent;
	
	SRtrMgrProtocolCB       m_cb;       // protocol control block
	
	AdviseDataList	m_AdviseList;	// list of advises

	DWORD			m_dwFlags;

	// Disconnect
	void Disconnect();
	
	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();
	
	// Critical section support
	CRITICAL_SECTION	m_critsec;
};



/*---------------------------------------------------------------------------
	Class:	InterfaceInfo
 ---------------------------------------------------------------------------*/

class InterfaceInfo :
   public IInterfaceInfo,
   public CWeakRef
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIInterfaceInfoMembers(IMPL)

	InterfaceInfo(LPCTSTR         lpszId,
				  DWORD           dwIfType,
				  BOOL            bEnable,
                  DWORD           dwBindFlags,
				  RouterInfo*    pRouterInfo);
	~InterfaceInfo();

	static HRESULT FindInterfaceTitle(LPCTSTR pszMachine,
								   LPCTSTR pszInterface,
								   LPTSTR *ppszTitle);


protected:
//	CInterfaceInfo	m_CInterfaceInfo;
	SInterfaceCB    m_cb;           // interface control block
	PRtrMgrInterfaceInfoList	m_RmIfList; // list of IRtrMgrInterfaceInfo
//	CObList         m_rmIfList;     // list of CRmInterfaceInfo
	CString         m_stMachine;     // machine whose config is loaded
	HANDLE          m_hMachineConfig;     // handle to machine's config
	HANDLE          m_hInterface;   // handle to interface-config
	BOOL            m_bDisconnect;

	AdviseDataList	m_AdviseList;	// list of advises

	DWORD			m_dwFlags;

	IRouterInfo *	m_pRouterInfoParent;

	HRESULT LoadRtrMgrInterfaceList();
	HRESULT TryToConnect(LPCWSTR pszMachine, HANDLE *phMachine);
	HRESULT TryToGetIfHandle(HANDLE hMachine, LPCWSTR pswzInterface, HANDLE *phInterface);

	// Disconnect
	void Disconnect();
	
	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();
	
	// Critical section support
	CRITICAL_SECTION	m_critsec;
};



/*---------------------------------------------------------------------------
	Class:	RtrMgrInterfaceInfo
 ---------------------------------------------------------------------------*/

class RtrMgrInterfaceInfo :
   public IRtrMgrInterfaceInfo,
   public CWeakRef
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrInterfaceInfoMembers(IMPL)
			
	RtrMgrInterfaceInfo(DWORD           dwTransportId,
						LPCTSTR         lpszId,
						LPCTSTR         lpszIfId,
						DWORD           dwIfType,
						InterfaceInfo *	pIfInfo);
	virtual ~RtrMgrInterfaceInfo();

protected:
//	CRmInterfaceInfo	m_CRmInterfaceInfo;
	SRtrMgrInterfaceCB      m_cb;           // router-manager control block
	PRtrMgrProtocolInterfaceInfoList	m_RmProtIfList;
//	CObList                 m_protList;     // list of CRmProtInterfaceInfo
	CString                 m_stMachine;     // name of machine 
	HANDLE                  m_hMachineConfig;     // handle to machine's config
	HANDLE                  m_hInterface;   // handle to interface-config
	HANDLE                  m_hIfTransport; // handle to transport-config
	BOOL                    m_bDisconnect;


	DWORD					m_dwFlags;		// state of this interface

	AdviseDataList	m_AdviseList;	// list of advises

	IInterfaceInfo *		m_pInterfaceInfoParent;

	HRESULT	LoadRtrMgrInterfaceInfo(HANDLE hMachine,
									HANDLE hInterface,
									HANDLE hIfTransport);	
	HRESULT SaveRtrMgrInterfaceInfo(HANDLE hMachine,
								   HANDLE hInterface,
								   HANDLE hIfTransport,
								   IInfoBase *pInterfaceInfoBase,
								   DWORD dwDeleteProtocolId);

    HRESULT TryToGetAllHandles(LPCWSTR pszMachine,
                               HANDLE *phMachine,
                               HANDLE *phInterface,
                               HANDLE *phTransport);
	HRESULT TryToConnect(LPCWSTR pswzMachine, HANDLE *phMachine);
	HRESULT TryToGetIfHandle(HANDLE hMachine, LPCWSTR pswzInterface, HANDLE *phInterface);
	
	// Disconnect
	void Disconnect();

    // Notification helper functions
    HRESULT NotifyOfRmProtIfAdd(IRtrMgrProtocolInterfaceInfo *pRmProtIf,
                                IInterfaceInfo *pParentIf);
	
	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();
	
	// Critical section support
	CRITICAL_SECTION	m_critsec;
};


/*---------------------------------------------------------------------------
	Class:	RtrMgrProtocolInterfaceInfo
 ---------------------------------------------------------------------------*/

class RtrMgrProtocolInterfaceInfo :
   public IRtrMgrProtocolInterfaceInfo,
   public CWeakRef
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrProtocolInterfaceInfoMembers(IMPL)

	RtrMgrProtocolInterfaceInfo(DWORD dwProtocolId,
								LPCTSTR pszId,
								DWORD dwTransportId,
								LPCTSTR pszRmId,
								LPCTSTR pszIfId,
								DWORD dwIfType,
								RtrMgrInterfaceInfo *pRmIf);
	virtual ~RtrMgrProtocolInterfaceInfo();

	SRtrMgrProtocolInterfaceCB      m_cb;       // protocol control block

protected:
	
	AdviseDataList	m_AdviseList;	// list of advises

	DWORD			m_dwFlags;

	IRtrMgrInterfaceInfo *	m_pRtrMgrInterfaceInfoParent;
	
	// Disconnect
	void Disconnect();
	
	// Overrides of CWeakRef functions
	virtual void OnLastStrongRef();
	virtual void ReviveStrongRef();
	
	// Critical section support
	CRITICAL_SECTION	m_critsec;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\infopriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       infopriv.h
//
//--------------------------------------------------------------------------


#ifndef _INFOPRIV_H_
#define _INFOPRIV_H_

#include "setupapi.h"

HRESULT RasPhoneBookRemoveInterface(LPCTSTR pszMachine, LPCTSTR pszIf);


/*---------------------------------------------------------------------------
	Class: CNetcardRegistryHelper

	This class is provided for NT4/NT5 registry compatibility.
	This is a temporary class.  Change to use the NetCfg APIs once
	they are in place, that is once they can be remoted.
 ---------------------------------------------------------------------------*/

class CNetcardRegistryHelper
{
public:
	CNetcardRegistryHelper();
	~CNetcardRegistryHelper();

    void	Initialize(BOOL fNt4, HKEY hkeyBase,
					   LPCTSTR pszKeyBase, LPCTSTR pszMachineName);
	
	DWORD	ReadServiceName();
	LPCTSTR	GetServiceName();
	
	DWORD	ReadTitle();
	LPCTSTR	GetTitle();

	DWORD	ReadDeviceName();
	LPCTSTR	GetDeviceName();

private:
	void    FreeDevInfo();
	DWORD	PrivateInit();
	DWORD	ReadRegistryCString(LPCTSTR pszKey,
								LPCTSTR pszValue,
								HKEY	hkey,
								CString *pstDest);
	
	CString	m_stTitle;			// string holding title
	CString m_stKeyBase;		// string holding name of key in hkeyBase (NT5)
	CString	m_stDeviceName;

	HKEY	m_hkeyBase;

    // Used for Connection info
    HKEY    m_hkeyConnection;

	// Keys only used for NT4 only
	HKEY	m_hkeyService;		// hkey where the service value is held
	CString	m_stService;		// string holding service name
	HKEY	m_hkeyTitle;		// hkey where the title value is held

	// Values used for NT5 only
	HDEVINFO	m_hDevInfo;
	CString	m_stMachineName;
	
	BOOL	m_fInit;
	BOOL	m_fNt4;

};


class	CWeakRef
{
public:
	CWeakRef();
	virtual ~CWeakRef() {};

	virtual void	ReviveStrongRef() {};
	virtual void	OnLastStrongRef() {};

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(AddWeakRef)();
	STDMETHOD(ReleaseWeakRef)();

	
protected:
	// Total number of references (strong and weak) on this object
	LONG		m_cRef;

	// Number of weak references on this object
	LONG		m_cRefWeak;

	// Is there a strong reference on this object?
	BOOL		m_fStrongRef;

	// Has the object been told to destruct?  If so, it will do
	// should call Destruct() in OnLastStrongRef().
	BOOL		m_fDestruct;

	// Are we in the process of calling OnLastStrongRef().  If we
	// are, then additional calls to AddRef() do not cause us
	// to wake up again.
	BOOL		m_fInShutdown;
};

#define IMPLEMENT_WEAKREF_ADDREF_RELEASE(klass) \
STDMETHODIMP_(ULONG) klass::AddRef() \
{ \
	return CWeakRef::AddRef(); \
} \
STDMETHODIMP_(ULONG) klass::Release() \
{ \
	return CWeakRef::Release(); \
} \
STDMETHODIMP klass::AddWeakRef() \
{ \
	return CWeakRef::AddWeakRef(); \
} \
STDMETHODIMP klass::ReleaseWeakRef() \
{ \
	return CWeakRef::ReleaseWeakRef(); \
} \



#define CONVERT_TO_STRONGREF(p) \
		(p)->AddRef(); \
		(p)->ReleaseWeakRef(); \

#define CONVERT_TO_WEAKREF(p)	\
		(p)->AddWeakRef(); \
		(p)->Release(); \

interface IRouterInfo;
interface IRtrMgrInfo;
interface IInterfaceInfo;
interface IRtrMgrInterfaceInfo;
interface IRtrMgrProtocolInterfaceInfo;

HRESULT CreateRouterDataObject(LPCTSTR pszMachineName,
							   DATA_OBJECT_TYPES type,
							   MMC_COOKIE cookie,
							   ITFSComponentData *pTFSCompData,
							   IDataObject **ppDataObject,
                               CDynamicExtensions * pDynExt /* = NULL */,
                               BOOL fAddedAsLocal);
HRESULT CreateDataObjectFromRouterInfo(IRouterInfo *pInfo,
									   LPCTSTR pszMachineName,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt /* = NULL */,
                                       BOOL fAddedAsLocal);
HRESULT CreateDataObjectFromRtrMgrInfo(IRtrMgrInfo *pInfo,
									  IDataObject **ppDataObject);
HRESULT CreateDataObjectFromInterfaceInfo(IInterfaceInfo *pInfo,
										  DATA_OBJECT_TYPES type,
										  MMC_COOKIE cookie,
										  ITFSComponentData *pTFSCompData,
										 IDataObject **ppDataObject);
HRESULT CreateDataObjectFromRtrMgrInterfaceInfo(IRtrMgrInterfaceInfo *pInfo,
											   IDataObject **ppDataObject);
HRESULT CreateDataObjectFromRtrMgrProtocolInterfaceInfo(IRtrMgrProtocolInterfaceInfo *pInfo,
	IDataObject **ppDataObject);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\isbound.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       isbound.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <netcfgx.h>
#include <devguid.h>

// Note: ReleaseObj() checks for NULL before actually releasing the pointer

ULONG APIENTRY
ReleaseObj (
    void* punk)
{
    return (punk) ? (((IUnknown*)punk)->Release()) : 0;
}


HRESULT HrGetINetCfg(IN BOOL fGetWriteLock,
                     INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    // Initialize the output parameters.
    *ppnc = NULL;

    // initialize COM
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    static const ULONG c_cmsTimeout = 15000;
                    static const TCHAR c_szSampleNetcfgApp[] =
                        TEXT("Routing and Remote Access Manager (mprsnap.dll)");
                    LPTSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(c_cmsTimeout, c_szSampleNetcfgApp,
                                               &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                        _tprintf(TEXT("Could not lock INetcfg, it is already locked by '%s'"), szLockedBy);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    // initialize failed, if obtained lock, release it
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }
            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrReleaseINetCfg
//
// Purpose:   Uninitialize INetCfg, release write lock (if present)
//            and uninitialize COM.
//
// Arguments:
//    fHasWriteLock [in]  whether write lock needs to be released.
//    pnc           [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 01-October-98
//
// Notes:
//
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc)
{
    HRESULT hr = S_OK;

    // uninitialize INetCfg
    hr = pnc->Uninitialize();

    // if write lock is present, unlock it
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);

    CoUninitialize();

    return hr;
}

BOOL IsProtocolBoundToAdapter(INetCfg * pnc, INetCfgComponent* pncc, LPGUID pguid)
{
    HRESULT       hr;
    BOOL          fBound = FALSE;
    BOOL          fFound = FALSE;
    INetCfgClass* pncclass;

    // Get the Adapter Class
    //
    hr = pnc->QueryNetCfgClass(&GUID_DEVCLASS_NET, IID_INetCfgClass,
                               reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        IEnumNetCfgComponent* pencc = NULL;
        INetCfgComponent*     pnccAdapter = NULL;
        ULONG                 celtFetched;

        // Search for the adapter in question
        //
        hr = pncclass->EnumComponents(&pencc);

        while (SUCCEEDED(hr) && (S_OK == (hr = pencc->Next(1, &pnccAdapter, &celtFetched))))
        {
            GUID guidAdapter;

            // Get the adapter's instance ID
            //
            hr = pnccAdapter->GetInstanceGuid(&guidAdapter);
            if (SUCCEEDED(hr))
            {
                // Is this the one we're looking for?
                //
                if (*pguid == guidAdapter)
                {
                    INetCfgComponentBindings* pnccBind = NULL;

                    // Get the Bindings interface and check if we're bound
                    //
                    hr = pncc->QueryInterface (IID_INetCfgComponentBindings,
                                               reinterpret_cast<VOID**>(&pnccBind));
                    if (SUCCEEDED(hr))
                    {
                        // Is the protocol bound to this adapter?
                        //
                        hr = pnccBind->IsBoundTo (pnccAdapter);
                        if (S_OK == hr)
                        {
                            fBound = TRUE;
                        }

                        pnccBind->Release();
                    }

                    // We found the adapter, no need to search further
                    //
                    fFound = TRUE;
                }
            }

            ReleaseObj(pnccAdapter);
        }

        ReleaseObj(pencc);
        ReleaseObj(pncclass);
    }

    return fBound;
}


BOOL FIsAppletalkBoundToAdapter(INetCfg * pnc, LPWSTR pszwInstanceGuid)
{
    BOOL    fBound = FALSE;
    GUID    guidInstance;
    HRESULT hr;

    // change the instance guid string to a guid
    //
    hr = IIDFromString(const_cast<LPTSTR>(pszwInstanceGuid),
                       static_cast<LPIID>(&guidInstance));
    if (SUCCEEDED(hr))
    {
        INetCfgClass* pncclass;

        // Find the Appletalk component
        //
        hr = pnc->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS, IID_INetCfgClass,
                                   reinterpret_cast<void**>(&pncclass));
        if (SUCCEEDED(hr))
        {
            INetCfgComponent* pnccAtlk = NULL;

            hr = pncclass->FindComponent(NETCFG_TRANS_CID_MS_APPLETALK, &pnccAtlk);

            // This call may succeed, but return S_FALSE if
            // Appletalk is not installed.  Thus, we need to
            // check for S_OK.
            if (FHrOK(hr))
            {
                Assert(pnccAtlk);
                fBound = IsProtocolBoundToAdapter(pnc, pnccAtlk, &guidInstance);
                ReleaseObj(pnccAtlk);
            }

            ReleaseObj(pncclass);
        }
        else
            DisplayErrorMessage(NULL, hr);

    }

    return fBound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\infopriv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	infopriv.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "infoi.h"
#include "rtrstr.h"			// common router strings
#include "rtrdata.h"		// CRouterDataObject
#include "setupapi.h"		// SetupDi* functions

static const GUID GUID_DevClass_Net = {0x4D36E972,0xE325,0x11CE,{0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18}};


typedef DWORD (APIENTRY* PRASRPCCONNECTSERVER)(LPTSTR, HANDLE *);
typedef DWORD (APIENTRY* PRASRPCDISCONNECTSERVER)(HANDLE);
typedef DWORD (APIENTRY* PRASRPCREMOTEGETSYSTEMDIRECTORY)(HANDLE, LPTSTR, UINT);
typedef DWORD (APIENTRY* PRASRPCREMOTERASDELETEENTRY)(HANDLE, LPTSTR, LPTSTR);

HRESULT RasPhoneBookRemoveInterface(LPCTSTR pszMachine, LPCTSTR pszIf)
{			
	CString		stPath;
	DWORD		dwErr;
	HINSTANCE	hrpcdll = NULL;
	TCHAR		szSysDir[MAX_PATH+1];

	PRASRPCCONNECTSERVER pRasRpcConnectServer;
	PRASRPCDISCONNECTSERVER pRasRpcDisconnectServer;
	PRASRPCREMOTEGETSYSTEMDIRECTORY pRasRpcRemoteGetSystemDirectory;
	PRASRPCREMOTERASDELETEENTRY pRasRpcRemoteRasDeleteEntry;
	HANDLE hConnection = NULL;

	if (!(hrpcdll = LoadLibrary(TEXT("rasman.dll"))) ||
		!(pRasRpcConnectServer = (PRASRPCCONNECTSERVER)GetProcAddress(
											hrpcdll, "RasRpcConnectServer"
		)) ||
		!(pRasRpcDisconnectServer = (PRASRPCDISCONNECTSERVER)GetProcAddress(
											hrpcdll, "RasRpcDisconnectServer"
		)) ||
		!(pRasRpcRemoteGetSystemDirectory =
							   (PRASRPCREMOTEGETSYSTEMDIRECTORY)GetProcAddress(
									hrpcdll, "RasRpcRemoteGetSystemDirectory"
		)) ||
		!(pRasRpcRemoteRasDeleteEntry =
								(PRASRPCREMOTERASDELETEENTRY)GetProcAddress(
									hrpcdll, "RasRpcRemoteRasDeleteEntry"
		)))
		{
			
			if (hrpcdll) { FreeLibrary(hrpcdll); }
			return hrOK;
		}
				
	dwErr = pRasRpcConnectServer((LPTSTR)pszMachine, &hConnection);
	
	if (dwErr == NO_ERROR)
	{
		szSysDir[0] = TEXT('\0');

		//$ Review: kennt, are these functions WIDE or ANSI?
		// We can't just pass in TCHARs.  Since we're dynamically
		// linking to these functions we need to know.
		
		// This is bogus, if this call fails we don't know what to do
		pRasRpcRemoteGetSystemDirectory(hConnection, szSysDir, MAX_PATH);
		
		stPath.Format(TEXT("%s\\RAS\\%s"), szSysDir, c_szRouterPbk);
		
		dwErr = pRasRpcRemoteRasDeleteEntry(
		                            hConnection,
									(LPTSTR)(LPCTSTR)stPath,
									(LPTSTR)(LPCTSTR)pszIf
								   );
		pRasRpcDisconnectServer(hConnection);
	}

    if (hrpcdll)
        FreeLibrary(hrpcdll);
	
	return HRESULT_FROM_WIN32(dwErr);
}




/*---------------------------------------------------------------------------
	CNetcardRegistryHelper implemenation
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::CNetcardRegistryHelper
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CNetcardRegistryHelper::CNetcardRegistryHelper()
	: m_hkeyBase(NULL),
	m_hkeyService(NULL),
	m_hkeyTitle(NULL),
    m_hkeyConnection(NULL),
	m_fInit(FALSE),
	m_fNt4(FALSE),
	m_hDevInfo(INVALID_HANDLE_VALUE)
{
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::~CNetcardRegistryHelper
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CNetcardRegistryHelper::~CNetcardRegistryHelper()
{
    FreeDevInfo();

 	if (m_hkeyTitle && (m_hkeyTitle != m_hkeyBase))
		::RegCloseKey(m_hkeyTitle);

    if (m_hkeyService && (m_hkeyService != m_hkeyBase))
		::RegCloseKey(m_hkeyService);

    if (m_hkeyConnection)
        ::RegCloseKey(m_hkeyConnection);
}

void CNetcardRegistryHelper::FreeDevInfo()
{
	if (m_hDevInfo != INVALID_HANDLE_VALUE)
	{
		SetupDiDestroyDeviceInfoList(m_hDevInfo);
		m_hDevInfo = INVALID_HANDLE_VALUE;
	}
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::Initialize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void CNetcardRegistryHelper::Initialize(BOOL fNt4, HKEY hkeyBase, LPCTSTR pszKeyBase, LPCTSTR pszMachineName)
{
	m_fNt4 = fNt4;
	m_hkeyBase = hkeyBase;
	m_hkeyService = NULL;
	m_hkeyTitle = NULL;
	m_fInit = FALSE;
	m_stService.Empty();
	m_stTitle.Empty();
	m_stKeyBase = pszKeyBase;
	m_stMachineName.Empty();

    
    // Get the connection registry key
    if (!m_fNt4 && hkeyBase)
    {
        if (m_hkeyConnection != NULL)
        {
            RegCloseKey(m_hkeyConnection);
            m_hkeyConnection = NULL;
        }
        
        if (RegOpenKey(hkeyBase, c_szRegKeyConnection, &m_hkeyConnection)
                != ERROR_SUCCESS)
        {
            m_hkeyConnection = NULL;
        }
    }

    // Get up the setup api info
	if (!m_fNt4)
	{
        FreeDevInfo();

        if (IsLocalMachine(pszMachineName))
		{
			m_hDevInfo = SetupDiCreateDeviceInfoList((LPGUID) &GUID_DevClass_Net, NULL);
		}
		else
		{
			if (StrniCmp(pszMachineName, _T("\\\\"), 2) != 0)
			{
				m_stMachineName = _T("\\\\");
				m_stMachineName += pszMachineName;
			}
			else
				m_stMachineName = pszMachineName;
			
			m_hDevInfo = SetupDiCreateDeviceInfoListEx(
				(LPGUID) &GUID_DevClass_Net,
				NULL,
				(LPCTSTR) m_stMachineName,
				0);
		}
	}
		
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::ReadServiceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNetcardRegistryHelper::ReadServiceName()
{
	DWORD	dwErr = ERROR_SUCCESS;
	LPCTSTR	pszService;

	dwErr = PrivateInit();
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	Assert(m_fNt4);

	pszService = m_fNt4 ? c_szServiceName : c_szService;

	dwErr = ReadRegistryCString(_T(""), pszService,
								m_hkeyService, &m_stService);
	return dwErr;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::GetServiceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPCTSTR CNetcardRegistryHelper::GetServiceName()
{
	ASSERT(m_fInit);
	return m_stService;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::ReadTitle
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNetcardRegistryHelper::ReadTitle()
{
	DWORD	dwErr = ERROR_SUCCESS;
	CString	stTemp;
	TCHAR		szDesc[1024];
	
	dwErr = PrivateInit();
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	if (m_fNt4)
	{
		dwErr = ReadRegistryCString(_T(""), c_szTitle,
									m_hkeyTitle, &stTemp);
		if (dwErr == ERROR_SUCCESS)
			m_stTitle = stTemp;
	}
	else
	{
		
		//$NT5
		SPMprConfigHandle	sphConfig;
		LPWSTR				pswz;
		
		if (m_stMachineName.IsEmpty())
			pswz = NULL;
		else
			pswz = (LPTSTR) (LPCTSTR) m_stMachineName;

		dwErr = ::MprConfigServerConnect(pswz,
										 &sphConfig);

		if (dwErr == ERROR_SUCCESS)
			dwErr = ::MprConfigGetFriendlyName(sphConfig,
											   T2W((LPTSTR)(LPCTSTR)m_stKeyBase),
											   szDesc,
											   sizeof(szDesc));

		m_stTitle = szDesc;
	}
//Error:	
	return dwErr;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::GetTitle
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPCTSTR CNetcardRegistryHelper::GetTitle()
{
	Assert(m_fInit);
 	return m_stTitle;
}


/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::ReadDeviceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNetcardRegistryHelper::ReadDeviceName()
{
	SP_DEVINFO_DATA	DevInfo;
	CString	stPnpInstanceID;
	DWORD		dwType = REG_SZ;
	TCHAR		szDesc[1024];
	DWORD	dwErr = ERROR_SUCCESS;
	

	if (m_fNt4)
	{
		if (m_stTitle.IsEmpty())
			dwErr = ReadTitle();
		m_stDeviceName = m_stTitle;
	}
	else
	{
		//$NT5
		// For NT5, we have a much harder time, since this involves
		// multiple lookups

        // Windows NT Bug : ?
        // The New Binding Engine changed some of the keys around,
        // We neet do look at the
		// HKLM\SYSTEM\CCS\Control\Network\{GUID_DEVCLASS_NET}\{netcard guid}\Connection
		// From this subkey get the PnpInstanceID

        if (m_hkeyConnection)
            dwErr = ReadRegistryCString(_T("HKLM\\SYSTEM\\CCS\\Control\\Network\\{GID_DEVCLASS_NET}\\{netcard guid}\\Connection"),
                                        c_szPnpInstanceID,
                                        m_hkeyConnection,
                                        &stPnpInstanceID);

		// ok, the base key is
		// HKLM\SYSTEM\CCS\Control\Network\{GUID_DEVCLASS_NET}\{netcard guid}
		// From this subkey get the PnpInstanceID

        if (dwErr != ERROR_SUCCESS)
            dwErr = ReadRegistryCString(_T("HKLM\\SYSTEM\\CCS\\Control\\Network\\{GID_DEVCLASS_NET}\\{netcard guid}"),
                                        c_szPnpInstanceID,
                                        m_hkeyBase,
                                        &stPnpInstanceID);
		if (dwErr != ERROR_SUCCESS)			
			goto Error;


		// Initialize the structure
		::ZeroMemory(&DevInfo, sizeof(DevInfo));
		DevInfo.cbSize = sizeof(DevInfo);
		
		if (!SetupDiOpenDeviceInfo(m_hDevInfo,
								   (LPCTSTR) stPnpInstanceID,
								   NULL,
								   0,
								   &DevInfo
								  ))
		{
			dwErr = GetLastError();
			goto Error;
		}

		// Try to get the friendly name first
		if (!SetupDiGetDeviceRegistryProperty(m_hDevInfo,
											  &DevInfo,
											  SPDRP_FRIENDLYNAME,
											  &dwType,
											  (LPBYTE) szDesc,
											  sizeof(szDesc),
											  NULL
											 ))
		{
			// If we fail to get the friendly name, try to
			// get the device description instead.
			if (!SetupDiGetDeviceRegistryProperty(m_hDevInfo,
				&DevInfo,
				SPDRP_DEVICEDESC,
				&dwType,
				(LPBYTE) szDesc,
				sizeof(szDesc),
				NULL
				))
			{
				dwErr = GetLastError();
				goto Error;
			}
		}

		m_stDeviceName = szDesc;
	}

Error:
	return dwErr;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::GetDeviceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPCTSTR CNetcardRegistryHelper::GetDeviceName()
{
	Assert(m_fInit);
	return m_stDeviceName;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::PrivateInit
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNetcardRegistryHelper::PrivateInit()
{
	DWORD	dwErr = ERROR_SUCCESS;
	
	if (m_fInit)
		return ERROR_SUCCESS;

	m_fInit = TRUE;

	if (m_fNt4)
	{
		// For NT4, we don't need to do anything, we are at the
		// place where we want to read the data
		m_hkeyService = m_hkeyBase;
		m_hkeyTitle = m_hkeyBase;
	}
	else
	{
		// We don't need m_hkeyService for NT5
		m_hkeyService = NULL;
		m_hkeyTitle = NULL;
	}
		

//Error:

	if (dwErr != ERROR_SUCCESS)
	{
		if (m_hkeyService)
			::RegCloseKey(m_hkeyService);
		m_hkeyService = NULL;
		
		if (m_hkeyTitle)
			::RegCloseKey(m_hkeyTitle);
		m_hkeyTitle = NULL;

		m_fInit = FALSE;
	}
	
	return dwErr;
}

/*!--------------------------------------------------------------------------
	CNetcardRegistryHelper::ReadRegistryCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNetcardRegistryHelper::ReadRegistryCString(
									LPCTSTR pszKey,
									LPCTSTR pszValue,
									HKEY	hkey,
									CString *pstDest)
{
	DWORD	dwSize, dwType;
	DWORD	dwErr = ERROR_SUCCESS;

	ASSERT(pstDest);
	
	dwSize = 0;
	dwErr = ::RegQueryValueEx(hkey,
							  pszValue,
							  NULL,
							  &dwType,
							  NULL,
							  &dwSize);
	CheckRegQueryValueError(dwErr, pszKey, pszValue, TEXT("CNetcardRegistryHelper::ReadRegistryCString"));
	if (dwErr != ERROR_SUCCESS)
		goto Error;
	ASSERT(dwType == REG_SZ);

	// Increase size to handle terminating NULL
	dwSize ++;
	
	dwErr = ::RegQueryValueEx(hkey,
							  pszValue,
							  NULL,
							  &dwType,
							  (LPBYTE) pstDest->GetBuffer(dwSize),
							  &dwSize);
	pstDest->ReleaseBuffer();
	
	CheckRegQueryValueError(dwErr, pszKey, pszValue, _T("CNetcardRegistryHelper::ReadRegistryCString"));
	if (dwErr != ERROR_SUCCESS)
		goto Error;

Error:
	return dwErr;
}

CWeakRef::CWeakRef()
	: m_cRef(1),
	m_cRefWeak(0),
	m_fStrongRef(TRUE),
	m_fDestruct(FALSE),
	m_fInShutdown(FALSE)
{
}

STDMETHODIMP_(ULONG) CWeakRef::AddRef()
{
	ULONG	ulReturn;
	Assert(m_cRef >= m_cRefWeak);
	ulReturn = InterlockedIncrement(&m_cRef);
	if (!m_fStrongRef)
	{
		m_fStrongRef = TRUE;
		ReviveStrongRef();
	}
	return ulReturn;	
}

STDMETHODIMP_(ULONG) CWeakRef::Release()
{
	ULONG	ulReturn;
	BOOL	fShutdown = m_fInShutdown;
	
	Assert(m_cRef >= m_cRefWeak);
	
	ulReturn = InterlockedDecrement(&m_cRef);
	if (ulReturn == 0)
		m_fInShutdown = TRUE;
	
	if ((m_cRef == m_cRefWeak) && m_fStrongRef)
	{
		m_fStrongRef = FALSE;

		AddWeakRef();
		
		OnLastStrongRef();

		ReleaseWeakRef();

	}

	if (ulReturn == 0 && (m_fInShutdown != fShutdown) && m_fInShutdown)
		delete this;
	return ulReturn;
}

STDMETHODIMP CWeakRef::AddWeakRef()
{
	Assert(m_cRef >= m_cRefWeak);
	InterlockedIncrement(&m_cRef);
	InterlockedIncrement(&m_cRefWeak);
	return hrOK;
}

STDMETHODIMP CWeakRef::ReleaseWeakRef()
{
	Assert(m_cRef >= m_cRefWeak);
	InterlockedDecrement(&m_cRefWeak);
	Release();
	return hrOK;
}


void SRouterCB::LoadFrom(const RouterCB *pcb)
{
	dwLANOnlyMode = pcb->dwLANOnlyMode;
}

void SRouterCB::SaveTo(RouterCB *pcb)
{
	pcb->dwLANOnlyMode = dwLANOnlyMode;
}


void SRtrMgrCB::LoadFrom(const RtrMgrCB *pcb)
{
	dwTransportId = pcb->dwTransportId;
	stId = pcb->szId;
	stTitle = pcb->szTitle;
	stDLLPath = pcb->szDLLPath;
//	stConfigDLL = pcb->szConfigDLL;			
}

void SRtrMgrCB::SaveTo(RtrMgrCB *pcb)
{
	pcb->dwTransportId = dwTransportId;
	StrnCpyOleFromT(pcb->szId, (LPCTSTR) stId, RTR_ID_MAX);
	StrnCpyOleFromT(pcb->szTitle, (LPCTSTR) stTitle, RTR_TITLE_MAX);
	StrnCpyOleFromT(pcb->szDLLPath, (LPCTSTR) stDLLPath, RTR_PATH_MAX);
//	StrnCpyOleFromT(pcb->szConfigDLL, (LPCTSTR) stConfigDLL, RTR_PATH_MAX);
}


void SRtrMgrProtocolCB::LoadFrom(const RtrMgrProtocolCB *pcb)
{
	dwProtocolId = pcb->dwProtocolId;
	stId = pcb->szId;
    dwFlags = pcb->dwFlags;
	dwTransportId = pcb->dwTransportId;
	stRtrMgrId = pcb->szRtrMgrId;
	stTitle = pcb->szTitle;
	stDLLName = pcb->szDLLName;
//	stConfigDLL = pcb->szConfigDLL;
	guidAdminUI = pcb->guidAdminUI;
	guidConfig = pcb->guidConfig;
	stVendorName = pcb->szVendorName;
}

void SRtrMgrProtocolCB::SaveTo(RtrMgrProtocolCB *pcb)
{
	pcb->dwProtocolId = dwProtocolId;
	StrnCpyOleFromT(pcb->szId, (LPCTSTR) stId, RTR_ID_MAX);
    pcb->dwFlags = dwFlags;
	pcb->dwTransportId = dwTransportId;
	StrnCpyOleFromT(pcb->szRtrMgrId, (LPCTSTR) stRtrMgrId, RTR_ID_MAX);
	StrnCpyOleFromT(pcb->szTitle, (LPCTSTR) stTitle, RTR_TITLE_MAX);
	StrnCpyOleFromT(pcb->szDLLName, (LPCTSTR) stDLLName, RTR_PATH_MAX);
//	StrnCpyOleFromT(pcb->szConfigDLL, (LPCTSTR) stConfigDLL, RTR_PATH_MAX);
	pcb->guidAdminUI = guidAdminUI;
	pcb->guidConfig = guidConfig;
	StrnCpyOleFromT(pcb->szVendorName, (LPCTSTR) stVendorName, VENDOR_NAME_MAX);
}


void SInterfaceCB::LoadFrom(const InterfaceCB *pcb)
{
	stId = pcb->szId;
	stDeviceName = pcb->szDevice;
	dwIfType = pcb->dwIfType;
	bEnable = pcb->bEnable;
	stTitle = pcb->szTitle;
    dwBindFlags = pcb->dwBindFlags;
}

void SInterfaceCB::SaveTo(InterfaceCB *pcb)
{
	StrnCpyOleFromT(pcb->szId, (LPCTSTR) stId, RTR_ID_MAX);
	StrnCpyOleFromT(pcb->szDevice, (LPCTSTR) stDeviceName, RTR_DEVICE_MAX);
	pcb->dwIfType = dwIfType;
	pcb->bEnable = bEnable;
	StrnCpyOleFromT(pcb->szTitle, (LPCTSTR) stTitle, RTR_TITLE_MAX);
    pcb->dwBindFlags = dwBindFlags;
}


void SRtrMgrInterfaceCB::LoadFrom(const RtrMgrInterfaceCB *pcb)
{
	dwTransportId = pcb->dwTransportId;
	stId = pcb->szId;
	stInterfaceId = pcb->szInterfaceId;
	dwIfType = pcb->dwIfType;
	stTitle = pcb->szTitle;
}

void SRtrMgrInterfaceCB::SaveTo(RtrMgrInterfaceCB *pcb)
{
	pcb->dwTransportId = dwTransportId;
	StrnCpyOleFromT(pcb->szId, (LPCTSTR) stId, RTR_ID_MAX);
	StrnCpyOleFromT(pcb->szInterfaceId, (LPCTSTR) stInterfaceId, RTR_ID_MAX);
	pcb->dwIfType = dwIfType;
	StrnCpyOleFromT(pcb->szTitle, (LPCTSTR) stTitle, RTR_TITLE_MAX);
}


void SRtrMgrProtocolInterfaceCB::LoadFrom(const RtrMgrProtocolInterfaceCB *pcb)
{
	dwProtocolId = pcb->dwProtocolId;
	stId = pcb->szId;
	dwTransportId = pcb->dwTransportId;
	stRtrMgrId = pcb->szRtrMgrId;
	stInterfaceId = pcb->szInterfaceId;
	dwIfType = pcb->dwIfType;
	stTitle = pcb->szTitle;
}

void SRtrMgrProtocolInterfaceCB::SaveTo(RtrMgrProtocolInterfaceCB *pcb)
{
	pcb->dwProtocolId = dwProtocolId;
	StrnCpyOleFromT(pcb->szId, (LPCTSTR) stId, RTR_ID_MAX);
	pcb->dwTransportId = dwTransportId;
	StrnCpyOleFromT(pcb->szRtrMgrId, (LPCTSTR) stRtrMgrId, RTR_ID_MAX);
	StrnCpyOleFromT(pcb->szInterfaceId, (LPCTSTR) stInterfaceId, RTR_TITLE_MAX);
	pcb->dwIfType = dwIfType;
	StrnCpyOleFromT(pcb->szTitle, (LPCTSTR) stTitle, RTR_PATH_MAX);
}



/*!--------------------------------------------------------------------------
	CreateDataObjectFromRouterInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromRouterInfo(IRouterInfo *pInfo,
									   LPCTSTR pszMachineName,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt,
                                       BOOL fAddedAsLocal)
{
	Assert(ppDataObject);
	CRouterDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CRouterDataObject;
	spDataObject = pdo;

	pdo->SetComputerName(pszMachineName);
    pdo->SetComputerAddedAsLocal(fAddedAsLocal);
	
	CORg( CreateRouterInfoAggregation(pInfo, pdo, &spunk) );
	
	pdo->SetInnerIUnknown(spunk);
		
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclasscls with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);

    pdo->SetDynExt(pDynExt);

	*ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	AdviseDataList::AddConnection
		Adds a connection to the list.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AdviseDataList::AddConnection(IRtrAdviseSink *pAdvise,
									  LONG_PTR ulConnId,
									  LPARAM lUserParam)
{
	Assert(pAdvise);
	
	HRESULT	hr = hrOK;
	SAdviseData	adviseData;
	
	COM_PROTECT_TRY
	{
		adviseData.m_ulConnection = ulConnId;
		adviseData.m_pAdvise = pAdvise;
		adviseData.m_lUserParam = lUserParam;

		AddTail(adviseData);
		
		pAdvise->AddRef();
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	AdviseDataList::RemoveConnection
		Removes the connection from the list.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AdviseDataList::RemoveConnection(LONG_PTR ulConnection)
{
	HRESULT		hr = E_INVALIDARG;
	POSITION	pos, posTemp;
    POSITION    posNotify;
	SAdviseData	adviseData;
	
	COM_PROTECT_TRY
	{
		pos = GetHeadPosition();
		while (pos)
		{
			posTemp = pos;
			adviseData = GetNext(pos);
			if (adviseData.m_ulConnection == ulConnection)
			{
				hr = hrOK;
				SAdviseData::Destroy(&adviseData);
				RemoveAt(posTemp);

                // Remove this connection from the list
                if (!m_listNotify.IsEmpty())
                {
                    posNotify = m_listNotify.GetHeadPosition();
                    while (posNotify)
                    {
                        posTemp = posNotify;
                        adviseData = m_listNotify.GetNext(posNotify);
                        if (adviseData.m_ulConnection == ulConnection)
                        {
                            adviseData.m_ulFlags |= ADVISEDATA_DELETED;
                            m_listNotify.SetAt(posTemp, adviseData);
                            break;
                        }
                    }
                }
				break;
			}
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	AdviseDataList::NotifyChange
		Enumerates through the list of advise sinks and sends this
		notification to each one.		
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AdviseDataList::NotifyChange(DWORD dwChangeType,
									 DWORD dwObjectType,
									 LPARAM lParam)
{
	POSITION	pos;
	SAdviseData	adviseData;
	HRESULT		hr = hrOK;

    // This requires a two-step process.  (this is necessary since
    // a callback here, may change the items in the list).

    // First, gather a list of all the advise sinks (place them
    // in a list).
    //
    // Secondly, go through the list calling the OnChange()
    // notifications.  THIS LIST MAY BE MODIFIED BY A CALL TO
    // THE UNADVISE FUNCTIONS.  This means that the unadvise must
    // traverse this list.


    // Remove all entries in m_listNotify
    m_listNotify.RemoveAll();

    
    // Do the first step and build up the list
	pos = GetHeadPosition();

	while (pos)
	{
		adviseData = GetNext(pos);
        adviseData.m_ulFlags = 0;

        m_listNotify.AddTail(adviseData);
    }

    // Now go through the notify list and send out the notifies
    pos = m_listNotify.GetHeadPosition();
    while (pos)
    {
        adviseData = m_listNotify.GetNext(pos);

        if ((adviseData.m_ulFlags & ADVISEDATA_DELETED) == 0)
        {
            // Ignore the return value
            adviseData.m_pAdvise->OnChange(adviseData.m_ulConnection,
                                           dwChangeType,
                                           dwObjectType,
                                           adviseData.m_lUserParam,
                                           lParam);
        }
	}

    // Clear out the list again
    m_listNotify.RemoveAll();
	return hr;
}


void SAdviseData::Destroy(SAdviseData *pAdviseData)
{
	if (pAdviseData && pAdviseData->m_pAdvise)
	{
		pAdviseData->m_pAdvise->Release();
		pAdviseData->m_pAdvise = NULL;
		pAdviseData->m_ulConnection = NULL;
		pAdviseData->m_lUserParam = 0;
	}
#ifdef DEBUG
	else if (pAdviseData)
		Assert(pAdviseData->m_ulConnection == 0);
#endif
}

void SRmData::Destroy(SRmData *pRmData)
{
	if (pRmData && pRmData->m_pRmInfo)
	{
        // This destruct should only get called if this RtrMgr is
        // a child of this node.
		pRmData->m_pRmInfo->Destruct();
		pRmData->m_pRmInfo->ReleaseWeakRef();

		pRmData->m_pRmInfo = NULL;
	}
}



/*!--------------------------------------------------------------------------
	CreateDataObjectFromInterfaceInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromInterfaceInfo(IInterfaceInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject)
{
	Assert(ppDataObject);

	HRESULT			hr = hrOK;
	CRouterDataObject *	pdo = NULL;
	SPIDataObject	spDataObject;
	SPIUnknown		spunk;

	pdo = new CRouterDataObject;
	spDataObject = pdo;

	pdo->SetComputerName(pInfo->GetMachineName());

	CORg( CreateInterfaceInfoAggregation(pInfo, pdo, &spunk) );

	pdo->SetInnerIUnknown(spunk);
	
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclass with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);
						
	*ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	LookupRtrMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) LookupRtrMgr(IRouterInfo *pRouter,
								  DWORD dwTransportId,
								  IRtrMgrInfo **ppRm)
{
	Assert(pRouter);
	Assert(ppRm);
	return pRouter->FindRtrMgr(dwTransportId, ppRm);
}

/*!--------------------------------------------------------------------------
	LookupRtrMgrProtocol
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) LookupRtrMgrProtocol(IRouterInfo *pRouter,
										  DWORD dwTransportId,
										  DWORD dwProtocolId,
										  IRtrMgrProtocolInfo **ppRmProt)
{
	Assert(pRouter);
	Assert(ppRmProt);

	SPIRtrMgrInfo	spRm;
	HRESULT			hr = hrOK;
	
	CORg( LookupRtrMgr(pRouter, dwTransportId, &spRm) );

	if (FHrOK(hr))
		CORg( spRm->FindRtrMgrProtocol(dwProtocolId, ppRmProt) );

Error:
	return hr;
}


TFSCORE_API(HRESULT) LookupRtrMgrInterface(IRouterInfo *pRouter,
										   LPCOLESTR pszInterfaceId,
										   DWORD dwTransportId,
										   IRtrMgrInterfaceInfo **ppRmIf)
{
	Assert(pRouter);
	SPIInterfaceInfo	spIf;
	HRESULT				hr = hrFalse;

	CORg( pRouter->FindInterface(pszInterfaceId, &spIf) );
	if (FHrOK(hr))
	{
		hr = spIf->FindRtrMgrInterface(dwTransportId, ppRmIf);
	}

Error:
	return hr;
}

TFSCORE_API(HRESULT) LookupRtrMgrProtocolInterface(
	IInterfaceInfo *pIf, DWORD dwTransportId, DWORD dwProtocolId,
	IRtrMgrProtocolInterfaceInfo **ppRmProtIf)
{
	Assert(pIf);
	SPIRtrMgrInterfaceInfo	spRmIf;
	HRESULT				hr = hrFalse;

	hr = pIf->FindRtrMgrInterface(dwTransportId, &spRmIf);
	if (FHrOK(hr))
		CORg( spRmIf->FindRtrMgrProtocolInterface(dwProtocolId, ppRmProtIf) );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateRouterDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateRouterDataObject(LPCTSTR pszMachineName,
							   DATA_OBJECT_TYPES type,
							   MMC_COOKIE cookie,
							   ITFSComponentData *pTFSCompData,
							   IDataObject **ppDataObject,
                               CDynamicExtensions * pDynExt,
                               BOOL fAddedAsLocal)
{
	Assert(ppDataObject);
	CRouterDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CRouterDataObject;
	spDataObject = pdo;

	pdo->SetComputerName(pszMachineName);
    pdo->SetComputerAddedAsLocal(fAddedAsLocal);
	
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclasscls with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);

    pdo->SetDynExt(pDynExt);

	*ppDataObject = spDataObject.Transfer();

//Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\msgdlg.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:	msgdlg.h
//
// History:
//	10/23/96	Abolade Gbadegesin		Created.
//
// Declarations for the "Send Message" dialogs.
//============================================================================


#ifndef _MSGDLG_H_
#define _MSGDLG_H_

class CMessageDlg : public CBaseDialog {

	public:

		CMessageDlg(
			LPCTSTR 			pszServerName,
			LPCTSTR 			pszUserName,
			LPCTSTR 			pszComputer,
			HANDLE				hConnection,
			CWnd*				pParent = NULL );

		CMessageDlg(
			LPCTSTR 			pszServerName,
			LPCTSTR 			pszTarget,
			CWnd*				pParent = NULL );

	protected:

		static DWORD			m_dwHelpMap[];

		BOOL					m_fUser;
		CString 				m_sServerName;
		CString 				m_sUserName;
		CString 				m_sTarget;
		HANDLE					m_hConnection;

		virtual VOID
		DoDataExchange(
			CDataExchange*		pDX );

		virtual BOOL
		OnInitDialog( );

		virtual VOID
		OnOK( );

		DWORD SendToClient(LPCTSTR pszServerName,
						   LPCTSTR pszTarget,
						   MPR_SERVER_HANDLE hMprServer,
						   HANDLE hConnection,
						   LPCTSTR pszMessage);

		DWORD
		SendToServer(
			LPCTSTR 			 pszServer,
			LPCTSTR 			 pszText,
			BOOL*				pbCancel	= NULL );

		DECLARE_MESSAGE_MAP()
};


#endif // _MSGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\mstatus.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipface
		Base IP interface node handler
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipface.h"
#include "ipadmin.h"	// for CreateDataObjectFromInterfaceInfo
#include "column.h"		// for ComponentConfigStream
#include "ipconn.h"		// for IPConnection
#include "mstatus.h"


BaseIPResultNodeData::BaseIPResultNodeData()
{
#ifdef DEBUG
	StrCpy(m_szDebug, _T("BaseIPResultNodeData"));
#endif
	m_pIPConnection = NULL;
}

BaseIPResultNodeData::~BaseIPResultNodeData()
{
	if (m_pIPConnection)
		m_pIPConnection->Release();
	m_pIPConnection = NULL;
}

HRESULT BaseIPResultNodeData::Init(ITFSNode *pNode, IInterfaceInfo *pIf,
								  IPConnection *pIPConn)
{
	HRESULT				hr = hrOK;
	BaseIPResultNodeData *	pData = NULL;
	
	pData = new BaseIPResultNodeData;
	pData->m_spIf.Set(pIf);
	pData->m_pIPConnection = pIPConn;
	pIPConn->AddRef();

	SET_BASEIPRESULT_NODEDATA(pNode, pData);
	
	return hr;
}

HRESULT BaseIPResultNodeData::Free(ITFSNode *pNode)
{	
	BaseIPResultNodeData *	pData = GET_BASEIPRESULT_NODEDATA(pNode);
	ASSERT_BASEIPRESULT_NODEDATA(pData);
	pData->m_spIf.Release();
	delete pData;
	SET_BASEIPRESULT_NODEDATA(pNode, NULL);
	
	return hrOK;
}


/*---------------------------------------------------------------------------
	BaseIPResultHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(BaseIPResultHandler)

IMPLEMENT_ADDREF_RELEASE(BaseIPResultHandler)

STDMETHODIMP BaseIPResultHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CBaseResultHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	BaseIPResultHandler::GetString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) BaseIPResultHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
	Assert(m_spNodeMgr);
	
	SPITFSNode		spNode;
	BaseIPResultNodeData *	pData;
	ConfigStream *	pConfig;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pData = GET_BASEIPRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPRESULT_NODEDATA(pData);

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	return pData->m_rgData[pConfig->MapColumnToSubitem(m_ulColumnId, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
	BaseIPResultHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) BaseIPResultHandler::CompareItems(ITFSComponent * pComponent,
	MMC_COOKIE cookieA, MMC_COOKIE cookieB, int nCol)
{
	ConfigStream *	pConfig;
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	int	nSubItem = pConfig->MapColumnToSubitem(m_ulColumnId, nCol);

	if (pConfig->GetSortCriteria(m_ulColumnId, nCol) == CON_SORT_BY_DWORD)
	{
		SPITFSNode	spNodeA, spNodeB;
		BaseIPResultNodeData *	pNodeDataA, *pNodeDataB;

		m_spNodeMgr->FindNode(cookieA, &spNodeA);
		m_spNodeMgr->FindNode(cookieB, &spNodeB);

		pNodeDataA = GET_BASEIPRESULT_NODEDATA(spNodeA);
		ASSERT_BASEIPRESULT_NODEDATA(pNodeDataA);
		
		pNodeDataB = GET_BASEIPRESULT_NODEDATA(spNodeB);
		ASSERT_BASEIPRESULT_NODEDATA(pNodeDataB);

		return pNodeDataA->m_rgData[nSubItem].m_dwData -
				pNodeDataB->m_rgData[nSubItem].m_dwData;
		
	}
	else
		return StriCmpW(GetString(pComponent, cookieA, nCol),
						GetString(pComponent, cookieB, nCol));
}

ImplementEmbeddedUnknown(BaseIPResultHandler, IRtrAdviseSink)

STDMETHODIMP BaseIPResultHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(BaseIPResultHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;
	
	Panic0("Should never reach here, interface nodes have no children");
	return hr;
}


HRESULT BaseIPResultHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	return hrOK;
}

STDMETHODIMP BaseIPResultHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	BaseIPResultNodeData::Free(spNode);
	
	BaseRouterHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	FillInNumberData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void FillInNumberData(BaseIPResultNodeData *pNodeData, UINT iIndex,
					  DWORD dwData)
{
	TCHAR	szNumber[32];

	FormatNumber(dwData, szNumber, DimensionOf(szNumber), FALSE);
	pNodeData->m_rgData[iIndex].m_stData = szNumber;
	pNodeData->m_rgData[iIndex].m_dwData = dwData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\msgdlg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:	msgdlg.cpp
//
// History:
//	10/23/96	Abolade Gbadegesin		Created.
//
// Implementation of the "Send Message" dialogs.
//============================================================================

#include "stdafx.h"
#include "dialog.h"
#include "rtrstr.h"
extern "C" {
//nclude "dim.h"
//nclude "ras.h"
//nclude "lm.h"
}

#include "msgdlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//----------------------------------------------------------------------------
// Class:		CMessageDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:	CMessageDlg::CMessageDlg
//
// Constructor.
//----------------------------------------------------------------------------

CMessageDlg::CMessageDlg(
	LPCTSTR 		pszServerName,
	LPCTSTR 		pszUserName,
	LPCTSTR 		pszComputer,
	HANDLE			hConnection,
	CWnd*			pParent
	) : CBaseDialog(IDD_DDM_MESSAGE, pParent),
		m_fUser(TRUE),
		m_sServerName(pszServerName ? pszServerName : c_szEmpty),
		m_sUserName(pszUserName ? pszUserName : c_szEmpty),
		m_sTarget(pszComputer ? pszComputer : c_szEmpty),
		m_hConnection(hConnection)
{
}

CMessageDlg::CMessageDlg(
	LPCTSTR 		pszServerName,
	LPCTSTR 		pszTarget,
	CWnd*			pParent
	) : CBaseDialog(IDD_DDM_MESSAGE, pParent),
		m_fUser(FALSE),
		m_sServerName(pszServerName ? pszServerName: c_szEmpty),
		m_sUserName(c_szEmpty),
		m_sTarget(pszTarget ? pszTarget : c_szEmpty)
{
}


//----------------------------------------------------------------------------
// Function:	CMessageDlg::DoDataExchange
//
// DDX handler.
//----------------------------------------------------------------------------

VOID
CMessageDlg::DoDataExchange(
	CDataExchange*	pDX
	) {

	CBaseDialog::DoDataExchange(pDX);
}



BEGIN_MESSAGE_MAP(CMessageDlg, CBaseDialog)
END_MESSAGE_MAP()

DWORD CMessageDlg::m_dwHelpMap[] =
{
//	IDC_DM_TO, HIDC_DM_TO,
//	IDC_DM_MESSAGE, HIDC_DM_MESSAGE,
	0,0
};


//----------------------------------------------------------------------------
// Function:	CMessageDlg::OnInitDialog
//
// Performs dialog initialization.
//----------------------------------------------------------------------------

BOOL
CMessageDlg::OnInitDialog(
	) {

	CBaseDialog::OnInitDialog();


	//
	// Set the 'To' text to indicate who the message is going to
	//

	CString sText;

	if (m_fUser) {

		//
		// We're sending to a client
		//

		AfxFormatString2(sText, IDS_DM_TO_USER_FORMAT, m_sUserName, m_sTarget);
	}
	else {
        CString stTarget;

        // Windows NT Bug : 285468
        // Need to adjust for the local machine case.  (if we are
        // a local machine, then we will get a NULL name).
        stTarget = m_sTarget;
        if (stTarget.IsEmpty())
        {
            stTarget.LoadString(IDS_DM_LOCAL_MACHINE);
        }
        
		//
		// We're sending to all RAS users in a domain or server
		//

		AfxFormatString1(
			sText, IDS_DM_TO_SERVER_FORMAT,
			stTarget
			);
	}

	SetDlgItemText(IDC_DM_EDIT_TO, sText);

	return FALSE;
}



//----------------------------------------------------------------------------
// Function:	CMessageDlg::OnOK
//
//----------------------------------------------------------------------------

VOID
CMessageDlg::OnOK(
	) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	CString sText;
	DWORD err = ERROR_SUCCESS;
	SPMprServerHandle	sphMprServer;
	USES_CONVERSION;

	GetDlgItemText(IDC_DM_EDIT_MESSAGE, sText);

	if (!sText.GetLength() &&
		AfxMessageBox(IDS_ERR_NO_TEXT, MB_YESNO|MB_ICONQUESTION) != IDYES)
	{
		return;
	}


	if (m_fUser)
	{
        CWaitCursor wait;
        
		// Need to get a connection to the server (to get the server handle)
		err = ::MprAdminServerConnect(T2W((LPTSTR)(LPCTSTR)m_sServerName),
									  &sphMprServer);
		
		if (err == ERROR_SUCCESS)
			err = SendToClient(m_sServerName, 
							m_sTarget, 
							sphMprServer, 
							m_hConnection, 
							sText);
		
		sphMprServer.Release();
	}
	else
	{
		err = SendToServer(m_sServerName, sText);
	}

	if (err == NERR_Success) 
	{ 
		CBaseDialog::OnOK(); 
	}
}


/*!--------------------------------------------------------------------------
	CMessageDlg::SendToServer
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD
CMessageDlg::SendToServer(
	LPCTSTR  pszServer,
	LPCTSTR  pszText,
	BOOL*	pbCancel
	) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	DWORD dwErr = ERROR_SUCCESS;
	CString sText;
	TCHAR szServer[MAX_COMPUTERNAME_LENGTH+3];
	DWORD i, dwTotal = 0, rc0Count = 0;
	RAS_CONNECTION_0 *rc0Table = NULL, *prc0;
	WCHAR wszServer[MAX_COMPUTERNAME_LENGTH+3];
	HRESULT hr = hrOK;
	SPMprServerHandle	sphMprServer;
	SPMprAdminBuffer	spMprBuffer;

	Assert(pszServer);
	Assert(pszText);

	COM_PROTECT_TRY
	{

		StrCpy(szServer, pszServer);
		StrCpyWFromT(wszServer, pszServer);
		
		//
		// See if the router is installed on the machine;
		//

		if (!::MprAdminIsServiceRunning(wszServer))
		{
			goto Error;
		}
		
		
		//
		// Connect to the server
		//
		
		{
			CWaitCursor wait;
			dwErr = ::MprAdminServerConnect(wszServer, &sphMprServer);
		}
		
		if (dwErr != NO_ERROR) {
			
			TCHAR	szText[2048];
			
			FormatSystemError(HRESULT_FROM_WIN32(dwErr),
							  szText, DimensionOf(szText), 0,
							  FSEFLAG_ANYMESSAGE);
			AfxFormatString2(sText, IDS_ERR_CONNECT_ERROR, szServer, szText);
			AfxMessageBox(sText, MB_OK|MB_ICONINFORMATION);

			goto Error;
		}
		
		
		//
		// Retrieve an array of the connections on the server
		//
		
		{
			CWaitCursor wait;
			rc0Table = NULL;
			dwErr = ::MprAdminConnectionEnum(
											 sphMprServer,
											 0,
											 (BYTE**)&spMprBuffer,
											 (DWORD)-1,
											 &rc0Count,
											 &dwTotal,
											 NULL
											);
			rc0Table = (RAS_CONNECTION_0 *) (BYTE *) spMprBuffer;
		}
		
		if (dwErr != NO_ERROR) {
			
			TCHAR	szText[2048];
			
			FormatSystemError(HRESULT_FROM_WIN32(dwErr),
							  szText, DimensionOf(szText), 0,
							  FSEFLAG_ANYMESSAGE);
			AfxFormatString2(sText, IDS_ERR_CONNENUM_ERROR, szServer, szText);
			AfxMessageBox(sText, MB_OK|MB_ICONINFORMATION);

			goto Error;
		}
			
			
		//
		// For each one which is a client with RAS_FLAGS_MESSENGER_PRESENT,
		// send the message
		//
		
		for (i = 0; i < rc0Count; i++)
		{			
			prc0 = rc0Table + i;
			
			if (prc0->dwInterfaceType != ROUTER_IF_TYPE_CLIENT ||
				!lstrlenW(prc0->wszRemoteComputer) ||
				!(prc0->dwConnectionFlags & RAS_FLAGS_MESSENGER_PRESENT)){
				continue;
			}
				
			dwErr = SendToClient(pszServer,
								 prc0->wszRemoteComputer,
								 sphMprServer,
								 prc0->hConnection,
								 pszText);
							
			if (!dwErr) { continue; }
			
				
			AfxFormatString1(sText, IDS_PROMPT_SERVER_CONTINUE, szServer);
			
			if (AfxMessageBox(sText, MB_YESNO|MB_ICONQUESTION) == IDNO)
			{	
				if (pbCancel) { *pbCancel = TRUE; } 			
				break;
			}
		}			
			
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	if ((dwErr == ERROR_SUCCESS) && !FHrSucceeded(hr))
	{
		// Assume that the failure was an out of memory
		dwErr = ERROR_OUTOFMEMORY;
	}

	sphMprServer.Release();

	return dwErr;
}


/*!--------------------------------------------------------------------------
	CMessageDlg::SendToClient
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CMessageDlg::SendToClient(LPCTSTR pszServerName,
								LPCTSTR pszTarget,
								MPR_SERVER_HANDLE hMprServer,
								HANDLE hConnection,
								LPCTSTR pszText)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	WCHAR		*pswzText = NULL;
	CString sText;
	DWORD	dwErr;
	HKEY	hkMachine = NULL;
	HRESULT hr = hrOK;
	RouterVersionInfo	verInfo;
	
	USES_CONVERSION;

	Assert(pszTarget);
	Assert(pszServerName);
	Assert(hMprServer);
	Assert(hConnection);

	COM_PROTECT_TRY
	{
		// Windows NT Bug : 158746
		// Note, if the target machine is NT5, then we can use the
		// new APIs
		// ------------------------------------------------------------

		// setup a default of NT5
		// ------------------------------------------------------------
		verInfo.dwRouterVersion = 5;

		dwErr = ConnectRegistry(pszServerName, &hkMachine);
		hr = HRESULT_FROM_WIN32(dwErr);
		if (FHrSucceeded(hr) && hkMachine)
		{
			QueryRouterVersionInfo(hkMachine, &verInfo);
			DisconnectRegistry(hkMachine);
		}

		// For NT4, call the old NetMessageBufferSend
		// ------------------------------------------------------------
		if (verInfo.dwRouterVersion == 4)
		{
			CWaitCursor wait;
			
			pswzText = StrDupWFromT(pszText);
			
			dwErr = ::NetMessageBufferSend(
										   NULL,
										   T2W((LPTSTR) pszTarget),
										   NULL,
										   (BYTE *) pswzText,
										   CbStrLenW(pswzText));
			
		}
		else	
		{
			// For NT5 and up, Use the MprAdminXXX api.  This will
			// work correctly for the Appletalk case
			// --------------------------------------------------------
			CWaitCursor wait;
			dwErr = ::MprAdminSendUserMessage(hMprServer,
											  hConnection,
											  T2W((LPTSTR) pszText));
		}

		
		if (dwErr != ERROR_SUCCESS)
		{
			TCHAR	szText[2048];
			
			FormatSystemError(HRESULT_FROM_WIN32(dwErr),
							  szText, DimensionOf(szText), 0,
							  FSEFLAG_ANYMESSAGE);
			AfxFormatString2(sText, IDS_ERR_SEND_FAILED, pszTarget, szText);
			AfxMessageBox(sText, MB_OK|MB_ICONINFORMATION);
		}
	}
	COM_PROTECT_CATCH;

	delete pswzText;
	
	if ((dwErr == ERROR_SUCCESS) && !FHrSucceeded(hr))
	{
		dwErr = ERROR_OUTOFMEMORY;
	}
		
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\mstatus.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipface.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _MSTATUS_H
#define _MSTATUS_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _BASERTR_H
#include "basertr.h"
#endif

class IPConnection;

#define IPCONTAINER_MAX_COLUMNS	32

struct _BaseIPResultData
{
	DWORD		m_dwData;
	CString		m_stData;
};

struct BaseIPResultNodeData
{
	BaseIPResultNodeData();
	~BaseIPResultNodeData();
#ifdef DEBUG
	TCHAR	m_szDebug[32];
#endif

	// Each column entry will have a structure that contains
	// (1) a string, (2) a DWORD, (3) a Boolean telling us to
	// sort by the string or the DWORD.  The string is ALWAYS what gets
	// displayed!
	_BaseIPResultData	m_rgData[IPCONTAINER_MAX_COLUMNS];

	SPIInterfaceInfo	m_spIf;

	// Indicates the existence of a global filter, used by IP
	BOOL				m_fFilters;

	DWORD				m_dwInterfaceIndex;

	// Used by Mark/Release algorithms
	DWORD				m_dwMark;

	IPConnection *		m_pIPConnection;

	static HRESULT	Init(ITFSNode *pNode, IInterfaceInfo *pIf,
						IPConnection *pIPConn);
	static HRESULT	Free(ITFSNode *pNode);
};

#define GET_BASEIPRESULT_NODEDATA(pNode) \
					((BaseIPResultNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_BASEIPRESULT_NODEDATA(pNode, pData) \
					pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)
#ifdef DEBUG
#define ASSERT_BASEIPRESULT_NODEDATA(pData) \
		Assert(lstrcmp(pData->m_szDebug, _T("BaseIPResultNodeData")) == 0);
#else
#define ASSERT_BASEIPRESULT_NODEDATA(x)
#endif


/*---------------------------------------------------------------------------
	Class:	BaseIPResultHandler

	This is a base class to be used by the interface result items.  It
	will contain some of the core code needed for basic things (like
	display of data).  It will not do the specifics (like menus/properties).

 ---------------------------------------------------------------------------*/
class BaseIPResultHandler :
   public BaseRouterHandler
{
public:
	BaseIPResultHandler(ITFSComponentData *pCompData, ULONG ulId)
			: BaseRouterHandler(pCompData), m_ulColumnId(ulId)
			{ DEBUG_INCREMENT_INSTANCE_COUNTER(BaseIPResultHandler); };
	~BaseIPResultHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(BaseIPResultHandler); }
	
	DeclareIUnknownMembers(IMPL)
	OVERRIDE_ResultHandler_GetString();
	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_DestroyResultHandler();

	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);
	
protected:
	CString			m_stTitle;	// holds the title of the node

	//
	// This is the id of the column set to use.  This is used when we
	// interact with the ComponentConfigStream.
	//
	ULONG			m_ulColumnId;


	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)	
};


void FillInNumberData(BaseIPResultNodeData *pNodeData, UINT iIndex,
					  DWORD dwData);

#endif _MSTATUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ndisutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ndisutil.h
//
//--------------------------------------------------------------------------

// NdisUtil header file.
// This is for everything that shouldn't be exported.


#ifndef _NDISUTIL_H_
#define _NDISUTIL_H_


HRESULT
HrSendNdisHandlePnpEvent (
        UINT        uiLayer,
        UINT        uiOperation,
        LPCWSTR     pszUpper,
        LPCWSTR     pszLower,
        LPCWSTR     pmszBindList,
        PVOID       pvData,
        DWORD       dwSizeData);

HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        LPCWSTR     wszUpper,
        LPCWSTR     wszLower,
        PVOID       pvData,
        DWORD       dwSizeData);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\machine.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   machine.h
      Machine node information.
      
    FILE HISTORY:
    	Wei Jiang : 5/7/98 --- SECURE_ROUTERINFO
    				new funciton SecureRouterInfo is added to MachineHandler
        
*/

#ifndef _MACHINE_H
#define _MACHINE_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _BASERTR_H
#include "basertr.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#define MACHINE_SYNCHRONIZE_ICON     100

//
// Possible states for the machine information (not necessarily for
// the data in the IRouterInfo).
//
typedef enum _MACHINE_STATES
{
	// These are the unloaded states
	machine_not_connected,			// haven't tried to connect
	machine_connecting,			// trying to connect
	machine_unable_to_connect,	// connect failed!  unknown reason
	machine_access_denied,		// connect failed!  access denied
    machine_bad_net_path,         // bad machine name (cannot find the name)

	// All states added after this should be considered loaded.
	machine_connected,			// connected!
    
	// end of valid machine states
	// this is a sentinel value, do not use this as a possible
	// machine state
	machine_enum_end
} MACHINE_STATES;



/*---------------------------------------------------------------------------
	Possible service states.

    The is orthogonal to our access level (you can read, but not change).
 ---------------------------------------------------------------------------*/
typedef enum _SERVICE_STATES
{
	service_unknown,
    service_access_denied,
    service_bad_net_path,
    service_not_a_server,
	service_started,
	service_stopped,
	service_rasadmin,

	// end of valid machine states
	// this is a sentinel value, do not use this as a possible
	// machine state
	service_enum_end
} SERVICE_STATES;


//
// These are the possible states for the IRouterInfo
//
typedef enum _DATA_STATES
{
	data_not_loaded,			// IRouterInfo not loaded
	data_unable_to_load,		// Unable to connect to the server
	data_loading,			// Still loading
	data_loaded				// IRouterInfo::Load() succeeded
} DATA_STATES;

// forward declartions
class RouterAdminConfigStream;
struct SMachineNodeMenu;
class DomainStatusHandler;

/*---------------------------------------------------------------------------
   Struct:  MachineNodeData
   This is machine node specific data.  A pointer to this structure is stored
   as the machine node user data.

   This is an AddRef'd data structure!
 ---------------------------------------------------------------------------*/

enum ServerRouterType
{
	ServerType_Unknown = 0,	// don't know what kind of machine this is.
    ServerType_Uninstalled, // NT4 - nothing installed
    ServerType_Workstation, // This is a workstation (no admin allowed)
	ServerType_Ras,			// NT4 (non-Steelhead) (RAS only)
	ServerType_Rras,		// NT4 Steelhead and NT5 and up.

    // This differs from the regular Uninstalled case, this means
    // that the bits are there, just that the config needs to get run.
    ServerType_RrasUninstalled, // NT5 and up, not installed
};


// forward delaration
struct	MachineNodeData;

// Structure used to pass data to callbacks - used as a way of
// avoiding recomputation
struct MachineConfig
{
public:
	MachineConfig() 
		: m_fReachable(FALSE), 
		m_fNt4(FALSE), 
		m_fConfigured(FALSE), 
		m_dwServiceStatus(0),
		m_fLocalMachine(FALSE)
		{};

	MachineConfig& operator= (const MachineConfig& m)
	{

		m_fReachable		= m.m_fReachable;		
		m_fNt4				= m.m_fNt4;	
		m_fConfigured 		= m.m_fConfigured;
		m_dwServiceStatus	= m.m_dwServiceStatus;
		m_fLocalMachine		= m.m_fLocalMachine;
		
		return *this;
	};
    
	BOOL			m_fReachable;		// can we connect?
	BOOL			m_fNt4;				// NT4 or not?
	BOOL			m_fConfigured;		// has install been run?
	DWORD			m_dwServiceStatus;	// GetRouterServiceStatus()
	BOOL			m_fLocalMachine;

    // Loads some basic machine config information
	HRESULT			GetMachineConfig(MachineNodeData *pData);

};



struct MachineNodeData
{
	MachineNodeData();
	~MachineNodeData();

	// AddRef/Release info
	ULONG	AddRef();
	ULONG	Release();
	LONG	m_cRef;


	HRESULT	Init(LPCTSTR pszMachineName);

	HRESULT	Merge(const MachineNodeData& data);
	
	// Load/unload/reload/etc....
	// Note: Calling Load() twice in a row will not reload
	// the data.  A refresh requires that an Unload() be called first.
	HRESULT	Load();
	HRESULT	Unload();
	HRESULT	SetDefault();
	
#ifdef DEBUG
	char		m_szDebug[32];
#endif

	// Static data (this data does not get reloaded)
	BOOL		m_fLocalMachine;
	BOOL		m_fAddedAsLocal;
	CString		m_stMachineName;	// name of the machine (duh)
	DWORD		m_dwServerHandle;
	LONG_PTR	m_ulRefreshConnId;
	MMC_COOKIE	m_cookie;

	// This data does get reloaded
	BOOL		m_fExtension;
	
	// Depending on the state of the service, this will return
	// the appropriate image index for the service.
	LPARAM			GetServiceImageIndex();

    SERVICE_STATES  m_serviceState;
	MACHINE_STATES	m_machineState;
	DATA_STATES		m_dataState;

    // The m_stState must be kept up-to-date with the machine state
    // variable
	CString		m_stState;			// "started", "stopped", ...

    
	CString		m_stServerType;		// Actually the router version
	CString		m_stBuildNo;			// OS Build no.
	DWORD		m_dwPortsInUse;
	DWORD		m_dwPortsTotal;
	DWORD		m_dwUpTime;
    BOOL        m_fStatsRetrieved;
    BOOL        m_fIsServer;        // Is this a server or a workstation?
    

    // This is the hProcess of RASADMIN (this is so we only have one running)
    HANDLE      m_hRasAdmin;
 
	ServerRouterType	m_routerType;
    RouterVersionInfo   m_routerVersion;
	
	MachineConfig	m_MachineConfig;

	HRESULT		FetchServerState(CString& stState);
protected:
	HRESULT		LoadServerVersion();
};

#define GET_MACHINENODEDATA(pNode) \
                  ((MachineNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_MACHINENODEDATA(pNode, pData) \
                  pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)

DeclareSmartPointer(SPMachineNodeData, MachineNodeData, if(m_p) m_p->Release());

/*---------------------------------------------------------------------------
   Class:   MachineHandler

   This is the handler for all "server" nodes.
 ---------------------------------------------------------------------------*/
class MachineHandler :
   public BaseRouterHandler
{
public:
	void ExpandNode(ITFSNode *  pNode,BOOL fExpand);

	MachineHandler(ITFSComponentData *pCompData);
	~MachineHandler()
	{ 
		m_spRouterInfo.Release();
		m_spDataObject.Release();   // cached data object
		DEBUG_DECREMENT_INSTANCE_COUNTER(MachineHandler);
	}
	
	HRESULT  Init(LPCTSTR pszMachineName,
				  RouterAdminConfigStream *pConfigStream,
				  ITFSNodeHandler* pSumNodeHandler = NULL,
				  ITFSNode* pSumNode = NULL );
	
	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	// Embedded interface to deal with refresh callbacks
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)
			
	//
	// base handler functionality we override
	//
	OVERRIDE_NodeHandler_GetString();
	
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	
	// result handler overrides -- result pane message
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_UserResultNotify();
	
	//
	// override to provide the specific RouterInfo Dataobject
	//
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	//
	// override to clean up our per-node data structures
	//
	OVERRIDE_NodeHandler_DestroyHandler();

    OVERRIDE_NodeHandler_UserNotify();
	
	//
	// Notification overrides (not part of an interface)
	//
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseHandlerNotify_OnExpandSync();
    OVERRIDE_BaseHandlerNotify_OnDelete();

	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szMachine, MachineNodeData *pData);
	
//
	OVERRIDE_BaseResultHandlerNotify_OnResultShow();
//


	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode      m_spNode;
        SPIRouterInfo   m_spRouterInfo;

        MachineConfig * m_pMachineConfig;
	};
	
	HRESULT OnNewRtrRASConfigWiz(ITFSNode *pNode, BOOL fTest);
	
    static ULONG MachineRtrConfWizFlags(const SRouterNodeMenu *pMenuData,
                                        INT_PTR pData /* SMenuData * */);
	static ULONG GetAutoRefreshFlags(const SRouterNodeMenu *pMenuData,
                                     INT_PTR pData /* SMenuData * */);
    static ULONG GetPauseFlags(const SRouterNodeMenu *pMenuData,
                               INT_PTR pData /* SMenuData * */);
    
	HRESULT	SetExternalRefreshObject(IRouterRefresh *pRefresh);

	// This is static so that the other nodes can use it.
	static ULONG GetServiceFlags(const SRouterNodeMenu *pMenuData,
                                 INT_PTR pData /* SMenuData * */);
	static ULONG QueryService(const SRouterNodeMenu *pMenuData,
                              INT_PTR pData /* SMenuData * */);
	
	HRESULT ChgService(ITFSNode *pNode, const CString& szServer, ULONG menuId);
    HRESULT SynchronizeIcon(ITFSNode *pNode);
	

	HRESULT SetExtensionStatus(ITFSNode * pNode, BOOL bExtension);

    // result message view helper
    void    UpdateResultMessage(ITFSNode * pNode);

protected:
	// to postpone the loading of RouterInfo from Init, till it's used
	// function SecureRouterInfo is introduced to make sure RouterInfo is Loaded
	HRESULT				SecureRouterInfo(ITFSNode *pNode, BOOL fShowUI);
	
	
	// Add remove node update support
	HRESULT				AddRemoveRoutingInterfacesNode(ITFSNode *, DWORD, DWORD);
	HRESULT				AddRemovePortsNode(ITFSNode *, DWORD, DWORD);
	HRESULT				AddRemoveDialinNode(ITFSNode *, DWORD, DWORD);

	// RasAdmin.Exe support for Windows NT 4 RAS administration
	HRESULT				StartRasAdminExe(MachineNodeData *pData);
	
	ITFSNodeHandler*    m_pSumNodeHandler;
	ITFSNode*           m_pSumNode;
	
	BOOL                m_bExpanded;
	BOOL				m_fCreateNewDataObj;
	BOOL				m_fNoConnectingUI;
	BOOL				m_bRouterInfoAddedToAutoRefresh;
    BOOL                m_bMergeRequired;

    // This is set to FALSE after the connect in the OnExpand()
    // fails.  This is a hack to fix the two connect attempts,
    // one in the OnExpand() and one in the OnResultShow().
    BOOL                m_fTryToConnect;

	CString             m_stNodeTitle;
	
	SPIDataObject       m_spDataObject;   // cached data object
	RouterAdminConfigStream *  m_pConfigStream;
	DWORD				m_EventId;
};



#endif _MACHINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ndisutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ndisutil.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ndisutil.h"
#include "rtrstr.h"

#include "raserror.h"

#include "ustringp.h"
#include <ndispnp.h>



//-------------------------------------------------------------------
// Function:    HrSendNdisHandlePnpEvent
//
// Purpose:     Send to Ndis a HandlePnpEvent notification
//
// Parameters:
//      uiLayer - either NDIS or TDI
//      uiOperation - either BIND, RECONFIGURE, or UNBIND
//      pszUpper - a WIDE string containing the upper component name
//      pszLower - a WIDE string containing the lower component name
//            This is one of the Export names from that component
//            The values NULL and c_szEmpty are both supported
//      pmszBindList - a WIDE string containing the NULL terminiated list of strings
//            representing the bindlist, vaid only for reconfigure
//            The values NULL and c_szEmpty are both supported
//      pvData - Pointer to ndis component notification data. Content
//            determined by each component.
//      dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:  Do not use this routine directly, see...
//                  HrSendNdisPnpBindOrderChange,
//                  HrSendNdisPnpBindStateChange, or
//                  HrSendNdisPnpReconfig
//
//-------------------------------------------------------------------
HRESULT
HrSendNdisHandlePnpEvent (
        UINT        uiLayer,
        UINT        uiOperation,
        LPCWSTR     pszUpper,
        LPCWSTR     pszLower,
        LPCWSTR     pmszBindList,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));
    Assert( (BIND == uiOperation) || (RECONFIGURE == uiOperation) || (UNBIND == uiOperation) );
//    AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
//            (RECONFIGURE == uiOperation) &&
//            (TDI == uiLayer) &&
//            (0 == lstrlenW( pszLower ))),
//            "bind order change requires a bind list, no lower, only for TDI, and with Reconfig for the operation" );

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
		hr = HRESULT_FROM_WIN32(GetLastError());
    }

//    TraceError( "HrSendNdisHandlePnpEvent", hr );
    return( hr );
}



//-------------------------------------------------------------------
// Function:    HrSendNdisPnpReconfig
//
// Purpose:     Send to Ndis a HandlePnpEvent reconfig notification
//
// Parameters:  uiLayer - either NDIS or TDI
//              wszUpper - a WIDE string containing the upper component name
//                         (typically a protocol)
//              wszLower - a WIDE string containing the lower component name
//                         (typically an adapter bindname) The values NULL and
//                         c_szEmpty are both supported
//              pvData - Pointer to ndis component notification data. Content
//                       determined by each component.
//              dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
//-------------------------------------------------------------------
HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        LPCWSTR     wszUpper,
        LPCWSTR     wszLower,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    Assert(NULL != wszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));

    if (NULL == wszLower)
    {
        wszLower = c_szEmpty;
    }

	CString	strLower;
//    tstring strLower;

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if ( wszLower && lstrlenW(wszLower))
    {
        strLower = c_szDevice;
        strLower += wszLower;
    }

    HRESULT hr = HrSendNdisHandlePnpEvent( uiLayer,
                RECONFIGURE,
                wszUpper,
                strLower,
                c_szEmpty,
                pvData,
                dwSizeData);
//    TraceError( "HrSendNdisPnpReconfig", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\machine.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   machine.pp

    FILE HISTORY:

        Wei Jiang : 5/7/98 --- SECURE_ROUTERINFO
                    Postpone the loading of router info
                    Added function calls SecureRouterInfo before each usage of
                    router info to make sure router info is loaded.
        Wei Jiang : 10/26/98 --- Move Auto Refresh from "Router Interfaces" node to machine node.
        Wei Jiang : 10/27/98 --- Move Auto Refresh from "Machine" node to Root node, multiple machine shares 
                    the same auto refresh settings.
        
        
*/

#include "stdafx.h"
#include "root.h"
#include "machine.h"
#include "ifadmin.h"
#include "dialin.h"
#include "ports.h"
#include "rtrutilp.h"   // InitiateServerConnection
#include "rtrcfg.h"
#include "rtrwiz.h"
#include "cservice.h"
#include <htmlhelp.h>
#include "rrasqry.h"
#include "rtrres.h"
#include "dumbprop.h"   // dummy property page
#include "refresh.h"
#include "refrate.h"
#include "cncting.h"
#include "dvsview.h"
#include "rrasutil.h"
#include "rtrcomn.h"
#include "routprot.h"   // MS_IP_XXX
#include "raputil.h"

// result message view stuff
#define MACHINE_MESSAGE_MAX_STRING  5

typedef enum _MACHINE_MESSAGES
{
    MACHINE_MESSAGE_NOT_CONFIGURED,
    MACHINE_MESSAGE_MAX
};

UINT g_uMachineMessages[MACHINE_MESSAGE_MAX][MACHINE_MESSAGE_MAX_STRING] =
{
    {IDS_MACHINE_MESSAGE_TITLE, Icon_Information, IDS_MACHINE_MESSAGE_BODY1, IDS_MACHINE_MESSAGE_BODY2, 0},
};

// if you want to test Qry
// #define  __RRAS_QRY_TEST   // to test the component
//
#ifdef   __RRAS_QRY_TEST                   
#include "dlgtestdlg.h"
#endif

static CString  c_stStatUnavail;
static CString  c_stStatNotConfig;
static CString  c_stStatAccessDenied;

static  CString c_stServiceStopped;
static  CString c_stServiceStartPending;
static  CString c_stServiceStopPending;
static  CString c_stServiceRunning;
static  CString c_stServiceContinuePending;
static  CString c_stServicePausePending;
static  CString c_stServicePaused;
static  CString c_stServiceStateUnknown;


const CStringMapEntry ServiceStateMap[] =
{
    { SERVICE_STOPPED, &c_stServiceStopped, IDS_SERVICE_STOPPED },
    { SERVICE_START_PENDING, &c_stServiceStartPending, IDS_SERVICE_START_PENDING },
    { SERVICE_STOP_PENDING, &c_stServiceStopPending, IDS_SERVICE_STOP_PENDING },
    { SERVICE_RUNNING, &c_stServiceRunning, IDS_SERVICE_RUNNING },
    { SERVICE_CONTINUE_PENDING, &c_stServiceContinuePending, IDS_SERVICE_CONTINUE_PENDING },
    { SERVICE_PAUSE_PENDING, &c_stServicePausePending, IDS_SERVICE_PAUSE_PENDING },
    { SERVICE_PAUSED, &c_stServicePaused, IDS_SERVICE_PAUSED },
    { -1, &c_stServiceStateUnknown, IDS_SERVICE_UNKNOWN }
};

CString& ServiceStateToCString(DWORD dwState)
{
    return MapDWORDToCString(dwState, ServiceStateMap);
}


DEBUG_DECLARE_INSTANCE_COUNTER(MachineNodeData);

MachineNodeData::MachineNodeData()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    m_cRef = 1;
   
    IfDebug(StrCpyA(m_szDebug, "MachineNodeData"));
    
    m_fLocalMachine = TRUE;
    m_fAddedAsLocal = TRUE;
    m_stMachineName.Empty();
    m_fExtension = FALSE;

    m_machineState = machine_not_connected;
    m_dataState = data_not_loaded;
    
    m_stState.Empty();
    m_stServerType.Empty();
    m_stBuildNo.Empty();

    m_dwPortsInUse = 0;
    m_dwPortsTotal = 0;
    m_dwUpTime = 0;
    
    m_fStatsRetrieved = FALSE;

    m_fIsServer = TRUE;

    m_dwServerHandle = 0;

    m_hRasAdmin = INVALID_HANDLE_VALUE;

    m_routerType = ServerType_Unknown;
    
    m_ulRefreshConnId = 0;

    if (c_stStatUnavail.IsEmpty())
        c_stStatUnavail.LoadString(IDS_DVS_STATUS_UNAVAILABLE);
    if (c_stStatNotConfig.IsEmpty())
        c_stStatNotConfig.LoadString(IDS_DVS_STATUS_NOTCONFIG);
    if (c_stStatAccessDenied.IsEmpty())
        c_stStatAccessDenied.LoadString(IDS_DVS_STATUS_ACCESSDENIED);
    
    DEBUG_INCREMENT_INSTANCE_COUNTER(MachineNodeData);
}

MachineNodeData::~MachineNodeData()
{
    if (m_hRasAdmin != INVALID_HANDLE_VALUE)
        ::CloseHandle(m_hRasAdmin);
    m_hRasAdmin = INVALID_HANDLE_VALUE;
    DEBUG_DECREMENT_INSTANCE_COUNTER(MachineNodeData);
}

ULONG MachineNodeData::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG MachineNodeData::Release()
{
    Assert(m_cRef > 0);
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT MachineNodeData::Init(LPCTSTR pszMachineName)
{
    HRESULT     hr = hrOK;

    m_stMachineName = pszMachineName;
    m_fAddedAsLocal = m_stMachineName.IsEmpty();
    m_fLocalMachine = IsLocalMachine(pszMachineName);

    return hr;
}

HRESULT MachineNodeData::Merge(const MachineNodeData& data)
{
    m_machineState  = data.m_machineState;
    m_serviceState  = data.m_serviceState;
    m_dataState     = data.m_dataState;

    m_stState       = data.m_stState;           // "started", "stopped", ...
    m_stServerType  = data.m_stServerType;      // Actually the router version
    m_stBuildNo     = data.m_stBuildNo;         // OS Build no.
    m_dwPortsInUse  = data.m_dwPortsInUse;
    m_dwPortsTotal  = data.m_dwPortsTotal;
    m_dwUpTime      = data.m_dwUpTime;
    m_fStatsRetrieved   = data.m_fStatsRetrieved;

    m_routerType    = data.m_routerType;

    m_MachineConfig = data.m_MachineConfig;
    m_routerVersion = data.m_routerVersion;

    return S_OK;
}

HRESULT MachineNodeData::SetDefault()
{
//  m_fLocalMachine = TRUE;
//  m_stMachineName.Empty();

//  m_fExtension = FALSE;
    m_machineState = machine_not_connected;
    m_dataState = data_not_loaded;
    m_serviceState = service_unknown;
    
    m_stState.Empty();
    m_stServerType.Empty();
    m_stBuildNo.Empty();

    m_dwPortsInUse = 0;
    m_dwPortsTotal = 0;
    m_dwUpTime = 0;
    
    m_fStatsRetrieved = FALSE;

    // This data is reserved for setting/clearing by the
    // MachineHandler().
    // m_dwServerHandle = 0;
    // m_ulRefreshConnId = 0;

    m_routerType = ServerType_Unknown;

    return hrOK;
}

/*!--------------------------------------------------------------------------
    MachineNodeData::Load
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineNodeData::Load()
{
    CString     szState;
    HRESULT     hr = hrOK;
    DWORD       dwErr;
    CWaitCursor wait;
//    HKEY        hkeyMachine;
//    RegKey      rkeyMachine;
    
    MIB_SERVER_HANDLE handle = INVALID_HANDLE_VALUE;
    MPR_SERVER_0* pserver0 = NULL;

    // set the defaults
    // ----------------------------------------------------------------
    SetDefault();

    // Ok, we're no longer in the machine_not_connected (haven't tried yet)
    // state.
    // ----------------------------------------------------------------
    m_machineState = machine_connecting;


    // First, try to connect with the registry calls
    // ----------------------------------------------------------------
    dwErr = ValidateUserPermissions((LPCTSTR) m_stMachineName,
                                    &m_routerVersion,
                                    NULL);


    // If this succeeded, then we have access to the right
    // areas.  We can continue on.  This does NOT tell us about
    // the service state.
    // ----------------------------------------------------------------
    if (dwErr == ERROR_ACCESS_DENIED)
    {
        // An access denied at this stage means that we can't
        // do any machine configuration, so this value should
        // not get changed by anything below.
        // ------------------------------------------------------------
        m_machineState = machine_access_denied;
    }
    else if (dwErr == ERROR_BAD_NETPATH)
    {
        m_machineState = machine_bad_net_path;

        // If we get a bad net path, we can stop right now, since
        // everything else will fail also.
        // ------------------------------------------------------------

        m_stState.LoadString(IDS_MACHINE_NAME_NOT_FOUND);
        m_serviceState = service_bad_net_path;
        m_dataState = data_unable_to_load;

        goto Error;
    }
    else if (dwErr != ERROR_SUCCESS)
    {
        // I don't know why we can't connect
        // ------------------------------------------------------------
        m_machineState = machine_unable_to_connect;
    }
        
    
    
    // Try to connect to the mpradmin service, to get statistics
    // and such.
    // ----------------------------------------------------------------

    if (m_machineState != machine_access_denied)
    {
        dwErr = ::MprAdminServerConnect((LPWSTR) (LPCTSTR) m_stMachineName, &handle);

        if (dwErr == ERROR_SUCCESS)
            dwErr = ::MprAdminServerGetInfo(handle, 0, (LPBYTE *) &pserver0);

        if (dwErr == ERROR_SUCCESS)
        {
            // successful mpradmin fetch
            m_dwPortsInUse = pserver0->dwPortsInUse;
            m_dwPortsTotal = pserver0->dwTotalPorts;
            m_dwUpTime = pserver0->dwUpTime;
            m_fStatsRetrieved = TRUE;
        }
    }

    hr = LoadServerVersion();
    if (!FHrOK(hr))
    {
        // We've failed to get the version information.
        // This is pretty bad.  Assume that we are unable to
        // connect.
        // ------------------------------------------------------------
        if (m_machineState == machine_connecting)
            m_machineState = machine_unable_to_connect;
    }

    // If this is not a server, we need to adjust the states
    // so that we don't show the state.
    // ----------------------------------------------------------------
    if (!m_fIsServer)
    {
        m_serviceState = service_not_a_server;
        m_machineState = machine_unable_to_connect;
        m_stState.LoadString(IDS_ERR_IS_A_WKS);
    }
    else
    {
        // This will set the service state (started, stopped, etc..)
        // ------------------------------------------------------------
        FetchServerState( szState );
    
        m_stState = szState;
    }

    
    // If we have reached this point, then all is well!
    // ----------------------------------------------------------------
    if (m_machineState == machine_connecting)
        m_machineState = machine_connected;
    

    // load machine config info as well
    hr = m_MachineConfig.GetMachineConfig(this);

Error:  
    if (pserver0) ::MprAdminBufferFree(pserver0);
    if (handle != INVALID_HANDLE_VALUE) ::MprAdminServerDisconnect(handle);


    return hr;
}

/*!--------------------------------------------------------------------------
    MachineNodeData::Unload
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineNodeData::Unload()
{
    // Unload the data (i.e. NULL it out).
    SetDefault();
    return 0;
}


/*!--------------------------------------------------------------------------
    MachineNodeData::LoadServerVersion
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineNodeData::LoadServerVersion()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    HKEY        hkMachine = 0;
    CString     skey, stVersion;
    CString     stServerType;
    CString     stBuildNo;
    CString     stProductType;
    CString     stProductName;
    TCHAR       szCurrentVersion[256];
    TCHAR       szCSDVersion[256];
    TCHAR       szBuffer[256];
    DWORD       dwErr;
    RegKey      regkeyWindows;
    RegKey      regkeyProduct;
    int         iProductType;

    // Windows NT Bug: 274198
    // If we couldn't find the path to the machine, just punt
    // ----------------------------------------------------------------
    if (m_machineState == machine_bad_net_path)
    {
        m_stState.LoadString(IDS_MACHINE_NAME_NOT_FOUND);
        return HResultFromWin32(ERROR_BAD_NETPATH);
    }

    // Everything we do here uses read-only permissions.  So
    // we may able to do things even if our machine state is
    // machine_access_denied.
    // ----------------------------------------------------------------

    COM_PROTECT_TRY
    {
        // This is the default (unknown)
        m_stServerType.LoadString(IDS_UNKNOWN);
        m_stBuildNo = m_stServerType;
        
        CWRg( ConnectRegistry(m_stMachineName, &hkMachine) );
        
        skey = c_szSoftware;
        skey += TEXT('\\');
        skey += c_szMicrosoft;
        skey += TEXT('\\');
        skey += c_szWindowsNT;
        skey += TEXT('\\');
        skey += c_szCurrentVersion;
        
        CWRg( regkeyWindows.Open(hkMachine, (LPCTSTR) skey, KEY_READ) );
        
        // Ok, now try to get the current version value
        CWRg( regkeyWindows.QueryValue( c_szCurrentVersion, szCurrentVersion,
                                        sizeof(szCurrentVersion),
                                        FALSE) );
        // Now get the SP version
        // ----------------------------------------------------------------
        szCSDVersion[0] = 0;
        
        // We don't care if we get an error here
        regkeyWindows.QueryValue( c_szCSDVersion, szCSDVersion,
                                  sizeof(szCSDVersion),
                                  FALSE);
        if (szCSDVersion[0] == 0)
        {
            // Set this to a space (to make the print easier)
            StrCpy(szCSDVersion, _T(" "));
        }
        
        
        
        // Determine the product type

        // setup the default product type (NTS)
        if (_ttoi(szCurrentVersion) >= 5)
        {
            // For NT5 and up, we can use the
            // HKLM \ Software \ Microsoft \ Windows NT \ CurrentVersion
            //      ProductName : REG_SZ
            // --------------------------------------------------------
            iProductType = IDS_ROUTER_TYPE_WIN2000_SERVER;

            dwErr = regkeyWindows.QueryValue( c_szRegValProductName, stProductName );
            if (dwErr != ERROR_SUCCESS)
                stProductName.LoadString(IDS_WIN2000);
        }
        else
            iProductType = IDS_ROUTER_TYPE_NTS;


        // Now that we've determine the version id, we
        // need to determine the product type (wks or svr)
        // ------------------------------------------------------------
        dwErr = regkeyProduct.Open(hkMachine, c_szRegKeyProductOptions, KEY_READ);
        if (dwErr == ERROR_SUCCESS)
        {
            // Ok, now get the product info
            // The product type is used to determine if server or not.
            regkeyProduct.QueryValue(c_szRegValProductType, stProductType);

            if (stProductType.CompareNoCase(c_szWinNT) == 0)
            {
                if (_ttoi(szCurrentVersion) >= 5)
                    iProductType = IDS_ROUTER_TYPE_WIN2000_PRO;
                else
                    iProductType = IDS_ROUTER_TYPE_NTW;
                m_fIsServer = FALSE;
            }
        }

        // If this is a Win2000 machine, show
        //      Win2000 (CSD)
        // else
        //      NT 4.X (CSD)
        // ------------------------------------------------------------
        if ((iProductType == IDS_ROUTER_TYPE_WIN2000_SERVER) ||
            (iProductType == IDS_ROUTER_TYPE_WIN2000_PRO))
            AfxFormatString2(stVersion, iProductType,
                             stProductName, szCSDVersion);
        else
            AfxFormatString2(stVersion, iProductType,
                             szCurrentVersion, szCSDVersion);

        // Now that we know that it is a workstation or server, adjust
        // for RRAS

        // If this is a workstation, then routertype is none.
        // If this is NT5 or up, then this is a RRAS machine.
        // If NT4, if the HKLM\Software\Microsoft\Router exists, this is RRAS
        // Else if HKLM\System\CurrentControlSet\Services\RemoteAccess, RAS
        // Else nothing is installed.

        if (m_fIsServer == FALSE)
        {
            m_routerType = ServerType_Workstation;
        }
        else if (_ttoi(szCurrentVersion) >= 5)
        {
            DWORD   dwConfigured;
            
            // Check the configuration flags key.
            if (FHrSucceeded(ReadRouterConfiguredReg(m_stMachineName, &dwConfigured)))
            {
                if (dwConfigured)
                    m_routerType = ServerType_Rras;
                else
                    m_routerType = ServerType_RrasUninstalled;
            }
            else
                m_routerType = ServerType_Unknown;
        }
        else
        {
            RegKey  regkeyT;
            
            // Now check for the Router key
            dwErr = regkeyT.Open(hkMachine, c_szRegKeyRouter, KEY_READ);
            if (dwErr == ERROR_SUCCESS)
                m_routerType = ServerType_Rras;
            else
            {
                dwErr = regkeyT.Open(hkMachine, c_szRemoteAccessKey, KEY_READ);
                if (dwErr == ERROR_SUCCESS)
                    m_routerType = ServerType_Ras;               
                else
                    m_routerType = ServerType_Uninstalled;
            }
            regkeyT.Close();

            // If the error code is anything other than ERROR_FILE_NOT_FOUND
            // then we set the router type to be unknown.
            if ((dwErr != ERROR_SUCCESS) &&
                (dwErr != ERROR_FILE_NOT_FOUND))
            {
                m_routerType = ServerType_Unknown;
            }
            dwErr = ERROR_SUCCESS;
        }

        // Setup the default string
        stServerType = stVersion;
        
        if (_ttoi(szCurrentVersion) == 4)
        {
            UINT    ids = 0;

            if (m_routerType == ServerType_Rras)
                ids = IDS_RRAS;
            else if (m_routerType == ServerType_Ras)
                ids = IDS_RAS;

            if (ids)
            {
                CString stRras;
                stRras.LoadString(ids);
                AfxFormatString2(stServerType, IDS_ROUTER_TYPE_NTsteelhead,
                                 stVersion, stRras);
            }
        }
        
        m_stServerType = stServerType;

        szBuffer[0] = 0;
        regkeyWindows.QueryValue( c_szCurrentBuildNumber, szBuffer,
                           sizeof(szBuffer), FALSE);
        m_stBuildNo = szBuffer;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
        
    if (hkMachine)
        DisconnectRegistry( hkMachine );

    return hr;
}



/*!--------------------------------------------------------------------------
    MachineNodeData::FetchServerState
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineNodeData::FetchServerState(CString& szState)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT         hr = hrOK;
    DWORD           dwStatus, dwErrorCode;

    // Windows NT Bug: 274198
    // If we couldn't find the path to the machine, just punt
    // ----------------------------------------------------------------
    if (m_machineState == machine_bad_net_path)
    {
        szState.LoadString(IDS_MACHINE_NAME_NOT_FOUND);
        return HResultFromWin32(ERROR_BAD_NETPATH);
    }

    // Note: We could be in machine_access_denied but still
    // be able to access the service status.
    // ----------------------------------------------------------------

    hr = GetRouterServiceStatus((LPCTSTR) m_stMachineName,
                                &dwStatus,
                                &dwErrorCode);
    
    if (FHrSucceeded(hr))
    {
        m_MachineConfig.m_dwServiceStatus = dwStatus;

        if (dwStatus == SERVICE_RUNNING)
            m_serviceState = service_started;
        else
            m_serviceState = service_stopped;

        szState = ServiceStateToCString(dwStatus);


        if (m_routerType == ServerType_RrasUninstalled)
        {
            CString stTemp;
            stTemp.Format(IDS_ROUTER_UNINSTALLED,
                          (LPCTSTR) szState);
            szState = stTemp;
        }
    }
    else
    {
        m_MachineConfig.m_dwServiceStatus = 0;
        if (hr == HResultFromWin32(ERROR_ACCESS_DENIED))
        {
            szState = c_stStatAccessDenied;
            m_serviceState = service_access_denied;
        }
        else
        {
            szState = c_stStatUnavail;
            m_serviceState = service_unknown;
        }
    }
                
    return hr;
}


typedef struct
{
    SERVICE_STATES  m_serviceState;
    LPARAM          m_imageIndex;
} ServiceStateImageMapEntry;

static ServiceStateImageMapEntry    s_rgImageMap[] =
    {
    { service_unknown,  IMAGE_IDX_MACHINE },
    { service_not_a_server, IMAGE_IDX_MACHINE_ERROR },
    { service_access_denied,        IMAGE_IDX_MACHINE_ACCESS_DENIED },
    { service_bad_net_path,       IMAGE_IDX_MACHINE_ERROR },
    { service_started,  IMAGE_IDX_MACHINE_STARTED },
    { service_stopped,  IMAGE_IDX_MACHINE_STOPPED },
    { service_rasadmin, IMAGE_IDX_MACHINE_STARTED },
    { service_enum_end, IMAGE_IDX_MACHINE },
    };

LPARAM  MachineNodeData::GetServiceImageIndex()
{
    ServiceStateImageMapEntry * pEntry;

    for (pEntry = s_rgImageMap; pEntry->m_serviceState != service_enum_end; pEntry++)
    {
        if (pEntry->m_serviceState == m_serviceState)
            break;
    }
    return pEntry->m_imageIndex;
}

/*---------------------------------------------------------------------------
   MachineHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(MachineHandler)

MachineHandler::MachineHandler(ITFSComponentData *pCompData)
   : BaseRouterHandler(pCompData),
   m_bExpanded(FALSE),
   m_pConfigStream(NULL),
   m_bRouterInfoAddedToAutoRefresh(FALSE),
   m_bMergeRequired(FALSE),
   m_fTryToConnect(TRUE)
{
   m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
   m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;

   m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
   m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

   m_pSumNodeHandler = NULL;
   m_pSumNode=NULL;

   m_fCreateNewDataObj = FALSE;
   m_fNoConnectingUI = FALSE;
	m_EventId = -1;
   DEBUG_INCREMENT_INSTANCE_COUNTER(MachineHandler);
};


/*!--------------------------------------------------------------------------
    MachineHandler::QueryInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP MachineHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
    else if (riid == IID_IRtrAdviseSink)
        *ppv = &m_IRtrAdviseSink;
    else
        return BaseRouterHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
    ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;   
}


/*!--------------------------------------------------------------------------
    MachineHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::Init(LPCTSTR pszMachine,
    RouterAdminConfigStream *pConfigStream,
    ITFSNodeHandler* pSumNodeHandler /*=NULL*/,
    ITFSNode* pSumNode /*=NULL*/)
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT  hr = hrOK;
	
   
   m_pConfigStream = pConfigStream;
   m_pSumNodeHandler = pSumNodeHandler;
   m_pSumNode = pSumNode;
      
   Assert(m_spRouterInfo == NULL);
   CORg( CreateRouterInfo(&m_spRouterInfo, m_spTFSCompData->GetHiddenWnd(), pszMachine) );
   Assert(m_spRouterInfo != NULL);

   // Windows NT Bug : 330939
   // Add the delete button to the machine node
   // -----------------------------------------------------------------
   m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
   m_bState[MMC_VERB_DELETE_INDEX] = TRUE;

	

   
Error:
   return hr;
}


/*!--------------------------------------------------------------------------
   MachineHandler::GetString
      Implementation of ITFSNodeHandler::GetString
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) MachineHandler::GetString(ITFSNode *pNode, int nCol)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
   int      nFormat;
   Assert(pData);
   
   if (m_stNodeTitle.IsEmpty())
   {
      if (pData->m_fExtension)
          nFormat = IDS_RRAS_SERVICE_DESC;
      
      else if (pData->m_fAddedAsLocal)
          nFormat = IDS_RRAS_LOCAL_TITLE;
      
      else
          nFormat = IDS_RRAS_TITLE;
      
      m_stNodeTitle.Format(nFormat, (LPCTSTR) pData->m_stMachineName);
   }
   return (LPCTSTR) m_stNodeTitle;
}

/*!--------------------------------------------------------------------------
   IfAdminNodeHandler::CreatePropertyPages
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
MachineHandler::CreatePropertyPages
(
   ITFSNode *           pNode,
   LPPROPERTYSHEETCALLBACK lpProvider,
   LPDATAOBJECT         pDataObject, 
   LONG_PTR              handle, 
   DWORD             dwType
)
{
    // Check to see if this router has been initialized
    // if not, do the dummy page thing
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    SMenuData   sData;
    SRouterNodeMenu sRouterData;
    RtrCfgSheet*   pPropSheet = NULL;
    SPIComponentData spComponentData;
    CString     stTitle;
    CDummyProperties * pProp;
    ULONG       ulFlags;
    int         idsErr;

    // Windows NT Bug : 177400
    // If the machine is not configured, do not allow the properties
    // page to be brought up
    // ----------------------------------------------------------------
    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
    
    ::ZeroMemory(&sRouterData, sizeof(sRouterData));
    sRouterData.m_sidMenu = IDS_MENU_RTRWIZ;
    
    sData.m_spNode.Set(pNode);
    sData.m_pMachineConfig = &(pData->m_MachineConfig);
    sData.m_spRouterInfo.Set(m_spRouterInfo);

    CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

    ulFlags = MachineRtrConfWizFlags(&sRouterData,
                                     reinterpret_cast<INT_PTR>(&sData));
    if ((ulFlags == MF_ENABLED) ||
        (ulFlags == 0xFFFFFFFF) ||
        (pData->m_machineState < machine_connected))
    {
        // We are unable to connect.
        if (pData->m_machineState == machine_bad_net_path)
            idsErr = IDS_ERR_MACHINE_NAME_NOT_FOUND;
                     
        if (pData->m_machineState < machine_connected)
            idsErr = IDS_ERR_NONADMIN_CANNOT_SEE_PROPERTIES;
        
        // If this is an NT4 machine, we don't show the properties
        else if (sData.m_pMachineConfig->m_fNt4)
            idsErr = IDS_ERR_CANNOT_SHOW_NT4_PROPERTIES;
        
        // This case means that the install menu should be shown
        // and the properties menu hidden
        else
            idsErr = IDS_ERR_MUST_INSTALL_BEFORE_PROPERTIES;

        AfxMessageBox(idsErr);

        pProp = new CDummyProperties(pNode, spComponentData, NULL);
        hr = pProp->CreateModelessSheet(lpProvider, handle);
    }

    else
    {
        pPropSheet = new RtrCfgSheet(pNode, m_spRouterInfo, spComponentData,
        m_spTFSCompData, stTitle);

        // added by WeiJiang 5/7/98, to postpone the Load of RouterInfo
        CORg(SecureRouterInfo(pNode, !m_fNoConnectingUI));

        pPropSheet->Init(m_spRouterInfo->GetMachineName()); 

        if (lpProvider)
            hr = pPropSheet->CreateModelessSheet(lpProvider, handle);
        else
            hr = pPropSheet->DoModelessSheet();
    }

Error:
   return hr;
}

/*!--------------------------------------------------------------------------
    MachineHandler::HasPropertyPages
        
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
MachineHandler::HasPropertyPages
(
   ITFSNode *        pNode,
   LPDATAOBJECT      pDataObject, 
   DATA_OBJECT_TYPES   type, 
   DWORD               dwType
)
{
    return hrOK;
}


// this is the set of menus for NT4 RRAS
static const SRouterNodeMenu s_rgIfNodeMenuNT4[] =
{
    // Add items that go on the top menu here
    { IDS_DMV_MENU_START, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_DMV_MENU_STOP, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },

    { IDS_MENU_PAUSE_SERVICE, MachineHandler::GetPauseFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_MENU_RESUME_SERVICE, MachineHandler::GetPauseFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TASK }

};

// this is the set of menus for NT5
static const SRouterNodeMenu s_rgIfNodeMenu[] =
{
#ifdef kennt
   // Add items that go on the top menu here
    { IDS_MENU_NEW_WIZARD_TEST, NULL,
    CCM_INSERTIONPOINTID_PRIMARY_TOP },
#endif
    
    { IDS_MENU_RTRWIZ, MachineHandler::MachineRtrConfWizFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TOP, _T("_CONFIGURE_RRAS_WIZARD_") },
    
    { IDS_DMV_MENU_REMOVESERVICE, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TOP, _T("_DISABLE_RRAS_") },
    
    { IDS_DMV_MENU_START, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_DMV_MENU_STOP, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_MENU_PAUSE_SERVICE, MachineHandler::GetPauseFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_MENU_RESUME_SERVICE, MachineHandler::GetPauseFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_MENU_RESTART_SERVICE, MachineHandler::QueryService,
    CCM_INSERTIONPOINTID_PRIMARY_TASK }

};

static const SRouterNodeMenu s_rgIfNodeMenu_ExtensionOnly[] =
{

    { IDS_MENU_SEPARATOR, 0,
    CCM_INSERTIONPOINTID_PRIMARY_TOP },
    
    { IDS_MENU_AUTO_REFRESH, MachineHandler::GetAutoRefreshFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TOP },
    
    { IDS_MENU_REFRESH_RATE, MachineHandler::GetAutoRefreshFlags,
    CCM_INSERTIONPOINTID_PRIMARY_TOP }, 
};


    
ULONG MachineHandler::MachineRtrConfWizFlags(const SRouterNodeMenu *pMenuData,
                                             INT_PTR pData)
{
    return GetServiceFlags(pMenuData, pData);
}


ULONG MachineHandler::GetServiceFlags(const SRouterNodeMenu *pMenuData,
                                      INT_PTR pUserData)
{
    Assert(pUserData);
    
    ULONG   uStatus = MF_GRAYED;
    SMenuData *pData = reinterpret_cast<SMenuData *>(pUserData);
    ULONG   ulMenuId = pMenuData->m_sidMenu;

    BOOL fStarted = (pData->m_pMachineConfig->m_dwServiceStatus != SERVICE_STOPPED);
    
    if ( ulMenuId == IDS_DMV_MENU_START )
    {
        // If this is an NT5 machine (or up), then the start menu
        // will appear grayed if the machine has not been configured.
        if ((pData->m_pMachineConfig->m_fNt4) || (pData->m_pMachineConfig->m_fConfigured))
            uStatus = ( fStarted ? MF_GRAYED : MF_ENABLED);
        else
        {
            // If this is an NT5 machine and if the machine is not configured
            uStatus = MF_GRAYED;
        }
    }
    else if (( ulMenuId == IDS_DMV_MENU_STOP ) ||
             ( ulMenuId == IDS_MENU_RESTART_SERVICE) )
    {
        if (pData->m_pMachineConfig->m_fConfigured)
	       uStatus = ( fStarted ? MF_ENABLED : MF_GRAYED);
        else
        	uStatus = MF_GRAYED;
    }
    else if ( (ulMenuId == IDS_MENU_RTRWIZ) ||
              (ulMenuId == IDS_DMV_MENU_REMOVESERVICE))
    {
        if ( pData->m_pMachineConfig->m_fReachable )
        {
            if ( pData->m_pMachineConfig->m_fNt4 )
            {
                // This is an NT4 machine, we can't bring
                // this menu option up.
                uStatus = 0xFFFFFFFF;
            }
            else
            {
                if (ulMenuId == IDS_MENU_RTRWIZ)
                    uStatus = (pData->m_pMachineConfig->m_fConfigured ? MF_GRAYED : MF_ENABLED);
                else
                    uStatus = (pData->m_pMachineConfig->m_fConfigured ? MF_ENABLED : MF_GRAYED);
            }
        }
    }

    return uStatus;
}


/*!--------------------------------------------------------------------------
    MachineHandler::GetPauseFlags
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
ULONG MachineHandler::GetPauseFlags(const SRouterNodeMenu *pMenuData,
                                    INT_PTR pUserData)
{
    ULONG   ulReturn = MF_GRAYED;
    SMenuData *pData = reinterpret_cast<SMenuData *>(pUserData);
    ULONG   ulMenuId = pMenuData->m_sidMenu;

    // We can only pause when the service is started and configured
    if ((pData->m_pMachineConfig->m_dwServiceStatus == SERVICE_RUNNING) &&
        (ulMenuId == IDS_MENU_PAUSE_SERVICE) && (pData->m_pMachineConfig->m_fConfigured))
        ulReturn = 0;

    // We can only resume when the service is paused and configured
    if ((pData->m_pMachineConfig->m_dwServiceStatus == SERVICE_PAUSED) &&
        (ulMenuId == IDS_MENU_RESUME_SERVICE) && (pData->m_pMachineConfig->m_fConfigured))
        ulReturn = 0;

    return ulReturn;
}

/*!--------------------------------------------------------------------------
    MachineHandler::GetAutoRefreshFlags
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
ULONG MachineHandler::GetAutoRefreshFlags(const SRouterNodeMenu *pMenuData,
                                          INT_PTR pUserData)
{
    
    ULONG   uStatus = MF_GRAYED;
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);
    Assert(pData);
    
    while( pData->m_pMachineConfig->m_fReachable )  // Pseudo loop
    {
        SPIRouterRefresh    spRefresh;

        if(!pData->m_spRouterInfo)
            break;
        pData->m_spRouterInfo->GetRefreshObject(&spRefresh);
        if (!spRefresh)
            break;

        uStatus = MF_ENABLED;
        if (pMenuData->m_sidMenu == IDS_MENU_AUTO_REFRESH && (spRefresh->IsRefreshStarted() == hrOK))
        {
            uStatus |= MF_CHECKED;
        }

        break;
    }

    return uStatus;
}

HRESULT MachineHandler::SetExternalRefreshObject(IRouterRefresh *pRefresh)
{
    Assert((IRouterInfo*)m_spRouterInfo);
    return m_spRouterInfo->SetExternalRefreshObject(pRefresh);
}

ULONG MachineHandler::QueryService(const SRouterNodeMenu *pMenuData, INT_PTR pData)
{
    return GetServiceFlags(pMenuData, pData);
}


STDMETHODIMP MachineHandler::OnAddMenuItems(
   ITFSNode *pNode,
   LPCONTEXTMENUCALLBACK pContextMenuCallback, 
   LPDATAOBJECT lpDataObject, 
   DATA_OBJECT_TYPES type, 
   DWORD dwType,
   long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
    BOOL bExtension = pData->m_fExtension;
    UINT            cMenu;
    const SRouterNodeMenu *pMenu;
    SMenuData   menuData;
    
    HRESULT hr = S_OK;
    
    COM_PROTECT_TRY
    {

        // Windows NT Bug : 281492
        // If we have not connected, attempt to connect
        if (pData->m_machineState == machine_not_connected)
        {
            pData->Unload();
            pData->Load();
        }
        
        // For down-level servers, we can't do anything with it.
        if ((pData->m_routerType == ServerType_Rras) ||
            (pData->m_routerType == ServerType_RrasUninstalled))
        {
            // Get some initial state data.
            MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
            menuData.m_pMachineConfig = &(pData->m_MachineConfig);
            
            // Now go through and add our menu items
            menuData.m_spNode.Set(pNode);
            menuData.m_spRouterInfo.Set(m_spRouterInfo);
            
            // NT4 and NT5 have different menus
            if (pData->m_MachineConfig.m_fNt4)
            {
                pMenu = s_rgIfNodeMenuNT4;
                cMenu = DimensionOf(s_rgIfNodeMenuNT4);
            }
            else
            {
                pMenu = s_rgIfNodeMenu;
                cMenu = DimensionOf(s_rgIfNodeMenu);
            }
            
            hr = AddArrayOfMenuItems(pNode,
                                     pMenu,
                                     cMenu,
                                     pContextMenuCallback,
                                     *pInsertionAllowed,
                                     (INT_PTR) &menuData);
            if(bExtension)
                hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu_ExtensionOnly,
                                         DimensionOf(s_rgIfNodeMenu_ExtensionOnly),
                                         pContextMenuCallback,
                                         *pInsertionAllowed,
                                         (INT_PTR) &menuData);
        }
    }
    COM_PROTECT_CATCH;
    
    return hr; 
}
struct STimerParam
{
	MachineHandler * pHandler;
	ITFSNode * pNode;
};

extern CTimerMgr	g_timerMgr;
void ExpandTimerProc(LPARAM lParam, DWORD dwTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	STimerParam * pParam = (STimerParam * )lParam;
	pParam->pHandler->ExpandNode(pParam->pNode, TRUE);
}


void MachineHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData    spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;
	RegKey				regkey;
	BOOL				bFound = FALSE;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) );
	//set the regkey 
	if (ERROR_SUCCESS == regkey.Open (	HKEY_LOCAL_MACHINE,
										c_szRemoteAccessKey,
										KEY_ALL_ACCESS,  
										m_spRouterInfo->GetMachineName()
									  ) 
	   )
	{
		DWORD dwSet = 0;
		CWRg(regkey.SetValue( c_szRegValOpenMPRSnap, dwSet));
		dwSet = 1;
		CWRg(regkey.SetValue( c_szRegValOpenIPSnap, dwSet));
	}




Error:
		if ( m_EventId != -1 )
		{
			g_timerMgr.FreeTimer(m_EventId);
			m_EventId = -1;
		}

    return;
}
/*!--------------------------------------------------------------------------
   MachineHandler::OnCommand
      Implementation of ITFSNodeHandler::OnCommand
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP MachineHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
                                 DATA_OBJECT_TYPES type, 
                                 LPDATAOBJECT pDataObject, 
                                 DWORD dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    ClearTFSErrorInfo(0);
    
    COM_PROTECT_TRY
    {
        switch (nCommandId)
        {
            case IDS_MENU_NEW_WIZARD_TEST:
                {
                    hr = OnNewRtrRASConfigWiz(pNode, TRUE);
                }
                break;
            case IDS_MENU_RTRWIZ:
                hr = OnNewRtrRASConfigWiz(pNode, FALSE);
                //hr = OnRtrRASConfigWiz(pNode);

                // when summary node is not yet created, then refresh icon
                // from machine node is needed
                if (!m_pSumNodeHandler &&
                    (*pNode->GetNodeType()) == GUID_RouterMachineNodeType)
                {
                    MachineNodeData*    pData = GET_MACHINENODEDATA(pNode);
                    Assert(pData);

                    // Ignore the return value, if the load fails
                    // we still need to update the icon
                    // ------------------------------------------------
                    pData->Load();
                    hr = SynchronizeIcon(pNode);
					//HACK Alert!  This is the most
					//hacky stuff I have seen around
					//but cannot help it at all...
					{
						STimerParam * pParam = new STimerParam;
						pParam ->pHandler = this;
						pParam->pNode = pNode;
						RegKey regkey;
						//set the regkey 
						if (ERROR_SUCCESS == regkey.Open (	HKEY_LOCAL_MACHINE,
															c_szRemoteAccessKey,
															KEY_ALL_ACCESS,  
															m_spRouterInfo->GetMachineName()
														  ) 
						   )
						{
							DWORD dwSet = 1;
							regkey.SetValue( c_szRegValOpenMPRSnap, dwSet);
						}

						//Give MMC enough time to settle down...
						m_EventId = g_timerMgr.AllocateTimer ( ExpandTimerProc,
												(LPARAM)pParam,
												10000
											 );

					}
                }

                break;
                
            case IDS_DMV_MENU_START:
            case IDS_DMV_MENU_STOP:
            case IDS_DMV_MENU_REMOVESERVICE:               
            case IDS_MENU_PAUSE_SERVICE:
            case IDS_MENU_RESUME_SERVICE:
            case IDS_MENU_RESTART_SERVICE:
                {
                    // Windows NT Bug : 285537
                    // First, ask the user if they really wish
                    // to disable the router.
                    if ((nCommandId != IDS_DMV_MENU_REMOVESERVICE) ||
                        (IDYES == AfxMessageBox(IDS_WRN_DISABLE_ROUTER, MB_YESNO)))
                    {
                        MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
                        hr = ChgService(pNode,
                                        pData->m_stMachineName,
                                        nCommandId);
                    }
                    SynchronizeIcon(pNode);
                }

            case IDS_DMV_MENU_REFRESH:
                {

                    SPITFSNode        spRoutingNode;
                    SPITFSNodeEnum    spMachineEnum;
                    SPITFSNode        spMachineNode;

                    // when summary node is not yet created, then refresh icon from machine node is needed
                    if (!m_pSumNodeHandler && (*pNode->GetNodeType()) == GUID_RouterMachineNodeType)
                    {
                        MachineNodeData*    pData = GET_MACHINENODEDATA(pNode);
                        Assert(pData);
                        
                        // Ignore the return value, if the load fails
                        // we still need to update the icon
                        // --------------------------------------------
                        pData->Load();
                        hr = SynchronizeIcon(pNode);
                    }
                }
                break;

            case IDS_MENU_REFRESH_RATE:
                {
                    CRefRateDlg refrate;
                    SPIRouterRefresh    spRefresh;

                    m_spRouterInfo->GetRefreshObject(&spRefresh);

                    if (spRefresh)
                    {
                        DWORD   rate;
                        spRefresh->GetRefreshInterval(&rate);
                        refrate.m_cRefRate = rate;
                        if (refrate.DoModal() == IDOK)
                        {
                            spRefresh->SetRefreshInterval(refrate.m_cRefRate);
                        }
                    }
                                            
                }
                break;
            case IDS_MENU_AUTO_REFRESH:
                {
                    SPIRouterRefresh    spRefresh;
                    m_spRouterInfo->GetRefreshObject(&spRefresh);

                    if(!spRefresh)
                        break;
                    if (spRefresh->IsRefreshStarted() == hrOK)
                        spRefresh->Stop();
                    else
                    {
                        DWORD   rate;
                        spRefresh->GetRefreshInterval(&rate);
                        spRefresh->Start(rate);
                    }
                }
                break;
        
            default:
                break;
        }
    }
    COM_PROTECT_CATCH;

    if (!FHrSucceeded(hr))
    {
        DisplayTFSErrorMessage(NULL);
    }
    
    ForceGlobalRefresh(m_spRouterInfo);
    
    return hrOK;
}

/*!--------------------------------------------------------------------------
    MachineHandler::SynchronizeIcon
        -
    Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::SynchronizeIcon(ITFSNode *pNode)
{
    HRESULT         hr = hrOK;
    MachineNodeData *pMachineData;
    LPARAM          imageIndex;

    pMachineData = GET_MACHINENODEDATA(pNode);
    Assert(pMachineData);

	CString	str;
	pMachineData->FetchServerState(str);
    imageIndex = pMachineData->GetServiceImageIndex();
    pNode->SetData(TFS_DATA_IMAGEINDEX, imageIndex);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, imageIndex);
    
    pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON);

    if (m_bExpanded)
        UpdateResultMessage(pNode);

    return hr;
}

/*!--------------------------------------------------------------------------
    MachineHandler::ChgService
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::ChgService(ITFSNode *pNode, const CString& szServer, ULONG menuId)
{
    CServiceManager sm;
    DWORD dw;
    ULONG ret;
    HRESULT hr=S_OK;
    CWaitCursor wait;
    DWORD   dwStartType = 0;

    if (menuId == IDS_DMV_MENU_START)
    {
        // Windows NT Bug : 310919
        // Check service state before starting service.
        // ------------------------------------------------------------
        hr = GetRouterServiceStartType(szServer, &dwStartType);        
        if (FHrSucceeded(hr))
        {
            if (dwStartType == SERVICE_DISABLED)
            {
                if (AfxMessageBox(IDS_PROMPT_START_DISABLED_SERVICE, MB_YESNO) == IDNO)
                    goto Error;
                SetRouterServiceStartType(szServer, SERVICE_AUTO_START);
            }
        }
        
        
        hr = StartRouterService(szServer);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_START_ROUTER);
            CORg(hr);
        }
    }
    
    else if (menuId == IDS_DMV_MENU_STOP)
    {
        hr = StopRouterService(szServer);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_STOP_ROUTER);
            CORg(hr);
        }
    }
    
    else if (menuId == IDS_DMV_MENU_REMOVESERVICE)
    {
        MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
        GUID              guidConfig = GUID_RouterNull;
        SPIRouterProtocolConfig	spRouterConfig;
        SPIRtrMgrProtocolInfo   spRmProt;
        RtrMgrProtocolCB    RmProtCB;
        
        // Stop the router service
        hr = StopRouterService((LPCTSTR) szServer);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_REMOVE_ROUTER);
            CORg(hr);
        }
        
        // remove router id object from DS if the it's an NT5 server
        Assert(m_spRouterInfo);
        
        if(FHrSucceeded( hr = SecureRouterInfo(pNode, !m_fNoConnectingUI)))
        {
            RouterVersionInfo   RVI;
            USES_CONVERSION;
            if(S_OK == m_spRouterInfo->GetRouterVersionInfo(&RVI) && RVI.dwRouterVersion >= 5)
            {
                hr = RRASDelRouterIdObj(T2W((LPTSTR)(LPCTSTR)szServer));
                Assert(hr == S_OK);
            }
        }

        // Windows NT Bug : 389469
        // This is hardcoded for NAT (I do not want to change too much).
        // Find the config GUID for NAT, and then remove the protocol.
        hr = LookupRtrMgrProtocol(m_spRouterInfo,
                                  PID_IP,
                                  MS_IP_NAT,
                                  &spRmProt);
        
        // If the lookup returns S_FALSE, then it couldn't find the
        // protocol.
        if (FHrOK(hr))
        {
            spRmProt->CopyCB(&RmProtCB);
            
            CORg( CoCreateProtocolConfig(RmProtCB.guidConfig,
                                         m_spRouterInfo,
                                         PID_IP,
                                         MS_IP_NAT,
                                         &spRouterConfig) );
            
            if (spRouterConfig)                
                hr = spRouterConfig->RemoveProtocol(m_spRouterInfo->GetMachineName(),
                    PID_IP,
                    MS_IP_NAT,
                    NULL,
                    0,
                    m_spRouterInfo,
                    0);
        }
        
    
        // Perform any removal/cleanup action
        UninstallGlobalSettings(szServer,
                                m_spRouterInfo,
                                pData->m_MachineConfig.m_fNt4,
                                TRUE);

        // Remove the router from the domain
        if (m_spRouterInfo->GetRouterType() != ROUTER_TYPE_LAN)
            RegisterRouterInDomain(szServer, FALSE);
        
        // Disable the service
        SetRouterServiceStartType((LPCTSTR) szServer,
                                  SERVICE_DISABLED);

        //
        // Bug 519414
        //  Since IAS now has a Microsoft policy with the appropriate settings,
        //  there is no longer a single default policy.  In addition there is
        //  no need to update any policy to have the required settings since the
        //  Microsoft VPN server policy does the job.
        //
    
#if __DEFAULT_POLICY

        //Now update the default policy
        CORg( UpdateDefaultPolicy((LPTSTR)(LPCTSTR)szServer,
                            FALSE,
                            FALSE,
                            0
                            ) );

#endif

    }

    else if (menuId == IDS_MENU_PAUSE_SERVICE)
    {
        hr = PauseRouterService(szServer);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_PAUSE_ROUTER);
            CORg(hr);
        }
    }

    else if (menuId == IDS_MENU_RESUME_SERVICE)
    {
        hr = ResumeRouterService(szServer);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_RESUME_ROUTER);
            CORg(hr);
        }
    }

    else if (menuId == IDS_MENU_RESTART_SERVICE)
    {
        // Do a stop and then a start
        //CORg( ChgService(pNode, szServer, IDS_DMV_MENU_STOP) );
        //CORg( ChgService(pNode, szServer, IDS_DMV_MENU_START) );
        COSERVERINFO            csi;
        COAUTHINFO              cai;
        COAUTHIDENTITY          caid;
        SPIRemoteRouterRestart  spRestart;
        IUnknown *              punk = NULL;
        
        ZeroMemory(&csi, sizeof(csi));
        ZeroMemory(&cai, sizeof(cai));
        ZeroMemory(&caid, sizeof(caid));
        
        csi.pAuthInfo = &cai;
        cai.pAuthIdentityData = &caid;
        
        CORg( CoCreateRouterConfig(szServer,
                                   m_spRouterInfo,
                                   &csi,
                                   IID_IRemoteRouterRestart,
                                   &punk) );
        spRestart = (IRemoteRouterRestart *) punk;

        spRestart->RestartRouter(0);

        //Get the current time before we begin restart the router
        CTime timeStart = CTime::GetCurrentTime();
        
        spRestart.Release();

        
        // Put up the dialog with the funky spinning thing to 
        // let the user know that something is happening
        CString stTitle;
        CString stDescrption;
        stTitle.LoadString(IDS_PROMPT_SERVICE_RESTART_TITLE);
        stDescrption.Format(IDS_PROMPT_SERVICE_RESTART_DESC, szServer);

        CRestartRouterDlg dlgRestartRouter(szServer, (LPCTSTR)stDescrption, 
                                           (LPCTSTR)stTitle, &timeStart);
        dlgRestartRouter.DoModal();

        if (NO_ERROR != dlgRestartRouter.m_dwError)
        {
            AddHighLevelErrorStringId(IDS_ERR_RESTART_SERVICE);
            hr = HRESULT_FROM_WIN32(dlgRestartRouter.m_dwError);
        }
        else if (dlgRestartRouter.m_fTimeOut)
        {
            CString stErrMsg;
            stErrMsg.Format(IDS_ERR_RESTART_TIMEOUT, szServer);
            ::AfxMessageBox((LPCTSTR)stErrMsg);
        }

        if (csi.pAuthInfo)
            delete csi.pAuthInfo->pAuthIdentityData->Password;
    
    }
            
Error:
    if (!FHrSucceeded(hr)) 
    {
        AddSystemErrorMessage(hr);
        TRACE0("MachineHandler::ChgService, unable to start/stop service");
    }

    return hr;    
}


/*!--------------------------------------------------------------------------
    MachineHandler::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP MachineHandler::OnCreateDataObject(MMC_COOKIE cookie,
                                                DATA_OBJECT_TYPES type,
                                                IDataObject **ppDataObject)
{
   Assert(ppDataObject);
   
   HRESULT  hr = hrOK;
   MachineNodeData * pData;
   SPITFSNode   spNode;
      
   m_spNodeMgr->FindNode(cookie, &spNode);
 
   pData = GET_MACHINENODEDATA(spNode);
   
   COM_PROTECT_TRY
   {
      if (m_spDataObject)
      {
         // If our cached data object does not have the correct
         // type, release it and create a new one.
         // or if it doesn't have a RouterInfo object and one is now 
         // available, recreate
         SPINTERNAL      spInternal = ExtractInternalFormat(m_spDataObject);
         SPIRouterInfo spRouterInfo;

         if ( (spInternal != NULL && (spInternal->m_type != type)) ||
              (FAILED(spRouterInfo.HrQuery(m_spDataObject)) && m_spRouterInfo) )
            m_spDataObject.Set(NULL);
      }
      
      if (!m_spDataObject)
      {
          //if (FAILED(SecureRouterInfo(spNode)))
          //{
          //      Trace0("SecureRouterInfo failed! Creating data object without RouterInfo\n");
          //}
          
          if (m_spRouterInfo)
          {
              CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
                  pData->m_stMachineName,
                  type, cookie, m_spTFSCompData,
                  &m_spDataObject, &m_dynExtensions,
                  pData->m_fAddedAsLocal
                  ) );
          }
          else
          {

              CORg( CreateRouterDataObject(pData->m_stMachineName,
                                           type, cookie, m_spTFSCompData,
                                           &m_spDataObject, &m_dynExtensions,
                                           pData->m_fAddedAsLocal) );
          }

          Assert(m_spDataObject);
      }
      
      *ppDataObject = m_spDataObject;
      (*ppDataObject)->AddRef();
      
      COM_PROTECT_ERROR_LABEL;
   }
   COM_PROTECT_CATCH;
   return hr;
}

/*!--------------------------------------------------------------------------
   MachineHandler::ConstructNode
      Initializes the node for a machine.
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::ConstructNode(ITFSNode *pNode, LPCTSTR szMachine, MachineNodeData *pMachineData)
{
    DWORD dwErr;
    const GUID *   pguid;
    HRESULT  hr = hrOK;
    int      i;
    
    Assert(pMachineData);
    
    pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_MACHINE);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_MACHINE);
    
    pNode->SetNodeType(&GUID_RouterMachineErrorNodeType);
    
    // Save the machine type for this particular data type
    pNode->SetData(TFS_DATA_TYPE, ROUTER_NODE_MACHINE);
    
    // Assume that there's nothing in the node at this point
    Assert(pNode->GetData(TFS_DATA_USER) == 0);
    
    // If szMachine == NULL, then this is the local machine and
    // we have to get the name of the local machine
    // added the first condition m_fLocalMachine, to fix bug 223062
    pMachineData->m_fAddedAsLocal = FALSE;
    if (pMachineData->m_fLocalMachine || szMachine == NULL || *szMachine == 0)
    {
        pMachineData->m_stMachineName = GetLocalMachineName(); 
        pMachineData->m_fLocalMachine = TRUE;
        if(szMachine == NULL || *szMachine == 0)
        {
            pMachineData->m_fAddedAsLocal = TRUE;

            // set flag in routeInfo, so other component will get this piece
            Assert(m_spRouterInfo);	// should have been initialized at this point

			// append add as local flag
            m_spRouterInfo->SetFlags(m_spRouterInfo->GetFlags() | RouterInfo_AddedAsLocal);
            
        }
    }
    else
    {
        // Strip out the "\\" if there are any
        if ((szMachine[0] == _T('\\')) && (szMachine[1] == _T('\\')))
            pMachineData->m_stMachineName = szMachine + 2;
        else
            pMachineData->m_stMachineName = szMachine;
        pMachineData->m_fLocalMachine = FALSE;
    }
    
    pMachineData->m_cookie = (MMC_COOKIE) pNode->GetData(TFS_DATA_COOKIE);
    
    // Save the machine data back to the node
    pMachineData->AddRef();
    SET_MACHINENODEDATA(pNode, pMachineData);
    
    /*-----------------------------------------------------------------------
     * ALL data for the node that holds true, even if we can't get to
     * the machine, must be set before the call to QueryRouterType()!
     ------------------------------------------------------------------------*/
    
    pNode->SetNodeType(&GUID_RouterMachineNodeType);
    
    SynchronizeIcon(pNode);
    
    EnumDynamicExtensions(pNode);

    return hr;
}


/*!--------------------------------------------------------------------------
    MachineHandler::DestroyHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP MachineHandler::DestroyHandler(ITFSNode *pNode)
{
    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);

    // Release the refresh advise sinks
    // ----------------------------------------------------------------
    if ( m_spRouterInfo )
    {
        SPIRouterRefresh    spRefresh;
        SPIRouterRefreshModify  spModify;
               
        m_spRouterInfo->GetRefreshObject(&spRefresh);

        if(spRefresh && m_bRouterInfoAddedToAutoRefresh)
        {
            spModify.HrQuery(spRefresh);
            if (spModify)
                spModify->RemoveRouterObject(IID_IRouterInfo, m_spRouterInfo);
        }

        if (spRefresh && pData->m_ulRefreshConnId )
            spRefresh->UnadviseRefresh(pData->m_ulRefreshConnId);
    }


    pData->Release();
    SET_MACHINENODEDATA(pNode, NULL);
   
    m_spDataObject.Release();
    m_spRouterInfo.Release();
    return hrOK;
}


/*!--------------------------------------------------------------------------
   MachineHandler::SetExtensionStatus
      Sets whether this node is operating as an extension (network console).
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::SetExtensionStatus(ITFSNode * pNode, BOOL bExtension)
{
    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
    pData->m_fExtension = bExtension;

    return hrOK;
}


/*!--------------------------------------------------------------------------
   MachineHandler::SecureRouterInfo
       to postpone the loading of RouterInfo from Init, till it's used
       function SecureRouterInfo is introduced to make sure RouterInfo is Loaded
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::SecureRouterInfo(ITFSNode *pNode, BOOL fShowUI)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
    HRESULT hr = S_OK;

    Assert(m_spRouterInfo);

    // If the name is invalid, skip this attempt.
    // ----------------------------------------------------------------
//    if (pData->m_machineState == machine_bad_net_path)
//    {
//      pData->m_dataState = data_unable_to_load;        
//        return hr;
//    }

    // If this is an NT4 RAS server, we don't need to do this
    // ----------------------------------------------------------------
    if (pData->m_routerType == ServerType_Ras)
    {
        pData->m_dataState = data_unable_to_load;        
        SynchronizeIcon(pNode);
        return hr;
    }

    // If this is a workstation, we don't need to connect
    // ----------------------------------------------------------------
    if (pData->m_fIsServer == FALSE)
    {
        pData->m_dataState = data_unable_to_load;        
        SynchronizeIcon(pNode);
        return hr;
    }


    // This function should try to connect
    // (or reconnect).
    if ((pData->m_dataState == data_not_loaded) ||
        (pData->m_dataState == data_unable_to_load) ||
        (pData->m_machineState == machine_access_denied))
    {
        pData->m_dataState = data_loading;

        CORg(InitiateServerConnection(pData->m_stMachineName,
                                      NULL,
                                      !fShowUI,
                                      m_spRouterInfo));

        if (!FHrOK(hr))
        {
            // though this case when user chooses cancel on user/password dlg,
            // this is considered as FAIL to connect
            if (hr == S_FALSE)
                hr = HResultFromWin32(ERROR_CANCELLED);
            goto Error;
        }
    
        {
            CWaitCursor wc;

            if (m_bMergeRequired)
            {
                SPIRouterInfo   spNewRouter;
            
                CORg( CreateRouterInfo(&spNewRouter, NULL , (LPCTSTR) pData->m_stMachineName));

				TransferCredentials ( m_spRouterInfo, 
									 spNewRouter
								   );
                CORg( spNewRouter->Load(T2COLE((LPTSTR) (LPCTSTR) pData->m_stMachineName),
                                       NULL) );
                m_spRouterInfo->Merge(spNewRouter);
            }
            else
            {
                CORg( m_spRouterInfo->Load(T2COLE((LPTSTR) (LPCTSTR) pData->m_stMachineName),
                                          NULL) );
                m_bMergeRequired = TRUE;
            }

            pData->Load();
        }

        pData->m_dataState = data_loaded;
    }

Error:
    if (FAILED(hr))
    {
        pData->m_dataState = data_unable_to_load;

        if (hr == HResultFromWin32(ERROR_BAD_NETPATH))
        {
            pData->m_machineState = machine_bad_net_path;
            pData->m_stState.LoadString(IDS_MACHINE_NAME_NOT_FOUND);
            pData->m_serviceState = service_bad_net_path;
        }
        else if (hr == HResultFromWin32(ERROR_CANCELLED))
        {
            pData->m_machineState = machine_access_denied;
            pData->m_stState = c_stStatAccessDenied;
            pData->m_serviceState = service_access_denied;
        }
    }

    // No matter what, try to synchronize the icon
    // ----------------------------------------------------------------
    SynchronizeIcon(pNode);

    return hr;
};

/*!--------------------------------------------------------------------------
   MachineHandler::OnExpandSync
      If this gets called, then MMC is initalizing and we don't want to 
      put up UI which can cause messages to start flying around....
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnExpandSync(ITFSNode *pNode,
                                     LPDATAOBJECT pDataObject,
                                     LPARAM arg,
                                     LPARAM lParam)
{
    m_fNoConnectingUI = TRUE;

    return hrOK;
}


/*!--------------------------------------------------------------------------
   MachineHandler::OnExpand
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnExpand(ITFSNode *pNode,
                                 LPDATAOBJECT pDataObject,
                                 DWORD dwType,
                                 LPARAM arg,
                                 LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT              hr = hrOK;
    SPITFSNode           spNode;
    SPITFSNodeHandler    spHandler;
    IfAdminNodeHandler * pHandler = NULL;
    DialInNodeHandler  * pDialInHandler = NULL;
    PortsNodeHandler   * pPortsHandler = NULL;
    RouterVersionInfo    versionInfo;
    DWORD                dwRouterFlags = 0;
    DWORD                dwRouterType = 0;
    MachineNodeData    * pData = NULL;

    if (m_bExpanded)
        return hr;

    CComPtr<IConsole2>	spConsole;

	m_spTFSCompData->GetConsole(&spConsole);
	if(spConsole != NULL)
	{
    	HWND				hMainWnd = NULL;

    	spConsole->GetMainWindow(&hMainWnd);

    	if (hMainWnd)
    		SetForegroundWindow(hMainWnd);
    

	}
	
	
	
	// If this is an error node, don't show the child nodes
    // ----------------------------------------------------------------
    if (*(pNode->GetNodeType()) == GUID_RouterMachineErrorNodeType)
        return hrOK;
    
    Assert(m_spRouterInfo);

    // We need the machine node data, that is where the connection id
    // is stored.
    // ----------------------------------------------------------------
    pData = GET_MACHINENODEDATA(pNode);

    // Load the data if we need to:
    // ----------------------------------------------------------------
    if (pData->m_machineState == machine_not_connected)
        pData->Load();
    SynchronizeIcon(pNode);

    // Windows Nt Bug : 302430
    // If this is an NT4 machine, we don't need to do the rest
    // ----------------------------------------------------------------
    if (pData->m_routerType == ServerType_Ras)
        goto Error;
    
            
    // Connect to the target router
    // ----------------------------------------------------------------
    CORg( SecureRouterInfo(pNode, m_fNoConnectingUI) );

    // Windows NT Bug : ?
    // Need to check the machine state.
    // ----------------------------------------------------------------
    if (pData->m_dataState < data_loaded)
        return hrOK;

    {
        CWaitCursor wc;

        // Setup the refresh advise sinks
        // ----------------------------------------------------------------
        if ( m_spRouterInfo )
        {
            SPIRouterRefresh    spRefresh;
            SPIRouterRefreshModify spModify;

            m_spRouterInfo->GetRefreshObject(&spRefresh);
            if(spRefresh)
            {
                spModify.HrQuery(spRefresh);
                if (spModify)
                    spModify->AddRouterObject(IID_IRouterInfo, m_spRouterInfo);
                m_bRouterInfoAddedToAutoRefresh = TRUE;

                // The lUserParam for this refresh connection, must be the
                // cookie.
                // ------------------------------------------------------------
                if ( pData->m_ulRefreshConnId == 0 )
                    spRefresh->AdviseRefresh(&m_IRtrAdviseSink,
                                         &(pData->m_ulRefreshConnId),
                                         pNode->GetData(TFS_DATA_COOKIE));
            }
        }


        dwRouterType = m_spRouterInfo->GetRouterType();

        m_spRouterInfo->GetRouterVersionInfo(&versionInfo);
        dwRouterFlags = versionInfo.dwRouterFlags;
        
        // Routing interfaces is enabled only if NOT a RAS-only router
        AddRemoveRoutingInterfacesNode(pNode, dwRouterType, dwRouterFlags);

        AddRemoveDialinNode(pNode, dwRouterType, dwRouterFlags);

        AddRemovePortsNode(pNode, dwRouterType, dwRouterFlags);
        
        // update status node, and Icon
        if (m_pSumNodeHandler && m_pSumNode)
            m_pSumNodeHandler->OnCommand(m_pSumNode,IDS_MENU_REFRESH,CCT_RESULT, NULL, 0);

        m_bExpanded = TRUE;

        CORg(AddDynamicNamespaceExtensions(pNode));
    }
    
Error:

    // Windows NT Bug : 274198
    // If we have an error and if the error is not "ERROR_BAD_NETPATH"
    // then we continue to load the info
    // ----------------------------------------------------------------

    // Setup the machine state at this point
    // ----------------------------------------------------------------
    if (!FHrSucceeded(hr))
    {
        if (hr == HResultFromWin32(ERROR_BAD_NETPATH))
        {
            pData->m_machineState = machine_bad_net_path;
            pData->m_serviceState = service_bad_net_path;
            pData->m_stState.LoadString(IDS_MACHINE_NAME_NOT_FOUND);
        }    
        else
        {
            // Try to load up the data if we can
            if ((pData->m_machineState == machine_unable_to_connect) ||
                (pData->m_machineState == machine_not_connected))
                pData->Load();
            
            if (pData->m_routerType == ServerType_Ras)
                hr = StartRasAdminExe(pData);
            else if (hr != HResultFromWin32(ERROR_CANCELLED))
                DisplayErrorMessage(NULL, hr);
        }

        m_fTryToConnect = FALSE;

	// snapin relies on registry service, check if it's running.
    // check if Remote Registry Service is not running
	    CServiceManager	csm;
	    CService svr;
	    DWORD	dwState = 0;
	    BOOL	RRWrong = TRUE;	// if any problem with RemoteRegistry Service
	        
		if (!IsLocalMachine(m_spRouterInfo->GetMachineName()) && SUCCEEDED( csm.HrOpen(SC_MANAGER_CONNECT, m_spRouterInfo->GetMachineName(), NULL)))
		{
		    if (SUCCEEDED(csm.HrOpenService(&svr, L"RemoteRegistry", SERVICE_QUERY_STATUS)))
		    {
		        if (SUCCEEDED(svr.HrQueryState(&dwState)))
   			    {
   			    	if(dwState == SERVICE_RUNNING)
   			    		RRWrong = FALSE;
		        }
		    }
		    
	       	if (RRWrong)
    	   	{
       			CString	str1;
       			str1.LoadString(IDS_ERR_RR_SERVICE_NOT_RUNNING);
	       		CString	str;
    	   		str.Format(str1, m_spRouterInfo->GetMachineName());
       		    ::AfxMessageBox(str);
	       	}
       	}
	// end of remote registry service checking
    }
        
    return hr;
}

HRESULT MachineHandler::OnResultRefresh(ITFSComponent * pComponent,
                                        LPDATAOBJECT pDataObject,
                                        MMC_COOKIE cookie,
                                        LPARAM arg,
                                        LPARAM lParam)
{
    HRESULT hr = hrOK;

    SPITFSNode spNode;
    m_spResultNodeMgr->FindNode(cookie, &spNode);

    MachineNodeData * pData = GET_MACHINENODEDATA(spNode);

    int nOldState = pData->m_dataState;

    if (pData->m_dataState != data_loaded)
    {
        SPIDataObject spDataObject;

        // change state to not connected here
        pData->m_dataState = data_not_loaded;

        hr = SecureRouterInfo(spNode, m_fNoConnectingUI);
    }

    // force an update if the machine was able to load
    // or the state has changed
    if (hr == S_OK &&
        m_spRouterInfo && 
        ( (pData->m_dataState >= data_loaded) ||
          (nOldState != pData->m_dataState) ) )
    {
        ForceGlobalRefresh(m_spRouterInfo);

        hr = OnCommand(spNode, IDS_DMV_MENU_REFRESH, CCT_RESULT, NULL, 0);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
   MachineHandler::AddMenuItems
      Over-ride this to add our view menu item
   Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
MachineHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
   MMC_COOKIE              cookie,
   LPDATAOBJECT         pDataObject, 
   LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
   long *               pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    return hr;
}


/*!--------------------------------------------------------------------------
   MachineHandler::Command
      Handles commands for the current view
   Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
MachineHandler::Command
(
    ITFSComponent * pComponent, 
   MMC_COOKIE        cookie, 
   int            nCommandID,
   LPDATAOBJECT   pDataObject
)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   HRESULT hr = S_OK;

   switch (nCommandID)
   {
        case MMCC_STANDARD_VIEW_SELECT:
            break;
    }

    return hr;
}

/*---------------------------------------------------------------------------
   MachineHandler::OnGetResultViewType
      Return the result view that this node is going to support
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
MachineHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
	LPWSTR		lpwszFormat = NULL; 
	LPWSTR		lpwszURL = NULL;
	WCHAR		wszSystemDirectory[MAX_PATH+1] = {0};
    SPITFSNode spNode;    

    m_spResultNodeMgr->FindNode(cookie, &spNode);

    MachineNodeData * pData = GET_MACHINENODEDATA(spNode);

    if ( !pData->m_MachineConfig.m_fConfigured )
    {
        lpwszFormat = L"res://%s\\mprsnap.dll/configure.htm";
    }
    else
    {
        lpwszFormat = L"res://%s\\mprsnap.dll/cfgdone.htm";
    }
	GetSystemDirectoryW ( wszSystemDirectory, MAX_PATH);
	lpwszURL = (LPWSTR)CoTaskMemAlloc( ( ::lstrlen(wszSystemDirectory) + ::lstrlen(lpwszFormat) ) * sizeof(WCHAR) );
	if ( lpwszURL )
	{
		wsprintf( lpwszURL, lpwszFormat, wszSystemDirectory );
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
		*ppViewType = lpwszURL;
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
 
    //return BaseRouterHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);
}


/*!--------------------------------------------------------------------------
   MachineHandler::OnResultSelect
        Update the result pane
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnResultSelect(ITFSComponent *pComponent,
                                       LPDATAOBJECT pDataObject,
                                       MMC_COOKIE cookie,
                                       LPARAM arg,
                                       LPARAM lParam)
{
    HRESULT hr = hrOK;
    SPITFSNode spNode;
    
    CORg(BaseRouterHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    m_spNodeMgr->FindNode(cookie, &spNode);

    UpdateResultMessage(spNode);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
   MachineHandler::UpdateResultMessage
        Determines what (if anything) to put in the result pane message
   Author: EricDav
 ---------------------------------------------------------------------------*/
void MachineHandler::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default none
    int i;
    CString strTitle, strBody, strTemp;
    // Only do this if the node we are looking at is a
    // machine node.
    if ((pNode == NULL) ||
        (*(pNode->GetNodeType()) != GUID_RouterMachineNodeType))
        return;

    MachineNodeData * pData = GET_MACHINENODEDATA(pNode);
    
    if (pData == NULL)
        return;

    if (pData->m_routerType == ServerType_RrasUninstalled)
    {
        nMessage = MACHINE_MESSAGE_NOT_CONFIGURED;

        // now build the text strings
        // first entry is the title
        strTitle.LoadString(g_uMachineMessages[nMessage][0]);

        // second entry is the icon
        // third ... n entries are the body strings

        for (i = 2; g_uMachineMessages[nMessage][i] != 0; i++)
        {
            strTemp.LoadString(g_uMachineMessages[nMessage][i]);
            strBody += strTemp;
        }
    }

    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uMachineMessages[nMessage][1]);
    }
}


/*!--------------------------------------------------------------------------
    MachineHandler::UserResultNotify
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::UserResultNotify(ITFSNode *pNode,
                                         LPARAM lParam1,
                                         LPARAM lParam2)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        // Do not handle RRAS_ON_SAVE, since there isn't any column
        // information for us to save.
        // ------------------------------------------------------------
        if (lParam1 != RRAS_ON_SAVE)
        {
            hr = BaseRouterHandler::UserResultNotify(pNode, lParam1, lParam2);
        }
    }
    COM_PROTECT_CATCH;
    
    return hr;      
}



/*---------------------------------------------------------------------------
    Embedded IRtrAdviseSink
 ---------------------------------------------------------------------------*/
ImplementEmbeddedUnknown(MachineHandler, IRtrAdviseSink)



/*!--------------------------------------------------------------------------
    MachineHandler::EIRtrAdviseSink::OnChange
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP MachineHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
    DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    InitPThis(MachineHandler, IRtrAdviseSink);
    SPITFSNode              spThisNode;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {

        //$ TODO : this is bogus, this is tied to the cookie
        // for this handler.  What we need is a mapping between
        // the connection ids (for this handler) and the appropriate
        // nodes.
        // ------------------------------------------------------------

        // The lUserParam passed into the refresh is the cookie for
        // this machine node.
        // ------------------------------------------------------------
        pThis->m_spNodeMgr->FindNode(lUserParam, &spThisNode);

        if(spThisNode)
	        pThis->SynchronizeIcon(spThisNode);
    
        if (dwChangeType == ROUTER_REFRESH)
        {
            DWORD   dwNewRouterType, dwNewRouterFlags;
            RouterVersionInfo   versionInfo;
            
            dwNewRouterType = pThis->m_spRouterInfo->GetRouterType();
            
            pThis->m_spRouterInfo->GetRouterVersionInfo(&versionInfo);
            dwNewRouterFlags = versionInfo.dwRouterFlags;
    
            // Ok, we have to take a look see and what nodes
            // we can add/remove
            // ----------------------------------------------------
            
            // Look to see if we need the Routing Interfaces node
            // ----------------------------------------------------
            pThis->AddRemoveRoutingInterfacesNode(spThisNode, dwNewRouterType,
                dwNewRouterFlags);
            
            // Look to see if we need the ports node
            // ----------------------------------------------------
            pThis->AddRemovePortsNode(spThisNode, dwNewRouterType,
                                      dwNewRouterFlags);
            
            // Look to see if we need the Dial-In Clients node
            // ----------------------------------------------------
            pThis->AddRemoveDialinNode(spThisNode, dwNewRouterType,
                                       dwNewRouterFlags);
        }
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    MachineHandler::AddRemoveRoutingInterfacesNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::AddRemoveRoutingInterfacesNode(ITFSNode *pNode, DWORD dwRouterType, DWORD dwRouterFlags)
{
    HRESULT     hr = hrOK;
    SPITFSNodeHandler spHandler;
    IfAdminNodeHandler * pHandler = NULL;
    SPITFSNode  spChild;

    // Search for an already existing node
    // ----------------------------------------------------------------
    SearchChildNodesForGuid(pNode, &GUID_RouterIfAdminNodeType, &spChild);

    if ((dwRouterType & (ROUTER_TYPE_WAN | ROUTER_TYPE_LAN)) &&
        (dwRouterFlags & RouterSnapin_IsConfigured))
    {
        // Create the new node if we don't already have one
        // ------------------------------------------------------------
        if (spChild == NULL)
        {
            // as a default, add the routing interfaces node
            // --------------------------------------------------------
            pHandler = new IfAdminNodeHandler(m_spTFSCompData);
            CORg( pHandler->Init(m_spRouterInfo, m_pConfigStream) );
            spHandler = pHandler;
            
            CreateContainerTFSNode(&spChild,
                                   &GUID_RouterIfAdminNodeType,
                                   static_cast<ITFSNodeHandler *>(pHandler),
                                   static_cast<ITFSResultHandler *>(pHandler),
                                   m_spNodeMgr);
            
            // Call to the node handler to init the node data
            // --------------------------------------------------------
            pHandler->ConstructNode(spChild);
            
            // Make the node immediately visible
            // --------------------------------------------------------
            spChild->SetVisibilityState(TFS_VIS_SHOW);
            
            //$ TODO : We should add this in the right place (where is that?)
            // --------------------------------------------------------
            pNode->AddChild(spChild);
        }
    }
    else
    {
        if (spChild)
        {
            // Remove this node
            // --------------------------------------------------------
            pNode->RemoveChild(spChild);
            spChild->Destroy();
            spChild.Release();
        }
    }
        
Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    MachineHandler::AddRemovePortsNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::AddRemovePortsNode(ITFSNode *pNode, DWORD dwRouterType,
                                           DWORD dwRouterFlags)
{
    HRESULT     hr = hrOK;
    SPITFSNodeHandler spHandler;
    PortsNodeHandler *   pPortsHandler = NULL;
    SPITFSNode  spChild;

    // Search for an already existing node
    // ----------------------------------------------------------------
    SearchChildNodesForGuid(pNode, &GUID_RouterPortsNodeType, &spChild);

    if ( (dwRouterType & (ROUTER_TYPE_RAS | ROUTER_TYPE_WAN) ) &&
         (dwRouterFlags & RouterSnapin_IsConfigured))

    {
        // Create the new node if we don't already have one
        // ------------------------------------------------------------
        if (spChild == NULL)
        {
            // as a default, add the routing interfaces node
            // --------------------------------------------------------
            pPortsHandler = new PortsNodeHandler(m_spTFSCompData);
            CORg( pPortsHandler->Init(m_spRouterInfo, m_pConfigStream) );
            spHandler = pPortsHandler;
            CreateContainerTFSNode(&spChild,
                                   &GUID_RouterPortsNodeType,
                                   static_cast<ITFSNodeHandler *>(pPortsHandler),
                                   static_cast<ITFSResultHandler *>(pPortsHandler),
                                   m_spNodeMgr);
            
            // Call to the node handler to init the node data
            // --------------------------------------------------------
            pPortsHandler->ConstructNode(spChild);
            
            // Make the node immediately visible
            // --------------------------------------------------------
            spChild->SetVisibilityState(TFS_VIS_SHOW);
            
            //$ TODO : We should add this in the right place (where is that?)
            // --------------------------------------------------------
            pNode->AddChild(spChild);
        }
    }
    else
    {
        if (spChild)
        {
            // Remove this node
            // --------------------------------------------------------
            pNode->RemoveChild(spChild);
            spChild->Destroy();
            spChild.Release();
        }
    }
        
Error:
    return hr;
}



/*!--------------------------------------------------------------------------
    MachineHandler::AddRemoveDialinNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::AddRemoveDialinNode(ITFSNode *pNode, DWORD dwRouterType,
                                            DWORD dwRouterFlags)
{
    HRESULT     hr = hrOK;
    SPITFSNodeHandler spHandler;
    DialInNodeHandler *  pDialInHandler = NULL;
    SPITFSNode  spChild;

    // Search for an already existing node
    // ----------------------------------------------------------------
    SearchChildNodesForGuid(pNode, &GUID_RouterDialInNodeType, &spChild);

    if ((dwRouterType & ROUTER_TYPE_RAS ) &&
        (dwRouterFlags & RouterSnapin_IsConfigured))
    {
        // Create the new node if we don't already have one
        // ------------------------------------------------------------
        if (spChild == NULL)
        {
            // as a default, add the dial in node
            pDialInHandler = new DialInNodeHandler(m_spTFSCompData);
            CORg( pDialInHandler->Init(m_spRouterInfo, m_pConfigStream) );
            spHandler = pDialInHandler;
            CreateContainerTFSNode(&spChild,
                                   &GUID_RouterDialInNodeType,
                                   static_cast<ITFSNodeHandler *>(pDialInHandler),
                                   static_cast<ITFSResultHandler *>(pDialInHandler),
                                   m_spNodeMgr);
            
            // Call to the node handler to init the node data
            pDialInHandler->ConstructNode(spChild);
            
            // Make the node immediately visible
            spChild->SetVisibilityState(TFS_VIS_SHOW);
            
            //$ TODO : We should add this in the right place (where is that?)
            // --------------------------------------------------------
            pNode->AddChild(spChild);
        }
    }
    else
    {
        if (spChild)
        {
            // Remove this node
            // --------------------------------------------------------
            pNode->RemoveChild(spChild);
            spChild->Destroy();
            spChild.Release();
        }
    }
        
Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    MachineConfig::GetMachineConfig
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineConfig::GetMachineConfig(MachineNodeData *pData)
{
    // m_fReachable
    m_fReachable = (pData->m_machineState == machine_connected);
    
    // m_fNt4
    m_fNt4 = (pData->m_routerVersion.dwRouterVersion <= 4);
            
    // m_fConfigured
    m_fConfigured = (pData->m_routerType != ServerType_RrasUninstalled);
    
    // m_dwServiceStatus
    // Set in FetchServerState();
    
    // m_fLocalMachine
    m_fLocalMachine = IsLocalMachine((LPCTSTR) pData->m_stMachineName);

    return hrOK;
}


/*!--------------------------------------------------------------------------
    MachineHandler::StartRasAdminExe
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::StartRasAdminExe(MachineNodeData *pData)
{
    // Locals.
    CString              sRasAdminExePath;
    CString              stCommandLine;
    LPTSTR               pszRasAdminExe = NULL;
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;
    HRESULT              hr = S_OK;
    UINT                 nCnt = 0;
    DWORD                cbAppCnt = 0;

    // Check the handle to see if rasadmin is running
    if (pData->m_hRasAdmin != INVALID_HANDLE_VALUE)
    {
        DWORD   dwReturn = 0;
        // If the state is not signalled, then the process has
        // not exited (or some other occurred).
        dwReturn = WaitForSingleObject(pData->m_hRasAdmin, 0);

        if (dwReturn == WAIT_TIMEOUT)
        {
            // The process has not signalled (it's still running);
            return hrOK;
        }
        else
        {
            // the process has signalled or the call failed, close the handle
            // and call up RasAdmin
            ::CloseHandle(pData->m_hRasAdmin);
            pData->m_hRasAdmin = INVALID_HANDLE_VALUE;
        }
    }
        
    try
    {

        // Looks like the RasAdmin.Exe is not running on this 
        // workstation's desktop; so, start it!
        
        // Figure out where the \\WinNt\System32 directory is.
        pszRasAdminExe = sRasAdminExePath.GetBuffer(((MAX_PATH+1)*sizeof(TCHAR)));
        nCnt = ::GetSystemDirectory(pszRasAdminExe, MAX_PATH);
        sRasAdminExePath.ReleaseBuffer();
        if (nCnt == 0)
            throw (HRESULT_FROM_WIN32(::GetLastError()));
        
        // Complete the construction of the executable's name.
        sRasAdminExePath += _T("\\rasadmin.exe");
        Assert(!::IsBadStringPtr((LPCTSTR)sRasAdminExePath, 
                                 sRasAdminExePath.GetLength()));

        // Build command line string
        stCommandLine.Format(_T("%s \\\\%s"),
                             (LPCTSTR) sRasAdminExePath,
                             (LPCTSTR) pData->m_stMachineName);
        
        // Start RasAdmin.Exe.
        ::ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO); 
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L; 
        si.wShowWindow = SW_SHOW; 
        ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
        if (!::CreateProcess(NULL,                      // pointer to name of executable module
                             (LPTSTR) (LPCTSTR) stCommandLine,   // pointer to command line string
                             NULL,                      // process security attributes
                             NULL,                      // thread security attributes
                             FALSE,                     // handle inheritance flag
                             CREATE_NEW_CONSOLE,        // creation flags
                             NULL,                      // pointer to new environment block
                             NULL,                      // pointer to current directory name
                             &si,                       // pointer to STARTUPINFO
                             &pi))                      // pointer to PROCESS_INFORMATION
            {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            ::CloseHandle(pi.hProcess); 
            }
        else
        {
            Assert(pData->m_hRasAdmin == INVALID_HANDLE_VALUE);
            pData->m_hRasAdmin = pi.hProcess;
        }
        ::CloseHandle(pi.hThread); 
        
        //
        // OPT: Maybe we should have used the ShellExecute() API rather than
        //         the CreateProcess() API. Why? The ShellExecute() API will
        //         give the shell the opportunity to check the current user's
        //         system policy settings before allowing the executable to execute.
        //
    }
    catch (CException * e)
    {
        hr = E_OUTOFMEMORY;
    }
    catch (HRESULT hrr)
    {
        hr = hrr;
    }
    catch (...)
    {
        hr = E_UNEXPECTED;
    }

    //Assert(SUCCEEDED(hr));
    return hr;
}



/*!--------------------------------------------------------------------------
    MachineHandler::OnResultShow
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnResultShow(ITFSComponent *pComponent,
                                     MMC_COOKIE cookie,
                                     LPARAM arg,
                                     LPARAM lParam)
{
    BOOL bSelect = static_cast<BOOL>(arg);
    HRESULT hr = hrOK;
    SPITFSNode  spNode;
    MachineNodeData    * pData = NULL;

    hr = BaseRouterHandler::OnResultShow(pComponent, cookie, arg, lParam);

    if (bSelect)
    {
        m_spNodeMgr->FindNode(cookie, &spNode);
        
        // We need the machine node data.
        // ------------------------------------------------------------
        pData = GET_MACHINENODEDATA(spNode);
        if (pData->m_routerType == ServerType_Ras)
            hr = StartRasAdminExe(pData);
        else if ((pData->m_machineState == machine_access_denied) ||
                 (pData->m_machineState == machine_bad_net_path))
        {
            // Try to connect again
            // --------------------------------------------------------
            if (m_fTryToConnect)
                OnExpand(spNode, NULL, 0, 0, 0);

            // If we have failed, keep on trucking!
            // --------------------------------------------------------
            m_fTryToConnect = TRUE;
        }
    }
    
    return hr;
}

/*!--------------------------------------------------------------------------
    MachineHandler::OnDelete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnDelete(ITFSNode *pNode,
                                 LPARAM arg,
                                 LPARAM param)
{
    SPITFSNode  spNode;
    SPITFSNode  spStatusNode;
    SPITFSNodeHandler spHoldHandler;
    SPITFSNode  spParent;
    SPITFSNode  spGrandParent;
    SPITFSNode  spthis;
    SPITFSNode  spMachineNode;
    DMVNodeData* pData;
    MachineNodeData *   pMachineData = NULL;
    MachineNodeData *   pNodeData = NULL;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode  spResultNode;
    MMC_COOKIE  cookie;


    // This will be the machine node, in the scope pane, that
    // we wish to delete.
    Assert(pNode);
    cookie = pNode->GetData(TFS_DATA_COOKIE);
    
    // Addref this node so that it won't get deleted before we're out
    // of this function
    spHoldHandler.Set( this );
    spthis.Set( pNode );
    
    pNode->GetParent( &spParent );
    Assert( spParent );

    // Given this node, find the node in the result pane that
    // corresponds to this scope node.
    
    // Iterate through the nodes of our parent node to find the
    // server status node.
    // ----------------------------------------------------------------

    spParent->GetEnum(&spNodeEnum);
    while (spNodeEnum->Next(1, &spStatusNode, NULL) == hrOK)
    {
        if ((*spStatusNode->GetNodeType()) == GUID_DomainStatusNodeType)
            break;
        spStatusNode.Release();
    }

    Assert(spStatusNode != NULL);


    // Now iterate through the status node to find the appropriate
    // machine.
    // ----------------------------------------------------------------
    spNodeEnum.Release();
    spStatusNode->GetEnum(&spNodeEnum);

    while (spNodeEnum->Next(1, &spResultNode, NULL) == hrOK)
    {
        pData = GET_DMVNODEDATA( spResultNode );
        Assert( pData );

        pMachineData = pData->m_spMachineData;
        if (pMachineData->m_cookie == cookie)
            break;
        spResultNode.Release();
    }
    

    // Note: if the server status node has not been expanded yet
    // we could hit this case.
    // ----------------------------------------------------------------
    if (pMachineData && (pMachineData->m_cookie == cookie))
    {
        // fetch & delete server node (the node in the result pane)
        spStatusNode->RemoveChild( spResultNode );
        spResultNode.Release();

    }
    else
    {
        // If this is the case, we need to remove the server from
        // the list before it is expanded.
        // ------------------------------------------------------------
        
        SPITFSNodeHandler   spHandler;
        spParent->GetHandler(&spHandler);

        // Get the node data (for this specific machine node)
        // ------------------------------------------------------------
        pNodeData = GET_MACHINENODEDATA(pNode);

        spHandler->UserNotify(spParent,
                              DMV_DELETE_SERVER_ENTRY,
                              (LPARAM) (LPCTSTR) pNodeData->m_stMachineName
                             );


    }
        

    // delete the machine node (the node in the scope pane)
    spParent->RemoveChild( pNode );
    

    return hrOK;
}

STDMETHODIMP MachineHandler::UserNotify(ITFSNode *pNode, LPARAM lParam, LPARAM lParam2)
{
    HRESULT     hr = hrOK;
    
    COM_PROTECT_TRY
    {
        switch (lParam)
        {
            case MACHINE_SYNCHRONIZE_ICON:
                {
                    SynchronizeIcon(pNode);
                }
                break;
            default:
                hr = BaseRouterHandler::UserNotify(pNode, lParam, lParam2);
                break;                
        }
    }
    COM_PROTECT_CATCH;

    return hr;                     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ports.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                         **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999                  **/
/**********************************************************************/

/*
    Ports
        Interface node information
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "Ports.h"
#include "ifadmin.h"
#include "rtrstrm.h"        // for RouterAdminConfigStream
#include "rtrlib.h"         // ContainerColumnInfo
#include "coldlg.h"         // ColumnDlg
#include "column.h"     // ComponentConfigStream
#include "refresh.h"        // IRouterRefresh
#include "iface.h"        // for interfacenode data
#include "portdlg.h"        // CConnDlg - connection dialog
#include "msgdlg.h"         // CMessageDlg
#include "raserror.h"
#include "dmvcomp.h"
#include "remras.h"
#include "rrasutil.h"        // Smart pointers
#include "rtrcomn.h"        // CoCreateRouterConfig
#include "rtrutilp.h"        // PortsDeviceTypeToCString

static BOOL RestartComputer(LPTSTR szMachineName);

//$PPTP
// This is the maximum number of ports that we allow for PPTP.
// Thus we can raise the maximum to this value only.
// --------------------------------------------------------------------

#define PPTP_MAX_PORTS      16384

//$L2TP
// This is the maximum number of ports that we allow for L2TP.
// Thus we can raise the maximum to this value only.
// --------------------------------------------------------------------

#define L2TP_MAX_PORTS      30000



/*---------------------------------------------------------------------------
    Defaults
 ---------------------------------------------------------------------------*/


PortsNodeData::PortsNodeData()
{
#ifdef DEBUG
    StrCpyA(m_szDebug, "PortsNodeData");
#endif
}

PortsNodeData::~PortsNodeData()
{
}

/*!--------------------------------------------------------------------------
    PortsNodeData::InitAdminNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeData::InitAdminNodeData(ITFSNode *pNode,
                                         RouterAdminConfigStream *pConfigStream)
{
    HRESULT             hr = hrOK;
    PortsNodeData * pData = NULL;
    
    pData = new PortsNodeData;

    SET_PORTSNODEDATA(pNode, pData);

    // Need to connect to the router to get this data
    
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeData::FreeAdminNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeData::FreeAdminNodeData(ITFSNode *pNode)
{    
    PortsNodeData * pData = GET_PORTSNODEDATA(pNode);
    delete pData;
    SET_PORTSNODEDATA(pNode, NULL);
    
    return hrOK;
}


HRESULT PortsNodeData::LoadHandle(LPCTSTR pszMachineName)
{
    m_stMachineName = pszMachineName;
    return HResultFromWin32(::MprAdminServerConnect((LPTSTR) pszMachineName,
        &m_sphDdmHandle));
    
}

HANDLE PortsNodeData::GetHandle()
{
    if (!m_sphDdmHandle)
    {
        LoadHandle(m_stMachineName);
    }
    return m_sphDdmHandle;
}

void PortsNodeData::ReleaseHandles()
{
    m_sphDdmHandle.Release();
}


STDMETHODIMP PortsNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
        return E_INVALIDARG;

    //    Place NULL in *ppv in case of failure
    *ppv = NULL;

    //    This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
    else if (riid == IID_IRtrAdviseSink)
        *ppv = &m_IRtrAdviseSink;
    else
        return CHandler::QueryInterface(riid, ppv);

    //    If we're going to return an interface, AddRef it first
    if (*ppv)
    {
    ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;    
}


/*---------------------------------------------------------------------------
    NodeHandler implementation
 ---------------------------------------------------------------------------*/

extern const ContainerColumnInfo    s_rgPortsColumnInfo[];

const ContainerColumnInfo s_rgPortsColumnInfo[] =
{
    { IDS_PORTS_COL_NAME,        CON_SORT_BY_STRING, TRUE , COL_IF_NAME},
    { IDS_PORTS_COL_DEVICE,     CON_SORT_BY_STRING, TRUE , COL_STRING},
    { IDS_PORTS_COL_USAGE,         CON_SORT_BY_STRING, TRUE , COL_STRING},
    { IDS_PORTS_COL_STATUS,     CON_SORT_BY_STRING, TRUE , COL_STATUS},
    { IDS_PORTS_COL_COMMENT,    CON_SORT_BY_STRING, FALSE , COL_STRING},
};
                                            
#define NUM_FOLDERS 1

PortsNodeHandler::PortsNodeHandler(ITFSComponentData *pCompData)
    : BaseContainerHandler(pCompData, DM_COLUMNS_PORTS, s_rgPortsColumnInfo),
    m_bExpanded(FALSE),
    m_pConfigStream(NULL),
    m_ulConnId(0),
    m_ulRefreshConnId(0),
    m_dwActivePorts(0)
{

    m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
    m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;

    // Setup the verb states for this node
    m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
    m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::Init(IRouterInfo *pRouterInfo,
                               RouterAdminConfigStream *pConfigStream)
{
    HRESULT hr = hrOK;

    // If we don't have a router info then we probably failed to load
    // or failed to connect.  Bail out of this.
    if (!pRouterInfo)
        CORg( E_FAIL );
    
    m_spRouterInfo.Set(pRouterInfo);

    // Also need to register for change notifications
    m_spRouterInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

    m_pConfigStream = pConfigStream;

Error:
    return hrOK;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::DestroyHandler
        Implementation of ITFSNodeHandler::DestroyHandler
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsNodeHandler::DestroyHandler(ITFSNode *pNode)
{
    PortsNodeData::FreeAdminNodeData(pNode);

    m_spDataObject.Release();
    
    if (m_ulRefreshConnId)
    {
        SPIRouterRefresh    spRefresh;
        if (m_spRouterInfo)
            m_spRouterInfo->GetRefreshObject(&spRefresh);
        if (spRefresh)
            spRefresh->UnadviseRefresh(m_ulRefreshConnId);
    }
    m_ulRefreshConnId = 0;
    
    if (m_spRouterInfo)
    {
        m_spRouterInfo->RtrUnadvise(m_ulConnId);
        m_spRouterInfo.Release();
    }
    return hrOK;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
PortsNodeHandler::HasPropertyPages
(
    ITFSNode *            pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES    type, 
    DWORD                dwType
)
{
    // Yes, we do have property pages
    return hrOK;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::CreatePropertyPages
        Implementation of ITFSNodeHandler::CreatePropertyPages
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsNodeHandler::CreatePropertyPages(
    ITFSNode *                pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                    dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;

    PortsProperties*    pPropSheet = NULL;
    SPIComponentData spComponentData;
    CString     stTitle;

    CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

    pPropSheet = new PortsProperties(pNode, spComponentData,
                                     m_spTFSCompData, stTitle,
                                     NULL, 0, TRUE
                                    );

    if ( FHrFailed(pPropSheet->Init(m_spRouterInfo, this)) ) 
    {
        AfxMessageBox(IDS_ERR_NO_ROUTERPROTOCOLS);
        delete pPropSheet;
        return hr;
    }

    if (lpProvider)
        hr = pPropSheet->CreateModelessSheet(lpProvider, handle);
    else
        hr = pPropSheet->DoModelessSheet();

Error:
    return hr;
}




/*---------------------------------------------------------------------------
    Menu data structure for our menus
 ---------------------------------------------------------------------------*/

struct SPortsNodeMenu
{
    ULONG    m_sidMenu;            // string/command id for this menu item
    ULONG    (PortsNodeHandler:: *m_pfnGetMenuFlags)(PortsNodeHandler::SMenuData *);
    ULONG    m_ulPosition;
};

//static const SPortsNodeMenu    s_rgPortsNodeMenu[] =
//{
//    // Add items that are primary go here
//    // Add items that go on the "Create new" menu here
//    // Add items that go on the "Task" menu here
//};

/*!--------------------------------------------------------------------------
    PortsNodeHandler::OnAddMenuItems
        Implementation of ITFSNodeHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsNodeHandler::OnAddMenuItems(
                                                ITFSNode *pNode,
                                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                                LPDATAOBJECT lpDataObject, 
                                                DATA_OBJECT_TYPES type, 
                                                DWORD dwType,
                                                long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = S_OK;
    
    COM_PROTECT_TRY
    {
        // Uncomment if you have items to add
//        hr = AddArrayOfMenuItems(pNode, s_rgPortsNodeMenu,
//                                 DimensionOf(s_rgPortsNodeMenu),
//                                 pContextMenuCallback,
//                                 *pInsertionAllowed);
    }
    COM_PROTECT_CATCH;
        
    return hr; 
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) PortsNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        if (m_stTitle.IsEmpty())
            m_stTitle.LoadString(IDS_PORTS);
    }
    COM_PROTECT_CATCH;

    return m_stTitle;
}


/*!--------------------------------------------------------------------------
    PortsNodeHandler::OnCreateDataObject
        Implementation of ITFSNodeHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsNodeHandler::OnCreateDataObject(MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;
    
    COM_PROTECT_TRY
    {
        if (!m_spDataObject)
        {
            CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
                m_spRouterInfo->GetMachineName(),
                type, cookie, m_spTFSCompData,
                &m_spDataObject, NULL, FALSE) );
            Assert(m_spDataObject);
        }
        
        *ppDataObject = m_spDataObject;
        (*ppDataObject)->AddRef();
            
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::OnExpand
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::OnExpand(ITFSNode *pNode,
                                   LPDATAOBJECT pDataObject,
                                   DWORD dwType,
                                   LPARAM arg,
                                   LPARAM lParam)
{
    HRESULT                 hr = hrOK;

    // If we don't have a router object, then we don't have any info, don't
    // try to expand.
    if (!m_spRouterInfo)
        return hrOK;
    
    if (m_bExpanded)
        return hrOK;

    COM_PROTECT_TRY
    {
        SynchronizeNodeData(pNode);

        m_bExpanded = TRUE;

    }
    COM_PROTECT_CATCH;

    return hr;
}


/*!--------------------------------------------------------------------------
    PortsNodeHandler::OnResultShow
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::OnResultShow(ITFSComponent *pTFSComponent,
                                       MMC_COOKIE cookie,
                                       LPARAM arg,
                                       LPARAM lParam)
{
    BOOL    bSelect = (BOOL) arg;
    HRESULT hr = hrOK;
    SPIRouterRefresh    spRefresh;
    SPITFSNode    spNode;

    BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

    if (bSelect)
    {
        // Call synchronize on this node
        m_spNodeMgr->FindNode(cookie, &spNode);
        if (spNode)
            SynchronizeNodeData(spNode);
    }

    // Un/Register for refresh advises
    if (m_spRouterInfo)
        m_spRouterInfo->GetRefreshObject(&spRefresh);

    if (spRefresh)
    {
        if (bSelect)
        {
            if (m_ulRefreshConnId == 0)
                spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
        }
        else
        {
            if (m_ulRefreshConnId)
                spRefresh->UnadviseRefresh(m_ulRefreshConnId);
            m_ulRefreshConnId = 0;
        }
    }
    
    return hr;
}


/*!--------------------------------------------------------------------------
    PortsNodeHandler::ConstructNode
        Initializes the Domain node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::ConstructNode(ITFSNode *pNode)
{
    HRESULT         hr = hrOK;
    PortsNodeData * pNodeData;
    
    if (pNode == NULL)
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the Domain node
        pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        m_cookie = reinterpret_cast<LONG_PTR>(pNode);
        pNode->SetData(TFS_DATA_COOKIE, m_cookie);

        pNode->SetNodeType(&GUID_RouterPortsNodeType);
        
        PortsNodeData::InitAdminNodeData(pNode, m_pConfigStream);

        pNodeData = GET_PORTSNODEDATA(pNode);
        Assert(pNodeData);
        //if there is any handle open, release it first
        pNodeData->ReleaseHandles();
        // Ignore the error, we should be able to deal with the
        // case of a stopped router.
        pNodeData->LoadHandle(m_spRouterInfo->GetMachineName());
    }
    COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
    PortsNodeHandler::SynchronizeNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
    Assert(pThisNode);
    
    SPITFSNodeEnum    spEnum;
    int             i;
    
    HRESULT hr = hrOK;
    InterfaceNodeData    *pData;
    DWORD                dwErr;
    PortsNodeData * pNodeData;
    PortsList            portsList;
    PortsList            newPortsList;
    PortsListEntry *    pPorts;
    BOOL                fFound;
    POSITION            pos;
    SPITFSNode            spChildNode;
    InterfaceNodeData * pChildData;

    DWORD               dwOldGdiBatchLimit;

    dwOldGdiBatchLimit = GdiGetBatchLimit();
    GdiSetBatchLimit(100);

    COM_PROTECT_TRY
    {

        // Get the status data from the running router
        pNodeData = GET_PORTSNODEDATA(pThisNode);
        // Ignore the error, we should be able to deal with the
        // case of a stopped router.
        if(pNodeData)
        {
            pNodeData->ReleaseHandles();
            pNodeData->LoadHandle(m_spRouterInfo->GetMachineName());
        }

        if (pNodeData == NULL || INVALID_HANDLE_VALUE == pNodeData->GetHandle())
        {
            // Remove all of the nodes, we can't connect so we can't
            // get any running data.
            UnmarkAllNodes(pThisNode, spEnum);
            RemoveAllUnmarkedNodes(pThisNode, spEnum);
            return hrOK;
        }
        
        // Unmark all of the nodes    
        pThisNode->GetEnum(&spEnum);
        UnmarkAllNodes(pThisNode, spEnum);
        
        // Go out and grab the data, merge the the new data in with
        // the old data.
        if( S_OK == GenerateListOfPorts(pThisNode, &portsList) )
        {
        
            pos = portsList.GetHeadPosition();

            // clear active ports count -- for bug 165862
            m_dwActivePorts = 0;
        
            while (pos)
            {
                pPorts = & portsList.GetNext(pos);
            
                // Look for this entry in our current list of nodes
                spEnum->Reset();
                spChildNode.Release();
            
                fFound = FALSE;
            
                for (;spEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
                {
                    pChildData = GET_INTERFACENODEDATA(spChildNode);
                    Assert(pChildData);

                    if (pChildData->m_rgData[PORTS_SI_PORT].m_ulData ==
                        (LONG_PTR) pPorts->m_rp0.hPort)
                    {
                        // Ok, this user already exists, update the metric
                        // and mark it
                        Assert(pChildData->dwMark == FALSE);
                        pChildData->dwMark = TRUE;
                    
                        fFound = TRUE;
                    
                        SetUserData(spChildNode, *pPorts);
                    
                        // Force MMC to redraw the node
                        spChildNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
                        break;
                    }
                }
            
                if (!fFound)
                    newPortsList.AddTail(*pPorts);
            
            }
        }

        // Remove all nodes that were not marked
        RemoveAllUnmarkedNodes(pThisNode, spEnum);

        // Now iterate through the list of new users, adding them all in.

        pos = newPortsList.GetHeadPosition();
        while (pos)
        {
            pPorts = & newPortsList.GetNext(pos);

            AddPortsUserNode(pThisNode, *pPorts);
        }
    }
    COM_PROTECT_CATCH;

    GdiFlush();
    GdiSetBatchLimit(dwOldGdiBatchLimit);
        
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::SetUserData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::SetUserData(ITFSNode *pNode,
                                      const PortsListEntry& entry)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    InterfaceNodeData * pData;
    TCHAR        szNumber[32];
    CString     st;
    int         ids;

    pData = GET_INTERFACENODEDATA(pNode);
    Assert(pData);

    st.Format(IDS_PORTS_NAME_FORMAT, entry.m_rp0.wszDeviceName,
              entry.m_rp0.wszPortName);
    pData->m_rgData[PORTS_SI_NAME].m_stData = st;
    pData->m_rgData[PORTS_SI_DEVICE].m_stData = entry.m_rp0.wszDeviceType;

    if (entry.m_fActiveDialOut)
    {
        ids = IDS_PORTS_DIALOUT_ACTIVE;
    }
    else if (entry.m_rp0.dwPortCondition == RAS_PORT_AUTHENTICATED)
    {
        ids = IDS_PORTS_ACTIVE;
        // to know how many active ports: BUG -- 165862
        // to prepare total number of active ports -- Wei Jiang
        m_dwActivePorts++;
    }
    else
    {
        ids = IDS_PORTS_INACTIVE;
    }
    pData->m_rgData[PORTS_SI_STATUS].m_stData.LoadString(ids);
    pData->m_rgData[PORTS_SI_STATUS].m_dwData = entry.m_rp0.dwPortCondition;

    pData->m_rgData[PORTS_SI_PORT].m_ulData = (LONG_PTR) entry.m_rp0.hPort;

    // fix b: 32887 --  show ras/routing enabled information
    // Column 0...Usage
    INT iType = (entry.m_dwEnableRas * 2) + 
                entry.m_dwEnableRouting | 
                entry.m_dwEnableOutboundRouting;
    pData->m_rgData[PORTS_SI_USAGE].m_stData = PortsDeviceTypeToCString(iType);



    // Update the PortsListEntry
    * (PortsListEntry *)pData->lParamPrivate = entry;
    
    // For status, need to check to see if there are any connections
    // on this port.

    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::GenerateListOfPorts
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::GenerateListOfPorts(ITFSNode *pNode, PortsList *pList)
{
    HRESULT         hr = hrOK;
    PortsListEntry    entry;
    PortsNodeData * pPortsData;
    DWORD            dwTotal;
    DWORD            i;
    RAS_PORT_0 *    rp0Table;
    DWORD            rp0Count;
    SPMprAdminBuffer    spMpr;
    HANDLE          hRasHandle = INVALID_HANDLE_VALUE;
    DWORD           dwSize, dwEntries;
    DWORD           dwErr;
    LPBYTE          pbPorts = NULL;
    POSITION        pos;
    POSITION        posPort;
    RasmanPortMap   portMap;
    
    // fix b: 3288 --
    PortsDeviceList    portsDeviceList;
    PortsDataEntry    portsDataEntry;
    

    pPortsData = GET_PORTSNODEDATA(pNode);
    Assert(pPortsData);

    // If we are connected, enumerate through the list of
    // ports
    CWRg( ::MprAdminPortEnum( pPortsData->GetHandle(),
                              0,
                              INVALID_HANDLE_VALUE,
                              (BYTE **) &rp0Table,
                              (DWORD) -1,
                              &rp0Count,
                              &dwTotal,
                              NULL) );

    Assert(rp0Table);
                                  
    spMpr = (LPBYTE) rp0Table;

    // Add a new PortsListEntry for each port

    // fix b: 32887 --  show ras/routing enabled information
    // use PortsDataEntry to load the device information to be use later for each ports
    // to get if a port is enabled for ras / routing
    hr = portsDataEntry.Initialize(m_spRouterInfo->GetMachineName());

    if (hr == S_OK)
    {
        hr = portsDataEntry.LoadDevices(&portsDeviceList);
    }
    
    
    for (i=0; i<rp0Count; i++)
    {
        ::ZeroMemory(&entry, sizeof(entry));
        entry.m_rp0 = rp0Table[i];

	//Get the unicode name from the port handle
	//RasGetUnicodeDeviceName(entry.m_rp0.hPort, entry.m_rp0.wszDeviceName);
        
        entry.m_fActiveDialOut = FALSE;

        // find out if ras / routing is enabled on the port
        entry.m_dwEnableRas = 0;                // = 1 if RAS is enabled on this device
        entry.m_dwEnableRouting = 0;            // = 1 if Routing is enabled on this device
        entry.m_dwEnableOutboundRouting = 0;    // = 1 if outbound 
                                                //  routing is enabled 
                                                //  on this device

        POSITION    pos;
        pos = portsDeviceList.GetHeadPosition();

        while(pos != NULL)
        {
            PortsDeviceEntry *    pPortEntry = portsDeviceList.GetNext(pos);

            CString strPortName = entry.m_rp0.wszDeviceName;

            if(strPortName == pPortEntry->m_stDisplayName)
            {
                entry.m_dwEnableRas  = pPortEntry->m_dwEnableRas;
                entry.m_dwEnableRouting = pPortEntry->m_dwEnableRouting;
                entry.m_dwEnableOutboundRouting = 
                    pPortEntry->m_dwEnableOutboundRouting;
                break;
            }
        }

        pList->AddTail(entry);
    }

    spMpr.Free();

Error:
    delete [] pbPorts;
    if (hRasHandle != INVALID_HANDLE_VALUE)
        RasRpcDisconnectServer(hRasHandle);
    return hr;
}


ImplementEmbeddedUnknown(PortsNodeHandler, IRtrAdviseSink)

STDMETHODIMP PortsNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
    DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    InitPThis(PortsNodeHandler, IRtrAdviseSink);
    SPITFSNode                spThisNode;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {

        pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);
    
        if (dwChangeType == ROUTER_REFRESH)
        {
            // Ok, just call the synchronize on this node
            pThis->SynchronizeNodeData(spThisNode);
        }
        else if (dwChangeType == ROUTER_DO_DISCONNECT)
        {
            PortsNodeData * pData = GET_PORTSNODEDATA(spThisNode);
            Assert(pData);

            // Release the handle
            pData->ReleaseHandles();
            
        }
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::CompareItems
        Implementation of ITFSResultHandler::CompareItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) PortsNodeHandler::CompareItems(
                                ITFSComponent * pComponent,
                                MMC_COOKIE cookieA,
                                MMC_COOKIE cookieB,
                                int nCol)
{
    // Get the strings from the nodes and use that as a basis for
    // comparison.
    SPITFSNode    spNode;
    SPITFSResultHandler spResult;

    m_spNodeMgr->FindNode(cookieA, &spNode);
    spNode->GetResultHandler(&spResult);
    return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*!--------------------------------------------------------------------------
    PortsNodeHandler::AddPortsUserNode
        Adds a user to the UI.    This will create a new result item
        node for each interface.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::AddPortsUserNode(ITFSNode *pParent, const PortsListEntry& PortsEntry)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    PortsUserHandler *    pHandler;
    SPITFSResultHandler     spHandler;
    SPITFSNode                spNode;
    HRESULT                 hr = hrOK;

    pHandler = new PortsUserHandler(m_spTFSCompData);
    spHandler = pHandler;
    CORg( pHandler->Init(m_spRouterInfo, pParent) );
    
    CORg( CreateLeafTFSNode(&spNode,
                            NULL,
                            static_cast<ITFSNodeHandler *>(pHandler),
                            static_cast<ITFSResultHandler *>(pHandler),
                            m_spNodeMgr) );
    CORg( pHandler->ConstructNode(spNode, NULL, &PortsEntry) );

    SetUserData(spNode, PortsEntry);
    
    // Make the node immediately visible
    CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
    CORg( pParent->AddChild(spNode) );
Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::UnmarkAllNodes
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
    SPITFSNode    spChildNode;
    InterfaceNodeData * pNodeData;
    
    pEnum->Reset();
    for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
    {
        pNodeData = GET_INTERFACENODEDATA(spChildNode);
        Assert(pNodeData);
        
        pNodeData->dwMark = FALSE;            
    }
    return hrOK;
}

/*!--------------------------------------------------------------------------
    PortsNodeHandler::RemoveAllUnmarkedNodes
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsNodeHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
    HRESULT     hr = hrOK;
    SPITFSNode    spChildNode;
    InterfaceNodeData * pNodeData;
    
    pEnum->Reset();
    for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
    {
        pNodeData = GET_INTERFACENODEDATA(spChildNode);
        Assert(pNodeData);
        
        if (pNodeData->dwMark == FALSE)
        {
            pNode->RemoveChild(spChildNode);
            spChildNode->Destroy();
        }
    }

    return hr;
}



/*---------------------------------------------------------------------------
    PortsUserHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(PortsUserHandler)

IMPLEMENT_ADDREF_RELEASE(PortsUserHandler)

STDMETHODIMP PortsUserHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
        return E_INVALIDARG;

    //    Place NULL in *ppv in case of failure
    *ppv = NULL;

    //    This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
    else if (riid == IID_IRtrAdviseSink)
        *ppv = &m_IRtrAdviseSink;
    else
        return CBaseResultHandler::QueryInterface(riid, ppv);

    //    If we're going to return an interface, AddRef it first
    if (*ppv)
    {
    ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;    
}


/*---------------------------------------------------------------------------
    NodeHandler implementation
 ---------------------------------------------------------------------------*/


PortsUserHandler::PortsUserHandler(ITFSComponentData *pCompData)
            : BaseRouterHandler(pCompData),
            m_ulConnId(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(PortsUserHandler);

    // Enable Refresh from the node itself
    // ----------------------------------------------------------------
    m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
    m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
}


/*!--------------------------------------------------------------------------
    PortsUserHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsUserHandler::Init(IRouterInfo *pInfo, ITFSNode *pParent)
{
    m_spRouterInfo.Set(pInfo);
    return hrOK;
}


/*!--------------------------------------------------------------------------
    PortsUserHandler::DestroyResultHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsUserHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
    SPITFSNode    spNode;
    
    m_spNodeMgr->FindNode(cookie, &spNode);
    InterfaceNodeData::Free(spNode);
    
    CHandler::DestroyResultHandler(cookie);
    return hrOK;
}


static DWORD    s_rgInterfaceImageMap[] =
     {
     ROUTER_IF_TYPE_HOME_ROUTER,    IMAGE_IDX_WAN_CARD,
     ROUTER_IF_TYPE_FULL_ROUTER,    IMAGE_IDX_WAN_CARD,
     ROUTER_IF_TYPE_CLIENT,         IMAGE_IDX_WAN_CARD,
     ROUTER_IF_TYPE_DEDICATED,        IMAGE_IDX_LAN_CARD,
     ROUTER_IF_TYPE_INTERNAL,        IMAGE_IDX_LAN_CARD,
     ROUTER_IF_TYPE_LOOPBACK,        IMAGE_IDX_LAN_CARD,
     -1,                            IMAGE_IDX_WAN_CARD, // sentinel value
     };

/*!--------------------------------------------------------------------------
    PortsUserHandler::ConstructNode
        Initializes the Domain node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsUserHandler::ConstructNode(ITFSNode *pNode,
                                         IInterfaceInfo *pIfInfo,
                                         const PortsListEntry *pEntry)
{
    HRESULT         hr = hrOK;
    int             i;
    InterfaceNodeData * pData;

    Assert(pEntry);
    
    if (pNode == NULL)
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the Domain node

        pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_WAN_CARD);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_WAN_CARD);
        
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<LONG_PTR>(pNode));

        //$ Review: kennt, what are the different type of interfaces
        // do we distinguish based on the same list as above? (i.e. the
        // one for image indexes).
        pNode->SetNodeType(&GUID_RouterPortsResultNodeType);

        m_entry = *pEntry;

        InterfaceNodeData::Init(pNode, pIfInfo);

        // We need to save this pointer so that it can be modified
        // (and updated) at a later time.
        // ------------------------------------------------------------
        pData = GET_INTERFACENODEDATA(pNode);
        pData->lParamPrivate = (LPARAM) &m_entry;
    }
    COM_PROTECT_CATCH
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsUserHandler::GetString
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) PortsUserHandler::GetString(ITFSComponent * pComponent,
    MMC_COOKIE cookie,
    int nCol)
{
    Assert(m_spNodeMgr);
    
    SPITFSNode        spNode;
    InterfaceNodeData * pData;
    ConfigStream *    pConfig;

    m_spNodeMgr->FindNode(cookie, &spNode);
    Assert(spNode);

    pData = GET_INTERFACENODEDATA(spNode);
    Assert(pData);

    pComponent->GetUserData((LONG_PTR *) &pConfig);
    Assert(pConfig);

    return pData->m_rgData[pConfig->MapColumnToSubitem(DM_COLUMNS_PORTS, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
    PortsUserHandler::CompareItems
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) PortsUserHandler::CompareItems(ITFSComponent * pComponent,
    MMC_COOKIE cookieA,
    MMC_COOKIE cookieB,
    int nCol)
{
    return StriCmpW(GetString(pComponent, cookieA, nCol),
                    GetString(pComponent, cookieB, nCol));
}

static const SRouterNodeMenu s_rgIfNodeMenu[] =
{
    { IDS_MENU_PORTS_STATUS, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    
    { IDS_MENU_PORTS_DISCONNECT, PortsUserHandler::GetDisconnectMenuState,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
};

ULONG PortsUserHandler::GetDisconnectMenuState(const SRouterNodeMenu *pMenuData,
                                               INT_PTR pUserData)
{
    InterfaceNodeData * pNodeData;
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);
    
    pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
    Assert(pNodeData);

    if (pNodeData->m_rgData[PORTS_SI_STATUS].m_dwData == RAS_PORT_AUTHENTICATED)
        return 0;
    else
        return MF_GRAYED;
}

/*!--------------------------------------------------------------------------
    PortsUserHandler::AddMenuItems
        Implementation of ITFSResultHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsUserHandler::AddMenuItems(ITFSComponent *pComponent,
                                                MMC_COOKIE cookie,
                                                LPDATAOBJECT lpDataObject, 
                                                LPCONTEXTMENUCALLBACK pContextMenuCallback,
    long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = S_OK;
    SPITFSNode    spNode;
    PortsUserHandler::SMenuData menuData;

    // We don't allow any actions on active dialout connections
    // ------------------------------------------------------------
    if (m_entry.m_fActiveDialOut)
        return hrOK;
    
    COM_PROTECT_TRY
    {
        m_spNodeMgr->FindNode(cookie, &spNode);

        // Now go through and add our menu items
        menuData.m_spNode.Set(spNode);
        
        hr = AddArrayOfMenuItems(spNode, s_rgIfNodeMenu,
                                 DimensionOf(s_rgIfNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
    }
    COM_PROTECT_CATCH;
        
    return hr; 
}

/*!--------------------------------------------------------------------------
    PortsUserHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsUserHandler::Command(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           int nCommandId,
                                           LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    SPITFSNode    spNode;
    SPITFSNode    spNodeParent;
    SPITFSNodeHandler    spParentHandler;
    PortsNodeData * pData;
    HRESULT hr = S_OK;

    COM_PROTECT_TRY
    {
        switch (nCommandId)
        {
            case IDS_MENU_PORTS_STATUS:
                {
                    BOOL    fRefresh = FALSE;
                    DWORD   dwInterval = 60;                    
                    SPIRouterRefresh    spRefresh;
                    
                    if (m_spRouterInfo)
                        m_spRouterInfo->GetRefreshObject(&spRefresh);
                    
                    // Stop the auto refresh (if it is turned on)
                    // ------------------------------------------------
                    if (spRefresh && FHrOK(spRefresh->IsRefreshStarted()))
                    {
                        fRefresh = TRUE;
                        spRefresh->GetRefreshInterval(&dwInterval);
                        spRefresh->Stop();
                    }
                    
                    // NOTE: This function gets called from other places
                    // in the code (for which pDataObject==NULL)
                    
                    // Get the hServer and hPort
                    m_spNodeMgr->FindNode(cookie, &spNode);
                    spNode->GetParent(&spNodeParent);

                    pData = GET_PORTSNODEDATA(spNodeParent);

                    CPortDlg    portdlg((LPCTSTR) pData->m_stMachineName,
                                        pData->GetHandle(),
                                        m_entry.m_rp0.hPort,
                                        spNodeParent
                                        );    

                    portdlg.DoModal();

//                  if (portdlg.m_bChanged)
                    RefreshInterface(cookie);

                    // Restart the refresh mechanism
                    // ------------------------------------------------
                    if (fRefresh && spRefresh)
                    {
                        spRefresh->SetRefreshInterval(dwInterval);
                        spRefresh->Start(dwInterval);
                    }
                }
                break;
            case IDS_MENU_PORTS_DISCONNECT:
                {
                    // Get the hServer and hPort
                    m_spNodeMgr->FindNode(cookie, &spNode);
                    spNode->GetParent(&spNodeParent);

                    pData = GET_PORTSNODEDATA(spNodeParent);
                        
                    ::MprAdminPortDisconnect(
                        pData->GetHandle(),
                        m_entry.m_rp0.hPort);

                    RefreshInterface(cookie);
                }
                break;
            default:
                break;
        };
    }
    COM_PROTECT_CATCH;
    
    return hr;
}


ImplementEmbeddedUnknown(PortsUserHandler, IRtrAdviseSink)

STDMETHODIMP PortsUserHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
    DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    InitPThis(PortsUserHandler, IRtrAdviseSink);
    HRESULT hr = hrOK;
    
    return hr;
}


/*!--------------------------------------------------------------------------
    PortsUserHandler::OnCreateDataObject
        Implementation of ITFSResultHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP PortsUserHandler::OnCreateDataObject(ITFSComponent *pComp,
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;
    
    COM_PROTECT_TRY
    {
        CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
                                             m_spRouterInfo->GetMachineName(),
                                             type, cookie, m_spTFSCompData,
                                             ppDataObject, NULL, FALSE) );
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

STDMETHODIMP PortsUserHandler::HasPropertyPages (
    ITFSComponent *pComp,
    MMC_COOKIE cookie,
    LPDATAOBJECT pDataObject)
{
    return hrFalse;
}


/*!--------------------------------------------------------------------------
    PortsUserHandler::RefreshInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsUserHandler::RefreshInterface(MMC_COOKIE cookie)
{
    ForceGlobalRefresh(m_spRouterInfo);
}

/*!--------------------------------------------------------------------------
    PortsUserHandler::OnResultItemClkOrDblClk
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsUserHandler::OnResultItemClkOrDblClk(ITFSComponent *pComponent,
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM lParam ,
    BOOL bDoubleClick)
{
    HRESULT     hr = hrOK;
    
    // We don't allow any actions on active dialout connections
    // ------------------------------------------------------------
    if (m_entry.m_fActiveDialOut)
        return hrOK;
    
    if (bDoubleClick)
    {
        // Bring up the status dialog on this port
        CORg( Command(pComponent, cookie, IDS_MENU_PORTS_STATUS,
                      NULL) );
    }

Error:
    return hr;
}


/*---------------------------------------------------------------------------
    PortsProperties implementation
 ---------------------------------------------------------------------------*/

PortsProperties::PortsProperties(ITFSNode *pNode,
                                 IComponentData *pComponentData,
                                 ITFSComponentData *pTFSCompData,
                                 LPCTSTR pszSheetName,
                                 CWnd *pParent,
                                 UINT iPage,
                                 BOOL fScopePane)
    : RtrPropertySheet(pNode, pComponentData, pTFSCompData,
                       pszSheetName, pParent, iPage, fScopePane),
        m_pageGeneral(IDD_PORTS_GLOBAL_GENERAL),
        m_pPortsNodeHandle(NULL),
        m_dwThreadId(0)
{
}

PortsProperties::~PortsProperties()
{
    if (m_dwThreadId)
        DestroyTFSErrorInfoForThread(m_dwThreadId, 0);
    if(m_pPortsNodeHandle)
    {
        m_pPortsNodeHandle->Release();
        m_pPortsNodeHandle = NULL;
    }
}

/*!--------------------------------------------------------------------------
    PortsProperties::Init
        Initialize the property sheets.  The general action here will be
        to initialize/add the various pages.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsProperties::Init(IRouterInfo *pRouter, PortsNodeHandler* pPortsNodeHandle)
{
    Assert(pRouter);
    HRESULT hr = hrOK;

    m_spRouter.Set(pRouter);
    
    m_pPortsNodeHandle = pPortsNodeHandle;
    if(m_pPortsNodeHandle)    m_pPortsNodeHandle->AddRef();

    // The pages are embedded members of the class
    // do not delete them.
    m_bAutoDeletePages = FALSE;

    m_pageGeneral.Init(this, pRouter);
    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

//Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    PortsProperties::SetThreadInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsProperties::SetThreadInfo(DWORD dwThreadId)
{
    m_dwThreadId = dwThreadId;
}


/*---------------------------------------------------------------------------
    PortsPageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(PortsPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(PortsPageGeneral)
    ON_BN_CLICKED(IDC_PGG_BTN_CONFIGURE, OnConfigure)
    ON_NOTIFY(NM_DBLCLK, IDC_PGG_LIST, OnListDblClk)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_PGG_LIST, OnNotifyListItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

PortsPageGeneral::~PortsPageGeneral()
{
    while (!m_deviceList.IsEmpty())
        delete m_deviceList.RemoveHead();
}


/*!--------------------------------------------------------------------------
    PortsPageGeneral::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsPageGeneral::Init(PortsProperties *pPropSheet, IRouterInfo *pRouter)
{
    m_pPortsPropSheet = pPropSheet;
    m_spRouter.Set(pRouter);
    
    RouterVersionInfo    routerVersion;

    // Get the version info.  Needed later on.
    // ----------------------------------------------------------------
    ASSERT(m_spRouter.p);
    m_spRouter->GetRouterVersionInfo(&routerVersion);

    m_bShowContent = (routerVersion.dwRouterVersion >= 5);

    return hrOK;
}

/*!--------------------------------------------------------------------------
    PortsPageGeneral::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL PortsPageGeneral::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr= hrOK;
    int         i;
    CString     st;
    UINT        cRows = 0;
    PortsDeviceEntry *    pEntry = NULL;
    TCHAR        szNumber[32];
    HRESULT     hrT;
    RECT        rc;
    int         nWidth, nUsageWidth;
    int            nListWidth;
    POSITION    pos;
    INT         iPos;
    HKEY        hkeyMachine = 0;
    INT         iType, idsType;
    DWORD        dwIn, dwOut;

    // if focus on NT4 machine, not to display the content of the dialog, only display some text
    // for the user that the snapin only shows property of NT5 server
    if (!m_bShowContent)
    {
        CString     st;

        st.LoadString(IDS_ERR_NOPORTINFO_ON_NT4);
        
        EnableChildControls(GetSafeHwnd(), PROPPAGE_CHILD_HIDE | PROPPAGE_CHILD_DISABLE);
        GetDlgItem(IDC_PGG_TXT_NOINFO)->SetWindowText(st);
        GetDlgItem(IDC_PGG_TXT_NOINFO)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_PGG_TXT_NOINFO)->EnableWindow(TRUE);
        return TRUE;
    }

    // hide the warning text if on NT5 servers
    GetDlgItem(IDC_PGG_TXT_NOINFO)->ShowWindow(SW_HIDE);
    
    COM_PROTECT_TRY
    {
        // This assumes that this page will always come up.
        // Create the error info for this thread!
        // ------------------------------------------------------------
        CreateTFSErrorInfo(0);
        m_pPortsPropSheet->SetThreadInfo(GetCurrentThreadId());
        
        RtrPropertyPage::OnInitDialog();

        ListView_SetExtendedListViewStyle(m_listCtrl.GetSafeHwnd(),
                                          LVS_EX_FULLROWSELECT);
        

        // Initialize the list control (with the list of devices)
        // Determine optimal width for the header control
        GetDlgItem(IDC_PGG_LIST)->GetWindowRect(&rc);
        nListWidth = rc.right - rc.left;

        // Figure out the size of Ras/Routing
        st.LoadString(IDS_PORTSDLG_COL_RASROUTING);
        st += _T("WW"); // add extra padding to get a little wider
        nUsageWidth = m_listCtrl.GetStringWidth(st);

        // Remove the Ras/Routing column from the rest of the width
        nListWidth -= nUsageWidth;

        // Remove four pixels off the end (for the borders?)
        nListWidth -= 4;

        // Split the width into fifths
        nWidth = nListWidth / 5;

        // Create the column headers.

        // Column 0...Usage
        st.LoadString(IDS_PORTSDLG_COL_USAGE);
        m_listCtrl.InsertColumn(PORTS_COL_USAGE, st, LVCFMT_LEFT, nUsageWidth, 0);

        
        // Column 1...Device
        st.LoadString(IDS_PORTSDLG_COL_NAME);
        m_listCtrl.InsertColumn(PORTS_COL_DEVICE, st, LVCFMT_LEFT, 3*nWidth, 0);

        
        // Column 2...Type
        st.LoadString(IDS_PORTSDLG_COL_TYPE);
        m_listCtrl.InsertColumn(PORTS_COL_TYPE, st, LVCFMT_LEFT, nWidth, 0);

        
        // Column 3...Number of Ports
        st.LoadString(IDS_PORTSDLG_COL_NUM_PORTS);
        m_listCtrl.InsertColumn(PORTS_COL_NUMBER, st, LVCFMT_LEFT, nWidth, 0);

        
        // Query for the ports' data.
        m_deviceDataEntry.Initialize(m_spRouter->GetMachineName());
        m_deviceDataEntry.LoadDevices(&m_deviceList);

        
        // Walk the list of ports and construct the row entry for the table 
        // for the given port.
        pos = m_deviceList.GetHeadPosition();
        while (pos)
        {
            pEntry = m_deviceList.GetNext(pos);
            Assert(!::IsBadReadPtr(pEntry, sizeof(PortsDeviceEntry)));

            // Column 1...Device
            iPos = m_listCtrl.InsertItem(cRows, pEntry->m_stDisplayName);
            m_listCtrl.SetItemText(iPos, PORTS_COL_DEVICE,
                                   (LPCTSTR) pEntry->m_stDisplayName);
            
            // Column 2...Type
            st = PortTypeToCString(RAS_DEVICE_TYPE(pEntry->m_eDeviceType));
            m_listCtrl.SetItemText(iPos, PORTS_COL_TYPE, (LPCTSTR) st);

            // Column 3...Number of Ports
            FormatNumber(pEntry->m_dwPorts, szNumber,
                         DimensionOf(szNumber), FALSE);
            m_listCtrl.SetItemText(iPos, PORTS_COL_NUMBER, (LPCTSTR) szNumber);

            m_listCtrl.SetItemData(iPos, (LONG_PTR) pEntry);

            // Column 0...Usage
            iType = (pEntry->m_dwEnableRas * 2) + 
                    (pEntry->m_dwEnableRouting |
                     pEntry->m_dwEnableOutboundRouting);

            st = PortsDeviceTypeToCString(iType);
            m_listCtrl.SetItemText(iPos, PORTS_COL_USAGE, (LPCTSTR) st);

            // How many rows now?
            ++cRows;    // preincrement faster operation on Pentium chips...
        }

        // As a default, disable the maximum ports dialog
        GetDlgItem(IDC_PGG_BTN_CONFIGURE)->EnableWindow(FALSE);
        
        if (cRows)
        {
            // Select the first entry in the list control
            m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
        }

    }
    COM_PROTECT_CATCH;
    
    SetDirty(FALSE);
        
    if (!FHrSucceeded(hr))
    {
        delete pEntry;
        Cancel();
    }
    return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
    PortsPageGeneral::DoDataExchange
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsPageGeneral::DoDataExchange(CDataExchange *pDX)
{
    if (!m_bShowContent)    return;

    RtrPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(PortsPageGeneral)
    DDX_Control(pDX, IDC_PGG_LIST, m_listCtrl);
    //}}AFX_DATA_MAP
    
}

/*!--------------------------------------------------------------------------
    PortsPageGeneral::OnApply
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL PortsPageGeneral::OnApply()
{
    if (!m_bShowContent)    return TRUE;
    
    if (m_pPortsPropSheet->IsCancel())
        return TRUE;

    if(!IsDirty())
        return TRUE;
    
    BOOL        fReturn;
    HRESULT     hr = hrOK;
    HRESULT     hrT = hrOK;
    DWORD        dwErr, dwInValue, dwOutValue;
    HKEY        hkeyMachine;
    RegKey        regkeyMachine;
    POSITION    pos;
    PortsDeviceEntry *    pEntry;

    // Create an error object (just in case)
    CreateTFSErrorInfo(0);
    ClearTFSErrorInfo(0);

    CWRg( ConnectRegistry(m_spRouter->GetMachineName(), &hkeyMachine) );
    regkeyMachine.Attach(hkeyMachine);

    // We ignore the error code from the SaveDevices().  The reason
    // is that for most of the failures, it's only a partial failure
    // (especially for the RasSetDeviceConfigInfo() call.

    hrT = m_deviceDataEntry.SaveDevices(&m_deviceList);
    AddSystemErrorMessage(hrT);
    
Error:
    if (!FHrSucceeded(hr) || !FHrSucceeded(hrT))
    {
        AddHighLevelErrorStringId(IDS_ERR_CANNOT_SAVE_PORTINFO);
        DisplayTFSErrorMessage(NULL);

        // Set focus back to the property sheet
        BringWindowToTop();

        // If the only thing that reports failure is hrT (or the
        // SaveDevices() code), then we continue on.
        if (FHrSucceeded(hr))
            fReturn = RtrPropertyPage::OnApply();
        else
            fReturn = FALSE;
    }
    else
        fReturn = RtrPropertyPage::OnApply();


    // Windows NT Bug : 174916 - need to force a refresh through
    ForceGlobalRefresh(m_spRouter);
    
    return fReturn;
}


void PortsPageGeneral::OnListDblClk(NMHDR *pNMHdr, LRESULT *pResult)
{
    OnConfigure();

    *pResult = 0;
}

/*!--------------------------------------------------------------------------
    PortsPageGeneral::OnNotifyListItemChanged
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsPageGeneral::OnNotifyListItemChanged(NMHDR *pNmHdr, LRESULT *pResult)
{
//    NMLISTVIEW *    pnmlv = reinterpret_cast<NMLISTVIEW *>(pNmHdr);
//    BOOL            fEnable = !!(pnmlv->uNewState & LVIS_SELECTED);
    BOOL fEnable = (m_listCtrl.GetSelectedCount() != 0);

    GetDlgItem(IDC_PGG_BTN_CONFIGURE)->EnableWindow(fEnable);
    *pResult = 0;
}


/*!--------------------------------------------------------------------------
    PortsPageGeneral::OnConfigure
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsPageGeneral::OnConfigure()
{
    // Windows NT Bug : 322955
    // Always mark the page dirty.  This is needed because the OnOK()
    // will call OnApply() on the property sheet before the dialog is
    // exited.  This is called to force the changes to save back before
    // the restart is called.
    // ----------------------------------------------------------------
    SetDirty(TRUE);
    SetModified();
    
    OnConfigurePorts(m_spRouter->GetMachineName(),
                     m_pPortsPropSheet->m_pPortsNodeHandle->GetActivePorts(),
                     this,
                     &m_listCtrl);
}


/*---------------------------------------------------------------------------
    PortsDataEntry implementation
 ---------------------------------------------------------------------------*/

PortsDataEntry::PortsDataEntry()
{
    m_fReadFromRegistry = TRUE;
}

PortsDataEntry::~PortsDataEntry()
{
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::Initialize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::Initialize(LPCTSTR pszMachineName)
{
    DWORD       dwErr;
    HRESULT     hr = hrOK;
    HKEY        hkeyMachine;

    m_fRestrictDialin = TRUE;
    m_regkeyMachine.Close();
    m_stMachine = pszMachineName;
    
    dwErr = ConnectRegistry( m_stMachine, &hkeyMachine);
    if( dwErr == NO_ERROR)
    {
        m_regkeyMachine.Attach(hkeyMachine);
        hr = CheckForDialinRestriction();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::LoadDevices
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::LoadDevices(PortsDeviceList *pList)
{
    HRESULT     hr = hrOK;
    POSITION    pos;
    PortsDeviceEntry *    pEntry;

    // Try to load the devices from the router (actually rasman),
    // if that fails then try the registry

    hr = LoadDevicesFromRouter(pList);
    if (!FHrSucceeded(hr))
        hr = LoadDevicesFromRegistry(pList);

    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::LoadDevicesFromRegistry
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::LoadDevicesFromRegistry(PortsDeviceList *pList)
{
    HRESULT     hr = hrOK;
    RegKey        regkey;
    RegKey        regkeyDevice;
    RegKey        regkeyEnable;
    RegKeyIterator    regkeyIter;
    HRESULT     hrIter;
    CString     stKey;
    CString     st;
    CString     stFullText;
    CString     stComponentId;
    DWORD        dwEnableRas;
    DWORD        dwEnableRouting;
    DWORD        dwEnableOutboundRouting;
    DWORD        dwT;
    DWORD        dwErr;
    PortsDeviceEntry *    pEntry;
    WCHAR devName[MAX_DEVICE_NAME + 1];
    
    COM_PROTECT_TRY
    {
        // Connect to the machine
        // ------------------------------------------------------------
        if (m_regkeyMachine == NULL)
        {
            CORg(ERROR_CAN_NOT_COMPLETE);
        }
    
        // Get the list of devices
        // ------------------------------------------------------------
    
        // Open HKLM\System\CurrentControlSet\Control\Class\<Modem GUID>
        // ------------------------------------------------------------
        CWRg( regkey.Open(m_regkeyMachine, c_szModemKey, KEY_READ) );

        
        // Enumerate through the list of modems
        // ------------------------------------------------------------
        CORg( regkeyIter.Init(&regkey) );
        
        for (hrIter = regkeyIter.Next(&stKey); hrIter == hrOK; stKey.Empty(), hrIter = regkeyIter.Next(&stKey))
        {
            // Cleanup from the previous loop
            // --------------------------------------------------------
            regkeyDevice.Close();
            regkeyEnable.Close();
        
            // Open the key
            // --------------------------------------------------------
            dwErr = regkeyDevice.Open(regkey, stKey, KEY_READ | KEY_WRITE);
            if (dwErr != ERROR_SUCCESS)
                continue;
        
            // Need to check for the EnableForRas subkey
            // --------------------------------------------------------
            dwErr = regkeyEnable.Open(regkeyDevice, c_szClientsRasKey, KEY_READ);
            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = regkeyEnable.QueryValue(c_szEnableForRas, dwEnableRas);
            }
        
            // Default: assume that the modems are RAS-enabled
            // --------------------------------------------------------
            if (dwErr != ERROR_SUCCESS)
                dwEnableRas = 1;
        
            // Need to check for the EnableForRouting subkey
            // --------------------------------------------------------
            dwErr = regkeyEnable.QueryValue(c_szEnableForRouting, dwEnableRouting);
        
            // Default: assume that the modems are not routing-enabled
            // --------------------------------------------------------
            if (dwErr != ERROR_SUCCESS)
                dwEnableRouting = 0;


            // Need to check for the EnableForOutboundRouting subkey
            // --------------------------------------------------------
            dwErr = regkeyEnable.QueryValue(
                        c_szEnableForOutboundRouting, dwEnableOutboundRouting
                        );
        
            // Default: assume that the modems are not routing-enabled
            // --------------------------------------------------------
            if (dwErr != ERROR_SUCCESS)
                dwEnableOutboundRouting = 0;


            CString stDisplay;
        
            // Do allocation before adding the text to the UI
            // --------------------------------------------------------
            pEntry = new PortsDeviceEntry;
            pEntry->m_fModified = FALSE;
            pEntry->m_dwPorts = 1;
            pEntry->m_fWriteable = FALSE;        // # of ports can't be changed
            pEntry->m_dwMinPorts = pEntry->m_dwPorts;
            pEntry->m_dwMaxPorts = pEntry->m_dwPorts;
            pEntry->m_dwMaxMaxPorts = pEntry->m_dwMaxPorts;
            pEntry->m_dwEnableRas = dwEnableRas;
            pEntry->m_dwEnableRouting = dwEnableRouting;
            pEntry->m_dwEnableOutboundRouting = dwEnableOutboundRouting;
            pEntry->m_eDeviceType = RDT_Modem;
                
            // Save the old values
            // --------------------------------------------------------
            pEntry->m_dwOldPorts = pEntry->m_dwPorts;

            // Add this modem to the list
            // --------------------------------------------------------
            regkeyDevice.QueryValue(c_szFriendlyName, stFullText);
            regkeyDevice.QueryValue(c_szAttachedTo, st);
            stDisplay.Format(IDS_PORTS_NAME_FORMAT, stFullText, st);
            swprintf(devName, L"%S",(LPCTSTR)stDisplay);
            pEntry->m_stDisplayName = devName;

            // Read in all data from the registry key BEFORE here
            // --------------------------------------------------------
            pEntry->m_fRegistry = TRUE;
            pEntry->m_hKey = regkeyDevice;        
            regkeyDevice.Detach();

            
            pList->AddTail(pEntry);
            
            pEntry = NULL;
        }
    
    
        // Enumerate through the list of adapters that have the EnableForRas flag
        // Open HKLM\System\CurrentControlSet\Control\Class\GUID_DEVCLASS_NET
        // ------------------------------------------------------------
        regkey.Close();
        CWRg( regkey.Open(m_regkeyMachine, c_szRegKeyGUID_DEVCLASS_NET, KEY_READ | KEY_WRITE) );
        
        // Enumerate through the list of adapters
        // ------------------------------------------------------------
        CORg( regkeyIter.Init(&regkey) );
        
        stKey.Empty();
        
        for (hrIter = regkeyIter.Next(&stKey); hrIter == hrOK; hrIter = regkeyIter.Next(&stKey))
        {
            // Cleanup from the previous loop
            // --------------------------------------------------------
            regkeyDevice.Close();
            
            // Open the key
            // --------------------------------------------------------
            dwErr = regkeyDevice.Open(regkey, stKey, KEY_READ | KEY_WRITE);
            if (dwErr == ERROR_SUCCESS)
            {
                CString stDisplay;
                DWORD    dwEndpoints;
                
                // Need to get the ComponentId to check for PPTP/PTI
                // ------------------------------------------------
                dwErr = regkeyDevice.QueryValue(c_szRegValMatchingDeviceId,
                                                stComponentId);
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = regkeyDevice.QueryValue(c_szRegValComponentId,
                        stComponentId);
                    if (dwErr != ERROR_SUCCESS)
                        stComponentId.Empty();
                }

                
                // Check to see if it has the EnableForRas flag
                // ----------------------------------------------------
                dwErr = regkeyDevice.QueryValue(c_szEnableForRas, dwEnableRas);
                
                // Default: assume that adapters are RAS-enabled
                // ----------------------------------------------------
                if (dwErr != ERROR_SUCCESS)
                {
                    // Windows NT Bug : 292615
                    // If this is a parallel port, do not enable RAS
                    // by default.
                    // ------------------------------------------------
                    if (stComponentId.CompareNoCase(c_szPtiMiniPort) == 0)
                        dwEnableRas = 0;
                    else
                        dwEnableRas = 1;
                }

                
                // Check to see if it has the EnableForRouting flag
                // ----------------------------------------------------
                dwErr = regkeyDevice.QueryValue(c_szEnableForRouting,
                                                dwEnableRouting);
                
                // Default: assume that adapters are not routing-enabled
                // ----------------------------------------------------
                if (dwErr != ERROR_SUCCESS)
                    dwEnableRouting = 0;

                // Need to check for the EnableForOutboundRouting subkey
                // --------------------------------------------------------
                dwErr = regkeyEnable.QueryValue(
                            c_szEnableForOutboundRouting, dwEnableOutboundRouting
                            );
            
                // Default: assume that the adapters are not routing-enabled
                // --------------------------------------------------------
                if (dwErr != ERROR_SUCCESS)
                    dwEnableOutboundRouting = 0;

                
                dwErr = regkeyDevice.QueryValue(c_szWanEndpoints, dwEndpoints);

                
                // If there is no WanEndpoints key, then we assume
                // that the device isn't RAS-capable
                // ----------------------------------------------------
                if (dwErr == ERROR_SUCCESS)
                {
        
                    // Do allocation before adding the text to the UI
                    // ------------------------------------------------
                    pEntry = new PortsDeviceEntry;
                    pEntry->m_fModified = FALSE;
                    pEntry->m_dwEnableRas = dwEnableRas;
                    pEntry->m_dwEnableRouting = dwEnableRouting;
                    pEntry->m_dwEnableOutboundRouting =
                        dwEnableOutboundRouting;
                            
                    pEntry->m_dwPorts = dwEndpoints;
                    
                    // If this is PPTP, then set the eDeviceType flag
                    // ------------------------------------------------
                    if (stComponentId.CompareNoCase(c_szPPTPMiniPort) == 0)
                        pEntry->m_eDeviceType = RDT_Tunnel_Pptp;
                    else if (stComponentId.CompareNoCase(c_szL2TPMiniPort) == 0)
                        pEntry->m_eDeviceType = RDT_Tunnel_L2tp;
                    else if (stComponentId.CompareNoCase(c_szPPPoEMiniPort) == 0)
                        pEntry->m_eDeviceType = RDT_PPPoE;
                    else if (stComponentId.CompareNoCase(c_szPtiMiniPort) == 0)
                        pEntry->m_eDeviceType = RDT_Parallel;
                    else
                        pEntry->m_eDeviceType = (RASDEVICETYPE) RDT_Other;

                    
                    // Save the old values
                    // ------------------------------------------------
                    pEntry->m_dwOldPorts = pEntry->m_dwPorts;        
                                        
                    // Look for min and max values
                    // If the MinWanEndpoints and MaxWanEndpoints keys
                    // exist then this is writeable.
                    // ------------------------------------------------
                    dwErr = regkeyDevice.QueryValue(c_szMinWanEndpoints, dwT);
                    pEntry->m_dwMinPorts = dwT;
                    if (dwErr == ERROR_SUCCESS)
                        dwErr = regkeyDevice.QueryValue(c_szMaxWanEndpoints, dwT);
                    if (dwErr != ERROR_SUCCESS)
                    {
                        pEntry->m_fWriteable = FALSE;
                        pEntry->m_dwMinPorts = pEntry->m_dwPorts;
                        pEntry->m_dwMaxPorts = pEntry->m_dwPorts;
                    }
                    else
                    {
                        pEntry->m_fWriteable = TRUE;
                        pEntry->m_dwMaxPorts = dwT;
                    }
                    pEntry->m_dwMaxMaxPorts = pEntry->m_dwMaxPorts;

                    //$PPTP
                    // For PPTP, we can change the m_dwMaxMaxPorts
                    // ------------------------------------------------
                    if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
                    {
                        pEntry->m_dwMaxMaxPorts = m_fRestrictDialin ?
                                                    MAX_ALLOWED_DIALIN : 
                                                    PPTP_MAX_PORTS;
                    }

                    //$L2TP
                    // For L2TP, change the dwMaxMaxPorts
                    // ------------------------------------------------
                    if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp)
                    {
                        pEntry->m_dwMaxMaxPorts = m_fRestrictDialin ?
                                                    MAX_ALLOWED_DIALIN : 
                                                    L2TP_MAX_PORTS;
                    }

                    //$PPPoE
                    // For PPPoE, we cannot change the number of endpoints
                    // ------------------------------------------------
                    if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_PPPoE)
                    {
                        pEntry->m_fWriteable = FALSE;
                    }

                    // Verify current set of endpoints is within range
                    //-------------------------------------------------
                    if (pEntry->m_dwMaxPorts > pEntry->m_dwMaxMaxPorts)
                    {
                        pEntry->m_dwMaxPorts = pEntry->m_dwMaxMaxPorts;
                    }

                    if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                    {
                        pEntry->m_dwPorts = pEntry->m_dwMaxPorts;
                    }
                    
                    // Add this device to the list
                    // ------------------------------------------------
                    regkeyDevice.QueryValue(c_szRegValDriverDesc, stDisplay);
                    pEntry->m_stDisplayName = stDisplay;
                                    
                    // Store the value so that we can use it to write
                    // ------------------------------------------------
                    pEntry->m_fRegistry = TRUE;
                    pEntry->m_hKey = regkeyDevice;
                    regkeyDevice.Detach();
                    
                    pList->AddTail(pEntry);
                    pEntry = NULL;
                }
            }
            stKey.Empty();
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (FHrSucceeded(hr))
        m_fReadFromRegistry = TRUE;
    
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::LoadDevicesFromRouter
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::LoadDevicesFromRouter(PortsDeviceList *pList)
{
    HRESULT     hr = hrOK;
    HANDLE        hConnection = 0;
    DWORD        cDevices = 0;
    DWORD        cbData = 0;
    BYTE *        pbData = NULL;
    RAS_DEVICE_INFO *    pDevInfo = NULL;
    PortsDeviceEntry *    pEntry = NULL;
    DWORD        dwVersion;
    UINT        i;
    DWORD        dwErr;
    WCHAR devName[MAX_DEVICE_NAME + 1];

    
    USES_CONVERSION;

    COM_PROTECT_TRY
    {

        // Connect to the server
        CWRg( RasRpcConnectServer((LPTSTR) (LPCTSTR)m_stMachine, &hConnection) );

        dwVersion = RasGetServerVersion(hConnection);

        // Get the device information from the router
        dwErr = RasGetDeviceConfigInfo(hConnection,
                                       &dwVersion,
                                       &cDevices,
                                       &cbData,
                                       NULL);

        if (dwErr == ERROR_BUFFER_TOO_SMALL)
            dwErr = ERROR_SUCCESS;
        CWRg(dwErr);
        
        pbData = (BYTE *) new char[cbData];
        
        // Go out and actually grab the data
        CWRg( RasGetDeviceConfigInfo(hConnection,
                                     &dwVersion,
                                     &cDevices,
                                     &cbData,
                                     pbData));

        pDevInfo = (RAS_DEVICE_INFO *) pbData;

        // If we found something and we don't understand the dev version,
        // just punt.
        if (cDevices && pDevInfo->dwVersion != 0 && pDevInfo->dwVersion != VERSION_501)
        {
            // We don't understand the version information
            hr = E_FAIL;
            goto Error;
        }

        if(dwVersion == VERSION_501)
        {
            for (i=0; i<cDevices; i++, pDevInfo++)
            {
                pEntry = new PortsDeviceEntry;
                pEntry->m_fModified = FALSE;
                pEntry->m_dwEnableRas = pDevInfo->fRasEnabled;
                pEntry->m_dwEnableRouting = pDevInfo->fRouterEnabled;
                pEntry->m_dwEnableOutboundRouting =
                    pDevInfo->fRouterOutboundEnabled;
                pEntry->m_stDisplayName = pDevInfo->wszDeviceName;
                pEntry->m_dwPorts = pDevInfo->dwNumEndPoints;
                pEntry->m_eDeviceType = pDevInfo->eDeviceType;
                
                // Save the old values
                pEntry->m_dwOldPorts = pEntry->m_dwPorts;

                pEntry->m_dwMinPorts = pDevInfo->dwMinWanEndPoints;
                pEntry->m_dwMaxPorts = pDevInfo->dwMaxWanEndPoints;
                pEntry->m_dwMaxMaxPorts = pEntry->m_dwMaxPorts;

                //$PPTP
                // For PPTP, we can adjust the value of m_dwMaxPorts
                // --------------------------------------------------------
                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
                {
                    pEntry->m_dwMaxMaxPorts = m_fRestrictDialin ?
                                                MAX_ALLOWED_DIALIN :
                                                PPTP_MAX_PORTS;
                }

                //$L2TP
                // For L2TP, we can adjust the value of m_dwMaxPorts
                // --------------------------------------------------------
                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp)
                {
                    pEntry->m_dwMaxMaxPorts = m_fRestrictDialin ?
                                                MAX_ALLOWED_DIALIN :
                                                L2TP_MAX_PORTS;
                }

                // Verify current set of endpoints is within range
                //-------------------------------------------------
                if (pEntry->m_dwMaxPorts > pEntry->m_dwMaxMaxPorts)
                {
                    pEntry->m_dwMaxPorts = pEntry->m_dwMaxMaxPorts;
                }

                if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                {
                    pEntry->m_dwPorts = pEntry->m_dwMaxPorts;
                }

                pEntry->m_fWriteable = 
                    (pEntry->m_dwMinPorts != pEntry->m_dwMaxPorts) &&
                    (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) != RDT_PPPoE);
                
                pEntry->m_fRegistry = FALSE;
                pEntry->m_hKey = NULL;

                // Make a copy of the data
                pEntry->m_RasDeviceInfo = *pDevInfo;

                pList->AddTail(pEntry);
                pEntry = NULL;                    
            }
        }
        else
        {
            RAS_DEVICE_INFO_V500 * pDevInfo500 = (RAS_DEVICE_INFO_V500 *)pbData;

	        for (i=0; i<cDevices; i++, pDevInfo500++)
	        {
	            pEntry = new PortsDeviceEntry;
	            pEntry->m_fModified = FALSE;
	            pEntry->m_dwEnableRas = pDevInfo500->fRasEnabled;
	            pEntry->m_dwEnableRouting = pDevInfo500->fRouterEnabled;
	            swprintf(devName, L"%S", pDevInfo500->szDeviceName);
	            pEntry->m_stDisplayName = devName;
	            pEntry->m_dwPorts = pDevInfo500->dwNumEndPoints;
	            pEntry->m_eDeviceType = pDevInfo500->eDeviceType;
	            
	            // Save the old values
	            pEntry->m_dwOldPorts = pEntry->m_dwPorts;
	        
	            pEntry->m_dwMinPorts = pDevInfo500->dwMinWanEndPoints;
	            pEntry->m_dwMaxPorts = pDevInfo500->dwMaxWanEndPoints;
	            pEntry->m_dwMaxMaxPorts = pEntry->m_dwMaxPorts;

	            //$PPTP
	            // For PPTP, we can adjust the value of m_dwMaxPorts
	            // --------------------------------------------------------
	            if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
	            {
	                pEntry->m_dwMaxMaxPorts = PPTP_MAX_PORTS;
	            }
	            
	            //$L2TP
	            // For L2TP, we can adjust the value of m_dwMaxPorts
	            // --------------------------------------------------------
	            if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp)
	            {
	                pEntry->m_dwMaxMaxPorts = L2TP_MAX_PORTS;
	            }
	            
	            pEntry->m_fWriteable = 
	                (pEntry->m_dwMinPorts != pEntry->m_dwMaxPorts) &&
	                (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) != RDT_PPPoE);
	            
	            pEntry->m_fRegistry = FALSE;
	            pEntry->m_hKey = NULL;

	            // Make a copy of the data
	            // pEntry->m_RasDeviceInfo = *pDevInfo;
	            memcpy(&pEntry->m_RasDeviceInfo, pDevInfo500,
	                   FIELD_OFFSET(RAS_DEVICE_INFO, fRouterOutboundEnabled));
                memcpy(&pEntry->m_RasDeviceInfo.dwTapiLineId, 
                       &pDevInfo500->dwTapiLineId,
                       sizeof(RAS_DEVICE_INFO) 
                       - FIELD_OFFSET(RAS_DEVICE_INFO, dwTapiLineId));
                       
	            pList->AddTail(pEntry);
	            pEntry = NULL;                    
	        }
            
            
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (FHrSucceeded(hr))
        m_fReadFromRegistry = FALSE;
    
    // If the function didn't succeed, clean out the list
    if (!FHrSucceeded(hr))
    {
        while (!pList->IsEmpty())
            delete pList->RemoveHead();
    }

    delete [] pbData;
    delete pEntry;
        
    if (hConnection)
        RasRpcDisconnectServer(hConnection);
    return hr;
}


/*!--------------------------------------------------------------------------
    PortsDataEntry::SaveDevices
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::SaveDevices(PortsDeviceList *pList)
{
    HRESULT     hr = hrOK;
    CWaitCursor wait;

    if (m_fReadFromRegistry)
        hr = SaveDevicesToRegistry(pList);
    else
        hr = SaveDevicesToRouter(pList);
    
    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::SaveDevicesToRegistry
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::SaveDevicesToRegistry(PortsDeviceList *pList)
{
    HRESULT     hr = hrOK;
    RegKey        regkeyDevice;
    RegKey        regkeyPptpProtocol;
    POSITION    pos;
    PortsDeviceEntry *    pEntry = NULL;
    DWORD        dwErr;

    Assert(pList);

    // Write any changes made to the per-device configuration
    // and write that back out to the registry
    // ----------------------------------------------------------------
    pos = pList->GetHeadPosition();
    while (pos)
    {
        pEntry = pList->GetNext(pos);

        if (pEntry->m_fModified)
        {
            Assert(pEntry->m_hKey);

            regkeyDevice.Attach(pEntry->m_hKey);
            COM_PROTECT_TRY
            {
                RegKey    regkeyModem;
                RegKey *    pRegkeyDevice = NULL;
                
                if (pEntry->m_fWriteable)
                {
                    if (m_fRestrictDialin &&
                        (pEntry->m_dwPorts > MAX_ALLOWED_DIALIN))
                    {
                        pEntry->m_dwPorts = MAX_ALLOWED_DIALIN;
                    }
                    
                    regkeyDevice.SetValue(c_szWanEndpoints,
                                          pEntry->m_dwPorts);

                    //$PPTP
                    // We need to adjust the upper limit for the
                    // number of PPTP ports.
                    // ------------------------------------------------
                    if ((RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp) &&
                        (pEntry->m_dwPorts > pEntry->m_dwMaxPorts))
                    {
                        DWORD   dwPorts;

                        //$PPTP
                        // Keep the value of the number of PPTP ports
                        // below the max.
                        // --------------------------------------------
                        if (m_fRestrictDialin)
                            dwPorts = MAX_ALLOWED_DIALIN;
                        else
                            dwPorts = min(pEntry->m_dwPorts, PPTP_MAX_PORTS);
                        regkeyDevice.SetValue(c_szMaxWanEndpoints, dwPorts);
                    }
                    
                    //$L2TP
                    // We need to adjust the upper limit for the
                    // number of L2TP ports.
                    // ------------------------------------------------
                    if ((RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp) &&
                        (pEntry->m_dwPorts > pEntry->m_dwMaxPorts))
                    {
                        DWORD   dwPorts;

                        //$L2TP
                        // Keep the value of the number of L2TP ports
                        // below the max.
                        // --------------------------------------------
                        if (m_fRestrictDialin)
                            dwPorts = MAX_ALLOWED_DIALIN;
                        else
                            dwPorts = min(pEntry->m_dwPorts, L2TP_MAX_PORTS);
                        regkeyDevice.SetValue(c_szMaxWanEndpoints, dwPorts);
                    }
                }

                // Get the clients subkey (if for a modem)
                // else use the device key
                // ----------------------------------------------------
                if (pEntry->m_eDeviceType == RDT_Modem)
                {
                    dwErr = regkeyModem.Create(regkeyDevice, c_szClientsRasKey);
                    pRegkeyDevice = &regkeyModem;
                }
                else
                {
                    pRegkeyDevice = &regkeyDevice;
                    dwErr = ERROR_SUCCESS;
                }

                if (dwErr == ERROR_SUCCESS)
                {
                    pRegkeyDevice->SetValue(c_szEnableForRas,
                                            pEntry->m_dwEnableRas);
                    pRegkeyDevice->SetValue(c_szEnableForRouting,
                                            pEntry->m_dwEnableRouting);
                    pRegkeyDevice->SetValue(c_szEnableForOutboundRouting,
                                            pEntry->m_dwEnableOutboundRouting);
                }
            }
            COM_PROTECT_CATCH;
            regkeyDevice.Detach();

            // The NumberLineDevices is no longer used in NT5.

            // if this is for PPTP, then we need to special case the
            // code to set the PPTP number of devices
            // --------------------------------------------------------
            if (pEntry->m_fWriteable &&
                pEntry->m_fModified &&
                RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
            {
                // Open the PPTP registry key
                // ----------------------------------------------------
                dwErr = regkeyPptpProtocol.Open(m_regkeyMachine,
                                                c_szRegKeyPptpProtocolParam);
                
                // set the NumberLineDevices registry value
                // ----------------------------------------------------
                if (dwErr == ERROR_SUCCESS)
                    regkeyPptpProtocol.SetValue(c_szRegValNumberLineDevices,
                                                pEntry->m_dwPorts);
                regkeyPptpProtocol.Close();
            }
            
        }

        // Windows NT Bug: 136858 (add called id support)
        // Save called id info
        // ------------------------------------------------------------
        if (pEntry->m_fSaveCalledIdInfo)
        {
            Assert(pEntry->m_fCalledIdInfoLoaded);

            regkeyDevice.Attach(pEntry->m_hKey);

            regkeyDevice.SetValueExplicit(c_szRegValCalledIdInformation,
                                          REG_MULTI_SZ,
                                          pEntry->m_pCalledIdInfo->dwSize,
                                          (PBYTE) pEntry->m_pCalledIdInfo->bCalledId
                                          );
            
            regkeyDevice.Detach();

            
        }
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDataEntry::SaveDevicesToRouter
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::SaveDevicesToRouter(PortsDeviceList *pList)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK, hrTemp;
    HANDLE        hConnection = 0;
    DWORD        cDevices = 0;
    BYTE *        pbData = NULL;
    RAS_DEVICE_INFO *    pDevInfo = NULL;
    PortsDeviceEntry *    pEntry = NULL;
    POSITION    pos;
    UINT        i;
    RAS_CALLEDID_INFO    calledIdInfo;
    DWORD        dwErr = ERROR_SUCCESS;
    TCHAR        szErr[512];
    DWORD       dwVersion;
    

    Assert(pList);

    COM_PROTECT_TRY
    {

        // Connect to the server
        // ------------------------------------------------------------
        CWRg( RasRpcConnectServer((LPTSTR)(LPCTSTR)m_stMachine, &hConnection) );

        dwVersion = RasGetServerVersion(hConnection);

        // Allocate space for the data
        // ------------------------------------------------------------
        pbData = (BYTE *) new RAS_DEVICE_INFO[pList->GetCount()];

        pDevInfo = (RAS_DEVICE_INFO *) pbData;

        pos = pList->GetHeadPosition();
        cDevices = pList->GetCount();

        if(dwVersion == VERSION_501)
        {
            for (i=0; i<cDevices; i++, pDevInfo++)
            {
                Assert(pos);

                pEntry = pList->GetNext(pos);

                // Get the information needed to calculate the number
                // of ports
                // --------------------------------------------------------
                *pDevInfo = pEntry->m_RasDeviceInfo;

                pDevInfo->fWrite = TRUE;
                pDevInfo->fRasEnabled = pEntry->m_dwEnableRas;
                pDevInfo->fRouterEnabled = pEntry->m_dwEnableRouting;
                pDevInfo->fRouterOutboundEnabled = 
                    pEntry->m_dwEnableOutboundRouting;
                if ((m_fRestrictDialin) && 
                    (pEntry->m_dwPorts > MAX_ALLOWED_DIALIN))
                {
                    pEntry->m_dwPorts = MAX_ALLOWED_DIALIN;
                }
                pDevInfo->dwNumEndPoints = pEntry->m_dwPorts;
                pDevInfo->dwMaxWanEndPoints = pEntry->m_dwMaxPorts;

                // Windows NT Bug : 168364
                // From RaoS, I also need to set the maximum incoming/outging
                // --------------------------------------------------------

                // Windows NT Bug : ?
                // Use the defaults for now,
                // This will get removed later.
                // --------------------------------------------------------
                pDevInfo->dwMaxInCalls = (-1);
                pDevInfo->dwMaxOutCalls = 3;
                

                // if this is for PPTP, then we need to special case the
                // code to set the PPTP number of devices
                // --------------------------------------------------------
                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
                {
                    //$PPTP
                    // We need to adjust the upper limit for the
                    // number of PPTP ports.
                    // ------------------------------------------------
                    if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                    {
                        DWORD   dwPorts;

                        //$PPTP
                        // Keep the value of the number of PPTP ports
                        // below the max.
                        // --------------------------------------------
                        if (m_fRestrictDialin)
                            dwPorts = MAX_ALLOWED_DIALIN;
                        else
                            dwPorts = min(pEntry->m_dwPorts, PPTP_MAX_PORTS);
                        pDevInfo->dwMaxWanEndPoints = dwPorts;
                    }
                    
                    RegKey        regkeyMachine;
                    RegKey        regkeyPptpProtocol;
                    HKEY        hkeyMachine;
                    
                    // Connect to the machine
                    dwErr = ConnectRegistry(m_stMachine, &hkeyMachine);
                    regkeyMachine.Attach(hkeyMachine);

                    // Open the PPTP registry key
                    dwErr = regkeyPptpProtocol.Open(regkeyMachine,
                                                    c_szRegKeyPptpProtocolParam);
                    
                    // set the NumberLineDevices registry value
                    if (dwErr == ERROR_SUCCESS)
                        regkeyPptpProtocol.SetValue(c_szRegValNumberLineDevices,
                                                    pEntry->m_dwPorts);
                    regkeyPptpProtocol.Close();
                    regkeyMachine.Close();
                }


                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp)
                {
                    //$L2TP
                    // We need to adjust the upper limit for the
                    // number of L2TP ports.
                    // ------------------------------------------------
                    if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                    {
                        DWORD   dwPorts;

                        //$L2TP
                        // Keep the value of the number of L2TP ports
                        // below the max.
                        // --------------------------------------------
                        if (m_fRestrictDialin)
                            dwPorts = MAX_ALLOWED_DIALIN;
                        else
                            dwPorts = min(pEntry->m_dwPorts, L2TP_MAX_PORTS);
                        pDevInfo->dwMaxWanEndPoints = dwPorts;
                    }
                }

                // Windows NT Bug : 136858 (add called id support)
                // Do we need to save the called id info?
                // --------------------------------------------------------
                if (pEntry->m_fSaveCalledIdInfo && pEntry->m_pCalledIdInfo)
                {
                    Assert(pEntry->m_fCalledIdInfoLoaded);
                    
                    //: if the call fails, what should we do? -- save it later
                    
                    hrTemp = RasSetCalledIdInfo(hConnection,
                                                pDevInfo,
                                                pEntry->m_pCalledIdInfo,
                                                TRUE);

                    // We've saved it, we don't need to save it again
                    // unless it changes.
                    // ----------------------------------------------------
                    if (FHrSucceeded(hrTemp))
                        pEntry->m_fSaveCalledIdInfo = FALSE;
                }
            }

            dwErr = RasSetDeviceConfigInfo(hConnection,
                                           cDevices,
                                           sizeof(RAS_DEVICE_INFO)*cDevices,
                                           pbData);
        }                                       
        else
        {
            RAS_DEVICE_INFO_V500 *pDevInfo500 = (RAS_DEVICE_INFO_V500 *) pbData;
            
            for (i=0; i<cDevices; i++, pDevInfo500++)
            {
                Assert(pos);

                pEntry = pList->GetNext(pos);

                // Get the information needed to calculate the number
                // of ports
                // --------------------------------------------------------
                // *pDevInfo = pEntry->m_RasDeviceInfo;
                memcpy(pDevInfo500, &pEntry->m_RasDeviceInfo,
                        FIELD_OFFSET(RAS_DEVICE_INFO, fRouterOutboundEnabled));
                memcpy(&pDevInfo500->dwTapiLineId, 
                       &pEntry->m_RasDeviceInfo.dwTapiLineId,
                       sizeof(RAS_DEVICE_INFO)
                       - FIELD_OFFSET(RAS_DEVICE_INFO, dwTapiLineId));

                pDevInfo500->fWrite = TRUE;
                pDevInfo500->fRasEnabled = pEntry->m_dwEnableRas;
                pDevInfo500->fRouterEnabled = pEntry->m_dwEnableRouting;
                pDevInfo500->dwNumEndPoints = pEntry->m_dwPorts;
                pDevInfo500->dwMaxWanEndPoints = pEntry->m_dwMaxPorts;

                // Windows NT Bug : 168364
                // From RaoS, I also need to set the maximum incoming/outging
                // --------------------------------------------------------

                // Windows NT Bug : ?
                // Use the defaults for now,
                // This will get removed later.
                // --------------------------------------------------------
                pDevInfo500->dwMaxInCalls = (-1);
                pDevInfo500->dwMaxOutCalls = 3;
                

                // if this is for PPTP, then we need to special case the
                // code to set the PPTP number of devices
                // --------------------------------------------------------
                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp)
                {
                    //$PPTP
                    // We need to adjust the upper limit for the
                    // number of PPTP ports.
                    // ------------------------------------------------
                    if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                    {
                        DWORD   dwPorts;

                        //$PPTP
                        // Keep the value of the number of PPTP ports
                        // below the max.
                        // --------------------------------------------
                        dwPorts = min(pEntry->m_dwPorts, PPTP_MAX_PORTS);
                        pDevInfo500->dwMaxWanEndPoints = dwPorts;
                    }
                    
                    RegKey        regkeyMachine;
                    RegKey        regkeyPptpProtocol;
                    HKEY        hkeyMachine;
                    
                    // Connect to the machine
                    dwErr = ConnectRegistry(m_stMachine, &hkeyMachine);
                    regkeyMachine.Attach(hkeyMachine);

                    // Open the PPTP registry key
                    dwErr = regkeyPptpProtocol.Open(regkeyMachine,
                                                    c_szRegKeyPptpProtocolParam);
                    
                    // set the NumberLineDevices registry value
                    if (dwErr == ERROR_SUCCESS)
                        regkeyPptpProtocol.SetValue(c_szRegValNumberLineDevices,
                                                    pEntry->m_dwPorts);
                    regkeyPptpProtocol.Close();
                    regkeyMachine.Close();
                }


                if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp)
                {
                    //$L2TP
                    // We need to adjust the upper limit for the
                    // number of L2TP ports.
                    // ------------------------------------------------
                    if (pEntry->m_dwPorts > pEntry->m_dwMaxPorts)
                    {
                        DWORD   dwPorts;

                        //$L2TP
                        // Keep the value of the number of L2TP ports
                        // below the max.
                        // --------------------------------------------
                        dwPorts = min(pEntry->m_dwPorts, L2TP_MAX_PORTS);
                        pDevInfo500->dwMaxWanEndPoints = dwPorts;
                    }
                }

                // Windows NT Bug : 136858 (add called id support)
                // Do we need to save the called id info?
                // --------------------------------------------------------
                if (pEntry->m_fSaveCalledIdInfo && pEntry->m_pCalledIdInfo)
                {
                    Assert(pEntry->m_fCalledIdInfoLoaded);
                    
                    //: if the call fails, what should we do? -- save it later
                    
                    hrTemp = RasSetCalledIdInfo(hConnection,
                                                (RAS_DEVICE_INFO *) pDevInfo500,
                                                pEntry->m_pCalledIdInfo,
                                                TRUE);

                    // We've saved it, we don't need to save it again
                    // unless it changes.
                    // ----------------------------------------------------
                    if (FHrSucceeded(hrTemp))
                        pEntry->m_fSaveCalledIdInfo = FALSE;
                }
            }

            dwErr = RasSetDeviceConfigInfo(hConnection,
                                           cDevices,
                                           sizeof(RAS_DEVICE_INFO_V500)*cDevices,
                                           pbData);
        
        }
        if (dwErr != ERROR_SUCCESS)
        {
            CString stErr;
            CString stErrCode;
            BOOL    fErr = FALSE;
            if(dwVersion == VERSION_501)
            {
                RAS_DEVICE_INFO *    pDevice;
                
                // Need to grab the error information out of the
                // info struct an set the error strings.

                // Could not save the information for the following
                // devices
                pDevice = (RAS_DEVICE_INFO *) pbData;

                stErr.LoadString(IDS_ERR_SETDEVICECONFIGINFO_GEEK);
                for (i=0; i<cDevices; i++, pDevice++)
                {
                    if (pDevice->dwError)
                    {
                        CString stErrString;

                        FormatError(HRESULT_FROM_WIN32(pDevice->dwError),
                                    szErr, DimensionOf(szErr));
                                    
                        stErrCode.Format(_T("%s (%08lx)"), szErr,
                                         pDevice->dwError);
                        stErr += _T(" ");
                        stErr += pDevice->szDeviceName;
                        stErr += _T(" ");
                        stErr += stErrCode;
                        stErr += _T("\n");

                        fErr = TRUE;
                    }
                }
            }
            else
            {
                RAS_DEVICE_INFO_V500 *    pDevice;
                
                // Need to grab the error information out of the
                // info struct an set the error strings.

                // Could not save the information for the following
                // devices
                pDevice = (RAS_DEVICE_INFO_V500 *) pbData;

                stErr.LoadString(IDS_ERR_SETDEVICECONFIGINFO_GEEK);
                for (i=0; i<cDevices; i++, pDevice++)
                {
                    if (pDevice->dwError)
                    {
                        CString stErrString;

                        FormatError(HRESULT_FROM_WIN32(pDevice->dwError),
                                    szErr, DimensionOf(szErr));
                                    
                        stErrCode.Format(_T("%s (%08lx)"), szErr,
                                         pDevice->dwError);
                        stErr += _T(" ");
                        stErr += pDevice->szDeviceName;
                        stErr += _T(" ");
                        stErr += stErrCode;
                        stErr += _T("\n");

                        fErr = TRUE;
                    }
                }
            
            }

            if (fErr)
                AddGeekLevelErrorString(stErr);
            
            
            CWRg(dwErr);
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    delete [] pbData;
        
    if (hConnection)
        RasRpcDisconnectServer(hConnection);
    return hr;
}

/*!--------------------------------------------------------------------------
    IsMaxDialinPortsRestricted
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDataEntry::CheckForDialinRestriction()
{
    DWORD       dwMajor, dwMinor, dwErr;
    HRESULT     hr = hrOK;
    RegKey      regkeyProduct;
    CString     stProductType, stSuite;
    CStringList stlProductSuite;
    
    
    COM_PROTECT_TRY
    {
        dwErr = GetNTVersion(m_regkeyMachine, &dwMajor, &dwMinor, NULL);

        if ( (dwErr == NO_ERROR) &&
             ( (dwMajor > 5) ||
               ((dwMajor == 5) && (dwMinor > 1)) ) )
              
        {
            CWRg( regkeyProduct.Open(
                    m_regkeyMachine, c_szRegKeyProductOptions, KEY_READ
                    ));

            CWRg( regkeyProduct.QueryValue(c_szRegValProductType, stProductType) );

            if (stProductType.Compare(c_szServerNT) == 0)
            {
                //
                // ok, this is a server box
                //

                CWRg( regkeyProduct.QueryValue(
                        c_szRegValProductSuite, stlProductSuite
                        ) );

                POSITION pos = stlProductSuite.GetHeadPosition();

                while( pos != NULL )
                {
                    stSuite = stlProductSuite.GetNext(pos);

                    if(( stSuite.Compare(c_szEnterprise) == 0) ||
                       ( stSuite.Compare(c_szDataCenter) == 0) ||
                       ( stSuite.Compare(c_szSecurityAppliance) == 0 ))
                    {
                        //
                        // This is either a DataCenter or Enterprise version
                        //
                        
                        m_fRestrictDialin = FALSE;
                    }
                }
            }
        }

        else
        {
            m_fRestrictDialin = FALSE;
        }
                
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*---------------------------------------------------------------------------
    PortsDeviceConfigDlg implementation
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(PortsDeviceConfigDlg, CBaseDialog)
    //{{AFX_MSG_MAP(PortsPageGeneral)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void PortsDeviceConfigDlg::DoDataExchange(CDataExchange *pDX)
{
    CBaseDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_DEVCFG_SPIN_PORTS, m_spinPorts);
}

void PortsDeviceConfigDlg::SetDevice(PortsDeviceEntry *pEntry, DWORD dwTotalActivePorts)
{
    Assert(pEntry);
    m_pEntry = pEntry;
    m_dwTotalActivePorts = dwTotalActivePorts;
}

BOOL PortsDeviceConfigDlg::OnInitDialog()
{
    HRESULT     hr;
    CString     stCalledIdInfo;
    CString     stDisplay;
    Assert(m_pEntry);
    
    CBaseDialog::OnInitDialog();

    if (RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_PPPoE)
    {
        CheckDlgButton(IDC_DEVCFG_BTN_RAS, FALSE);
        GetDlgItem(IDC_DEVCFG_BTN_RAS)->EnableWindow(FALSE);
        CheckDlgButton(IDC_DEVCFG_BTN_ROUTING, FALSE);
        GetDlgItem(IDC_DEVCFG_BTN_ROUTING)->EnableWindow(FALSE);
        CheckDlgButton(
            IDC_DEVCFG_BTN_OUTBOUND_ROUTING, 
            m_pEntry->m_dwEnableOutboundRouting
            );
    }
    else
    {
        CheckDlgButton(IDC_DEVCFG_BTN_RAS, m_pEntry->m_dwEnableRas);
        CheckDlgButton(IDC_DEVCFG_BTN_ROUTING, m_pEntry->m_dwEnableRouting);
        CheckDlgButton(IDC_DEVCFG_BTN_OUTBOUND_ROUTING, FALSE);
        GetDlgItem(IDC_DEVCFG_BTN_OUTBOUND_ROUTING)->EnableWindow(FALSE);
    }

    m_spinPorts.SetBuddy(GetDlgItem(IDC_DEVCFG_EDIT_PORTS));
    m_spinPorts.SetRange(m_pEntry->m_dwMinPorts, m_pEntry->m_dwMaxMaxPorts);
    m_spinPorts.SetPos(m_pEntry->m_dwPorts);

    // If we can edit/change the number of ports, set it up here
    // ----------------------------------------------------------------
    if (!m_pEntry->m_fWriteable || (m_pEntry->m_dwMinPorts == m_pEntry->m_dwMaxPorts))
    {
        GetDlgItem(IDC_DEVCFG_SPIN_PORTS)->EnableWindow(FALSE);
        GetDlgItem(IDC_DEVCFG_EDIT_PORTS)->EnableWindow(FALSE);
        GetDlgItem(IDC_DEVCFG_TEXT_PORTS)->EnableWindow(FALSE);
        GetDlgItem(IDC_DEVCFG_TEXT)->EnableWindow(FALSE);        
    }

    // Windows NT Bug : 136858 - Get the called id info
    // ----------------------------------------------------------------
    LoadCalledIdInfo();

    // Get the called id info, format it into a string and add it to
    // the display
    // ----------------------------------------------------------------
    CalledIdInfoToString(&stCalledIdInfo);

    GetDlgItem(IDC_DEVCFG_EDIT_CALLEDID)->SetWindowText(stCalledIdInfo);
    ((CEdit *)GetDlgItem(IDC_DEVCFG_EDIT_CALLEDID))->SetModify(FALSE);
    if ((RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_Parallel) ||
        (RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_PPPoE)){
	        GetDlgItem(IDC_DEVCFG_EDIT_CALLEDID)->EnableWindow(FALSE);
               GetDlgItem(IDC_DEVCFG_TEXT_CALLEDID)->EnableWindow(FALSE);
    	}


    // Set the window title to include the display name of the adapter
    // ----------------------------------------------------------------
    stDisplay.Format(IDS_TITLE_CONFIGURE_PORTS,
                     (LPCTSTR) m_pEntry->m_stDisplayName);
    SetWindowText(stDisplay);

    return TRUE;
}


/*!--------------------------------------------------------------------------
    PortsDeviceConfigDlg::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsDeviceConfigDlg::OnOK()
{
    BOOL    fChanged = FALSE;
    BOOL    fReboot = FALSE;
    DWORD   dwNewEnableRas, dwNewEnableRouting, 
            dwNewEnableOutboundRouting, dwNewPorts;
    
    // Check to see if the values changed
    dwNewEnableRas = (IsDlgButtonChecked(IDC_DEVCFG_BTN_RAS) != 0);
    dwNewEnableRouting = (IsDlgButtonChecked(IDC_DEVCFG_BTN_ROUTING) != 0);
    dwNewEnableOutboundRouting = 
        (IsDlgButtonChecked(IDC_DEVCFG_BTN_OUTBOUND_ROUTING) != 0);
    
    dwNewPorts = m_spinPorts.GetPos();

    // Make sure that we have a valid size
    // ----------------------------------------------------------------
    if ((dwNewPorts < m_pEntry->m_dwMinPorts) ||
        (dwNewPorts > m_pEntry->m_dwMaxMaxPorts))
    {
        CString st;
        st.Format(IDS_ERR_PORTS_BOGUS_SIZE, m_pEntry->m_dwMinPorts,
                  m_pEntry->m_dwMaxMaxPorts);
        AfxMessageBox(st);
        return;
    }

    // Windows NT Bug : 174803
    // We do not allow the user to change the number of PPTP ports down
    // to 0.
    // ----------------------------------------------------------------
    if ((RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_Tunnel_Pptp) &&
        (dwNewPorts == 0))
    {
        AfxMessageBox(IDS_ERR_PPTP_PORTS_EQUAL_ZERO);
        return;
    }

    // Windows NT Bugs : 165862
    // If we are changing the number of ports for PPTP
    // then we need to warn the user (since PPTP is not yet
    // fully PnP (4/23/98).
    //
    //$PPTP
    // For PPTP, if the value of m_dwPorts exceeds the value of
    // m_dwMaxPorts, then we have to reboot (we also need to adjust
    // the appropriate registry entries).
    // ----------------------------------------------------------------
    if ((dwNewPorts > m_pEntry->m_dwMaxPorts) &&
        (RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_Tunnel_Pptp))
    {
        // If we have a page, then we can do a reboot, otherwise we
        // are in the wizard and can't do a reboot at this point.
        // ------------------------------------------------------------
        if (m_pageGeneral)
        {
            // The user chose Yes indicating that he wants to be prompted to
            // reboot, so set this flag to trigger a reboot request.
            // --------------------------------------------------------
            if (AfxMessageBox(IDS_WRN_PPTP_NUMPORTS_CHANGING, MB_YESNO) == IDYES)
            {
                fReboot = TRUE;
            }
        }
        else
            AfxMessageBox(IDS_WRN_PPTP_NUMPORTS_CHANGING2, MB_OK);
    }

    //$L2TP
    // For L2TP, if the value of m_dwPorts exceeds the value of
    // m_dwMaxPorts, then we have to reboot (we also need to adjust
    // the appropriate registry entries).
    // ----------------------------------------------------------------
    if ((dwNewPorts > m_pEntry->m_dwMaxPorts) &&
        (RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_Tunnel_L2tp))
    {
        // If we have a page, then we can do a reboot, otherwise we
        // are in the wizard and can't do a reboot at this point.
        // ------------------------------------------------------------
        if (m_pageGeneral)
        {
            // The user chose Yes indicating that he wants to be prompted to
            // reboot, so set this flag to trigger a reboot request.
            // --------------------------------------------------------
            if (AfxMessageBox(IDS_WRN_L2TP_NUMPORTS_CHANGING, MB_YESNO) == IDYES)
            {
                fReboot = TRUE;
            }
        }
        else
            AfxMessageBox(IDS_WRN_L2TP_NUMPORTS_CHANGING2, MB_OK);
    }

    if ((dwNewEnableRas != m_pEntry->m_dwEnableRas) ||
        (dwNewEnableRouting != m_pEntry->m_dwEnableRouting) ||
        (dwNewEnableOutboundRouting != 
            m_pEntry->m_dwEnableOutboundRouting) ||
        (dwNewPorts != m_pEntry->m_dwPorts))
    {
        // warning user -- client could be disconnected  -- BUG 165862
        // when disable router / ras
        // decreasing the number of ports
        // ras
        if(!dwNewEnableRas &&
           m_pEntry->m_dwEnableRas &&
           m_dwTotalActivePorts > 0 &&
           AfxMessageBox(IDS_WRN_PORTS_DISABLERAS, MB_YESNO | MB_DEFBUTTON2) == IDNO)
            goto L_RESTORE;
        
        // routing
        if (((!dwNewEnableRouting &&
             m_pEntry->m_dwEnableRouting) ||
            (!dwNewEnableOutboundRouting &&
             m_pEntry->m_dwEnableOutboundRouting)) &&
             m_dwTotalActivePorts > 0    &&
            AfxMessageBox(IDS_WRN_PORTS_DISABLEROUTING, MB_YESNO | MB_DEFBUTTON2) == IDNO)
            goto L_RESTORE;

            
        // Bug 263958
        //ports --  We cannot count the number of outgoing connection remotely.
        // Therefore if we reduce the number of port, give warning without counting total
        // active connections.
        if(dwNewPorts < m_pEntry->m_dwPorts &&
           AfxMessageBox(IDS_WRN_PORTS_DECREASE, MB_YESNO | MB_DEFBUTTON2) == IDNO)
            goto L_RESTORE;

        m_pEntry->m_dwEnableRas = dwNewEnableRas;
        m_pEntry->m_dwEnableRouting = dwNewEnableRouting;
        m_pEntry->m_dwEnableOutboundRouting = 
            dwNewEnableOutboundRouting;
        m_pEntry->m_dwPorts = dwNewPorts;
        m_pEntry->m_fModified = TRUE;
    }

    // Get the called id info string (if the field changed)
    // ----------------------------------------------------------------
    if (((CEdit *) GetDlgItem(IDC_DEVCFG_EDIT_CALLEDID))->GetModify())
    {
        CString st;
        GetDlgItem(IDC_DEVCFG_EDIT_CALLEDID)->GetWindowText(st);

        StringToCalledIdInfo((LPCTSTR) st);

        // Now set the changed state on the structure
        // We need to save this data back to the registry
        // ------------------------------------------------------------
        m_pEntry->m_fSaveCalledIdInfo = TRUE;
    }
    
    CBaseDialog::OnOK();
 
    if(fReboot == TRUE)
    {
        Assert(m_pageGeneral);
        
        // force an OnApply to save data before shut down
        // ------------------------------------------------------------
        if (m_pageGeneral->OnApply()) {
           WCHAR szComputer[MAX_COMPUTERNAME_LENGTH + 1];
           DWORD dwLength = MAX_COMPUTERNAME_LENGTH;

           GetComputerName(szComputer, &dwLength );
           if (lstrcmpi(szComputer, (LPTSTR)m_pageGeneral->m_spRouter->GetMachineName())) 
           {
               ::RestartComputer((LPTSTR)m_pageGeneral->m_spRouter->GetMachineName());
           }
           else
               ::RestartComputer((LPTSTR)NULL);
        }
    }

    return;
    
L_RESTORE:
    if (RAS_DEVICE_TYPE(m_pEntry->m_eDeviceType) == RDT_PPPoE)
    {
        CheckDlgButton(
            IDC_DEVCFG_BTN_OUTBOUND_ROUTING, 
            m_pEntry->m_dwEnableOutboundRouting
            );
    }

    else
    {
        CheckDlgButton(IDC_DEVCFG_BTN_RAS, m_pEntry->m_dwEnableRas);
        CheckDlgButton(IDC_DEVCFG_BTN_ROUTING, m_pEntry->m_dwEnableRouting);
    }

    m_spinPorts.SetPos(m_pEntry->m_dwPorts);

    return;
}


/*!--------------------------------------------------------------------------
    PortsDeviceConfigDlg::LoadCalledIdInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDeviceConfigDlg::LoadCalledIdInfo()
{
    HRESULT hr = hrOK;
    
    if (!m_pEntry->m_fCalledIdInfoLoaded)
    {
        // Read the data from the registry
        // ------------------------------------------------------------
        if (m_pEntry->m_fRegistry)
        {
            DWORD    dwType;
            DWORD    dwSize;
            LPBYTE    pbData = NULL;
            DWORD    dwErr;
            RegKey    regkeyDevice;
            
            regkeyDevice.Attach(m_pEntry->m_hKey);

            dwErr = regkeyDevice.QueryValueExplicit(c_szRegValCalledIdInformation,
                &dwType,
                &dwSize,
                &pbData);

            hr = HRESULT_FROM_WIN32(dwErr);

            if ((dwErr == ERROR_SUCCESS) &&
                (dwType == REG_MULTI_SZ))
            {
                // Allocate space for a new called id structure
                // ----------------------------------------------------
                delete (BYTE *) m_pEntry->m_pCalledIdInfo;
                hr = AllocateCalledId(dwSize, &(m_pEntry->m_pCalledIdInfo));

                if (FHrSucceeded(hr))
                {
                    memcpy(m_pEntry->m_pCalledIdInfo->bCalledId,
                           pbData,
                           dwSize);
                }

            }
            
            delete pbData;
            
            regkeyDevice.Detach();
        }
        else
        {
            HANDLE    hConnection = NULL;
            DWORD    dwSize = 0;
            DWORD    dwErr;
                                  
            // use Rao's API
            
            // Connect to the server
            // --------------------------------------------------------
            dwErr = RasRpcConnectServer((LPTSTR) (LPCTSTR)m_stMachine,
                                        &hConnection);

            // Call it once to get the size information
            // --------------------------------------------------------
            if (dwErr == ERROR_SUCCESS)
                dwErr = RasGetCalledIdInfo(hConnection,
                                           &m_pEntry->m_RasDeviceInfo,
                                           &dwSize,
                                           NULL);
            hr = HRESULT_FROM_WIN32(dwErr);

            if ((dwErr == ERROR_BUFFER_TOO_SMALL) ||
                (dwErr == ERROR_SUCCESS))
            {
                // Allocate space for a new called id structure
                // ----------------------------------------------------
                delete (BYTE *) m_pEntry->m_pCalledIdInfo;
                AllocateCalledId(dwSize, &(m_pEntry->m_pCalledIdInfo));

                dwErr = RasGetCalledIdInfo(hConnection,
                                           &m_pEntry->m_RasDeviceInfo,
                                           &dwSize,
                                           m_pEntry->m_pCalledIdInfo
                                          );
                hr = HRESULT_FROM_WIN32(dwErr);
            }

            if (hConnection)
                RasRpcDisconnectServer(hConnection);
        }

        // Set the status flags, depending on whether the operation
        // succeeded or not
        // ------------------------------------------------------------

        // We always set the save value to FALSE after we have read
        // something in (or tried to read something in).
        // ------------------------------------------------------------
        m_pEntry->m_fSaveCalledIdInfo = FALSE;

        // We always set the load value to TRUE (we have tried to load
        // the information but it failed, for example the registry
        // key may not exist).
        // ------------------------------------------------------------
        m_pEntry->m_fCalledIdInfoLoaded = TRUE;
        
        if (!FHrSucceeded(hr))
        {
            delete m_pEntry->m_pCalledIdInfo;
            m_pEntry->m_pCalledIdInfo = NULL;
        }
    }
//Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    PortsDeviceConfigDlg::AllocateCalledId
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDeviceConfigDlg::AllocateCalledId(DWORD dwSize,
                                               RAS_CALLEDID_INFO **ppCalledId)
{
    HRESULT     hr = hrOK;

    *ppCalledId = NULL;
    
    COM_PROTECT_TRY
    {
        *ppCalledId =
            (RAS_CALLEDID_INFO *) new BYTE[sizeof(RAS_CALLEDID_INFO) +
                                         dwSize];
        (*ppCalledId)->dwSize = dwSize;
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    PortsDeviceConfigDlg::CalledIdInfoToString
        Converts the data in the called id info structure into a
        semi-colon separated string.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDeviceConfigDlg::CalledIdInfoToString(CString *pst)
{
    WCHAR * pswz = NULL;
    HRESULT hr = hrOK;
    USES_CONVERSION;

    Assert(pst);
    Assert(m_pEntry);

    COM_PROTECT_TRY
    {
    
        pst->Empty();

        if (m_pEntry->m_pCalledIdInfo)
            pswz = (WCHAR *) (m_pEntry->m_pCalledIdInfo->bCalledId);

        if (pswz && *pswz)
        {
            *pst += W2T(pswz);

            // Skip over the terminating NULL
            // --------------------------------------------------------
            pswz += StrLenW(pswz)+1;
            
            while (*pswz)
            {
                *pst += _T("; ");
                *pst += W2T(pswz);
                
                // Skip over the terminating NULL
                // --------------------------------------------------------
                pswz += StrLenW(pswz)+1;
            }
        }
    }
    COM_PROTECT_CATCH;

    if (!FHrSucceeded(hr))
        pst->Empty();

    return hr;    
}

/*!--------------------------------------------------------------------------
    PortsDeviceConfigDlg::StringToCalledIdInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT PortsDeviceConfigDlg::StringToCalledIdInfo(LPCTSTR psz)
{
    DWORD    cchSize;
    WCHAR * pswzData = NULL;
    WCHAR * pswzCurrent;
    LPTSTR    pszBufferStart = NULL;
    LPTSTR    pszBuffer = NULL;
    RAS_CALLEDID_INFO * pCalledInfo = NULL;
    HRESULT hr = hrOK;
    CString stTemp;

    // We need to parse the string (look for separators)
    // ----------------------------------------------------------------

    COM_PROTECT_TRY
    {

        // Allocate some space for the called id info (it's just as long
        // as the string, maybe even somewhat smaller).
        // Allocate twice the space so that we are sure of getting
        // all of the NULL terminating characters
        // ------------------------------------------------------------
        pswzData = new WCHAR[2*(StrLen(psz)+1) + 1];
        pswzCurrent = pswzData;
        
        // Copy the string into a buffer
        // ------------------------------------------------------------
        pszBufferStart = StrDup(psz);
        pszBuffer = pszBufferStart;
        
        _tcstok(pszBuffer, _T(";"));
        
        while (pszBuffer && *pszBuffer)
        {
            // Trim the string (get rid of whitespace, before and after).
            // --------------------------------------------------------
            stTemp = pszBuffer;
            stTemp.TrimLeft();
            stTemp.TrimRight();
            
            if (!stTemp.IsEmpty())
            {
                StrCpyWFromT(pswzCurrent, (LPCTSTR) stTemp);
                pswzCurrent += stTemp.GetLength()+1;
            }
            
            pszBuffer = _tcstok(NULL, _T(";"));
        }
        
        // Add extra terminating NULL character (so that it conforms
        // to the REG_MULTI_SZ format).
        // ------------------------------------------------------------
        *pswzCurrent = 0;
        cchSize = pswzCurrent - pswzData + 1;
        
        // Allocate the real data structure
        // Allocate and copy into a temporary so that in case
        // of an exception, we don't lose the original data
        // ------------------------------------------------------------
        AllocateCalledId(cchSize*sizeof(WCHAR), &pCalledInfo);
        memcpy(pCalledInfo->bCalledId,
               pswzData,
               cchSize*sizeof(WCHAR));

        delete (BYTE *) m_pEntry->m_pCalledIdInfo;
        m_pEntry->m_pCalledIdInfo = pCalledInfo;

        // Set to NULL so that we don't delete our new pointer
        // on exit.
        // ------------------------------------------------------------
        pCalledInfo = NULL;
        
    }
    COM_PROTECT_CATCH;

    delete pszBufferStart;
    delete pswzData;
    
    delete pCalledInfo;
    
    return hr;
}



/*---------------------------------------------------------------------------
    PortsSimpleDeviceConfigDlg implementation
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(PortsSimpleDeviceConfigDlg, CBaseDialog)
    //{{AFX_MSG_MAP(PortsPageGeneral)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void PortsSimpleDeviceConfigDlg::DoDataExchange(CDataExchange *pDX)
{
    CBaseDialog::DoDataExchange(pDX);
}

BOOL PortsSimpleDeviceConfigDlg::OnInitDialog()
{
    HRESULT     hr;
    
    CBaseDialog::OnInitDialog();

    // If we are using the BIG dialog, then we need to disable
    // the unapplicable controls.
    if (GetDlgItem(IDC_DEVCFG_TEXT_CALLEDID))
    {
        MultiEnableWindow(GetSafeHwnd(),
                          FALSE,
                          IDC_DEVCFG_TEXT_CALLEDID,
                          IDC_DEVCFG_EDIT_CALLEDID,
                          IDC_DEVCFG_TEXT_PORTS,
                          IDC_DEVCFG_EDIT_PORTS,
                          IDC_DEVCFG_SPIN_PORTS,
                          IDC_DEVCFG_TEXT,
                          0);
    }

    CheckDlgButton(IDC_DEVCFG_BTN_RAS, m_dwEnableRas);
    CheckDlgButton(IDC_DEVCFG_BTN_ROUTING, m_dwEnableRouting);
    GetDlgItem(IDC_DEVCFG_BTN_OUTBOUND_ROUTING)->EnableWindow(FALSE);

    return TRUE;
}


/*!--------------------------------------------------------------------------
    PortsSimpleDeviceConfigDlg::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void PortsSimpleDeviceConfigDlg::OnOK()
{
    // Check to see if the values changed
    m_dwEnableRas = (IsDlgButtonChecked(IDC_DEVCFG_BTN_RAS) != 0);
    m_dwEnableRouting = (IsDlgButtonChecked(IDC_DEVCFG_BTN_ROUTING) != 0);

    CBaseDialog::OnOK(); 
    return;
}



/*---------------------------------------------------------------------------
    PortsDeviceEntry implementation
 ---------------------------------------------------------------------------*/

PortsDeviceEntry::PortsDeviceEntry()
    : m_hKey(NULL),
    m_fRegistry(FALSE),
    m_fSaveCalledIdInfo(FALSE),
    m_fCalledIdInfoLoaded(FALSE),
    m_pCalledIdInfo(NULL)
{
}


PortsDeviceEntry::~PortsDeviceEntry()
{
    delete (BYTE *) m_pCalledIdInfo;
    
    if (m_hKey)
        DisconnectRegistry(m_hKey);
    m_hKey = NULL;
}

BOOL
RestartComputer(LPTSTR szMachineName)

    /* Called if user chooses to shut down the computer.
    **
    ** Return false if failure, true otherwise
    */
{
   HANDLE             hToken;              /* handle to process token */
   TOKEN_PRIVILEGES  tkp;                  /* ptr. to token structure */
   BOOL              fResult;              /* system shutdown flag */
   CString             str;

   TRACE(L"RestartComputer");

   /* Enable the shutdown privilege */

   if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
      return FALSE;

   /* Get the LUID for shutdown privilege. */

   if (szMachineName)
       LookupPrivilegeValue(NULL, SE_REMOTE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
   else
       LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);


   tkp.PrivilegeCount = 1;    /* one privilege to set    */
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   /* Get shutdown privilege for this process. */

   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   /* Cannot test the return value of AdjustTokenPrivileges. */

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   str.LoadString(IDS_SHUTDOWN_WARNING);
   fResult = InitiateSystemShutdownEx(
                szMachineName,          // computer to shutdown
                str.GetBuffer(10),      // msg. to user
                20,                     // time out period - shut down right away
                FALSE,                  // forcibly close open apps
                TRUE,                   // Reboot after shutdown
                SHTDN_REASON_FLAG_PLANNED | 
                SHTDN_REASON_MAJOR_OPERATINGSYSTEM | 
                SHTDN_REASON_MINOR_RECONFIG
                );
 
   str.ReleaseBuffer();

   if (!fResult)
    {
        return FALSE;
    }
   if( !ExitWindowsEx(EWX_REBOOT, 0))
      return FALSE;

   /* Disable shutdown privilege. */

   tkp.Privileges[0].Attributes = 0;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   return TRUE;
}


/*!--------------------------------------------------------------------------
    OnConfigurePorts
        Returns TRUE if something has changed.    FALSE otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL OnConfigurePorts(LPCTSTR pszMachineName,
                      DWORD dwTotalActivePorts,
                      PortsPageGeneral *pPage,
                      CListCtrlEx *pListCtrl)
{
    BOOL    fChanged = FALSE;
    
    // Need to determine if multiple items are selected or not
    if (pListCtrl->GetSelectedCount() == 1)
    {    
        PortsDeviceConfigDlg    configdlg(pPage, pszMachineName);
        int                     iPos;
        PortsDeviceEntry *        pEntry;
        CString                 st;
        int                     iType;
        TCHAR                    szNumber[32];
        
        if ((iPos = pListCtrl->GetNextItem(-1, LVNI_SELECTED)) == -1)
            return FALSE;
        
        pEntry = (PortsDeviceEntry *) pListCtrl->GetItemData(iPos);
        
        // total number of active ports are passed over to dialog, so if user tries to reduce total number of port
        // below this total number, give a warning message
        configdlg.SetDevice(pEntry, dwTotalActivePorts);
        
        if (configdlg.DoModal() == IDOK)
        {
            // Get the values from pEntry and update the list control entry
            iType = (pEntry->m_dwEnableRas * 2) + 
                    (pEntry->m_dwEnableRouting ||
                     pEntry->m_dwEnableOutboundRouting);

            st = PortsDeviceTypeToCString(iType);
            pListCtrl->SetItemText(iPos, PORTS_COL_USAGE, (LPCTSTR) st);
            
            FormatNumber(pEntry->m_dwPorts, szNumber,
                         DimensionOf(szNumber), FALSE);
            pListCtrl->SetItemText(iPos, PORTS_COL_NUMBER, (LPCTSTR) szNumber);

            fChanged = TRUE;
        }
    }
    
    return fChanged;
}



/*---------------------------------------------------------------------------
    RasmanPortMap implementation
 ---------------------------------------------------------------------------*/

RasmanPortMap::~RasmanPortMap()
{
    m_map.RemoveAll();
}

HRESULT RasmanPortMap::Init(HANDLE hRasHandle,
                            RASMAN_PORT *pPort,
                            DWORD dwPorts)
{
    RASMAN_INFO     rasmaninfo;
    DWORD       i;
    DWORD       dwErr = NO_ERROR;
    HRESULT     hr = hrOK;

    if (pPort == NULL)
    {
        m_map.RemoveAll();
        return hr;
    }
    
    for (i=0; i<dwPorts; i++, pPort++)
    {
        // If the port is closed, there is no need
        // to go any further.  (No need to do an RPC for this).
        // ----------------------------------------------------
        if (pPort->P_Status == CLOSED)
            continue;
        
        dwErr = RasGetInfo(hRasHandle,
                           pPort->P_Handle,
                           &rasmaninfo);
        
        if (dwErr != ERROR_SUCCESS)
            continue;
        
        // If this is a dial-out port and in use
        // mark it as active
        // --------------------------------------------
        if ((rasmaninfo.RI_ConnState == CONNECTED) &&
            (pPort->P_ConfiguredUsage & (CALL_IN | CALL_ROUTER)) &&
            (rasmaninfo.RI_CurrentUsage & CALL_OUT))
        {
            // Ok, this is a candidate.  Add it to the list
            // ----------------------------------------
            WCHAR   swzPortName[MAX_PORT_NAME+1];

            StrnCpyWFromA(swzPortName,
                          pPort->P_PortName,
                          MAX_PORT_NAME);
            
            m_map.SetAt(swzPortName, pPort);
        }
    }

    return hr;
}

BOOL RasmanPortMap::FIsDialoutActive(LPCWSTR pswzPortName)
{
    LPVOID  pv;
    
    return m_map.Lookup(pswzPortName, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\portdlg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    portdlg.cpp
//
// History:
//  09/22/96    Abolade Gbadegesin  Created.
//
// Implementation of the port-status dialog.
//============================================================================


#include "stdafx.h"
#include "dialog.h"
#include "rtrutilp.h"
extern "C" {
#include "ras.h"
}

#include "portdlg.h"
#include "rtrstr.h"
#include "iface.h"
#include "ports.h"
#include "raserror.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//----------------------------------------------------------------------------
// Class:       CPortDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:    CPortDlg::CPortDlg
//
// Constructor: initialize the base-class and the dialog's data.
//----------------------------------------------------------------------------

CPortDlg::CPortDlg(
                   LPCTSTR pszServer,
                   HANDLE       hServer,
                   HANDLE      hPort,
                   ITFSNode*	pPortsNode,
                   CWnd*       pParent
                  ) : CBaseDialog (IDD_DDM_PORT, pParent),
                  m_stServer(pszServer)
{
    m_hServer = hServer;
    m_hPort = hPort;
    m_spPortsNode.Set(pPortsNode);

    m_bChanged = FALSE;
}


//----------------------------------------------------------------------------
// Function:    CPortDlg::DoDataExchange
//
// DDX handler.
//----------------------------------------------------------------------------

VOID
CPortDlg::DoDataExchange(
    CDataExchange*  pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_DP_COMBO_PORTLIST, m_comboPorts);
}



BEGIN_MESSAGE_MAP(CPortDlg, CBaseDialog)
    ON_COMMAND(IDC_DP_BTN_RESET, OnReset)
    ON_COMMAND(IDC_DP_BTN_HANGUP, OnHangUp)
    ON_COMMAND(IDC_DP_BTN_REFRESH, OnRefresh)
    ON_CBN_SELENDOK(IDC_DP_COMBO_PORTLIST, OnSelendokPortList)
END_MESSAGE_MAP()


BOOL
CPortDlg::OnInitDialog(
    ) {

    CBaseDialog::OnInitDialog();

    RefreshItem(m_hPort);

    return FALSE;
}



BOOL
CPortDlg::RefreshItem(
    HANDLE  hPort,
    BOOL    bDisconnected
    ) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    DWORD dwErr, dwTotal;
    DWORD rp0Count, rc0Count;
    BYTE* rp0Table, *rc0Table;
    BOOL  bChanged = FALSE;
    DWORD   rasmanCount = 0, dwSize;
    BYTE *  pRasmanPorts = NULL;
    HANDLE  hRasHandle = INVALID_HANDLE_VALUE;

    rp0Table = rc0Table = 0;

    do {
    
        //
        // Retrieve an array of ports
        // to be used to fill the combo-box
        //
    
        dwErr = ::MprAdminPortEnum(
					m_hServer,
//                    (RAS_SERVER_HANDLE)m_pRootNode->QueryDdmHandle(),
                    0,
                    INVALID_HANDLE_VALUE,
                    (BYTE**)&rp0Table,
                    (DWORD)-1,
                    &rp0Count,
                    &dwTotal,
                    NULL
                    );
    
        if (dwErr != NO_ERROR) { break; }

        // if the caller signals explicitely that the port was disconnected
        // alter at this point the structure returned my MprAdminPortEnum.
        // This is done because ::MprAdminPortDisconnect() is disconnecting synchronously 
        // the port, but does not update the internal data synchronously!
        if (bDisconnected)
        {
            INT         i;
            RAS_PORT_0* prp0;

            for (i = 0, prp0 = (RAS_PORT_0*)rp0Table; i < (INT)rp0Count; i++, prp0++)
            {
                if (prp0->hPort == hPort)
                {
                    prp0->dwPortCondition = RAS_PORT_DISCONNECTED;
                    prp0->hConnection = INVALID_HANDLE_VALUE;
                    break;
                }
            }

        }

        //
        // Retrieve an array of connections
        //

        dwErr = ::MprAdminConnectionEnum(
//                    (RAS_SERVER_HANDLE)m_pRootNode->QueryDdmHandle(),
					m_hServer,
                    0,
                    (BYTE**)&rc0Table,
                    (DWORD)-1,
                    &rc0Count,
                    &dwTotal,
                    NULL
                    );

        if (dwErr != NO_ERROR) { break; }

        //
        // Do the refresh of the display,
        // selecting the item specified by the caller.
        //
        bChanged = Refresh(rp0Table,
                           rp0Count,
                           rc0Table,
                           rc0Count,
                           hRasHandle,
                           pRasmanPorts,
                           rasmanCount,
                           hPort);
        dwErr = NO_ERROR;

    } while (FALSE);

    delete pRasmanPorts;

    if (hRasHandle != INVALID_HANDLE_VALUE)
        RasRpcDisconnectServer(hRasHandle);


    if (rc0Table) { ::MprAdminBufferFree(rc0Table); }
    if (rp0Table) { ::MprAdminBufferFree(rp0Table); }


    if (dwErr != NO_ERROR) {
		TCHAR	szText[1024];

		FormatSystemError(HRESULT_FROM_WIN32(dwErr),
						  szText, DimensionOf(szText),
						  IDS_ERR_INITDLGERROR, FSEFLAG_ANYMESSAGE);
        AfxMessageBox(szText);

        EndDialog(IDCANCEL);
    }

    return bChanged;
}



VOID
CPortDlg::OnHangUp(
    ) {

    INT     iSel;
    HANDLE  hPort;
    DWORD   dwErr;

    iSel = m_comboPorts.GetCurSel();

    if (iSel == CB_ERR) { return; }

    hPort = (HANDLE)m_comboPorts.GetItemData(iSel);

    dwErr = ::MprAdminPortDisconnect(
//        (RAS_SERVER_HANDLE)m_pRootNode->QueryDdmHandle(),
		m_hServer,
        hPort
        );

    m_bChanged |= RefreshItem(hPort, dwErr == NO_ERROR);
}



VOID
CPortDlg::OnReset(
    ) {

    INT iSel;
    HANDLE hPort;

    iSel = m_comboPorts.GetCurSel();

    if (iSel == CB_ERR) { return; }

    hPort = (HANDLE)m_comboPorts.GetItemData(iSel);

    ::MprAdminPortClearStats(
//        (RAS_SERVER_HANDLE)m_pRootNode->QueryDdmHandle(),
		m_hServer,
        hPort
        );

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}



VOID
CPortDlg::OnSelendokPortList(
    ) {

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}



VOID
CPortDlg::OnRefresh(
    ) {

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}


BOOL
CPortDlg::PortHasChanged(
    ITFSNode    *pPortsNode,
    RAS_PORT_0  *pRP0)
{	
    SPITFSNodeEnum	spEnum;
    SPITFSNode	    spChildNode;

    pPortsNode->GetEnum(&spEnum);

    for (;spEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
    {
	    InterfaceNodeData * pChildData;

	    pChildData = GET_INTERFACENODEDATA(spChildNode);
	    Assert(pChildData);

	    if (pChildData->m_rgData[PORTS_SI_PORT].m_ulData ==
		    (ULONG_PTR) pRP0->hPort)
	    {
            BOOL bChanged;
            bChanged = ((DWORD)pRP0->dwPortCondition != pChildData->m_rgData[PORTS_SI_STATUS].m_dwData);
            m_bChanged |= bChanged;
            return bChanged;
	    }
    }

    return FALSE;
}


BOOL
CPortDlg::Refresh(
                  BYTE*     rp0Table,
                  DWORD     rp0Count,
                  BYTE*     rc0Table,
                  DWORD     rc0Count,
                  HANDLE    hRasHandle,
                  BYTE *    pRasmanPorts,
                  DWORD     rasmanCount,
                  VOID*     pParam
    ) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    DWORD dwErr = ERROR_SUCCESS;
    CString sItem;
    RAS_PORT_0* prp0;
    RAS_PORT_1* prp1;
    RAS_CONNECTION_0* prc0;
    RAS_CONNECTION_1* prc1;
    INT i, j, iSel, count;
    HANDLE hPort, hPortSel = NULL, *pPortTable;
	TCHAR	szName[256];
	TCHAR	szNumber[32];
    BOOL    bChanged = FALSE;
    RasmanPortMap   portMap;

    hPortSel = (HANDLE)pParam;


    //
    // Fill an array of port-handles with the ports which are already
    // in the combobox.
    //

    count = m_comboPorts.GetCount();

    if (count) {

        pPortTable = new HANDLE[count];
    }

    for (i = 0; i < count; i++) {

        pPortTable[i] = (HANDLE)m_comboPorts.GetItemData(i);
    }



    // Windows NT Bug : 338611
    // To make this faster, we need to create a hash table of
    // the RasPortEnum data.  Note: this class relies on the
    // pbPorts being valid when calling any functions in the class.
    // ------------------------------------------------------------
    portMap.Init(hRasHandle, (RASMAN_PORT *) pRasmanPorts, rasmanCount);

    //
    // Refresh the combobox with port-names;
    // We do this in two passes, first adding the names of ports
    // which aren't already in the combobox,
    // and then removing the names of ports which aren't
    // in the table of ports ('rp0Table').
    //

    for (i = 0, prp0 = (RAS_PORT_0*)rp0Table; i < (INT)rp0Count; i++, prp0++) {

        //
        // See if port 'i' is already in the combobox.
        //

        for (j = 0; j < count; j++) {

            if (pPortTable[j] == prp0->hPort) { break; }
        }

        if (j < count) { continue; }

        
        // Check to see that this port isn't dialout active,
        // if so, we can ignore it
        // ------------------------------------------------------------
        if ( portMap.FIsDialoutActive(prp0->wszPortName) )
        {
            continue;
        }
        
        //
        // Port 'i' isn't already in the combobox, so add it.
        //
		FormatRasPortName((BYTE *) prp0, szName, DimensionOf(szName));
		sItem = szName;

        iSel = m_comboPorts.AddString(sItem);

        if (iSel >= 0) {

            m_comboPorts.SetItemData(iSel, (LONG_PTR)prp0->hPort);

            if (prp0->hPort == hPortSel) { m_comboPorts.SetCurSel(iSel); }

            bChanged = TRUE;
        }
    }

    if (count) { delete [] pPortTable; }


    //
    // Second stage: remove all ports which aren't in 'rp0Table'.
    // This is only necessary if there were any ports in the combobox before.
    //

    if (count > 0) {

        count = m_comboPorts.GetCount();

        for (i = 0; i < count; i++) {

            hPort = (HANDLE)m_comboPorts.GetItemData(i);

            //
            // See if the port is in 'rp0Table'.
            //

            for (j = 0, prp0 = (RAS_PORT_0*)rp0Table; j < (INT)rp0Count;
                 j++, prp0++) {

                if (prp0->hPort == hPort) { break; }
            }

            if (j < (INT)rp0Count) {

                if (prp0->hPort == hPortSel) { m_comboPorts.SetCurSel(i); }

                continue;
            }


            //
            // The port wasn't found in 'rp0Table',
            // so remove it from the combobox,
            // and adjust the enumeration indices.
            //

            m_comboPorts.DeleteString(i);
            --i; --count;

            bChanged = TRUE;
        }
    }

	// Clear out the address fields
	SetDlgItemText(IDC_DP_TEXT_IPADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_IPXADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_NBFADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_ATLKADDRESS, c_szEmpty);

	// Clear out the line bps field
	SetDlgItemText(IDC_DP_TEXT_LINEBPS, c_szEmpty);
    SetDlgItemText(IDC_DP_TEXT_DURATION, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_BYTESIN, c_szEmpty);	
	SetDlgItemText(IDC_DP_TEXT_BYTESOUT, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_TIMEOUT, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_ALIGNMENT, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_FRAMING, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_HWOVERRUN, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_BUFOVERRUN, c_szEmpty);
	SetDlgItemText(IDC_DP_TEXT_CRC, c_szEmpty);
			

    //
    // If there is no selection select the first item
    //

    if ((iSel = m_comboPorts.GetCurSel()) == CB_ERR) {

        iSel = m_comboPorts.SetCurSel(0);
    }

    if (iSel == CB_ERR) { return bChanged; }


    //
    // Update the display with information for the selected item
    //

    hPort = (HANDLE)m_comboPorts.GetItemData(iSel);

    for (i = 0, prp0 = (RAS_PORT_0*)rp0Table; i < (INT)rp0Count;
         i++, prp0++) {

        if (prp0->hPort == hPort) { break; }
    }

    if (i >= (INT)rp0Count) { return bChanged; }

    // if the ports are the same, check if the currently selected port did not change!
    if (!bChanged)
    {
        // check if the data returned here matches with the one handled by the console.
        // if it doesn't, set bChanged to TRUE, saying that something has changed.
        // subsequently, the caller will know to initiate a global refresh.
        bChanged = PortHasChanged(m_spPortsNode, prp0);
    }

    //
    // First update the RAS_PORT_0-based information
    //

    FormatDuration(prp0->dwConnectDuration, sItem, UNIT_SECONDS);
    SetDlgItemText(IDC_DP_TEXT_DURATION, sItem);


    //
    // Now if the port is connected, find its RAS_CONNECTION_0
    //

    prc0 = NULL;

    if (prp0->hConnection != INVALID_HANDLE_VALUE) {

        for (i = 0, prc0 = (RAS_CONNECTION_0*)rc0Table; i < (INT)rc0Count;
             i++, prc0++) {

            if (prc0->hConnection == prp0->hConnection) { break; }
        }

        if (i >= (INT)rc0Count) { prc0 = NULL; }
    }

	sItem = PortConditionToCString(prp0->dwPortCondition);

    if (!prc0) {

        //
        // The port is not connected; show only the port condition.
        //

        SetDlgItemText(IDC_DP_EDIT_CONDITION, sItem);
        if (GetFocus() == GetDlgItem(IDC_DP_BTN_HANGUP))
		{
            GetDlgItem(IDC_DP_BTN_RESET)->SetFocus();
        }

        GetDlgItem(IDC_DP_BTN_HANGUP)->EnableWindow(FALSE);		
    }
    else {

        CString sCondition;

        //
        // Show condition as "Port condition (Connection)".
        //

        sCondition.Format(TEXT("%s (%ls)"), sItem, prc0->wszInterfaceName);

        SetDlgItemText(IDC_DP_EDIT_CONDITION, sCondition);

        GetDlgItem(IDC_DP_BTN_HANGUP)->EnableWindow(TRUE);
    }


    do {
    
        //
        // Set the information in the dialog text-controls
        //

		// Windows NT Bug : 139866
		// if we are not authenticated, do not show this information
		if (prp0->dwPortCondition == RAS_PORT_AUTHENTICATED)
		{    
			//
			// Now retrieve the RAS_PORT_1 information for this port.
			//
			
			dwErr = ::MprAdminPortGetInfo(
										  m_hServer,
										  1,
										  prp0->hPort,
										  (BYTE**)&prp1
										 );
			
			if (dwErr != NO_ERROR) { break; }
    
    
			FormatNumber(prp1->dwLineSpeed, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_LINEBPS, szNumber);
			
			FormatNumber(prp1->dwBytesRcved, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_BYTESIN, szNumber);
			
			FormatNumber(prp1->dwBytesXmited, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_BYTESOUT, szNumber);
			
			FormatNumber(prp1->dwCrcErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_CRC, szNumber);
			
			FormatNumber(prp1->dwTimeoutErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_TIMEOUT, szNumber);
			
			FormatNumber(prp1->dwAlignmentErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_ALIGNMENT, szNumber);
			
			FormatNumber(prp1->dwFramingErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_FRAMING, szNumber);
			
			FormatNumber(prp1->dwHardwareOverrunErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_HWOVERRUN, szNumber);
			
			FormatNumber(prp1->dwBufferOverrunErr, szNumber, DimensionOf(szNumber), FALSE);
			SetDlgItemText(IDC_DP_TEXT_BUFOVERRUN, szNumber);

			
			::MprAdminBufferFree(prp1);
		}
    
    
    
        //
        // Finally, if the port is connected, retreive RAS_CONNECTION_1 info
        // and use it to fill the network-registration controls.
        //
		if (prp0->dwPortCondition != RAS_PORT_AUTHENTICATED)
			break;
    
//        if (prp0->hConnection == INVALID_HANDLE_VALUE) { break; }

        dwErr = ::MprAdminConnectionGetInfo(
//                    (RAS_SERVER_HANDLE)m_pRootNode->QueryDdmHandle(),
					m_hServer,
                    1,
                    prp0->hConnection,
                    (BYTE**)&prc1
                    );

        if (dwErr != NO_ERROR || !prc1) { break; }


        //
        // Fill in the network registration info for projected networks.
        //

        if (prc1->PppInfo.ip.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DP_TEXT_IPADDRESS, prc1->PppInfo.ip.wszRemoteAddress);
        }

        if (prc1->PppInfo.ipx.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DP_TEXT_IPXADDRESS, prc1->PppInfo.ipx.wszAddress);
        }

        if (prc1->PppInfo.nbf.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DP_TEXT_NBFADDRESS, prc1->PppInfo.nbf.wszWksta);
        }

		if (prc1->PppInfo.at.dwError == NO_ERROR)
		{
			SetDlgItemTextW(IDC_DP_TEXT_ATLKADDRESS,
							prc1->PppInfo.at.wszAddress);
		}

        ::MprAdminBufferFree(prc1);

    } while (FALSE);

    if (dwErr != NO_ERROR) {
		TCHAR	szText[1024];
		FormatSystemError(HRESULT_FROM_WIN32(dwErr),
						  szText, DimensionOf(szText),
						  IDS_ERR_INITDLGERROR, FSEFLAG_ANYMESSAGE);

        AfxMessageBox(szText);

        EndDialog(IDCANCEL);
    }

    return bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\portdlg.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    portdlg.h
//
// History:
//  09/21/96    Abolade Gbadegesin  Created.
//
// Contains declarations for the port-status dialog.
//============================================================================


#ifndef _PORTDLG_H_
#define _PORTDLG_H_


//----------------------------------------------------------------------------
// Class:   CPortDlg
//
// Controls the Port-status dialog for DDMADMIN.
//----------------------------------------------------------------------------

class CPortDlg : public CBaseDialog {

    public:

        CPortDlg(
                 LPCTSTR        pszServer,
                 HANDLE				hServer,
                 HANDLE              hPort,
                 ITFSNode*           pPortsNode = NULL,
                 CWnd*               pParent = NULL);

        BOOL
        PortHasChanged(
            ITFSNode            *pPortsNode,
            RAS_PORT_0          *pRP0);

        BOOL
        Refresh(
            BYTE*               rp0Table,
            DWORD               rp0Count,
            BYTE*               rc0Table,
            DWORD               rc0Count,
            HANDLE              hRasHandle,
            BYTE *              pRasmanPorts,
            DWORD               rasmanCount,
            VOID*               pParam  = NULL );

        CComboBox               m_comboPorts;
        BOOL                    m_bChanged;

    protected:
//		static DWORD			m_dwHelpMap[];

        virtual VOID	DoDataExchange(CDataExchange * pDX );

        virtual BOOL    OnInitDialog( );
        afx_msg VOID    OnHangUp( );
        afx_msg VOID    OnReset( );
        afx_msg VOID    OnSelendokPortList( );
        afx_msg VOID    OnRefresh( );

        BOOL	        RefreshItem(
                            HANDLE hPort,
                            BOOL bDisconnected = FALSE );

        CString                 m_stServer;
        RAS_SERVER_HANDLE		m_hServer;
        HANDLE                  m_hPort;
        SPITFSNode	            m_spPortsNode;

        DECLARE_MESSAGE_MAP()
};


#endif // _PORTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ports.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ports.h
        Interface administration
        
    FILE HISTORY:
        
*/

#ifndef _PORTS_H_
#define _PORTS_H_

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H_
#include "handlers.h"
#endif

#ifndef _ROUTER_H
#include "router.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"
#endif

#ifndef _RTRUTIL_H_
#include "rtrutil.h"
#endif

#ifndef _RTRSHEET_H_
#include "rtrsheet.h"
#endif

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _LISTCTRL_H_
#include "listctrl.h"
#endif

#include "rasdlg.h"

extern "C"
{
#ifndef _RASMAN_
#include "rasman.h"
#endif
};



// forward declarations
class RouterAdminConfigStream;
interface IRouterInfo;
struct ColumnData;
struct SPortsNodeMenu;
class PortsProperties;



/*---------------------------------------------------------------------------
    Struct:    PortsNodeData
    This is information related to the set of interfaces (not per-interface),
    this is intended for SHARED data.

    Put data in here that needs to be accessed by the child nodes.  All other
    private data should go in the handler.
 ---------------------------------------------------------------------------*/

struct PortsNodeData
{
    PortsNodeData();
    ~PortsNodeData();
#ifdef DEBUG
    char    m_szDebug[32];    // for iding structures
#endif

    static    HRESULT InitAdminNodeData(ITFSNode *pNode, RouterAdminConfigStream *pConfigStream);
    static    HRESULT    FreeAdminNodeData(ITFSNode *pNode);

    HRESULT LoadHandle(LPCTSTR pszMachineName);
    HANDLE  GetHandle();

    void    ReleaseHandles();
    
    CString             m_stMachineName;
    
protected:

    SPMprServerHandle    m_sphDdmHandle;
};

#define GET_PORTSNODEDATA(pNode) \
                        ((PortsNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_PORTSNODEDATA(pNode, pData) \
                        pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
    This is the list of columns available for the Interfaces node
        - Name, "COM1: USR Sportster Modem"
        - Device, "modem"
        - Comment, "stuff"
        - Status, "active"
 ---------------------------------------------------------------------------*/
enum
{
    PORTS_SI_NAME = 0,
    PORTS_SI_DEVICE = 1,
    PORTS_SI_USAGE = 2, 
    PORTS_SI_STATUS = 3,
    PORTS_SI_COMMENT = 4,

    PORTS_MAX_COLUMNS,

    // Entries after this are not visible to the user
    PORTS_SI_PORT = PORTS_MAX_COLUMNS,

    PORTS_SI_MAX,
};


/*---------------------------------------------------------------------------
    Struct:    PortsListEntry
 ---------------------------------------------------------------------------*/
struct PortsListEntry
{
    RAS_PORT_0        m_rp0;
    BOOL            m_fActiveDialOut;   // TRUE if used as a dial-out port

    // fix b32887 -- add more information to the result pane -- ras / routing enabled ports
    DWORD   m_dwEnableRas;              // = 1 if RAS is enabled on this device
    DWORD   m_dwEnableRouting;          // = 1 if Routing is enabled on this device
    DWORD   m_dwEnableOutboundRouting;  // = 1 if outbound Routing is 
                                        //      enabled on this device
};

typedef CList<PortsListEntry, PortsListEntry &> PortsList;



/*---------------------------------------------------------------------------
    Struct: PortsDeviceEntry

    Data kept by the property page on a per-device basis, rather than a
    per-port basis.
 ---------------------------------------------------------------------------*/
struct PortsDeviceEntry
{
    PortsDeviceEntry();
    ~PortsDeviceEntry();

    BOOL    m_fRegistry;    // TRUE if read in from the registry
    
    BOOL    m_fModified;    // TRUE if struct has been modifed, FALSE otherwise
    DWORD    m_dwPorts;        // Number of ports available
    DWORD    m_dwOldPorts;    // Number of ports avail. (old value)
    BOOL    m_fWriteable;    // Is the number of ports modifiable.
    DWORD    m_dwMinPorts;    // these values only matter if m_fWriteable is TRUE
    DWORD    m_dwMaxPorts;

    //$PPTP
    // This value is added explicitly for PPTP.  For PPTP the maximum
    // may be adjusted above the value of m_dwMaxPorts.  (In this case
    // we prompt for a reboot).  This is the maximum value that m_dwMaxPorts
    // may take.
    DWORD   m_dwMaxMaxPorts;
    
    HKEY    m_hKey;            // registry key for this device (if router is off)
    
    DWORD    m_dwEnableRas;        // = 1 if RAS is enabled on this device
    DWORD    m_dwEnableRouting;    // = 1 if Routing is enabled on this device
    DWORD   m_dwEnableOutboundRouting;  // = 1 if outbound only routing 
                                        // is enabled on this device.

    
    // from RAS_DEVICE_INFO - set for PPTP/L2TP only
    RASDEVICETYPE    m_eDeviceType;
                                    
    CString    m_stDisplayName;

    
    // We store a copy of this struct for the case where the router is live.
    // We copy the info here into the variables above which are used as
    // temporary storage.  When the user hits OK, we copy the information
    // back to the RAS_DEVICE_INFO structure and write that out.  (Thus we
    // only write over what we use).
    RAS_DEVICE_INFO    m_RasDeviceInfo;

    
    // Store a copy of the calledid info
    // This will get saved only when we exit out of the ports
    // property sheet.  It gets loaded only if needed.
    BOOL    m_fSaveCalledIdInfo;    // TRUE if it needs to be written back
    BOOL    m_fCalledIdInfoLoaded;    // TRUE if the data has been loaded

    RAS_CALLEDID_INFO *m_pCalledIdInfo;

};
typedef CList<PortsDeviceEntry *, PortsDeviceEntry *> PortsDeviceList;


/*---------------------------------------------------------------------------
    Class:    PortsDataEntry

    This class is used to abstract the data gathering.  There are two
    ways of getting the data, the first is through the registry (when the
    router is not running) and the second is go through the Ras APIs.
 ---------------------------------------------------------------------------*/
class PortsDataEntry
{
public:
    PortsDataEntry();
    ~PortsDataEntry();

    // Initializes the class for the machine.
    HRESULT    Initialize(LPCTSTR pszMachineName);
    HRESULT    CheckForDialinRestriction();
    // Loads the data into the PortsDeviceList.  If the router is
    // running then the Ras APIs will be used else we go through the
    // registry.
    HRESULT    LoadDevices(PortsDeviceList *pList);

    HRESULT    LoadDevicesFromRegistry(PortsDeviceList *pList);
    HRESULT LoadDevicesFromRouter(PortsDeviceList *pList);


    // Saves the data into the PortsDeviceList.  If the router is
    // running then the Ras APIs will be used else we go through the
    // registry.
    HRESULT    SaveDevices(PortsDeviceList *pList);

    HRESULT    SaveDevicesToRegistry(PortsDeviceList *pList);
    HRESULT    SaveDevicesToRouter(PortsDeviceList *pList);

    BOOL        m_fRestrictDialin;

protected:

    CString     m_stMachine;
    RegKey      m_regkeyMachine;

    BOOL        m_fReadFromRegistry;
    
};



/*---------------------------------------------------------------------------
    Class:    PortsNodeHandler

 ---------------------------------------------------------------------------*/
class PortsNodeHandler :
   public BaseContainerHandler
{
public:
    PortsNodeHandler(ITFSComponentData *pCompData);

    HRESULT    Init(IRouterInfo *pInfo, RouterAdminConfigStream *pConfigStream);

    // Override QI to handle embedded interface
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
    
    // Embedded interface to deal with refresh callbacks
    DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

    // base handler functionality we override
    OVERRIDE_NodeHandler_DestroyHandler();
    OVERRIDE_NodeHandler_GetString();
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCreateDataObject();

    OVERRIDE_ResultHandler_CompareItems();

    // override handler notifications
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseResultHandlerNotify_OnResultShow();

    // Initializes the node
    HRESULT ConstructNode(ITFSNode *pNode);

    // User-initiated commands

    // Helper function to add interfaces to the UI
    HRESULT AddPortsUserNode(ITFSNode *pParent, const PortsListEntry &PortsEntry);

    // Causes a sync action (synchronizes data not the structure)
    HRESULT SynchronizeNodeData(ITFSNode *pNode);
    HRESULT UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
    HRESULT RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
    HRESULT GenerateListOfPorts(ITFSNode *pNode, PortsList *pList);

    HRESULT    SetUserData(ITFSNode *pNode, const PortsListEntry& Ports);
    

    // Structure used to pass data to callbacks - used as a way of
    // avoiding recomputation
    struct SMenuData
    {
        ULONG                m_ulMenuId;
        SPITFSNode            m_spNode;
    };


    DWORD            GetActivePorts() { return m_dwActivePorts;};
    
protected:
    SPIDataObject    m_spDataObject;    // cachecd data object
    CString            m_stTitle;        // holds the title of the node
    LONG_PTR        m_ulConnId;        // notification id for router info
    LONG_PTR        m_ulRefreshConnId; // id for refresh notifications
    BOOL            m_bExpanded;    // is the node expanded?
    MMC_COOKIE        m_cookie;        // cookie for the node

    DWORD            m_dwActivePorts;    // number of active ports

    RouterAdminConfigStream *    m_pConfigStream;

};



/*---------------------------------------------------------------------------
    Class:    PortsUserHandler

 ---------------------------------------------------------------------------*/
class PortsUserHandler :
   public BaseRouterHandler
{
public:
    PortsUserHandler(ITFSComponentData *pCompData);
    ~PortsUserHandler()
            { DEBUG_DECREMENT_INSTANCE_COUNTER(PortsUserHandler); }
    
    HRESULT    Init(IRouterInfo *pInfo, ITFSNode *pParent);

    // Override QI to handle embedded interface
    DeclareIUnknownMembers(IMPL)
//    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
    OVERRIDE_ResultHandler_GetString();

    OVERRIDE_ResultHandler_HasPropertyPages();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnCreateDataObject();
    OVERRIDE_ResultHandler_DestroyResultHandler();

    OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk();
    
    // Initializes the node
    HRESULT ConstructNode(ITFSNode *pNode,
                          IInterfaceInfo *pIfInfo,
                          const PortsListEntry *pEntry);

    // Refresh the data for this node
    void RefreshInterface(MMC_COOKIE cookie);

public:
    // Structure used to pass data to callbacks - used as a way of
    // avoiding recomputation
    struct SMenuData
    {
        SPITFSNode            m_spNode;
    };

    static ULONG GetDisconnectMenuState(const SRouterNodeMenu *pMenuData,
                                        INT_PTR pUserData);


protected:
    CString            m_stTitle;    // holds the title of the node
    DWORD            m_ulConnId;
    PortsListEntry    m_entry;

    // It is assumed that this will be valid for the lifetime of this node!

    DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)    
};


/*---------------------------------------------------------------------------
    Class:    PortsPageGeneral

    This class handles the General page of the Ports sheet.
 ---------------------------------------------------------------------------*/
class PortsPageGeneral :
   public RtrPropertyPage
{
friend class PortsDeviceConfigDlg;
public:
    PortsPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
            : RtrPropertyPage(nIDTemplate, nIDCaption), m_bShowContent(TRUE)
    {};
    ~PortsPageGeneral();

    HRESULT    Init(PortsProperties * pIPPropSheet, IRouterInfo *pRouter);

protected:
    // Override the OnApply() so that we can grab our data from the
    // controls in the dialog.
    virtual BOOL OnApply();

    PortsProperties *        m_pPortsPropSheet;

    //{{AFX_VIRTUAL(PortsPageGeneral)
    protected:
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    //}}AFX_VIRTUAL

    //{{AFX_MSG(PortsPageGeneral)
    virtual BOOL    OnInitDialog();
    afx_msg void    OnConfigure();
    afx_msg    void    OnListDblClk(NMHDR *pNMHdr, LRESULT *);
    afx_msg    void    OnNotifyListItemChanged(NMHDR *, LRESULT *);
    //}}AFX_MSG

    // Use CListCtrlEx to get the checkboxes
    CListCtrlEx        m_listCtrl;

    SPIRouterInfo    m_spRouter;
    BOOL            m_bShowContent;    // only show content of the page on NT5 servers

    PortsDeviceList    m_deviceList;
    PortsDataEntry    m_deviceDataEntry;

    DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
    Class:    PortsProperties

    This is the property sheet support class for the properties page of
    the Ports node.
 ---------------------------------------------------------------------------*/

class PortsProperties :
    public RtrPropertySheet
{
public:
    PortsProperties(ITFSNode *pNode,
                        IComponentData *pComponentData,
                        ITFSComponentData *pTFSCompData,
                        LPCTSTR pszSheetName,
                        CWnd *pParent = NULL,
                        UINT iPage=0,
                        BOOL fScopePane = TRUE);
    ~PortsProperties();

    HRESULT    Init(IRouterInfo *pRouter, PortsNodeHandler* pPortNodeHandler);

    void    SetThreadInfo(DWORD dwThreadId);

    PortsNodeHandler*    m_pPortsNodeHandle;
    
protected:
    SPIRouterInfo            m_spRouter;
    PortsPageGeneral            m_pageGeneral;
    DWORD                m_dwThreadId;
};



/*---------------------------------------------------------------------------
    Class :    PortsDeviceConfigDlg
 ---------------------------------------------------------------------------*/
class PortsDeviceConfigDlg : public CBaseDialog
{
public:
    PortsDeviceConfigDlg(PortsPageGeneral *pageGeneral,
                         LPCTSTR pszMachine, 
                         CWnd *pParent = NULL)
            : CBaseDialog(PortsDeviceConfigDlg::IDD, pParent),
            m_pEntry(NULL) ,
            m_dwTotalActivePorts(0),
            m_pageGeneral(pageGeneral),
            m_stMachine(pszMachine)
        {};

    enum { IDD = IDD_PORTS_DEVICE_CONFIG };

    void    SetDevice(PortsDeviceEntry *pEntry, DWORD dwTotalActivePorts);

protected:
    // total number of active ports
    DWORD m_dwTotalActivePorts;
    virtual void DoDataExchange(CDataExchange *pDX);

    HRESULT    LoadCalledIdInfo();
    HRESULT    AllocateCalledId(DWORD dwSize, RAS_CALLEDID_INFO **ppCalledIdInfo);

    HRESULT    CalledIdInfoToString(CString *pst);
    HRESULT    StringToCalledIdInfo(LPCTSTR psz);

    CSpinButtonCtrl    m_spinPorts;

    PortsDeviceEntry *    m_pEntry;

    CString            m_stMachine;

    virtual BOOL    OnInitDialog();
    virtual void    OnOK();

    PortsPageGeneral *m_pageGeneral;
    DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
    Class :    PortsSimpleDeviceConfigDlg

    This is a simplified version of PortsDeviceConfigDlg.  We allow
    setting of the RAS/Routing flag only.
 ---------------------------------------------------------------------------*/
class PortsSimpleDeviceConfigDlg : public CBaseDialog
{
public:
    PortsSimpleDeviceConfigDlg(UINT uIDD = PortsSimpleDeviceConfigDlg::IDD,
                               CWnd *pParent = NULL)
            : CBaseDialog(uIDD, pParent),
            m_dwEnableRas(0), m_dwEnableRouting(0),
            m_dwEnableOutboundRouting(0)
        {};

    enum { IDD = IDD_PORTS_DEVICE_CONFIG };

    DWORD   m_dwEnableRas;
    DWORD   m_dwEnableRouting;
    DWORD   m_dwEnableOutboundRouting;
    

protected:
    virtual void DoDataExchange(CDataExchange *pDX);

    virtual BOOL    OnInitDialog();
    virtual void    OnOK();

    DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
    Utility functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    OnConfigurePorts
        This will bring up the ports dialog for the specified machine.
        
        The total number of active ports is used to determine if a
        warning should be displayed when we reduce the number of ports
        on a device.

        This returns TRUE if something has been changed (and the dirty
        flag should be set).  FALSE is returned if nothing has been
        changed.

        If pPage is NULL, then it is assumed that this function is NOT
        being called from the property page (and thus is being called from
        the wizard).  In the case that pPage is non-NULL, we will reboot
        the machine if the PPTP ports are changed.
        
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL OnConfigurePorts(LPCTSTR pszMachineName,
                      DWORD dwTotalActivePorts,
                      PortsPageGeneral *pPage,
                      CListCtrlEx *pListCtrl);

// List box columns (in the Ports General page), for the wizard and
// the properties.
// --------------------------------------------------------------------
#define PORTS_COL_DEVICE        (0)
#define PORTS_COL_USAGE         (1)
#define PORTS_COL_TYPE          (2)
#define PORTS_COL_NUMBER        (3)


// To make it easier to find the dialout ports, create a
// special case (with the port name as the hash key).
//
// Note: we store a pointer to the port in the CStringMapToPtr.
// We do not access this pointer (except in debug to verify that we
// actually found the right port).  If we do not think a port is
// dialout active, we do not add it to our list.
// --------------------------------------------------------------------

class RasmanPortMap
{
public:
    ~RasmanPortMap();
    
    HRESULT Init(HANDLE hRasHandle,
                 RASMAN_PORT *pPort,
                 DWORD dwEntries);

    BOOL FIsDialoutActive(LPCWSTR pswzPortName);


protected:

    CMapStringToPtr m_map;
};


#endif _PORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\radbal.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       radbal.cpp
//
//--------------------------------------------------------------------------

// **********************************************************************
// Load balancing code for RADIUS Servers.
// **********************************************************************
#include <stdafx.h>
#include <assert.h>

#include "radcfg.h"
//nclude "radclnt.h"
#include "radbal.h"

// ======================== CRadiusServers ==============================

CRadiusServers::CRadiusServers()
{
	m_pServerList		= NULL;
	m_pCurrentServer	= NULL;
    m_pDeletedServers   = NULL;
	m_dwUnique = 1;
	InitializeCriticalSection(&m_cs);
} // CRadiusServers()


// ========================= ~CRadiusServers =============================

CRadiusServers::~CRadiusServers()
{
	RADIUSSERVER *pServer;

	EnterCriticalSection(&m_cs);
		{ // free all items in linked list
		pServer = m_pServerList;
		while (pServer != NULL)
			{
			m_pServerList = pServer->pNext;

			// Ensure that the password is zeroed
			ZeroMemory(pServer, sizeof(*pServer));
			
			LocalFree(pServer);
			pServer = m_pServerList;
			}
		}
	LeaveCriticalSection(&m_cs);
	
	assert(m_pServerList == NULL);
	DeleteCriticalSection(&m_cs);
} // ~CRadiusServers()


// ========================= AddServer ==================================
// Adds a RADIUS server node into the linked list of avialable servers.
// INPUT:
//		pRadiusServer		- struct defining attributes for RADIUS server.
//		dwUnique			- insert before server with this dwUnique value
//							  dwUnique = 0, means add to head
//							  dwUnique = -1, means add to tail
// RETURN: 
//		ERROR_SUCCESS 		- Server Node added successfully
//		Win32 error code	- unsuccessfully in adding server node.
		
DWORD CRadiusServers::AddServer(RADIUSSERVER *pRadiusServer,
								LONG_PTR dwUnique)
{
	__try
		{
		RADIUSSERVER 	*pNewServer;
		RADIUSSERVER 	*pServer;
		RADIUSSERVER 	*pPrevServer;

		m_dwUnique++;
		
		assert(pRadiusServer != NULL);
		// Allocate space for node
		pNewServer = (RADIUSSERVER *) LocalAlloc(LPTR, sizeof(RADIUSSERVER));
		if (pNewServer == NULL)
			__leave;

		// Set the unqiue value (this will be used to index this server
		// by the UI).
		pRadiusServer->dwUnique = m_dwUnique;
		
		// Copy server data
		*pNewServer = *pRadiusServer;
		
		EnterCriticalSection(&m_cs);
			{
			// Find location to insert at
			if (dwUnique == 0)
			{
				pServer = m_pServerList;
				pPrevServer = NULL;
			}
			else
			{
				pServer = m_pServerList;
				pPrevServer = NULL;

				while (pServer)
				{
					if (pServer->dwUnique == (DWORD) dwUnique)
						break;

					pPrevServer = pServer;
					pServer = pServer->pNext;
				}
				
				// If not found, add to the head of the list
				if (!pServer)
				{
					pServer = m_pServerList;
					pPrevServer = NULL;
				}
			}
			
			// Add node to linked list
			if (pPrevServer)
				pPrevServer->pNext = pNewServer;

			if (pServer == m_pServerList)
			{
				Assert(!pPrevServer);
				m_pServerList = pNewServer;
			}
			
			pNewServer->pNext = pServer;
			}
		LeaveCriticalSection(&m_cs);
			
		SetLastError(ERROR_SUCCESS);
		} // __try

	__finally
		{
		} // __finally
		
	return (GetLastError());
} // AddServer()

// ========================= ValidateServer =================================
// Used to update the status of the RADIUS servers.
// All servers start with a score of MAXSCORE
// Every time a server responding the score is increased by INCSCORE to a max of MAXSCORE
// Every time a server fails to respond the score is decreased by DECSCORE to a min of MINSCORE
// Servers with the highest score are selected in a roundrobin method for servers with equal score
//
// INPUT:
//		fResponding		- Indicates if the server is responding or not
// OUTPUT:
//

VOID CRadiusServers::ValidateServer(RADIUSSERVER *pServer, BOOL fResponding)
{
	assert(pServer != NULL && (fResponding == TRUE || fResponding == FALSE));

	EnterCriticalSection(&m_cs);
		{
		// pNext point to to real pointer of this node in the linked list
		pServer = pServer->pNext;
		assert(pServer);
		
		if (fResponding)
			{
			pServer->cScore = min(MAXSCORE, pServer->cScore + INCSCORE);
			}
		else
			{
			pServer->cScore = max(MINSCORE, pServer->cScore - DECSCORE);
			}
		}
	LeaveCriticalSection(&m_cs);
} // ValidateServer()

// ======================== GetNextServer ======================================
// Used to cycle thru all the RADIUS servers.
// INPUT:
//		fFirst		- TRUE if u want to get the root node.
// OUTPUT:
//		pointer to next RADIUS server descriptor.

RADIUSSERVER *CRadiusServers::GetNextServer(BOOL fFirst)
{
	RADIUSSERVER 	*pServer = NULL;
	
	assert(fFirst == TRUE || fFirst == FALSE);
	
	EnterCriticalSection(&m_cs);
		{
		if (fFirst == TRUE)
			m_pCurrentServer = m_pServerList;
		else
			{
			assert(m_pCurrentServer);
			m_pCurrentServer = m_pCurrentServer->pNext;
			}

		// Increment unique packet id counter
		if (m_pCurrentServer != NULL)
			m_pCurrentServer->bIdentifier ++;
		
		pServer = m_pCurrentServer;
		}
	LeaveCriticalSection(&m_cs);	

	return (pServer);
} // GetNextServer()

VOID CRadiusServers::MoveServer(LONG_PTR dwUnique, BOOL fUp)
{
	RADIUSSERVER 	*pServerTemp = NULL;
	RADIUSSERVER 	*pServer;
	RADIUSSERVER 	*pPrevServer;
	RADIUSSERVER 	*pPrevPrevServer;

	Assert(dwUnique);

	if (m_pServerList == NULL)
		return;
	
	EnterCriticalSection(&m_cs);
	{
		if (m_pServerList->dwUnique == (DWORD) dwUnique)
		{
			pPrevPrevServer = NULL;
			pPrevServer = NULL;
			pServer = m_pServerList;
		}
		else
		{
			pPrevPrevServer = NULL;
			pPrevServer = m_pServerList;
			pServer = pPrevServer->pNext;

			while (pServer)
			{
				if (pServer->dwUnique == (DWORD) dwUnique)
					break;

				pPrevPrevServer = pPrevServer;
				pPrevServer = pServer;
				pServer = pServer->pNext;
			}
		}

		if (pServer)
		{
			if (fUp)
			{
				if (m_pServerList == pPrevServer)
					m_pServerList = pServer;
				
				if (pPrevServer)
					pPrevServer->pNext = pServer->pNext;
				
				pServer->pNext = pPrevServer;
				
				if (pPrevPrevServer)
					pPrevPrevServer->pNext = pServer;
			}
			else
			{
				if (pPrevServer)
					pPrevServer->pNext = pServer->pNext;
				if (pServer->pNext)
				{
					if (m_pServerList == pServer)
						m_pServerList = pServer->pNext;
					
					pServerTemp = pServer->pNext->pNext;
					pServer->pNext->pNext = pServer;
					pServer->pNext = pServerTemp;
				}
			}
		}
	}
	LeaveCriticalSection(&m_cs);
	
}


DWORD CRadiusServers::DeleteServer(LONG_PTR dwUnique, BOOL fRemoveLSAEntry)
{
	RADIUSSERVER *	pServer = m_pServerList;
	RADIUSSERVER *	pDeadServer;

	if (pServer == NULL)
		return 0;

	// check the first one
	if (pServer->dwUnique == (DWORD) dwUnique)
	{
		m_pServerList = pServer->pNext;

        if (fRemoveLSAEntry)
        {
            AddToDeletedServerList(pServer);
        }
        else
        {		
            // Ensure that the password is zeroed
            ZeroMemory(pServer, sizeof(*pServer));            
            LocalFree(pServer);
        }
		return 0;
	}

	for (pServer = m_pServerList; pServer->pNext; pServer=pServer->pNext)
	{
		if (pServer->pNext->dwUnique == (DWORD) dwUnique)
		{
			pDeadServer = pServer->pNext;
			pServer->pNext = pServer->pNext->pNext;

            if (fRemoveLSAEntry)
            {
                AddToDeletedServerList(pDeadServer);
            }
            else
            {                
                ZeroMemory(pDeadServer, sizeof(*pDeadServer));
                LocalFree(pDeadServer);
            }
			break;
		}
	}
	return 0;
}

/*!--------------------------------------------------------------------------
	CRadiusServers::AddToDeletedServerList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void CRadiusServers::AddToDeletedServerList(RADIUSSERVER *pServer)
{
    Assert(pServer);
    
    // Add this server to the head of our list
    pServer->pNext = m_pDeletedServers;
    m_pDeletedServers = pServer;
}

/*!--------------------------------------------------------------------------
	CRadiusServers::ClearDeletedServerList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void CRadiusServers::ClearDeletedServerList(LPCTSTR pszServerName)
{
    RADIUSSERVER *  pDeadServer;
    RADIUSSERVER *  pNextServer;
    
    // Remove the appropriate RADIUS servers from the LSA policy
    DeleteRadiusServers(pszServerName, GetFirstDeletedServer());

    // Clear out the server list
    for (pDeadServer=GetFirstDeletedServer();
         pDeadServer;
         )
    {
        pNextServer = pDeadServer->pNext;

        // Remove the entry from the list
		// Ensure that the password is zeroed
        ZeroMemory(pDeadServer, sizeof(*pDeadServer));
        LocalFree(pDeadServer);

        pDeadServer = pNextServer;
    }

    // ok, there is nothing left to point to
    m_pDeletedServers = NULL;
}


/*!--------------------------------------------------------------------------
	CRadiusServers::FreeAllServers
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void CRadiusServers::FreeAllServers()
{
    RADIUSSERVER *  pServer = NULL;
    RADIUSSERVER *  pNextServer = NULL;
    
    for (pServer = m_pServerList;
         pServer;
         )
    {
        pNextServer = pServer->pNext;

        ZeroMemory(pServer, sizeof(*pServer));
        LocalFree(pServer);

        pServer = pNextServer;
    }

    m_pServerList = NULL;
}

BOOL CRadiusServers::FindServer(DWORD dwUnique, RADIUSSERVER **ppServer)
{
    RADIUSSERVER *  pServer = m_pServerList;

    while (pServer)
    {
        if (pServer->dwUnique == dwUnique)
        {
            if (ppServer)
                *ppServer = pServer;
            return TRUE;
        }
        pServer = pServer->pNext;
    }
    return FALSE;
}

BOOL CRadiusServers::FindServer(LPCTSTR pszName, RADIUSSERVER **ppServer)
{
    RADIUSSERVER *  pServer = m_pServerList;

    while (pServer)
    {
        if (StrCmp(pServer->szName, pszName) == 0)
        {
            if (ppServer)
                *ppServer = pServer;
            return TRUE;
        }
        pServer = pServer->pNext;
    }
    return FALSE;
}



void RadiusServer::UseDefaults()
{
    szName[0] = 0;
    wszSecret[0] = 0;
    cchSecret = 0;

	Timeout.tv_sec = DEFTIMEOUT;
    cRetries = 0;
    cScore = MAXSCORE;
    
    AuthPort = DEFAUTHPORT;
	AcctPort = DEFACCTPORT;

    IPAddress.sin_family = AF_INET;
    IPAddress.sin_port = htons((SHORT) AuthPort);
    IPAddress.sin_addr.s_addr = 0;
    
	fAccountingOnOff = FALSE;
    bIdentifier = 0;
    lPacketID = 0;
    fUseDigitalSignatures = FALSE;

    fPersisted = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\qryfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       qryfrm.h
//
//--------------------------------------------------------------------------

// QryFrm.h : Declaration of the CRRASQueryForm

#ifndef __RRASQUERYFORM_H_
#define __RRASQUERYFORM_H_

#include "resource.h"       // main symbols
#include "dialog.h"         // CBaseDialog
#include "helper.h"

// attribute names
#define	ATTR_NAME_CN			L"cn"
#define	ATTR_NAME_DN			L"distinguishedName"
#define ATTR_NAME_OBJECTCLASS	L"objectClass"
#define	ATTR_NAME_RRASATTRIBUTE	L"msRRASAttribute"
#define	ATTR_NAME_RRASDICENTRY	L"msRRASVendorAttributeEntry"
#define	CN_ROUTERID				L"CN=RouterIdentity"
#define	DNPREFIX_ROUTERID		L"CN=RouterIdentity,CN="
#define	CN_DICTIONARY			L"cn=IdentityDictionary,cn=RRAS,cn=Services,"

// class names
#define	ATTR_CLASS_RRASID		L"RRASAdministrationConnectionPoint"
#define	ATTR_CLASS_RRASDIC		L"RRASAdministrationDictionary"
#define	ATTR_CLASS_COMPUTER		L"computer"

// special attribute values
#define	ATTR_VAL_VENDORID_MS	L"311"
#define	ATTR_VAL_LANtoLAN		L"311:6:601"
#define	ATTR_VAL_RAS			L"311:6:602"
#define	ATTR_VAL_DEMANDDIAL		L"311:6:603"
#define	ATTR_VAL_NAT			L"311:6:604"

class CQryDialog : public CBaseDialog
{
// Construction
public:
	CQryDialog(UINT nIDTemplate, CWnd* pParent) : CBaseDialog(nIDTemplate, pParent)	{	};

	virtual void	Init() PURE;
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams) PURE;
	virtual HRESULT ClearForm() {Init(); UpdateData(FALSE); return S_OK;};
	virtual HRESULT	Enable(BOOL bEnable) SAYOK;
	virtual HRESULT Persist(IPersistQuery* pPersistQuery, BOOL fRead) NOIMP;
};


/////////////////////////////////////////////////////////////////////////////
// CRRASQueryForm
class ATL_NO_VTABLE CRRASQueryForm : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRRASQueryForm, &CLSID_RRASQueryForm>,
	public IQueryForm
{
public:
	CRRASQueryForm()
	{
	}

DECLARE_REGISTRY(CRRASQueryForm,
				 _T("RouterDSQueryForm.RouterDSQueryForm.1"),
				 _T("RouterDSQueryForm.RouterDSQueryForm"),
				 IDS_QRY_TITLE_RRASQUERYFORM, THREADFLAGS_APARTMENT);

    // IQueryForm methods
    STDMETHOD(Initialize)(THIS_ HKEY hkForm);
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

BEGIN_COM_MAP(CRRASQueryForm)
	COM_INTERFACE_ENTRY(IQueryForm)
END_COM_MAP()

// IRRASQueryForm
public:
};

#define FILTER_PREFIX   TEXT("(")
#define FILTER_POSTFIX  TEXT(")")

typedef struct
{
    INT    fmt;
    INT    cx;
    UINT   idsName;
    LONG   iPropertyIndex;
    LPWSTR pPropertyName;
} COLUMNINFO, * LPCOLUMNINFO;

extern COLUMNINFO	RRASColumn[];
extern int			cRRASColumn;

HRESULT BuildQueryParams(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery);
HRESULT QueryParamsAlloc(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery, LONG iColumns, LPCOLUMNINFO aColumnInfo);
HRESULT QueryRRASAdminDictionary(VARIANT* pVar);
HRESULT GetGeneralPageAttributes(CStrArray& array);
HRESULT QueryParamsAddQueryString(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery);

#endif //__RRASQUERYFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\qryfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       qryfrm.cpp
//
//--------------------------------------------------------------------------

// QryFrm.cpp : Implementation of CRRASQueryForm
#include "stdafx.h"
#include <cmnquryp.h>
#include "QryFrm.h"
#include "dlggen.h"
#include "dlgadv.h"

COLUMNINFO	RRASColumn[] =
{
    {0, 40, IDS_QRY_COL_CN, 0, ATTR_NAME_DN},
    {0, 30, IDS_QRY_COL_OBJECTCLASS, 1, ATTR_NAME_OBJECTCLASS},
    {0, 30, IDS_QRY_COL_RRASATTRIBUTE, 2, ATTR_NAME_RRASATTRIBUTE},
};

int	cRRASColumn = 3;

/////////////////////////////////////////////////////////////////////////////
// CRRASQueryForm

//=========================================================================
// IQueryForm methods
HRESULT PageProc(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);

STDMETHODIMP CRRASQueryForm::Initialize(HKEY hkForm)
{
    // This method is called to initialize the query form object, it is called before
    // any pages are added.  hkForm should be ignored, in the future however it
    // will be a way to persist form state.

	HRESULT hr = S_OK;

	return hr;
}

STDMETHODIMP CRRASQueryForm::AddForms(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
    CQFORM cqf;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // This method is called to allow the form handler to register its query form(s),
    // each form is identifiered by a CLSID and registered via the pAddFormProc.  Here
    // we are going to register a test form.
    
    // When registering a form which is only applicable to a specific task, eg. Find a Domain
    // object, it is advised that the form be marked as hidden (CQFF_ISNEVERLISTED) which 
    // will cause it not to appear in the form picker control.  Then when the
    // client wants to use this form, they specify the form identifier and ask for the
    // picker control to be hidden. 

    if ( !pAddFormsProc )
        return E_INVALIDARG;

    cqf.cbStruct = sizeof(cqf);
    cqf.dwFlags = CQFF_NOGLOBALPAGES | CQFF_ISNEVERLISTED;
    cqf.clsid = CLSID_RRASQueryForm;
    cqf.hIcon = NULL;

	CString	title;
	title.LoadString(IDS_QRY_TITLE_RRASQUERYFORM);
    cqf.pszTitle = (LPCTSTR)title;

    return pAddFormsProc(lParam, &cqf);
}

STDMETHODIMP CRRASQueryForm::AddPages(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
	HRESULT hr = S_OK;
    CQPAGE cqp;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // AddPages is called after AddForms, it allows us to add the pages for the
    // forms we have registered.  Each page is presented on a seperate tab within
    // the dialog.  A form is a dialog with a DlgProc and a PageProc.  
    //
    // When registering a page the entire structure passed to the callback is copied, 
    // the amount of data to be copied is defined by the cbStruct field, therefore
    // a page implementation can grow this structure to store extra information.   When
    // the page dialog is constructed via CreateDialog the CQPAGE strucuture is passed
    // as the create param.

    if ( !pAddPagesProc )
        return E_INVALIDARG;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = PageProc;
    cqp.hInstance = _Module.m_hInst;
    cqp.idPageName = IDS_QRY_TITLE_GENERALPAGE;
    cqp.idPageTemplate = IDD_QRY_GENERAL;
    cqp.pDlgProc = DlgProc;
    cqp.lParam = (LPARAM)new CDlgGeneral();

    hr = pAddPagesProc(lParam, CLSID_RRASQueryForm, &cqp);

	if(hr != S_OK)
		return hr;

    cqp.dwFlags = 0x0;
    cqp.pPageProc = PageProc;
    cqp.hInstance = _Module.m_hInst;
    cqp.idPageName = IDS_QRY_TITLE_ADVANCEDPAGE;
    cqp.idPageTemplate = IDD_QRY_ADVANCED;
    cqp.pDlgProc = DlgProc;        
    cqp.lParam = (LPARAM)new CDlgAdvanced();

    return pAddPagesProc(lParam, CLSID_RRASQueryForm, &cqp);

}


/*---------------------------------------------------------------------------*/

// The PageProc is used to perform general house keeping and communicate between
// the frame and the page. 
//
// All un-handled, or unknown reasons should result in an E_NOIMPL response
// from the proc.  
//
// In:
//  pPage -> CQPAGE structure (copied from the original passed to pAddPagesProc)
//  hwnd = handle of the dialog for the page
//  uMsg, wParam, lParam = message parameters for this event
//
// Out:
//  HRESULT
//
// uMsg reasons:
// ------------
//  CQPM_INIIIALIZE
//  CQPM_RELEASE
//      These are issued as a result of the page being declared or freed, they 
//      allow the caller to AddRef, Release or perform basic initialization
//      of the form object.
//
// CQPM_ENABLE
//      Enable is when the query form needs to enable or disable the controls
//      on its page.  wParam contains TRUE/FALSE indicating the state that
//      is required.
//
// CQPM_GETPARAMETERS
//      To collect the parameters for the query each page on the active form 
//      receives this event.  lParam is an LPVOID* which is set to point to the
//      parameter block to pass to the handler, if the pointer is non-NULL 
//      on entry the form needs to appened its query information to it.  The
//      parameter block is handler specific. 
//
//      Returning S_FALSE from this event causes the query to be canceled.
//
// CQPM_CLEARFORM
//      When the page window is created for the first time, or the user clicks
//      the clear search the page receives a CQPM_CLEARFORM notification, at 
//      which point it needs to clear out the edit controls it has and
//      return to a default state.
//
// CQPM_PERSIST:
//      When loading of saving a query, each page is called with an IPersistQuery
//      interface which allows them to read or write the configuration information
//      to save or restore their state.  lParam is a pointer to the IPersistQuery object,
//      and wParam is TRUE/FALSE indicating read or write accordingly.

HRESULT PageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CQryDialog*	pDialog = (CQryDialog*)pQueryPage->lParam;

	ASSERT(pDialog);

    switch ( uMsg )
    {
        // Initialize so AddRef the object we are associated with so that
        // we don't get unloaded.
        case CQPM_INITIALIZE:
            break;

        // Changed from qform sample to detach the hwnd, and delete the CDialog
        // ensure correct destruction etc.
        case CQPM_RELEASE:
			pDialog->Detach();
	        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)0);
			delete pDialog;
            break;

        // Enable so fix the state of our two controls within the window.

        case CQPM_ENABLE:
            break;

        // Fill out the parameter structure to return to the caller, this is 
        // handler specific.  In our case we constructure a query of the CN
        // and objectClass properties, and we show a columns displaying both
        // of these.  For further information about the DSQUERYPARAMs structure
        // see dsquery.h

        case CQPM_GETPARAMETERS:
            hr = pDialog->GetQueryParams((LPDSQUERYPARAMS*)lParam);
            break;

        // Clear form, therefore set the window text for these two controls
        // to zero.

        case CQPM_CLEARFORM:
            hr = pDialog->ClearForm();
            break;
            
        // persistance is not currently supported by this form.            
                  
        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            if ( !pPersistQuery )
                return E_INVALIDARG;

			hr = pDialog->Persist(pPersistQuery, fRead);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

    return hr;
}


/*---------------------------------------------------------------------------*/

// The DlgProc is a standard Win32 dialog proc associated with the form
// window.  

INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPCQPAGE pQueryPage;
	CQryDialog*	pDialog;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( uMsg == WM_INITDIALOG )
    {
        // changed from qForm sample to save CDialog pointer
        // in the DWL_USER field of the dialog box instance.

        pQueryPage = (LPCQPAGE)lParam;
		pDialog = (CQryDialog*)pQueryPage->lParam;
		pDialog->Attach(hwnd);

        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pDialog);

		return pDialog->OnInitDialog();

    }
    else
    {
        // CDialog pointer is stored in DWL_USER
        // dialog structure, note however that in some cases this will
        // be NULL as it is set on WM_INITDIALOG.

		pDialog = (CQryDialog*)GetWindowLongPtr(hwnd, DWLP_USER);
    }

	if(!pDialog)
		return FALSE;
	else
		return AfxCallWndProc(pDialog, hwnd, uMsg, wParam, lParam);
}

/*---------------------------------------------------------------------------*/

// Build a parameter block to pass to the query handler.  Each page is called
// with a pointer to a pointer which it must update with the revised query
// block.   For the first page this pointer is NULL, for subsequent pages
// the pointer is non-zero and the page must append its data into the
// allocation.
//
// Returning either and error or S_FALSE stops the query.   An error is
// reported to the user, S_FALSE stops silently.


HRESULT BuildQueryParams(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery)
{
	ASSERT(pQuery);
	
	if(*ppDsQueryParams)
		return QueryParamsAddQueryString(ppDsQueryParams, pQuery);

	else
		
		return QueryParamsAlloc(ppDsQueryParams, pQuery, cRRASColumn, RRASColumn);


}

/*-----------------------------------------------------------------------------
/ QueryParamsAlloc
/ ----------------
/   Construct a block we can pass to the DS query handler which contains
/   all the parameters for the query.
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be used
/   iColumns = number of columns
/   pColumnInfo -> column info structure to use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryParamsAlloc(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery, LONG iColumns, LPCOLUMNINFO aColumnInfo)
{
    HRESULT hr;
    LPDSQUERYPARAMS pDsQueryParams = NULL;
    LONG cbStruct;
    LONG i;

	ASSERT(!*ppDsQueryParams);

    TRACE(L"QueryParamsAlloc");

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( !pQuery || !iColumns || !ppDsQueryParams )
        ExitGracefully(hr, E_INVALIDARG, "Failed to build query parameter block");

	
    // Compute the size of the structure we need to be using

    cbStruct  = sizeof(DSQUERYPARAMS) + (sizeof(DSCOLUMN)*iColumns);
    cbStruct += StringByteSizeW(pQuery);

    for ( i = 0 ; i < iColumns ; i++ )
    {
        if ( aColumnInfo[i].pPropertyName ) 
            cbStruct += StringByteSizeW(aColumnInfo[i].pPropertyName);
    }

    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);

    if ( !pDsQueryParams )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate parameter block");

    // Structure allocated so lets fill it with data

    pDsQueryParams->cbStruct = cbStruct;
    pDsQueryParams->dwFlags = 0;
    pDsQueryParams->hInstance = _Module.m_hInst;
    pDsQueryParams->iColumns = iColumns;
    pDsQueryParams->dwReserved = 0;

    cbStruct  = sizeof(DSQUERYPARAMS) + (sizeof(DSCOLUMN)*iColumns);

    pDsQueryParams->offsetQuery = cbStruct;
    StringByteCopyW(pDsQueryParams, cbStruct, pQuery);
    cbStruct += StringByteSizeW(pQuery);

    for ( i = 0 ; i < iColumns ; i++ )
    {
        pDsQueryParams->aColumns[i].dwFlags = 0;
        pDsQueryParams->aColumns[i].fmt = aColumnInfo[i].fmt;
        pDsQueryParams->aColumns[i].cx = aColumnInfo[i].cx;
        pDsQueryParams->aColumns[i].idsName = aColumnInfo[i].idsName;
        pDsQueryParams->aColumns[i].dwReserved = 0;

        if ( aColumnInfo[i].pPropertyName ) 
        {
            pDsQueryParams->aColumns[i].offsetProperty = cbStruct;
            StringByteCopyW(pDsQueryParams, cbStruct, aColumnInfo[i].pPropertyName);
            cbStruct += StringByteSizeW(aColumnInfo[i].pPropertyName);
        }
        else
        {
            pDsQueryParams->aColumns[i].offsetProperty = aColumnInfo[i].iPropertyIndex;
        }
    }

    hr = S_OK;              // success

exit_gracefully:

    if ( FAILED(hr) && pDsQueryParams )
    {
        CoTaskMemFree(pDsQueryParams); 
        pDsQueryParams = NULL;
    }

    *ppDsQueryParams = pDsQueryParams;

    return hr;
}

/*-----------------------------------------------------------------------------
/ QueryParamsAddQueryString
/ -------------------------
/   Given an existing DS query block appened the given LDAP query string into
/   it. We assume that the query block has been allocated by IMalloc (or CoTaskMemAlloc).
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be appended
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryParamsAddQueryString(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery)
{
    HRESULT hr;
    LPWSTR pOriginalQuery = NULL;
    LPDSQUERYPARAMS pDsQuery = *ppDsQueryParams;
    INT cbQuery, i;
    LPVOID  pv;

	ASSERT(*ppDsQueryParams);
	
    TRACE(_T("QueryParamsAddQueryString"));

    if ( pQuery )
    {
        if ( !pDsQuery )
            ExitGracefully(hr, E_INVALIDARG, "No query to append to");

        // Work out the size of the bits we are adding, take a copy of the
        // query string and finally re-alloc the query block (which may cause it
        // to move).
       
        cbQuery = StringByteSizeW(pQuery) + StringByteSizeW(L"(&)");
        TRACE(_T("DSQUERYPARAMS being resized by %d bytes"));

		i = (wcslen((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery)) + 1) * sizeof(WCHAR);
		pOriginalQuery = (WCHAR*)_alloca(i);
		lstrcpyW(pOriginalQuery, (LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery));
		
        pv = CoTaskMemRealloc(*ppDsQueryParams, pDsQuery->cbStruct+cbQuery);
        if ( pv == NULL )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to re-alloc control block");

        *ppDsQueryParams = (LPDSQUERYPARAMS) pv;

        pDsQuery = *ppDsQueryParams;            // if may have moved

        // Now move everything above the query string up, and fix all the
        // offsets that reference those items (probably the property table),
        // finally adjust the size to reflect the change

        MoveMemory(ByteOffset(pDsQuery, pDsQuery->offsetQuery+cbQuery), 
                     ByteOffset(pDsQuery, pDsQuery->offsetQuery), 
                     (pDsQuery->cbStruct - pDsQuery->offsetQuery));
                
        for ( i = 0 ; i < pDsQuery->iColumns ; i++ )
        {
            if ( pDsQuery->aColumns[i].offsetProperty > pDsQuery->offsetQuery )
            {
                pDsQuery->aColumns[i].offsetProperty += cbQuery;
            }
        }

        wcscpy((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), L"(&");
        wcscat((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pOriginalQuery);
        wcscat((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pQuery);        
        wcscat((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), L")");

        pDsQuery->cbStruct += cbQuery;
    }

    hr = S_OK;

exit_gracefully:

    return hr;
}



// Get the list of values in the dictionary, the variant is expected to be SARRY
HRESULT QueryRRASAdminDictionary(VARIANT* pVar)
{
	ASSERT(pVar);
	
    USES_CONVERSION;

    CString str, str1;

    IADs*           pIADs = NULL;
    // enumerate EAP list

    // retieve the list of EAPTypes in the DS
    // get ROOTDSE
    HRESULT hr = S_OK;
	
	CHECK_HR(hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**)&pIADs));

    ASSERT(pIADs);

    VariantClear(pVar);
    CHECK_HR(hr = pIADs->Get(L"configurationNamingContext", pVar));
    str1 = V_BSTR(pVar);

    pIADs->Release();
    pIADs = NULL;

    str = L"LDAP://";
    str += CN_DICTIONARY;
    str += str1;

	// Dictionary Object
    CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)str), IID_IADs, (void**)&pIADs));
	ASSERT(pIADs);
	
	VariantClear(pVar);
    CHECK_HR(hr = pIADs->GetEx(ATTR_NAME_RRASDICENTRY, pVar));

	goto L_EXIT;

L_ERR:
	VariantClear(pVar);
	
L_EXIT:

    if(pIADs)
        pIADs->Release();

    return hr;
}


HRESULT GetGeneralPageAttributes(CStrArray& array)
{
	HRESULT	hr = S_OK;

	CString*	pStr = NULL;

/*
#define	ATTR_VAL_LANtoLAN		L"311:6:601"
#define	ATTR_VAL_RAS			L"311:6:602"
#define	ATTR_VAL_DEMANDDIAL		L"311:6:603"
*/
	try
	{
		pStr = new CString(ATTR_VAL_LANtoLAN);
		array.Add(pStr);
		
		pStr = new CString(ATTR_VAL_RAS);
		array.Add(pStr);

		pStr = new CString(ATTR_VAL_DEMANDDIAL);
		array.Add(pStr);
	}
	catch(CMemoryException* pException)
	{
		pException->Delete();
		hr = E_OUTOFMEMORY;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\raputil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

// Error code indicating no default profile exists.
#define ERROR_NO_DEFAULT_PROFILE HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

HRESULT
UpdateDefaultPolicy(
    IN LPWSTR wszMachineName,
    IN BOOL fEnableMSCHAPv1,
    IN BOOL fEnableMSCHAPv2,
    IN BOOL fRequireEncryption
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\refrate.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    RefRate.cpp
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Code dealing with refresh rate
//============================================================================
//

#include "stdafx.h"
#include "dialog.h"
#include "RefRate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRefRateDlg dialog


CRefRateDlg::CRefRateDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CRefRateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRefRateDlg)
	m_cRefRate = 0;
	//}}AFX_DATA_INIT

}


void CRefRateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRefRateDlg)
	DDX_Text(pDX, IDC_EDIT_REFRESHRATE, m_cRefRate);
	DDV_MinMaxUInt(pDX, m_cRefRate, 10, 999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRefRateDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CRefRateDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRefRateDlg message handlers
// maps control id's to help contexts
DWORD CRefRateDlg::m_dwHelpMap[] =
{
//	IDC_REFRESHRATE,		HIDC_REFRESHRATE,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\radcfg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                         **/
/**                Copyright(c) Microsoft Corporation, 1998 - 1999                  **/
/**********************************************************************/

/*
    radcfg.cpp
        Implementation file for the RADIUS config object.
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "lsa.h"
#include "radcfg.h"
#include "rtrstr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// This is used as the seed value for the RtlRunEncodeUnicodeString
// and RtlRunDecodeUnicodeString functions.
#define ENCRYPT_SEED        (0xA5)

//max # of digits of the score of a radius server
#define SCORE_MAX_DIGITS    8

//max # of chars in a radius server name
#define MAX_RADIUS_NAME        256

// Const string used when displaying the old secret.  It's a fixed length.
const TCHAR c_szDisplayedSecret[] = _T("\b\b\b\b\b\b\b\b");

const int c_nListColumns = 2;



/*!--------------------------------------------------------------------------
    RouterAuthRadiusConfig::Initialize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAuthRadiusConfig::Initialize(LPCOLESTR pszMachineName,
                                               ULONG_PTR *puConnection)
{
    HRESULT hr = hrOK;
    
    COM_PROTECT_TRY
    {
        // for now, allocate a string and have it point at the string
        // ------------------------------------------------------------
        *puConnection = (ULONG_PTR) StrDupTFromOle(pszMachineName);     
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAuthRadiusConfig::Uninitialize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAuthRadiusConfig::Uninitialize(ULONG_PTR uConnection)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        delete (TCHAR *) uConnection;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    RouterAuthRadiusConfig::Configure
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAuthRadiusConfig::Configure(
                                              ULONG_PTR uConnection,
                                              HWND hWnd,
                                              DWORD dwFlags,
                                              ULONG_PTR uReserved1,
                                              ULONG_PTR uReserved2)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    RadiusServerDialog    authDlg(TRUE, IDS_RADIUS_SERVER_AUTH_TITLE);

    // parameter checking
    // ----------------------------------------------------------------
    if (uConnection == 0)
        return E_INVALIDARG;
    
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
        authDlg.SetServer((LPCTSTR) uConnection);
        authDlg.DoModal();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAuthRadiusConfig::Activate
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAuthRadiusConfig::Activate(
                                             ULONG_PTR uConnection,
                                             ULONG_PTR uReserved1,
                                             ULONG_PTR uReserved2)
{
    // parameter checking
    // ----------------------------------------------------------------
    if (uConnection == 0)
        return E_INVALIDARG;
    
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAuthRadiusConfig::Deactivate
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAuthRadiusConfig::Deactivate(
                                               ULONG_PTR uConnection,
                                               ULONG_PTR uReserved1,
                                               ULONG_PTR uReserved2)
{
    // parameter checking
    // ----------------------------------------------------------------
    if (uConnection == 0)
        return E_INVALIDARG;
    
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
    


/*---------------------------------------------------------------------------
    RadiusServerDialog implementation
 ---------------------------------------------------------------------------*/

RadiusServerDialog::RadiusServerDialog(BOOL fAuth, UINT idsTitle)
    : CBaseDialog(RadiusServerDialog::IDD),
    m_hkeyMachine(NULL),
    m_idsTitle(idsTitle),
    m_fAuthDialog(fAuth)
{
}

RadiusServerDialog::~RadiusServerDialog()
{
    if (m_hkeyMachine)
    {
        DisconnectRegistry(m_hkeyMachine);
        m_hkeyMachine = NULL;
    }
}

BEGIN_MESSAGE_MAP(RadiusServerDialog, CBaseDialog)
    //{{AFX_MSG_MAP(RadiusServerDialog)
    ON_BN_CLICKED(IDC_RADAUTH_BTN_ADD, OnBtnAdd)
    ON_BN_CLICKED(IDC_RADAUTH_BTN_EDIT, OnBtnEdit)
    ON_BN_CLICKED(IDC_RADAUTH_BTN_DELETE, OnBtnDelete)
    ON_NOTIFY(NM_DBLCLK, IDC_RADAUTH_LIST, OnListDblClk)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_RADAUTH_LIST, OnNotifyListItemChanged)
    ON_WM_VSCROLL()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
    RadiusScoreCompareProc
        -    The comparison function for sort of radius server list
    Author: NSun
 ---------------------------------------------------------------------------*/
int CALLBACK RadiusScoreCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lSort)
{
    RADIUSSERVER *pServer1 = NULL;
    RADIUSSERVER *pServer2 = NULL;
    RADIUSSERVER *pServer = NULL;
    CRadiusServers        *pServerList = (CRadiusServers*)lSort;

    for (pServer = pServerList->GetNextServer(TRUE); pServer;
         pServer = pServerList->GetNextServer(FALSE) )
    {
        if (pServer->dwUnique == (DWORD) lParam1)
        {
            //Server 1 found
            pServer1 = pServer;
            
            //if server 2 also found, end search
            if (pServer2)    
                break;
        }
        else if (pServer->dwUnique == (DWORD) lParam2)
        {
            //server 2 found
            pServer2 = pServer;

            //if server 1 also found, end search
            if (pServer1)
                break;
        }
    }

    if (!pServer1 || !pServer2)
    {
        Panic0("We can't find the server in the list (but we should)!");
        return 0;
    }
    else
        return pServer2->cScore - pServer1->cScore;
}

/*!--------------------------------------------------------------------------
    RadiusServerDialog::DoDataExchange
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RadiusServerDialog)
    DDX_Control(pDX, IDC_RADAUTH_LIST, m_ListServers);
    //}}AFX_DATA_MAP
}

/*!--------------------------------------------------------------------------
    RadiusServerDialog::SetServer
        Sets the name of the machine we are looking at.
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::SetServer(LPCTSTR pszServerName)
{
    m_stServerName = pszServerName;
}

/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RadiusServerDialog::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    RADIUSSERVER *    pServer;
    int             iPos;
    CString         stTitle;

    LV_COLUMN lvCol;  // list view column struct for radius servers
    RECT rect;


    CBaseDialog::OnInitDialog();
    
    ListView_SetExtendedListViewStyle(m_ListServers.GetSafeHwnd(),
                                      LVS_EX_FULLROWSELECT);
    
    Assert(m_hkeyMachine == 0);

    stTitle.LoadString(m_idsTitle);
    SetWindowText(stTitle);
    
    // Connect to the machine (get the registry key)
    if (ConnectRegistry(m_stServerName, &m_hkeyMachine) != ERROR_SUCCESS)
    {
        //$ TODO : put in error messages here
        
        // we failed to connect, error out
        OnCancel();
        return TRUE;
    }
    
    // Get the list of RADIUS servers
    LoadRadiusServers(m_stServerName,
                      m_hkeyMachine,
                      m_fAuthDialog,
                      &m_ServerList,
                      0);

    // Get the other list of RADIUS servers
    LoadRadiusServers(m_stServerName,
                      m_hkeyMachine,
                      !m_fAuthDialog,
                      &m_OtherServerList,
                      RADIUS_FLAG_NOUI | RADIUS_FLAG_NOIP);

    m_ListServers.GetClientRect(&rect);
    int nColWidth = rect.right / c_nListColumns;
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = nColWidth;

    CString stColCaption;

    for(int index = 0; index < c_nListColumns; index++)
    {
        stColCaption.LoadString((0 == index) ? IDS_RADIUS_CONFIG_RADIUS: IDS_RADIUS_CONFIG_SCORE);
        lvCol.pszText = (LPTSTR)((LPCTSTR) stColCaption);
        m_ListServers.InsertColumn(index, &lvCol);
    }


    // Now iterate through the server list and add the servers to the
    // list box
    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;
    
    int nCount = 0;
    TCHAR szBufScore[SCORE_MAX_DIGITS];
    for (pServer = m_ServerList.GetNextServer(TRUE); pServer;
         pServer = m_ServerList.GetNextServer(FALSE) )
    {
        lvItem.iItem = nCount;
        lvItem.iSubItem = 0;
        lvItem.pszText = pServer->szName;
        lvItem.lParam = pServer->dwUnique; //same functionality as SetItemData()

        iPos = m_ListServers.InsertItem(&lvItem);
        
        if (iPos != -1)
        {
            _itot(pServer->cScore, szBufScore, 10);
            m_ListServers.SetItemText(iPos, 1, szBufScore);
            nCount++;
        }
    }

    if (m_ListServers.GetItemCount())
    {
        m_ListServers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
        m_ListServers.SortItems(RadiusScoreCompareProc, (LPARAM)&m_ServerList);
    }
    else
    {
        GetDlgItem(IDC_RADAUTH_BTN_DELETE)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADAUTH_BTN_EDIT)->EnableWindow(FALSE);
    }

    return TRUE;
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnOK()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    RADIUSSERVER *    pServer;
    HRESULT         hr = hrOK;

    // fix 8155    rajeshp    06/15/1998    RADIUS: Updating of the radius server entries in the snapin requires a restart of remoteaccess.
    DWORD    dwMajor = 0, dwMinor = 0, dwBuildNo = 0;
    GetNTVersion(m_hkeyMachine, &dwMajor, &dwMinor, &dwBuildNo);            

    DWORD    dwVersionCombine = MAKELONG( dwBuildNo, MAKEWORD(dwMinor, dwMajor));
    DWORD    dwVersionCombineNT50 = MAKELONG ( VER_BUILD_WIN2K, MAKEWORD(VER_MINOR_WIN2K, VER_MAJOR_WIN2K));

    // if the version is greater than Win2K release
    if(dwVersionCombine > dwVersionCombineNT50)
        ;    // skip the restart message
    else
       AfxMessageBox(IDS_WRN_RADIUS_PARAMS_CHANGING);

    // Clear out the deleted server list
    // Do this before we save the list (otherwise the list
    // may have an LSA entry that we will delete).
    // ----------------------------------------------------------------
    m_ServerList.ClearDeletedServerList(m_stServerName);
    
    pServer = m_ServerList.GetNextServer(TRUE);
    
    hr = SaveRadiusServers(m_stServerName,
                           m_hkeyMachine,
                           m_fAuthDialog,
                           pServer);

    if (!FHrSucceeded(hr))
    {
        DisplayErrorMessage(GetSafeHwnd(), hr);
        return;
    }

    CBaseDialog::OnOK();
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnBtnAdd
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnBtnAdd()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ServerPropDialog *        pServerDlg;
    RADIUSSERVER            server;
    int                     iPos;

    ServerPropDialog        authDlg(FALSE);
    ServerPropAcctDialog    acctDlg(FALSE);

    if (m_fAuthDialog)
        pServerDlg = &authDlg;
    else
        pServerDlg = &acctDlg;

    if (pServerDlg->DoModal() == IDOK)
    {
        ZeroMemory(&server, sizeof(server));
        
        pServerDlg->GetDefault(&server);


        
        CString stText;
        BOOL    bFound = FALSE;
        int nCount = m_ListServers.GetItemCount();

        if(nCount > 0)
        {
            TCHAR szRadSrvName[MAX_RADIUS_NAME];

            //we need case insensitive comparation, so cannot use CListBox::FindStringExact()
            for(int iIndex = 0; iIndex < nCount; iIndex++)
            {
                m_ListServers.GetItemText(iIndex, 0, szRadSrvName, MAX_RADIUS_NAME);
                if(lstrcmpi(szRadSrvName, server.szName) == 0)
                {
                    bFound = TRUE;
                    break;
                }

            }
        }
        
        //if the server is already is the list, we won't add it.
        if(bFound)
        {
            CString stText;
            stText.Format(IDS_ERR_RADIUS_DUP_NAME, server.szName);
            AfxMessageBox((LPCTSTR)stText, MB_OK | MB_ICONEXCLAMATION);
        }
        else
        {
            // Add to the server list
            m_ServerList.AddServer(&server, 0);

            // Add to the list control
            TCHAR szBuf[SCORE_MAX_DIGITS];
            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.state = 0;
            
            lvItem.iItem = 0;
            lvItem.iSubItem = 0;
            lvItem.pszText = server.szName;
            lvItem.lParam = server.dwUnique;  //same functionality as SetItemData()

            iPos = m_ListServers.InsertItem(&lvItem);

            _itot(server.cScore, szBuf, 10);

            m_ListServers.SetItemText(iPos, 1, szBuf);

            if (iPos != -1)
            {
                //if no radius server in the list previously, select the new added server.
                // (and enable "edit" and "delete" buttons in OnNotifyListItemChanged()
                if (nCount == 0)
                    m_ListServers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

                m_ListServers.SortItems(RadiusScoreCompareProc, (LPARAM)&m_ServerList);
            }
        }
    }
    SetFocus();
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnBtnDelete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnBtnDelete()
{
    // Get the selection and delete it
    int     iPos;
    ULONG_PTR    dwUnique;
    RADIUSSERVER *  pServer = NULL;
    BOOL        fRemoveLSAEntry = FALSE;

    iPos = m_ListServers.GetNextItem(-1, LVNI_SELECTED);
    if (iPos == -1)
        return;

    dwUnique = m_ListServers.GetItemData(iPos);

    // Does this server exist in the other list
    Verify( m_ServerList.FindServer((DWORD) dwUnique, &pServer) );
    Assert(pServer);
    
    // If we find this server in the other list, we can't remove its
    // LSA entry
    fRemoveLSAEntry = !m_OtherServerList.FindServer(pServer->szName, NULL);

    m_ServerList.DeleteServer(dwUnique, fRemoveLSAEntry);

    m_ListServers.DeleteItem(iPos);

    // See if we can move the selection to the next item in the list
    // if that fails, try to set it to the previous item
    if (!m_ListServers.SetItemState(iPos, LVIS_SELECTED, LVIS_SELECTED))
        m_ListServers.SetItemState(iPos - 1, LVIS_SELECTED, LVIS_SELECTED);
    
    SetFocus();
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnBtnEdit
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnBtnEdit()
{
    ServerPropDialog *        pServerDlg;
    RADIUSSERVER            server;
    RADIUSSERVER *            pServer;
    int                     iOldPos, iPos;
    LONG_PTR                    dwUnique;


    ServerPropDialog        authDlg(TRUE);
    ServerPropAcctDialog    acctDlg(TRUE);

    if (m_fAuthDialog)
        pServerDlg = &authDlg;
    else
        pServerDlg = &acctDlg;

    iOldPos = m_ListServers.GetNextItem(-1, LVNI_SELECTED);
    if (iOldPos == -1)
        return;

    dwUnique = m_ListServers.GetItemData(iOldPos);
    // Need to look for server data that matches this one
    // Now iterate through the server list and add the servers to the
    // list box
    for (pServer = m_ServerList.GetNextServer(TRUE); pServer;
         pServer = m_ServerList.GetNextServer(FALSE) )
    {
        if (pServer->dwUnique == (DWORD) dwUnique)
            break;
    }

    if (!pServer)
    {
        Panic0("We can't find the server in the list (but we should)!");
        return;
    }

    pServerDlg->SetDefault(pServer);

    if (pServerDlg->DoModal() == IDOK)
    {
        ZeroMemory(&server, sizeof(server));
        
        pServerDlg->GetDefault(&server);

        // Add to the server list, need to add this at the proper place
        m_ServerList.AddServer(&server, dwUnique);

        // Delete the old server data
        m_ServerList.DeleteServer(dwUnique, FALSE);
        m_ListServers.DeleteItem(iOldPos);
        pServer = NULL;

        // Add to the list control
        TCHAR szBuf[SCORE_MAX_DIGITS];
        LV_ITEM lvItem;

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;
        
        lvItem.iItem = iOldPos;
        lvItem.iSubItem = 0;
        lvItem.pszText = server.szName;
        lvItem.lParam = server.dwUnique;    //same functionality as SetItemData()

        iPos = m_ListServers.InsertItem(&lvItem);

        _itot(server.cScore, szBuf, 10);

        m_ListServers.SetItemText(iPos, 1, szBuf);

        if (iPos != -1)
        {
            // Reset the current selection
            m_ListServers.SetItemState(iPos, LVIS_SELECTED, LVIS_SELECTED);

            m_ListServers.SortItems(RadiusScoreCompareProc, (LPARAM)&m_ServerList);
        }
        ZeroMemory(&server, sizeof(server));        
    }
    
    SetFocus();
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnListDblClk
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnListDblClk(NMHDR *pNMHdr, LRESULT *pResult)
{
    OnBtnEdit();
}


/*!--------------------------------------------------------------------------
    RadiusServerDialog::OnNotifyListItemChanged
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RadiusServerDialog::OnNotifyListItemChanged(NMHDR *pNMHdr, LRESULT *pResult)
{
    NMLISTVIEW *    pnmlv = reinterpret_cast<NMLISTVIEW *>(pNMHdr);
    int iPos;

    if ((pnmlv->uNewState & LVIS_SELECTED) != (pnmlv->uOldState & LVIS_SELECTED))
    {
        iPos = m_ListServers.GetNextItem(-1, LVNI_SELECTED);

        GetDlgItem(IDC_RADAUTH_BTN_DELETE)->EnableWindow(iPos != -1);
        GetDlgItem(IDC_RADAUTH_BTN_EDIT)->EnableWindow(iPos != -1);
    }

    *pResult = 0;
}


//**
//
// Call:        LoadRadiusServers
//
// Returns:     NO_ERROR         - Success
//                Non-zero returns - Failure
//
// Description:
//
HRESULT
LoadRadiusServers(
    IN LPCTSTR            pszServerName,
    IN HKEY             hkeyMachine,
    IN BOOL             fAuthentication,
    IN CRadiusServers * pRadiusServers,
    IN DWORD            dwFlags
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT             hr = hrOK;
    DWORD                dwErrorCode;
    BOOL                fValidServer = FALSE;
    RegKey                regkeyServers;
    RegKeyIterator        regkeyIter;
    HRESULT             hrIter;
    CString             stKey;
    RegKey                regkeyServer;
    DWORD                dwData;
    WSADATA             wsadata;
    BOOL                fWSInitialized = FALSE;
    DWORD                wsaerr = 0;

    COM_PROTECT_TRY
    {    
//        DWORD            dwKeyIndex, cbKeyServer, cbValue;
//        TCHAR            szKeyServer[MAX_PATH+1];
        CHAR            szName[MAX_PATH+1];
        RADIUSSERVER    RadiusServer;
        CWaitCursor        waitCursor;

        ZeroMemory(&RadiusServer, sizeof(RadiusServer));

        Assert(pRadiusServers != NULL);
        Assert(hkeyMachine);

        wsaerr = WSAStartup(0x0101, &wsadata);
        if (wsaerr)
        {
            // Need to setup a winsock error
            hr = E_FAIL;
            goto Error;
        }

        // Winsock successfully initialized
        fWSInitialized = TRUE;

        CWRg( regkeyServers.Open(hkeyMachine,
                                 fAuthentication ?
                                    c_szRadiusAuthServersKey :
                                    c_szRadiusAcctServersKey,
                                 KEY_READ) );

        CORg( regkeyIter.Init(&regkeyServers) );

        for (hrIter=regkeyIter.Next(&stKey); hrIter == hrOK;
             hrIter=regkeyIter.Next(&stKey), regkeyServer.Close())
        {
            CWRg( regkeyServer.Open(regkeyServers, stKey, KEY_READ) );
            
            ZeroMemory( &RadiusServer, sizeof( RadiusServer ) );

            // Copy the name over
            StrnCpy(RadiusServer.szName, stKey, MAX_PATH);


            // Since we're reading this in from the registry, it's
            // been persisted
            RadiusServer.fPersisted = TRUE;


            // Get the timeout value
            dwErrorCode = regkeyServer.QueryValue(c_szTimeout, dwData);         
            if ( dwErrorCode != NO_ERROR )
                RadiusServer.Timeout.tv_sec = DEFTIMEOUT;
            else
                RadiusServer.Timeout.tv_sec = dwData;

            //
            // Secret Value is required
            //

            CWRg( RetrievePrivateData( pszServerName,
                                       RadiusServer.szName, 
                                       RadiusServer.wszSecret,
                                       DimensionOf(RadiusServer.wszSecret)) );
            RadiusServer.cchSecret = lstrlen(RadiusServer.wszSecret);

            // Encode the password, do not store it as plain text
            // Decode as needed.
            RadiusServer.ucSeed = ENCRYPT_SEED;
            RtlEncodeW(&RadiusServer.ucSeed, RadiusServer.wszSecret);

            //
            // read in port numbers
            //

            // Get the AuthPort

            if (fAuthentication)
            {
                dwErrorCode = regkeyServer.QueryValue( c_szAuthPort, dwData );
                if ( dwErrorCode != NO_ERROR )
                    RadiusServer.AuthPort = DEFAUTHPORT;
                else
                    RadiusServer.AuthPort = dwData;

                // Windows NT Bug : 311398
                // Get the Digital Signature data
                if (dwErrorCode == NO_ERROR)
                    dwErrorCode = regkeyServer.QueryValue( c_szRegValSendSignature, dwData );
                
                if (dwErrorCode == NO_ERROR)
                    RadiusServer.fUseDigitalSignatures = dwData;
                else
                    RadiusServer.fUseDigitalSignatures = FALSE;
            }
            else
            {
                // Get the AcctPort
                dwErrorCode = regkeyServer.QueryValue(c_szAcctPort, dwData );
                if ( dwErrorCode != NO_ERROR )
                    RadiusServer.AcctPort = DEFACCTPORT;
                else
                    RadiusServer.AcctPort = dwData;

                // Get the EnableAccounting On/Off flag
                dwErrorCode = regkeyServer.QueryValue( c_szEnableAccountingOnOff,
                    dwData );
                if ( dwErrorCode != NO_ERROR )
                    RadiusServer.fAccountingOnOff = TRUE;
                else
                    RadiusServer.fAccountingOnOff = dwData;
            }
                
                
            // Get the score
            dwErrorCode = regkeyServer.QueryValue( c_szScore, dwData );
            if ( dwErrorCode != NO_ERROR )
                RadiusServer.cScore = MAXSCORE;
            else
                RadiusServer.cScore = dwData;

            
            RadiusServer.cRetries = 1;

            //
            // Convert name to ip address.
            //

            if ( INET_ADDR( RadiusServer.szName ) == INADDR_NONE )
            { 
                // resolve name

                struct hostent * phe = NULL;

                if (dwFlags & RADIUS_FLAG_NOIP)
                    phe = NULL;
                else
                {
                    StrnCpyAFromT(szName, RadiusServer.szName,
                                  DimensionOf(szName));
                    phe = gethostbyname( szName );
                }

                if ( phe != NULL )
                { 
                    // host could have multiple addresses
                    // BUG#185732 (nsun 11/04/98) We only load the first Ip Address
                    
                    if( phe->h_addr_list[0] != NULL )
                    {
                        RadiusServer.IPAddress.sin_family = AF_INET;
                        RadiusServer.IPAddress.sin_port = 
                                        htons((SHORT) RadiusServer.AuthPort);
                        RadiusServer.IPAddress.sin_addr.S_un.S_addr = 
                                      *((PDWORD) phe->h_addr_list[0]);
                    }
                }
                else
                {
                    if ((dwFlags & RADIUS_FLAG_NOUI) == 0)
                    {
                        CString stText;
                        stText.Format(IDS_ERR_RADIUS_INVALID_NAME, RadiusServer.szName);
                        AfxMessageBox((LPCTSTR)stText, MB_OK | MB_ICONEXCLAMATION);
                        waitCursor.Restore();
                    }
                }
            }
            else
            { 
                //
                // use specified ip address
                //

                RadiusServer.IPAddress.sin_family = AF_INET;
                RadiusServer.IPAddress.sin_port = 
                                        htons((SHORT) RadiusServer.AuthPort);
                RadiusServer.IPAddress.sin_addr.S_un.S_addr = INET_ADDR(RadiusServer.szName);

            }
            
            if ( pRadiusServers != NULL )
            {
                fValidServer = (pRadiusServers->AddServer(&RadiusServer, (DWORD) -1) 
                                == NO_ERROR 
                                ? TRUE 
                                : FALSE);
            }
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (fWSInitialized)
        WSACleanup();

    //
    // if no servers entries are found in registry return error code.
    //

    if ( ( fValidServer == FALSE ) && FHrSucceeded(hr) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_RADIUS_SERVERS);
    }

    return( hr );
} 

//**
//
// Call:        SaveRadiusServers
//
// Returns:     NO_ERROR         - Success
//                Non-zero returns - Failure
//
// Description:
//
HRESULT
SaveRadiusServers(LPCTSTR pszServerName,
                  HKEY    hkeyMachine,
                  IN BOOL            fAuthentication,
                  IN RADIUSSERVER * pServerRoot
)
{
    HRESULT             hr = hrOK;
    RADIUSSERVER        *pServer;
    DWORD                dwErrorCode;
    RegKey                regkeyMachine;
    RegKey                regkeyServers, regkeyServer;
    DWORD                dwData;
    
    pServer = pServerRoot;

    COM_PROTECT_TRY
    {

        regkeyMachine.Attach(hkeyMachine);
        regkeyMachine.RecurseDeleteKey(fAuthentication ?
                                    c_szRadiusAuthServersKey :
                                    c_szRadiusAcctServersKey);

        CWRg( regkeyServers.Create(hkeyMachine,
                                 fAuthentication ?
                                    c_szRadiusAuthServersKey :
                                    c_szRadiusAcctServersKey) );

        while( pServer != NULL )
        {
            CWRg( regkeyServer.Create(regkeyServers, pServer->szName) );

            // Need to unencode the private data
            RtlDecodeW(pServer->ucSeed, pServer->wszSecret);
            dwErrorCode = StorePrivateData(pszServerName,
                                           pServer->szName,
                                           pServer->wszSecret);
            RtlEncodeW(&pServer->ucSeed, pServer->wszSecret);
            CWRg( dwErrorCode );

            // Ok, we've saved the information
            pServer->fPersisted = TRUE;

            dwData = pServer->Timeout.tv_sec;
            CWRg( regkeyServer.SetValue(c_szTimeout, dwData) );

            if (fAuthentication)
            {
                dwData = pServer->AuthPort;
                CWRg( regkeyServer.SetValue(c_szAuthPort, dwData) );

                // Windows NT Bug: 311398
                // Save the digital signature data
                dwData = pServer->fUseDigitalSignatures;
                CWRg( regkeyServer.SetValue(c_szRegValSendSignature, dwData) );
            }
            else
            {
                dwData = pServer->AcctPort;
                CWRg( regkeyServer.SetValue(c_szAcctPort, dwData) );

                dwData = pServer->fAccountingOnOff;
                CWRg( regkeyServer.SetValue(c_szEnableAccountingOnOff, dwData) );
            }
                

            dwData = pServer->cScore;
            CWRg( regkeyServer.SetValue(c_szScore, dwData) );

            regkeyServer.Close();
            pServer = pServer->pNext;
        }

        COM_PROTECT_ERROR_LABEL;            
    }
    COM_PROTECT_CATCH;

    regkeyMachine.Detach();

    return hr;
} 


/*!--------------------------------------------------------------------------
    DeleteRadiusServers
        DANGER!  Do NOT call this unless you absolutely know this is
        what you need.  The problem is that there is no way to
        distinguish between accouting/authentication entries, thus an
        external reference check must be made.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
DeleteRadiusServers(LPCTSTR pszServerName,
                    RADIUSSERVER * pServerRoot
)
{
    HRESULT             hr = hrOK;
    RADIUSSERVER        *pServer;
    
    pServer = pServerRoot;

    COM_PROTECT_TRY
    {
        while( pServer != NULL )
        {
            if (pServer->fPersisted)
                DeletePrivateData(pszServerName,
                                  pServer->szName);
            pServer = pServer->pNext;
        }
    }
    COM_PROTECT_CATCH;

    return hr;
} 



/*---------------------------------------------------------------------------
    ServerPropDialog implementation
 ---------------------------------------------------------------------------*/

ServerPropDialog::ServerPropDialog(BOOL fEdit, CWnd* pParent /*=NULL*/)
    : CBaseDialog(ServerPropDialog::IDD, pParent),
    m_fEdit(fEdit)
{
    //{{AFX_DATA_INIT(ServerPropDialog)
    m_uAuthPort = DEFAUTHPORT;
    m_uAcctPort = DEFACCTPORT;
    m_stSecret.Empty();
    m_cchSecret = 0;
    m_ucSeed = ENCRYPT_SEED;
    m_stServer.Empty();
    m_uTimeout = DEFTIMEOUT;
    m_iInitScore = MAXSCORE;
    m_fAccountingOnOff = FALSE;
    m_fUseDigitalSignatures = FALSE;
    //}}AFX_DATA_INIT
}

ServerPropDialog::ServerPropDialog(BOOL fEdit, UINT idd, CWnd* pParent /*=NULL*/)
    : CBaseDialog(idd, pParent),
    m_fEdit(fEdit)
{
    //{{AFX_DATA_INIT(ServerPropDialog)
    m_uAuthPort = DEFAUTHPORT;
    m_uAcctPort = DEFACCTPORT;
    m_stSecret.Empty();
    m_cchSecret = 0;
    m_ucSeed = ENCRYPT_SEED;
    m_stServer.Empty();
    m_uTimeout = DEFTIMEOUT;
    m_iInitScore = MAXSCORE;
    m_fAccountingOnOff = FALSE;
    m_fUseDigitalSignatures = FALSE;
    //}}AFX_DATA_INIT
}

ServerPropDialog::~ServerPropDialog()
{
    ::SecureZeroMemory(m_stSecret.GetBuffer(0),
               m_stSecret.GetLength() * sizeof(TCHAR));
    m_stSecret.ReleaseBuffer(-1);
}

void ServerPropDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ServerPropDialog)
    DDX_Control(pDX, IDC_RAC_EDIT_SERVER, m_editServerName);
    DDX_Control(pDX, IDC_RAC_EDIT_SECRET, m_editSecret);
    DDX_Control(pDX, IDC_RAC_EDIT_PORT, m_editPort);
    DDX_Control(pDX, IDC_RAC_SPIN_SCORE, m_spinScore);
    DDX_Control(pDX, IDC_RAC_SPIN_TIMEOUT, m_spinTimeout);

    DDX_Text(pDX, IDC_RAC_EDIT_PORT, m_uAuthPort);
    DDX_Text(pDX, IDC_RAC_EDIT_SERVER, m_stServer);
    DDX_Text(pDX, IDC_RAC_EDIT_TIMEOUT, m_uTimeout);
    DDX_Text(pDX, IDC_RAC_EDIT_SCORE, m_iInitScore);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ServerPropDialog, CBaseDialog)
    //{{AFX_MSG_MAP(ServerPropDialog)
    ON_BN_CLICKED(IDC_RAC_BTN_CHANGE, OnBtnPassword)
//    ON_WM_CONTEXTMENU()
//    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ServerPropDialog message handlers

            
/*!--------------------------------------------------------------------------
    ServerPropDialog::SetDefault
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
VOID ServerPropDialog::SetDefault(RADIUSSERVER *pServer)
{
    Assert(pServer);
    m_stServer        = pServer->szName;
    m_stSecret            = pServer->wszSecret;
    m_ucSeed            = pServer->ucSeed;
    m_cchSecret         = pServer->cchSecret;
    m_uTimeout            = pServer->Timeout.tv_sec;
    m_uAcctPort         = pServer->AcctPort;
    m_uAuthPort         = pServer->AuthPort;
    m_iInitScore            = pServer->cScore;
    m_fAccountingOnOff    = pServer->fAccountingOnOff;
    m_fUseDigitalSignatures = pServer->fUseDigitalSignatures;
} // SetDefault()


/*!--------------------------------------------------------------------------
    ServerPropDialog::GetDefault
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
VOID ServerPropDialog::GetDefault(RADIUSSERVER *pServer)
{
    Assert(pServer);
    lstrcpy(pServer->szName, m_stServer);

    lstrcpy(pServer->wszSecret, m_stSecret);
    pServer->cchSecret            = m_stSecret.GetLength();
    pServer->ucSeed             = m_ucSeed;
    
    pServer->Timeout.tv_sec     = m_uTimeout;
    pServer->AcctPort            = m_uAcctPort;
    pServer->AuthPort            = m_uAuthPort;
    pServer->cScore             = m_iInitScore;
    pServer->fAccountingOnOff    = m_fAccountingOnOff;
    pServer->fUseDigitalSignatures = m_fUseDigitalSignatures;
} // GetDefault()


/*!--------------------------------------------------------------------------
    ServerPropDialog::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ServerPropDialog::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString     stTitle;
    
    CBaseDialog::OnInitDialog();

    // Set the title of this dialog
    stTitle.LoadString(m_fEdit ? IDS_RADIUS_CONFIG_EDIT : IDS_RADIUS_CONFIG_ADD);
    SetWindowText(stTitle);

    m_editServerName.SetFocus();

    // We don't allow editing of the secret from here
    m_editSecret.EnableWindow(FALSE);

    // Need to send 'cchSecret' backspace characters to the
    // edit control.  Do this so that it looks as if there are
    // the right number of characters
    //
    // Windows NT Bug : 186649 - we should show the same number of
    // characters regardless.
    //
    // If this is a new server, then we keep the secret text as
    // blank, so the user knows that there is no secret.  In the
    // edit case, we still show the text even if the secret is blank.
    // ----------------------------------------------------------------
    if (m_fEdit)
        m_editSecret.SetWindowText(c_szDisplayedSecret);
    
    m_spinScore.SetBuddy(GetDlgItem(IDC_RAC_EDIT_SCORE));
    m_spinScore.SetRange(0, MAXSCORE);

    m_spinTimeout.SetBuddy(GetDlgItem(IDC_RAC_EDIT_TIMEOUT));
    m_spinTimeout.SetRange(0, 300);

    if (GetDlgItem(IDC_RAC_BTN_DIGITALSIG))
        CheckDlgButton(IDC_RAC_BTN_DIGITALSIG, m_fUseDigitalSignatures);

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*!--------------------------------------------------------------------------
    ServerPropDialog::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ServerPropDialog::OnOK() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString stTemp;
    
    if (!UpdateData(TRUE))
        return;

    // Do parameter checking
    m_editServerName.GetWindowText(stTemp);
    stTemp.TrimLeft();
    stTemp.TrimRight();
    if (stTemp.IsEmpty())
    {
        AfxMessageBox(IDS_ERR_INVALID_SERVER_NAME);
        m_editServerName.SetFocus();
        return;
    }
    
    // Need to grab the current value of the secret out of the edit
    // control.  If there are only backspace characters, then do
    // not change the secret.  Otherwise overwrite the current secret.
//    m_editSecret.GetWindowText(stTemp);
//    for (int i=0; i<stTemp.GetLength(); i++)
//    {
//        if (stTemp[i] != _T('\b'))
//        {
//            // Ok, the secret has changed, use the new password instead
//            RtlEncodeW(&m_ucSeed, stTemp.GetBuffer(0));
//            stTemp.ReleaseBuffer(-1);
//
//            // Get a pointer to the old memory and write 0's into it
//            ::SecureZeroMemory(m_stSecret.GetBuffer(0),
//                       m_stSecret.GetLength() * sizeof(TCHAR));
//            m_stSecret.ReleaseBuffer(-1);
//            
//            m_stSecret = stTemp;
//            break;
//        }
//    }

//    m_fAuthentication = IsDlgButtonChecked(IDC_RAC_BTN_ENABLE);

    if (GetDlgItem(IDC_RAC_BTN_DIGITALSIG))
        m_fUseDigitalSignatures = IsDlgButtonChecked(IDC_RAC_BTN_DIGITALSIG);

    if (m_iInitScore > MAXSCORE || m_iInitScore < MINSCORE)
    {
        CString stErrMsg;
        stErrMsg.Format(IDS_ERR_INVALID_RADIUS_SCORE, m_iInitScore, MINSCORE, MAXSCORE);
        AfxMessageBox((LPCTSTR)stErrMsg);
    }
    else
        CBaseDialog::OnOK();
}


/*!--------------------------------------------------------------------------
    ServerPropDialog::OnBtnPassword
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ServerPropDialog::OnBtnPassword()
{
    RADIUSSecretDialog    secretdlg;

    // Ask for the new secret
    if (secretdlg.DoModal() == IDOK)
    {
        // Zero out the old value
        ::SecureZeroMemory(m_stSecret.GetBuffer(0),
                   m_stSecret.GetLength() * sizeof(TCHAR));
        m_stSecret.ReleaseBuffer(-1);
        
        // Get the value of the new secret and seed
        secretdlg.GetSecret(&m_stSecret, &m_cchSecret, &m_ucSeed);
        
        // Windows NT Bug : 186649
        // Must show secrets as constant length.
        m_editSecret.SetWindowText(c_szDisplayedSecret);
    }
}


//static const DWORD rgHelpIDs[] = 
//    {
//    IDC_EDIT_SERVERNAME,    IDH_SERVER_NAME,
//    IDC_EDIT_SECRET,        IDH_SECRET,
//    IDC_EDIT_TIMEOUT,        IDH_TIMEOUT,
//    IDC_SPIN_TIMEOUT,        IDH_TIMEOUT,
//    IDC_EDIT_SCORE,         IDH_INITIAL_SCORE,
//    IDC_SPIN_SCORE,         IDH_INITIAL_SCORE,
//    IDC_CHECK_ACCT,         IDH_ENABLE_ACCOUNTING,
//    IDC_STATIC_ACCTPORT,    IDH_ACCOUNTING_PORT,
//    IDC_EDIT_ACCTPORT,        IDH_ACCOUNTING_PORT,
//    IDC_CHECK_AUTH,         IDH_ENABLE_AUTHENTICATION,
//    IDC_STATIC_AUTHPORT,    IDH_AUTHENTICATION_PORT,
//    IDC_EDIT_AUTHPORT,        IDH_AUTHENTICATION_PORT,
//    IDC_CHECK_ACCT_ONOFF,    IDH_ACCOUNTING_ONOFF,
//    0, 0
//};
    
/*---------------------------------------------------------------------------
    RADIUSSecretDialog implementation
 ---------------------------------------------------------------------------*/

RADIUSSecretDialog::RADIUSSecretDialog(CWnd* pParent /*=NULL*/)
    : CBaseDialog(RADIUSSecretDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(RADIUSSecretDialog)
    //}}AFX_DATA_INIT
    m_cchNewSecret = 0;
    m_stNewSecret.Empty();
    m_ucNewSeed = 0;
}

RADIUSSecretDialog::~RADIUSSecretDialog()
{
    ::SecureZeroMemory(m_stNewSecret.GetBuffer(0),
               m_stNewSecret.GetLength() * sizeof(TCHAR));
    m_stNewSecret.ReleaseBuffer(-1);
}


void RADIUSSecretDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RADIUSSecretDialog)
    DDX_Control(pDX, IDC_SECRET_EDIT_NEW, m_editSecretNew);
    DDX_Control(pDX, IDC_SECRET_EDIT_NEW_CONFIRM, m_editSecretNewConfirm);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(RADIUSSecretDialog, CBaseDialog)
    //{{AFX_MSG_MAP(RADIUSSecretDialog)
//    ON_WM_CONTEXTMENU()
//    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// RADIUSSecretDialog message handlers


/*!--------------------------------------------------------------------------
    RADIUSSecretDialog::GetSecret
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
VOID RADIUSSecretDialog::GetSecret(CString *pst, INT *pcch, UCHAR *pucSeed)
{
    *pst = m_stNewSecret;
    *pcch = m_cchNewSecret;
    *pucSeed = m_ucNewSeed;
}


/*!--------------------------------------------------------------------------
    RADIUSSecretDialog::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RADIUSSecretDialog::OnInitDialog() 
{

    CBaseDialog::OnInitDialog();

    m_editSecretNew.SetWindowText(c_szEmpty);
    m_editSecretNewConfirm.SetWindowText(c_szEmpty);

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*!--------------------------------------------------------------------------
    RADIUSSecretDialog::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RADIUSSecretDialog::OnOK() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString stTemp;
    CString stNew, stNewConfirm, stOld;
    UCHAR    ucSeed;

    // Get the text for the new password, compare it to the
    // new confirm passord, if they are the same use that as
    // the password.
    GetDlgItemText(IDC_SECRET_EDIT_NEW, stNew);
    GetDlgItemText(IDC_SECRET_EDIT_NEW_CONFIRM, stNewConfirm);

    if (stNew != stNewConfirm)
    {
        AfxMessageBox(IDS_ERR_SECRETS_MUST_MATCH);
        return;
    }

    // Zero out the old value
    ::SecureZeroMemory(m_stNewSecret.GetBuffer(0),
               m_stNewSecret.GetLength() * sizeof(TCHAR));
    m_stNewSecret.ReleaseBuffer(-1);

    // Get the new values (and encrypt)
    m_stNewSecret = stNew;
    m_ucNewSeed = ENCRYPT_SEED;
    RtlEncodeW(&m_ucNewSeed, m_stNewSecret.GetBuffer(0));
    m_stNewSecret.ReleaseBuffer(-1);
    m_cchNewSecret = m_stNewSecret.GetLength();

    // Zero out the on-stack memory
    ::SecureZeroMemory(stNew.GetBuffer(0),
               stNew.GetLength() * sizeof(TCHAR));
    stNew.ReleaseBuffer(-1);
    
    ::SecureZeroMemory(stNewConfirm.GetBuffer(0),
               stNewConfirm.GetLength() * sizeof(TCHAR));
    stNewConfirm.ReleaseBuffer(-1);
    
    // Need to grab the current value of the secret out of the edit
    // control.  If there are only backspace characters, then do
    // not change the secret.  Otherwise overwrite the current secret.
//    m_editSecret.GetWindowText(stTemp);
//    for (int i=0; i<stTemp.GetLength(); i++)
//    {
//        if (stTemp[i] != _T('\b'))
//        {
//            // Ok, the secret has changed, use the new password instead
//            RtlEncodeW(&m_ucSeed, stTemp.GetBuffer(0));
//            stTemp.ReleaseBuffer(-1);
//
//            // Get a pointer to the old memory and write 0's into it
//            ::SecureZeroMemory(m_stSecret.GetBuffer(0),
//                       m_stSecret.GetLength() * sizeof(TCHAR));
//            m_stSecret.ReleaseBuffer(-1);
//            
//            m_stSecret = stTemp;
//            break;
//        }
//    }

    CBaseDialog::OnOK();
}






/*---------------------------------------------------------------------------
    RouterAcctRadiusConfig implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    RouterAcctRadiusConfig::Initialize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAcctRadiusConfig::Initialize(LPCOLESTR pszMachineName,
                                               ULONG_PTR *puConnection)
{
    HRESULT hr = hrOK;

    // Parameter checking
    // ----------------------------------------------------------------
    if (puConnection == NULL)
        return E_INVALIDARG;
    
    COM_PROTECT_TRY
    {
        // for now, allocate a string and have it point at the string
        // ------------------------------------------------------------
        *puConnection = (ULONG_PTR) StrDupTFromOle(pszMachineName);     
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAcctRadiusConfig::Uninitialize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAcctRadiusConfig::Uninitialize(ULONG_PTR uConnection)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        delete (TCHAR *) uConnection;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAcctRadiusConfig::Configure
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAcctRadiusConfig::Configure(
                                              ULONG_PTR uConnection,
                                              HWND hWnd,
                                              DWORD dwFlags,
                                              ULONG_PTR uReserved1,
                                              ULONG_PTR uReserved2)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    RadiusServerDialog    acctDlg(FALSE, IDS_RADIUS_SERVER_ACCT_TITLE);
    
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
        acctDlg.SetServer((TCHAR *) uConnection);
        acctDlg.DoModal();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAcctRadiusConfig::Activate
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAcctRadiusConfig::Activate(
                                             ULONG_PTR uConnection,
                                             ULONG_PTR uReserved1,
                                             ULONG_PTR uReserved2)
{
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterAcctRadiusConfig::Deactivate
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT     RouterAcctRadiusConfig::Deactivate(
                                               ULONG_PTR uConnection,
                                               ULONG_PTR uReserved1,
                                               ULONG_PTR uReserved2)
{
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
    }
    COM_PROTECT_CATCH;
    return hr;
}

    
    
/*---------------------------------------------------------------------------
    ServerPropAcctDialog implementation
 ---------------------------------------------------------------------------*/

ServerPropAcctDialog::ServerPropAcctDialog(BOOL fEdit, CWnd* pParent /*=NULL*/)
    : ServerPropDialog(fEdit, ServerPropAcctDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(ServerPropAcctDialog)
    //}}AFX_DATA_INIT
}

ServerPropAcctDialog::~ServerPropAcctDialog()
{
}

void ServerPropAcctDialog::DoDataExchange(CDataExchange* pDX)
{
    ServerPropDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ServerPropAcctDialog)
    DDX_Text(pDX, IDC_RAC_EDIT_PORT, m_uAcctPort);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ServerPropAcctDialog, CBaseDialog)
    //{{AFX_MSG_MAP(ServerPropAcctDialog)
    ON_BN_CLICKED(IDC_RAC_BTN_CHANGE, OnBtnPassword)
//    ON_WM_CONTEXTMENU()
//    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ServerPropAcctDialog message handlers

/*!--------------------------------------------------------------------------
    ServerPropAcctDialog::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ServerPropAcctDialog::OnInitDialog() 
{

    ServerPropDialog::OnInitDialog();

    CheckDlgButton(IDC_RAC_BTN_ONOFF, m_fAccountingOnOff);

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*!--------------------------------------------------------------------------
    ServerPropAcctDialog::OnOK
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ServerPropAcctDialog::OnOK() 
{
    CString stTemp;
    
    // Need to grab the current value of the secret out of the edit
    // control.  If there are only backspace characters, then do
    // not change the secret.  Otherwise overwrite the current secret.
//    m_editSecret.GetWindowText(stTemp);
//    for (int i=0; i<stTemp.GetLength(); i++)
//    {
//        if (stTemp[i] != _T('\b'))
//        {
//            // Ok, the secret has changed, use the new password instead
//            RtlEncodeW(&m_ucSeed, stTemp.GetBuffer(0));
//            stTemp.ReleaseBuffer(-1);
//
//            // Get a pointer to the old memory and write 0's into it
//            ::SecureZeroMemory(m_stSecret.GetBuffer(0),
//                       m_stSecret.GetLength() * sizeof(TCHAR));
//            m_stSecret.ReleaseBuffer(-1);
//            
//            m_stSecret = stTemp;
//            break;
//        }
//    }

    m_fAccountingOnOff = IsDlgButtonChecked(IDC_RAC_BTN_ONOFF);

    ServerPropDialog::OnOK();
}


//static const DWORD rgHelpIDs[] = 
//    {
//    IDC_EDIT_SERVERNAME,    IDH_SERVER_NAME,
//    IDC_EDIT_SECRET,        IDH_SECRET,
//    IDC_EDIT_TIMEOUT,        IDH_TIMEOUT,
//    IDC_SPIN_TIMEOUT,        IDH_TIMEOUT,
//    IDC_EDIT_SCORE,         IDH_INITIAL_SCORE,
//    IDC_SPIN_SCORE,         IDH_INITIAL_SCORE,
//    IDC_CHECK_ACCT,         IDH_ENABLE_ACCOUNTING,
//    IDC_STATIC_ACCTPORT,    IDH_ACCOUNTING_PORT,
//    IDC_EDIT_ACCTPORT,        IDH_ACCOUNTING_PORT,
//    IDC_CHECK_AUTH,         IDH_ENABLE_AUTHENTICATION,
//    IDC_STATIC_AUTHPORT,    IDH_AUTHENTICATION_PORT,
//    IDC_EDIT_AUTHPORT,        IDH_AUTHENTICATION_PORT,
//    IDC_CHECK_ACCT_ONOFF,    IDH_ACCOUNTING_ONOFF,
//    0, 0
//};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\radbal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       radbal.h
//
//--------------------------------------------------------------------------

#ifndef _RADBAL_H_
#define _RADBAL_H_

#include <winsock.h>

// 5 seconds for default timeout to server requests
#define DEFTIMEOUT				5

// Windows NT Bug : 186647 - use new defaults
#define DEFAUTHPORT				1812
#define DEFACCTPORT				1813

#define MAXSCORE				30
#define INCSCORE				3
#define DECSCORE				2
#define MINSCORE				0

typedef struct RadiusServer
	{
	TCHAR				szName[MAX_PATH+1];		// Name of radius server
	TCHAR				wszSecret[MAX_PATH+1];	// secret password use to encrypt packets
	ULONG				cchSecret;				// # of characters in secret

	SOCKADDR_IN			IPAddress;				// IP Address of radius server
	struct timeval		Timeout;				// recv timeout in seconds
	DWORD				cRetries;				// number of times to retry sending packets to server
	INT					cScore;					// Score indicating functioning power of server.
	DWORD				AuthPort;				// Authentication port number
	DWORD				AcctPort;				// Accounting port number
//	BOOL				fAuthentication;		// Enable authentication
//	BOOL				fAccounting;			// Enable accounting
	BOOL				fAccountingOnOff;		// Enable accounting On/Off messages
	BYTE				bIdentifier;			// Unique ID for packet
	LONG				lPacketID;				// Global Packet ID across all servers
    BOOL                fUseDigitalSignatures;  // Enable Digital Signatures
	struct RadiusServer	*pNext;					// Pointer to next radius server in linked list


	DWORD				dwUnique;				// unique id (used by the UI)
												// this is not persistent!
	UCHAR				ucSeed;					// seed value for RtlEncode

    // This should be kept in sync with what is in radcfg.cpp
    void                UseDefaults();

    BOOL                fPersisted;             // was entry persisted?
    
	} RADIUSSERVER, *PRADIUSSERVER;
	

class CRadiusServers
	{
public:
	CRadiusServers();
	~CRadiusServers();

	// dwUnique specifies the server to insert before
	// dwUnique == 0, is add it to the head of the list
	// dwUnique == -1, means add it to the tail
	DWORD			AddServer(RADIUSSERVER *pRadiusServer,
							 LONG_PTR dwUnique);
	VOID			ValidateServer(RADIUSSERVER *pServer,
								   BOOL fResponding);
	DWORD			DeleteServer(LONG_PTR dwUnique, BOOL fRemoveLSAEntry);
	RADIUSSERVER *	GetNextServer(BOOL fFirst);
	VOID			MoveServer(LONG_PTR dwUnique, BOOL fUp);
    BOOL            FindServer(LPCTSTR pszServerName, RADIUSSERVER **ppServer);
    BOOL            FindServer(DWORD dwUnique, RADIUSSERVER **ppServer);

    // Operations for deleted servers
    RADIUSSERVER *  GetFirstDeletedServer()
    {
        return m_pDeletedServers;
    }
    
    void            AddToDeletedServerList(RADIUSSERVER *pServer);
    void            ClearDeletedServerList(LPCTSTR pszServerName);
    

    void            FreeAllServers();
		
private:
	RADIUSSERVER *	m_pServerList;		// Linked list of valid radius servers
	RADIUSSERVER *	m_pCurrentServer;	// Last server request was sent to
	CRITICAL_SECTION	m_cs;		// used to prevent multiple access to variables of this class

	DWORD			m_dwUnique;			// incremented each time AddServer
										// is called

    RADIUSSERVER *  m_pDeletedServers;  // Linked list of deleted servers
    };
	
#endif // _RADBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\raputil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/
#include <stdafx.h>
#include <sdoias.h>
#include "raputil.h"



//////////
// Extract an interface pointer from a VARIANT struct.
//////////
HRESULT
GetInterfaceFromVariant(
    IN VARIANT *var,
    IN REFIID riid,
    OUT PVOID *ppv
    )
{
    HRESULT hr;
    
    // Check the parameters.
    if (!var || !ppv) { return E_POINTER; }
    
    // Switch based on the VARIANT type.
    switch (V_VT(var))
    {
        case VT_UNKNOWN:
            hr = V_UNKNOWN(var)->QueryInterface(riid, ppv);
            break;
            
        case VT_DISPATCH:
            hr = V_DISPATCH(var)->QueryInterface(riid, ppv);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
    }
    
   return hr;
}

//////////
// Removes an integer value from a SAFEARRAY of VARIANTs.
//////////
HRESULT
RemoveIntegerFromArray(
    IN VARIANT* array,
    IN LONG value
    )
{
    VARIANT *begin, *end, *i;
    
    // Check the parameters.
    if (!array)
    {
        return E_POINTER;
    }
    else if (V_VT(array) == VT_EMPTY)
    {
        // If the VARIANT is empty, then the value doesn't exists, so there's
        // nothing to do.
        return S_OK;
    }
    else if (V_VT(array) != (VT_ARRAY | VT_VARIANT))
    {
        // The VARIANT doesn't contain a SAFEARRAY of VARIANTs.
        return DISP_E_TYPEMISMATCH;
    }
    
    // Compute the beginning and end of the array data.
    begin = (VARIANT*)V_ARRAY(array)->pvData;
    end = begin + V_ARRAY(array)->rgsabound[0].cElements;
    
    // Search for the value to be removed.
    for (i = begin; i != end && V_I4(i) != value; ++i)
    {
        if (V_VT(i) == VT_I4 && V_I4(i) == value)
        {
            // We found a match, so remove it from the array ...
            memmove(i, i + 1, ((end - i) - 1) * sizeof(VARIANT));
            
            // ... and decrement the number of elements.
            --(V_ARRAY(array)->rgsabound[0].cElements);
            
            // We don't allow duplicates, so we're done.
            break;
        }
    }
    
    return S_OK;
}

//////////
// Adds an integer value to a SAFEARRAY of VARIANTs.
//////////
HRESULT
AddIntegerToArray(
    IN VARIANT *array,
    IN LONG value
    )
{
    ULONG nelem;
    VARIANT *begin, *end, *i;
    SAFEARRAY* psa;
    
    // Check the parameters.
    if (!array)
    {
        return E_POINTER;
    }
    else if (V_VT(array) == VT_EMPTY)
    {
        // The VARIANT is empty, so create a new array.
        psa = SafeArrayCreateVector(VT_VARIANT, 0, 1);
        if (!psa) { return E_OUTOFMEMORY; }
        
        // Set the value of the lone element.
        i = (VARIANT*)psa->pvData;
        V_VT(i) = VT_I4;
        V_I4(i) = value;
        
        // Store the SAFEARRAY in the VARIANT.
        V_VT(array) = (VT_ARRAY | VT_VARIANT);
        V_ARRAY(array) = psa;
        
        return S_OK;
    }
    else if (V_VT(array) != (VT_ARRAY | VT_VARIANT))
    {
        // The VARIANT doesn't contain a SAFEARRAY of VARIANTs.
        return DISP_E_TYPEMISMATCH;
    }
    
    // Compute the beginning and end of the array data.
    nelem = V_ARRAY(array)->rgsabound[0].cElements;
    begin = (VARIANT*)V_ARRAY(array)->pvData;
    end = begin + nelem;
    
    // See if the value already exists, ...
    for (i = begin; i != end; ++i)
    {
        if (V_I4(i) == value)
        {
            // ... and if it does, then there's nothing to do.
            return S_OK;
        }
    }
    
    // Create a new array with enough room for the new element.
    psa = SafeArrayCreateVector(VT_VARIANT, 0, nelem + 1);
    if (!psa) { return E_OUTOFMEMORY; }
    i = (VARIANT*)psa->pvData;
    
    // Copy in the old data.
    memcpy(i + 1, begin, nelem * sizeof(VARIANT));
    
    // Add the new element.
    V_VT(i) = VT_I4;
    V_I4(i) = value;
    
    // Destroy the old array ...
    SafeArrayDestroy(V_ARRAY(array));
    
    // ... and save the new one.
    V_ARRAY(array) = psa;
    
    return S_OK;
}

//////////
// Create a machine SDO and attach to the local machine.
//////////
HRESULT
OpenMachineSdo(
    IN LPWSTR wszMachineName,
    OUT ISdoMachine **ppMachine
    )
{
    HRESULT hr;
    USES_CONVERSION;
    
    // Check the parameters.
    if (!ppMachine) { return E_POINTER; }
    
    // Create the SdoMachine object.
    hr = CoCreateInstance(
                          CLSID_SdoMachine,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISdoMachine,
                          (PVOID*)ppMachine
                         );
    if (SUCCEEDED(hr))
    {
        // Attach to the local machine.
        BSTR	bstrMachineName = W2BSTR(wszMachineName);
        hr = (*ppMachine)->Attach(bstrMachineName);
        if (FAILED(hr))
        {
            // We couldn't attach, so don't return the SDO to the caller.
            (*ppMachine)->Release();
            ppMachine = NULL;
        }

        SysFreeString(bstrMachineName);
    }
    
    
    return hr;
}

//////////
// Given a machine SDO and a service name, retrieve the service SDO.
//////////
HRESULT
OpenServiceSDO(
    IN ISdoMachine *pMachine,
    IN LPWSTR wszServiceName,
    OUT ISdo **ppService
    )
{
    HRESULT     hr;
    IUnknown*   pUnk;
    BSTR        bstrServiceName = NULL;

    // Create a BSTR for the service name
    bstrServiceName = SysAllocString(wszServiceName);
    if (bstrServiceName == NULL)
        return E_OUTOFMEMORY;
    
    // Check the parameters.
    if (!pMachine || !ppService) { return E_POINTER; }
    
    // Retrieve the service SDO ...
    hr = pMachine->GetServiceSDO(
                                 DATA_STORE_LOCAL,
                                 bstrServiceName,
                                 &pUnk
                                );
    if (SUCCEEDED(hr))
    {
        // ... and query for the ISdo interface.
        hr = pUnk->QueryInterface(IID_ISdo, (PVOID*)ppService );
        pUnk->Release();
    }

    SysFreeString(bstrServiceName);
    
    return hr;
}

//////////
// Given a machine SDO, retrieve the dictionary SDO.
//////////
HRESULT
OpenDictionarySDO(
    IN ISdoMachine *pMachine,
    OUT ISdoDictionaryOld **ppDictionary
    )
{
    HRESULT hr;
    IUnknown* pUnk;
    
    // Check the parameters.
    if (!ppDictionary) { return E_POINTER; }
    
    // Get the dictionary SDO ...
    hr = pMachine->GetDictionarySDO(&pUnk);
    if (SUCCEEDED(hr))
    {
        // ... and query for the ISdoDictionaryOld interface.
        hr = pUnk->QueryInterface(IID_ISdoDictionaryOld,
                                  (PVOID*)ppDictionary
                                 );

        pUnk->Release();
    }
    
    return hr;
}

//////////
// Given a parent SDO, retrieve a child SDO with the given property ID.
//////////
HRESULT
OpenChildObject(
    IN ISdo *pParent,
    IN LONG lProperty,
    IN REFIID riid,
    OUT PVOID *ppv
    )
{
    HRESULT hr;
    VARIANT val;
    
    // Check the parameters.
    if (!pParent || !ppv) { return E_POINTER; }
    
    // ISdo::GetProperty requires the out parameters to be initialized.
    VariantInit(&val);
    
    // Get the property corresponding to the child object ...
    hr = pParent->GetProperty(
                              lProperty,
                              &val
                             );
    if (SUCCEEDED(hr))
    {
        // ... and convert it to the desired interface.
        hr = GetInterfaceFromVariant(
                                     &val,
                                     riid,
                                     ppv
                                    );
        
        VariantClear(&val);
    }
    
    return hr;
}

//////////
// Given a service SDO, retrieve the default profile. If more than one profile
// exists, this function returns ERROR_NO_DEFAULT_PROFILE.
//////////
HRESULT
GetDefaultProfile(
    IN ISdo* pService,
    OUT ISdo** ppProfile
    )
{
    HRESULT hr;
    ISdoCollection* pProfiles;
    LONG count;
    ULONG   ulCount;
    IUnknown* pUnk;
    IEnumVARIANT* pEnum;
    VARIANT val;
    
    // Check the parameters.
    if (!pService || !ppProfile) { return E_POINTER; }
    
    // Null this out, so we can safely release it on exit.
    pProfiles = NULL;
    
    do
    {
        // Get the profiles collection, which is a child of the service SDO.
        hr = OpenChildObject(
                             pService,
                             PROPERTY_IAS_PROFILES_COLLECTION,
                             IID_ISdoCollection,
                             (PVOID*)&pProfiles
                            );
        if (FAILED(hr)) { break; }
        
        // How many profiles are there?
        hr = pProfiles->get_Count(
                                  &count
                                 );
        if (FAILED(hr)) { break; }
        
        // If there's more than one, then there's no default.
        if (count != 1)
        {
            hr = ERROR_NO_DEFAULT_PROFILE;
            break;
        }
        
        // Get an enumerator for the collection.
        hr = pProfiles->get__NewEnum(
                                     &pUnk
                                    );
        if (FAILED(hr)) { break; }
        hr = pUnk->QueryInterface(
                                  IID_IEnumVARIANT,
                                  (PVOID*)&pEnum
                                 );
        pUnk->Release();
        if (FAILED(hr)) { break; }
        
        // Get the first (and only) object in the collection.
        VariantInit(&val);
        hr = pEnum->Next(
                         1,
                         &val,
                         &ulCount
                        );
        if (SUCCEEDED(hr))
        {
            if (ulCount == 1)
            {
                // Get the ISdo interface for the default profile.
                hr = GetInterfaceFromVariant(
                                             &val,
                                             IID_ISdo,
                                             (PVOID*)ppProfile
                                            );
                
                VariantClear(&val);
            }
            else
            {
                // This should never happen since we already checked the count.
                hr = ERROR_NO_DEFAULT_PROFILE;
            }

            pEnum->Release();
        }
        
    } while (FALSE);
    
    // Release the Profiles collection.
    if (pProfiles) { pProfiles->Release(); }
    
    return hr;
}

//////////
// Get a particular attribute SDO from the collection. If the attribute doesn't
// exist and pDictionary is non-NULL, then a new attribute will be created.
//////////
HRESULT
GetAttribute(
    IN ISdoCollection *pAttributes,
    IN OPTIONAL ISdoDictionaryOld *pDictionary,
    IN PCWSTR wszName,
    OUT ISdo **ppAttribute
    )
{
    HRESULT hr;
    VARIANT key;
    IDispatch* pDisp;
    ATTRIBUTEID attrId;
    
    // Check the parameters
    if (!pAttributes || !ppAttribute) { return E_POINTER; }
    
    // Create a VARIANT key to look up the attribute.
    VariantInit(&key);
    V_VT(&key) = VT_BSTR;
    V_BSTR(&key) = SysAllocString(wszName);
    if (!V_BSTR(&key)) { return E_OUTOFMEMORY; }
    
    // Retrieve the desired attribute.
    hr = pAttributes->Item(
                             &key,
                             &pDisp
                            );
    
    // If it doesn't exist and me have a dictionary, create a new attribute.
    if (hr == DISP_E_MEMBERNOTFOUND && pDictionary)
    {
        // Look up the attribute ID.
        hr = pDictionary->GetAttributeID(
                                         V_BSTR(&key),
                                         &attrId
                                        );
        if (SUCCEEDED(hr))
        {
            // Create an attribute SDO.
            hr = pDictionary->CreateAttribute(
                                              attrId,
                                              &pDisp
                                             );
            if (SUCCEEDED(hr))
            {
                // Add it to the attributes collection.
                hr = pAttributes->Add(
                                      V_BSTR(&key),
                                      &pDisp
                                     );
                if (FAILED(hr))
                {
                    // If we couldn't add it, then release the object.
                    pDisp->Release();
                }
            }
        }
    }
    
    // If we successfully retrieved or created an attribute, then get it's
    // ISdo interface.
    if (SUCCEEDED(hr))
    {
        hr = pDisp->QueryInterface(
                                   IID_ISdo,
                                   (PVOID*)ppAttribute
                                  );
        pDisp->Release();
    }
    
    // We're done with the key.
    VariantClear(&key);
    
    return hr;
}

//////////
// Sets/Adds a single-valued integer attribute in a profile.
//////////
HRESULT
SetIntegerAttribute(
    IN ISdoCollection *pAttributes,
    IN OPTIONAL ISdoDictionaryOld *pDictionary,
    IN LPWSTR wszName,
    IN LONG lValue
    )
{
    HRESULT hr;
    ISdo *pAttribute;
    VARIANT val;
    
    // Get the attribute SDO.
    hr = GetAttribute(
                      pAttributes,
                      pDictionary,
                      wszName,
                      &pAttribute
                     );
    if (SUCCEEDED(hr))
    {
        // Initialize the attribute value ...
        VariantInit(&val);
        V_VT(&val) = VT_I4;
        V_I4(&val) = lValue;
        
        // ... and set the value property.
        hr = pAttribute->PutProperty(
                                     PROPERTY_ATTRIBUTE_VALUE,
                                     &val
                                    );

        pAttribute->Release();
    }
    
    return hr;
}

HRESULT
SetBooleanAttribute (
    IN ISdoCollection *pAttributes,
    IN OPTIONAL ISdoDictionaryOld *pDictionary,
    IN LPWSTR wszName,
    IN BOOL lValue
    )
{
    HRESULT hr;
    ISdo *pAttribute;
    VARIANT val;
    
    // Get the attribute SDO.
    hr = GetAttribute(
                      pAttributes,
                      pDictionary,
                      wszName,
                      &pAttribute
                     );
    if (SUCCEEDED(hr))
    {
        // Initialize the attribute value ...
        VariantInit(&val);
        V_VT(&val) = VT_BOOL;
        V_BOOL(&val) = (VARIANT_BOOL)lValue;
        
        // ... and set the value property.
        hr = pAttribute->PutProperty(
                                     PROPERTY_ATTRIBUTE_VALUE,
                                     &val
                                    );

        pAttribute->Release();
    }
    
    return hr;
}

HRESULT  SetDialinSetting(	IN ISdoCollection *pAttributes,
							IN OPTIONAL ISdoDictionaryOld *pDictionary,
							BOOL fDialinAllowed)
{
   long						ulCount;
   ULONG					ulCountReceived;
   HRESULT					hr = S_OK;

   CComBSTR					bstr;
   CComPtr<IUnknown>		spUnknown;
   CComPtr<IEnumVARIANT>	spEnumVariant;
   CComPtr<ISdoDictionaryOld> spDictionarySdo(pDictionary);
   CComVariant				var;

   //
    // get the attribute collection of this profile
    //
   CComPtr<ISdoCollection> spProfAttrCollectionSdo ( pAttributes );

   // We check the count of items in our collection and don't bother getting the
   // enumerator if the count is zero.
   // This saves time and also helps us to a void a bug in the the enumerator which
   // causes it to fail if we call next when it is empty.
   hr = spProfAttrCollectionSdo->get_Count( & ulCount );
   if ( FAILED(hr) )
   {
	   return hr;
   }


   if ( ulCount > 0)
   {
      // Get the enumerator for the attribute collection.
      hr = spProfAttrCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
      if ( FAILED(hr) )
      {
			return hr;
      }

      hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
      spUnknown.Release();
      if ( FAILED(hr) )
      {
		  return hr;
      }

      // Get the first item.
      hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
      while( SUCCEEDED( hr ) && ulCountReceived == 1 )
      {
         // Get an sdo pointer from the variant we received.

         CComPtr<ISdo> spSdo;
         hr = V_DISPATCH(&var)->QueryInterface( IID_ISdo, (void **) &spSdo );
         if ( !SUCCEEDED(hr))
         {
			return hr;
         }

            //
            // get attribute ID
            //
         var.Clear();
         hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var);
         if ( !SUCCEEDED(hr) )
         {
            return hr;
         }


         DWORD dwAttrId = V_I4(&var);
         

         if ( dwAttrId == (DWORD)IAS_ATTRIBUTE_ALLOW_DIALIN )
         {
            // found this one in the profile, check for its value
            var.Clear();
            V_VT(&var) = VT_BOOL;
            V_BOOL(&var) = fDialinAllowed ? VARIANT_TRUE: VARIANT_FALSE ;
            hr = spSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
            if ( !SUCCEEDED(hr) )
            {               
               return hr;
            }
            return S_OK;
         }

         // Clear the variant of whatever it had --
         // this will release any data associated with it.
         var.Clear();

         // Get the next item.
         hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
         if ( !SUCCEEDED(hr))
         {

            return hr;
         }
      } // while
   } // if

   // if we reach here, it means we either haven't found the attribute,
   // or the profile doesn't have anything in its attribute collection.
   if ( !fDialinAllowed )
   {
      // we don't need to do anything if dialin is allowed, becuase if this
      // attribute is not in the profile, then dialin is by default allowed

      // but we need to add this attribute to the profile if it's DENIED
            // create the SDO for this attribute
      CComPtr<IDispatch>   spDispatch;
      hr =  spDictionarySdo->CreateAttribute( (ATTRIBUTEID)IAS_ATTRIBUTE_ALLOW_DIALIN,
                                      (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         return hr;
      }


      // add this node to profile attribute collection
      hr = spProfAttrCollectionSdo->Add(NULL, (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         return hr;
      }

      //
      // get the ISdo pointer
      //
      CComPtr<ISdo> spAttrSdo;
      hr = spDispatch->QueryInterface( IID_ISdo, (void **) &spAttrSdo);
      if ( !SUCCEEDED(hr) )
      {
         return hr;
      }

            
      // set sdo property for this attribute
      CComVariant var;

      // set value
      V_VT(&var) = VT_BOOL;
      V_BOOL(&var) = VARIANT_FALSE;
            
      hr = spAttrSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
      if ( !SUCCEEDED(hr) )
      {
         return hr;
      }

      var.Clear();

   } // if (!dialinallowed)

   return hr;
}





//////////
// Update the default policy based on the specified flags.
//////////
HRESULT
UpdateDefaultPolicy(
    IN LPWSTR wszMachineName,
    IN BOOL fEnableMSCHAPv1,
    IN BOOL fEnableMSCHAPv2,
    IN BOOL fRequireEncryption
    )
{
    HRESULT hr;
    ISdoMachine *pMachine;
    ISdo *pService, *pProfile, *pAuthType;
    ISdoDictionaryOld *pDictionary;
    ISdoCollection *pAttributes;
    VARIANT val;
    
    // Initialize the local variables, so we can safely clean up on exit.
    pMachine = NULL;
    pService = pProfile = pAuthType = NULL;
    pDictionary = NULL;
    pAttributes = NULL;
    VariantInit(&val);
    
    do
    {
        hr = OpenMachineSdo(wszMachineName, &pMachine);
        if (FAILED(hr)) { break; }
        
        hr = OpenServiceSDO(pMachine, L"RemoteAccess", &pService);
        if (FAILED(hr)) { break; }
        
        hr = OpenDictionarySDO(pMachine, &pDictionary);
        if (FAILED(hr)) { break; }
        
        hr = GetDefaultProfile(pService, &pProfile);
        if (FAILED(hr)) { break; }
        
        // Get the attributes collection, which is a child of the profile.
        hr = OpenChildObject(
                             pProfile,
                             PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                             IID_ISdoCollection,
                             (PVOID*)&pAttributes
                            );
        if (FAILED(hr)) { break; }
        
        // Get the current value of the NP-Authentication-Type attribute.
        hr = GetAttribute(
                          pAttributes,
                          pDictionary,
                          L"NP-Authentication-Type",
                          &pAuthType
                         );
        if (FAILED(hr)) { break; }
        hr = pAuthType->GetProperty(
                                    PROPERTY_ATTRIBUTE_VALUE,
                                    &val
                                   );
        if (FAILED(hr)) { break; }
        
        // Update MS-CHAP v1
        if (fEnableMSCHAPv1)
        {
            hr = AddIntegerToArray(&val, 3);
        }
        else
        {
            hr = RemoveIntegerFromArray(&val, 3);
        }
        if (FAILED(hr)) { break; }
        
        // Update MS-CHAP v2
        if (fEnableMSCHAPv2)
        {
            hr = AddIntegerToArray(&val, 4);
        }
        else
        {
            hr = RemoveIntegerFromArray(&val, 4);
        }
        if (FAILED(hr)) { break; }
        
        // Write the new value back to the attribute.
        hr = pAuthType->PutProperty(
                                    PROPERTY_ATTRIBUTE_VALUE,
                                    &val
                                   );
        if (FAILED(hr)) { break; }
        

        // Update the encryption attributes if necessary.
        if (fRequireEncryption)
        {
            hr = SetIntegerAttribute(
                                     pAttributes,
                                     pDictionary,
                                     L"MS-MPPE-Encryption-Policy",
                                     2
                                    );
            if (FAILED(hr)) { break; }
            
            hr = SetIntegerAttribute(
                                     pAttributes,
                                     pDictionary,
                                     L"MS-MPPE-Encryption-Types",
                                     14
                                    );
            if (FAILED(hr)) { break; }
        }

		//
		//Update the default for msNPAllowDialin - This should be set
		//to deny permissions by default
		//
		hr = SetDialinSetting(pAttributes,pDictionary, FALSE);
        if (FAILED(hr)) { break; }
        
        hr = pProfile->Apply();
        
    } while (FALSE);
    
    // Clean up.
    VariantClear(&val);
    if (pAttributes)
        pAttributes->Release();
    if (pDictionary)
        pDictionary->Release();
    if (pAuthType)
        pAuthType->Release();
    if (pProfile)
        pProfile->Release();
    if (pService)
        pService->Release();
    if (pMachine)
        pMachine->Release();

    return hr;
}

#if 0
#include <stdio.h>

int __cdecl wmain(int argc, wchar_t *argv[])
{
   HRESULT hr;
   BOOL fEnableMSCHAPv1, fEnableMSCHAPv2, fRequireEncryption;

   if (argc != 4)
   {
      wprintf(L"Usage: wizard <t|f> <t|f> <t|f>\n"
              L"   1st flag: MS-CHAP v1 enabled\n"
              L"   2nd flag: MS-CHAP v2 enabled\n"
              L"   3rd flag: Encryption required\n");
      return -1;
   }

   fEnableMSCHAPv1 = argv[1][0] == 't' ? TRUE : FALSE;
   fEnableMSCHAPv2 = argv[2][0] == 't' ? TRUE : FALSE;
   fRequireEncryption = argv[3][0] == 't' ? TRUE : FALSE;

   CoInitializeEx(NULL, COINIT_MULTITHREADED);

   hr = UpdateDefaultPolicy(
            NULL,  // Machine name.
            fEnableMSCHAPv1,
            fEnableMSCHAPv2,
            fRequireEncryption
            );
   if (SUCCEEDED(hr))
   {
      wprintf(L"UpdateDefaultPolicy succeeded.\n");
   }
   else
   {
      wprintf(L"UpdateDefaultPolicy returned: 0x%08X.\n", hr);
   }

   CoUninitialize();

   return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\radcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1998 - 1999 **/
/**********************************************************************/

/*
	radcfg.h
		Header file for RADIUS config obj.
		
    FILE HISTORY:
        
*/

#include "resource.h"       // main symbols

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _RADBAL_H_
#include "radbal.h"
#endif



/*---------------------------------------------------------------------------
	Class:	RadiusServerDialog

	Class for the RADIUS authentication server dialog.
 ---------------------------------------------------------------------------*/

class RadiusServerDialog : public CBaseDialog
{
public:
	RadiusServerDialog(BOOL fAuth, UINT idsTitle);
	~RadiusServerDialog();

	void	SetServer(LPCTSTR pszServerName);
	
// Dialog Data
	//{{AFX_DATA(RadiusServerDialog)
	enum { IDD = IDD_RADIUS_AUTH };
	CListCtrl	m_ListServers;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(RadiusServerDialog)
public:
	virtual void OnOK();
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(RadiusServerDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnBtnAdd();
	afx_msg void OnBtnEdit();
	afx_msg void OnBtnDelete();
	afx_msg void OnListDblClk(NMHDR *pNMHdr, LRESULT *pResult);
	afx_msg void OnNotifyListItemChanged(NMHDR *pNMHdr, LRESULT *pResult);
//	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CRadiusServers		m_ServerList;

    // This is the other list (if this is the auth dlg, this is the acct list)
    // and vice versa.  This is used to determine if a server's LSA entry
    // needs to be removed.
    CRadiusServers      m_OtherServerList;
    
	CString				m_stServerName;
	HKEY				m_hkeyMachine;
	UINT				m_idsTitle;

	BOOL				m_fAuthDialog;	// are we looking at auth or acct?

};



/*---------------------------------------------------------------------------
	Class:	ServerPropDialog
 ---------------------------------------------------------------------------*/
class ServerPropDialog : public CBaseDialog
{
// Construction
public:
	ServerPropDialog(BOOL fEdit, CWnd* pParent = NULL);   // standard constructor
	~ServerPropDialog();

protected:
	ServerPropDialog(BOOL fEdit, UINT idd, CWnd* pParent = NULL);   // standard constructor

public:
	VOID	SetDefault(RADIUSSERVER	*pServer);
	VOID	GetDefault(RADIUSSERVER	*pServer);
		
// Dialog Data
	//{{AFX_DATA(ServerPropDialog)
	enum { IDD = IDD_RADIUS_AUTH_CONFIG };

	CEdit	m_editServerName;
	CEdit	m_editSecret;
	CEdit	m_editInterval;
	CSpinButtonCtrl	m_spinScore;
	CSpinButtonCtrl	m_spinTimeout;

	CEdit	m_editPort;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ServerPropDialog)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL	m_fEdit;			// = TRUE if editing (else we are adding)

	UINT	m_uAuthPort;
	CString	m_stSecret;
	INT		m_cchSecret;
	UCHAR	m_ucSeed;
	CString	m_stServer;
	UINT	m_uTimeout;
	int		m_iInitScore;

    BOOL    m_fUseDigitalSignatures;

	// The accounting data is also stored here (but not used)
	UINT	m_uAcctPort;
	BOOL	m_fAccountingOnOff;
	
	// Generated message map functions
	//{{AFX_MSG(ServerPropDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnBtnPassword();
//	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG


	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	Class:	RADIUSSecretDialog
 ---------------------------------------------------------------------------*/
class RADIUSSecretDialog : public CBaseDialog
{
// Construction
public:
	RADIUSSecretDialog(CWnd* pParent = NULL);   // standard constructor
	~RADIUSSecretDialog();

	VOID	GetSecret(CString *pst, INT *pch, UCHAR *pucSeed);
		
// Dialog Data
	//{{AFX_DATA(RADIUSSecretDialog)
	enum { IDD = IDD_CHANGE_SECRET };

	CEdit	m_editSecretOld;
	CEdit	m_editSecretNew;
	CEdit	m_editSecretNewConfirm;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(RADIUSSecretDialog)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	INT		m_cchOldSecret;
	CString	m_stOldSecret;
	UCHAR	m_ucOldSeed;

	INT		m_cchNewSecret;
	CString	m_stNewSecret;
	UCHAR	m_ucNewSeed;

	// Generated message map functions
	//{{AFX_MSG(RADIUSSecretDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
//	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	Class:	RouterAuthRadiusConfig

	This is the config object for RADIUS.
	
	Author: KennT
 ---------------------------------------------------------------------------*/

class RouterAuthRadiusConfig :
    public IAuthenticationProviderConfig,
    public CComObjectRoot,
    public CComCoClass<RouterAuthRadiusConfig, &CLSID_RouterAuthRADIUS>
{
public:
DECLARE_REGISTRY(RouterAuthRadiusConfig, 
				 _T("RouterAuthRadiusConfig.RouterAuthRadiusConfig.1"), 
				 _T("RouterAuthRadiusConfig.RouterAuthRadiusConfig"), 
				 IDS_RADIUS_CONFIG_DESC, 
				 THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(RouterAuthRadiusConfig)
    COM_INTERFACE_ENTRY(IAuthenticationProviderConfig) // Must have one static entry
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(RouterAuthRadiusConfig)

// these must be overridden to provide values to the base class
protected:
	
	DeclareIAuthenticationProviderConfigMembers(IMPL);
};



/*---------------------------------------------------------------------------
	Class:	RouterAcctRadiusConfig

	This is the config object for RADIUS.
	
	Author: KennT
 ---------------------------------------------------------------------------*/

class RouterAcctRadiusConfig :
    public IAccountingProviderConfig,
    public CComObjectRoot,
    public CComCoClass<RouterAcctRadiusConfig, &CLSID_RouterAcctRADIUS>
{
public:
DECLARE_REGISTRY(RouterAcctRadiusConfig, 
				 _T("RouterAcctRadiusConfig.RouterAcctRadiusConfig.1"), 
				 _T("RouterAcctRadiusConfig.RouterAcctRadiusConfig"), 
				 IDS_RADIUS_CONFIG_DESC, 
				 THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(RouterAcctRadiusConfig)
    COM_INTERFACE_ENTRY(IAccountingProviderConfig) // Must have one static entry
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(RouterAcctRadiusConfig)

// these must be overridden to provide values to the base class
protected:
	
	DeclareIAccountingProviderConfigMembers(IMPL);
};



/*---------------------------------------------------------------------------
	Class:	ServerPropAcctDialog
 ---------------------------------------------------------------------------*/
class ServerPropAcctDialog : public ServerPropDialog
{
// Construction
public:
	ServerPropAcctDialog(BOOL fEdit, CWnd* pParent = NULL);   // standard constructor
	~ServerPropAcctDialog();

// Dialog Data
	//{{AFX_DATA(ServerPropAcctDialog)
	enum { IDD = IDD_RADIUS_ACCT_CONFIG };

	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ServerPropAcctDialog)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

	// Generated message map functions
	//{{AFX_MSG(ServerPropAcctDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnBtnEnable();
//	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};




/*---------------------------------------------------------------------------
	Helper functions (for RADIUS registry access)
 ---------------------------------------------------------------------------*/

// Do not show UI when loading the RADIUS server
#define RADIUS_FLAG_NOUI    (0x00000001)

// Do not do the IP Address lookup
#define RADIUS_FLAG_NOIP    (0x00000002)

HRESULT	LoadRadiusServers(IN OPTIONAL LPCTSTR pszServerName,
						  IN	HKEY hkeyMachine,
						  IN	BOOL fAuthentication,
						  IN	CRadiusServers * pRadiusServers,
                          IN    DWORD dwFlags);

HRESULT SaveRadiusServers(IN OPTIONAL LPCTSTR pszServerName,
						  IN	HKEY	hkeyMachine,
						  IN BOOL		fAuthentication,
						  IN RADIUSSERVER *pServerRoot);

HRESULT DeleteRadiusServers(IN OPTIONAL LPCTSTR pszServerName,
                            IN RADIUSSERVER *pServerRoot);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\refrate.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    RefRate.h
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Code dealing with refresh rate
//============================================================================
//

/////////////////////////////////////////////////////////////////////////////
// CRefRateDlg dialog

class CRefRateDlg : public CBaseDialog
{
// Construction
public:
	CRefRateDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRefRateDlg)
	enum { IDD = IDD_REFRESHRATE };
	UINT	m_cRefRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRefRateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD m_dwHelpMap[];

	// Generated message map functions
	//{{AFX_MSG(CRefRateDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\refresh.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	info.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "infoi.h"
#include "rtrstr.h"			// common router strings
#include "refresh.h"
#include "dvsview.h"
#include "machine.h"
#include "rtrutilp.h"


// Number of connections that we have made, this is used to
// generate the dwConnectionId
extern long		s_cConnections;

DEBUG_DECLARE_INSTANCE_COUNTER(RefreshItem);



/*!--------------------------------------------------------------------------
	RouterObjectRefreshTimerProc
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RouterRefreshObjectTimerProc(LPARAM lParam, DWORD dwTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// The lParam passed in is a pointer to the RouterRefreshObject

	// Call through on the RouterRefreshObject to start the query
	// object
	((RouterRefreshObject *)lParam)->ExecuteRefresh();
}

/*---------------------------------------------------------------------------
	RouterRefreshObjectGroup implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(RouterRefreshObjectGroup);

RouterRefreshObjectGroup::~RouterRefreshObjectGroup()
{
	POSITION	p = NULL;
	RouterRefreshObject*	pObj = NULL;
	for(p = m_list.GetHeadPosition(); p != NULL; )
	{
		pObj = m_list.GetNext(p);
		Assert(pObj != NULL);
		pObj->SetGroup(NULL);
		pObj->Release();
	}

	m_list.RemoveAll();
    
	DEBUG_DECREMENT_INSTANCE_COUNTER(RouterRefreshObjectGroup);
}

/*!--------------------------------------------------------------------------
	RouterRefreshObjectGroup::Join
        -
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	RouterRefreshObjectGroup::Join(RouterRefreshObject* pRefresh)
{
	Assert(pRefresh);
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_list.AddTail(pRefresh);
        pRefresh->AddRef();
        pRefresh->SetGroup(this);
    }
    COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObjectGroup::Leave
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	RouterRefreshObjectGroup::Leave(RouterRefreshObject* pRefresh)
{
	POSITION p = m_list.Find(pRefresh);

	if (p)
	{
		Assert(pRefresh == m_list.GetAt(p));	
		m_list.RemoveAt(p);
		pRefresh->SetGroup(NULL);
		pRefresh->Release();	
	}

	return S_OK;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObjectGroup::Refresh
        call each member in the group to DoRefresh
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	RouterRefreshObjectGroup::Refresh()
{
	POSITION	p = NULL;
	RouterRefreshObject*	pObj = NULL;
	for(p = m_list.GetHeadPosition(); p != NULL; )
	{
		pObj = m_list.GetNext(p);
		Assert(pObj != NULL);
		pObj->DoRefresh();
	}

	return S_OK;
}

/*---------------------------------------------------------------------------
	RouterRefreshObject implementation
 ---------------------------------------------------------------------------*/

IMPLEMENT_ADDREF_RELEASE(RouterRefreshObject);

DEBUG_DECLARE_INSTANCE_COUNTER(RouterRefreshObject);

STDMETHODIMP RouterRefreshObject::QueryInterface(REFIID iid,void **ppv)
{ 
	*ppv = 0; 
	if (iid == IID_IUnknown)
		*ppv = (IUnknown *) (IRouterRefresh *) this;
	else if (iid == IID_IRouterRefresh)
		*ppv = (IRouterRefresh *) this;
    else if (iid == IID_IRouterRefreshModify)
        *ppv = (IRouterRefreshModify *) this;
	else
		return ThreadHandler::QueryInterface(iid, ppv);
	
	((IUnknown *) *ppv)->AddRef(); 
	return hrOK;
}


RouterRefreshObject::RouterRefreshObject(HWND hWndSync)
	: m_hWndSync(hWndSync),
	m_dwSeconds(DEFAULT_REFRESH_INTERVAL),
	m_iEventId(-1),
	m_pRefreshGroup(NULL),
	m_fStarted(FALSE),
	m_fInRefresh(FALSE)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(RouterRefreshObject);
	InitializeCriticalSection(&m_critsec);
}

RouterRefreshObject::~RouterRefreshObject()
{
	// Shut down the timer if its started
	Stop();

	DEBUG_DECREMENT_INSTANCE_COUNTER(RouterRefreshObject);

	DeleteCriticalSection(&m_critsec);
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::GetRefreshInterval
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::GetRefreshInterval(DWORD *pdwSeconds)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;

	if (pdwSeconds == NULL)
		return E_INVALIDARG;
	
	COM_PROTECT_TRY
	{
		if (pdwSeconds)
			*pdwSeconds = m_dwSeconds;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::GetRefreshInterval
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::SetRefreshInterval(DWORD dwSeconds)
{
	HRESULT	hr = hrOK;
	if (IsRefreshStarted() == hrOK)
	{
		Stop();
		Start(dwSeconds);
	}
	else
	{
		RtrCriticalSection	rtrCritSec(&m_critsec);
		m_dwSeconds = dwSeconds;
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::IsInRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::IsInRefresh()
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		hr = (m_fInRefresh) ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::Refresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::Refresh()
{
	if (m_pRefreshGroup)
	{
		return m_pRefreshGroup->Refresh();
	}
	else
	{
		return DoRefresh();
	}
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::DoRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterRefreshObject::DoRefresh()
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		// If we are in a refresh cycle, return hrOK
		if (m_fInRefresh)
			goto Error;

		// If we are not in a refresh cycle, then we start one
		ExecuteRefresh();


		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::Start
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::Start(DWORD dwSeconds)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		// If we are already started then end
		if (m_fStarted)
			goto Error;

		// Start the timer going
		m_fStarted = TRUE;
		m_dwSeconds = dwSeconds;
		m_iEventId = g_timerMgr.AllocateTimer(RouterRefreshObjectTimerProc,
											  (LPARAM) this,
											  dwSeconds * 1000);
		if (m_iEventId == -1)
		{
			m_fStarted = FALSE;
			hr = HRESULT_FROM_WIN32(::GetLastError());
		}
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::Stop
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::Stop()
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (!m_fStarted)
		{
			Assert(m_iEventId == -1);
			goto Error;
		}

		// Stop the timer
		if (m_iEventId != -1)
			g_timerMgr.FreeTimer(m_iEventId);
		m_iEventId = -1;

		ReleaseThreadHandler();
		WaitForThreadToExit();
		
		m_fStarted = FALSE;

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::IsRefreshStarted
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::IsRefreshStarted()
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		hr = m_fStarted ? hrOK : hrFalse;
		Assert((m_fStarted == FALSE) || (m_iEventId != -1));
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::AdviseRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::AdviseRefresh(IRtrAdviseSink *pRtrAdviseSink,
												LONG_PTR *pdwConnection,
												LPARAM lUserParam)
{
	Assert(pRtrAdviseSink);
	Assert(pdwConnection);

	RtrCriticalSection	rtrCritSec(&m_critsec);
	DWORD	dwConnId;
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		dwConnId = (DWORD) InterlockedIncrement(&s_cConnections);

		CORg( m_AdviseList.AddConnection(pRtrAdviseSink, dwConnId, lUserParam) );
		
		*pdwConnection = dwConnId;

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::AddRouter
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::AddRouterObject(REFIID riid, IUnknown *pUnk)
{
	HRESULT	hr = S_OK;
    IRouterInfo *   pRouterInfo;

    if (riid != IID_IRouterInfo)
        return E_NOINTERFACE;

    pRouterInfo = reinterpret_cast<IRouterInfo *>(pUnk);

    COM_PROTECT_TRY
    {    
		CRouterInfoRefreshItem* pRefreshItem =
                                    new CRouterInfoRefreshItem(pRouterInfo);

        if (pRefreshItem)
        {
            // check for duplicates
            if (S_FALSE == m_listElements.AddRefreshItem(pRefreshItem))
                delete pRefreshItem;
        }
    }
    COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::RemoveRouterObject
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::RemoveRouterObject(REFIID riid, IUnknown *pUnk)
{
    if (riid != IID_IRouterInfo)
        return E_NOINTERFACE;
    
    IRouterInfo * pRouterInfo = reinterpret_cast<IRouterInfo *>(pUnk);
    
	CRouterInfoRefreshItem	RefreshItem(pRouterInfo);

	return m_listElements.RemoveRefreshItem(RefreshItem);
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::AddStatusNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterRefreshObject::AddStatusNode(DomainStatusHandler* pStatusHandler, ITFSNode *pServerNode)
{
	HRESULT	hr = S_OK;

    COM_PROTECT_TRY
    {
		CStatusNodeRefreshItem* pRefreshItem = new CStatusNodeRefreshItem(pStatusHandler, pServerNode);

		if (pRefreshItem)
		{
            // Check for duplicates
			if (S_FALSE == m_listElements.AddRefreshItem(pRefreshItem))
				delete pRefreshItem;
		}
    }
    COM_PROTECT_CATCH;
    
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::RemoveRouter
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterRefreshObject::RemoveStatusNode(ITFSNode *pServerNode)
{
	CStatusNodeRefreshItem	RefreshItem((DomainStatusHandler *)0x1, pServerNode);

	return m_listElements.RemoveRefreshItem(RefreshItem);
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::NotifyRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::NotifyRefresh()
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_AdviseList.NotifyChange(ROUTER_REFRESH, 0, 0);
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::UnadviseRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RouterRefreshObject::UnadviseRefresh(LONG_PTR dwConnection)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		hr = m_AdviseList.RemoveConnection(dwConnection);
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	RouterRefreshObject::ExecuteRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RouterRefreshObject::ExecuteRefresh()
{
	SPITFSQueryObject	spQuery;
	RouterRefreshQueryObject *	pQuery;

//  Trace0("Refresh started\n");
	
	if (m_fInRefresh)
		return;
	
	m_fInRefresh = TRUE;
	
	// Create the Query Object
	pQuery = new RouterRefreshQueryObject;
	spQuery = pQuery;

	pQuery->Init(&m_listElements);

	// Need to start the background thread
	Verify( StartBackgroundThread(NULL, m_hWndSync, spQuery) );
	
}

HRESULT RouterRefreshObject::OnNotifyError(LPARAM lParam)
{
	return hrOK;
}

HRESULT RouterRefreshObject::OnNotifyHaveData(LPARAM lParam)
{
	LONG_PTR 							RefreshItemKey  = (LONG_PTR)lParam;
	RouterRefreshQueryElement* 			pCur = NULL;
	SPRouterRefreshQueryElement		 	spPre;
	HRESULT								hr = S_OK;

	// notify every one on the list, till lParam == Key of the refresh item 
	// enumerate and call TryNotify ...
	if (RefreshItemKey)
	{
		do
        {
            pCur = m_listElements.Next(spPre);
            if (pCur)
                pCur->TryNotifyQueryResult();

			spPre.Free();
			spPre = pCur;
		} while(pCur && pCur->GetRefreshItem()->GetKey() != RefreshItemKey);
	}
	return hrOK;
}

HRESULT RouterRefreshObject::OnNotifyExiting(LPARAM lParam)
{
//  Trace0("RouterRefreshObject::OnNotifyExiting()\n");
	
	// need to do the various actions at this point
	// Merge the tree with the already existing tree
	IRouterInfo* 	pRouter = (IRouterInfo*)lParam;
	SPRouterRefreshQueryElement		 	spPre;
	RouterRefreshQueryElement* 			pCur = NULL;
	HRESULT			hr = S_OK;

	// notify every one on the list, till lParam == IRouterInfo* 
	// enumerate and call TryNotify ...
	do
	{
		pCur = m_listElements.Next(spPre);
		if (pCur)
			pCur->TryNotifyQueryResult();

		spPre.Free();
		spPre = pCur;
	} while(pCur);

	// Now notify all of the registered handlers
	NotifyRefresh();
	
	ReleaseThreadHandler();
	WaitForThreadToExit();
		
	m_fInRefresh = FALSE;
	return hrOK;
}


/*!--------------------------------------------------------------------------
	RtrRefreshTimerProc
		This is used by the CTimerMgr as its callback proc.  We then call
		the Refresh code.
	Author: KennT
 ---------------------------------------------------------------------------*/
void CALLBACK RtrRefreshTimerProc(HWND hWnd, UINT uMsg, UINT_PTR nIdEvent,
								  DWORD dwTime)
{
	RtrCriticalSection	rtrCritSec(&g_timerMgr.m_critsec);

	CTimerDesc *pDesc = g_timerMgr.GetTimerDesc(nIdEvent);
	if (pDesc)
	{
		(*(pDesc->refreshProc))(pDesc->lParam, dwTime);
	}		
}



/*---------------------------------------------------------------------------
	Global variable:	g_timerMgr
 ---------------------------------------------------------------------------*/
CTimerMgr	g_timerMgr;

DEBUG_DECLARE_INSTANCE_COUNTER(CTimerMgr);


/*!--------------------------------------------------------------------------
	CTimerMgr::CTimerMgr
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
CTimerMgr::CTimerMgr()
{
	InitializeCriticalSection(&m_critsec);
}

/*!--------------------------------------------------------------------------
	CTimerMgr::~CTimerMgr
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
CTimerMgr::~CTimerMgr()
{
    CTimerDesc * pTimerDesc;

    for (int i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimerId != 0)
            FreeTimer(i);

        delete pTimerDesc;
    }
	DeleteCriticalSection(&m_critsec);
}

/*!--------------------------------------------------------------------------
	CTimerMgr::AllocateTimer
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CTimerMgr::AllocateTimer
(
	REFRESHPROC		RefreshProc,
	LPARAM			lParam,
	UINT			uTimerInterval
)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);

    CTimerDesc * pTimerDesc = NULL;

    // look for an empty slot
    for (int i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimerId == 0)
            break;
    }

    // did we find one?  if not allocate one
    if (i < 0)
    {
        pTimerDesc = new CTimerDesc;
		pTimerDesc->lParam = 0;
		pTimerDesc->uTimerInterval = 0;
		pTimerDesc->refreshProc = NULL;
		pTimerDesc->uTimerId = 0;
		
        Add(pTimerDesc);
        i = GetUpperBound();
    }
    
    pTimerDesc->uTimerId = SetTimer(NULL, 0, uTimerInterval, RtrRefreshTimerProc);
    if (pTimerDesc->uTimerId == 0)
        return -1;

	pTimerDesc->lParam = lParam;
	pTimerDesc->uTimerInterval = uTimerInterval;
	pTimerDesc->refreshProc = RefreshProc;
 
    return i;
}

/*!--------------------------------------------------------------------------
	CTimerMgr::FreeTimer
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CTimerMgr::FreeTimer
(
    int uEventId
)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);

    CTimerDesc * pTimerDesc;

    Assert(uEventId <= GetUpperBound());
    if (uEventId > GetUpperBound())
        return;

    pTimerDesc = GetAt(uEventId);
    ::KillTimer(NULL, pTimerDesc->uTimerId);

	pTimerDesc->lParam = 0;
	pTimerDesc->uTimerId = 0;
	pTimerDesc->uTimerInterval = 0;
	pTimerDesc->refreshProc = NULL;
}

/*!--------------------------------------------------------------------------
	CTimerMgr::GetTimerDesc
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
CTimerDesc *
CTimerMgr::GetTimerDesc
(
    INT_PTR uTimerId
)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);

    CTimerDesc * pTimerDesc;

    for (int i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimerId == (UINT) uTimerId)
            return pTimerDesc;
    }

    return NULL;
}

/*!--------------------------------------------------------------------------
	CTimerMgr::ChangeInterval
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CTimerMgr::ChangeInterval
(
    int     uEventId,
    UINT    uNewInterval
)
{
	RtrCriticalSection	rtrCritSec(&m_critsec);

    Assert(uEventId <= GetUpperBound());
    if (uEventId > GetUpperBound())
        return;

    CTimerDesc   tempTimerDesc;
    CTimerDesc * pTimerDesc;

    pTimerDesc = GetAt(uEventId);

    // kill the old timer
    ::KillTimer(NULL, pTimerDesc->uTimerId);

    // set a new one with the new interval
    pTimerDesc->uTimerId = ::SetTimer(NULL, 0, uNewInterval, RtrRefreshTimerProc);
}



/*---------------------------------------------------------------------------
	RouterRefreshQueryObject implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(RouterRefreshQueryObject);

RouterRefreshQueryObject::RouterRefreshQueryObject()
{
}

STDMETHODIMP RouterRefreshQueryObject::Execute()
{
	// for each router info in the queue, run load
	// after each load of router info, post message
	// WM_HIDDENWND_INDEX_HAVEDATA
	SPRouterRefreshQueryElement		 	spPre;
	RouterRefreshQueryElement* 			pCur = NULL;
	HRESULT			hr = S_OK;

	// notify every one on the list, till lParam == IRouterInfo* 
	// enumerate and call TryNotify ...
	Assert(m_plistElements);
	do
	{
		pCur = m_plistElements->Next(spPre);
		if (pCur)
			pCur->DoQuery(m_hHiddenWnd, m_uMsgBase, m_spHandler);

		spPre.Free();
		spPre = pCur;
	}while(pCur);

	return hrFalse;
}

STDMETHODIMP RouterRefreshQueryObject::OnThreadExit()
{
	::PostMessage(m_hHiddenWnd, m_uMsgBase + WM_HIDDENWND_INDEX_EXITING,
				  (WPARAM)(ITFSThreadHandler *)m_spHandler, 0);
//  Trace0("Exiting RouterRefreshQueryObject::Execute()\n");
	return hrOK;
}



//=========================================
// CRouterInfoRefreshItem implementation
//

DEBUG_DECLARE_INSTANCE_COUNTER(CRouterInfoRefreshItem);

/*!--------------------------------------------------------------------------
	CRouterInfoRefreshItem::NotifyQueryResult
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	CRouterInfoRefreshItem::NotifyQueryResult()
{
	// get the flag to see if need to notify, if not return S_FALSE
//  TRACE(_T("\nAUTOREFRESH!!RouterInfoRefreshItem!!Merge on %8x\n"), GetKey());
	// need to do the various actions at this point
	// Merge the tree with the already existing tree
	HRESULT hr = S_OK;
	m_cs.Lock();

    COM_PROTECT_TRY
    {
        hr = m_pRouter->Merge(m_spRouterNew);
        m_spRouterNew->DoDisconnect();
    }
    COM_PROTECT_CATCH;
    
	m_cs.Unlock();

	return hr;
};


/*!--------------------------------------------------------------------------
	CRouterInfoRefreshItem::DoQuery
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	CRouterInfoRefreshItem::DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler)	// this happens in background worker thread
{
//  TRACE(_T("\nAUTOREFRESH!!RouterInfoRefreshItem!!Do query on %8x\n"), GetKey());
	// create new RouterInfo, if newRouterInfo is NULL
	// Create the dummy router info
	HRESULT	hr = S_OK;

	m_cs.Lock();

    COM_PROTECT_TRY
    {
		if (!m_spRouterNew)
			hr = CreateRouterInfo(&m_spRouterNew, NULL, m_pRouter->GetMachineName());

		// do query on newRouterInfo
		Assert(m_pRouter);
		if (hr == S_OK)
        {
			TransferCredentials ( m_pRouter, m_spRouterNew );
			m_pRouter->DoDisconnect();
			hr = m_spRouterNew->Load(m_pRouter->GetMachineName(), NULL);

        }
    }
    COM_PROTECT_CATCH;

	m_cs.Unlock();
	
	return hr; 
};


//=========================================
// CMachineNodeDataRefreshItem implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CStatusNodeRefreshItem);

CStatusNodeRefreshItem::CStatusNodeRefreshItem(DomainStatusHandler* pStatusHandler, ITFSNode *pServerNode)
		: 	m_pNode(pServerNode) , 
			m_pStatusHandler(pStatusHandler),
			m_pData(NULL)
{ 
	Assert(pStatusHandler);
	Assert(pServerNode);

	DMVNodeData     *pData;
	MachineNodeData *pMachineData;
    
    pData = GET_DMVNODEDATA(m_pNode);
    Assert(pData);
	pMachineData = pData->m_spMachineData;
	Assert(pMachineData);

	m_strMachineName = pMachineData->m_stMachineName;
}


CStatusNodeRefreshItem::~CStatusNodeRefreshItem()
{ 
	TerminateBlockingThread();
	if (m_pData)
	{
		m_pData->Release();
		m_pData = NULL;
	}
};


HRESULT	CStatusNodeRefreshItem::NotifyQueryResult()
{
	// get the flag to see if need to notify, if not return S_FALSE
//  TRACE(_T("\nAUTOREFRESH!!RouterInfoRefreshItem!!Sync node data on %8x\n"), GetKey());
	HRESULT hr = S_OK;
	
	m_cs.Lock();
    
    COM_PROTECT_TRY
    {
		// set the new node data
		DMVNodeData     *pData;
    	pData = GET_DMVNODEDATA(m_pNode);
	
		hr = pData->MergeMachineNodeData(m_pData);
		if (hr == S_OK)
			hr = m_pStatusHandler->UpdateSubItemUI(m_pNode);
    }
    COM_PROTECT_CATCH;

	m_cs.Unlock();

	// ssync on the node

	return hr;
};

HRESULT	CStatusNodeRefreshItem::DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler)	// this happens in background worker thread
{
//  TRACE(_T("\nAUTOREFRESH!!RouterInfoRefreshItem!!Do query on %8x\n"), GetKey());

	// create a new machine node data, load informaiton, 
	HRESULT	hr = S_OK;

	m_cs.Lock();

    COM_PROTECT_TRY
    {
        if (!m_pData)
        {
            m_pData = new MachineNodeData;
            m_pData->Init(m_strMachineName);
        }
        m_pData->Load();
    }
    COM_PROTECT_CATCH;

    m_cs.Unlock();

	return hr; 
};

//=========================================
// RouterRefreshQueryElement implementation

DEBUG_DECLARE_INSTANCE_COUNTER(RouterRefreshQueryElement);

HRESULT RouterRefreshQueryElement::SetRefreshItem(RefreshItem* pItem)
{
	if (m_cs.Lock() == 0) 	return E_FAIL;

	m_pItem = pItem;

	m_cs.Unlock();
	return S_OK;
};

RefreshItem* RouterRefreshQueryElement::GetRefreshItem()
{	
	RefreshItem* 	pItem;
	m_cs.Lock();

	pItem = m_pItem;

	m_cs.Unlock();
	return pItem;
};


/*!--------------------------------------------------------------------------
	RouterRefreshQueryElement::TryNotifyQueryResult
        to detect if the query done, yet to Notify
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	RouterRefreshQueryElement::TryNotifyQueryResult()	
{
	HRESULT		hr = S_OK;
	RefreshItem*	pItem = NULL;

	// get the flag to see if need to notify, if not return S_FALSE

	if (GetStatus() == RouterQuery_ToNotify)
	{
//  	TRACE(_T("\nAUTOREFRESH!!TryNotifyQueryResult on %8x\n"), m_pItem->GetKey());
		// need to do the various actions at this point
		// Merge the tree with the already existing tree
		pItem = GetRefreshItem();
	}

	if(pItem)
	{
		hr = pItem->NotifyQueryResult();

			// after notify, set the flag, return S_OK
		SetStatus(RouterQuery_NoAction);
	}

	return hr;
};

void RouterRefreshQueryElement::PostNotify(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler)	// this happens in background worker thread
{
	// set ready to notify flag
	SetStatus(RouterQuery_ToNotify);
	// Post done to hidden window
	::PostMessage(hwndHidden, uMsgBase + WM_HIDDENWND_INDEX_HAVEDATA,
		  (WPARAM)pHandler, (LPARAM)m_pItem->GetKey());
}

HRESULT	RouterRefreshQueryElement::DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler)	// this happens in background worker thread
{
	HRESULT	hr = S_OK;
	
//  TRACE(_T("\nAUTOREFRESH!!Do query on %8x\n"), m_pItem->GetKey());
	RefreshItem*	pItem = GetRefreshItem();
    
    COM_PROTECT_TRY
    {
		// asked to do query, do it anyway, no matter what's the status

		// set blocking current thread, in case, this query blocks 
		pItem->SetBlockingThread(GetCurrentThread());
		
		hr = pItem->DoQuery(hwndHidden, uMsgBase, pHandler);

		if (hr == S_OK)
		{
			PostNotify(hwndHidden, uMsgBase, pHandler);
		}	

		// it's not blocked, reset it
		pItem->ResetBlockingThread();
	}
    COM_PROTECT_CATCH;

	return hr;
};

RouterRefreshQueryElementList::~RouterRefreshQueryElementList()
{
	POSITION	p = NULL;
	RouterRefreshQueryElement*	pEle = NULL;
	
	m_cs.Lock();
	p = m_list.GetHeadPosition();
	for(p = m_list.GetHeadPosition(); p != NULL; )
	{
		pEle = m_list.GetNext(p);
		pEle->Release();
	}
	m_list.RemoveAll();
	m_cs.Unlock();
}

HRESULT	RouterRefreshQueryElementList::AddRefreshItem(RefreshItem* pItem)	// no ref on IRouterInfo
{
	POSITION	p = NULL;
	RouterRefreshQueryElement*	pE = NULL;
	HRESULT		hr = S_OK;

	m_cs.Lock();
	try{
		for (p = m_list.GetHeadPosition(); p != NULL; )
		{
			pE = m_list.GetNext(p);
            
            // already added, so only addRef
			if (pItem->GetKey() == pE->GetRefreshItem()->GetKey())
			{
				break;
			}
		}

		if (p != NULL)	// found
		{
			pE->AddRef();
			hr = S_FALSE;	// we are not keeping the pItem
		}
		else
		{
			CComObject<RouterRefreshQueryElement>*	pEle = NULL;
			hr = CComObject<RouterRefreshQueryElement>::CreateInstance(&pEle);
            if ( FHrSucceeded(hr) )
            {
                Assert(pEle);
				pEle->SetRefreshItem(pItem);
				pEle->AddRef();
				m_list.AddTail(pEle);
			}
		}
	}
	catch(CMemoryException* pException)
	{
		pException->Delete();
		hr = E_OUTOFMEMORY;
	}
	catch(...)
	{
		m_cs.Unlock();
		throw;
	}

	m_cs.Unlock();

	
	return hr;
}

HRESULT	RouterRefreshQueryElementList::RemoveRefreshItem(RefreshItem& Item)		// no ref on IRouterInfo
{
	HRESULT	hr = hrOK;
	POSITION	p = NULL;
	POSITION	cp = NULL;
	RouterRefreshQueryElement*	pE = NULL;

	m_cs.Lock();
	try{
		for(p = m_list.GetHeadPosition(); p != NULL; )
		{
			cp = p;
			pE = m_list.GetNext(p);
			if (Item.GetKey() == pE->GetRefreshItem()->GetKey())	// already added, will release on Ele object
			{
				break;
			}
            
            // This is not the one we are looking for.
            cp = NULL;
		}

		if (cp != NULL)	// found
		{
			pE->Release();   //remove from the refresh list
			m_list.RemoveAt(cp);
		}
		else
			hr = S_FALSE;
	}
	catch(...)
	{
		m_cs.Unlock();
		throw;
	}

	m_cs.Unlock();
	
	return hr;
}


RouterRefreshQueryElement* 	RouterRefreshQueryElementList::Next(RouterRefreshQueryElement* pEle)	// AddRef on Ele Object
{
	RouterRefreshQueryElement*	pNext = NULL;
	m_cs.Lock();
	if (pEle == NULL)
	{
		if (m_list.GetCount() != 0)	// asking for the first element
			pNext = m_list.GetHead();
	}
	else
	{
		POSITION		p;
		// find the current one
		for(p = m_list.GetHeadPosition(); p != NULL; )
		{
			if (pEle == m_list.GetNext(p))
			{
				if (p != NULL)
					pNext = m_list.GetAt(p);
				break;
			}
		}
	}

	m_cs.Unlock();

	if (pNext)
		pNext->AddRef();
		
	return pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\refresh.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    refresh.h
//
// History:
//  Kenn Takara			Sept. 16, 1997   Created.
//
//============================================================================


#ifndef _REFRESH_H_
#define _REFRESH_H_

#include <afxmt.h>
#include <list>
#include "infoi.h"
#include "router.h"

#ifndef _HANDLERS_H_
#include "handlers.h"
#endif

/*---------------------------------------------------------------------------
	Defines
 ---------------------------------------------------------------------------*/
#define	DEFAULT_REFRESH_INTERVAL		60


/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/
class RouterRefreshQueryElement;		// COM
class RefreshItem;
class DomainStatusHandler;
struct MachineNodeData;



/*---------------------------------------------------------------------------
	Class:  RouterRefreshQueryElementList
 ---------------------------------------------------------------------------*/
class RouterRefreshQueryElementList
{
public:
	~RouterRefreshQueryElementList();
	HRESULT	AddRefreshItem(RefreshItem* pItem);			// no ref
	HRESULT	RemoveRefreshItem(RefreshItem& Item);		// no ref

	RouterRefreshQueryElement* Next(RouterRefreshQueryElement* pEle);	// AddRef

protected:

	CList<RouterRefreshQueryElement*, RouterRefreshQueryElement*>	m_list;
	CCriticalSection						m_cs;
};


/*---------------------------------------------------------------------------
	Class:	RouterRefreshObjectGroup
		Do refresh on a group, all it's members DoRefresh is called
 ---------------------------------------------------------------------------*/
class RouterRefreshObjectGroup 
{
public:
    RouterRefreshObjectGroup()
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(RouterRefreshObjectGroup);
    }
	~RouterRefreshObjectGroup();
	HRESULT	Join(RouterRefreshObject* pRefresh);
	HRESULT	Leave(RouterRefreshObject* pRefresh);
	HRESULT	Refresh();
	
protected:
	CList<RouterRefreshObject*, RouterRefreshObject*>	m_list;
};



/*---------------------------------------------------------------------------
	Class:	RouterRefreshObject
    
	class RouterRefreshObject implements IRouterRefresh interface,
    and also other two functions used by Status node refresh: 
		HRESULT	AddStatusNode;
		HRESULT	RemoveStatusNode;
	Internally to this object, it maitains a list of RefreshElements,
    in this implementation, the element could be either build
    from IRouterInfo pointer or, an machine status node pointer

	The items are maintained by
    thread safe list object RouterRefreshQueryElementList
 ---------------------------------------------------------------------------*/

class RouterRefreshObject :
        public IRouterRefresh,
        public IRouterRefreshModify,
        public ThreadHandler
{
	friend void RouterRefreshObjectTimerProc(LPARAM lParam, DWORD dwTime);
	
public:
	DeclareIUnknownMembers(IMPL);
	DeclareIRouterRefreshMembers(IMPL);
	DeclareIRouterRefreshModifyMembers(IMPL);
	DeclareITFSThreadHandlerMembers(IMPL);

	RouterRefreshObject(/*IRouterInfo *pRouter, */HWND hWndSync);
	~RouterRefreshObject();


	// Interface in refresh Router Status nodes
	HRESULT	AddStatusNode(DomainStatusHandler* pStatusHandler, ITFSNode *pServerNode);
	HRESULT	RemoveStatusNode(ITFSNode *pServerNode);
	HRESULT	DoRefresh();
	void	SetGroup(RouterRefreshObjectGroup* pGroup) { m_pRefreshGroup = pGroup;};

protected:
	void ExecuteRefresh();
	
	
	AdviseDataList	m_AdviseList;	// list of advises

	// Number of seconds between refresh intervals
	DWORD		m_dwSeconds;

	// TRUE if we are currently in a refresh cycle
	BOOL		m_fInRefresh;

	// TRUE if we have started the refresh mechanism
	BOOL		m_fStarted;

	// Id returned by CTimerMgr::AllocateTimer()
	int			m_iEventId;

	// This is tied directly to the IRouterInfo, it does not AddRef()
	RouterRefreshQueryElementList			m_listElements;

	HWND		m_hWndSync;
	
	CRITICAL_SECTION	m_critsec;

	RouterRefreshObjectGroup* 				m_pRefreshGroup; 

};

DeclareSmartPointer(SPRouterRefreshObject, RouterRefreshObject, if(m_p) m_p->Release());

typedef void (*REFRESHPROC)(LPARAM lParam, DWORD dwTime);




/*---------------------------------------------------------------------------
	Class:	CTimerDesc

	This holds some of the per-refresh proc information.
 ---------------------------------------------------------------------------*/
class CTimerDesc
{
public:
	LPARAM			lParam;
    UINT_PTR        uTimerId;
	UINT			uTimerInterval;
	REFRESHPROC		refreshProc;
};


typedef CArray<CTimerDesc *, CTimerDesc *> CTimerArrayBase;

class CTimerMgr : protected CTimerArrayBase
{
public:
    CTimerMgr();
    ~CTimerMgr();

public:
    int             AllocateTimer(REFRESHPROC procRefresh,
								  LPARAM lParam,
								  UINT uTimerInterval);
    void            FreeTimer(int uEventId);
    void            ChangeInterval(int uEventId, UINT uNewInterval);

	//
	// Function: GetTimerDesc
	// Finds the TimerDesc based on the uTimerd (the one that is
	// returned by SetTimer()).
	//
    CTimerDesc *    GetTimerDesc(INT_PTR uTimerId);

	CRITICAL_SECTION	m_critsec;
};


extern CTimerMgr	g_timerMgr;

enum RouterRefreshQueryElementStatus
{
	RouterQuery_NoAction = 0,
	RouterQuery_NeedQuery,
	RouterQuery_Working,
	RouterQuery_ToNotify,
};



/*---------------------------------------------------------------------------
    Class:  RefreshItem
    
	RefreshItem generalize the interface for background refresh task to 
	DoQuery, and NotifyQueryResult
 ---------------------------------------------------------------------------*/
class RefreshItem
{
public:
	RefreshItem(){
		m_hBlockingThread = INVALID_HANDLE_VALUE;
        DEBUG_INCREMENT_INSTANCE_COUNTER(RefreshItem);
	};

	virtual ~RefreshItem()
	{
		// this should be called in Destructor of derived class, to be safe, do it here again.
		TerminateBlockingThread();
        DEBUG_DECREMENT_INSTANCE_COUNTER(RefreshItem);
	}
	
	// helper function,
	// Terminate Blocking Thread before Delete ..
	// Should be called in Destructor of derived object
	BOOL	TerminateBlockingThread()
	{
		BOOL	r = FALSE;
		m_csBlockingThread.Lock();
		if(m_hBlockingThread != INVALID_HANDLE_VALUE)
		{
			Assert(0);	// just to notify some thread is still runing
			r = TerminateThread(m_hBlockingThread, 1);
			CloseHandle(m_hBlockingThread);
			m_hBlockingThread = INVALID_HANDLE_VALUE;
		}
		m_csBlockingThread.Unlock();
		return r;
	};

	void	ResetBlockingThread()
	{
		SetBlockingThread(INVALID_HANDLE_VALUE);
	};
	
	BOOL	SetBlockingThread(HANDLE	hThread)
	{
		BOOL	r = FALSE;
		m_csBlockingThread.Lock();
		if(m_hBlockingThread != INVALID_HANDLE_VALUE)
			CloseHandle(m_hBlockingThread);
        m_hBlockingThread = INVALID_HANDLE_VALUE;
        
		if(hThread != INVALID_HANDLE_VALUE)
			r = DuplicateHandle(GetCurrentProcess(),
								hThread,
								GetCurrentProcess(),
								&m_hBlockingThread, 
								DUPLICATE_SAME_ACCESS,
								FALSE,
								DUPLICATE_SAME_ACCESS);
		else
			m_hBlockingThread = INVALID_HANDLE_VALUE;
		m_csBlockingThread.Unlock();

		return r;
	}

	
	// to detect if the query done, yet to Notify
    virtual HRESULT	NotifyQueryResult() = 0;

	// this happens in background worker thread
	virtual HRESULT	DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler) = 0;	

	// used to compare if two items are the same
    virtual LONG_PTR	GetKey() = 0;
private:    
	HANDLE				m_hBlockingThread;
    CCriticalSection 	m_csBlockingThread;
};



/*---------------------------------------------------------------------------
    Class:  CRouterInfoRefreshItem
    
	CRouterInfoRefreshItem implements the refresh task item for IRouterInfo
 ---------------------------------------------------------------------------*/
class CRouterInfoRefreshItem : public RefreshItem
{
public:
	CRouterInfoRefreshItem(IRouterInfo* pRouter) : m_pRouter(pRouter){ASSERT(pRouter);};
	virtual ~CRouterInfoRefreshItem() 
	{
		TerminateBlockingThread();
	};
	
	// to detect if the query done, yet to Notify
    virtual HRESULT	NotifyQueryResult();
    
	// this happens in background worker thread
	virtual HRESULT	DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler);	

	// used to compare if two items are the same
    virtual LONG_PTR	GetKey() {return (LONG_PTR)m_pRouter;};
protected:	
	// This is tied directly to the IRouterInfo, it does not AddRef()
	IRouterInfo*			m_pRouter;
	SPIRouterInfo			m_spRouterNew;
	CCriticalSection		m_cs;
};



/*---------------------------------------------------------------------------
	Class:  CStatusNodeRefreshItem
        Implements the refresh task item fo the machine status node.
 ---------------------------------------------------------------------------*/
class CStatusNodeRefreshItem: public RefreshItem
{
public:
	CStatusNodeRefreshItem(DomainStatusHandler* pStatusHandler,
                           ITFSNode *pServerNode);
	virtual ~CStatusNodeRefreshItem();

    // to detect if the query done, yet to Notify
	virtual HRESULT	NotifyQueryResult();
    
	// this happens in background worker thread
	virtual HRESULT	DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler);
    
	// used to compare if two items are the same
	virtual LONG_PTR	GetKey() { return (LONG_PTR)m_pNode;};
    
protected:	
	MachineNodeData*		m_pData;
	ITFSNode*				m_pNode;			//since this lives within the life time of node, so no ref count
	DomainStatusHandler*	m_pStatusHandler;	// no ref count
	CString					m_strMachineName;
	CCriticalSection		m_cs;
};



/*---------------------------------------------------------------------------
	Class:	RouterRefreshQueryElement
    
	RouterRefreshQueryElement is the unit of refresh, it is constructed by
    using RefreshItem object.  Each refresh item implements function
    for DoQuery, and NotifyQueryResult 
 ---------------------------------------------------------------------------*/
class ATL_NO_VTABLE RouterRefreshQueryElement :
    public CComObjectRoot,
    public IUnknown
{
BEGIN_COM_MAP(RouterRefreshQueryElement)
    COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

public:
	RouterRefreshQueryElement() : m_Status(RouterQuery_NoAction), m_pItem(NULL) {}; 
	~RouterRefreshQueryElement(){ delete m_pItem; m_pItem = NULL;};

	HRESULT SetRefreshItem(RefreshItem* pRouterInfo);
	RefreshItem* GetRefreshItem();

	RouterRefreshQueryElementStatus GetStatus()
	{
		RouterRefreshQueryElementStatus s;
		m_cs.Lock();
		s = m_Status;
		m_cs.Unlock();
		return s;
	};
	void SetStatus(RouterRefreshQueryElementStatus s)
	{
		m_cs.Lock();
		m_Status = s;
		m_cs.Unlock();
	};
	
	// to detect if the query done, yet to Notify
    HRESULT	TryNotifyQueryResult();
    
	// set notify after query
    void	PostNotify(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler);	

	// this happens in background worker thread
	HRESULT	DoQuery(HWND hwndHidden, UINT uMsgBase, ITFSThreadHandler* pHandler);	

protected:
	// This is tied directly to the IRouterInfo, it does not AddRef()
	// we may need to change this in the future OPT
	RefreshItem*						m_pItem;
	RouterRefreshQueryElementStatus		m_Status;

	CCriticalSection	m_cs;
};

DeclareSmartPointer(SPRouterRefreshQueryElement, RouterRefreshQueryElement, if(m_p) m_p->Release());



/*---------------------------------------------------------------------------
	Class:	RouterRefreshQueryObject
    
	RouterRefreshQueryObject is the worker of RouterRefreshObject, it execute
    RefreshElements DoQuery	in backgroud process
 ---------------------------------------------------------------------------*/
class RouterRefreshQueryObject : public CQueryObject
{
public:
	RouterRefreshQueryObject();

	void Init(RouterRefreshQueryElementList* plist)
	{
		ASSERT(plist);
		m_plistElements = plist;
	};

	// Override the ITFSQueryObject::Execute
	STDMETHOD(Execute)();
	STDMETHOD(OnThreadExit)();
	
protected:
	RouterRefreshQueryElementList*			m_plistElements;
};

#endif	_REFRESH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtrsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_ROOT_NODE_NAME              2
#define IDS_SNAPIN_DISPLAY_NAME         3
#define IDNEXT                          3
#define IDI_SNAPIN_ICON                 4
#define IDS_ROOT_NODE_NAME_DOMAIN       5
#define IDS_ABOUT_DESCRIPTION           6
#define IDS_ABOUT_PROVIDER              7
#define IDS_ABOUT_VERSION               8
#define IDS_DIALIN_USERS_NUM            9
#define IDS_ROOTNODE_SERVER             10
#define IDS_ROOTNODE_DOMAIN             11
#define IDS_DOMAINNODE_DOMAIN           12
#define IDS_ROUTING_INTERFACES          13
#define IDS_COL_INTERFACES              14
#define IDS_COL_TYPE                    15
#define IDS_COL_STATUS                  16
#define IDS_COL_CONNECTION_STATE        17
#define IDS_SECONDSFMT                  18
#define IDS_CHOOSER_CAPTION             19
#define IDS_DIALIN_USERS                20
#define IDS_PORTS                       21
#define IDS_PORTS_NAME_FORMAT           22
#define IDS_ATLK_PROPPAGE_TITLE         23
#define IDS_ATLK_DESC                   24
#define IDS_ABOUT_ATLKDESC              25
#define IDS_ABOUT_ATLKPROVIDER          26
#define IDS_ABOUT_ATLKVERSION           27
#define IDS_ATLK_COL_ADAPTERS           28
#define IDS_MENU_ATLK_ENABLE            29
#define IDS_ATLK_TITLE                  30
#define IDS_RRAS_TITLE                  31
#define IDS_RADIUS_CONFIG_DESC          32
#define IDS_ATLK_DISPLAY_NAME           33
#define IDS_RRAS_LOCAL_TITLE            34
#define IDS_RRAS_SERVICE_DESC           35
#define IDS_RADIUS_CONFIG_ADD           36
#define IDS_RADIUS_CONFIG_EDIT          37
#define IDS_RADIUS_SERVER_AUTH_TITLE    38
#define IDS_RADIUS_SERVER_ACCT_TITLE    39
#define IDS_ACCOUNTING_PROVIDERS_NONE   40
#define IDS_DMV_DESC                    41
#define IDS_DMV_DISPLAYNAME             42
#define IDS_DMV_ABOUT_DESCRIPTION       43
#define IDS_DMV_DOMAINVIEW              44
#define IDS_DMV_COL_SERVERNAME          45
#define IDS_DMV_COL_STATE               46
#define IDS_DMV_COL_PORTSINUSE          47
#define IDS_DMV_COL_PORTSTOTAL          48
#define IDS_DMV_COL_UPTIME              49
#define IDS_DMV_NODENAME_ROOT           50
#define IDS_DMV_NODENAME_STATUS         51
#define IDS_DVS_COL_ADAPTERS            52
#define IDS_DVS_SUMMARYNODE             53
#define IDS_DMV_MENU_START              54
#define IDS_DMV_MENU_STOP               55
#define IDS_DMV_MENU_REFRESH            56
#define IDS_DMV_MENU_ADDSVR             57
#define IDS_DMV_MENU_REMOVESVR          58
#define IDS_DMV_MENU_REMOVESERVICE      59
#define IDS_DMV_MENU_REBUILDSVRLIST     60
#define IDS_DMV_MENU_REMOVEFROMDIR      61
#define IDS_DVS_DOMAINVIEWQRY           62
#define IDS_DVS_STATUS_UNAVAILABLE      63
#define IDS_SUMMARY_VPN_ACCESS          64
#define IDS_SUMMARY_DIALUP_ACCESS       65
#define IDS_DVS_STATUS_NOTCONFIG        66
#define IDS_DVS_STATUS_ACCESSDENIED     67
#define IDS_SUMMARY_DEMAND_DIAL         68
#define IDS_ATLK_NOZONES                69
#define IDS_ATLK_COL_STATUS             70
#define IDS_ATLK_COL_NETRANGE           71
#define IDS_ATLK_COL_STATUS_ROUTING     72
#define IDS_ATLK_COL_STATUS_SEEDROUTING 73
#define IDS_ATLK_COL_STATUS_NONROUTING  74
#define IDS_ATLK_COL_STATUS_ROUTING_DEF 75
#define IDS_ATLK_COL_STATUS_SEEDROUTING_DEF 76
#define IDS_ATLK_COL_STATUS_NONROUTING_DEF 77
#define IDS_COL_DEVICE_NAME             78
#define IDS_ATLK_COL_STATUS_NETWORKNOTSEEDED 79
#define IDS_TITLE_DIALINHOURS           80
#define IDS_SAPAGENT_SERVICE_DESC       81
#define IDS_TITLE_CONFIGURE_PORTS       82
#define IDS_CONFIGFILTER                83
#define IDS_NOT_AVAILABLE               84
#define IDS_ROUTER_TYPE_NTsteelhead     85
#define IDS_ROUTER_TYPE_NTW             86
#define IDS_ROUTER_TYPE_NTS             87
#define IDS_ROUTER_TYPE_WIN2000_SERVER  88
#define IDS_ROUTER_TYPE_WIN2000_PRO     89
#define IDS_RRAS                        90
#define IDS_DMV_COL_SERVERTYPE          91
#define IDS_DMV_COL_BUILDNO             92
#define IDS_DEFAULT_ADAPTER             93
#define IDS_RAS                         94
#define IDS_RADIUS_CONFIG_RADIUS        95
#define IDS_RADIUS_CONFIG_SCORE         96
#define IDS_ROUTER_UNINSTALLED          97
#define IDS_MACHINE_NAME_NOT_FOUND      98
#define IDS_WIN2000                     99
#define IDS_DIALINUSR_DOMAIN_AND_NAME   100
#define IDS_DIALINUSR_DOMAIN_ONLY       101
#define IDS_SERVICE_STOPPED             102
#define IDS_SERVICE_START_PENDING       103
#define IDS_SERVICE_STOP_PENDING        104
#define IDS_SERVICE_RUNNING             105
#define IDS_SERVICE_CONTINUE_PENDING    106
#define IDS_SERVICE_PAUSE_PENDING       107
#define IDS_SERVICE_PAUSED              108
#define IDS_SERVICE_UNKNOWN             109
#define IDS_NO_PUBLIC_INTERFACE         110
#define IDS_SUMMARY_NAT                 111
#define IDS_SUMMARY_BASIC_FIREWALL      112
#define IDS_SUMMARY_LAN_ROUTING         113
#define IDS_VPN_A_FINISH_SUMMARY        114
#define IDS_VPN_A_FINISH_POLICIES       115
#define IDS_VPN_A_FINISH_RADIUS         116
#define IDS_RAS_VPN_A_FINISH_SUMMARY    117
#define IDS_NAT_A_FINISH_SUMMARY        118
#define IDS_NAT_SUMMARY_BASIC_FIREWALL  119
#define IDS_NAT_A_FINISH_SUMMARY_SIMPLE 120
#define IDS_MENU_SYNC                   145
#define IDS_DIALIN_COL_USERNAME         200
#define IDS_DIALIN_COL_DURATION         201
#define IDS_DIALIN_COL_NUMBEROFPORTS    202
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDB_WIZWATERMARK                204
#define IDD_DLGTEST_DIALOG              205
#define IDB_WIZBANNER                   205
#define IDS_PORT_NON_OPERATIONAL        210
#define IDS_PORT_DISCONNECTED           211
#define IDS_PORT_CALLING_BACK           212
#define IDB_ROOT_SMALL                  212
#define IDS_PORT_LISTENING              213
#define IDB_ROOT_LARGE                  213
#define IDS_PORT_AUTHENTICATING         214
#define IDS_PORT_AUTHENTICATED          215
#define IDS_PORT_INITIALIZING           216
#define IDD_NEWRTRWIZ_RRASVPN           216
#define IDS_PORT_UNKNOWN                217
#define IDD_NEWRTRWIZ_CUSTOM_CONFIG     217
#define IDC_EDIT_SERVER                 222
#define IDC_EDIT_DOMAIN                 223
#define IDC_RAD_SERVER                  224
#define IDC_RAD_DOMAIN                  225
#define IDC_TEXT_IFSTATUS               226
#define IDC_TEXT_ELAPSED                227
#define IDC_EDIT_INTERFACENAME          228
#define IDC_EDIT_IC_USERNAME            229
#define IDS_DM_TO_USER_FORMAT           230
#define IDC_EDIT_IC_DOMAIN              230
#define IDS_DM_TO_DOMAIN_FORMAT         231
#define IDC_EDIT_IC_PASSWORD            231
#define IDS_DM_TO_SERVER_FORMAT         232
#define IDC_EDIT_IC_PASSWORD2           232
#define IDS_DM_LOCAL_MACHINE            233
#define IDC_EDIT_SERVERNAME             233
#define IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY 233
#define IDC_EDIT_USERNAME               234
#define IDS_NAT_EXTERNAL_FINISH_SUMMARY 234
#define IDC_TEXT_USER                   235
#define IDC_TXT_PRESHARED_KEY           235
#define IDS_NAT_EXTERNAL_FINISH_SUMMARY_DHCP_PRIVATE 235
#define IDC_EDIT_USER_PASSWORD          236
#define IDC_TEXT_PASSWORD               237
#define IDC_TEXT_INACCESSIBLE_RESOURCE  238
#define IDC_EDIT_MACHINENAME            239
#define IDC_STATIC_PRESHARED_KEY        239
#define IDS_PORTS_COL_NAME              240
#define IDC_EDIT_REFRESHRATE            240
#define IDC_STATIC_PRESHARED_KEY1       240
#define IDS_PORTS_COL_DEVICE            241
#define IDC_NEWWIZ_VPN_BTN_YES          241
#define IDS_PORTS_COL_COMMENT           242
#define IDC_NEWWIZ_VPN_BTN_NO           242
#define IDS_PORTS_COL_STATUS            243
#define IDC_NEWWIZ_NO_ICS               243
#define IDS_PORTSDLG_COL_NAME           244
#define IDC_ICS_TEXT                    244
#define IDS_PORTSDLG_COL_NUM_PORTS      245
#define IDC_VPN_YES_TEXT                245
#define IDS_PORTSDLG_COL_USAGE          246
#define IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN 246
#define IDS_PORTSDLG_COL_RAS            247
#define IDC_NEWWIZ_CONFIG_BTN_NAT1      247
#define IDS_PORTSDLG_COL_ROUTING        248
#define IDC_NEWWIZ_CONFIG_BTN_VPNNAT    248
#define IDS_PORTSDLG_COL_RASROUTING     249
#define IDC_NEWWIZ_CONFIG_BTN_DOD       249
#define IDS_PORTSDLG_COL_NOUSAGE        250
#define IDC_DP_COMBO_PORTLIST           250
#define IDC_NEWWIZ_CONFIG_BTN_CUSTOM    250
#define IDS_PORTSDLG_COL_UNKNOWN        251
#define IDC_DP_EDIT_CONDITION           251
#define IDC_NEWWIZ_BTN_VPN              251
#define IDS_PORTSDLG_COL_TYPE           252
#define IDC_DP_TEXT_LINEBPS             252
#define IDC_NEWWIZ_BTN_DIALUP_RAS       252
#define IDS_MENU_ATLK_DISABLE           253
#define IDC_DP_TEXT_DURATION            253
#define IDC_NEWWIZ_BTN_ENABLEALL        253
#define IDS_PORTS_COL_USAGE             254
#define IDC_DP_TEXT_BYTESIN             254
#define IDC_DP_TEXT_BYTESOUT            255
#define IDC_NEWWIZ_BTN_VPN_ACCESS       255
#define IDC_DP_TEXT_CRC                 256
#define IDC_NEWWIZ_BTN_DIALUP_ACCESS    256
#define IDC_DP_TEXT_TIMEOUT             257
#define IDC_NEWWIZ_BTN_DOD              257
#define IDC_DP_TEXT_ALIGNMENT           258
#define IDC_NEWWIZ_BTN_DOD_NAT          258
#define IDC_NEWWIZ_BTN_NAT              258
#define IDC_DP_TEXT_FRAMING             259
#define IDC_NEWWIZ_BTN_LAN_ROUTING      259
#define IDS_PORTS_ACTIVE                260
#define IDC_DP_TEXT_HWOVERRUN           260
#define IDC_NEWWIZ_BTN_BASIC_FIREWALL   260
#define IDS_PORTS_INACTIVE              261
#define IDC_DP_TEXT_BUFOVERRUN          261
#define IDC_NEWWIZ_BTN_ENABLE_ALL_FEATURES 261
#define IDS_PORTS_DIALOUT_ACTIVE        262
#define IDC_DP_TEXT_IPADDRESS           262
#define IDC_CHK_BASIC_FIREWALL          262
#define IDC_DP_TEXT_IPXADDRESS          263
#define IDC_DP_TEXT_NBFADDRESS          264
#define IDC_CHK_ENABLE_SECURITY         264
#define IDC_DP_BTN_REFRESH              265
#define IDC_TXT_SUMMARY                 265
#define IDC_DP_BTN_RESET                266
#define IDC_STATIC_DUMMY                266
#define IDC_DP_BTN_HANGUP               267
#define IDC_TXT_VPN_SUMMARY             267
#define IDC_DP_TEXT_ATLKADDRESS         268
#define IDC_BTN_HELP_USER_ACCOUNTS      268
#define IDC_TXT_RAS_VPN_SUMMARY         269
#define IDC_TXT_NAT_SUMMARY             270
#define IDC_BTN_HLP_PORT_MAPPINGS       271
#define IDC_TXT_NAT_EXTERNAL_FINISH_SUMMARY 272
#define IDS_RTRWIZ_REMOTE               273
#define IDC_TXT_NAT_VPN_SUMMARY         273
#define IDS_RTRWIZ_SERVICERUNNING       274
#define IDC_BTN_DEMAND_DIAL_HELP        274
#define IDC_DUMMY_CTRL                  276
#define IDC_DUMMY_CONTROL               277
#define IDC_TXT_ROUTER_FINISH_DD_SUMMARY 278
#define IDS_RTRWIZ_PROTO_IP             279
#define IDS_RTRWIZ_PROTO_IPX            280
#define IDC_DC_COMBO_CONNLIST           280
#define IDS_RTRWIZ_PROTO_NETBEUI        281
#define IDC_DC_TEXT_DURATION            281
#define IDS_RTRWIZ_PROTO_APPLETALK      282
#define IDC_DC_TEXT_BYTESIN             282
#define IDC_DC_TEXT_FRAMESIN            283
#define IDC_DC_TEXT_COMPIN              284
#define IDC_DC_TEXT_BYTESOUT            285
#define IDC_DC_TEXT_FRAMESOUT           286
#define IDC_DC_TEXT_COMPOUT             287
#define IDC_DC_TEXT_CRC                 288
#define IDC_DC_TEXT_TIMEOUT             289
#define IDS_ROOT_MESSAGE_TITLE          290
#define IDC_DC_TEXT_ALIGNMENT           290
#define IDS_ROOT_MESSAGE_BODY1          291
#define IDC_DC_TEXT_FRAMING             291
#define IDS_ROOT_MESSAGE_BODY2          292
#define IDC_DC_TEXT_HWOVERRUN           292
#define IDC_DC_TEXT_BUFOVERRUN          293
#define IDC_DC_TEXT_IPADDRESS           294
#define IDC_DC_TEXT_IPXADDRESS          295
#define IDC_DC_TEXT_NBFADDRESS          296
#define IDC_DC_BTN_REFRESH              297
#define IDC_DC_BTN_RESET                298
#define IDC_DC_BTN_HANGUP               299
#define IDS_MACHINE_MESSAGE_TITLE       300
#define IDC_DC_TEXT_ATLKADDRESS         300
#define IDS_MACHINE_MESSAGE_BODY1       301
#define IDS_MACHINE_MESSAGE_BODY2       302
#define IDS_LARGEFONTNAME               310
#define IDC_DM_EDIT_TO                  310
#define IDS_LARGEFONTSIZE               311
#define IDC_DM_EDIT_MESSAGE             311
#define IDS_BULLETFONTNAME              312
#define IDS_BULLETFONTSIZE              313
#define IDS_NEWWIZ_COMMONCONFIG_TITLE   320
#define IDS_NEWWIZ_COMMONCONFIG_SUBTITLE 321
#define IDS_NEWWIZ_NAT_CHOICE_TITLE     322
#define IDS_NEWWIZ_NAT_CHOICE_SUBTITLE  323
#define IDS_NEWWIZ_NAT_A_PUBLIC_TITLE   324
#define IDS_NEWWIZ_NAT_A_PUBLIC_SUBTITLE 325
#define IDS_NEWWIZ_NAT_A_PRIVATE_TITLE  326
#define IDS_NEWWIZ_NAT_A_PRIVATE_SUBTITLE 327
#define IDS_NEWWIZ_NAT_A_DHCPDNS_TITLE  328
#define IDS_NEWWIZ_NAT_A_DHCPDNS_SUBTITLE 329
#define IDS_NEWWIZ_NAT_A_DD_WARNING_TITLE 330
#define IDS_NEWWIZ_NAT_A_DD_WARNING_SUBTITLE 331
#define IDS_NEWWIZ_RAS_CHOICE_TITLE     332
#define IDS_NEWWIZ_RAS_CHOICE_SUBTITLE  333
#define IDS_NEWWIZ_RAS_A_PROTOCOLS_TITLE 334
#define IDS_NEWWIZ_RAS_A_PROTOCOLS_SUBTITLE 335
#define IDS_NEWWIZ_RAS_A_ATALK_TITLE    336
#define IDS_NEWWIZ_RAS_A_ATALK_SUBTITLE 337
#define IDS_NEWWIZ_RAS_A_SELECT_NETWORK_TITLE 338
#define IDS_NEWWIZ_RAS_A_SELECT_NETWORK_SUBTITLE 339
#define IDS_NEWWIZ_RAS_NONICS_TITLE     340
#define IDS_NEWWIZ_RAS_NONICS_SUBTITLE  341
#define IDS_NEWWIZ_RAS_A_ADDRESSING_NONICS_TITLE 342
#define IDS_NEWWIZ_RAS_A_ADDRESSING_NONICS_SUBTITLE 343
#define IDS_NEWWIZ_RAS_A_ADDRESS_ASSIGNMENT_TITLE 344
#define IDS_NEWWIZ_ADDRESS_ASSIGNMENT_TITLE 344
#define IDS_NEWWIZ_RAS_A_ADDRESS_ASSIGNMENT_SUBTITLE 345
#define IDS_NEWWIZ_ADDRESS_ASSIGNMENT_SUBTITLE 345
#define IDS_NEWWIZ_RAS_A_ADDRESS_POOL_TITLE 346
#define IDS_NEWWIZ_ADDRESS_POOL_TITLE   346
#define IDS_NEWWIZ_RAS_A_ADDRESS_POOL_SUBTITLE 347
#define IDS_NEWWIZ_ADDRESS_POOL_SUBTITLE 347
#define IDS_NEWWIZ_RAS_A_USERADIUS_TITLE 348
#define IDS_NEWWIZ_RAS_A_USERADIUS_SUBTITLE 349
#define IDS_NEWWIZ_RAS_A_RADIUS_CONFIG_TITLE 350
#define IDS_NEWWIZ_RADIUS_CONFIG_TITLE  350
#define IDS_NEWWIZ_RAS_A_RADIUS_CONFIG_SUBTITLE 351
#define IDS_NEWWIZ_RADIUS_CONFIG_SUBTITLE 351
#define IDS_NEWWIZ_VPN_A_PROTOCOLS_TITLE 352
#define IDS_NEWWIZ_VPN_A_PROTOCOLS_SUBTITLE 353
#define IDS_NEWWIZ_VPN_A_ATALK_TITLE    354
#define IDS_NEWWIZ_VPN_A_ATALK_SUBTITLE 355
#define IDS_NEWWIZ_VPN_A_SELECT_PUBLIC_TITLE 356
#define IDS_NEWWIZ_VPN_A_SELECT_PUBLIC_SUBTITLE 357
#define IDS_NEWWIZ_VPN_A_SELECT_PRIVATE_TITLE 358
#define IDS_NEWWIZ_VPN_A_SELECT_PRIVATE_SUBTITLE 359
#define IDS_NEWWIZ_VPN_A_ADDRESSING_NONICS_TITLE 360
#define IDS_NEWWIZ_VPN_A_ADDRESSING_NONICS_SUBTITLE 361
#define IDS_NEWWIZ_VPN_A_ADDRESS_ASSIGNMENT_TITLE 362
#define IDS_NEWWIZ_VPN_A_ADDRESS_ASSIGNMENT_SUBTITLE 363
#define IDS_NEWWIZ_VPN_A_ADDRESS_POOL_TITLE 364
#define IDS_NEWWIZ_VPN_A_ADDRESS_POOL_SUBTITLE 365
#define IDS_NEWWIZ_VPN_A_USERADIUS_TITLE 366
#define IDS_NEWWIZ_USERADIUS_TITLE      366
#define IDS_NEWWIZ_VPN_A_USERADIUS_SUBTITLE 367
#define IDS_NEWWIZ_USERADIUS_SUBTITLE   367
#define IDS_NEWWIZ_VPN_A_RADIUS_CONFIG_TITLE 368
#define IDS_NEWWIZ_VPN_A_RADIUS_CONFIG_SUBTITLE 369
#define IDS_NEWWIZ_ROUTER_PROTOCOLS_TITLE 370
#define IDS_NEWWIZ_ROUTER_PROTOCOLS_SUBTITLE 371
#define IDS_NEWWIZ_ROUTER_ADDRESS_ASSIGNMENT_TITLE 372
#define IDS_NEWWIZ_ROUTER_ADDRESS_ASSIGNMENT_SUBTITLE 373
#define IDS_NEWWIZ_ROUTER_ADDRESS_POOL_TITLE 374
#define IDS_NEWWIZ_ROUTER_ADDRESS_POOL_SUBTITLE 375
#define IDS_NEWWIZ_ROUTER_USEDD_TITLE   376
#define IDS_NEWWIZ_ROUTER_USEDD_SUBTITLE 377
#define IDS_NEWWIZ_NAT_A_DHCP_WARNING_TITLE 378
#define IDS_NEWWIZ_NAT_A_DHCP_WARNING_SUBTITLE 379
#define IDS_IFLIST_COL_NAME             400
#define IDC_RB_ENTIRE_NETWORK           400
#define IDS_IFLIST_COL_DESC             401
#define IDC_RB_THIS_COMPUTER            401
#define IDS_IFLIST_COL_IPADDRESS        402
#define IDC_RTR_IPX_CB_ALLOW_CLIENT     402
#define IDS_IFLIST_DHCP                 403
#define IDC_RTR_IP_CB_ALLOW_REMOTETCPIP 403
#define IDC_RTR_IPX_CB_SAME_ADDRESS     404
#define IDS_IPPOOL_COL_START            405
#define IDC_RTR_IPX_EB_FIRST            405
#define IDS_IPPOOL_COL_END              406
#define IDC_RTR_IPX_EB_LAST             406
#define IDS_IPPOOL_COL_RANGE            407
#define IDC_RTR_IPX_TEXT_FIRST          407
#define IDS_IPPOOL_COL_IPADDRESS        408
#define IDC_RTR_IPX_TEXT_LAST           408
#define IDS_IPPOOL_COL_MASK             409
#define IDC_RTR_IP_RB_DHCP              409
#define IDS_RTRWIZ_INTERFACE_NAME_1     410
#define IDC_RTR_IPX_CB_REMOTEIPX        410
#define IDS_RTRWIZ_INTERFACE_2          411
#define IDC_RTR_IP_RB_POOL              411
#define IDC_RTR_IPX_RB_AUTO             412
#define IDC_RTR_IPX_RB_POOL             413
#define IDC_RTR_IP_TEXT_ADAPTER         414
#define IDC_RTR_IP_COMBO_ADAPTER        415
#define IDC_RTR_IP_DHCP_TEXT            416
#define IDC_RTR_IP_TEXT_LABEL_ADAPTER   417
#define IDC_RTR_IP_BTN_ADD              418
#define IDC_RTR_IP_BTN_EDIT             419
#define IDC_RTR_IP_BTN_REMOVE           420
#define IDC_RTR_IP_LIST                 421
#define IDC_RTR_IP_BTN_ENABLE_IPROUTING 422
#define IDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD 423
#define IDC_RTR_ARAP_CB_REMOTEARAP      426
#define IDC_RTR_IPX_CB_REMOTENETBEUI    444
#define IDC_RTR_ATLK_SEEDNETWORK        445
#define IDC_BTN_ATLK_ZONEADD            446
#define IDC_BTN_ATLK_ZONEREMOVE         447
#define IDC_BTN_ATLK_GETZONES           448
#define IDC_RTR_ATLK_FROM               450
#define IDC_RTR_ATLK_TO                 451
#define IDC_RTR_ATLK_S_LOWER            452
#define IDC_RTR_ATLK_S_UPPER            453
#define IDC_RTR_ATLK_LB_DEFZONES        454
#define IDC_RTR_ATLK_NEWZONE_STATIC     455
#define IDC_RTR_ATLK_NEWZONE_EDIT       456
#define IDC_RTR_ATLK_S_RANGE            458
#define IDC_RTR_ATLK_S_DEF              460
#define IDC_RTR_GEN_CB_RAS              461
#define IDC_RTR_GEN_RB_LAN              462
#define IDC_RTR_GEN_RB_LANWAN           463
#define IDC_RTR_GEN_CB_SVRASRTR         464
#define IDC_RTR_ARAP_GRP_NETALLOC       467
#define IDC_RTR_ATLK_DEFAULTZONE_PROMPT 468
#define IDC_RTR_ATLK_DEFAULTZONE_DISPLAY 469
#define IDC_PGG_LIST                    470
#define IDC_PGG_BTN_CONFIGURE           471
#define IDC_PGG_TXT_NOINFO              472
#define IDC_RTR_EAPCFG_LIST             480
#define IDC_RTR_AUTH_BTN_NOAUTH         490
#define IDC_RTR_AUTH_BTN_EAP            491
#define IDC_RTR_AUTH_BTN_DETAILS        492
#define IDC_RTR_AUTH_BTN_MSCHAP         493
#define IDC_RTR_AUTH_BTN_CHAP           494
#define IDC_RTR_AUTH_BTN_PAP            495
#define IDC_RTR_AUTH_BTN_ENCRYPTION     496
#define IDC_RTR_AUTH_COMBO_AUTHPROV     497
#define IDC_RTR_AUTH_BTN_AUTHCFG        498
#define IDC_RTR_AUTH_COMBO_ACCTPROV     499
#define IDC_RTR_AUTH_BTN_ACCTCFG        500
#define IDS_QRY_PROJNAME                501
#define IDC_RTR_AUTH_BTN_SPAP           501
#define IDS_QRY_TITLE_RRASQUERYFORM     502
#define IDC_RTR_AUTH_TXT_DETAILS        502
#define IDS_QRY_TITLE_GENERALPAGE       503
#define IDS_QRY_TITLE_ADVANCEDPAGE      504
#define IDC_RTR_AUTH_BTN_MSCHAPV2       504
#define IDS_ERR_TITLE                   505
#define IDC_RTR_AUTH_BTN_SETTINGS       505
#define IDS_MIN_CHARS                   506
#define IDS_ERR_ERRORCODE               507
#define IDS_QRY_COL_CN                  508
#define IDS_QRY_COL_OBJECTCLASS         509
#define IDS_QRY_COL_RRASATTRIBUTE       510
#define IDS_QRY_ERR_RRASADMINDIC        511
#define IDS_NEXT                        512
#define IDS_OK                          513
#define IDS_WAIT_FOR_RRAS               514
#define IDS_CONNECT_AS_TEXT             515
#define IDS_WAIT_FOR_RRAS_TITLE         516
#define IDS_ADD_IPPOOL_TITLE            517
#define IDS_EDIT_IPPOOL_TITLE           518
#define IDC_RADAUTH_LIST                520
#define IDC_RADAUTH_BTN_ADD             522
#define IDC_RADAUTH_BTN_EDIT            523
#define IDC_RADAUTH_BTN_DELETE          524
#define IDC_RAC_EDIT_SERVER             530
#define IDC_NIG_BTN_ALLOW               530
#define IDC_RAC_EDIT_SECRET             531
#define IDC_NIG_BTN_ENABLE              531
#define IDC_RAC_BTN_CHANGE              532
#define IDC_NIG_BTN_ENABLENAPT          532
#define IDC_RAC_EDIT_TIMEOUT            533
#define IDC_NIA_LIST_RANGES             533
#define IDC_RAC_SPIN_TIMEOUT            534
#define IDC_NIA_BTN_ADD                 534
#define IDC_RAC_EDIT_SCORE              535
#define IDC_NIA_BTN_EDIT                535
#define IDC_RAC_SPIN_SCORE              536
#define IDC_NIA_BTN_REMOVE              536
#define IDC_RAC_EDIT_PORT               537
#define IDC_NIA_BTN_RESERVATIONS        537
#define IDC_RAC_BTN_ONOFF               538
#define IDC_RAC_TXT_PORT                539
#define IDC_RAC_TXT_SECONDS             540
#define IDC_NIS_COMBO_PROTOCOL          540
#define IDC_RAC_BTN_DIGITALSIG          541
#define IDC_NIS_LIST_MAPPINGS           541
#define IDC_NIS_BTN_ADD                 542
#define IDC_NIS_BTN_EDIT                543
#define IDC_NIS_BTN_REMOVE              544
#define IDC_PPPCFG_BTN_MULTILINK        550
#define IDC_NAR_LIST_MAPPINGS           550
#define IDC_PPPCFG_BTN_BACP             551
#define IDC_NAR_BTN_ADD                 551
#define IDC_PPPCFG_BTN_LCP              552
#define IDC_NAR_BTN_REMOVE              552
#define IDC_PPPCFG_BTN_SWCOMP           553
#define IDC_PPPCFG_BTN_AUDIO_ACC        554
#define IDC_SECRET_EDIT_OLD             560
#define IDC_NDA_IP_STARTADDRESS         560
#define IDC_SECRET_EDIT_NEW             561
#define IDC_NDA_IP_ENDADDRESS           561
#define IDC_SECRET_EDIT_NEW_CONFIRM     562
#define IDC_NDA_IP_SUBNETMASK           562
#define IDC_NDS_IP_PUBLICADDRESS        570
#define IDC_NDS_EDIT_PUBLICPORT         571
#define IDC_NDS_BTN_ANYADDRESS          573
#define IDC_NDS_BTN_PUBLICADDRESS       574
#define IDC_NDS_EDIT_PRIVATEPORT        575
#define IDC_NDS_IP_PRIVATEADDRESS       577
#define IDC_RTRWIZ_BTN_ROUTER           580
#define IDC_RTRWIZ_BTN_RAS              581
#define IDC_RTRWIZ_BTN_LAN              582
#define IDC_RTRWIZ_BTN_LANWAN           583
#define IDC_RTRWIZ_PORTS_BTN_ROUTING    586
#define IDC_RTRWIZ_PORTS_BTN_RAS        587
#define IDC_RTRWIZ_PORTS_BTN_BOTH       588
#define IDC_RTRWIZ_PORTS_BTN_CONFIGURE  589
#define IDC_RTRWIZ_BTN_ALL_METHODS      590
#define IDC_RTRWIZ_BTN_SECURE           591
#define IDC_RTRWIZ_BTN_SECURE_AND_ENCRYPT 592
#define IDC_DEVCFG_BTN_RAS              600
#define IDC_DEVCFG_BTN_ROUTING          601
#define IDC_DEVCFG_BTN_OUTBOUND_ROUTING 602
#define IDC_DEVCFG_EDIT_CALLEDID        603
#define IDC_DEVCFG_EDIT_PORTS           604
#define IDC_DEVCFG_SPIN_PORTS           605
#define IDC_DEVCFG_TEXT_PORTS           606
#define IDC_DEVCFG_TEXT_CALLEDID        607
#define IDC_DEVCFG_TEXT                 608
#define IDC_QRY_CHECK_LANTOLAN          611
#define IDC_QRY_CHECK_DEMANDDIAL        612
#define IDC_QRY_CHECK_RAS               613
#define IDC_QRY_LIST_VALUES             620
#define IDC_QRY_BUTTON_CLEARALL         621
#define IDC_QRY_BUTTON_SELECTALL        622
#define IDC_QRY_EDIT_DOMAIN             630
#define IDC_QRY_RADIO_THIS              631
#define IDC_QRY_RADIO_ANOTHER           632
#define IDC_QRY_RADIO_NT5               633
#define IDC_QRY_RADIO_NT4               634
#define IDC_QRY_EDIT_MACHINE            635
#define IDC_ELOG_BTN_LOGNONE            640
#define IDC_ELOG_BTN_LOGERROR           641
#define IDC_ELOG_BTN_LOGWARN            642
#define IDC_ELOG_BTN_LOGINFO            643
#define IDC_ELOG_BTN_PPP                644
#define IDC_TUNNEL_IP_LOCALADDR         650
#define IDC_TUNNEL_IP_REMOTEADDR        651
#define IDC_TUNNEL_EDIT_TTL             652
#define IDC_TUNNEL_SPIN_TTL             653
#define IDC_TUNNEL_EDIT_NAME            654
#define IDC_RTRWIZ_PROTO_LOCAL          660
#define IDC_RTRWIZ_PROTO_NETWORK        661
#define IDC_RTRWIZ_PROTO_LIST           662
#define IDC_RTRWIZ_IP_BTN_USE_DHCP      668
#define IDC_RTRWIZ_IP_BTN_USE_STATIC    669
#define IDC_RTRWIZ_IP_IP_ADDRESS        670
#define IDC_RTRWIZ_IP_IP_MASK           671
#define IDC_RTRWIZ_IP_EDIT_RANGE        672
#define IDC_RTRWIZ_IP_EDIT_COUNT        673
#define IDS_PORTSDLG_DEVTYPE_MODEM      680
#define IDC_NGT_EDIT_TCP                680
#define IDS_PORTSDLG_DEVTYPE_X25        681
#define IDC_NGT_EDIT_UDP                681
#define IDS_PORTSDLG_DEVTYPE_ISDN       682
#define IDC_NGT_SPIN_UDP                682
#define IDS_PORTSDLG_DEVTYPE_SERIAL     683
#define IDC_NGT_SPIN_TCP                683
#define IDS_PORTSDLG_DEVTYPE_FRAMERELAY 684
#define IDC_NGT_BTN_SET_DEFAULTS        684
#define IDS_PORTSDLG_DEVTYPE_ATM        685
#define IDC_NGT_BTN_APPLICATIONS        685
#define IDS_PORTSDLG_DEVTYPE_SONET      686
#define IDS_PORTSDLG_DEVTYPE_SW56       687
#define IDS_PORTSDLG_DEVTYPE_PPTP       688
#define IDS_PORTSDLG_DEVTYPE_L2TP       689
#define IDS_PORTSDLG_DEVTYPE_IRDA       690
#define IDC_NGG_BTN_LOGNONE             690
#define IDS_PORTSDLG_DEVTYPE_PARALLEL   691
#define IDC_NGG_BTN_LOGERROR            691
#define IDS_PORTSDLG_DEVTYPE_PPPOE      692
#define IDS_PORTSDLG_DEVTYPE_OTHER      693
#define IDC_NGG_BTN_LOGWARN             693
#define IDC_NGG_BTN_LOGINFO             694
#define IDC_NGD_BTN_ENABLE              700
#define IDC_NGD_IP_SCOPENETWORK         701
#define IDC_NGD_IP_SCOPEMASK            702
#define IDC_NGD_BTN_EXCLUSIONS          704
#define IDC_NGN_BTN_ENABLEDNS           711
#define IDC_NGN_COMBO_DEFAULT           713
#define IDC_NGN_BTN_DEFAULT             714
#define IDC_NHE_LIST_EXCLUSIONS         725
#define IDC_NHE_BTN_ADD                 726
#define IDC_NHE_BTN_EDIT                727
#define IDC_NHE_BTN_REMOVE              728
#define IDC_NHA_ADDRESS                 730
#define IDC_NDR_IP_PUBLICADDRESS        735
#define IDC_NDR_IP_PRIVATEADDRESS       736
#define IDC_NDR_BTN_ALLOWINBOUND        737
#define IDC_NAR_BTN_EDIT                740
#define IDC_NEWWIZ_TEST_USE_IP          790
#define IDC_NEWWIZ_TEST_USE_IPX         791
#define IDC_NEWWIZ_TEST_USE_ATLK        792
#define IDC_NEWWIZ_TEST_LOCAL           793
#define IDC_NEWWIZ_TEST_DNS             794
#define IDC_NEWWIZ_TEST_DHCP            795
#define IDC_NEWWIZ_TEST_DOMAIN          796
#define IDC_NEWWIZ_TEST_EDIT_NUMNICS    797
#define IDC_NEWWIZ_TEST_SHAREDACCESS    798
#define IDC_NEWWIZ_BIGTEXT              800
#define IDC_IPSNAP_ICON                 800
#define IDC_NEWWIZ_BTN_HELP             801
#define IDC_NEWWIZ_LIST                 802
#define IDC_NEWWIZ_CHECKBOX             803
#define IDC_NEWWIZ_BTN_SIMPLE           804
#define IDC_NEWWIZ_BTN_ADVANCED         805
#define IDC_NEWWIZ_BTN_YES              806
#define IDC_NEWWIZ_BTN_NO               807
#define IDC_NEWWIZ_BTN_NEW              808
#define IDC_NEWWIZ_BTN_EDIT             809
#define IDC_NEWWIZ_BTN_DELETE           810
#define IDC_NEWWIZ_BTN_EXISTING         811
#define IDC_NEWWIZ_BTN_OPEN_CONNECTIONS_UI 812
#define IDC_NEWWIZ_TEXT_INTERFACE_1     813
#define IDC_NEWWIZ_ICON                 814
#define IDC_NEWWIZ_TEXT_INTERFACE_2     815
#define IDC_NEWWIZ_TEXT_SERVER_NAME     816
#define IDC_NEWWIZ_BULLET_1             817
#define IDC_NEWWIZ_BULLET_2             818
#define IDC_NEWWIZ_BULLET_3             819
#define IDC_NEWWIZ_BULLET_4             820
#define IDC_NEWWIZ_TEXT_SERVER_NAME_2   821
#define IDC_NEWWIZ_CHK_HELP             822
#define IDC_NEWWIZ_TEXT_ERROR           823
#define IDC_NEWWIZ_TEXT_SUBNET          824
#define IDC_NEWWIZ_TEXT_MASK            825
#define IDC_NEWWIZ_CONFIG_BTN_NAT       830
#define IDC_NEWWIZ_CONFIG_BTN_RAS       831
#define IDC_NEWWIZ_CONFIG_BTN_VPN       832
#define IDC_NEWWIZ_CONFIG_BTN_ROUTER    833
#define IDC_NEWWIZ_CONFIG_BTN_MANUAL    834
#define IDC_NEWWIZ_NAT_USE_SIMPLE       835
#define IDC_NEWWIZ_NAT_USE_EXTERNAL     836
#define IDC_NEWWIZ_EDIT_PRIMARY         837
#define IDC_NEWWIZ_EDIT_SECONDARY       838
#define IDC_NEWWIZ_EDIT_SECRET          839
#define IDC_NEWWIZ_EDIT_LIMIT           840
#define IDC_NEWWIZ_SPIN_LIMIT           841
#define IDC_NEWWIZ_ICON_WARNING         842
#define IDC_NEWWIZ_ICON_CRITICAL        843
#define IDC_NEWWIZ_ICON_INFORMATION     844
#define IDC_IPPOOL_IP_START             850
#define IDC_IPPOOL_IP_END               851
#define IDC_IPPOOL_EDIT_RANGE           852
#define IDC_IPPOOL_SPIN_RANGE           853
#define IDC_ATLK_SPIN_FROM              860
#define IDC_ATLK_SPIN_TO                861
#define IDC_ATLK_BTN_SET_DEFAULT        862
#define IDC_GETRRAS                     1000
#define IDS_MENU_REFRESH                1000
#define IDC_BUTTON_EXEC                 1001
#define IDS_MENU_ADD_INTERFACE          1001
#define IDC_LIST_RESULT                 1002
#define IDS_MENU_USE_DEMANDDIALWIZARD   1002
#define IDS_MENU_SET_CREDENTIALS        1005
#define IDS_MENU_CONNECT                1006
#define IDS_MENU_DISCONNECT             1007
#define IDS_MENU_ENABLE                 1008
#define IDS_MENU_DISABLE                1009
#define IDS_MENU_UNREACHABILITY_REASON  1010
#define IDS_MENU_NEW_DEMAND_DIAL_INTERFACE 1011
#define IDS_MENU_SELECT_COLUMNS         1012
#define IDS_MENU_REFRESH_RATE           1013
#define IDS_MENU_AUTO_REFRESH           1014
#define IDS_MENU_DIALIN_STATUS          1015
#define IDS_MENU_DIALIN_DISCONNECT      1016
#define IDS_MENU_DIALIN_SENDMSG         1017
#define IDS_MENU_DIALIN_SENDALL         1018
#define IDS_MENU_PORTS_STATUS           1019
#define IDS_MENU_PORTS_DISCONNECT       1020
#define IDS_MENU_CONFIGURE_COLUMNS      1021
#define IDS_MENU_STATUS_REFRESH         1022
#define IDS_MENU_DEMAND_DIAL_FILTERS    1023
#define IDS_MENU_RTRWIZ                 1024
#define IDS_MENU_RRAS_QRY_TEST          1025
#define IDS_MENU_DIALIN_HOURS           1026
#define IDS_MENU_LOAD_CONFIG            1028
#define IDS_MENU_SAVE_CONFIG            1029
#define IDS_MENU_PAUSE_SERVICE          1031
#define IDS_MENU_RESUME_SERVICE         1032
#define IDS_MENU_RESTART_SERVICE        1033
#define IDS_MENU_NEW_WIZARD_TEST        1034
#define IDS_PROMPT_SERVICESTART         2000
#define IDS_PROMPT_VERIFY_REMOVE_INTERFACE 2001
#define IDS_PROMPT_NOPASSWORD           2002
#define IDS_PROMPT_DOMAIN_CONTINUE      2003
#define IDS_PROMPT_SERVER_CONTINUE      2004
#define IDS_PROMPT_INSTALL_STOP_ROUTER  2005
#define IDS_PROMPT_QUERY_TO_STOP_ROUTER 2006
#define IDS_PROMPT_VERIFY_DISCONNECT_INTERFACE 2007
#define IDS_PROMPT_START_ROUTER_AFTER_INSTALL 2008
#define IDS_PROMPT_START_DISABLED_SERVICE 2009
#define IDS_PROMPT_PLEASE_SELECT_INTERFACE 2010
#define IDS_PROMPT_SERVICE_RESTART_TITLE 2011
#define IDS_PROMPT_SERVICE_RESTART_DESC 2012
#define IDS_ERR_TEMPNOADD               3000
#define IDS_ERR_EDITPBKLOCAL            3001
#define IDS_ERR_LANONLY                 3002
#define IDS_ERR_IFASERVICESTOPPED       3003
#define IDS_ERR_UNABLETOCONFIGPBK       3004
#define IDS_ERR_DELETE_INTERFACE        3005
#define IDS_ERR_IF_DISCONNECTED         3006
#define IDS_ERR_IF_CONNECTFAILED        3007
#define IDS_ERR_ERROR_OCCURRED          3008
#define IDS_ERR_SET_CREDENTIALS_FAILED  3009
#define IDS_ERR_PASSWORD_MISMATCH       3010
#define IDS_ERR_THEREHASBEEN            3011
#define IDS_ERR_ACCESSDENIED            3012
#define IDS_ERR_NETPATHNOTFOUND         3013
#define IDS_ERR_ERRORCONNECT            3014
#define IDS_ERR_NEEDS_WAN               3015
#define IDS_ERR_INITDLGERROR            3016
#define IDS_ERR_NO_TEXT                 3017
#define IDS_ERR_ENUM_FAILED             3018
#define IDS_ERR_ENUM_EMPTY              3019
#define IDS_ERR_CONNECT_ERROR           3020
#define IDS_ERR_CONNENUM_ERROR          3021
#define IDS_ERR_SEND_FAILED             3022
#define IDS_ERR_NO_MESSENGER            3023
#define IDS_ERR_ARAP_RANGE_OVERLAP      3024
#define IDS_ERR_ARAP_LOWERRANGE_OVERLAP 3025
#define IDS_ERR_ARAP_UPPERRANGE_OVERLAP 3026
#define IDS_ERR_ENTER_IP_ADDRESS        3100
#define IDS_SRV_IP_RANGE_FMT            3101
#define IDS_ERR_NO_ROUTERPROTOCOLS      3102
#define IDS_ERR_ARAP_NETWORKRANGE       3103
#define IDS_ERR_ARAP_LOWERRANGE         3104
#define IDS_ERR_ARAP_UPPERRANGE         3105
#define IDS_ERR_ARAP_RANGE              3106
#define IDS_WRN_ATLK_DELDEFZONE         3107
#define IDS_WRN_ATLK_SEEDDEFZONE        3108
#define IDS_ERR_NO_EAP_PROVIDER_CONFIG  3109
#define IDS_WRN_ENCRYPTION_DISABLED     3110
#define IDS_WRN_NO_AUTHENTICATION       3111
#define IDS_WRN_AUTH_RESTART_NEEDED     3112
#define IDS_WRN_ACCT_RESTART_NEEDED     3113
#define IDS_ERR_INVALID_SERVER_NAME     3114
#define IDS_ERR_SECRETS_MUST_MATCH      3115
#define IDS_ERR_BOGUS_OLD_SECRET        3116
#define IDS_ERR_ARAP_NOADAPTINFO        3117
#define IDS_ERR_DDFILTERS_REQUIRE_IP    3130
#define IDS_ERR_ATLK_CONFIG             3131
#define IDS_WRN_INSTALL_REBOOT_NOTIFICATION 3132
#define IDS_ERR_IP_ENTER_VALID_MASK     3133
#define IDS_ERR_INVALID_RANGE           3134
#define IDS_ERR_ATLK_ZONE_NAME          3135
#define IDS_ERR_REG_QUERYVALUE_CALL_FAILED 3143
#define IDS_ERR_EAP_BOGUS_NAME          3146
#define IDS_ERR_PORTS_BOGUS_SIZE        3147
#define IDS_ERR_CANNOT_SAVE_PORTINFO    3148
#define IDS_ERR_CANNOT_SAVE_PORTINFO_GEEK 3149
#define IDS_ERR_SETDEVICECONFIGINFO_GEEK 3150
#define IDS_WRN_PPTP_NUMPORTS_CHANGING  3151
#define IDS_ERR_CANNOT_STOP_ROUTER      3152
#define IDS_ERR_CANNOT_STOP_ROUTER_GEEK 3153
#define IDS_ERR_COULD_NOT_START_ROUTER  3154
#define IDS_ERR_COULD_NOT_STOP_ROUTER   3155
#define IDS_ERR_COULD_NOT_REMOVE_ROUTER 3156
#define IDS_ERR_COULD_NOT_INSTALL_ROUTER 3157
#define IDS_ERR_PPTP_PORTS_EQUAL_ZERO   3158
#define IDS_ERR_NO_ROUTING_ENABLED_PORTS 3159
#define IDS_ERR_REMRRAS_DCOM_ACCESS_DENIED 3160
#define IDS_WRN_PORTS_DISABLERAS        3161
#define IDS_WRN_PORTS_DISABLEROUTING    3162
#define IDS_WRN_PORTS_DECREASE          3163
#define IDS_ERR_MUST_INSTALL_BEFORE_PROPERTIES 3164
#define IDS_ERR_IP_INVALID_COUNT        3165
#define IDS_ERR_NO_AUTH_PROTOCOLS_SELECTED 3166
#define IDS_WRN_NETBEUI_CHANGED_REBOOT_NEEDED 3167
#define IDS_SHUTDOWN_WARNING            3168
#define IDS_ERR_CANNOT_INSTALL_ROUTER   3169
#define IDS_ERR_CANNOT_REGISTER_IN_DS   3170
#define IDS_WRN_CHANGING_ROUTER_CONFIG  3171
#define IDS_WRN_MUST_SELECT_ROUTER_TYPE 3172
#define IDS_ERR_IP_MUST_ENTER_VALID_ADDRESS 3173
#define IDS_ERR_LOCAL_IPADDR_INVALID    3174
#define IDS_ERR_REMOTE_IPADDR_INVALID   3175
#define IDS_ERR_TUNNEL_NEEDS_A_NAME     3176
#define IDS_WRN_PPTP_NUMPORTS_CHANGING2 3177
#define IDS_ERR_ATLK_EMPTY_ZONE         3178
#define IDS_ERR_ATLK_DUP_ZONE_NAME      3179
#define IDS_ERR_RADIUS_INVALID_NAME     3180
#define IDS_ERR_RADIUS_DUP_NAME         3181
#define IDS_ERR_GENERIC_ERROR           3182
#define IDS_ERR_FAILED_CONNECT_NETWORK  3183
#define IDS_ERR_SERVICE_FAILED_TO_START 3184
#define IDS_ERR_SERVICE_FAILED_TO_START_UNKNOWN 3185
#define IDS_ERR_CANNOT_SHOW_NT4_PROPERTIES 3186
#define IDS_ERR_INVALID_RADIUS_SCORE    3187
#define IDS_ERR_NONADMIN_CANNOT_SEE_PROPERTIES 3188
#define IDS_WRN_MORE_STEPS_FOR_AUTHEN   3189
#define IDS_ERR_IPX_LAST_MUST_BE_MORE_THAN_FIRST 3190
#define IDS_WRN_DISABLE_ROUTER          3191
#define IDS_ERR_MACHINE_NAME_NOT_FOUND  3192
#define IDS_ERR_COULD_NOT_PAUSE_ROUTER  3193
#define IDS_ERR_COULD_NOT_RESUME_ROUTER 3194
#define IDS_ERR_IS_A_WKS                3195
#define IDS_ERR_NOPORTINFO_ON_NT4       3196
#define IDS_WRN_RADIUS_PARAMS_CHANGING  3197
#define IDS_WRN_RTRWIZ_NAT_DHCPDNS_FOUND 3198
#define IDS_WRN_RTRWIZ_RAS_NODHCP       3199
#define IDS_ERR_IP_ADDRESS_POOL_RANGE_TOO_SMALL 3200
#define IDS_ERR_ADDRESS_POOL_IS_EMPTY   3201
#define IDS_ERR_ADDRESS_POOL_NO_START_ADDRESS 3202
#define IDS_ERR_ADDRESS_POOL_NO_END_ADDRESS 3203
#define IDS_ERR_IP_ADDRESS_POOL_RANGE_OVERLAPS_127 3204
#define IDS_ERR_IP_ADDRESS_POOL_RANGE_NOT_NORMAL 3205
#define IDS_ERR_IP_ADDRESS_POOL_OVERLAP 3206
#define IDS_WRN_RTRWIZ_CANNOT_RESOLVE_RADIUS 3207
#define IDS_ERR_RTRWIZ_VPN_REQUIRES_IP  3208
#define IDS_WRN_L2TP_NUMPORTS_CHANGING  3209
#define IDS_WRN_L2TP_NUMPORTS_CHANGING2 3210
#define IDS_WRN_RTRWIZ_NAT_S_FINISH     3211
#define IDS_WRN_RTRWIZ_NAT_S_FINISH_NONLOCAL 3212
#define IDS_WRN_RTRWIZ_RAS_S_FINISH     3213
#define IDS_WRN_RTRWIZ_RAS_S_FINISH_NONLOCAL 3214
#define IDS_WRN_RTRWIZ_DEFAULT_ROUTE    3215
#define IDS_ERR_RESTART_TIMEOUT         3216
#define IDS_ERR_RESTART_SERVICE         3217
#define IDS_WRN_RTRWIZ_VPN_NODHCP       3218
#define IDS_WRN_RTRWIZ_NO_DHCP_SERVER   3219
#define IDS_ERR_CANNOT_FIND_DEFAULT_RAP 3220
#define IDS_ERR_CANNOT_SYNC_WITH_RAP    3221
#define IDS_ERR_NO_RADIUS_SERVERS_SPECIFIED 3222
#define IDS_ERR_VPN_NO_NICS_LEFT_FOR_PRIVATE_IF 3223
#define IDS_ERR_RR_SERVICE_NOT_RUNNING  3224
#define IDS_WRN_AUTH_CONFIG_AUTH        3225
#define IDS_WRN_AUTH_CONFIG_ACCT        3226
#define IDS_ERR_NO_PRESHARED_KEY        3227
#define IDI_MACHINE_WAIT                11000
#define IDI_ATLK_ICON                   11002
#define IDI_FOLDER_OPEN                 11003
#define IDI_FOLDER_CLOSED               11004
#define IDI_MACHINE                     11005
#define IDI_MACHINE_ERROR               11006
#define IDI_MACHINE_ACCESS_DENIED       11007
#define IDI_MACHINE_STARTED             11008
#define IDI_MACHINE_STOPPED             11009
#define IDI_DOMAIN                      11011
#define IDI_NET_INTERFACES              11012
#define IDI_NET_LAN_CARD                11013
#define IDI_NET_WAN_CARD                11014
#define IDI_CRITICAL                    11015
#define IDI_INFORMATION_SMALL           11016
#define IDI_WARNING_SMALL               11017
#define IDD_GENERIC_PROP_PAGE           12500
#define IDD_SERVERLOCATION              12501
#define IDD_CONNECTING                  12502
#define IDD_IF_CREDENTIALS              12503
#define IDD_CONNECT_AS                  12505
#define IDD_CONNECTREG                  12506
#define IDD_REFRESHRATE                 12507
#define IDD_DDM_PORT                    12508
#define IDD_DDM_CONN                    12509
#define IDD_DDM_MESSAGE                 12510
#define IDD_RTR_IP                      12511
#define IDD_RTR_IPX                     12512
#define IDD_RTR_NBF                     12513
#define IDD_PORTS_GLOBAL_GENERAL        12514
#define IDD_RTR_ARAP                    12515
#define IDD_RTR_ATLK                    12516
#define IDD_RTR_GENERAL                 12517
#define IDD_RTR_AUTHENTICATION          12518
#define IDD_RTR_EAP_CFG                 12519
#define IDD_ENCRYPTION                  12520
#define IDD_RADIUS_AUTH                 12521
#define IDD_RADIUS_AUTH_CONFIG          12522
#define IDD_RADIUS_ACCT                 12523
#define IDD_RADIUS_ACCT_CONFIG          12524
#define IDD_PPP_CONFIG                  12525
#define IDD_CHANGE_SECRET               12526
#define IDD_PORTS_DEVICE_CONFIG         12530
#define IDD_QRY_GENERAL                 12531
#define IDD_QRY_ADVANCED                12532
#define IDD_QRY_ADDSERVER               12533
#define IDD_RTR_EVENTLOGGING            12534
#define IDD_TUNNEL                      12535
#define IDD_RTR_ATLK_NEWZONE            12536
#define IDD_AUTHENTICATION_SETTINGS     12537
#define IDD_TEST_NEWWIZ_PARAMS          12599
#define IDD_NEWRTRWIZ_WELCOME           12610
#define IDD_NEWRTRWIZ_COMMONCONFIG      12611
#define IDD_NEWRTRWIZ_NAT_S_CONFLICT    12612
#define IDD_NEWRTRWIZ_NAT_S_CONFLICT_NONLOCAL 12613
#define IDD_NEWRTRWIZ_NAT_A_CONFLICT    12614
#define IDD_NEWRTRWIZ_NAT_A_CONFLICT_NONLOCAL 12615
#define IDD_NEWRTRWIZ_NAT_NOIP          12616
#define IDD_NEWRTRWIZ_NAT_NOIP_NONLOCAL 12617
#define IDD_NEWRTRWIZ_NAT_CHOOSE        12618
#define IDD_NEWRTRWIZ_NAT_A_PUBLIC      12619
#define IDD_NEWRTRWIZ_NAT_A_PRIVATE     12620
#define IDD_NEWRTRWIZ_NAT_A_NONICS_FINISH 12621
#define IDD_NEWRTRWIZ_NAT_A_DHCPDNS     12622
#define IDD_NEWRTRWIZ_NAT_A_DD_WARNING  12623
#define IDD_NEWRTRWIZ_NAT_A_FINISH      12624
#define IDD_NEWRTRWIZ_NAT_A_EXTERNAL_FINISH 12625
#define IDD_NEWRTRWIZ_NAT_A_DD_ERROR    12626
#define IDD_NEWRTRWIZ_RAS_CHOOSE        12627
#define IDD_NEWRTRWIZ_RAS_A_PROTOCOLS   12628
#define IDD_NEWRTRWIZ_RAS_A_NONICS_FINISH 12629
#define IDD_NEWRTRWIZ_RAS_A_NEED_PROT   12630
#define IDD_NEWRTRWIZ_RAS_A_NEED_PROT_NONLOCAL 12631
#define IDD_NEWRTRWIZ_RAS_A_ATALK       12632
#define IDD_NEWRTRWIZ_RAS_A_NETWORK     12633
#define IDD_NEWRTRWIZ_RAS_A_NONICS      12634
#define IDD_NEWRTRWIZ_RAS_A_FINISH_NONICS 12635
#define IDD_NEWRTRWIZ_RAS_A_ADDRESSING_NONICS 12636
#define IDD_NEWRTRWIZ_RAS_A_ADDRESSING  12637
#define IDD_NEWRTRWIZ_RAS_A_ADDRESSPOOL 12638
#define IDD_NEWRTRWIZ_ADDRESSPOOL       12638
#define IDD_NEWRTRWIZ_RAS_A_USERADIUS   12639
#define IDD_NEWRTRWIZ_USERADIUS         12639
#define IDD_NEWRTRWIZ_RAS_A_RADIUS_CONFIG 12640
#define IDD_NEWRTRWIZ_RAS_A_FINISH      12641
#define IDD_NEWRTRWIZ_VPN_A_FINISH_NONICS 12642
#define IDD_NEWRTRWIZ_VPN_NOIP          12643
#define IDD_NEWRTRWIZ_VPN_NOIP_NONLOCAL 12644
#define IDD_NEWRTRWIZ_VPN_A_PROTOCOLS   12645
#define IDD_NEWRTRWIZ_VPN_A_NEED_PROT   12646
#define IDD_NEWRTRWIZ_VPN_A_NEED_PROT_NONLOCAL 12647
#define IDD_NEWRTRWIZ_VPN_A_ATALK       12648
#define IDD_NEWRTRWIZ_VPN_A_PUBLIC      12649
#define IDD_NEWRTRWIZ_VPN_A_PRIVATE     12650
#define IDD_NEWRTRWIZ_VPN_A_ADDRESSING  12651
#define IDD_NEWRTRWIZ_ADDRESSING        12651
#define IDD_NEWRTRWIZ_VPN_A_ADDRESSPOOL 12652
#define IDD_NEWRTRWIZ_VPN_A_USERADIUS   12653
#define IDD_NEWRTRWIZ_VPN_A_RADIUS_CONFIG 12654
#define IDD_NEWRTRWIZ_RADIUS_CONFIG     12654
#define IDD_NEWRTRWIZ_VPN_A_FINISH      12655
#define IDD_NEWRTRWIZ_ROUTER_PROTOCOLS  12656
#define IDD_NEWRTRWIZ_ROUTER_NEED_PROT  12657
#define IDD_NEWRTRWIZ_ROUTER_NEED_PROT_NONLOCAL 12658
#define IDD_NEWRTRWIZ_ROUTER_USEDD      12659
#define IDD_NEWRTRWIZ_ROUTER_ADDRESSING 12660
#define IDD_NEWRTRWIZ_ROUTER_ADDRESSPOOL 12661
#define IDD_NEWRTRWIZ_ROUTER_FINISH     12662
#define IDD_NEWRTRWIZ_ROUTER_FINISH_DD  12663
#define IDD_NEWRTRWIZ_MANUAL_FINISH     12664
#define IDD_IPPOOL                      12665
#define IDD_NEWRTRWIZ_NAT_A_DHCP_WARNING 12666
#define IDD_NEWRTRWIZ_RAS_VPN_A_FINISH  12667
#define IDD_NEWRTRWIZ_NAT_VPN_A_FINISH  12668
#define IDS_DISPLAY_RESOURCE            57345
#define IDS_RESTART_RRAS_PSK            57346
#define IDS_ILLEGAL_CHARACTER           57347
#define IDS_ERR_DOMAIN_NAME             58000
#define IDS_ERR_DOMAIN_FORMAT           58001
#define IDS_NEWWIZ_CUSTOMCONFIG_TITLE   58002
#define IDS_NEWWIZ_CUSTOMCONFIG_SUBTITLE 58003
#define IDS_NEWWIZ_RRASVPN_TITLE        58004
#define IDS_NEWWIZ_RRASVPN_SUBTITLE     58005
#define IDS_PROMPT_PLEASE_SELECT_OPTION 58006
#define IDS_ROUTER_FINISH_DD_SUMMARY    58007
#define IDC_TXT_RAS_SUMMARY				58008
#define IDS_RAS_A_FINISH_SUMMARY		58009
#define IDS_NEWWIZ_ICF_ERROR			58010
#define IDS_NEWWIZ_ICS_ERROR			58011
#define IDS_NEWWIZ_IC_ERROR			58012
#define IDC_TXT_ROUTER_FINISH_SUMMARY 58013
#define IDS_NAT_EXTERNAL_FINISH_SUMMARY_CYS 58014
#define IDD_RAS_WARNING 		58015
#define ID_OK					58016
#define ID_HELP_BTN				58017
#define IDC_RAS_WARNING		58018
#define IDC_COMPLETE_ERROR		58019
#define IDS_BASIC_FIREWALL		58020
#define IDS_STATIC_FILTER		58021
#define IDC_VPN_PUBLIC_TEXT	58022
#define IDS_BASIC_FIREWALL_TEXT 58023
#define IDS_STATIC_FILTER_TEXT 58024
#define IDC_HELP_LINK			 58025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         279
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H_
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _RTRSTRM_H
#include "rtrstrm.h"
#endif


//generic root handler
class RootHandler
		: public BaseRouterHandler, public IPersistStreamInit
{
public:
	RootHandler(ITFSComponentData *pCompData);
	virtual ~RootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(RootHandler); };

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)

	// Basic initialization
	virtual HRESULT	Init();
			
	virtual HRESULT ConstructNode(ITFSNode *pNode);

	// Notification overrides
	OVERRIDE_BaseHandlerNotify_OnExpand() = 0;

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject() = 0;

	// Access ConfigStream
	virtual ConfigStream *	GetConfigStream() = 0;
	
protected:
	SPITFSComponentData	m_spTFSCompData;
	SPIRouterInfo		m_spRouterInfo;
};


#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	root.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "machine.h"
#include "rtrdata.h"		// CRouterDataObject

/*---------------------------------------------------------------------------
	RootHandler implementation
 ---------------------------------------------------------------------------*/

IMPLEMENT_ADDREF_RELEASE(RootHandler)

DEBUG_DECLARE_INSTANCE_COUNTER(RootHandler)

HRESULT RootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IPersistStreamInit)
		*ppv = (IPersistStreamInit *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return BaseRouterHandler::QueryInterface(riid, ppv);
}

RootHandler::RootHandler(ITFSComponentData *pCompData)
	: BaseRouterHandler(pCompData)
{
	m_spTFSCompData.Set(pCompData);
	DEBUG_INCREMENT_INSTANCE_COUNTER(RootHandler)
}

HRESULT RootHandler::Init()
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RootHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::ConstructNode(ITFSNode *pNode)
{
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_FOLDER_CLOSED);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_FOLDER_OPEN);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, 0);
	}
	COM_PROTECT_CATCH

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP RootHandler::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_RouterSnapin;

    return hrOK;
}

STDMETHODIMP RootHandler::IsDirty()
{
	SPITFSNode	spNode;

	m_spTFSCompData->GetRootNode(&spNode);
	return (spNode->GetData(TFS_DATA_DIRTY) || GetConfigStream()->GetDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP RootHandler::Load
(
	IStream *pStm
)
{
	Assert(pStm);
	HRESULT	hr = hrOK;
	CString	st;
	BOOL	fServer;
	
	COM_PROTECT_TRY
	{
		hr = GetConfigStream()->LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP RootHandler::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT hr = S_OK;
	SPITFSNode	spNode;

	Assert(pStm);

	COM_PROTECT_TRY
	{
		if (fClearDirty)
		{
			m_spTFSCompData->GetRootNode(&spNode);
			spNode->SetData(TFS_DATA_DIRTY, FALSE);
		}
		
		hr = GetConfigStream()->SaveTo(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP RootHandler::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	ULONG	cbSize;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{	
		hr = GetConfigStream()->GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;

}

STDMETHODIMP RootHandler::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		hr = GetConfigStream()->InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\reg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    util.cpp
//
// History:
//	03/10/97	Kenn M. Takara			Created
//
//	Source code for some of the utility functions in util.h
//============================================================================

#include "stdafx.h"
#include "mprsnap.h"
#include "rtrutilp.h"
#include "rtrstr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const GUID GUID_DevClass_Net = {0x4D36E972,0xE325,0x11CE,{0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18}};

//----------------------------------------------------------------------------
// Function:    ConnectRegistry
//
// Connects to the registry on the specified machine
//----------------------------------------------------------------------------

TFSCORE_API(DWORD)
ConnectRegistry(
    IN  LPCTSTR pszMachine,
    OUT HKEY*   phkeyMachine
    ) {

    //
    // if no machine name was specified, connect to the local machine.
    // otherwise, connect to the specified machine
    //

    DWORD dwErr = NO_ERROR;

	if (IsLocalMachine(pszMachine))
	{
        *phkeyMachine = HKEY_LOCAL_MACHINE;
    }
    else
	{
        //
        // Make the connection
        //

        dwErr = ::RegConnectRegistry(
                    (LPTSTR)pszMachine, HKEY_LOCAL_MACHINE, phkeyMachine
                    );
    }

	HrReportExit(HRESULT_FROM_WIN32(dwErr), TEXT("ConnectRegistry"));
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DisconnectRegistry
//
// Disconnects the specified config-handle. The handle is assumed to have been
// acquired by calling 'ConnectRegistry'.
//----------------------------------------------------------------------------

TFSCORE_API(VOID)
DisconnectRegistry(
    IN  HKEY    hkeyMachine
    ) {

    if (hkeyMachine != HKEY_LOCAL_MACHINE)
	{
		::RegCloseKey(hkeyMachine);
	}
}



/*!--------------------------------------------------------------------------
	QueryRouterType
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) QueryRouterType(HKEY hkeyMachine, DWORD *pdwRouterType,
									 RouterVersionInfo *pVersion)
{
	Assert(pdwRouterType);
	Assert(hkeyMachine);
	
	DWORD	dwErr = ERROR_SUCCESS;
	HKEY	hkey = 0;
	DWORD	dwType;
	DWORD	dwRouterType;
	DWORD	dwSize;
	RouterVersionInfo	versionTemp;
	LPCTSTR	pszRouterTypeKey = NULL;
	BOOL	fFirstTry = TRUE;

	// If the version structure is not passed in, we have to do it
	// ourselves
	// ----------------------------------------------------------------
	if (pVersion == NULL)
	{
		dwErr = QueryRouterVersionInfo(hkeyMachine, &versionTemp);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto Error;
        }
		pVersion = &versionTemp;
	}

	// Windows NT Bug : 137200
	// Need to get the router type from a different place depending
	// on the version.
	// ----------------------------------------------------------------
//	if (pVersion->dwRouterVersion <= 4)
	if (pVersion->dwOsBuildNo < RASMAN_PPP_KEY_LAST_VERSION)
		pszRouterTypeKey = c_szRegKeyRasProtocols;
	else
		pszRouterTypeKey = c_szRegKeyRemoteAccessParameters;



	// This is where we perform a retry
	// ----------------------------------------------------------------
Retry:

	// Cool, we have a machine registry entry, now get the
	// path down to the routertype key
	dwErr = RegOpenKeyEx(hkeyMachine, pszRouterTypeKey, 0, KEY_READ, &hkey);
	if (dwErr)
		goto Error;

	// Ok, at this point we just need to get the RouterType value from
	// the key
	dwType = REG_DWORD;
	dwSize = sizeof(dwRouterType);
	dwErr = RegQueryValueEx(hkey, c_szRouterType, NULL,
							&dwType,
							(LPBYTE) &dwRouterType,
							&dwSize);
	if (dwErr)
	{
		// Need to retry (look at the RAS/protocols key), for NT5
		if ((pVersion->dwRouterVersion >= 5) && fFirstTry)
		{
			dwErr = ERROR_SUCCESS;
			fFirstTry = FALSE;
			if (hkey)
				RegCloseKey(hkey);
			hkey = 0;
			pszRouterTypeKey = c_szRegKeyRasProtocols;
			goto Retry;
		}
		goto Error;
	}

	// Is this the right type?
	if (dwType != REG_DWORD)
		{
		dwErr = ERROR_BADKEY;
		goto Error;
		}

	// We have the right type, now return that value
	*pdwRouterType = dwRouterType;

Error:
	if (hkey)
		RegCloseKey(hkey);
	
	return HrReportExit(HRESULT_FROM_WIN32(dwErr), TEXT("QueryRouterType"));
}


//----------------------------------------------------------------------------
// Function:    LoadLinkageList
//
// Loads a list of strings with the adapters to which 'pszService' is bound;
// the list is built by examining the 'Linkage' and 'Disabled' subkeys
// of the service under HKLM\System\CurrentControlSet\Services.
//----------------------------------------------------------------------------

HRESULT LoadLinkageList(
						LPCTSTR         pszMachine,
						HKEY			hkeyMachine,
						LPCTSTR         pszService,
						CStringList*    pLinkageList)
{
	Assert(hkeyMachine);
	
    DWORD dwErr;
    BYTE* pValue = NULL;
    HKEY hkeyLinkage = NULL, hkeyDisabled = NULL;

    if (!pszService || !lstrlen(pszService) || !pLinkageList) {
        return ERROR_INVALID_PARAMETER;
    }


    do {

        TCHAR* psz;
        CString skey;
        DWORD dwType, dwSize;
		BOOL	fNt4;


		dwErr = IsNT4Machine(hkeyMachine, &fNt4);
		if (dwErr != NO_ERROR)
			break;

		//$NT5 : where is the registry key? same as NT4
		skey = c_szSystemCCSServices;
		skey += TEXT('\\');
		skey += pszService;
		skey += TEXT('\\');
		skey += c_szLinkage;

        //
        // Open the service's 'Linkage' key
        //

        dwErr = RegOpenKeyEx(
                    hkeyMachine, skey, 0, KEY_READ, &hkeyLinkage
                    );
        if (dwErr != NO_ERROR) {

            if (dwErr == ERROR_FILE_NOT_FOUND) { dwErr = NO_ERROR; }
			CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("QueryLinkageList"));
            break;
        }


        //
        // Retrieve the size of the 'Bind' value
        //

        dwErr = RegQueryValueEx(
                    hkeyLinkage, c_szBind, NULL, &dwType, NULL, &dwSize
                    );
        if (dwErr != NO_ERROR) {

            if (dwErr == ERROR_FILE_NOT_FOUND) { dwErr = NO_ERROR; }

			CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szBind, _T("QueryLinkageList"));

            break;
        }


        //
        // Allocate space for the 'Bind' value
        //

        pValue = new BYTE[dwSize + sizeof(TCHAR)];

        if (!pValue) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

        ::ZeroMemory(pValue, dwSize + sizeof(TCHAR));


        //
        // Read the 'Bind' value
        //

        dwErr = RegQueryValueEx(
                    hkeyLinkage, c_szBind, NULL, &dwType, pValue, &dwSize
                    );
		CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szBind, _T("QueryLinkageList"));

        if (dwErr != NO_ERROR) { break; }


        //
        // Convert the 'Bind' multi-string to a list of strings,
        // leaving out the string "\Device\" which is the prefix
        // for all the bindings.
        //

        for (psz = (TCHAR*)pValue; *psz; psz += lstrlen(psz) + 1) {

            pLinkageList->AddTail(psz + 8);
        }

        delete [] pValue; pValue = NULL;


        //
        // Now open the service's 'Disabled' key.
        //

        dwErr = RegOpenKeyEx(
                    hkeyLinkage, c_szDisabled, 0, KEY_READ, &hkeyDisabled
                    );
        if (dwErr != NO_ERROR) {

            if (dwErr == ERROR_FILE_NOT_FOUND) { dwErr = NO_ERROR; }
			CheckRegOpenError(dwErr, c_szDisabled, _T("QueryLinkageList"));
            break;
        }


        //
        // Retrieve the size of the 'Bind' value
        //

        dwErr = RegQueryValueEx(
                    hkeyDisabled, c_szBind, NULL, &dwType, NULL, &dwSize
                    );
        if (dwErr != NO_ERROR) {

            if (dwErr == ERROR_FILE_NOT_FOUND) { dwErr = NO_ERROR; }
			CheckRegQueryValueError(dwErr, c_szDisabled, c_szBind, _T("QueryLinkageList"));
            break;
        }


        //
        // Allocate space for the 'Bind' value
        //

        pValue = new BYTE[dwSize + sizeof(TCHAR)];

        if (!pValue) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

        ::ZeroMemory(pValue, dwSize + sizeof(TCHAR));


        //
        // Read the 'Bind' value
        //

        dwErr = RegQueryValueEx(
                    hkeyDisabled, c_szBind, NULL, &dwType, pValue, &dwSize
                    );
		CheckRegQueryValueError(dwErr, c_szDisabled, c_szBind, _T("QueryLinkageList"));

        if (dwErr != NO_ERROR) { break; }


        //
        // Each device in the 'Bind' mulit-string is disabled for the service,
        // so we will now remove such devices from the string-list built
        // from the 'Linkage' key.
        //

        for (psz = (TCHAR*)pValue; *psz; psz += lstrlen(psz) + 1) {

            POSITION pos = pLinkageList->Find(psz);

            if (pos) { pLinkageList->RemoveAt(pos); }
        }


    } while(FALSE);

    if (pValue) { delete [] pValue; }

    if (hkeyDisabled) { ::RegCloseKey(hkeyDisabled); }

    if (hkeyLinkage) { ::RegCloseKey(hkeyLinkage); }

    return dwErr;
}

/*!--------------------------------------------------------------------------
	IsNT4Machine
		-
	Author: KennT, WeiJiang
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD)	GetNTVersion(HKEY hkeyMachine, DWORD *pdwMajor, DWORD *pdwMinor, DWORD* pdwCurrentBuildNumber)
{
	// Look at the HKLM\Software\Microsoft\Windows NT\CurrentVersion
	//					CurrentVersion = REG_SZ "4.0"
	CString skey;
	DWORD	dwErr;
	TCHAR	szVersion[64];
	TCHAR	szCurrentBuildNumber[64];
	RegKey	regkey;
	CString	strVersion;
	CString	strMajor;
	CString	strMinor;


	ASSERT(pdwMajor);
	ASSERT(pdwMinor);
	ASSERT(pdwCurrentBuildNumber);

	skey = c_szSoftware;
	skey += TEXT('\\');
	skey += c_szMicrosoft;
	skey += TEXT('\\');
	skey += c_szWindowsNT;
	skey += TEXT('\\');
	skey += c_szCurrentVersion;

	dwErr = regkey.Open(hkeyMachine, (LPCTSTR) skey, KEY_READ);
	CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("GetNTVersion"));
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	// Ok, now try to get the current version value
	dwErr = regkey.QueryValue( c_szCurrentVersion, szVersion,
							   sizeof(szVersion),
							   FALSE);
	CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szCurrentVersion,
							_T("GetNTVersion"));
	if (dwErr != ERROR_SUCCESS)
		goto Err;
		
	// Ok, now try to get the current build number value
	dwErr = regkey.QueryValue( c_szCurrentBuildNumber, szCurrentBuildNumber,
							   sizeof(szCurrentBuildNumber),
							   FALSE);
	CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szCurrentBuildNumber,
							_T("GetNTVersion"));

	if (dwErr != ERROR_SUCCESS)
		goto Err;
		
	strVersion = szVersion;
	strMajor = strVersion.Left(strVersion.Find(_T('.')));
	strMinor = strVersion.Mid(strVersion.Find(_T('.')) + 1);

	if(pdwMajor)
		*pdwMajor = _ttol(strMajor);

	if(pdwMinor)
		*pdwMinor = _ttol(strMinor);

	if(pdwCurrentBuildNumber)
		*pdwCurrentBuildNumber = _ttol(szCurrentBuildNumber);

Err:

	return dwErr;
}


/*!--------------------------------------------------------------------------
	IsNT4Machine
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD)	IsNT4Machine(HKEY hkeyMachine, BOOL *pfNt4)
{
	// Look at the HKLM\Software\Microsoft\Windows NT\CurrentVersion
	//					CurrentVersion = REG_SZ "4.0"
	DWORD	dwMajor = 0;
	DWORD	dwErr = 0;

	dwErr = GetNTVersion(hkeyMachine, &dwMajor, NULL, NULL);
	if (dwErr == ERROR_SUCCESS)
	{
		*pfNt4 = (dwMajor == 4);
	}

	return dwErr;
}

//----------------------------------------------------------------------------
// Function:    FindRmSoftwareKey
//
// Finds the key for a router-manager in the Software section of the registry.
//----------------------------------------------------------------------------

HRESULT FindRmSoftwareKey(
						HKEY        hkeyMachine,
						DWORD       dwTransportId,
						HKEY*       phkrm,
						LPTSTR*     lplpszRm
					   )
{
	Assert(phkrm);
	
    DWORD			dwErr;
	RegKey			regkey;
	HRESULT			hr = hrOK;
	CString			stKey;
	RegKeyIterator	regkeyIter;
	HRESULT			hrIter;
	RegKey		regkeyRM;
	DWORD			dwProtocolId;
	BOOL			bFound = FALSE;

    //
    // open the key HKLM\Software\Microsoft\Router\RouterManagers
    //

    CString skey(c_szSoftware);

    skey += TEXT('\\');
    skey += c_szMicrosoft;
    skey += TEXT('\\');
    skey += c_szRouter;
    skey += TEXT('\\');
    skey += c_szCurrentVersion;
    skey += TEXT('\\');
    skey += c_szRouterManagers;

	dwErr = regkey.Open(hkeyMachine, (LPCTSTR) skey, KEY_READ);
	CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("QueryRmSoftwareKey"));
	CWRg(dwErr);

	if (lplpszRm)
		*lplpszRm = NULL;
	*phkrm = 0;

    //
    // Enumerate its subkeys looking for one which has a ProtocolId value
    // equal to 'dwTransportId';
    //

	CWRg( regkeyIter.Init(&regkey) );

	hrIter = regkeyIter.Next(&stKey);
	
	for (; hrIter == hrOK; hrIter = regkeyIter.Next(&stKey))
	{
		//
		// open the key
		//
		dwErr = regkeyRM.Open(regkey, stKey, KEY_READ);
		CheckRegOpenError(dwErr, stKey, _T("QueryRmSoftwareKey"));
		if (dwErr != ERROR_SUCCESS) { continue; }

		//
		// try to read the ProtocolId value
		//
		dwErr = regkeyRM.QueryValue(c_szProtocolId, dwProtocolId);
		CheckRegQueryValueError(dwErr, stKey, c_szProtocolId, _T("QueryRmSoftwareKey"));

		//
		// Break if this is the transport we're looking for,
		// otherwise close the key and continue
		//
		if ((dwErr == ERROR_SUCCESS) && (dwProtocolId == dwTransportId))
			break;

		regkeyRM.Close();
	}

	if (hrIter == hrOK)
	{
		//
		// The transport was found, so save its key-name and key
		//
		Assert(((HKEY)regkeyRM) != 0);
		if (lplpszRm)
			*lplpszRm = StrDup((LPCTSTR) stKey);
		bFound = TRUE;
		*phkrm = regkeyRM.Detach();
	}


Error:

	if (FHrSucceeded(hr) && !bFound)
	{
		hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
	}
	return hr;
}


#ifdef _DEBUG
void	CheckRegOpenErrorEx(DWORD dwError, LPCTSTR pszSubKey,
						  LPCTSTR pszDesc, LPCTSTR pszFile, int iLineNo)
{
	if (dwError)
	{
		CString	st;

		st.Format(_T("RegOpenEx failed(%08lx)\nfile: %s\nline: %d\nDesc: %s\nkey: %s"),
				  dwError, pszFile, iLineNo,
				  pszDesc, pszSubKey);
		if (AfxMessageBox(st, MB_OKCANCEL) == IDCANCEL)
		{
			DebugBreak();
		}
	}
}

void	CheckRegQueryValueErrorEx(DWORD dwError, LPCTSTR pszSubKey,
								LPCTSTR pszValue, LPCTSTR pszDesc,
								 LPCTSTR pszFile, int iLineNo)
{
	if (dwError)
	{
		CString	st;

		st.Format(_T("RegQueryValue failed(%08lx)\nfile: %s\nline: %d\ndesc: %s\nkey: %s\nvalue: %s"),
				  dwError, pszFile, iLineNo, pszDesc, pszSubKey, pszValue);
		if (AfxMessageBox(st, MB_OKCANCEL) == IDCANCEL)
		{
			DebugBreak();
		}
	}
}
#endif


/*!--------------------------------------------------------------------------
	SetupFindInterfaceTitle
		-
		This function retrieves the title of the given interface.
		The argument 'LpszIf' should contain the ID of the interface,
		for instance "EPRO1".
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SetupFindInterfaceTitle(LPCTSTR pszMachine,
                                     LPCTSTR pszInterface,
                                     LPTSTR *ppszTitle)
{
    HRESULT     hr = hrOK;
    CString     stMachine;
    HDEVINFO    hDevInfo = INVALID_HANDLE_VALUE;
    HKEY        hkMachine = NULL;
    HKEY        hkDevice= NULL;
    CString     stPnpInstanceId;
    RegKey      rkNet;
    RegKey      rkNetcard;
    RegKey      rkDevice;
    RegKey      rkConnection;
    CString     stBuffer, stPath;
    CString     stConnection;
    TCHAR       szClassGuid[128];
    DWORD       dwAction;
    DWORD       dwErr;
    SP_DEVINFO_DATA DevInfo;
    
    stMachine = pszMachine;
    if (IsLocalMachine(stMachine))
    {
        hDevInfo = SetupDiCreateDeviceInfoList(
                                               (LPGUID) &GUID_DevClass_Net,
                                               NULL);
    }
    else
    {
        // Append on the "\\\\" if needed
        if (StrniCmp((LPCTSTR) stMachine, _T("\\\\"), 2) != 0)
        {
            stMachine = _T("\\\\");
            stMachine += pszMachine;
        }
        
        hDevInfo = SetupDiCreateDeviceInfoListEx(
            (LPGUID) &GUID_DevClass_Net,
            NULL,
            (LPCTSTR) stMachine,
            0);
    }

    // Get hkMachine from system
    // ----------------------------------------------------------------
    CWRg( ConnectRegistry( (LPCTSTR) stMachine, &hkMachine) );

    
    // Get the PnpInstanceID
    // ----------------------------------------------------------------
    CWRg( rkNet.Open(hkMachine, c_szNetworkCardsNT5Key, KEY_READ) );

    CWRg( rkNetcard.Open(rkNet, pszInterface, KEY_READ) );

    dwErr = rkNetcard.QueryValue(c_szPnpInstanceID, stPnpInstanceId);
    if (dwErr != ERROR_SUCCESS)
    {
        RegKey  rkConnection;
        
        // Need to open another key to get this info.
        CWRg( rkConnection.Open(rkNetcard, c_szRegKeyConnection, KEY_READ) );

        CWRg( rkConnection.QueryValue(c_szPnpInstanceID, stPnpInstanceId) );
    }

        
    // Get hkDevice from SetupDiOpenDevRegKey
    // Now get the info for this device
    // ----------------------------------------------------------------
    ::ZeroMemory(&DevInfo, sizeof(DevInfo));
    DevInfo.cbSize = sizeof(DevInfo);

    if (!SetupDiOpenDeviceInfo(hDevInfo,
                               (LPCTSTR) stPnpInstanceId,
                               NULL,
                               0,
                               &DevInfo))
    {
        CWRg( GetLastError() );
    }


    // Now that we have the info, get the reg key
    // ----------------------------------------------------------------
    hkDevice = SetupDiOpenDevRegKey(hDevInfo,
                                    &DevInfo,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_READ);
    if ((hkDevice == NULL) || (hkDevice == INVALID_HANDLE_VALUE))
    {
        CWRg( GetLastError() );
    }

    // Attach so that it will get freed up
    // ----------------------------------------------------------------
    rkDevice.Attach( hkDevice );

    
    // Read in the netcfg instance
    // ----------------------------------------------------------------
    CWRg( rkDevice.QueryValue(c_szRegValNetCfgInstanceId, stBuffer) );
    

    // Generate path in registry for lookup
    StringFromGUID2(GUID_DevClass_Net, 
                    szClassGuid,
                    DimensionOf(szClassGuid));
    stPath.Format(_T("%s\\%s\\%s\\Connection"),
                  c_szRegKeyComponentClasses,
                  szClassGuid,
                  stBuffer);

    // Open the key
    CWRg( rkConnection.Open(hkMachine, stPath, KEY_READ) );
    
    // Read in and store the connections name
    CWRg( rkConnection.QueryValue(c_szRegValName, stConnection) );
    
    *ppszTitle = StrDup((LPCTSTR) stConnection);
        
        
Error:

    if (hDevInfo != INVALID_HANDLE_VALUE)
        SetupDiDestroyDeviceInfoList(hDevInfo);
    
    if (hkMachine)
        DisconnectRegistry( hkMachine );
    return hr;
}


/*!--------------------------------------------------------------------------
	RegFindInterfaceTitle
		-
		This function retrieves the title of the given interface.
		The argument 'LpszIf' should contain the ID of the interface,
		for instance "EPRO1".
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RegFindInterfaceTitle(LPCTSTR pszMachine,
								   LPCTSTR pszInterface,
								   LPTSTR *ppszTitle)
{
	HRESULT	hr = hrOK;
	DWORD		dwErr;
	HKEY		hkeyMachine = NULL;
	RegKey		regkey;
	RegKeyIterator	regkeyIter;
	HRESULT		hrIter;
	CString		stKey;
	RegKey		regkeyCard;
	CString		stServiceName;
	CString		stTitle;
	BOOL		fNT4;
	LPCTSTR		pszKey;
	CNetcardRegistryHelper	ncreghelp;
	
	COM_PROTECT_TRY
	{

		//
		// connect to the registry
		//
		CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

		CWRg( IsNT4Machine(hkeyMachine, &fNT4) );

		//
		// open HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards
		//
		pszKey = fNT4 ? c_szNetworkCardsKey : c_szNetworkCardsNT5Key;
		CWRg( regkey.Open(hkeyMachine, pszKey, KEY_READ) );

		//
        // enumerate the subkeys, and for each key,
        // see if it's the one we want
        //
		CWRg( regkeyIter.Init(&regkey) );

		hrIter = regkeyIter.Next(&stKey);

		for (; hrIter == hrOK; hrIter = regkeyIter.Next(&stKey))
		{
			hr = hrOK;

            //
            // now open the key
            //
			regkeyCard.Close();
			dwErr = regkeyCard.Open(regkey, stKey, KEY_READ);
            if (dwErr != ERROR_SUCCESS)
				continue;

			ncreghelp.Initialize(fNT4, regkeyCard, stKey,
								 pszMachine);

			//
			// read the ServiceName
			//

			//$NT5: the service name is not in the same format as NT4
			// this will need to be done differently.
			if (fNT4)
			{
				ncreghelp.ReadServiceName();
				if (dwErr != ERROR_SUCCESS)
					continue;
				stServiceName = ncreghelp.GetServiceName();
			}
			else
				stServiceName = pszKey;
			
			//
			// see if it's the one we're looking for
			//
			if (StriCmp(pszInterface, (LPCTSTR) stServiceName))
			{
				dwErr = ERROR_INVALID_HANDLE;
				continue;
			}
			
			//
			// this is the one; read the title
			//
			dwErr = ncreghelp.ReadTitle();
			if (dwErr != NO_ERROR)
				break;

			stTitle = (LPCTSTR) ncreghelp.GetTitle();

			*ppszTitle = StrDup((LPCTSTR) stTitle);
        }


		if (dwErr)
			hr = HRESULT_FROM_WIN32(dwErr);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	if (hkeyMachine)
		DisconnectRegistry(hkeyMachine);
	return hr;
}

/*!--------------------------------------------------------------------------
	RegFindRtrMgrTitle
		-
	This function retrieves the title of the given router-manager.
	The argument 'dwTransportId' should contain the ID of the router-manager,
	for instance PID_IP.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RegFindRtrMgrTitle(LPCTSTR pszMachine,
								DWORD dwTransportId,
								LPTSTR *ppszTitle)
{
	HRESULT		hr = hrOK;
    HKEY		hkey, hkeyMachine = 0;
	RegKey		regkey;
	CString		stValue;

	COM_PROTECT_TRY
	{
		//
		// connect to the registry
		//
		CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );

		//
		// open the key for the router-manager
		// under HKLM\Software\Microsoft\Router\RouterManagers
		//
		CORg( FindRmSoftwareKey(hkeyMachine, dwTransportId, &hkey, NULL) );
		regkey.Attach(hkey);

		//
		// Now find the "Title" value
		//
		CWRg( regkey.QueryValue( c_szTitle, stValue ) );

		// Copy the output data
		*ppszTitle = StrDup((LPCTSTR) stValue);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	if (hkeyMachine)
		DisconnectRegistry(hkeyMachine);
	return hr;
}


/*!--------------------------------------------------------------------------
	QueryRouterVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)	QueryRouterVersionInfo(HKEY hkeyMachine,
											   RouterVersionInfo *pVerInfo)
{
	// Look at the HKLM\Software\Microsoft\Windows NT\CurrentVersion
	//					CurrentVersion = REG_SZ "4.0"
	CString skey;
	DWORD	dwErr;
	TCHAR	szData[64];
	RegKey	regkey;
	BOOL	fNt4;
	DWORD	dwMajorVer, dwMinorVer, dwBuildNumber;
    DWORD   dwConfigured;
	DWORD	dwSPVer = 0;
	DWORD	dwOsFlags = 0;

	skey = c_szSoftware;
	skey += TEXT('\\');
	skey += c_szMicrosoft;
	skey += TEXT('\\');
	skey += c_szWindowsNT;
	skey += TEXT('\\');
	skey += c_szCurrentVersion;

    Assert(hkeyMachine != NULL);
    Assert(hkeyMachine != INVALID_HANDLE_VALUE);
	
	dwErr = regkey.Open(hkeyMachine, (LPCTSTR) skey, KEY_READ);
	CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("IsNT4Machine"));
	if (dwErr != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(dwErr);

	// Ok, now try to get the current version value
	dwErr = regkey.QueryValue( c_szCurrentVersion, szData,
							   sizeof(szData),
							   FALSE);
	CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szCurrentVersion,
							_T("QueryRouterVersionInfo"));
	if (dwErr == ERROR_SUCCESS)
	{
		int		nPos;
		int		nLength;
		CString	stData;

		stData = szData;

		nPos = stData.Find(_T('.'));
		nLength = stData.GetLength();

		// This assumes that
		// CurrentVersion : REG_SZ : Major.Minor.XX.XX
		// ------------------------------------------------------------

		// Pick out the major version from the string
		// ------------------------------------------------------------
		dwMajorVer = _ttoi(stData.Left(nPos));

		// Pick out the minor version
		// ------------------------------------------------------------
		dwMinorVer = _ttoi(stData.Right(nLength - nPos - 1));
	}

	
	// Get the build number
	// ----------------------------------------------------------------
	dwErr = regkey.QueryValue( c_szCurrentBuildNumber, szData,
							   sizeof(szData),
							   FALSE);
	if (dwErr == ERROR_SUCCESS)
		dwBuildNumber = _ttoi(szData);

	
	// If this is an NT4 machine, look for the Software\Microsoft\Router
	// registry key.  If that doesn't exist, then this is a
	// non-Steelhead router.
	// ----------------------------------------------------------------
	if ((dwErr == ERROR_SUCCESS) && (dwMajorVer < 5))
	{
		RegKey	regkeyRouter;
		dwErr = regkeyRouter.Open(hkeyMachine, c_szRegKeyRouter, KEY_READ);
		if (dwErr != ERROR_SUCCESS)
			dwOsFlags |= RouterSnapin_RASOnly;

		// Ignore the return code
		dwErr = ERROR_SUCCESS;
	}

	// Now get the SP version
	// ----------------------------------------------------------------
	dwErr = regkey.QueryValue( c_szCSDVersion, szData,
							   sizeof(szData),
							   FALSE);
	if (dwErr == ERROR_SUCCESS)
		dwSPVer = _ttoi(szData);
	dwErr = ERROR_SUCCESS;		// this could fail, so ignore return code

    // Look at the router is configured flag
    // ----------------------------------------------------------------
    regkey.Close();
    if (ERROR_SUCCESS == regkey.Open(hkeyMachine,c_szRemoteAccessKey) )
    {
        dwErr = regkey.QueryValue( c_szRtrConfigured, dwConfigured);
        if (dwErr != ERROR_SUCCESS)
            dwConfigured = FALSE;
        
		// Ignore the return code
		dwErr = ERROR_SUCCESS;
    }

	if (dwErr == ERROR_SUCCESS)
	{
		pVerInfo->dwRouterVersion = dwMajorVer;
		pVerInfo->dwOsMajorVersion = dwMajorVer;
		pVerInfo->dwOsMinorVersion = dwMinorVer;
		pVerInfo->dwOsServicePack = dwSPVer;
		pVerInfo->dwOsFlags |= (1 | dwOsFlags);
        pVerInfo->dwRouterFlags = dwConfigured ? RouterSnapin_IsConfigured : 0;
        
        // If this is NT4, then the default is the router is configured
        if (dwMajorVer <= 4)
            pVerInfo->dwRouterFlags |= RouterSnapin_IsConfigured;

		pVerInfo->dwOsBuildNo = dwBuildNumber;
	}

	return HRESULT_FROM_WIN32(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rrasqry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rrasqry.cpp
//
//--------------------------------------------------------------------------

// rrasqry.cpp : implementation file
//

#include "stdafx.h"
#include "qryfrm.h"
#include "rrasqry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static UINT g_cfDsObjectNames = 0;
static UINT g_cfDsQueryParams = 0;
static UINT g_cfDsQueryScope = 0;

#define DIR_SEARCH_PAGE_SIZE        256
#define DIR_SEARCH_PAGE_TIME_LIMIT  30

#define CFSTR_DSQUERYSCOPE         TEXT("DsQueryScope")

HRESULT  RRASDelRouterIdObj(  
/*[in]*/LPCWSTR   pwszMachineName   // DN of the computer object in DS
)
{
	HRESULT              hr = S_OK;
	CComPtr<IADsContainer>  spContainer;
	CString				machineName;

	if(!pwszMachineName || *pwszMachineName == 0)	// this machine
		machineName = GetLocalMachineName();
	else
		machineName = pwszMachineName;

	ASSERT(machineName.GetLength());
	if(machineName.GetLength() == 0)	return S_FALSE;

	// prepare fileter, 
	// in format 
	// (&(objectClass=RRASAdministrationConnectionPoint)(distinguishedName=CN=RouterIdentity,CN=*)
	CString	filter = FILTER_PREFIX;

	filter += _T("&");
	filter += FILTER_PREFIX;

#if 1 /// use computer to query
	filter += ATTR_NAME_OBJECTCLASS;
	filter += _T("=");
	filter += ATTR_CLASS_COMPUTER;
	filter += FILTER_POSTFIX;

	filter += FILTER_PREFIX;
	filter += ATTR_NAME_CN;
	filter += _T("=");
	filter += machineName;
#else	// user router id of the computer object for query, not found
	filter += ATTR_NAME_OBJECTCLASS;
	filter += _T("=");
	filter += ATTR_CLASS_RRASID;
	filter += FILTER_POSTFIX;

	filter += FILTER_PREFIX;
	filter += ATTR_NAME_DN;
	filter += _T("=");
	filter += DNPREFIX_ROUTERID;
	filter += machineName;
	filter += _T(",*");
#endif	
	filter += FILTER_POSTFIX;

	filter += FILTER_POSTFIX;
	// end of filter

	// Query the routerId Object
    // Search Routers under configuration
    CComPtr<IADs>           spIADs;
    CComPtr<IDirectorySearch>  spISearch;
    CString                 RIdPath;
    BSTR                 RRASPath = NULL;
    CString                 RRASDNSName;
    CComPtr<IADs>           spIADsRId;
    CComPtr<IADsContainer>  spIADsContainerRRAS;
    VARIANT                 var;
    CString                 strSearchScope;
    ADS_SEARCH_HANDLE         hSrch = NULL;
    ADS_SEARCH_COLUMN       colDN;       
      
   VariantInit(&var);
    // retieve the list of EAPTypes in the DS
    // get ROOTDSE
    // if no scope is specified, search the entire enterprise
   	CHECK_HR(hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**)&spIADs));

	ASSERT(spIADs.p);

	CHECK_HR(hr = spIADs->Get(L"rootDomainNamingContext", &var));

	ASSERT(V_BSTR(&var));
   
	strSearchScope = _T("LDAP://");

	strSearchScope += V_BSTR(&var);
	spIADs.Release();

      // Get the scope object
	CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)strSearchScope), IID_IDirectorySearch, (void**)&spISearch));
	ASSERT(spISearch.p);

    {
    	ADS_SEARCHPREF_INFO  s_aSearchPrefs[3];

		s_aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
		s_aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
		s_aSearchPrefs[0].vValue.Integer = DIR_SEARCH_PAGE_TIME_LIMIT;
		s_aSearchPrefs[0].dwStatus = ADS_STATUS_S_OK;

		s_aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		s_aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
		s_aSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;
		s_aSearchPrefs[1].dwStatus = ADS_STATUS_S_OK;

		s_aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
		s_aSearchPrefs[2].vValue.dwType = ADSTYPE_BOOLEAN;
		s_aSearchPrefs[2].vValue.Boolean = (ADS_BOOLEAN) -1;
		s_aSearchPrefs[2].dwStatus = ADS_STATUS_S_OK;

		PWSTR s_apwzAttrs[] = {  L"distinguishedName" };

		CHECK_HR(hr = spISearch->SetSearchPreference(s_aSearchPrefs, ARRAYSIZE(s_aSearchPrefs)));

		// do the search
		CHECK_HR(hr = spISearch->ExecuteSearch(T2W((LPTSTR)(LPCTSTR)filter),
                                      s_apwzAttrs, ARRAYSIZE(s_apwzAttrs), &hSrch));

		ASSERT(hSrch);

		do
		{
		//
		// Get the columns for each of the properties we are interested in, if
		// we failed to get any of the base properties for the object then lets
		// just skip this entry as we cannot build a valid IDLIST for it.  The
		// properties that we request should be present on all objects.
		//
			CHECK_HR(hr = spISearch->GetNextRow(hSrch));
            if(hr == S_OK) // it might equal to S_ADS_NOMORE_ROWS otherwise
            {
				CHECK_HR(hr = spISearch->GetColumn(hSrch, s_apwzAttrs[0], &colDN));
				RIdPath = _T("LDAP://");
				RIdPath += colDN.pADsValues->CaseIgnoreString;

#if 1	//uses computer to query
				spIADsContainerRRAS.Release();
				CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)RIdPath), IID_IADsContainer, (void**)&spIADsContainerRRAS));
				ASSERT(spIADsContainerRRAS.p);
#else	// uses routerID to query -- this mothed can not find the object, so changed
				spIADsRId.Release();
				CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)RIdPath), IID_IADs, (void**)&spIADsRId));

				ASSERT(spIADsRId.p);

				CHECK_HR(hr = spIADsRId->get_Parent(&RRASPath));

				spIADsContainerRRAS.Release();
				CHECK_HR(hr = ADsGetObject(RRASPath, IID_IADsContainer, (void**)&spIADsContainerRRAS));
				ASSERT(spIADsContainerRRAS.p);

				SysFreeString(RRASPath);
				RRASPath = NULL;
#endif
				VariantClear(&var);
				CHECK_HR(hr = spIADsContainerRRAS->Delete(ATTR_CLASS_RRASID, CN_ROUTERID));
            }
        } while( !FAILED(hr) && hr != S_ADS_NOMORE_ROWS);
	}
	// 

    
   // If there is more than one computer found, ( should not ) and give use a chance to delete one.
L_ERR:
   return S_OK;
}

HRESULT  RRASOpenQryDlg(
   /*[in]*/    CWnd*       pParent, 
   /*[in, out]*/  RRASQryData&   QryData
)
{
    CDlgSvr              dlg(QryData, pParent);
    HRESULT              hr = S_OK;
    
    if(dlg.DoModal() == IDOK)
    {
        if(QryData.dwCatFlag == RRAS_QRY_CAT_NT5LDAP)
            hr = RRASDSQueryDlg(pParent, QryData);
    }
    else
        hr = S_FALSE;
    
    return hr;
}

HRESULT  RRASDSQueryDlg(
   /*[in]*/    CWnd*       pParent, 
   /*[in, out]*/  RRASQryData&   QryData
)
{
    HRESULT              hr = S_OK;
    CComPtr<ICommonQuery>  spCommonQuery;
    CComPtr<IDataObject>   spDataObject;
    
    FORMATETC            fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM           medium = { TYMED_NULL, NULL, NULL };
    DSQUERYINITPARAMS       dqip;
    OPENQUERYWINDOW     oqw;
    
    CHECK_HR(hr = CoInitialize(NULL));    
    
    CHECK_HR(hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (LPVOID*)&spCommonQuery));
    
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags = 0;
    dqip.pDefaultScope = NULL;
    
    oqw.cbStruct = sizeof(oqw);
    oqw.dwFlags = 0;
    oqw.clsidHandler = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm = CLSID_RRASQueryForm;
    
    oqw.dwFlags |= OQWF_OKCANCEL;
    dqip.dwFlags |= DSQPF_NOSAVE;
    
    oqw.dwFlags |= OQWF_REMOVEFORMS;
    oqw.dwFlags |= OQWF_DEFAULTFORM;
    oqw.dwFlags |= OQWF_HIDEMENUS;
    oqw.dwFlags |= OQWF_HIDESEARCHUI;
    
    // Now display the dialog, and if we succeeded and get an IDataObject then
    // slurp the results into our list view.
    
    hr = spCommonQuery->OpenQueryWindow(NULL, &oqw, &spDataObject);
    
    if ( SUCCEEDED(hr) && spDataObject.p )
    {
        // now get the DSQUERYPARAMS and lets get the filter string
        if ( !g_cfDsQueryScope )
            g_cfDsQueryScope = RegisterClipboardFormat(CFSTR_DSQUERYSCOPE);
        
        fmte.cfFormat = (CLIPFORMAT) g_cfDsQueryScope;  
        
        if ( SUCCEEDED(spDataObject->GetData(&fmte, &medium)) )
        {
            LPWSTR pScopeStr = (LPWSTR)medium.hGlobal;
            QryData.strScope = pScopeStr;
            
            ReleaseStgMedium(&medium);
        }
        else
            QryData.strScope = _T("");
        
        
        
        if ( !g_cfDsQueryParams )
            g_cfDsQueryParams = RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);
        
        fmte.cfFormat = (CLIPFORMAT) g_cfDsQueryParams;  
        
        if ( SUCCEEDED(spDataObject->GetData(&fmte, &medium)) )
        {
            LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
            LPWSTR pFilter = (LPTSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery);
            QryData.strFilter = pFilter;
            
            ReleaseStgMedium(&medium);
        }
        else
            QryData.strFilter = _T("");
    }
    
L_ERR:

    CoUninitialize();
    return hr;
}

//
//    S_OK -- User select OK
//    S_FALSE -- User select Cancel
//    ERROR:
//       DS error, search activeDs.dll
//       Win32 erroe
//       LDAP error
//       General error -- memory, invalid argument ...

HRESULT  RRASExecQry(
					 /*[in]*/ RRASQryData&   QryData, 
					 /*[out]*/   DWORD&         dwFlags,
					 /*[out]*/   CStringArray&  RRASs
)
{
	USES_CONVERSION;

	HRESULT  hr = S_OK;
	
	switch(QryData.dwCatFlag)
	{
		case  RRAS_QRY_CAT_THIS:
		{
			CString machine;
			RRASs.Add(machine);
			break;
		}
		
		case  RRAS_QRY_CAT_MACHINE:
			
			RRASs.Add(QryData.strFilter);
			
			break;
			
			// NT4 Domain     
		case  RRAS_QRY_CAT_NT4DOMAIN:
		{
			LPWSTR            pDomainName;
			SERVER_INFO_100*  pServerInfo100 = NULL;
			SERVER_INFO_101*  pServerInfo101 = NULL;
			DWORD          dwRead;
			DWORD          dwTotal;
			DWORD		 index;
			BYTE		 flag;
			NET_API_STATUS       netret;
			
			dwFlags = RRAS_QRY_RESULT_HOSTNAME;
			
			if(QryData.strScope.IsEmpty())   
				return E_INVALIDARG;
			
			// Although the API excepts TCHAR it is exclusively UNICODE
			if (QryData.strScope.Left(2) != _T("\\\\"))
				pDomainName = T2W((LPTSTR)(LPCTSTR)QryData.strScope);
			else
				pDomainName = T2W((LPTSTR)(LPCTSTR)QryData.strScope + 2);

			// Check for dot. (FQDNs are not accepted)
			index = 0;
			while(pDomainName[index] != L'\0'){
				if(pDomainName[index] == L'.'){
					// Error out					
					AfxMessageBox(IDS_ERR_DOMAIN_FORMAT);
					return E_INVALIDARG;
				}
				index++;
			}
			
			do
			{
				CWaitCursor wCursor;
				
				netret = ::NetServerEnum(NULL, 101, (LPBYTE*)&pServerInfo101, 
										 0xffffffff, &dwRead, &dwTotal, SV_TYPE_DIALIN_SERVER,
										 pDomainName, NULL);
				
				if(pServerInfo101 && netret == NERR_Success || netret == ERROR_MORE_DATA)
				{
					PSERVER_INFO_101 pSvInfo101_t = pServerInfo101;
					CString  serverName;
					
					for (;dwRead > 0; dwRead--, pSvInfo101_t++)
					{
// this option should addin all the server in the NT4 domain, not the NT4 servers in the domain					
//						if(pSvInfo101_t->sv101_version_major == 4)
						{
							serverName = (LPWSTR)pSvInfo101_t->sv101_name;
							RRASs.Add(serverName);
						}
					}
					
					NetApiBufferFree(pServerInfo101);
				}
					
			} while (netret == ERROR_MORE_DATA);
			
			if(netret == NERR_Success)
				hr = S_OK;
			else if (netret != ERROR_ACCESS_DENIED) {
				// Error out					
				AfxMessageBox(IDS_ERR_DOMAIN_NAME);
				return E_INVALIDARG;				
			}
			else
				hr = HRESULT_FROM_WIN32(netret);
			
		}
		break;
		
		// NT5 LADP Query    
		case  RRAS_QRY_CAT_NT5LDAP:
		{
			// Search Routers under configuration
			CComPtr<IADs>           spIADs;
			CComPtr<IDirectorySearch>  spISearch;
			CString                 RIdPath;
			BSTR                 RRASPath = NULL;
			CString                 RRASDNSName;
			CComPtr<IADs>           spIADsRId;
			CComPtr<IADs>           spIADsRRAS;
			VARIANT                 var;
			CString                 strSearchScope;
			ADS_SEARCH_HANDLE         hSrch = NULL;
			ADS_SEARCH_COLUMN       colDN;       
			CWaitCursor				cw;
			
			//      dwFlags = RRAS_QRY_RESULT_DNSNAME;
			dwFlags = RRAS_QRY_RESULT_HOSTNAME;
			
			
			VariantInit(&var);
			// retieve the list of EAPTypes in the DS
			// get ROOTDSE
			// if no scope is specified, search the entire enterprise
			if(QryData.strScope.IsEmpty())
			{
				CHECK_HR(hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**)&spIADs));
				
				ASSERT(spIADs.p);
				
				CHECK_HR(hr = spIADs->Get(L"rootDomainNamingContext", &var));
				
				ASSERT(V_BSTR(&var));
				
				strSearchScope = _T("LDAP://");
				
				strSearchScope += V_BSTR(&var);
				spIADs.Release();
			}
			else
				strSearchScope = QryData.strScope;
			
			
			// Get the scope object
			CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)strSearchScope), IID_IDirectorySearch, (void**)&spISearch));
			ASSERT(spISearch.p);
			
			{
				ADS_SEARCHPREF_INFO  s_aSearchPrefs[3];
				
				s_aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
				s_aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
				s_aSearchPrefs[0].vValue.Integer = DIR_SEARCH_PAGE_TIME_LIMIT;
				s_aSearchPrefs[0].dwStatus = ADS_STATUS_S_OK;
				
				s_aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
				s_aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
				s_aSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;
				s_aSearchPrefs[1].dwStatus = ADS_STATUS_S_OK;
				
				s_aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
				s_aSearchPrefs[2].vValue.dwType = ADSTYPE_BOOLEAN;
				s_aSearchPrefs[2].vValue.Boolean = (ADS_BOOLEAN) -1;
				s_aSearchPrefs[2].dwStatus = ADS_STATUS_S_OK;
				
				PWSTR s_apwzAttrs[] = {  L"distinguishedName" };
				
				CHECK_HR(hr = spISearch->SetSearchPreference(s_aSearchPrefs, ARRAYSIZE(s_aSearchPrefs)));
				
				// do the search
				CHECK_HR(hr = spISearch->ExecuteSearch(T2W((LPTSTR)(LPCTSTR)QryData.strFilter),
					s_apwzAttrs, ARRAYSIZE(s_apwzAttrs), &hSrch));
				
				ASSERT(hSrch);
				
				do
				{
					//
					// Get the columns for each of the properties we are interested in, if
					// we failed to get any of the base properties for the object then lets
					// just skip this entry as we cannot build a valid IDLIST for it.  The
					// properties that we request should be present on all objects.
					//
					CHECK_HR(hr = spISearch->GetNextRow(hSrch));
					if(hr == S_OK) // it might equal to S_ADS_NOMORE_ROWS otherwise
					{
						CHECK_HR(hr = spISearch->GetColumn(hSrch, s_apwzAttrs[0], &colDN));
						RIdPath = _T("LDAP://");
						RIdPath += colDN.pADsValues->CaseIgnoreString;
						
						spIADsRId.Release();
						CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)RIdPath), IID_IADs, (void**)&spIADsRId));
						
						ASSERT(spIADsRId.p);
						
						CHECK_HR(hr = spIADsRId->get_Parent(&RRASPath));
						
						spIADsRRAS.Release();
						CHECK_HR(hr = ADsGetObject(RRASPath, IID_IADs, (void**)&spIADsRRAS));
						ASSERT(spIADsRRAS.p);
						
						SysFreeString(RRASPath);
						RRASPath = NULL;
						
						VariantClear(&var);
						//	build 1750, this is empty, changed to "name"
						//               CHECK_HR(hr = spIADsRRAS->Get(L"dNSHostName", &var));
						CHECK_HR(hr = spIADsRRAS->Get(L"name", &var));
						
						RRASDNSName = V_BSTR(&var);
						
						if(!RRASDNSName.IsEmpty())
							RRASs.Add(RRASDNSName);
					}
					
				} while( !FAILED(hr) && hr != S_ADS_NOMORE_ROWS);
			}
			
L_ERR:
			if(hSrch)
				CHECK_HR(hr = spISearch->CloseSearchHandle(hSrch));
	
			VariantClear(&var);
			SysFreeString(RRASPath);
		}
		break;
		default:
			hr = E_INVALIDARG;
	}

	if (FAILED(hr))
		DisplayErrorMessage(NULL, hr);
	return hr;
}
	

   
//    S_OK -- User select OK
//    ERROR:
//       DS error, search activeDs.dll
//       Win32 erroe
//       LDAP error
//       General error -- memory, invalid argument ...
/////////////////////////////////////////////////////////////////////////////
// CDlgSvr dialog

RRASQryData __staticQueryData;
CDlgSvr::CDlgSvr(CWnd* pParent /*=NULL*/)
   : m_QueryData(__staticQueryData), CBaseDialog(CDlgSvr::IDD, pParent)
{
   Init();
}

CDlgSvr::CDlgSvr(RRASQryData& QueryData, CWnd* pParent /*=NULL*/)
   : m_QueryData(QueryData), CBaseDialog(CDlgSvr::IDD, pParent)
{
   Init();
}

void CDlgSvr::Init()
{
   //{{AFX_DATA_INIT(CDlgSvr)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

void CDlgSvr::DoDataExchange(CDataExchange* pDX)
{
   CBaseDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgSvr)
   DDX_Control(pDX, IDC_QRY_EDIT_MACHINE, m_editMachine);
   DDX_Control(pDX, IDC_QRY_EDIT_DOMAIN, m_editDomain);
   DDX_Control(pDX, IDOK, m_btnOk);
   DDX_Control(pDX, IDNEXT, m_btnNext);
   DDX_Radio(pDX, IDC_QRY_RADIO_THIS, m_nRadio);
   DDX_Text(pDX, IDC_QRY_EDIT_DOMAIN, m_strDomain);
   DDV_MaxChars(pDX, m_strDomain, 253);
   if(m_nRadio == 2)
   {
      DDV_MinChars(pDX, m_strDomain, 1);
   }
   
   DDX_Text(pDX, IDC_QRY_EDIT_MACHINE, m_strMachine);
   DDV_MaxChars(pDX, m_strMachine, 253);
   if(m_nRadio == 1)
   {
      DDV_MinChars(pDX, m_strMachine, 1);
   }
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgSvr, CBaseDialog)
   //{{AFX_MSG_MAP(CDlgSvr)
   ON_BN_CLICKED(IDC_QRY_RADIO_ANOTHER, OnRadioAnother)
   ON_BN_CLICKED(IDC_QRY_RADIO_NT4, OnRadioNt4)
   ON_BN_CLICKED(IDC_QRY_RADIO_NT5, OnRadioNt5)
   ON_BN_CLICKED(IDC_QRY_RADIO_THIS, OnRadioThis)
   ON_BN_CLICKED(IDOK, OnButtonNext)
   ON_BN_CLICKED(IDNEXT, OnButtonNext)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgSvr message handlers

void CDlgSvr::OnRadioAnother() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  str;

   str.LoadString(IDS_OK);
   m_editMachine.EnableWindow(TRUE);   
   m_editDomain.EnableWindow(FALSE);   
//   m_btnNext.SetWindowText(str);

//Enable the OK button, hide the NEXT button
	m_btnOk.EnableWindow(TRUE);
	m_btnOk.ShowWindow(SW_SHOW);
	m_btnNext.EnableWindow(FALSE);
	m_btnNext.ShowWindow(SW_HIDE);
}

void CDlgSvr::OnRadioNt4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  str;

   str.LoadString(IDS_OK);
   m_editMachine.EnableWindow(FALSE);  
   m_editDomain.EnableWindow(TRUE); 
 //  m_btnNext.SetWindowText(str);

//Enable the OK button, hide the NEXT button
	m_btnOk.EnableWindow(TRUE);
	m_btnOk.ShowWindow(SW_SHOW);
	m_btnNext.EnableWindow(FALSE);
	m_btnNext.ShowWindow(SW_HIDE);
}

void CDlgSvr::OnRadioNt5() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  str;

   str.LoadString(IDS_NEXT);
   m_editMachine.EnableWindow(FALSE);  
   m_editDomain.EnableWindow(FALSE);   
 //  m_btnNext.SetWindowText(str);

 //Enable the NEXT button, hide the OK button
	m_btnNext.EnableWindow(TRUE);
	m_btnNext.ShowWindow(SW_SHOW);
	m_btnOk.EnableWindow(FALSE);
	m_btnOk.ShowWindow(SW_HIDE);
 }

void CDlgSvr::OnRadioThis() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  str;

   str.LoadString(IDS_OK);
   m_editMachine.EnableWindow(FALSE);  
   m_editDomain.EnableWindow(FALSE);   
 //  m_btnNext.SetWindowText(str);

//Enable the OK button, hide the NEXT button
	m_btnOk.EnableWindow(TRUE);
	m_btnOk.ShowWindow(SW_SHOW);
	m_btnNext.EnableWindow(FALSE);
	m_btnNext.ShowWindow(SW_HIDE);
}

void CDlgSvr::OnButtonNext() 
{
   if(UpdateData(TRUE) == 0) return;

   switch(m_nRadio)
   {
   case  0:
      m_QueryData.dwCatFlag = RRAS_QRY_CAT_THIS;
      break;
   case  1:
      m_QueryData.dwCatFlag = RRAS_QRY_CAT_MACHINE;
      m_QueryData.strFilter = m_strMachine;
      break;
   case  2:
      m_QueryData.dwCatFlag = RRAS_QRY_CAT_NT4DOMAIN;
      m_QueryData.strScope = m_strDomain;      
      break;
   case  3:
      m_QueryData.dwCatFlag = RRAS_QRY_CAT_NT5LDAP;
      break;
   default:
      ASSERT(0);  // this should not happen
      break;
   }
   
   EndDialog(IDOK);  
}

/////////////////////////////////////////////////////////////////////////////
// CDlgSrv message handlers

/////////////////////////////////////////////////////////////////////////////
// CDlgSvr1 message handlers

BOOL CDlgSvr::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   BOOL  bEnableMachine = FALSE, bEnableDomain = FALSE;
   UINT  okIDS = IDS_OK;
   
   switch(m_QueryData.dwCatFlag)
   {
   case  RRAS_QRY_CAT_THIS:
      m_nRadio = 0;
      break;
   case  RRAS_QRY_CAT_MACHINE:
      bEnableMachine = TRUE;
      m_strMachine = m_QueryData.strFilter;
      m_nRadio = 1;
      break;
   case  RRAS_QRY_CAT_NT4DOMAIN:
      bEnableDomain = TRUE;
      m_strDomain = m_QueryData.strScope;
      m_nRadio = 2;
      break;
   case  RRAS_QRY_CAT_NT5LDAP:
      m_nRadio = 3;
      okIDS = IDS_NEXT;
      break;
   default:
      m_nRadio = 0;
      break;
   }
   
   CBaseDialog::OnInitDialog();

   if(okIDS == IDS_OK){
	//Enable the OK button and disable the NEXT button
	m_btnOk.EnableWindow(TRUE);
	m_btnOk.ShowWindow(SW_SHOW);
	m_btnNext.EnableWindow(FALSE);
	m_btnNext.ShowWindow(SW_HIDE);
   }
   else if(okIDS == IDS_NEXT){
   	//Enable the NEXT button and disable the OK button
	m_btnNext.EnableWindow(TRUE);
	m_btnNext.ShowWindow(SW_SHOW);
	m_btnOk.EnableWindow(FALSE);
	m_btnOk.ShowWindow(SW_HIDE);
   }

   m_editMachine.EnableWindow(bEnableMachine);  
   m_editDomain.EnableWindow(bEnableDomain); 

/*
   CString  str;

   str.LoadString(IDS_OK);
   m_btnOk.SetWindowText(str);

   str.LoadString(IDS_NEXT);
   m_btnNext.SetWindowText(str);
*/

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rraswiz.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   rraswiz.h

   FILE HISTORY:
        
*/

#if !defined _RRASWIZ_H_
#define _RRASWIZ_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "listctrl.h"
#include "ports.h"
#include "rasppp.h"        // for PPPCFG_XXX constants
#include "rtrcfg.h"        // for DATA_SRV_??? structures
#include "rtrwiz.h"

#ifndef _ADDRPOOL_H_
#include "addrpool.h"
#endif

//Entry point flags for CYS Express Setup
#define MPRSNAP_CYS_EXPRESS_NONE				0x00000000
#define MPRSNAP_CYS_EXPRESS_NAT					0x00000001




// forward declarations
class CNewRtrWiz;

/*---------------------------------------------------------------------------
    Here are a list of the pages used by the install wizard

    CNewRtrWizWelcome                       - IDD_NEWRTRWIZ_WELCOME
    CNewRtrWizCommonConfig                  - IDD_NEWRTRWIZ_COMMONCONFIG
    CNewRtrWizNatFinishAConflict            - IDD_NEWRTRWIZ_NAT_A_CONFLICT
    CNewRtrWizNatFinishAConflictNonLocal    - IDD_NEWRTRIWZ_NAT_A_CONFLICT_NONOLOCAL
    CNewRtrWizNatFinishNoIP                 - IDD_NEWRTRWIZ_NAT_NOIP
    CNewRtrWizNatFinishNoIPNonLocal         - IDD_NEWRTRWIZ_NAT_NOIP_NONLOCAL
    CNewRtrWizNatChoice                     - IDD_NEWRTRWIZ_NAT_CHOOSE

    CNewRtrWizNatSelectPublic               - IDD_NEWRTRWIZ_NAT_A_PUBLIC
    CNewRtrWizNatSelectPrivate              - IDD_NEWRTRWIZ_NAT_A_PRIVATE
    CNewRtrWizNatFinishAdvancedNoNICs       - IDD_NEWRTRWIZ_NAT_A_NONICS_FINISH
    CNewRtrWizNatDHCPDNS                    - IDD_NEWRTRWIZ_NAT_A_DHCPDNS
    CNewRtrWizNatDHCPWarning                - IDD_NEWRTRWIZ_NAT_A_DHCP_WARNING
    CNewRtrWizNatDDWarning                  - IDD_NEWRTRWIZ_NAT_A_DD_WARNING
    CNewRtrWizNatFinish                     - IDD_NEWRTRWIZ_NAT_A_FINISH
    CNewRtrWizNatFinishExternal             - IDD_NEWRTRWIZ_NAT_A_EXTERNAL_FINISH
    CNewRtrWizNatFinishDDError              - IDD_NEWRTRWIZ_NAT_DD_ERROR

    
    // Some base classes for dialogs common to RAS and VPN

    CNewRtrWizAddressing             (no dialog)
    CNewRtrWizAddressPool                   (no dialog)
    CNewRtrWizRadius                        (no dialog)
    CNewRtrWizRadiusConfig                  (no dialog)


    CNewRtrWizRasFinishNeedProtocols        - IDD_NEWRTRWIZ_RAS_A_NEED_PROT
    CNewRtrWizRasFinishNeedProtocolsNonLocal - IDD_NEWRTRWIZ_RAS_A_NEED_PROT_NONLOCAL
    CNewRtrWizRasAtalk                      - IDD_NEWRTRWIZ_RAS_A_ATALK
    CNewRtrWizRasSelectNetwork              - IDD_NEWRTRWIZ_RAS_A_NETWORK
    CNewRtrWizRasNoNICs                     - IDD_NEWRTRWIZ_RAS_A_NONICS
    CNewRtrWizRasFinishNoNICs               - IDD_NEWRTRWIZ_RAS_A_FINISH_NONICS

        
    CNewRtrWizRasFinishAdvanced             - IDD_NEWRTRWIZ_RAS_A_FINISH

    CNewRtrWizVpnFinishNoIP                 - IDD_NEWRTRWIZ_VPN_NOIP
    CNewRtrWizVpnFinishNoIPNonLocal         - IDD_NEWRTRWIZ_VPN_NOIP_NONLOCAL

    CNewRtrWizVpnFinishNeedProtocols        - IDD_NEWRTRWIZ_VPN_A_NEED_PROT
    CNewRtrWizVpnFinishNeedProtocolsNonLocal - IDD_NEWRTRWIZ_V_A_NEED_PROT_NONLOCAL
    CNewRtrWizVpnFinishNoNICs               - IDD_NEWRTRWIZ_VPN_A_FINISH_NONICS
    CNewRtrWizVpnAtalk                      - IDD_NEWRTRWIZ_VPN_A_ATALK
    CNewRtrWizVpnSelectPublic               - IDD_NEWRTRWIZ_VPN_A_PUBLIC
    CNewRtrWizVpnSelectPrivate              - IDD_NEWRTRWIZ_VPN_A_PRIVATE

    
    CNewRtrWizVpnRadius                     - IDD_NEWRTRWIZ_VPN_A_USERADIUS
    CNewRtrWizVpnRadiusConfig               - IDD_NEWRTRWIZ_VPN_A_RADIUS_CONFIG
    CNewRtrWizVpnFinishAdvanced             - IDD_NEWRTRWIZ_VPN_A_FINISH


    CNewRtrWizRouterNeedProtocols           - IDD_NEWRTRWIZ_ROUTER_NEED_PROT
    CNewRtrWizRouterNeedProtocolsNonLocal   - IDD_NEWRTRWIZ_ROUTER_NEED_PROT_NONLOCAL
    CNewRtrWizRouterUseDD                   - IDD_NEWRTRWIZ_ROUTER_USEDD

    
    CNewRtrWizRouterFinish                  - IDD_NEWRTRWIZ_ROUTER_FINISH
    CNewRtrWizRouterFinishDD                - IDD_NEWRTRWIZ_ROUTER_FINISH_DD

    CNewRtrWizManualFinish                  - IDD_NEWRTRWIZ_MANUAL_FINISH

    CNewRtrWizCustomConfig                  - IDD_NEWRTRWIZ_CUSTOM_CONFIG
    CNewRtrWizRRasVPN                       - IDD_NEWRTRWIZ_RRASVPN
    
 ---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Class : RtrWizInterface

    This class holds the per-interface info for the wizard.

    This class is setup before coming into the wizard.  The list
    of interfaces is obtained from the router.  The relevant data is
    then filled in from the registry (there are no remote API calls).

    The DHCP and DNS checks will be done on a per-interface basis.
 ---------------------------------------------------------------------------*/
class RtrWizInterface
{
public:
    CString     m_stId;     // ID for the interface
    CString     m_stName;   // Friendly name for the interface
    CString     m_stDesc;

    // IP Address for this interface
    // Do we need to show multiple IP addresses? (why?)
    // This list is obtained from the iphlp apis
    CString     m_stIpAddress;
    CString     m_stMask;
    BOOL        m_fDhcpObtained;

    // IP address of the DHCP Server
    CString     m_stDhcpServer;

    BOOL        m_fIsDhcpEnabled;
    BOOL        m_fIsDnsEnabled;
};

// This is the map used to hold all of the interface information
typedef CMap<CString, LPCTSTR, RtrWizInterface *, RtrWizInterface *> RtrWizInterfaceMap;


/*---------------------------------------------------------------------------
    This is used to determine the action at the end of the wizard.

    Typically
        SaveFlag_DoNothing  - exactly what it means, do nothing.
        SaveFlag_Simple     - launch the connections UI (simple UI)
        SaveFlag_Advanced   - do the full wizard save/config
 ---------------------------------------------------------------------------*/
enum RtrWizFinishSaveFlag
{
    SaveFlag_DoNothing = 0,
    SaveFlag_Simple = 1,
    SaveFlag_Advanced = 2
};


/*---------------------------------------------------------------------------
    Determine what help to launch after the wizard    
 ---------------------------------------------------------------------------*/
enum RtrWizFinishHelpFlag
{
    HelpFlag_Nothing = 0,
    HelpFlag_AddIp = 1,                 // how to add IP
    HelpFlag_ICS = 2,                   // how to add ICS
    HelpFlag_AddProtocol = 3,           // how to add a protocol
    HelpFlag_InboundConnections = 4,    // how to add inbound conn
    HelpFlag_GeneralNAT = 5,            // NAT port mappings
    HelpFlag_GeneralRAS = 6,            // general RAS finish help
    HelpFlag_UserAccounts = 7,          // help on setting up dialin 
                                        // permissions
    HelpFlag_Dhcp = 8,                   // general help on dhcp
    HelpFlag_DemandDial = 9    // help on demand dial


};


enum RtrWizProtocolId
{
    RtrWizProtocol_None = 0,
    RtrWizProtocol_Ip = 1,
    RtrWizProtocol_Ipx = 2,
    RtrWizProtocol_Appletalk = 3,
    RtrWizProtocol_Nbf = 4
};


// These are special values for the return from NewRtrWizData::GetNextPage().

// This indicates that the wizard should be cancelled
#define ERR_IDD_CANCEL_WIZARD   (-2)

// Cancel out of the wizard (but call the OnWizardFinish()).
#define ERR_IDD_FINISH_WIZARD   (-3)

//New wizard options
#define NEWWIZ_ROUTER_TYPE_UNKNOWN              0x00000000
#define NEWWIZ_ROUTER_TYPE_NAT                  0x00000001
#define NEWWIZ_ROUTER_TYPE_DIALUP               0x00000002
#define NEWWIZ_ROUTER_TYPE_VPN                  0x00000004
#define NEWWIZ_ROUTER_TYPE_DOD                  0x00000008
#define NEWWIZ_ROUTER_TYPE_LAN_ROUTING          0x00000010
#define NEWWIZ_ROUTER_TYPE_BASIC_FIREWALL       0x00000020

//combinations

//A utility function, that gives info about the status of ICF/ICS/IC on the machine
BOOL IsIcsIcfIcEnabled(IRouterInfo *spRouterInfo, BOOL suppressMesg = FALSE);

HRESULT DisableRRAS(TCHAR * szMachineName);


/*---------------------------------------------------------------------------
    NewRtrWizData

    This structure is used to maintain all of the information needed
    by the pages. This way I can persist this stuff all at the end of
    the wizard.

    There are two parts to this structure.

    The first part is the data that is being set.

    The second part are parameters (they are queries that are being
    made as we go through the system).  These will be set by the test
    code but will eventually be made into code.
 ---------------------------------------------------------------------------*/
class NewRtrWizData
{
public:
    friend class    CNewWizTestParams;
    friend class    CNewRtrWizNatDDWarning;

    // This is the type of RRAS install that is being performed
    // ----------------------------------------------------------------
    enum WizardRouterType
    {
        NewWizardRouterType_DialupOrVPN = 0,
        NewWizardRouterType_NAT,
        NewWizardRouterType_VPNandNAT,
        NewWizardRouterType_DOD,
        NewWizardRouterType_Custom

    };

    WizardRouterType    m_wizType;
    DWORD               m_dwNewRouterType;
    DWORD               m_dwRouterType; // only used during the finish
	DWORD				m_dwExpressType;		//Express Type for the wizard
    BOOL                m_fNATEnableFireWall;   //Enable firewall on NAT public interface

    // This is TRUE if the data has already been saved (this is
    // for the NAT scenario, when we presave and then launch the
    // DD wizard).
    // ----------------------------------------------------------------
    BOOL                m_fSaved;
    BOOL                m_fShowDhcpHelp;


    // Constructor
    // ----------------------------------------------------------------
    NewRtrWizData()
    {
        // Defaults
        m_wizType = NewWizardRouterType_DialupOrVPN;
        m_dwNewRouterType = NEWWIZ_ROUTER_TYPE_UNKNOWN;

        m_fTest = FALSE;

        m_SaveFlag = SaveFlag_Advanced;
        m_HelpFlag = HelpFlag_Nothing;
        m_fAdvanced = FALSE;
        m_fCreateDD = FALSE;
        m_fUseDD = TRUE;
        m_hrDDError = hrOK;
        m_fWillBeInDomain = FALSE;
        m_fUseIpxType20Broadcasts = FALSE;
        m_fAppletalkUseNoAuth = FALSE;
        m_fUseDHCP = TRUE;
        m_fUseRadius = FALSE;
        m_fNeedMoreProtocols = FALSE;
        m_fNoNicsAreOk = FALSE;
        m_fNatUseSimpleServers = TRUE;
        m_fNatUseExternal = FALSE;
        m_fSetVPNFilter = FALSE;
        
        m_netRadius1IpAddress = 0;
        m_netRadius2IpAddress = 0;

        m_fSaved = FALSE;

        m_dwNumberOfNICs_IPorIPX = 0;
		m_dwExpressType = MPRSNAP_CYS_EXPRESS_NONE;
        m_fNATEnableFireWall  = -1;
        m_fShowDhcpHelp = FALSE;
		m_hr = hrOK;
    }

    ~NewRtrWizData();

    HRESULT Init(LPCTSTR pszServerName, IRouterInfo *pRouter, DWORD dwExpressType = MPRSNAP_CYS_EXPRESS_NONE);
    HRESULT FinishTheDamnWizard(HWND hwndOwner, IRouterInfo *pRouter,  BOOL  mesgflag=FALSE);

    // Query functions.  These will determine the state of the
    // machine.
    // ----------------------------------------------------------------
    HRESULT HrIsIPInstalled();
    HRESULT HrIsIPXInstalled();
    HRESULT HrIsAppletalkInstalled();
    HRESULT HrIsNbfInstalled();

    HRESULT HrIsIPInUse();
    HRESULT HrIsIPXInUse();
    HRESULT HrIsAppletalkInUse();
    HRESULT HrIsNbfInUse();

    HRESULT HrIsLocalMachine();
    
    HRESULT HrIsDNSRunningOnInterface();
    HRESULT HrIsDNSRunningOnGivenInterface(CString InterfaceId);
    HRESULT HrIsDNSRunningOnNATInterface();
    HRESULT HrIsDHCPRunningOnInterface();
    HRESULT HrIsDHCPRunningOnGivenInterface(CString InterfaceId);
    HRESULT HrIsDHCPRunningOnNATInterface();
    
    HRESULT HrIsDNSRunningOnServer();
    HRESULT HrIsDHCPRunningOnServer();

    HRESULT HrIsSharedAccessRunningOnServer();

    HRESULT HrIsMemberOfDomain();
	UINT GetStartPageId ();

    // Given the page, determine the next page
    // This is done to centralize the logic (rather than copying
    // and splitting the logic up).
    LRESULT GetNextPage(UINT uDialogId);

    
    
    // This function is pure test code, the real way to do this is
    // to use the IRouterInfo
    HRESULT GetNumberOfNICS_IP(DWORD *pdwNumber);
    HRESULT    GetNumberOfNICS_IPorIPX(DWORD *pdwNumber);
    HRESULT QueryForTestData();
    BOOL    m_fTest;

    // User-selections

    // Name of the machine, if blank assume local machine
    CString m_stServerName;

    RtrWizFinishSaveFlag    m_SaveFlag;
    RtrWizFinishHelpFlag    m_HelpFlag;

    // If this is FALSE, then the user chose to use the Connections UI.
    BOOL    m_fAdvanced;

    // If this is TRUE, then we have exited
    BOOL    m_fNeedMoreProtocols;

    // If this is TRUE, then we are to create a DD interface
    BOOL    m_fCreateDD;

    // This is the ID of the public interface (this should be empty if
    // m_fCreateDD is TRUE).
    CString m_stPublicInterfaceId;

    // This is the ID of the private interface
    CString m_stPrivateInterfaceId;

    //This is the ID of Private interface for NAT/VPN combo
    CString m_stNATPrivateInterfaceId;

    // This is usually set when the machine is not currently in a
    // domain but may join at a later time.
    BOOL    m_fWillBeInDomain;

    BOOL    m_fNoNicsAreOk;

    BOOL    m_fUseIpxType20Broadcasts;
    BOOL    m_fAppletalkUseNoAuth;


    // Address pool information
    // ----------------------------------------------------------------
    BOOL    m_fUseDHCP;
    
    // List of address ranges in the address pool.  This list will
    // only be used if m_fUseDHCP is FALSE.
    AddressPoolList   m_addressPoolList;



    // RADIUS information
    // ----------------------------------------------------------------
    BOOL    m_fUseRadius;       // TRUE if we are to use Radius
    CString m_stRadius1;        // Name of the primary RADIUS server
    CString m_stRadius2;        // Name of the secondary RADIUS server
    CString m_stRadiusSecret;   // munged shared secret
    UCHAR   m_uSeed;            // key to munged radius secret

    // These should be in NETWORK order
    DWORD   m_netRadius1IpAddress;
    DWORD   m_netRadius2IpAddress;
    
    HRESULT SaveRadiusConfig();
    

    // Protocol information
    // ----------------------------------------------------------------
    BOOL        m_fIpInUse;
    BOOL        m_fIpxInUse;
    BOOL        m_fAppletalkInUse;
    BOOL        m_fNbfInUse;


    // NAT information
    // If this TRUE, then NAT will use its own DHCP/DNS servers
    // ----------------------------------------------------------------
    BOOL    m_fNatUseSimpleServers;
    BOOL    m_fNatUseExternal;


    // VPN only Server
    // If this is true, filters will be plumbed on the public
    //  interface to the Internet to allow only VON traffic through
    //
    BOOL m_fSetVPNFilter;
    
    // Router DD information
    // ----------------------------------------------------------------
    // If this is TRUE, then the router wants to use a DD interface
    // This is only used when the wizard type is for a router.
    BOOL    m_fUseDD;

    // This is the error result from the DD interface wizard
    HRESULT m_hrDDError;



    // This function will select the interface that is not the public
    // interface.
    void    AutoSelectPrivateInterface();
    void    AutoSelectNATPrivateInterface();
    void    LoadInterfaceData(IRouterInfo *pRouter);
    RtrWizInterfaceMap  m_ifMap;
    DWORD    m_dwNumberOfNICs_IPorIPX;
	HRESULT		m_hr;			//last result of operation for the wizard

protected:
    // This is TEST code.  Do not use these variables, use the
    // functions instead.
    static BOOL     s_fIpInstalled;
    static BOOL     s_fIpxInstalled;
    static BOOL     s_fAppletalkInstalled;
    static BOOL     s_fNbfInstalled;
    static BOOL     s_fIsLocalMachine;
    static BOOL     s_fIsDNSRunningOnPrivateInterface;
    static BOOL     s_fIsDHCPRunningOnPrivateInterface;
    static BOOL     s_fIsSharedAccessRunningOnServer;    
    static BOOL     s_fIsMemberOfDomain;
    
    static DWORD    s_dwNumberOfNICs;

    // These are the real variables (used for the real thing)
    // ----------------------------------------------------------------
    BOOL        m_fIpInstalled;
    BOOL        m_fIpxInstalled;
    BOOL        m_fAppletalkInstalled;
    BOOL        m_fNbfInstalled;


    // DHCP/DNS service information.  This information is stored here
    // as cached information.
    // ----------------------------------------------------------------
    BOOL        m_fIsDNSRunningOnServer;
    BOOL        m_fIsDHCPRunningOnServer;


    // There is a two step-process, first we have to save the info
    // from our data-gathering into the DATA_SRV_XXX structures.  And
    // then we tell the DATA_SRV_XXX structures to save themselves
    // into the registry.
    // ----------------------------------------------------------------
    HRESULT     SaveToRtrConfigData();

    RtrConfigData   m_RtrConfigData;
};


/*---------------------------------------------------------------------------
    Class : CNewRtrWizPageBase

    This class implements the common router install wizard base
    wizard page functionality.

    The major function provides for a stack-based way of keeping
    track of which pages have been seen (this makes OnWizardBack()
    really easy).
 ---------------------------------------------------------------------------*/

// forward declaration
class   CNewRtrWizPageBase;

// The page stack consists of a series of DWORDs
typedef CList<DWORD, DWORD> PageStack;

// The list of pages consists of CNewRtrWizPageBase ptrs.
typedef CList<CNewRtrWizPageBase *, CNewRtrWizPageBase *> PPageList;

class CNewRtrWizPageBase : public CPropertyPageBase
{
public:
    enum PageType
    {
        Start = 0,
        Middle,
        Finish
    };

    
    CNewRtrWizPageBase(UINT idd, PageType pt);

    void    PushPage(UINT idd);
    UINT    PopPage();

    virtual BOOL    OnInitDialog();    
    virtual BOOL    OnSetActive();
     virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();
    virtual BOOL    OnWizardFinish();
    virtual void OnCancel();
    afx_msg LRESULT OnHelp(WPARAM, LPARAM);

    // The derived class should implement this
    virtual HRESULT OnSavePage();

    virtual void Init(NewRtrWizData* pRtrWizData, CNewRtrWiz *pRtrWiz)
            { m_pRtrWizData = pRtrWizData; m_pRtrWiz = pRtrWiz; }

protected:

    NewRtrWizData* m_pRtrWizData;
    CNewRtrWiz *    m_pRtrWiz;

    static PageStack m_pagestack;
    PageType        m_pagetype;
    UINT            m_uDialogId;

    // This is the font used for the big finish text
    CFont           m_fontBig;

    // This is the font used for the bullets
    CFont           m_fontBullet;
    
    DECLARE_MESSAGE_MAP()   
};




/*---------------------------------------------------------------------------
    Base class for the finish pages
 ---------------------------------------------------------------------------*/

class CNewRtrWizFinishPageBase : public CNewRtrWizPageBase
{
public:

    CNewRtrWizFinishPageBase(UINT idd,
                             RtrWizFinishSaveFlag SaveFlag,
                             RtrWizFinishHelpFlag HelpFlag);

    virtual BOOL    OnInitDialog();
    virtual BOOL    OnWizardFinish();
    virtual BOOL    OnSetActive();

protected:
    RtrWizFinishSaveFlag    m_SaveFlag;
    RtrWizFinishHelpFlag    m_HelpFlag;
    
    DECLARE_MESSAGE_MAP()   
};

//
// This makes it easier to create new finish pages
//
#define DEFINE_NEWRTRWIZ_FINISH_PAGE(classname, dialogid) \
class classname : public CNewRtrWizFinishPageBase \
{                                           \
public:                                     \
    classname();                            \
    enum { IDD = dialogid };                \
protected:                                  \
    DECLARE_MESSAGE_MAP()                   \
};

#define IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(classname, saveflag, helpflag)  \
classname::classname() :                             \
   CNewRtrWizFinishPageBase(classname::IDD, saveflag, helpflag) \
{                                                   \
    InitWiz97(TRUE, 0, 0);                          \
}                                                   \
                                                    \
BEGIN_MESSAGE_MAP(classname, CNewRtrWizFinishPageBase)    \
END_MESSAGE_MAP()                                   \


                                                   

// Utility functions

/*!--------------------------------------------------------------------------
    InitializeInterfaceListControl
        This will populate the list control with LAN interfaces for
        the router.

        It will also add the appropriate columns to the list control.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InitializeInterfaceListControl(IRouterInfo *pRouter,
                                       CListCtrl *pListCtrl,
                                       LPCTSTR pszExcludedIf,
                                       LPARAM flags,
                                       NewRtrWizData *pWizData);

HRESULT RefreshInterfaceListControl(IRouterInfo *pRouter,
                                    CListCtrl *pListCtrl,
                                    LPCTSTR pszExcludedIf,
                                    LPARAM flags,
                                    NewRtrWizData *pWizData);
#define IFLIST_FLAGS_DEBUG 0x01
#define IFLIST_FLAGS_NOIP  0x02


/////////////////////////////////////////////////////////////////////////////
// CNewRtrWizCustomConfig dialog

class CNewRtrWizCustomConfig : public CNewRtrWizPageBase
{
public:
    CNewRtrWizCustomConfig();

    enum { IDD = IDD_NEWRTRWIZ_CUSTOM_CONFIG };

    virtual BOOL    OnInitDialog();    
    virtual HRESULT OnSavePage();
    
protected:
    DECLARE_MESSAGE_MAP()   

};

/////////////////////////////////////////////////////////////////////////////
// CNewRtrWizRRasVPN dialog

class CNewRtrWizRRasVPN : public CNewRtrWizPageBase
{
public:
    CNewRtrWizRRasVPN();

    enum { IDD = IDD_NEWRTRWIZ_RRASVPN };

    virtual BOOL    OnInitDialog();    
    virtual HRESULT OnSavePage();
    virtual BOOL OnSetActive();

protected:
    afx_msg void    OnChkBtnClicked();
        
    DECLARE_MESSAGE_MAP()   
};

/////////////////////////////////////////////////////////////////////////////
// CNewRtrWizWelcome dialog
class CNewRtrWizWelcome : public CNewRtrWizPageBase
{
public:
    CNewRtrWizWelcome();

    enum { IDD = IDD_NEWRTRWIZ_WELCOME };

protected:
    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    Class CNewRtrWizCommonConfig
 ---------------------------------------------------------------------------*/
class CNewRtrWizCommonConfig : public CNewRtrWizPageBase
{
public:
    CNewRtrWizCommonConfig();

    enum { IDD = IDD_NEWRTRWIZ_COMMONCONFIG };

    virtual BOOL    OnInitDialog();    
    virtual HRESULT OnSavePage();
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:
    CFont       m_boldFont;
    
    DECLARE_MESSAGE_MAP()   
};



/*---------------------------------------------------------------------------
    Class:  CNewRtrWizNatFinishAConflict
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAConflict,
                             IDD_NEWRTRWIZ_NAT_A_CONFLICT)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizNatFinishAConflictNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAConflictNonLocal,
                             IDD_NEWRTRWIZ_NAT_A_CONFLICT_NONLOCAL)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizNatFinishNoIP
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishNoIP,
                             IDD_NEWRTRWIZ_NAT_NOIP)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizNatFinishNoIPNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishNoIPNonLocal,
                             IDD_NEWRTRWIZ_NAT_NOIP_NONLOCAL)


/*---------------------------------------------------------------------------
    CNewRtrWizNatSelectPublic
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatSelectPublic : public CNewRtrWizPageBase
{
public:
    CNewRtrWizNatSelectPublic();

    enum { IDD = IDD_NEWRTRWIZ_NAT_A_PUBLIC };

public:
	virtual BOOL    OnSetActive();
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:

    CListCtrl       m_listCtrl;

    afx_msg void    OnBtnClicked();
    
    DECLARE_MESSAGE_MAP()   
};

/*---------------------------------------------------------------------------
    CNewRtrWizNatSelectPrivate
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatSelectPrivate : public CNewRtrWizPageBase
{
public:
    CNewRtrWizNatSelectPrivate();

    enum { IDD = IDD_NEWRTRWIZ_NAT_A_PRIVATE };

public:
    virtual BOOL    OnInitDialog();
    virtual BOOL    OnSetActive();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:
    CListCtrl       m_listCtrl;

    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishAdvancedNoNICs
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAdvancedNoNICs,
                             IDD_NEWRTRWIZ_NAT_A_NONICS_FINISH)


/*---------------------------------------------------------------------------
    CNewRtrWizNatDHCPDNS
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatDHCPDNS : public CNewRtrWizPageBase
{
public:
    CNewRtrWizNatDHCPDNS();

    enum { IDD = IDD_NEWRTRWIZ_NAT_A_DHCPDNS };

public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    
protected:
    DECLARE_MESSAGE_MAP()   
};



/*---------------------------------------------------------------------------
    CNewRtrWizNatDHCPWarning
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatDHCPWarning : public CNewRtrWizPageBase
{
public:
    CNewRtrWizNatDHCPWarning();

    enum { IDD = IDD_NEWRTRWIZ_NAT_A_DHCP_WARNING };

    virtual BOOL    OnSetActive();
    
public:
    
protected:
    DECLARE_MESSAGE_MAP()   
};

/*---------------------------------------------------------------------------
    CNewRtrWizNatDDWarning
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatDDWarning : public CNewRtrWizPageBase
{
public:
    CNewRtrWizNatDDWarning();

    enum { IDD = IDD_NEWRTRWIZ_NAT_A_DD_WARNING };

    // Calling this will cause the DD wizard to be started
    virtual BOOL    OnSetActive();
    virtual HRESULT OnSavePage();
    
public:
    
protected:
    DECLARE_MESSAGE_MAP()   
};



/*---------------------------------------------------------------------------
    CNewRtrWizNatFinish
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatFinish : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizNatFinish();
    
    enum { IDD = IDD_NEWRTRWIZ_NAT_A_FINISH };

    virtual BOOL    OnSetActive();
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:
    DECLARE_MESSAGE_MAP()
};

/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishExternal
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatFinishExternal : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizNatFinishExternal();
    
    enum { IDD = IDD_NEWRTRWIZ_NAT_A_EXTERNAL_FINISH };

    virtual BOOL    OnSetActive();
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:
    DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizNatFinishDDError
 ---------------------------------------------------------------------------*/
class CNewRtrWizNatFinishDDError : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizNatFinishDDError();
    
    enum { IDD = IDD_NEWRTRWIZ_NAT_A_DD_ERROR };

    virtual BOOL    OnInitDialog();
    virtual BOOL    OnSetActive();
    
protected:
    DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRasFinishNeedProtocols
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNeedProtocols,
                             IDD_NEWRTRWIZ_RAS_A_NEED_PROT)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRasFinishNeedProtocolsNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNeedProtocolsNonLocal,
                             IDD_NEWRTRWIZ_RAS_A_NEED_PROT_NONLOCAL)



/*---------------------------------------------------------------------------
    Class:  CNewRtrWizVpnFinishNeedProtocols
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNeedProtocols,
                             IDD_NEWRTRWIZ_VPN_A_NEED_PROT)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizVpnFinishNeedProtocolsNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNeedProtocolsNonLocal,
                             IDD_NEWRTRWIZ_VPN_A_NEED_PROT_NONLOCAL)




/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRouterFinishNeedProtocols
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRouterFinishNeedProtocols,
                             IDD_NEWRTRWIZ_ROUTER_NEED_PROT)

/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRouterFinishNeedProtocolsNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRouterFinishNeedProtocolsNonLocal,
                             IDD_NEWRTRWIZ_ROUTER_NEED_PROT_NONLOCAL)


/*---------------------------------------------------------------------------
    CNewRtrWizSelectNetwork
 ---------------------------------------------------------------------------*/
class CNewRtrWizSelectNetwork : public CNewRtrWizPageBase
{
public:
    CNewRtrWizSelectNetwork(UINT uDialogId);

public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:

    CListCtrl       m_listCtrl;

    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    CNewRtrWizRasSelectNetwork
 ---------------------------------------------------------------------------*/
class CNewRtrWizRasSelectNetwork : public CNewRtrWizSelectNetwork
{
public:
    CNewRtrWizRasSelectNetwork();

    enum { IDD = IDD_NEWRTRWIZ_RAS_A_NETWORK };

};

/*---------------------------------------------------------------------------
    CNewRtrWizRasNoNICs
 ---------------------------------------------------------------------------*/
class CNewRtrWizRasNoNICs : public CNewRtrWizPageBase
{
public:
    CNewRtrWizRasNoNICs();

    enum { IDD = IDD_NEWRTRWIZ_RAS_A_NONICS };

public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:

    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishNoNICs
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNoNICs,
                             IDD_NEWRTRWIZ_RAS_A_FINISH_NONICS)



/*---------------------------------------------------------------------------
    CNewRtrWizAddressing
 ---------------------------------------------------------------------------*/
class CNewRtrWizAddressing : public CNewRtrWizPageBase
{

public:
    CNewRtrWizAddressing();
    enum { IDD = IDD_NEWRTRWIZ_ADDRESSING };
public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:

    DECLARE_MESSAGE_MAP()   
};



/*---------------------------------------------------------------------------
    CNewRtrWizAddressPool
 ---------------------------------------------------------------------------*/
class CNewRtrWizAddressPool : public CNewRtrWizPageBase
{
public:
    CNewRtrWizAddressPool();
    enum { IDD= IDD_NEWRTRWIZ_ADDRESSPOOL };

public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual BOOL    OnSetActive();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:

    CListCtrl       m_listCtrl;

    afx_msg VOID    OnBtnNew();
    afx_msg VOID    OnBtnEdit();
    afx_msg VOID    OnBtnDelete();
    afx_msg VOID    OnListDblClk(NMHDR *, LRESULT *);
    afx_msg VOID    OnNotifyListItemChanged(NMHDR *, LRESULT *);

    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    CNewRtrWizRadius
 ---------------------------------------------------------------------------*/
class CNewRtrWizRadius : public CNewRtrWizPageBase
{
public:
    CNewRtrWizRadius();
    enum {IDD = IDD_NEWRTRWIZ_USERADIUS };
public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:

    DECLARE_MESSAGE_MAP()   
};




/*---------------------------------------------------------------------------
    CNewRtrWizRadiusConfig
 ---------------------------------------------------------------------------*/
class CNewRtrWizRadiusConfig : public CNewRtrWizPageBase
{
public:
    CNewRtrWizRadiusConfig();
    enum { IDD = IDD_NEWRTRWIZ_RADIUS_CONFIG };
public:
    virtual BOOL    OnInitDialog();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    
protected:
    DWORD   ResolveName(LPCTSTR pszServer);

    DECLARE_MESSAGE_MAP()   
};



/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishAdvanced
 ---------------------------------------------------------------------------*/

class CNewRtrWizRasFinishAdvanced : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizRasFinishAdvanced();
    virtual BOOL    OnSetActive();
    enum { IDD = IDD_NEWRTRWIZ_RAS_A_FINISH};
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
protected:
    DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNoNICs
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoNICs,
                             IDD_NEWRTRWIZ_VPN_A_FINISH_NONICS)


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizVpnFinishNoIP
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoIP,
                             IDD_NEWRTRWIZ_VPN_NOIP)

/*---------------------------------------------------------------------------
    Class:  CNewRtrWizVpnFinishNoIPNonLocal
 ---------------------------------------------------------------------------*/
DEFINE_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoIPNonLocal,
                             IDD_NEWRTRWIZ_VPN_NOIP_NONLOCAL)


/*---------------------------------------------------------------------------
    CNewRtrWizRASVpnFinishAdvanced
 ---------------------------------------------------------------------------*/

class CNewRtrWizRASVpnFinishAdvanced : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizRASVpnFinishAdvanced();
    virtual BOOL    OnSetActive();
    enum { IDD = IDD_NEWRTRWIZ_RAS_VPN_A_FINISH};
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
protected:
    DECLARE_MESSAGE_MAP()
};

/*---------------------------------------------------------------------------
    CNewRtrWizNATVpnFinishAdvanced
 ---------------------------------------------------------------------------*/
class CNewRtrWizNATVpnFinishAdvanced : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizNATVpnFinishAdvanced();
    virtual BOOL    OnSetActive();
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    enum { IDD = IDD_NEWRTRWIZ_NAT_VPN_A_FINISH};
protected:
    DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishAdvanced
 ---------------------------------------------------------------------------*/

class CNewRtrWizVpnFinishAdvanced : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizVpnFinishAdvanced();
    virtual BOOL    OnSetActive();
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    enum { IDD = IDD_NEWRTRWIZ_VPN_A_FINISH};
protected:
    DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
    CNewRtrWizVpnSelectPublic
 ---------------------------------------------------------------------------*/
class CNewRtrWizVpnSelectPublic : public CNewRtrWizPageBase
{
public:
    CNewRtrWizVpnSelectPublic();

    enum { IDD = IDD_NEWRTRWIZ_VPN_A_PUBLIC };

public:
    virtual BOOL    OnInitDialog();
    virtual BOOL    OnSetActive();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
    
protected:
    CListCtrl       m_listCtrl;

    afx_msg void OnButtonClick();

    DECLARE_MESSAGE_MAP()   
};

/*---------------------------------------------------------------------------
    CNewRtrWizVpnSelectPrivate
 ---------------------------------------------------------------------------*/
class CNewRtrWizVpnSelectPrivate : public CNewRtrWizPageBase
{
public:
    CNewRtrWizVpnSelectPrivate();

    enum { IDD = IDD_NEWRTRWIZ_VPN_A_PRIVATE };

public:
    virtual BOOL    OnInitDialog();
    virtual BOOL    OnSetActive();
    virtual HRESULT OnSavePage();
    virtual VOID    DoDataExchange(CDataExchange *pDX);

    
protected:

    CListCtrl       m_listCtrl;

    DECLARE_MESSAGE_MAP()   
};


/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRouterUseDD
 ---------------------------------------------------------------------------*/
class CNewRtrWizRouterUseDD : public CNewRtrWizPageBase
{
public:
    CNewRtrWizRouterUseDD();

    enum { IDD = IDD_NEWRTRWIZ_ROUTER_USEDD };

public:
    virtual BOOL    OnInitDialog();
    virtual VOID    DoDataExchange(CDataExchange *pDX);
    virtual HRESULT OnSavePage();

protected:

    DECLARE_MESSAGE_MAP()   
};





/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRouterFinish
 ---------------------------------------------------------------------------*/
class CNewRtrWizRouterFinish : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizRouterFinish();
    virtual BOOL    OnSetActive();
    enum { IDD = IDD_NEWRTRWIZ_ROUTER_FINISH };
protected:
    DECLARE_MESSAGE_MAP()

};
/*---------------------------------------------------------------------------
    Class:  CNewRtrWizRouterFinishDD
 ---------------------------------------------------------------------------*/

class CNewRtrWizRouterFinishDD : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizRouterFinishDD();
    virtual BOOL    OnSetActive();
    enum { IDD = IDD_NEWRTRWIZ_ROUTER_FINISH_DD };
    void OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult);
protected:
    DECLARE_MESSAGE_MAP()

};
/*---------------------------------------------------------------------------
    Class:  CNewRtrWizManualFinish
 ---------------------------------------------------------------------------*/

class CNewRtrWizManualFinish : public CNewRtrWizFinishPageBase
{
public:
    CNewRtrWizManualFinish();
    virtual BOOL    OnSetActive();
    enum { IDD = IDD_NEWRTRWIZ_MANUAL_FINISH };
protected:
    DECLARE_MESSAGE_MAP()
};



///////////////////////////////////////////////////////////////////////////////
//
// CNewRtrWiz
// page holder to contain Router install wizard pages
//
/////////////////////////////////////////////////////////////////////////////

class CNewRtrWiz : public CPropertyPageHolderBase
{
	
public:
	static BOOL					fWizardInProgress;
    CNewRtrWiz (ITFSNode *        pNode,
                IRouterInfo *    pRouter,
                IComponentData *  pComponentData,
                ITFSComponentData * pTFSCompData,
                LPCTSTR           pszSheetName,
				BOOL			  fInvokedInMMC = TRUE,
				DWORD			  dwExpressType = MPRSNAP_CYS_EXPRESS_NONE);
    
    virtual ~CNewRtrWiz();
    
    HRESULT Init(LPCTSTR pszServerName);
    
    virtual DWORD   OnFinish();
    
    HRESULT QueryForTestData()
    {
        return m_RtrWizData.QueryForTestData();
    }
   virtual HRESULT DoModalWizard();
   inline NewRtrWizData * GetWizData() {return &m_RtrWizData;};
protected:

    CNewRtrWizWelcome       m_pageWelcome;
    CNewRtrWizCommonConfig  m_pageCommonConfig;    
    CNewRtrWizNatFinishAConflict  m_pageNatFinishAConflict;
    CNewRtrWizNatFinishAConflictNonLocal  m_pageNatFinishAConflictNonLocal;
    CNewRtrWizNatFinishNoIP m_pageNatFinishNoIP;
    CNewRtrWizNatFinishNoIPNonLocal m_pageNatFinishNoIPNonLocal;
    CNewRtrWizNatSelectPublic   m_pageNatSelectPublic;
    CNewRtrWizNatSelectPrivate  m_pageNatSelectPrivate;
    CNewRtrWizNatFinishAdvancedNoNICs   m_pageNatFinishAdvancedNoNICs;
    CNewRtrWizNatDHCPDNS        m_pageNatDHCPDNS;
    CNewRtrWizNatDHCPWarning    m_pageNatDHCPWarning;
    CNewRtrWizNatDDWarning      m_pageNatDDWarning;
    CNewRtrWizNatFinish         m_pageNatFinish;
    CNewRtrWizNatFinishExternal m_pageNatFinishExternal;
    CNewRtrWizNatFinishDDError  m_pageNatFinishDDError;

    
    CNewRtrWizRasFinishNeedProtocols m_pageRasFinishNeedProtocols;
    CNewRtrWizRasFinishNeedProtocolsNonLocal m_pageRasFinishNeedProtocolsNonLocal;

    CNewRtrWizRasNoNICs         m_pageRasNoNICs;
    CNewRtrWizRasFinishNoNICs   m_pageRasFinishNoNICs;
    CNewRtrWizRasSelectNetwork  m_pageRasNetwork;    
       
    CNewRtrWizRasFinishAdvanced m_pageRasFinishAdvanced;

    CNewRtrWizVpnFinishNoNICs   m_pageVpnFinishNoNICs;
    CNewRtrWizVpnFinishNoIP     m_pageVpnFinishNoIP;
    CNewRtrWizVpnFinishNoIPNonLocal m_pageVpnFinishNoIPNonLocal;
    CNewRtrWizVpnFinishNeedProtocols m_pageVpnFinishNeedProtocols;
    CNewRtrWizVpnFinishNeedProtocolsNonLocal m_pageVpnFinishNeedProtocolsNonLocal;
    CNewRtrWizVpnSelectPublic   m_pageVpnSelectPublic;
    CNewRtrWizVpnSelectPrivate  m_pageVpnSelectPrivate;
    CNewRtrWizVpnFinishAdvanced m_pageVpnFinishAdvanced;
    CNewRtrWizRASVpnFinishAdvanced m_pageRASVpnFinishAdvanced;
    CNewRtrWizNATVpnFinishAdvanced m_pageNATVpnFinishAdvanced;

    CNewRtrWizRouterFinishNeedProtocols   m_pageRouterFinishNeedProtocols;
    CNewRtrWizRouterFinishNeedProtocolsNonLocal   m_pageRouterFinishNeedProtocolsNonLocal;
    CNewRtrWizRouterUseDD       m_pageRouterUseDD;
    CNewRtrWizRouterFinish      m_pageRouterFinish;
    CNewRtrWizRouterFinishDD    m_pageRouterFinishDD;

    CNewRtrWizManualFinish      m_pageManualFinish;

    CNewRtrWizCustomConfig      m_pageCustomConfig;
    CNewRtrWizRRasVPN           m_pageRRasVPN;

    CNewRtrWizAddressing        m_pageAddressing;
    CNewRtrWizAddressPool       m_pageAddressPool;
    CNewRtrWizRadius            m_pageRadius;
    CNewRtrWizRadiusConfig      m_pageRadiusConfig;

    
	//Set if this is wizard is invoked from MMC.  Else False
	BOOL						m_fInvokedInMMC;	 //Default value of TRUE
	DWORD						m_dwExpressType;			//Express Type - default set to none
public:
    SPIRouterInfo           m_spRouter;
    
protected:
    SPITFSComponentData     m_spTFSCompData;
    CString                 m_stServerName;
    NewRtrWizData           m_RtrWizData;
    PPageList               m_pagelist;

};

class CRasWarning: public CDialog
{
public:
	CRasWarning(char * helpTopic, int strId, CWnd* pParent = NULL);
	enum { IDD = IDD_RAS_WARNING };
	char * m_helpTopic;
	int m_strId;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL    OnInitDialog();
	afx_msg void OnOkBtn();
	afx_msg void OnHelpBtn();
	DECLARE_MESSAGE_MAP()
};

class CNewWizTestParams : public CBaseDialog
{
public:
    CNewWizTestParams() :
            CBaseDialog(IDD_TEST_NEWWIZ_PARAMS)
   {};

    void    SetData(NewRtrWizData *pWizData)
            { m_pWizData = pWizData; }
        

protected:

    NewRtrWizData * m_pWizData;
    
    //{{AFX_VIRTUAL(CNewWizTestParams)
protected:
    virtual BOOL    OnInitDialog();
    virtual void    OnOK();
    //}}AFX_VIRTUAL
    
    DECLARE_MESSAGE_MAP()
};



#endif // !defined _RRASWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rrasqry.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rrasqry.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_)
#define AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// dlgsvr.h : header file
//

#include "resource.h"
#include "dialog.h"         // CBaseDialog
#include "helper.h"
// RRAS Query Categories
// -----
enum	RRAS_QRY_CAT{
	RRAS_QRY_CAT_NONE		= 0,
	RRAS_QRY_CAT_THIS,
	RRAS_QRY_CAT_MACHINE	,
	RRAS_QRY_CAT_NT4DOMAIN	,
	RRAS_QRY_CAT_NT5LDAP
};


// Data structure to pass Query Info
struct RRASQryData
{
	DWORD			dwCatFlag;		// RRAS_QRY_CAT_*
	CString			strScope;
	CString			strFilter;
};
//----
// QryData.strQryData definition
	//RRAS_QRY_CAT_NONE			ignored
	//RRAS_QRY_CAT_THIS			ignored
	//RRAS_QRY_CAT_MACHINE		name of the machine
	//RRAS_QRY_CAT_NT4DOMAIN	nt4 domain name
	//RRAS_QRY_CAT_NT5LDAP		DN name domain object, and LDAP filter string, filter start with '('
//----------------------------------

//
//		S_OK -- User select OK
//		S_FALSE -- User select Cancel
//		ERROR:
//			DS error, search activeDs.dll
//			Win32 erroe
//			LDAP error
//			General error -- memory, invalid argument ...


// Get a Query Data by pop up a set of dialog boxes
HRESULT	RRASOpenQryDlg(
	/*[in]*/		CWnd*			pParent, 
	/*[in, out]*/	RRASQryData&	QryData 		// existing data will be overwritten when S_OK
);

//
//		S_OK -- User select OK
//		S_FALSE -- User select Cancel
//		ERROR:
//			DS error, search activeDs.dll
//			Win32 erroe
//			LDAP error
//			General error -- memory, invalid argument ...

#define	RRAS_QRY_RESULT_DNSNAME		0x00000001
#define	RRAS_QRY_RESULT_HOSTNAME	0x00000002

HRESULT	RRASExecQry(
	/*[in]*/	RRASQryData&	QryData, 
	/*[out]*/	DWORD&			dwFlags,
	/*[out]*/	CStringArray&	RRASs	// existing data won't be destroyed
);
//		S_OK -- User select OK
//		ERROR:
//			DS error, search activeDs.dll
//			Win32 erroe
//			LDAP error
//			General error -- memory, invalid argument ...
//---
//---RRASs definition upon return----------
	//RRAS_QRY_CAT_NONE			no change, no query
	//RRAS_QRY_CAT_THIS			no change, no query
	//RRAS_QRY_CAT_MACHINE		no change, no query
	//RRAS_QRY_CAT_NT4DOMAIN	server names of the the NT4 domain get added to the array
	//RRAS_QRY_CAT_NT5LDAP		DN names of the computer object found in DS get added to the array
//----------------------------------
//

// Get a Query Data by pop up a set of dialog boxes
HRESULT	RRASDSQueryDlg(
	/*[in]*/		CWnd*			pParent, 
	/*[in, out]*/	RRASQryData&	QryData 		// existing data will be overwritten when S_OK
);


HRESULT  RRASDelRouterIdObj(  
/*[in]*/LPCWSTR   pwszMachineName   // DN of the computer object in DS
);

/////////////////////////////////////////////////////////////////////////////
// CDlgSvr dialog

class CDlgSvr : public CBaseDialog
{
// Construction
protected:
	CDlgSvr(CWnd* pParent = NULL);   // standard constructor
public:	
	CDlgSvr(RRASQryData& QryData, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgSvr)
	enum { IDD = IDD_QRY_ADDSERVER };
	CEdit	m_editMachine;
	CEdit	m_editDomain;
	CButton	m_btnOk;
	CButton	m_btnNext;
	CString	m_strDomain;
	CString	m_strMachine;
	int		m_nRadio;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgSvr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	Init();

	// Generated message map functions
	//{{AFX_MSG(CDlgSvr)
	afx_msg void OnRadioAnother();
	afx_msg void OnRadioNt4();
	afx_msg void OnRadioNt5();
	afx_msg void OnRadioThis();
	afx_msg void OnButtonNext();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	RRASQryData&	m_QueryData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rraswiz.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

#include "stdafx.h"
#include "root.h"
#include "machine.h"
#include "rtrutilp.h"   // InitiateServerConnection
#include "rtrcfg.h"
#include "rraswiz.h"
#include "rtrres.h"
#include "rtrcomn.h"
#include "addrpool.h"
#include "rrasutil.h"
#include "radbal.h"     // RADIUSSERVER
#include "radcfg.h"     // SaveRadiusServers
#include "lsa.h"
#include "helper.h"     // HrIsStandaloneServer
#include "ifadmin.h"    // GetPhoneBookPath
#include "infoi.h"      // InterfaceInfo::FindInterfaceTitle
#include "rtrerr.h"
#include "rtrui.h"      // NatConflictExists
#include "rrasqry.h"
#define _USTRINGP_NO_UNICODE_STRING
#include "ustringp.h"
#include <ntddip.h>     // to resolve ipfltdrv dependancies
#include "ipfltdrv.h"   // for the filter stuff
#include "raputil.h"    // for UpdateDefaultPolicy
#include "iphlpapi.h"
#include "dnsapi.h"  // for dns stuff

extern "C" {
#define _NOUIUTIL_H_
#include "dtl.h"
#include "pbuser.h"
#include "shlobjp.h"
};
extern BOOL WINAPI LinkWindow_RegisterClass();

WATERMARKINFO       g_wmi = {0};

#ifdef UNICODE
    #define SZROUTERENTRYDLG    "RouterEntryDlgW"
#else
    #define SZROUTERENTRYDLG    "RouterEntryDlgA"
#endif

// Useful functions

// defines for the flags parameter
HRESULT CallRouterEntryDlg(HWND hWnd, NewRtrWizData *pWizData, LPARAM flags);
HRESULT RouterEntryLoadInfoBase(LPCTSTR pszServerName,
                                LPCTSTR pszIfName,
                                DWORD dwTransportId,
                                IInfoBase *pInfoBase);
HRESULT RouterEntrySaveInfoBase(LPCTSTR pszServerName,
                                LPCTSTR pszIfName,
                                IInfoBase *pInfoBase,
                                DWORD dwTransportId);
void LaunchHelpTopic(LPCTSTR pszHelpString);
HRESULT AddVPNFiltersToInterface(IRouterInfo *pRouter, LPCTSTR pszIfId, RtrWizInterface*    pIf);
HRESULT DisableDDNSandNetBtOnInterface ( IRouterInfo *pRouter, LPCTSTR pszIfName, RtrWizInterface*    pIf);

// This is the command line that I use to launch the Connections UI shell
const TCHAR s_szConnectionUICommandLine[] =
      _T("\"%SystemRoot%\\explorer.exe\" ::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{7007acc7-3202-11d1-aad2-00805fc1270e}");

// Help strings
const TCHAR s_szHowToAddICS[] =
            _T("%systemdir%\\help\\netcfg.chm::/howto_share_conn.htm");
const TCHAR s_szHowToAddAProtocol[] =
            _T("%systemdir%\\help\\netcfg.chm::/HowTo_Add_Component.htm");
const TCHAR s_szHowToAddInboundConnections[] =
            _T("%systemdir%\\help\\netcfg.chm::/howto_conn_incoming.htm");
const TCHAR s_szGeneralNATHelp[] =
            _T("%systemdir%\\help\\RRASconcepts.chm::/sag_RRAS-Ch3_06b.htm");
const TCHAR s_szGeneralRASHelp[] =
            _T("%systemdir%\\help\\RRASconcepts.chm::/sag_RRAS-Ch1_1.htm");
const TCHAR s_szUserAccounts[] =
            _T("%systemdir%\\help\\RRASconcepts.chm::/sag_RRAS-Ch1_46.htm");
const TCHAR s_szDhcp[] =
            _T("%systemdir%\\help\\dhcpconcepts.chm");
const TCHAR s_szDemandDialHelp[] =
            _T("%systemdir%\\help\\RRASconcepts.chm::/sag_RRAS-Ch3_08d.htm");
	


/*---------------------------------------------------------------------------
    This enum defines the columns for the Interface list controls.
 ---------------------------------------------------------------------------*/
enum
{
    IFLISTCOL_NAME = 0,
    IFLISTCOL_DESC,
    IFLISTCOL_IPADDRESS,
    IFLISTCOL_COUNT
};

// This array must match the column indices above
INT s_rgIfListColumnHeaders[] =
{
    IDS_IFLIST_COL_NAME,
    IDS_IFLIST_COL_DESC,
    IDS_IFLIST_COL_IPADDRESS,
    0
};


/* 
	IsIcsIcfIcEnabled: This fucntion returns TRUE if ICS (connection sharing) or 
	ICF (connection firewall) or IC (incoming connections) is enabled on the machine

	author: kmurthy
*/
BOOL IsIcsIcfIcEnabled(IRouterInfo * spRouterInfo, BOOL suppressMesg)
{
    HRESULT        hr = hrOK;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;
    SPIRemoteICFICSConfig    spConfig;
    IUnknown *                punk = NULL;
    BOOL fwEnabled=FALSE, csEnabled=FALSE, icEnabled = FALSE;
    RegKey regkey;
    CString szKey = "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";
    CString szValue = "IcConfigured";
    CString szMachineName;
    DWORD dwErr, szResult=0;


    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));

    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;
    
    szMachineName = spRouterInfo->GetMachineName();
    
    // Create the remote config object
    hr = CoCreateRouterConfig(szMachineName ,
                              spRouterInfo,
                              &csi,
                              IID_IRemoteICFICSConfig,
                              &punk);

    if (FHrOK(hr))
    {
        spConfig = (IRemoteICFICSConfig *)punk;
        punk = NULL;
	
	//Is ICF enabled?
	hr = spConfig->GetIcfEnabled(&fwEnabled);
	if(FHrOK(hr))
	{
		if(fwEnabled) {
			if(!suppressMesg){
			    	CString stErr, st;
		    		stErr.LoadString(IDS_NEWWIZ_ICF_ERROR);
		    		st.Format(stErr, ((szMachineName.GetLength() == 0) ? GetLocalMachineName() : szMachineName));
			    	AfxMessageBox(st);
			}
		    	spConfig->Release();
	    		return TRUE;
		}
	}

	//Is ICS enabled?
	hr = spConfig->GetIcsEnabled(&csEnabled);
	if(FHrOK(hr))
	{
		if(csEnabled) {
			if(!suppressMesg){
			    	CString stErr, st;
		    		stErr.LoadString(IDS_NEWWIZ_ICS_ERROR);
		    		st.Format(stErr, ((szMachineName.GetLength() == 0) ? GetLocalMachineName() : szMachineName));
			    	AfxMessageBox(st);
			}
		    	spConfig->Release();
	    		return TRUE;
		}
	}

    }

    //Now check to see if IC is enabled 
      	dwErr = regkey.Open(	HKEY_LOCAL_MACHINE, 
						szKey, 
						KEY_QUERY_VALUE, 
						szMachineName 
					  );

	if ( ERROR_SUCCESS == dwErr ){
		dwErr = regkey.QueryValue( szValue, szResult);
		if(ERROR_SUCCESS == dwErr ){
			if(szResult == 1){
				//IC is enabled!
				if(!suppressMesg){
				    	CString stErr, st;
			    		stErr.LoadString(IDS_NEWWIZ_IC_ERROR);
			    		st.Format(stErr, ((szMachineName.GetLength() == 0) ? GetLocalMachineName() : szMachineName));
				    	AfxMessageBox(st);
				}
			    	regkey.Close();
		    		return TRUE;
			}
		}
	}

       regkey.Close();

       return FALSE;

}


/*!--------------------------------------------------------------------------
    MachineHandler::OnNewRtrRASConfigWiz
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MachineHandler::OnNewRtrRASConfigWiz(ITFSNode *pNode, BOOL fTest)
{
    Assert(pNode);
    HRESULT        hr = hrOK;
    CString strRtrWizTitle;
    SPIComponentData spComponentData;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;
    SPIRemoteNetworkConfig    spNetwork;
    IUnknown *                punk = NULL;
    CNewRtrWiz *            pRtrWiz = NULL;
    DWORD dwErr, szResult=0;
    CString szMachineName;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    szMachineName = m_spRouterInfo->GetMachineName();

    
    //kmurthy: We should not let the wizard run, if ICF/ICS/IC is already enabled on the machine
    if(IsIcsIcfIcEnabled(m_spRouterInfo)){
    	return S_FALSE;
    }
    
    // Windows NT Bug : 407878
    // We need to reset the registry information (to ensure
    // that it is reasonably accurate).
    // ----------------------------------------------------------------
    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));

    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;

    // Create the remote config object
    // ----------------------------------------------------------------
    hr = CoCreateRouterConfig(szMachineName ,
                              m_spRouterInfo,
                              &csi,
                              IID_IRemoteNetworkConfig,
                              &punk);

    if (FHrOK(hr))
    {
        spNetwork = (IRemoteNetworkConfig *) punk;
        punk = NULL;

        // Upgrade the configuration (ensure that the registry keys
        // are populated correctly).
        // ------------------------------------------------------------
        spNetwork->UpgradeRouterConfig();
    }



    hr = SecureRouterInfo(pNode, TRUE /* fShowUI */);
    if(FAILED(hr))    return hr;

    m_spNodeMgr->GetComponentData(&spComponentData);
    strRtrWizTitle.LoadString(IDS_MENU_RTRWIZ);

    //Load the watermark and
    //set it in  m_spTFSCompData

    InitWatermarkInfo(AfxGetInstanceHandle(),
                       &g_wmi,
                       IDB_WIZBANNER,        // Header ID
                       IDB_WIZWATERMARK,     // Watermark ID
                       NULL,                 // hPalette
                       FALSE);                // bStretch

    m_spTFSCompData->SetWatermarkInfo(&g_wmi);


    //
    //we dont have to free handles.  MMC does it for us
    //
    pRtrWiz = new CNewRtrWiz(pNode,
                             m_spRouterInfo,
                             spComponentData,
                             m_spTFSCompData,
                             strRtrWizTitle);

    if (fTest)
    {
        // Pure TEST code
        if (!FHrOK(pRtrWiz->QueryForTestData()))
        {
            delete pRtrWiz;
            return S_FALSE;
        }
    }

    if ( FAILED(pRtrWiz->Init( szMachineName )) )
    {
        delete pRtrWiz;
        return S_FALSE;
    }
    else
    {
        return pRtrWiz->DoModalWizard();
    }

    if (csi.pAuthInfo)
        delete csi.pAuthInfo->pAuthIdentityData->Password;

    return hr;
}



NewRtrWizData::~NewRtrWizData()
{
    POSITION    pos;
    CString     st;
    RtrWizInterface *   pRtrWizIf;

    pos = m_ifMap.GetStartPosition();
    while (pos)
    {
        m_ifMap.GetNextAssoc(pos, st, pRtrWizIf);
        delete pRtrWizIf;
    }

    m_ifMap.RemoveAll();

    // Clear out the RADIUS secret
    ::SecureZeroMemory(m_stRadiusSecret.GetBuffer(0),
               m_stRadiusSecret.GetLength() * sizeof(TCHAR));
    m_stRadiusSecret.ReleaseBuffer(-1);
}


/*!--------------------------------------------------------------------------
    NewRtrWizData::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::Init(LPCTSTR pszServerName, IRouterInfo *pRouter, DWORD dwExpressType)
{
    DWORD   dwServiceStatus = 0;
    DWORD   dwErrorCode = 0;

    m_stServerName = pszServerName;
	m_dwExpressType = dwExpressType;

    // Initialize internal wizard data
    m_RtrConfigData.Init(pszServerName, pRouter);
    m_RtrConfigData.m_fIpSetup = TRUE;

    // Move some of the RtrConfigData info over
    m_fIpInstalled = m_RtrConfigData.m_fUseIp;
    m_fIpxInstalled = m_RtrConfigData.m_fUseIpx;
    m_fNbfInstalled = m_RtrConfigData.m_fUseNbf;
    m_fAppletalkInstalled = m_RtrConfigData.m_fUseArap;

    m_fIpInUse = m_fIpInstalled;
    m_fIpxInUse = m_fIpxInstalled;
    m_fAppletalkInUse = m_fAppletalkInstalled;
    m_fNbfInUse = m_fNbfInstalled;

    // Test the server to see if DNS/DHCP is installed
    m_fIsDNSRunningOnServer = FALSE;
    m_fIsDHCPRunningOnServer = FALSE;

    // Get the status of the DHCP service
    // ----------------------------------------------------------------
    if (FHrSucceeded(TFSGetServiceStatus(pszServerName,
                                         _T("DHCPServer"),
                                         &dwServiceStatus,
                                         &dwErrorCode)))
    {
        // Note, if the service is not running, we assume it will
        // stay off and not assume that it will be turned on.
        // ------------------------------------------------------------
        m_fIsDHCPRunningOnServer = (dwServiceStatus == SERVICE_RUNNING);
    }

    //$ TODO : is this the correct name for the DNS Server?

    // Get the status of the DNS service
    // ----------------------------------------------------------------
    if (FHrSucceeded(TFSGetServiceStatus(pszServerName,
                                         _T("DNSServer"),
                                         &dwServiceStatus,
                                         &dwErrorCode)))
    {
        // Note, if the service is not running, we assume it will
        // stay off and not assume that it will be turned on.
        // ------------------------------------------------------------
        m_fIsDNSRunningOnServer = (dwServiceStatus == SERVICE_RUNNING);
    }

	//Based on the express type set some of the parameters upfront here
	switch ( m_dwExpressType )
	{
	case MPRSNAP_CYS_EXPRESS_NAT:
        m_fAdvanced = TRUE;
        m_wizType = NewRtrWizData::NewWizardRouterType_NAT;
        m_dwNewRouterType = NEWWIZ_ROUTER_TYPE_NAT;
		break;
	case MPRSNAP_CYS_EXPRESS_NONE:
	default:
        //do nothing here
		break;
	}

    LoadInterfaceData(pRouter);

    return hrOK;
}

UINT NewRtrWizData::GetStartPageId ()
{

	// Get a better scheme in place for this stuff.  This
	// is the index into the array m_pagelist.  
	switch ( m_dwExpressType )
	{
	case MPRSNAP_CYS_EXPRESS_NAT:
		return (6);
		break;
	case MPRSNAP_CYS_EXPRESS_NONE:
	default:
		return (0);
		break;
	}
	return 0;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::QueryForTestData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/

BOOL NewRtrWizData::s_fIpInstalled = FALSE;
BOOL NewRtrWizData::s_fIpxInstalled = FALSE;
BOOL NewRtrWizData::s_fAppletalkInstalled = FALSE;
BOOL NewRtrWizData::s_fNbfInstalled = FALSE;
BOOL NewRtrWizData::s_fIsLocalMachine = FALSE;
BOOL NewRtrWizData::s_fIsDNSRunningOnPrivateInterface = FALSE;
BOOL NewRtrWizData::s_fIsDHCPRunningOnPrivateInterface = FALSE;
BOOL NewRtrWizData::s_fIsSharedAccessRunningOnServer = FALSE;
BOOL NewRtrWizData::s_fIsMemberOfDomain = FALSE;
DWORD NewRtrWizData::s_dwNumberOfNICs = 0;

/*!--------------------------------------------------------------------------
    NewRtrWizData::QueryForTestData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::QueryForTestData()
{
    HRESULT hr = hrOK;
    CNewWizTestParams   dlgParams;

    m_fTest = TRUE;

    // Get the initial parameters
    // ----------------------------------------------------------------
    dlgParams.SetData(this);
    if (dlgParams.DoModal() == IDCANCEL)
    {
        return S_FALSE;
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsIPInstalled
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsIPInstalled()
{
    if (m_fTest)
        return s_fIpInstalled ? S_OK : S_FALSE;
    else
        return m_fIpInstalled ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsIPInUse
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsIPInUse()
{
    HRESULT hr = hrOK;

    hr = HrIsIPInstalled();
    if (FHrOK(hr))
        return m_fIpInUse ? S_OK : S_FALSE;
    else
        return hr;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsIPXInstalled
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsIPXInstalled()
{
    if (m_fTest)
        return s_fIpxInstalled ? S_OK : S_FALSE;
    else
        return m_fIpxInstalled ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsIPXInUse
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsIPXInUse()
{
    HRESULT hr = hrOK;

    hr = HrIsIPXInstalled();
    if (FHrOK(hr))
        return m_fIpxInUse ? S_OK : S_FALSE;
    else
        return hr;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsAppletalkInstalled
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsAppletalkInstalled()
{
    if (m_fTest)
        return s_fAppletalkInstalled ? S_OK : S_FALSE;
    else
        return m_fAppletalkInstalled ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsAppletalkInUse
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsAppletalkInUse()
{
    HRESULT hr = hrOK;

    hr = HrIsAppletalkInstalled();
    if (FHrOK(hr))
        return m_fAppletalkInUse ? S_OK : S_FALSE;
    else
        return hr;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsNbfInstalled
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsNbfInstalled()
{
    if (m_fTest)
        return s_fNbfInstalled ? S_OK : S_FALSE;
    else
        return m_fNbfInstalled ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsNbfInUse
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsNbfInUse()
{
    HRESULT hr = hrOK;

    hr = HrIsNbfInstalled();
    if (FHrOK(hr))
        return m_fNbfInUse ? S_OK : S_FALSE;
    else
        return hr;
}


/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsLocalMachine
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsLocalMachine()
{
    if (m_fTest)
        return s_fIsLocalMachine ? S_OK : S_FALSE;
    else
        return IsLocalMachine(m_stServerName) ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsDNSRunningOnInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsDNSRunningOnInterface()
{
    if (m_fTest)
        return s_fIsDNSRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the private interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(m_stPrivateInterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDnsEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}

HRESULT NewRtrWizData::HrIsDNSRunningOnGivenInterface(CString InterfaceId)
{
    if (m_fTest)
        return s_fIsDNSRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(InterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDnsEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}


HRESULT NewRtrWizData::HrIsDNSRunningOnNATInterface()
{
    if (m_fTest)
        return s_fIsDNSRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the private interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(m_stNATPrivateInterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDnsEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsDHCPRunningOnInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsDHCPRunningOnInterface()
{
    if (m_fTest)
        return s_fIsDHCPRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the private interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(m_stPrivateInterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDhcpEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}

HRESULT NewRtrWizData::HrIsDHCPRunningOnGivenInterface(CString InterfaceId)
{
    if (m_fTest)
        return s_fIsDHCPRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the private interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(InterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDhcpEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}

HRESULT NewRtrWizData::HrIsDHCPRunningOnNATInterface()
{
    if (m_fTest)
        return s_fIsDHCPRunningOnPrivateInterface ? S_OK : S_FALSE;
    else
    {
        // Search for the private interface in our list
        // ------------------------------------------------------------
        RtrWizInterface *   pRtrWizIf = NULL;

        m_ifMap.Lookup(m_stNATPrivateInterfaceId, pRtrWizIf);
        if (pRtrWizIf)
            return pRtrWizIf->m_fIsDhcpEnabled ? S_OK : S_FALSE;
        else
            return S_FALSE;
    }
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsDNSRunningOnServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsDNSRunningOnServer()
{
    return m_fIsDNSRunningOnServer ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsDHCPRunningOnServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsDHCPRunningOnServer()
{
    return m_fIsDHCPRunningOnServer ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsSharedAccessRunningOnServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsSharedAccessRunningOnServer()
{
    if (m_fTest)
        return s_fIsSharedAccessRunningOnServer ? S_OK : S_FALSE;
    else
        return NatConflictExists(m_stServerName) ? S_OK : S_FALSE;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::HrIsMemberOfDomain
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::HrIsMemberOfDomain()
{
    if (m_fTest)
        return s_fIsMemberOfDomain ? S_OK : S_FALSE;
    else
    {
        // flip the meaning
        HRESULT hr = HrIsStandaloneServer(m_stServerName);
        if (FHrSucceeded(hr))
            return FHrOK(hr) ? S_FALSE : S_OK;
        else
            return hr;
    }
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::GetNextPage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
LRESULT NewRtrWizData::GetNextPage(UINT uDialogId)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    LRESULT lNextPage = 0;
    DWORD   dwNICs;
    CString stTemp;

    switch (uDialogId)
    {
        default:
            Panic0("We should not be here, this is a finish page!");
            break;

        case IDD_NEWRTRWIZ_WELCOME:
            lNextPage = IDD_NEWRTRWIZ_COMMONCONFIG;
            break;
        case IDD_NEWRTRWIZ_COMMONCONFIG:
            switch (m_wizType)
            {                
                case NewWizardRouterType_DialupOrVPN:             
                    
                    if (FHrOK(HrIsIPInstalled()))
                    {
                        lNextPage = IDD_NEWRTRWIZ_RRASVPN;
                    }
                    else
                    {
                        if (FHrOK(HrIsLocalMachine()))
                            lNextPage = IDD_NEWRTRWIZ_VPN_NOIP;
                        else
                            lNextPage = IDD_NEWRTRWIZ_VPN_NOIP_NONLOCAL;
                    }

                    break;
                case NewWizardRouterType_NAT:
                    if ( !FHrOK(HrIsIPInstalled()) )
                    {
                        if (FHrOK(HrIsLocalMachine()))
                            lNextPage = IDD_NEWRTRWIZ_NAT_NOIP;
                        else
                            lNextPage = IDD_NEWRTRWIZ_NAT_NOIP_NONLOCAL;
                    }
                    else
                    {
                        // This is always in advanced mode of operation.
                        if (FHrOK(HrIsSharedAccessRunningOnServer()))
                        {
                            if (FHrOK(HrIsLocalMachine()))
                                lNextPage = IDD_NEWRTRWIZ_NAT_A_CONFLICT;
                            else
                                lNextPage = IDD_NEWRTRWIZ_NAT_A_CONFLICT_NONLOCAL;
                        }
                        else
                        {
                            lNextPage = IDD_NEWRTRWIZ_NAT_A_PUBLIC;
                        }
                    }
                    break;
                case NewWizardRouterType_VPNandNAT:

                    GetNumberOfNICS_IP(&dwNICs);
                    if ( dwNICs < 1 )
                    {
                        lNextPage  = IDD_NEWRTRWIZ_VPN_A_FINISH_NONICS;
                    }
                    else
                    {
                        m_dwNewRouterType |= (NEWWIZ_ROUTER_TYPE_VPN|NEWWIZ_ROUTER_TYPE_NAT);
                        lNextPage = IDD_NEWRTRWIZ_VPN_A_PUBLIC;
                    }

                    break;
                case NewWizardRouterType_DOD:
                    //Use demand dial
                    lNextPage = IDD_NEWRTRWIZ_ROUTER_USEDD;
                    break;
                case NewWizardRouterType_Custom:
                    lNextPage = IDD_NEWRTRWIZ_CUSTOM_CONFIG;
                    break;
            }
            break;
        case IDD_NEWRTRWIZ_CUSTOM_CONFIG:
            lNextPage = IDD_NEWRTRWIZ_MANUAL_FINISH;
            break;
        case IDD_NEWRTRWIZ_RRASVPN:

            //
            //Check to see what the router type is set to.  
            //based on that make a decision what page is next
            //
            GetNumberOfNICS_IP(&dwNICs);
            if ( dwNICs > 1 )
            {
                //
                //There are more than one nics
                //So check to see if it is RAS or VPN or both
                //

                lNextPage = IDD_NEWRTRWIZ_VPN_A_FINISH_NONICS;
                if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN && 
                     m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP
                   )
                {
                    //
                    //This is both a dialup and VPN server
                    //
                    //So show the public private network page
                    //as the next page.
                    //
                    lNextPage = IDD_NEWRTRWIZ_VPN_A_PUBLIC;

                }
                else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN )
                {
                    //
                    //This is only a VPN server.  So show the public
                    //private network page next
                    //
                    lNextPage = IDD_NEWRTRWIZ_VPN_A_PUBLIC;
                }
                else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
                {
                    //
                    //This is only a dialup server.  So show the private
                    //network page next.
                    //
                    lNextPage = IDD_NEWRTRWIZ_RAS_A_NETWORK;
                }

            }
            else if ( dwNICs == 0 )
            {
                //
                //No Nics.  So this if this is a VPN, 
                //this is an error state.  If RAS then 
                //we should be able to install dialup
                //even without a NIC.
                //Since we dont Enable VPN if there are 
                //no nics in the machine, this will
                //only have a dialup case.
                //
                lNextPage = IDD_NEWRTRWIZ_RAS_A_NONICS;
            }
            else
            {
                //
                //Only one nic so in either case, show 
                //the addressing page.  Collapse addressing
                //into one page

                AutoSelectPrivateInterface();
                lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
            }
            
            break;

        case IDD_NEWRTRWIZ_NAT_A_PUBLIC:
            {
                // Determine the number of NICs
                GetNumberOfNICS_IP(&dwNICs);

                // Adjust the number of NICs (depending on whether
                // we selected to create a DD or not).
                if (dwNICs)
                {
                    if (!m_fCreateDD)
                        dwNICs--;
                }

                // Now switch depending on the number of NICs
                if (dwNICs == 0)
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_NONICS_FINISH;
                else if (dwNICs > 1)
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_PRIVATE;

                if (lNextPage)
                    break;
            }
            // Fall through to the next case
            // At this stage, we now have the case that the
            // remaining number of NICs == 1, and we need to
            // autoselect the NIC and go on to the next test.
            AutoSelectPrivateInterface();

        case IDD_NEWRTRWIZ_NAT_A_PRIVATE:
            
            if ( m_wizType == NewWizardRouterType_VPNandNAT ) 
            {
                stTemp = m_stNATPrivateInterfaceId;
            }
            else
            {
                stTemp = m_stPrivateInterfaceId;
            }
            
            if (FHrOK(HrIsDNSRunningOnGivenInterface(stTemp)) ||
                FHrOK(HrIsDHCPRunningOnGivenInterface(stTemp)) ||
                FHrOK(HrIsDNSRunningOnServer()) ||
                FHrOK(HrIsDHCPRunningOnServer()))
            {
                // Popup a warning box
                // AfxMessageBox(IDS_WRN_RTRWIZ_NAT_DHCPDNS_FOUND,
                // MB_ICONEXCLAMATION);
                m_fNatUseSimpleServers = FALSE;
                //continue on down, and fall through
            }
            else
            {
                //
                //check to see if we are in express path
                //if so, we fall thru' again.  no showing 
                //this page.
                if ( MPRSNAP_CYS_EXPRESS_NAT == m_dwExpressType )
                {
                    m_fNatUseSimpleServers = FALSE;
                }
                else
                {
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_DHCPDNS;
                    break;
                }
            }

        case IDD_NEWRTRWIZ_NAT_A_DHCPDNS:
            if (m_fNatUseSimpleServers)
                lNextPage = IDD_NEWRTRWIZ_NAT_A_DHCP_WARNING;
            else
            {
                if (m_fCreateDD)
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_DD_WARNING;
                else
                {
                    if ( m_wizType == NewWizardRouterType_VPNandNAT )
                    {
                        lNextPage = IDD_NEWRTRWIZ_USERADIUS;
                    }
                    else
                        lNextPage = IDD_NEWRTRWIZ_NAT_A_EXTERNAL_FINISH;
                }
            }
            break;

        case IDD_NEWRTRWIZ_NAT_A_DHCP_WARNING:
            Assert(m_fNatUseSimpleServers);
            if (m_fCreateDD)
                lNextPage = IDD_NEWRTRWIZ_NAT_A_DD_WARNING;
            else
            {
                if ( m_wizType == NewWizardRouterType_VPNandNAT )
                {
                    lNextPage = IDD_NEWRTRWIZ_USERADIUS;
                }
                else
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_FINISH;
            }
            break;

        case IDD_NEWRTRWIZ_NAT_A_DD_WARNING:
            if (!FHrSucceeded(m_hrDDError))
                lNextPage = IDD_NEWRTRWIZ_NAT_A_DD_ERROR;
            else
            {
                if (m_fNatUseSimpleServers)
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_FINISH;
                else
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_EXTERNAL_FINISH;
            }
            break;


        case IDD_NEWRTRWIZ_RAS_A_ATALK:
            if (FHrOK(HrIsIPInUse()))
            {
                GetNumberOfNICS_IP(&dwNICs);

                if (dwNICs > 1)
                    lNextPage = IDD_NEWRTRWIZ_RAS_A_NETWORK;
                else if (dwNICs == 0)
                    lNextPage = IDD_NEWRTRWIZ_RAS_A_NONICS;
                else
                {
                    AutoSelectPrivateInterface();
                    lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
                }
                break;
            }

            // default catch
            lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH;
            break;

        case IDD_NEWRTRWIZ_RAS_A_NONICS:
            if (m_fNoNicsAreOk)
                lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
            else
                lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH_NONICS;
            break;

        case IDD_NEWRTRWIZ_RAS_A_NETWORK:
            lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
            break;

        case IDD_NEWRTRWIZ_ADDRESSING:

            GetNumberOfNICS_IP(&dwNICs);
            if ( m_wizType == NewWizardRouterType_VPNandNAT )
            {
                //This is a VPN and NAT case
                if ( m_fUseDHCP )
                {
                    // Determine how many choices are available for 
                    // NAT private interface
                    // The public interface cannot be used as a NAT private

                    if ( !m_stPublicInterfaceId.IsEmpty() )
                        dwNICs --;

                    // If there is only one NIC left, then pick that as the 
                    // NAT private interface. By now that same NIC has already 
                    // been selected as VPN private interface
                    // After that, goto the DHCP/DNS page
                    // Or else show the nat private interface selection page

                    // At this point dwNICs should never be less than 1
                    Assert(dwNICs > 0);
                    
                    if ( dwNICs == 1 )
                    {
                        m_stNATPrivateInterfaceId = m_stPrivateInterfaceId;

                        if (FHrOK(HrIsDNSRunningOnNATInterface()) ||
                            FHrOK(HrIsDHCPRunningOnNATInterface()) ||
                            FHrOK(HrIsDNSRunningOnServer()) ||
                            FHrOK(HrIsDHCPRunningOnServer()))
                        {
                            m_fNatUseSimpleServers = FALSE;

                            //
                            //Continue on with the VPN wizard part
                            //
                            lNextPage = IDD_NEWRTRWIZ_USERADIUS;

                        }
                        else
                        {
                            lNextPage = IDD_NEWRTRWIZ_NAT_A_DHCPDNS;
                        }
                    }
                    else
                    {
                        lNextPage = IDD_NEWRTRWIZ_NAT_A_PRIVATE;
                    }
                }
                else
                {
                    //
                    //Since static address pool was selected, show the
                    //addressing page.
                    //
                    lNextPage = IDD_NEWRTRWIZ_ADDRESSPOOL;
                }
            }
            else if ( ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN) || 
                 ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
               )
            {                
                if ( !dwNICs && m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
                {
                    //No NICS.  This should happen only in case of dialup.
                    if (m_fUseDHCP)
                    {
                        lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH;
                    }
                    else
                        lNextPage = IDD_NEWRTRWIZ_ADDRESSPOOL;
                }
                else if (m_fUseDHCP)
                {
                    //
                    //Logic is the same irrespective of whether it is
                    //VPN or DIALUP.
                    //
                    
                    lNextPage = IDD_NEWRTRWIZ_USERADIUS;
                }
                else
                    lNextPage = IDD_NEWRTRWIZ_ADDRESSPOOL;

            }
            else if ( m_dwNewRouterType && NEWWIZ_ROUTER_TYPE_DOD )
            {
                if (m_fUseDHCP)
                    lNextPage = IDD_NEWRTRWIZ_ROUTER_FINISH_DD;
                else
                    lNextPage = IDD_NEWRTRWIZ_ADDRESSPOOL;                
            }            
            break;

        case IDD_NEWRTRWIZ_ADDRESSPOOL:

            GetNumberOfNICS_IP(&dwNICs);

            if ( m_wizType == NewWizardRouterType_VPNandNAT )
            {
            
                // Determine how many choices are available for 
                // NAT private interface
                // The public interface cannot be used as a NAT private

                if ( !m_stPublicInterfaceId.IsEmpty() )
                    dwNICs --;

                // If there is only one NIC left, then pick that as the 
                // NAT private interface. By now that same NIC has already 
                // been selected as VPN private interface
                // After that, goto the DHCP/DNS page
                // Or else show the nat private interface selection page

                // At this point dwNICs should never be less than 1
                Assert(dwNICs > 0);
                
                if ( dwNICs == 1 )
                {
                    m_stNATPrivateInterfaceId = m_stPrivateInterfaceId;

                    if (FHrOK(HrIsDNSRunningOnNATInterface()) ||
                        FHrOK(HrIsDHCPRunningOnNATInterface()) ||
                        FHrOK(HrIsDNSRunningOnServer()) ||
                        FHrOK(HrIsDHCPRunningOnServer()))
                    {
                        m_fNatUseSimpleServers = FALSE;

                        //
                        //Continue on with the VPN wizard part
                        //
                        lNextPage = IDD_NEWRTRWIZ_USERADIUS;

                    }
                    else
                    {
                        lNextPage = IDD_NEWRTRWIZ_NAT_A_DHCPDNS;
                    }
                }
                else
                {
                    lNextPage = IDD_NEWRTRWIZ_NAT_A_PRIVATE;
                }        

            }
            else if ( ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN) || 
                 ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
               )
            {
                
                if (dwNICs == 0)
                    lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH;
                else
                    lNextPage = IDD_NEWRTRWIZ_USERADIUS;
            }
            else if ( m_dwNewRouterType && NEWWIZ_ROUTER_TYPE_DOD )
            {
                    lNextPage = IDD_NEWRTRWIZ_ROUTER_FINISH_DD;
            }
            break;
            

        case IDD_NEWRTRWIZ_USERADIUS:
            if (m_fUseRadius)
                lNextPage = IDD_NEWRTRWIZ_RADIUS_CONFIG;
            else
                if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN &&
                     m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT
                    )
                {
                    //NAT and VPN
                    lNextPage = IDD_NEWRTRWIZ_NAT_VPN_A_FINISH;
                }
                else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP &&
                     m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN 
                   )
                {
                    //RAS and VPN
                    lNextPage = IDD_NEWRTRWIZ_RAS_VPN_A_FINISH;
                }
                else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
                {    
                    //RAS only
                    lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH;
                }
                else
                {
                    //VPN only
                    lNextPage = IDD_NEWRTRWIZ_VPN_A_FINISH;
                }
            break;

        case IDD_NEWRTRWIZ_RADIUS_CONFIG:
            if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN &&
                 m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT
                )
            {
                //NAT and VPN
                lNextPage = IDD_NEWRTRWIZ_NAT_VPN_A_FINISH;
            }
            else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP &&
                 m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN 
               )
            {
                //RAS and VPN
                lNextPage = IDD_NEWRTRWIZ_RAS_VPN_A_FINISH;
            }
            else if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
            {
                //RAS only                
                lNextPage = IDD_NEWRTRWIZ_RAS_A_FINISH;
            }
            else
            {
                //VPN only
                lNextPage = IDD_NEWRTRWIZ_VPN_A_FINISH;
            }
            break;


        case IDD_NEWRTRWIZ_VPN_A_ATALK:

            GetNumberOfNICS_IP(&dwNICs);
            Assert(dwNICs >= 1);

            lNextPage = IDD_NEWRTRWIZ_VPN_A_PUBLIC;
            break;

        case IDD_NEWRTRWIZ_VPN_A_PUBLIC:
            GetNumberOfNICS_IP(&dwNICs);

            // Are there any NICs left?
            if (((dwNICs == 1) && m_stPublicInterfaceId.IsEmpty()) ||
                ((dwNICs == 2) && !m_stPublicInterfaceId.IsEmpty()))
            {
                AutoSelectPrivateInterface();
                lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
            }
            else
                lNextPage = IDD_NEWRTRWIZ_VPN_A_PRIVATE;
            break;

        case IDD_NEWRTRWIZ_VPN_A_PRIVATE:
            Assert(!m_stPrivateInterfaceId.IsEmpty());
            lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
            break;

        case IDD_NEWRTRWIZ_VPN_A_ADDRESSPOOL:
            
            break;

        case IDD_NEWRTRWIZ_ROUTER_USEDD:
           if (m_fUseDD)
               lNextPage = IDD_NEWRTRWIZ_ADDRESSING;
           else
               lNextPage = IDD_NEWRTRWIZ_ROUTER_FINISH;
           break;
        case IDD_NEWRTRWIZ_ROUTER_ADDRESSPOOL:
            lNextPage = IDD_NEWRTRWIZ_ROUTER_FINISH_DD;
            break;

    }

    return lNextPage;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::GetNumberOfNICS
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::GetNumberOfNICS_IP(DWORD *pdwNumber)
{
    if (m_fTest)
    {
        Assert(s_dwNumberOfNICs == m_ifMap.GetCount());
    }
    *pdwNumber = m_ifMap.GetCount();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::GetNumberOfNICS_IPorIPX
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::GetNumberOfNICS_IPorIPX(DWORD *pdwNumber)
{
    *pdwNumber = m_dwNumberOfNICs_IPorIPX;
    return hrOK;
}

void NewRtrWizData::AutoSelectNATPrivateInterface()
{
    POSITION            pos;
    RtrWizInterface *   pRtrWizIf = NULL;
    CString             st;

    m_stNATPrivateInterfaceId.Empty();

    pos = m_ifMap.GetStartPosition();
    while (pos)
    {
        m_ifMap.GetNextAssoc(pos, st, pRtrWizIf);

        if (m_stPublicInterfaceId != st && 
            m_stPrivateInterfaceId != st )
        {
            m_stNATPrivateInterfaceId = st;
            break;
        }
    }

    Assert(!m_stNATPrivateInterfaceId.IsEmpty());

    return;
}
/*!--------------------------------------------------------------------------
    NewRtrWizData::AutoSelectPrivateInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void NewRtrWizData::AutoSelectPrivateInterface()
{
    POSITION    pos;
    RtrWizInterface *   pRtrWizIf = NULL;
    CString     st;

    m_stPrivateInterfaceId.Empty();

    pos = m_ifMap.GetStartPosition();
    while (pos)
    {
        m_ifMap.GetNextAssoc(pos, st, pRtrWizIf);

        if (m_stPublicInterfaceId != st)
        {
            m_stPrivateInterfaceId = st;
            break;
        }
    }

    Assert(!m_stPrivateInterfaceId.IsEmpty());

    return;
}

/*!--------------------------------------------------------------------------
    NewRtrWizData::LoadInterfaceData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void NewRtrWizData::LoadInterfaceData(IRouterInfo *pRouter)
{
    HRESULT     hr = hrOK;
    HKEY        hkeyMachine = NULL;

    if (!m_fTest)
    {
        // Try to get the real information
        SPIEnumInterfaceInfo        spEnumIf;
        SPIInterfaceInfo            spIf;
        RtrWizInterface *           pRtrWizIf = NULL;
        CStringList                 listAddress;
        CStringList                 listMask;
        BOOL                        fDhcp;
        BOOL                        fDns;

        pRouter->EnumInterface(&spEnumIf);

        CWRg( ConnectRegistry(pRouter->GetMachineName(), &hkeyMachine) );

        for (; hrOK == spEnumIf->Next(1, &spIf, NULL); spIf.Release())
        {
            // Only look at NICs
            if (spIf->GetInterfaceType() != ROUTER_IF_TYPE_DEDICATED)
                continue;

            // count the interface bound to IP or IPX
            if (FHrOK(spIf->FindRtrMgrInterface(PID_IP, NULL)) || FHrOK(spIf->FindRtrMgrInterface(PID_IPX, NULL)))
            {
                m_dwNumberOfNICs_IPorIPX++;
            }

            // Only allow those interfaces bound to IP to show up
            if (!FHrOK(spIf->FindRtrMgrInterface(PID_IP, NULL)))
            {
                continue;
            }

            pRtrWizIf = new RtrWizInterface;

            pRtrWizIf->m_stName = spIf->GetTitle();
            pRtrWizIf->m_stId = spIf->GetId();
            pRtrWizIf->m_stDesc = spIf->GetDeviceName();

            if (FHrOK(HrIsIPInstalled()))
            {
                POSITION    pos;
                DWORD       netAddress, dwAddress;
                CString     stAddress, stDhcpServer;

                // Clear the lists before getting them again.
                // ----------------------------------------------------
                listAddress.RemoveAll();
                listMask.RemoveAll();
                fDhcp = fDns = FALSE;

                QueryIpAddressList(pRouter->GetMachineName(),
                                   hkeyMachine,
                                   spIf->GetId(),
                                   &listAddress,
                                   &listMask,
                                   &fDhcp,
                                   &fDns,
                                   &stDhcpServer);

                // Iterate through the list of strings looking
                // for an autonet address
                // ----------------------------------------------------
                pos = listAddress.GetHeadPosition();
                while (pos)
                {
                    stAddress = listAddress.GetNext(pos);
                    netAddress = INET_ADDR((LPCTSTR) stAddress);
                    dwAddress = ntohl(netAddress);

                    // Check for reserved address ranges, this indicates
                    // an autonet address
                    // ------------------------------------------------
                    if ((dwAddress & 0xFFFF0000) == MAKEIPADDRESS(169,254,0,0))
                    {
                        // This is not a DHCP address, it is an
                        // autonet address.
                        // --------------------------------------------
                        fDhcp = FALSE;
                        break;
                    }
                }

                FormatListString(listAddress, pRtrWizIf->m_stIpAddress,
                                 _T(","));
                FormatListString(listMask, pRtrWizIf->m_stMask,
                                 _T(","));

                stDhcpServer.TrimLeft();
                stDhcpServer.TrimRight();
                pRtrWizIf->m_stDhcpServer = stDhcpServer;

                pRtrWizIf->m_fDhcpObtained = fDhcp;
                pRtrWizIf->m_fIsDhcpEnabled = fDhcp;
                pRtrWizIf->m_fIsDnsEnabled = fDns;
            }

            m_ifMap.SetAt(pRtrWizIf->m_stId, pRtrWizIf);
            pRtrWizIf = NULL;
        }

        delete pRtrWizIf;
    }
    else
    {
        CString             st;
        RtrWizInterface *   pRtrWizIf;

        // For now just the debug data
        for (DWORD i=0; i<s_dwNumberOfNICs; i++)
        {
            pRtrWizIf = new RtrWizInterface;

            pRtrWizIf->m_stName.Format(_T("Local Area Connection #%d"), i);
            pRtrWizIf->m_stId.Format(_T("{%d-GUID...}"), i);
            pRtrWizIf->m_stDesc = _T("Generic Intel hardware");

            if (FHrOK(HrIsIPInstalled()))
            {
                pRtrWizIf->m_stIpAddress = _T("11.22.33.44");
                pRtrWizIf->m_stMask = _T("255.255.0.0");

                // These parameters are dependent on other things
                pRtrWizIf->m_fDhcpObtained = FALSE;
                pRtrWizIf->m_fIsDhcpEnabled = FALSE;
                pRtrWizIf->m_fIsDnsEnabled = FALSE;
            }

            m_ifMap.SetAt(pRtrWizIf->m_stId, pRtrWizIf);
            pRtrWizIf = NULL;
        }
    }

Error:
    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);
}


/*!--------------------------------------------------------------------------
    NewRtrWizData::SaveToRtrConfigData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::SaveToRtrConfigData()
{
    HRESULT     hr = hrOK;
    POSITION    pos;
    AddressPoolInfo poolInfo;
    m_dwRouterType  = 0;

    
    // Sync up with the general structure
    // ----------------------------------------------------------------
    if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT )
    {
        m_dwRouterType |= ROUTER_TYPE_LAN;

        // If we have been told to create a DD interface
        // then we must have a WAN router.
        if (m_fCreateDD)
            m_dwRouterType |= ROUTER_TYPE_WAN;
    }

    if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
    {
        m_dwRouterType |= ROUTER_TYPE_RAS;
    }

    if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN )
    {
        m_dwRouterType |= (ROUTER_TYPE_LAN | ROUTER_TYPE_WAN | ROUTER_TYPE_RAS);
    }

    if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DOD )
    {
        m_dwRouterType |= ROUTER_TYPE_WAN;
    }

    if ( m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_LAN_ROUTING )
    {
        m_dwRouterType |= ROUTER_TYPE_LAN;
    }

    
    m_RtrConfigData.m_dwRouterType = m_dwRouterType;

    // Setup the NAT-specific information
    // ----------------------------------------------------------------
    if ((m_wizType != NewWizardRouterType_Custom) && (m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT))
    {
        m_RtrConfigData.m_dwConfigFlags |= RTRCONFIG_SETUP_NAT;

        if (m_fNatUseSimpleServers)
        {
            m_RtrConfigData.m_dwConfigFlags |= RTRCONFIG_SETUP_DNS_PROXY;
            m_RtrConfigData.m_dwConfigFlags |= RTRCONFIG_SETUP_DHCP_ALLOCATOR;
        }

        m_RtrConfigData.m_dwConfigFlags |= RTRCONFIG_SETUP_ALG;  // savasg added
    }

    // Sync up with the IP structure
    // ----------------------------------------------------------------
    if (m_fIpInstalled)
    {
        DWORD   dwNICs;

        // Set the private interface id into the IP structure
        Assert(!m_stPrivateInterfaceId.IsEmpty());

        m_RtrConfigData.m_ipData.m_dwAllowNetworkAccess = TRUE;
        m_RtrConfigData.m_ipData.m_dwUseDhcp = m_fUseDHCP;

        // If there is only one NIC, leave this the way it is (RAS
        // to select the adapter).  Otherwise, people can get stuck.
        // Install 1, remove it and install a new one.
        // 
        // ------------------------------------------------------------
        GetNumberOfNICS_IP(&dwNICs);
        if (dwNICs > 1)
            m_RtrConfigData.m_ipData.m_stNetworkAdapterGUID = m_stPrivateInterfaceId;
        m_RtrConfigData.m_ipData.m_stPrivateAdapterGUID = m_stPrivateInterfaceId;
        m_RtrConfigData.m_ipData.m_stPublicAdapterGUID = m_stPublicInterfaceId;
        m_RtrConfigData.m_ipData.m_dwEnableIn = TRUE;

        // copy over the address pool list
        m_RtrConfigData.m_ipData.m_addressPoolList.RemoveAll();
        if (m_addressPoolList.GetCount())
        {
            pos = m_addressPoolList.GetHeadPosition();
            while (pos)
            {
                poolInfo = m_addressPoolList.GetNext(pos);
                m_RtrConfigData.m_ipData.m_addressPoolList.AddTail(poolInfo);
            }
        }
    }


    // Sync up with the IPX structure
    // ----------------------------------------------------------------
    if (m_fIpxInstalled)
    {
        m_RtrConfigData.m_ipxData.m_dwAllowNetworkAccess = TRUE;
        m_RtrConfigData.m_ipxData.m_dwEnableIn = TRUE;
        m_RtrConfigData.m_ipxData.m_fEnableType20Broadcasts = m_fUseIpxType20Broadcasts;

        // The other parameters will be left at their defaults
    }


    // Sync up with the Appletalk structure
    // ----------------------------------------------------------------
    if (m_fAppletalkInstalled)
    {
        m_RtrConfigData.m_arapData.m_dwEnableIn = TRUE;
    }

    // Sync up with the NBF structure
    // ----------------------------------------------------------------
    if (m_fNbfInstalled)
    {
        m_RtrConfigData.m_nbfData.m_dwAllowNetworkAccess = TRUE;
        m_RtrConfigData.m_nbfData.m_dwEnableIn = TRUE;
    }

    // Sync up with the PPP structure
    // ----------------------------------------------------------------
    // Use the defaults


    // Sync up with the Error log structure
    // ----------------------------------------------------------------
    // Use the defaults


    // Sync up with the Auth structure
    // ----------------------------------------------------------------
    m_RtrConfigData.m_authData.m_dwFlags = USE_PPPCFG_DEFAULT_METHODS;

    if (m_fAppletalkUseNoAuth)
        m_RtrConfigData.m_authData.m_dwFlags |=
                                               PPPCFG_AllowNoAuthentication;

    if (m_fUseRadius)
    {
        TCHAR   szGuid[128];

        // Setup the active auth/acct providers to be RADIUS
        StringFromGUID2(CLSID_RouterAuthRADIUS, szGuid, DimensionOf(szGuid));
        m_RtrConfigData.m_authData.m_stGuidActiveAuthProv = szGuid;

        StringFromGUID2(CLSID_RouterAcctRADIUS, szGuid, DimensionOf(szGuid));
        m_RtrConfigData.m_authData.m_stGuidActiveAcctProv = szGuid;
    }
    // Other parameters left at their defaults

    return hr;
}


// --------------------------------------------------------------------
// Windows NT Bug : 408722
// Use this code to grab the WM_HELP message from the property sheet.
// --------------------------------------------------------------------
static WNDPROC s_lpfnOldWindowProc = NULL;

LONG FAR PASCAL HelpSubClassWndFunc(HWND hWnd,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam)
{
    if (uMsg == WM_HELP)
    {
        HWND hWndOwner = PropSheet_GetCurrentPageHwnd(hWnd);
        HELPINFO *  pHelpInfo = (HELPINFO *) lParam;

        // Reset the context ID, since we know exactly what we're
        // sending (ahem, unless someone reuses this).
        // ------------------------------------------------------------
        pHelpInfo->dwContextId = 0xdeadbeef;

        // Send the WM_HELP message to the prop page
        // ------------------------------------------------------------
        ::SendMessage(hWndOwner, uMsg, wParam, lParam);
        return TRUE;
    }
    return CallWindowProc(s_lpfnOldWindowProc, hWnd, uMsg, wParam, lParam);
}



/*!--------------------------------------------------------------------------
    NewRtrWizData::FinishTheDamnWizard
        This is the code that actually does the work of saving the
        data and doing all the operations.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::FinishTheDamnWizard(HWND hwndOwner,
                                           IRouterInfo *pRouter, BOOL mesgflag)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DWORD dwError = ERROR_SUCCESS;
    SPIRemoteNetworkConfig    spNetwork;
    SPIRemoteSetDnsConfig    spDns;
    IUnknown *                punk = NULL;
    CWaitCursor                wait;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;
    HRESULT                 hr = hrOK, dnsHr = hrOK;
    CString sTempPrivateIfID = m_stPrivateInterfaceId;
    if (m_fSaved)
        return hr;

    // Synchronize the RtrConfigData with this structure
    // ----------------------------------------------------------------
    CORg( SaveToRtrConfigData() );


    // Ok, we now have the synchronized RtrConfigData.
    // We can do everything else that we did before to save the
    // information.

    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));

    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;

    // Create the remote config object
    // ----------------------------------------------------------------
    CORg( CoCreateRouterConfig(m_RtrConfigData.m_stServerName,
                               pRouter,
                               &csi,
                               IID_IRemoteNetworkConfig,
                               &punk) );

    spNetwork = (IRemoteNetworkConfig *) punk;
    punk = NULL;

    // Upgrade the configuration (ensure that the registry keys
    // are populated correctly).
    // ------------------------------------------------------------
    CORg( spNetwork->UpgradeRouterConfig() );

   if ( !m_stPublicInterfaceId.IsEmpty()){
	   //kmurthy: Mark the public interface selected as uninteresting to DNS. Bug:380423
	   dnsHr = CoCreateRouterConfig(m_RtrConfigData.m_stServerName,
                               pRouter,
                               &csi,
                               IID_IRemoteSetDnsConfig,
                               &punk);

	   if(FHrSucceeded(dnsHr)){
		spDns = (IRemoteSetDnsConfig *)punk;
	   	CORg(spDns->SetDnsConfig((DWORD)DnsConfigWaitForNameErrorOnAll, NULL));
	   }

	   punk = NULL;
   }


#ifdef KSL_IPINIP
    // Remove the IP-in-IP tunnel names (since the registry has
    // been cleared).
    // ------------------------------------------------------------
    CleanupTunnelFriendlyNames(pRouter);
#endif //KSL_IPINIP


    // At this point, the current IRouterInfo pointer is invalid.
    // We will need to release the pointer and reload the info.
    // ------------------------------------------------------------
    if (pRouter)
    {
        pRouter->DoDisconnect();
        pRouter->Unload();
        pRouter->Load(m_stServerName, NULL);
    }


    dwError = RtrWizFinish( &m_RtrConfigData, pRouter );
    hr = HResultFromWin32(dwError);

    // Windows NT Bug : 173564
    // Depending on the router type, we will go through and enable the
    // devices.
    //    If routing only is enabled : set devices to ROUTING
    //  If ras-only : set devices to RAS
    //    If ras/routing : set devices to RAS/ROUTING
    //    5/19/98 - need some resolution from DavidEi on what to do here.
    // ------------------------------------------------------------

    // Setup the entries in the list
    // ------------------------------------------------------------
    if (m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN )
        SetDeviceType(m_stServerName, m_dwRouterType, 256);
    else
        SetDeviceType(m_stServerName, m_dwRouterType, 10);

    // Update the RADIUS config
    // ----------------------------------------------------------------
    SaveRadiusConfig();

    //
    //Add the NAT protocol if tcpip routing is selected
    //
    
    if ( (m_wizType != NewWizardRouterType_Custom) && (m_wizType != NewWizardRouterType_DialupOrVPN)
        && m_RtrConfigData.m_ipData.m_dwAllowNetworkAccess )
        AddNATToServer(this, &m_RtrConfigData, pRouter, m_fCreateDD, TRUE);

    // Ok at this point we try to establish the server in the domain
    // If this fails, we ignore the error and popup a warning message.
    //
    // Windows NT Bug : 202776
    // Do not register the router if we are a LAN-only router.
    // ----------------------------------------------------------------
    if ( FHrSucceeded(hr) &&
         (m_dwRouterType != ROUTER_TYPE_LAN) &&
         (!m_fUseRadius))
    {
        HRESULT hrT = hrOK;

        hrT = ::RegisterRouterInDomain(m_stServerName, TRUE);

        if (hrT != ERROR_NO_SUCH_DOMAIN)
        {
            if (!FHrSucceeded(hrT))
            {
                CRasWarning dlg((char *)c_sazRRASDomainHelpTopic, IDS_ERR_CANNOT_REGISTER_IN_DS);
                dlg.DoModal();
            }
        }
    }
    // NT Bug : 239384
    // Install IGMP on the router by default (for RAS server only)
    // Boing!, Change to whenever RAS is installed.
    // ----------------------------------------------------------------

    // We do NOT do this if we are using NAT.  The reason is that
    // NAT may want to be added to a demand dial interface.
    // ----------------------------------------------------------------


//
//    if ( m_wizType == NewWizardRouterType_VPNandNAT )
//        m_stPrivateInterfaceId = m_stNATPrivateInterfaceId;
//

    if (!(m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT ) ||
        ((m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT ) && !m_fCreateDD))
    {
        // The path that NAT takes when creating the DD interface
        // is somewhere else.
        // ------------------------------------------------------------
        Assert(m_fCreateDD == FALSE);

        if (pRouter)
        {
            if (m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT )
            {
                AddIGMPToNATServer(this, &m_RtrConfigData, pRouter, (m_wizType == NewWizardRouterType_VPNandNAT));
            }
            else if (m_RtrConfigData.m_dwRouterType & ROUTER_TYPE_RAS)
            {
                AddIGMPToRasServer(&m_RtrConfigData, pRouter);
            }
        }

        if (m_RtrConfigData.m_dwConfigFlags & RTRCONFIG_SETUP_NAT)
        {
            AddNATToServer(this, &m_RtrConfigData, pRouter, m_fCreateDD, FALSE);
        }
        else if ( m_wizType == NewWizardRouterType_Custom )
        {
            //
            //If this is custom config and NAT is selected.  Just add the protocol and 
            //nothing else.
            //
            AddNATToServer(this, &m_RtrConfigData, pRouter, m_fCreateDD, TRUE);
        }

        // Windows NT Bug : 371493
        // Add the DHCP relay agent protocol
        if (m_RtrConfigData.m_dwRouterType & ROUTER_TYPE_RAS)
        {
            DWORD   dwDhcpServer = 0;

            if (!m_stPrivateInterfaceId.IsEmpty())
            {
                RtrWizInterface *   pRtrWizIf = NULL;

                m_ifMap.Lookup(m_stPrivateInterfaceId, pRtrWizIf);
                if (pRtrWizIf)
                {
                    if (!pRtrWizIf->m_stDhcpServer.IsEmpty())
                        dwDhcpServer = INET_ADDR((LPCTSTR) pRtrWizIf->m_stDhcpServer);

                    // If we have a value of 0, or if the address
                    // is all 1's then we have a bogus address.
                    if ((dwDhcpServer == 0) ||
                        (dwDhcpServer == MAKEIPADDRESS(255,255,255,255))){
                        CRasWarning dlg("RRASconcepts.chm::/mpr_how_dhcprelay.htm", IDS_WRN_RTRWIZ_NO_DHCP_SERVER);
                        dlg.DoModal();
                    	}
                }
            }

            AddIPBOOTPToServer(&m_RtrConfigData, pRouter, dwDhcpServer);
        }
    }

//    if ( m_wizType == NewWizardRouterType_VPNandNAT )
//        m_stPrivateInterfaceId = sTempPrivateIfID;


    // If this is a VPN, add the filters to the public interface
    // ----------------------------------------------------------------
    if ( (m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN) && 
            (m_wizType == NewWizardRouterType_DialupOrVPN) && 
            m_fSetVPNFilter )
    {
        if ((!m_stPublicInterfaceId.IsEmpty()) && (m_fSetVPNFilter == TRUE))
        {
#if __USE_ICF__
            m_RtrConfigData.m_dwConfigFlags |= RTRCONFIG_SETUP_NAT;
            AddNATToServer(this, &m_RtrConfigData, pRouter, m_fCreateDD, FALSE);
#else            
            RtrWizInterface*    pIf = NULL;
            m_ifMap.Lookup(m_stPublicInterfaceId, pIf);
            AddVPNFiltersToInterface(pRouter, m_stPublicInterfaceId, pIf);
            DisableDDNSandNetBtOnInterface ( pRouter, m_stPublicInterfaceId, pIf);
#endif
        }
    }

    //
    // Bug 519414
    //  Since IAS now has a Microsoft policy with the appropriate settings,
    //  there is no longer a single default policy.  In addition there is
    //  no need to update any policy to have the required settings since the
    //  Microsoft VPN server policy does the job.
    //
    
#if __DEFAULT_POLICY
    // Try to update the policy.
    // ----------------------------------------------------------------

    // This should check the auth flags and the value of the flags
    // should follow that.
    // ----------------------------------------------------------------
    if ((m_RtrConfigData.m_dwRouterType & ROUTER_TYPE_RAS) && !m_fUseRadius)
    {
        LPWSTR  pswzServerName = NULL;
        DWORD   dwFlags;
        BOOL    fRequireEncryption;

        if (!IsLocalMachine(m_stServerName))
            pswzServerName = (LPTSTR)(LPCTSTR) m_stServerName;

        dwFlags = m_RtrConfigData.m_authData.m_dwFlags;

        // Only require encryption if this is a VPN server
        // do not set the PPPCFG_RequireEncryption flag
        // ------------------------------------------------------------
        fRequireEncryption = (m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN );

        hr = UpdateDefaultPolicy(pswzServerName,
                                 !!(dwFlags & PPPCFG_NegotiateMSCHAP),
                                 !!(dwFlags & PPPCFG_NegotiateStrongMSCHAP),
                                 fRequireEncryption);

        if (!FHrSucceeded(hr))
        {
            if (hr == ERROR_NO_DEFAULT_PROFILE)
            {
                // Do one thing
                AfxMessageBox(IDS_ERR_CANNOT_FIND_DEFAULT_RAP, MB_OK | MB_ICONEXCLAMATION);

                // since we already displayed the warning
                hr = S_OK;
            }
            else
            {
                // Format the message
                AddSystemErrorMessage(hr);

                // popup a warning dialog
                AddHighLevelErrorStringId(IDS_ERR_CANNOT_SYNC_WITH_RAP);
                DisplayTFSErrorMessage(NULL);
            }
        }
    }
#endif


    // Always start the router.
    // ----------------------------------------------------------------
    SetRouterServiceStartType(m_stServerName,
                              SERVICE_AUTO_START);
    {

	if(!mesgflag){ //If the mesgflag is TRUE, all UI should be suppressed and service need not be started.
		
	        // If this is manual start, we need to prompt them
	        // ------------------------------------------------------------
	        if ((m_wizType != NewWizardRouterType_Custom) ||
	            (AfxMessageBox(IDS_PROMPT_START_ROUTER_AFTER_INSTALL,
	                           MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND) == IDYES))
	        {
	            CWaitCursor        wait;
	            StartRouterService(m_RtrConfigData.m_stServerName);
	        }
	}
    }


    if ( m_fUseDD && m_wizType == NewWizardRouterType_DOD)
    {
    	HRESULT hr;
        hr = CallRouterEntryDlg(NULL,
                            this,
                            0);
        
	 if (!FHrSucceeded(hr)){
	        DisableRRAS((TCHAR *)(LPCTSTR)m_stServerName);
	 }
    }
    // Mark this data structure as been saved.  This way, when we
    // reennter this function it doesn't get run again.
    // ----------------------------------------------------------------
    m_fSaved = TRUE;

Error:

    // Force a router reconfiguration
    // ----------------------------------------------------------------

    // Force a full disconnect
    // This will force the handles to be released
    // ----------------------------------------------------------------
    pRouter->DoDisconnect();

    // ForceGlobalRefresh(m_spRouter);

    // Get the error back
    // ----------------------------------------------------------------
    if (!FHrSucceeded(hr))
    {
        AddSystemErrorMessage(hr);
        AddHighLevelErrorStringId(IDS_ERR_CANNOT_INSTALL_ROUTER);
        DisplayTFSErrorMessage(NULL);
    }

    if (csi.pAuthInfo)
        delete csi.pAuthInfo->pAuthIdentityData->Password;

	m_hr = hr;
    return hr;
}


/*!--------------------------------------------------------------------------
    NewRtrWizData::SaveRadiusConfig
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT NewRtrWizData::SaveRadiusConfig()
{
    HRESULT     hr = hrOK;
    HKEY        hkeyMachine = NULL;
    RADIUSSERVER    rgServers[2];
    RADIUSSERVER *  pServers = NULL;
    CRadiusServers  oldServers;
    BOOL        fServerAdded = FALSE;

    CWRg( ConnectRegistry((LPTSTR) (LPCTSTR) m_stServerName, &hkeyMachine) );

    if (m_fUseRadius)
    {
        pServers = rgServers;

        Assert(!m_stRadius1.IsEmpty() || !m_stRadius2.IsEmpty());

        // Setup the pServers
        if (!m_stRadius1.IsEmpty() && m_stRadius1.GetLength())
        {
            pServers->UseDefaults();

            pServers->cScore = MAXSCORE;

            // For compatibility with other RADIUS servers, we
            // default this to OFF.
            pServers->fUseDigitalSignatures = FALSE;

            StrnCpy(pServers->szName, (LPCTSTR) m_stRadius1, MAX_PATH);
            StrnCpy(pServers->wszSecret, (LPCTSTR) m_stRadiusSecret, MAX_PATH);
            pServers->cchSecret = m_stRadiusSecret.GetLength();
            pServers->IPAddress.sin_addr.s_addr = m_netRadius1IpAddress;

            pServers->ucSeed = m_uSeed;

            pServers->pNext = NULL;

            fServerAdded = TRUE;
        }

        if (!m_stRadius2.IsEmpty() && m_stRadius2.GetLength())
        {
            // Have the previous one point here
            if (fServerAdded)
            {
                pServers->pNext = pServers+1;
                pServers++;
            }

            pServers->UseDefaults();

            pServers->cScore = MAXSCORE - 1;

            // For compatibility with other RADIUS servers, we
            // default this to OFF.
            pServers->fUseDigitalSignatures = FALSE;

            StrnCpy(pServers->szName, (LPCTSTR) m_stRadius2, MAX_PATH);
            StrnCpy(pServers->wszSecret, (LPCTSTR) m_stRadiusSecret, MAX_PATH);
            pServers->cchSecret = m_stRadiusSecret.GetLength();
            pServers->IPAddress.sin_addr.s_addr = m_netRadius2IpAddress;

            pServers->ucSeed = m_uSeed;

            pServers->pNext = NULL;

            fServerAdded = TRUE;
        }

        // Ok, reset pServers
        if (fServerAdded)
            pServers = rgServers;

    }

    // Load the original server list and remove it from the
    // LSA database.
    LoadRadiusServers(m_stServerName,
                      hkeyMachine,
                      TRUE,
                      &oldServers,
                      RADIUS_FLAG_NOUI | RADIUS_FLAG_NOIP);
    DeleteRadiusServers(m_stServerName,
                        oldServers.GetNextServer(TRUE));
    oldServers.FreeAllServers();


    LoadRadiusServers(m_stServerName,
                      hkeyMachine,
                      FALSE,
                      &oldServers,
                      RADIUS_FLAG_NOUI | RADIUS_FLAG_NOIP);
    DeleteRadiusServers(m_stServerName,
                        oldServers.GetNextServer(TRUE));


    // Save the authentication servers
    CORg( SaveRadiusServers(m_stServerName,
                            hkeyMachine,
                            TRUE,
                            pServers) );

    // Save the accounting servers
    CORg( SaveRadiusServers(m_stServerName,
                            hkeyMachine,
                            FALSE,
                            pServers) );

Error:
    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);
	m_hr = hr;
    return hr;
}



/*---------------------------------------------------------------------------
    CNewRtrWizPageBase Implementation
 ---------------------------------------------------------------------------*/

PageStack CNewRtrWizPageBase::m_pagestack;

CNewRtrWizPageBase::CNewRtrWizPageBase(UINT idd, PageType pt)
    : CPropertyPageBase(idd),
    m_pagetype(pt),
    m_pRtrWizData(NULL),
    m_uDialogId(idd)
{
}

BEGIN_MESSAGE_MAP(CNewRtrWizPageBase, CPropertyPageBase)
//{{AFX_MSG_MAP(CNewWizTestParams)
    ON_MESSAGE(WM_HELP, OnHelp)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static DWORD    s_rgBulletId[] =
{
    IDC_NEWWIZ_BULLET_1,
    IDC_NEWWIZ_BULLET_2,
    IDC_NEWWIZ_BULLET_3,
    IDC_NEWWIZ_BULLET_4,
    0
};

BOOL CNewRtrWizPageBase::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CWnd *  pWnd = GetDlgItem(IDC_NEWWIZ_BIGTEXT);
    HICON   hIcon;
    CWnd *  pBulletWnd;
    CString strFontName;
    CString strFontSize;
    BOOL    fCreateFont = FALSE;

    CPropertyPageBase::OnInitDialog();

    if (pWnd)
    {
        // Ok we have to create the font
        strFontName.LoadString(IDS_LARGEFONTNAME);
        strFontSize.LoadString(IDS_LARGEFONTSIZE);

        if (m_fontBig.CreatePointFont(10*_ttoi(strFontSize), strFontName))
        {
            pWnd->SetFont(&m_fontBig);
        }
    }

    // Set the fonts to show up as bullets
    for (int i=0; s_rgBulletId[i] != 0; i++)
    {
        pBulletWnd = GetDlgItem(s_rgBulletId[i]);
        if (pBulletWnd)
        {
            // Only create the font if needed
            if (!fCreateFont)
            {
                strFontName.LoadString(IDS_BULLETFONTNAME);
                strFontSize.LoadString(IDS_BULLETFONTSIZE);

                m_fontBullet.CreatePointFont(10*_ttoi(strFontSize), strFontName);
                fCreateFont = TRUE;
            }
            pBulletWnd->SetFont(&m_fontBullet);
        }
    }


    pWnd = GetDlgItem(IDC_NEWWIZ_ICON_WARNING);
    if (pWnd)
    {
        hIcon = AfxGetApp()->LoadStandardIcon(IDI_EXCLAMATION);
        ((CStatic *) pWnd)->SetIcon(hIcon);
    }

    pWnd = GetDlgItem(IDC_NEWWIZ_ICON_INFORMATION);
    if (pWnd)
    {
        hIcon = AfxGetApp()->LoadStandardIcon(IDI_INFORMATION);
        ((CStatic *) pWnd)->SetIcon(hIcon);
    }

    return TRUE;
}


/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::PushPage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void CNewRtrWizPageBase::PushPage(UINT idd)
{
    m_pagestack.AddHead(idd);
}

/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::PopPage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
UINT CNewRtrWizPageBase::PopPage()
{
    if (m_pagestack.IsEmpty())
        return 0;

    return m_pagestack.RemoveHead();
}


/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::OnSetActive
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizPageBase::OnSetActive()
{
    switch (m_pagetype)
    {
        case Start:
            GetHolder()->SetWizardButtonsFirst(TRUE);
            break;
        case Middle:
            GetHolder()->SetWizardButtonsMiddle(TRUE);
            break;
        default:
        case Finish:
            GetHolder()->SetWizardButtonsLast(TRUE);
            break;
    }

    return CPropertyPageBase::OnSetActive();
}

/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::OnCancel
        -
    Author: KennT
 ---------------------------------------------------------------------------*/

void CNewRtrWizPageBase::OnCancel()
{
    m_pRtrWizData->m_hr = HResultFromWin32(ERROR_CANCELLED);
}

/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::OnWizardNext
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
LRESULT CNewRtrWizPageBase::OnWizardNext()
{
    HRESULT hr = hrOK;
    LRESULT lResult;

    // Tell the page to save it's state
    m_pRtrWizData->m_hr = hr = OnSavePage();
    if (FHrSucceeded(hr))
    {
        // Now figure out where to go next
        Assert(m_pRtrWizData);
        lResult = m_pRtrWizData->GetNextPage(m_uDialogId);

        switch (lResult)
        {
            case ERR_IDD_FINISH_WIZARD:
                OnWizardFinish();

                // fall through to the cancel case

            case ERR_IDD_CANCEL_WIZARD:
				
                GetHolder()->PressButton(PSBTN_CANCEL);
				m_pRtrWizData->m_hr = HResultFromWin32(ERROR_CANCELLED);
                lResult = -1;
                break;

            default:
                // Push the page only if we are going to another page
                // The other cases will cause the wizard to exit, and
                // we don't need the page stack.
                // ----------------------------------------------------
                if (lResult != -1)
                    PushPage(m_uDialogId);
                break;
        }

        return lResult;
    }
    else
        return (LRESULT) -1;    // error! do not change the page
}

/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::OnWizardBack
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
LRESULT CNewRtrWizPageBase::OnWizardBack()
{
    Assert(!m_pagestack.IsEmpty());

    // a special case
    if(m_uDialogId == IDD_NEWRTRWIZ_USERADIUS){
	m_pRtrWizData->m_fUseRadius = FALSE;
    }

    return PopPage();
}

/*!--------------------------------------------------------------------------
    CNewRtrWizPageBase::OnWizardFinish
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizPageBase::OnWizardFinish()
{
    GetHolder()->OnFinish();
    return TRUE;
}

HRESULT CNewRtrWizPageBase::OnSavePage()
{
    return hrOK;
}

LRESULT CNewRtrWizPageBase::OnHelp(WPARAM, LPARAM lParam)
{
    HELPINFO *  pHelpInfo = (HELPINFO *) lParam;

    // Windows NT Bug : 408722
    // Put the help call here, this should only come in from
    // the call from the dialog.
    if (pHelpInfo->dwContextId == 0xdeadbeef)
    {
        HtmlHelpA(NULL, c_sazRRASDomainHelpTopic, HH_DISPLAY_TOPIC, 0);
        return TRUE;
    }
    return FALSE;
}




/*---------------------------------------------------------------------------
    CNewRtrWizFinishPageBase Implementation
 ---------------------------------------------------------------------------*/

CNewRtrWizFinishPageBase::CNewRtrWizFinishPageBase(UINT idd,
    RtrWizFinishSaveFlag SaveFlag,
    RtrWizFinishHelpFlag HelpFlag)
    : CNewRtrWizPageBase(idd, CNewRtrWizPageBase::Finish),
    m_SaveFlag(SaveFlag),
    m_HelpFlag(HelpFlag)
{
}

BEGIN_MESSAGE_MAP(CNewRtrWizFinishPageBase, CNewRtrWizPageBase)
//{{AFX_MSG_MAP(CNewWizTestParams)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


static DWORD    s_rgServerNameId[] =
{
   IDC_NEWWIZ_TEXT_SERVER_NAME,
   IDC_NEWWIZ_TEXT_SERVER_NAME_2,
   0
};

static DWORD   s_rgInterfaceId[] =
{
    IDC_NEWWIZ_TEXT_INTERFACE_1, IDS_RTRWIZ_INTERFACE_NAME_1,
    IDC_NEWWIZ_TEXT_INTERFACE_2, IDS_RTRWIZ_INTERFACE_2,
    0,0
};

/*!--------------------------------------------------------------------------
    CNewRtrWizFinishPageBase::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizFinishPageBase::OnInitDialog()
{
    CString st, stBase;

    CNewRtrWizPageBase::OnInitDialog();

    // If there is a control that wants a server name, replace it
    for (int i=0; s_rgServerNameId[i]; i++)
    {
        if (GetDlgItem(s_rgServerNameId[i]))
        {
            GetDlgItemText(s_rgServerNameId[i], stBase);
            st.Format((LPCTSTR) stBase,
                      (LPCTSTR) m_pRtrWizData->m_stServerName);
            SetDlgItemText(s_rgServerNameId[i], st);
            }
    }

    if (GetDlgItem(IDC_NEWWIZ_TEXT_ERROR))
    {
        TCHAR   szErr[2048];

        Assert(!FHrOK(m_pRtrWizData->m_hrDDError));

        FormatRasError(m_pRtrWizData->m_hrDDError, szErr, DimensionOf(szErr));

        GetDlgItemText(IDC_NEWWIZ_TEXT_ERROR, stBase);
        st.Format((LPCTSTR) stBase,
                  szErr);
        SetDlgItemText(IDC_NEWWIZ_TEXT_ERROR, (LPCTSTR) st);
    }

    return TRUE;
}


/*!--------------------------------------------------------------------------
    CNewRtrWizFinishPageBase::OnSetActive
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizFinishPageBase::OnSetActive()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    DWORD   i;
    CString st;
    CString stIfName;
    RtrWizInterface *   pRtrWizIf = NULL;


    // Handle support for displaying the interface name on the
    // finish page.  We need to do it in the OnSetActive() rather
    // than the OnInitDialog() since the interface chosen can change.

    // Try to find the inteface name
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        stIfName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        stIfName = m_pRtrWizData->m_stPublicInterfaceId;
    }
    for (i=0; s_rgInterfaceId[i] != 0; i+=2)
    {
        if (GetDlgItem(s_rgInterfaceId[i]))
        {
            st.Format(s_rgInterfaceId[i+1], (LPCTSTR) stIfName);
            SetDlgItemText(s_rgInterfaceId[i], st);
        }
    }

    return CNewRtrWizPageBase::OnSetActive();
}

/*!--------------------------------------------------------------------------
    CNewRtrWizFinishPageBase::OnWizardFinish
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizFinishPageBase::OnWizardFinish()
{
    m_pRtrWizData->m_SaveFlag = m_SaveFlag;

    // If there is a help button and it is not checked,
    // then do not bring up the help.
    if (!GetDlgItem(IDC_NEWWIZ_CHK_HELP) ||
    	(GetDlgItem(IDC_NEWWIZ_CHK_HELP) &&
        !IsDlgButtonChecked(IDC_NEWWIZ_CHK_HELP)))
        m_pRtrWizData->m_HelpFlag = HelpFlag_Nothing;
    else
        m_pRtrWizData->m_HelpFlag = m_HelpFlag;

    return CNewRtrWizPageBase::OnWizardFinish();
}

/////////////////////////////////////////////////////////////////////////////
//
// CNewRtrWiz holder
//
/////////////////////////////////////////////////////////////////////////////


CNewRtrWiz::CNewRtrWiz(
                       ITFSNode *        pNode,
                       IRouterInfo *      pRouter,
                       IComponentData *  pComponentData,
                       ITFSComponentData * pTFSCompData,
                       LPCTSTR           pszSheetName,
					   BOOL				fInvokedInMMC,
					   DWORD			dwExpressType
                      ) :
   CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    LinkWindow_RegisterClass();
    
   //ASSERT(pFolderNode == GetContainerNode());

   //if this is not done, deadlock can happen
   EnablePeekMessageDuringNotifyConsole(TRUE);

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    m_bWiz97 = TRUE;
	m_fInvokedInMMC = fInvokedInMMC;
	m_dwExpressType = dwExpressType;
    m_spRouter.Set(pRouter);
    if  ( MPRSNAP_CYS_EXPRESS_NONE != dwExpressType )
        m_bAutoDelete = FALSE;

}


CNewRtrWiz::~CNewRtrWiz()
{
    POSITION    pos;
    CNewRtrWizPageBase  *pPageBase;

    pos = m_pagelist.GetHeadPosition();
    while (pos)
    {
        pPageBase = m_pagelist.GetNext(pos);

        RemovePageFromList(static_cast<CPropertyPageBase *>(pPageBase), FALSE);
    }

    m_pagelist.RemoveAll();
}


/*!--------------------------------------------------------------------------
    CNewRtrWiz::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CNewRtrWiz::Init(LPCTSTR pServerName)
{
    HRESULT hr = hrOK;
    POSITION    pos;
    CNewRtrWizPageBase  *pPageBase;


    m_RtrWizData.Init(pServerName, m_spRouter, m_dwExpressType);
    m_RtrWizData.m_stServerName = pServerName;

    // Setup the list of pages
	//0
    m_pagelist.AddTail(&m_pageWelcome);					
	//1
    m_pagelist.AddTail(&m_pageCommonConfig);
	//2
    m_pagelist.AddTail(&m_pageNatFinishAConflict);
	//3
    m_pagelist.AddTail(&m_pageNatFinishAConflictNonLocal);
	//4
    m_pagelist.AddTail(&m_pageNatFinishNoIP);
	//5
    m_pagelist.AddTail(&m_pageNatFinishNoIPNonLocal);
	//6 
    m_pagelist.AddTail(&m_pageNatSelectPublic);
    // 7
    m_pagelist.AddTail ( &m_pageCustomConfig);
    // 8
    m_pagelist.AddTail ( &m_pageRRasVPN);
    // 9
    m_pagelist.AddTail(&m_pageNatSelectPrivate);
    m_pagelist.AddTail(&m_pageNatFinishAdvancedNoNICs);
    m_pagelist.AddTail(&m_pageNatDHCPDNS);
    m_pagelist.AddTail(&m_pageNatDHCPWarning);
    m_pagelist.AddTail(&m_pageNatDDWarning);
    m_pagelist.AddTail(&m_pageNatFinish);
    m_pagelist.AddTail(&m_pageNatFinishExternal);
    m_pagelist.AddTail(&m_pageNatFinishDDError);

    m_pagelist.AddTail(&m_pageRasFinishNeedProtocols);
    m_pagelist.AddTail(&m_pageRasFinishNeedProtocolsNonLocal);


    m_pagelist.AddTail(&m_pageRasNoNICs);
    m_pagelist.AddTail(&m_pageRasFinishNoNICs);
    m_pagelist.AddTail(&m_pageRasNetwork);

    m_pagelist.AddTail(&m_pageRasFinishAdvanced);

    m_pagelist.AddTail(&m_pageVpnFinishNoNICs);
    m_pagelist.AddTail(&m_pageVpnFinishNoIP);
    m_pagelist.AddTail(&m_pageVpnFinishNoIPNonLocal);
    m_pagelist.AddTail(&m_pageVpnFinishNeedProtocols);
    m_pagelist.AddTail(&m_pageVpnFinishNeedProtocolsNonLocal);

    m_pagelist.AddTail(&m_pageVpnSelectPublic);
    m_pagelist.AddTail(&m_pageVpnSelectPrivate);
    m_pagelist.AddTail(&m_pageVpnFinishAdvanced);
    m_pagelist.AddTail(&m_pageRASVpnFinishAdvanced);
    m_pagelist.AddTail(&m_pageNATVpnFinishAdvanced);

    m_pagelist.AddTail(&m_pageRouterFinishNeedProtocols);
    m_pagelist.AddTail(&m_pageRouterFinishNeedProtocolsNonLocal);
    m_pagelist.AddTail(&m_pageRouterUseDD);
    m_pagelist.AddTail(&m_pageRouterFinish);
    m_pagelist.AddTail(&m_pageRouterFinishDD);

    m_pagelist.AddTail(&m_pageManualFinish);
    m_pagelist.AddTail(&m_pageAddressing);
    m_pagelist.AddTail(&m_pageAddressPool);
    m_pagelist.AddTail(&m_pageRadius);
    m_pagelist.AddTail(&m_pageRadiusConfig);


    // Initialize all of the pages
    pos = m_pagelist.GetHeadPosition();
    while (pos)
    {
        pPageBase = m_pagelist.GetNext(pos);

        pPageBase->Init(&m_RtrWizData, this);
    }


    // Add all of the pages to the property sheet
    pos = m_pagelist.GetHeadPosition();
    while (pos)
    {
        pPageBase = m_pagelist.GetNext(pos);

        AddPageToList(static_cast<CPropertyPageBase *>(pPageBase));
    }

    return hr;
}
//
//This is the real Wiz97 flag.  Dont use PSH_WIZARD97.
//You'll get unpredictable results.
#define REAL_PSH_WIZARD97               0x01000000

HRESULT CNewRtrWiz::DoModalWizard()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = hrOK;
	
	if ( m_fInvokedInMMC )
	{
		return CPropertyPageHolderBase::DoModalWizard();
	}
	else
	{

		m_fSetDefaultSheetPos = NULL;
		PROPSHEETHEADER		psh;
		
		ZeroMemory ( &psh, sizeof(psh) );
		psh.dwSize = sizeof(psh);
		psh.dwFlags =	REAL_PSH_WIZARD97|
						PSH_USEHBMHEADER|
						PSH_USEHBMWATERMARK|
						PSH_WATERMARK|
						PSH_HEADER|
						PSH_NOAPPLYNOW;

		psh.hwndParent = GetActiveWindow();

		psh.hInstance = AfxGetInstanceHandle();

		psh.pszCaption = (LPCTSTR)m_stSheetTitle.GetBuffer(m_stSheetTitle.GetLength()+1);
		psh.hbmHeader = g_wmi.hHeader;
		psh.hbmWatermark = g_wmi.hWatermark;
		psh.hplWatermark = g_wmi.hPalette;
		psh.nStartPage = m_RtrWizData.GetStartPageId();
		psh.nPages = m_pageList.GetCount();
		psh.phpage = new HPROPSHEETPAGE[psh.nPages ];
		if ( NULL == psh.phpage )
		{
			m_RtrWizData.m_hr = E_OUTOFMEMORY;
			return m_RtrWizData.m_hr;
		}

		//now setup all the pages in the psh structure
		POSITION	pos;
		DWORD		dw=0;
		//For cys we do only wiz97 standard
		for( pos = m_pageList.GetHeadPosition(); pos != NULL; )
		{
			CPropertyPageBase* pPage = m_pageList.GetNext(pos);

			pPage->m_psp97.dwFlags &= ~PSP_HASHELP;

			HPROPSHEETPAGE hPage;

			hPage = ::CreatePropertySheetPage(&pPage->m_psp97);
			if (hPage == NULL)
			{
				m_RtrWizData.m_hr = E_UNEXPECTED;
				return m_RtrWizData.m_hr;
			}
			else
			{
				pPage->m_hPage = hPage;

				*(psh.phpage+dw) = hPage;
				dw++;
			}
		}

		if ( PropertySheet (&psh ) == -1 )
		{
			m_RtrWizData.m_hr = HResultFromWin32(GetLastError());
		}
				
	}
	
	return m_RtrWizData.m_hr;
}

/*!--------------------------------------------------------------------------
    CNewRtrWiz::OnFinish
        Called from the OnWizardFinish
    Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CNewRtrWiz::OnFinish()
{
    DWORD dwError = ERROR_SUCCESS;
    RtrWizInterface *   pRtrWizIf = NULL;
    TCHAR               szBuffer[1024];
    CString st;
    LPCTSTR              pszHelpString = NULL;
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;


#if defined(DEBUG) && defined(kennt)
    if (m_RtrWizData.m_SaveFlag != SaveFlag_Advanced)
        st += _T("NO configuration change required\n\n");

    // For now, just display the test parameter output
    switch (m_RtrWizData.m_wizType)
    {
        case NewRtrWizData::WizardRouterType_NAT:
            st += _T("NAT\n");
            break;
        case NewRtrWizData::WizardRouterType_RAS:
            st += _T("RAS\n");
            break;
        case NewRtrWizData::WizardRouterType_VPN:
            st += _T("VPN\n");
            break;
        case NewRtrWizData::WizardRouterType_Router:
            st += _T("Router\n");
            break;
        case NewRtrWizData::WizardRouterType_Manual:
            st += _T("Manual\n");
            break;
    }
    if (m_RtrWizData.m_fAdvanced)
        st += _T("Advanced path\n");
    else
        st += _T("Simple path\n");

    if (m_RtrWizData.m_fNeedMoreProtocols)
        st += _T("Need to install more protocols\n");

    if (m_RtrWizData.m_fCreateDD)
        st += _T("Need to create a DD interface\n");

    st += _T("Public interface : ");
    m_RtrWizData.m_ifMap.Lookup(m_RtrWizData.m_stPublicInterfaceId, pRtrWizIf);
    if (pRtrWizIf)
        st += pRtrWizIf->m_stName;
    st += _T("\n");

    st += _T("Private interface : ");
    m_RtrWizData.m_ifMap.Lookup(m_RtrWizData.m_stPrivateInterfaceId, pRtrWizIf);
    if (pRtrWizIf)
        st += pRtrWizIf->m_stName;
    st += _T("\n");

    if (m_RtrWizData.m_wizType == NewRtrWizData::WizardRouterType_NAT)
    {
        if (m_RtrWizData.m_fNatUseSimpleServers)
            st += _T("NAT - use simple DHCP and DNS\n");
        else
            st += _T("NAT - use external DHCP and DNS\n");
    }

    if (m_RtrWizData.m_fWillBeInDomain)
        st += _T("Will be in a domain\n");

    if (m_RtrWizData.m_fNoNicsAreOk)
        st += _T("No NICs is ok\n");

    if (m_RtrWizData.m_fUseIpxType20Broadcasts)
        st += _T("IPX should deliver Type20 broadcasts\n");

    if (m_RtrWizData.m_fAppletalkUseNoAuth)
        st += _T("Use unauthenticated access\n");

    if (m_RtrWizData.m_fUseDHCP)
        st += _T("Use DHCP for addressing\n");
    else
        st += _T("Use Static pools for addressing\n");

    if (m_RtrWizData.m_fUseRadius)
    {
        st += _T("Use RADIUS\n");
        st += _T("Server 1 : ");
        st += m_RtrWizData.m_stRadius1;
        st += _T("\n");
        st += _T("Server 2 : ");
        st += m_RtrWizData.m_stRadius2;
        st += _T("\n");
    }

    if (m_RtrWizData.m_fTest)
    {
        if (AfxMessageBox(st, MB_OKCANCEL) == IDCANCEL)
            return 0;
    }
#endif

    // else continue on, saving the real data

    if (m_RtrWizData.m_SaveFlag == SaveFlag_Simple)
    {
        ::ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.wShowWindow = SW_SHOW;
        ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

        ExpandEnvironmentStrings(s_szConnectionUICommandLine,
                                 szBuffer,
                                 DimensionOf(szBuffer));


        ::CreateProcess(NULL,          // ptr to name of executable
                        szBuffer,       // pointer to command line string
                        NULL,            // process security attributes
                        NULL,            // thread security attributes
                        FALSE,            // handle inheritance flag
                        CREATE_NEW_CONSOLE,// creation flags
                        NULL,            // ptr to new environment block
                        NULL,            // ptr to current directory name
                        &si,
                        &pi);
        ::CloseHandle(pi.hProcess);
        ::CloseHandle(pi.hThread);
    }
    else if (m_RtrWizData.m_SaveFlag == SaveFlag_Advanced)
    {
        // Ok, we're done!
        if (!m_RtrWizData.m_fTest)
        {
            // Get the owner window (i.e. the page)
            // --------------------------------------------------------
            HWND hWndOwner = PropSheet_GetCurrentPageHwnd(m_hSheetWindow);
            m_RtrWizData.FinishTheDamnWizard(hWndOwner, m_spRouter);
        }
    }


    if (m_RtrWizData.m_HelpFlag != HelpFlag_Nothing)
    {
        switch (m_RtrWizData.m_HelpFlag)
        {
            case HelpFlag_Nothing:
                break;
            case HelpFlag_ICS:
                pszHelpString = s_szHowToAddICS;
                break;
            case HelpFlag_AddIp:
            case HelpFlag_AddProtocol:
                pszHelpString = s_szHowToAddAProtocol;
                break;
            case HelpFlag_InboundConnections:
                pszHelpString = s_szHowToAddInboundConnections;
                break;
            case HelpFlag_GeneralNAT:
                pszHelpString = s_szGeneralNATHelp;
                break;
            case HelpFlag_GeneralRAS:
                pszHelpString = s_szGeneralRASHelp;
                break;
            case HelpFlag_UserAccounts:
                pszHelpString = s_szUserAccounts;
                break;
            case HelpFlag_DemandDial:
           	  pszHelpString = s_szDemandDialHelp;
           	  break;
            default:
                Panic0("Unknown help flag specified!");
                break;
        }

        LaunchHelpTopic(pszHelpString);
    }

    //
    //Now for a special case 
    //check to see if the dhcp help has been set.
    //if so show that help.
    //
    if ( m_RtrWizData.m_fShowDhcpHelp )
    {
        LaunchHelpTopic(s_szDhcp);
    }


    return dwError;
}



/*---------------------------------------------------------------------------
    CNewWizTestParams Implementation
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(CNewWizTestParams, CBaseDialog)
//{{AFX_MSG_MAP(CNewWizTestParams)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CNewWizTestParams::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    CheckDlgButton(IDC_NEWWIZ_TEST_LOCAL, m_pWizData->s_fIsLocalMachine);
    CheckDlgButton(IDC_NEWWIZ_TEST_USE_IP, m_pWizData->s_fIpInstalled);
    CheckDlgButton(IDC_NEWWIZ_TEST_USE_IPX, m_pWizData->s_fIpxInstalled);
    CheckDlgButton(IDC_NEWWIZ_TEST_USE_ATLK, m_pWizData->s_fAppletalkInstalled);
    CheckDlgButton(IDC_NEWWIZ_TEST_DNS, m_pWizData->s_fIsDNSRunningOnPrivateInterface);
    CheckDlgButton(IDC_NEWWIZ_TEST_DHCP, m_pWizData->s_fIsDHCPRunningOnPrivateInterface);
    CheckDlgButton(IDC_NEWWIZ_TEST_DOMAIN, m_pWizData->s_fIsMemberOfDomain);
    CheckDlgButton(IDC_NEWWIZ_TEST_SHAREDACCESS, m_pWizData->s_fIsSharedAccessRunningOnServer);

    SetDlgItemInt(IDC_NEWWIZ_TEST_EDIT_NUMNICS, m_pWizData->s_dwNumberOfNICs);

    return TRUE;
}

void CNewWizTestParams::OnOK()
{
    m_pWizData->s_fIsLocalMachine = IsDlgButtonChecked(IDC_NEWWIZ_TEST_LOCAL);
    m_pWizData->s_fIpInstalled = IsDlgButtonChecked(IDC_NEWWIZ_TEST_USE_IP);
    m_pWizData->s_fIpxInstalled = IsDlgButtonChecked(IDC_NEWWIZ_TEST_USE_IPX);
    m_pWizData->s_fAppletalkInstalled = IsDlgButtonChecked(IDC_NEWWIZ_TEST_USE_ATLK);

    m_pWizData->s_fIsDNSRunningOnPrivateInterface = IsDlgButtonChecked(IDC_NEWWIZ_TEST_DNS);
    m_pWizData->s_fIsDHCPRunningOnPrivateInterface = IsDlgButtonChecked(IDC_NEWWIZ_TEST_DHCP);
    m_pWizData->s_fIsMemberOfDomain = IsDlgButtonChecked(IDC_NEWWIZ_TEST_DOMAIN);
    m_pWizData->s_dwNumberOfNICs = GetDlgItemInt(IDC_NEWWIZ_TEST_EDIT_NUMNICS);
    m_pWizData->s_fIsSharedAccessRunningOnServer = IsDlgButtonChecked(IDC_NEWWIZ_TEST_SHAREDACCESS);

    CBaseDialog::OnOK();
}


/*---------------------------------------------------------------------------
    CNewRtrWizWelcome Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizWelcome::CNewRtrWizWelcome() :
   CNewRtrWizPageBase(CNewRtrWizWelcome::IDD, CNewRtrWizPageBase::Start)
{
    InitWiz97(TRUE, 0, 0);
}

BEGIN_MESSAGE_MAP(CNewRtrWizWelcome, CNewRtrWizPageBase)
END_MESSAGE_MAP()



/*---------------------------------------------------------------------------
    CNewRtrWizCustomConfig Implementation
 ---------------------------------------------------------------------------*/

CNewRtrWizCustomConfig::CNewRtrWizCustomConfig() :
    CNewRtrWizPageBase( CNewRtrWizCustomConfig::IDD, CNewRtrWizPageBase::Middle )
{
    InitWiz97(FALSE,
          IDS_NEWWIZ_CUSTOMCONFIG_TITLE,
          IDS_NEWWIZ_CUSTOMCONFIG_SUBTITLE);
}

BEGIN_MESSAGE_MAP(CNewRtrWizCustomConfig, CNewRtrWizPageBase)
END_MESSAGE_MAP()

BOOL CNewRtrWizCustomConfig::OnInitDialog()
{
    //
    //Based on what has already been selected by the user,
    //setup the new buttons.
    //
    if ( !m_pRtrWizData->m_dwNewRouterType )
    {
        if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT &&
             m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_BASIC_FIREWALL
           )
        {            
            CheckDlgButton ( IDC_NEWWIZ_BTN_NAT,
                              BST_CHECKED
                            );
        }
        if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
        {
            CheckDlgButton ( IDC_NEWWIZ_BTN_DIALUP_ACCESS,
                              BST_CHECKED
                            );
        }
        if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN )
        {
            CheckDlgButton ( IDC_NEWWIZ_BTN_VPN_ACCESS,
                              BST_CHECKED
                            );
        }
        if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DOD )
        {
            CheckDlgButton ( IDC_NEWWIZ_BTN_DOD,
                              BST_CHECKED
                            );
        }
        if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_LAN_ROUTING )
        {
            CheckDlgButton ( IDC_NEWWIZ_BTN_LAN_ROUTING,
                              BST_CHECKED
                            );
        }
    }
    return TRUE;
}

HRESULT CNewRtrWizCustomConfig::OnSavePage()
{
    DWORD dwNewRouterType = NEWWIZ_ROUTER_TYPE_UNKNOWN;

    //
    //Based on what the user has selected, setup 
    //the selection.
    //
    if ( IsDlgButtonChecked( IDC_NEWWIZ_BTN_NAT ) )
    {
        dwNewRouterType |= NEWWIZ_ROUTER_TYPE_NAT | NEWWIZ_ROUTER_TYPE_BASIC_FIREWALL;
    }

    if ( IsDlgButtonChecked( IDC_NEWWIZ_BTN_DIALUP_ACCESS ) )
    {
        dwNewRouterType |= NEWWIZ_ROUTER_TYPE_DIALUP;
    }

    if ( IsDlgButtonChecked( IDC_NEWWIZ_BTN_VPN_ACCESS ) )
    {
        dwNewRouterType |= NEWWIZ_ROUTER_TYPE_VPN;
    }

    if ( IsDlgButtonChecked( IDC_NEWWIZ_BTN_DOD ) )
    {
        dwNewRouterType |= NEWWIZ_ROUTER_TYPE_DOD;
    }

    if ( IsDlgButtonChecked( IDC_NEWWIZ_BTN_LAN_ROUTING ) )
    {
        dwNewRouterType |= NEWWIZ_ROUTER_TYPE_LAN_ROUTING;
    }

    //Check to see if at least one of the types is selected
    if ( NEWWIZ_ROUTER_TYPE_UNKNOWN == dwNewRouterType )
    {
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_OPTION);
        return E_FAIL;
    }
    
    m_pRtrWizData->m_dwNewRouterType = dwNewRouterType;

    return hrOK;
}

/*---------------------------------------------------------------------------
    CNewRtrWizRRasVPN Implementation
 ---------------------------------------------------------------------------*/

CNewRtrWizRRasVPN::CNewRtrWizRRasVPN() :
    CNewRtrWizPageBase( CNewRtrWizRRasVPN::IDD, CNewRtrWizPageBase::Middle )
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_RRASVPN_TITLE,
              IDS_NEWWIZ_RRASVPN_SUBTITLE);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRRasVPN, CNewRtrWizPageBase)
	ON_BN_CLICKED(IDC_NEWWIZ_BTN_VPN, OnChkBtnClicked)
	ON_BN_CLICKED(IDC_NEWWIZ_BTN_DIALUP_RAS, OnChkBtnClicked)
END_MESSAGE_MAP()

BOOL CNewRtrWizRRasVPN::OnInitDialog()
{
    DWORD dwNICs=0;
    CWnd * pVpnCheck = GetDlgItem ( IDC_NEWWIZ_BTN_VPN );
    DWORD dwRouterType = m_pRtrWizData->m_dwNewRouterType;

    if ( dwRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
    {
        CheckDlgButton( IDC_NEWWIZ_BTN_DIALUP_RAS, BST_CHECKED );
    }
    
    //Check to see if there is no NIC.  If no NIC then 
    //gray out the VPN option
    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);
    if ( dwNICs < 1 )
    {
        //
        //Gray out the VPN button since there is only
        //one NIC in the machine.
        //
        pVpnCheck->EnableWindow(FALSE);
    }
    else if ( dwRouterType & NEWWIZ_ROUTER_TYPE_VPN )
    {
        CheckDlgButton( IDC_NEWWIZ_BTN_VPN, BST_CHECKED );
    }

    return TRUE;
}

BOOL CNewRtrWizRRasVPN::OnSetActive()
{
    CWnd * pVpnCheck = GetDlgItem ( IDC_NEWWIZ_BTN_VPN );
    BOOL bRet = CNewRtrWizPageBase::OnSetActive();

    if ((pVpnCheck->IsWindowEnabled() && IsDlgButtonChecked(IDC_NEWWIZ_BTN_VPN)) || 
    	IsDlgButtonChecked(IDC_NEWWIZ_BTN_DIALUP_RAS)) {
	    	//Next button should be enabled in this case
    		GetHolder()->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
    	}
    else {
    		//Next button is disabled
		GetHolder()->SetWizardButtons(PSWIZB_BACK);
    }

    return bRet;
}

void CNewRtrWizRRasVPN::OnChkBtnClicked()
{	
    CWnd * pVpnCheck = GetDlgItem ( IDC_NEWWIZ_BTN_VPN );

    if ((pVpnCheck->IsWindowEnabled() && IsDlgButtonChecked(IDC_NEWWIZ_BTN_VPN)) || 
    	IsDlgButtonChecked(IDC_NEWWIZ_BTN_DIALUP_RAS)) {
	    	//Next button should be enabled in this case
    		GetHolder()->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
    	}
    else {
    		//Next button is disabled
		GetHolder()->SetWizardButtons(PSWIZB_BACK);
    }
}

HRESULT CNewRtrWizRRasVPN::OnSavePage()
{
    DWORD dwRouterType = NEWWIZ_ROUTER_TYPE_UNKNOWN;
    CWnd * pVpnCheck = GetDlgItem ( IDC_NEWWIZ_BTN_VPN );
    //
    //check to see which buttons are set and based on that
    //set the router type.
    //
    if ( pVpnCheck->IsWindowEnabled() && IsDlgButtonChecked(IDC_NEWWIZ_BTN_VPN) )
    {
       DWORD   dwNics = 0;
	m_pRtrWizData->GetNumberOfNICS_IP(&dwNics);
	if (dwNics <= 1)
	{
	    //Not enough for VPN standard config
	    AfxMessageBox(IDS_ERR_VPN_NO_NICS_LEFT_FOR_PRIVATE_IF);
	    return E_FAIL;
	}    	
        dwRouterType |= NEWWIZ_ROUTER_TYPE_VPN;
    }
    if ( IsDlgButtonChecked(IDC_NEWWIZ_BTN_DIALUP_RAS) )
    {
        dwRouterType |= NEWWIZ_ROUTER_TYPE_DIALUP;
    }

    if ( dwRouterType == NEWWIZ_ROUTER_TYPE_UNKNOWN )
    {
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_OPTION);
        return E_FAIL;
    }
    m_pRtrWizData->m_dwNewRouterType = dwRouterType;
    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizCommonConfig Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizCommonConfig::CNewRtrWizCommonConfig() :
   CNewRtrWizPageBase(CNewRtrWizCommonConfig::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_COMMONCONFIG_TITLE,
              IDS_NEWWIZ_COMMONCONFIG_SUBTITLE);
}

BEGIN_MESSAGE_MAP(CNewRtrWizCommonConfig, CNewRtrWizPageBase)
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizCommonConfig::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizCommonConfig::OnHelpClick )
END_MESSAGE_MAP()

// This list of IDs will have their controls made bold.
const DWORD s_rgCommonConfigOptionIds[] =
{
    IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN,
    IDC_NEWWIZ_CONFIG_BTN_NAT1,
    IDC_NEWWIZ_CONFIG_BTN_VPNNAT,
    IDC_NEWWIZ_CONFIG_BTN_DOD,
    IDC_NEWWIZ_CONFIG_BTN_CUSTOM,
    0
};

void CNewRtrWizCommonConfig::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/ras_common_configuration.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}


BOOL CNewRtrWizCommonConfig::OnInitDialog()
{
    Assert(m_pRtrWizData);
    UINT    idSelection;
    LOGFONT LogFont;
    CFont * pOldFont;

    CNewRtrWizPageBase::OnInitDialog();
#if 0
    //No need to bold the font in this new wizard.
    // Create a bold text font for the options
    pOldFont = GetDlgItem(s_rgCommonConfigOptionIds[0])->GetFont();
    pOldFont->GetLogFont(&LogFont);
    LogFont.lfWeight = 700;         // make this a bold font
    m_boldFont.CreateFontIndirect(&LogFont);

    // Set all of the options to use the bold font
    for (int i=0; s_rgCommonConfigOptionIds[i]; i++)
    {
        GetDlgItem(s_rgCommonConfigOptionIds[i])->SetFont(&m_boldFont);
    }
#endif
    
    switch (m_pRtrWizData->m_wizType)
    {
        case NewRtrWizData::NewWizardRouterType_DialupOrVPN:
            idSelection = IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN;
            break;
        case NewRtrWizData::NewWizardRouterType_NAT:
            idSelection = IDC_NEWWIZ_CONFIG_BTN_NAT1;
            break;
        case NewRtrWizData::NewWizardRouterType_VPNandNAT:
            idSelection = IDC_NEWWIZ_CONFIG_BTN_VPNNAT;
            break;
        case NewRtrWizData::NewWizardRouterType_DOD:
            idSelection = IDC_NEWWIZ_CONFIG_BTN_DOD;
            break;
        case NewRtrWizData::NewWizardRouterType_Custom:
            idSelection = IDC_NEWWIZ_CONFIG_BTN_CUSTOM;
            break;
        default:
            Panic1("Unknown Wizard Router Type : %d",
                   m_pRtrWizData->m_wizType);
            idSelection = IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN;
            break;
    }

    CheckRadioButton(IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN,
                     IDC_NEWWIZ_CONFIG_BTN_CUSTOM,
                     idSelection);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}



HRESULT CNewRtrWizCommonConfig::OnSavePage()
{
     // Record the change
    
    if (IsDlgButtonChecked(IDC_NEWWIZ_CONFIG_BTN_RAS_DIALUP_VPN))
    {
        m_pRtrWizData->m_wizType = NewRtrWizData::NewWizardRouterType_DialupOrVPN;
        //Dont know yet what the router type is
    }
    else if (IsDlgButtonChecked(IDC_NEWWIZ_CONFIG_BTN_NAT1))
    {
        m_pRtrWizData->m_wizType = NewRtrWizData::NewWizardRouterType_NAT;
        m_pRtrWizData->m_dwNewRouterType = NEWWIZ_ROUTER_TYPE_NAT;
    }
    else if (IsDlgButtonChecked(IDC_NEWWIZ_CONFIG_BTN_VPNNAT))
    {
       DWORD   dwNics = 0;
	m_pRtrWizData->GetNumberOfNICS_IP(&dwNics);
	if (dwNics <= 1)
	{
	    //Not enough for VPN standard config
	    AfxMessageBox(IDS_ERR_VPN_NO_NICS_LEFT_FOR_PRIVATE_IF);
	    return E_FAIL;
	}
	m_pRtrWizData->m_wizType = NewRtrWizData::NewWizardRouterType_VPNandNAT;
	m_pRtrWizData->m_dwNewRouterType = NEWWIZ_ROUTER_TYPE_NAT|NEWWIZ_ROUTER_TYPE_VPN;
    }
    else if (IsDlgButtonChecked(IDC_NEWWIZ_CONFIG_BTN_DOD))
    {
        m_pRtrWizData->m_wizType = NewRtrWizData::NewWizardRouterType_DOD;
        m_pRtrWizData->m_dwNewRouterType = NEWWIZ_ROUTER_TYPE_DOD;
    }
    else
    {
        //
        //Router type is still unknown here. next property page will tell
        //what should be the actual type.
        //
        Assert(IsDlgButtonChecked(IDC_NEWWIZ_CONFIG_BTN_CUSTOM));
        m_pRtrWizData->m_wizType = NewRtrWizData::NewWizardRouterType_Custom;
    }

    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishAConflict Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAConflict,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishAConflictNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAConflictNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishNoIP Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishNoIP,
                                SaveFlag_DoNothing,
                                HelpFlag_AddIp);


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishNoIPNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishNoIPNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);



/*---------------------------------------------------------------------------
    CNewRtrWizNatSelectPublic implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizNatSelectPublic::CNewRtrWizNatSelectPublic() :
   CNewRtrWizPageBase(CNewRtrWizNatSelectPublic::IDD, CNewRtrWizPageBase::Middle)
{
    
    InitWiz97(FALSE,
              IDS_NEWWIZ_NAT_A_PUBLIC_TITLE,
              IDS_NEWWIZ_NAT_A_PUBLIC_SUBTITLE);
}


void CNewRtrWizNatSelectPublic::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);

}

BEGIN_MESSAGE_MAP(CNewRtrWizNatSelectPublic, CNewRtrWizPageBase)
    ON_BN_CLICKED(IDC_NEWWIZ_BTN_NEW, OnBtnClicked)
    ON_BN_CLICKED(IDC_NEWWIZ_BTN_EXISTING, OnBtnClicked) 
    ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizNatSelectPublic::OnHelpClick )
    ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizNatSelectPublic::OnHelpClick )
END_MESSAGE_MAP()

void CNewRtrWizNatSelectPublic::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/mpr_und_interfaces.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizNatSelectPublic::OnSetActive()
{
	//Need a generic way of finding out if 
	//this is the start page or not.  But for now
	//just use the hard coded value
	//$TODO: Need to find a generic way of doing this.
	if ( m_pRtrWizData->m_dwExpressType == MPRSNAP_CYS_EXPRESS_NAT )
		m_pagetype = CNewRtrWizPageBase::Start;
	return CNewRtrWizPageBase::OnSetActive();
}
/*!--------------------------------------------------------------------------
    CNewRtrWizNatSelectPublic::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizNatSelectPublic::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DWORD   dwNICs;
    UINT    uSelection;

    CNewRtrWizPageBase::OnInitDialog();

    // Setup the dialog and add the NICs
    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);
	//::PostMessage( ::GetParent(m_hWnd), PSM_SETWIZBUTTONS, 0 , PSWIZB_NEXT);
    if (dwNICs == 0)
    {
        // Have to use new, there is no other choice.
        CheckRadioButton(IDC_NEWWIZ_BTN_NEW, IDC_NEWWIZ_BTN_EXISTING,
                         IDC_NEWWIZ_BTN_NEW);

        // There are no NICs, so just disable the entire listbox
        MultiEnableWindow(GetSafeHwnd(),
                          FALSE,
                          IDC_NEWWIZ_LIST,
                          IDC_NEWWIZ_BTN_EXISTING,
                          0);
    }
    else if (dwNICs == 1)
    {
        // Have to use new, there is no other choice because the single 
        // available interface can't be both the public and the private.
        CheckRadioButton(IDC_NEWWIZ_BTN_NEW, IDC_NEWWIZ_BTN_EXISTING,
                         IDC_NEWWIZ_BTN_NEW);


        InitializeInterfaceListControl(NULL,
                                       &m_listCtrl,
                                       NULL,
                                       0,
                                       m_pRtrWizData);
        RefreshInterfaceListControl(NULL,
                                    &m_listCtrl,
                                    NULL,
                                    0,
                                    m_pRtrWizData);

        // disable the  listbox
        MultiEnableWindow(GetSafeHwnd(),
                          FALSE,
                          IDC_NEWWIZ_LIST,
                          IDC_NEWWIZ_BTN_EXISTING,
                          0);
        
    }
    else
    {
        // The default is to use an existing connection.
        CheckRadioButton(IDC_NEWWIZ_BTN_NEW, IDC_NEWWIZ_BTN_EXISTING,
                         IDC_NEWWIZ_BTN_EXISTING);


        InitializeInterfaceListControl(NULL,
                                       &m_listCtrl,
                                       NULL,
                                       0,
                                       m_pRtrWizData);
        RefreshInterfaceListControl(NULL,
                                    &m_listCtrl,
                                    NULL,
                                    0,
                                    m_pRtrWizData);
        

      OnBtnClicked();
    }

    if ( m_pRtrWizData->m_fNATEnableFireWall < 0 )
    {
        //
        //This is the first time that this dialog has 
        //been entered.  So check the box and set 
        //the flag        
        m_pRtrWizData->m_fNATEnableFireWall = TRUE;

    }

    if (m_pRtrWizData->m_fNATEnableFireWall == TRUE)
        CheckDlgButton(IDC_CHK_BASIC_FIREWALL, TRUE);
    else
        CheckDlgButton(IDC_CHK_BASIC_FIREWALL, FALSE);

    return TRUE;
}

HRESULT CNewRtrWizNatSelectPublic::OnSavePage()
{
    if (IsDlgButtonChecked(IDC_NEWWIZ_BTN_NEW))
    {
        m_pRtrWizData->m_fCreateDD = TRUE;
        m_pRtrWizData->m_stPublicInterfaceId.Empty();
    }
    else
    {
        INT     iSel;

        // Check to see that we actually selected an item
        iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
        if (iSel == -1)
        {
            // We did not select an item
            AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_INTERFACE);
			//This is not an error that we would return to user
            return E_FAIL;
        }
        m_pRtrWizData->m_fCreateDD = FALSE;

        m_pRtrWizData->m_stPublicInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);

    }
    if ( IsDlgButtonChecked(IDC_CHK_BASIC_FIREWALL) )
        m_pRtrWizData->m_fNATEnableFireWall = TRUE;
    else
        m_pRtrWizData->m_fNATEnableFireWall = FALSE;


    return hrOK;
}

void CNewRtrWizNatSelectPublic::OnBtnClicked()
{
    int     iSel = 0;
    DWORD status;
    MIB_IFROW ifRow;
    CString stRouter;
    ULONG index;
    HANDLE  mprConfig;
    WCHAR  guidName[64] = L"\\DEVICE\\TCPIP_";

    MultiEnableWindow(GetSafeHwnd(),
                      IsDlgButtonChecked(IDC_NEWWIZ_BTN_EXISTING),
                      IDC_NEWWIZ_LIST,
                      0);

    // If use an existing button is checked,
    // auto-select the interface that is enabled and plugged.
    if (IsDlgButtonChecked(IDC_NEWWIZ_BTN_EXISTING)) {
         //Get name of machine if local.
       stRouter = m_pRtrWizData->m_stServerName;
       if (stRouter.GetLength() == 0)
       {
		stRouter = CString(_T("\\\\")) + GetLocalMachineName();
       }

	   status = MprConfigServerConnect((LPWSTR)(LPCTSTR)stRouter, &mprConfig );
       if ( status == NO_ERROR ) {
		  //Check each interface, looking for a plugged, enabled interface
		 for (int i=0;i < m_listCtrl.GetItemCount();i++)
	 	{
	 		//Get guid from friendly name
		        status = MprConfigGetGuidName(mprConfig, (PWCHAR)(LPCTSTR)m_listCtrl.GetItemText(i, IFLISTCOL_NAME), &guidName[14], sizeof(guidName ));
		        if (status != NO_ERROR ) {
		        	continue;
		        }
		        status = GetAdapterIndex( guidName, &index );
		        if ( status != NO_ERROR ) {
		        	continue;
		        }
			//Now get info abt the Interface
			ifRow.dwIndex = index;
			status = GetIfEntry(&ifRow);
			if(status != NO_ERROR){
				continue;
			}
			if((ifRow.dwAdminStatus == TRUE) && (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_NON_OPERATIONAL) 
				&& (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_UNREACHABLE)  && (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_DISCONNECTED)) {
				//Found the default
				iSel = i;
				break;
			}
		 }
       }

      m_listCtrl.SetItemState(iSel, LVIS_SELECTED, LVIS_SELECTED ); 
    }

}


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishAdvancedNoNICs
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizNatFinishAdvancedNoNICs,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);


/*---------------------------------------------------------------------------
    CNewRtrWizNatSelectPrivate
 ---------------------------------------------------------------------------*/
CNewRtrWizNatSelectPrivate::CNewRtrWizNatSelectPrivate() :
   CNewRtrWizPageBase(CNewRtrWizNatSelectPrivate::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_NAT_A_PRIVATE_TITLE,
              IDS_NEWWIZ_NAT_A_PRIVATE_SUBTITLE);
}


void CNewRtrWizNatSelectPrivate::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);

}

BEGIN_MESSAGE_MAP(CNewRtrWizNatSelectPrivate, CNewRtrWizPageBase)
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizNatSelectPrivate::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizNatSelectPrivate::OnHelpClick )
END_MESSAGE_MAP()

void CNewRtrWizNatSelectPrivate::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "dhcpconcepts.chm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}


/*!--------------------------------------------------------------------------
    CNewRtrWizNatSelectPrivate::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizNatSelectPrivate::OnInitDialog()
{
    DWORD   dwNICs;

    CNewRtrWizPageBase::OnInitDialog();

    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);

    InitializeInterfaceListControl(NULL,
                                   &m_listCtrl,
                                   NULL,
                                   0,
                                   m_pRtrWizData);
    return TRUE;
}

BOOL CNewRtrWizNatSelectPrivate::OnSetActive()
{
    DWORD   dwNICs;
    int     iSel = 0;
    DWORD dwErr, status;
    MIB_IFROW ifRow;
    CString stRouter;
    CString stPreviousId;
    ULONG index;
    HANDLE  mprConfig;
    WCHAR  guidName[64] = L"\\DEVICE\\TCPIP_";

    CNewRtrWizPageBase::OnSetActive();

    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);

    RefreshInterfaceListControl(NULL,
                                &m_listCtrl,
                                (LPCTSTR) m_pRtrWizData->m_stPublicInterfaceId,
                                0,
                                m_pRtrWizData);


    // Try to reselect the previously selected NIC
    if (m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT)
    {
        // If this page has come up as a part of VPN and NAT wizard, then we 
        // should see if NAT private interface selection has been made. 
        // If yes, use that
        // If not then default to the VPN private interface
        if ( !m_pRtrWizData->m_stNATPrivateInterfaceId.IsEmpty() )
        {
            stPreviousId = m_pRtrWizData->m_stNATPrivateInterfaceId;
        }
        else if ( !m_pRtrWizData->m_stPrivateInterfaceId.IsEmpty() )
        {
            stPreviousId = m_pRtrWizData->m_stPrivateInterfaceId;
        }
    }
    else
    {
        if ( !m_pRtrWizData->m_stPrivateInterfaceId.IsEmpty() )
        {
            stPreviousId = m_pRtrWizData->m_stPrivateInterfaceId;
        }
    }
        
    if (!stPreviousId.IsEmpty())
    {
        CString data;

        for (int i=0;i < m_listCtrl.GetItemCount();i++)
        {
            data = (LPCTSTR) m_listCtrl.GetItemData(i);
            if(data == stPreviousId) {
                iSel = i;
                break;
            }
        }


        /*
        LV_FINDINFO lvfi;

        lvfi.flags = LVFI_STRING;
        lvfi.psz = (LPCTSTR) m_pRtrWizData->m_stPrivateInterfaceId;
        iSel = m_listCtrl.FindItem(&lvfi, -1);
        if (iSel == -1)
            iSel = 0;
            */
    }
    else {
        // Make an interface that is not disabled or unplugged as default-selected.
 
        // Get name of machine if local.
        stRouter = m_pRtrWizData->m_stServerName;
        if (stRouter.GetLength() == 0)
        {
            stRouter = CString(_T("\\\\")) + GetLocalMachineName();
        }

        status = MprConfigServerConnect((LPWSTR)(LPCTSTR)stRouter, &mprConfig );
        if ( status == NO_ERROR ) 
        {
            //Check each interface, looking for a plugged, enabled interface
            for (int i=0;i < m_listCtrl.GetItemCount();i++)
            {
                //Get guid from friendly name
                status = MprConfigGetGuidName(mprConfig, (PWCHAR)(LPCTSTR)m_listCtrl.GetItemText(i, IFLISTCOL_NAME), &guidName[14], sizeof(guidName ));
                if (status != NO_ERROR ) 
                {
                    continue;
                }
                status = GetAdapterIndex( guidName, &index );
                if ( status != NO_ERROR ) 
                {
                    continue;
                }
                
                //Now get info abt the Interface
                ifRow.dwIndex = index;
                status = GetIfEntry(&ifRow);
                if(status != NO_ERROR)
                {
                    continue;
                }
                if((ifRow.dwAdminStatus == TRUE) && (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_NON_OPERATIONAL) 
                && (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_UNREACHABLE)  && (ifRow.dwOperStatus != MIB_IF_OPER_STATUS_DISCONNECTED)) 
                {
                    //Found the default
                    iSel = i;
                    break;
                }
            }
        }
    }

    m_listCtrl.SetItemState(iSel, LVIS_SELECTED, LVIS_SELECTED );
//    CheckDlgButton( IDC_CHK_DHCP_HELP,  m_pRtrWizData->m_fShowDhcpHelp );

    return TRUE;
}

HRESULT CNewRtrWizNatSelectPrivate::OnSavePage()
{
    INT     iSel;

    // Check to see that we actually selected an item
    iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iSel == -1)
    {
        // We did not select an item
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_INTERFACE);

        //this is not an error we send back to the client
        return E_FAIL;
    }

    if ( m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT)
        m_pRtrWizData->m_stNATPrivateInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);
    else
        m_pRtrWizData->m_stPrivateInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);

//    m_pRtrWizData->m_fShowDhcpHelp = IsDlgButtonChecked( IDC_CHK_DHCP_HELP );
    return hrOK;
}



/*---------------------------------------------------------------------------
    CNewRtrWizNatDHCPDNS
 ---------------------------------------------------------------------------*/
CNewRtrWizNatDHCPDNS::CNewRtrWizNatDHCPDNS() :
   CNewRtrWizPageBase(CNewRtrWizNatDHCPDNS::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_NAT_A_DHCPDNS_TITLE,
              IDS_NEWWIZ_NAT_A_DHCPDNS_SUBTITLE);
}


BEGIN_MESSAGE_MAP(CNewRtrWizNatDHCPDNS, CNewRtrWizPageBase)
END_MESSAGE_MAP()


BOOL CNewRtrWizNatDHCPDNS::OnInitDialog()
{
    CheckRadioButton(IDC_NEWWIZ_NAT_USE_SIMPLE,
                     IDC_NEWWIZ_NAT_USE_EXTERNAL,
                     m_pRtrWizData->m_fNatUseSimpleServers ? IDC_NEWWIZ_NAT_USE_SIMPLE : IDC_NEWWIZ_NAT_USE_EXTERNAL);
    return TRUE;
}

HRESULT CNewRtrWizNatDHCPDNS::OnSavePage()
{
    m_pRtrWizData->m_fNatUseSimpleServers = IsDlgButtonChecked(IDC_NEWWIZ_NAT_USE_SIMPLE);
    if ( !m_pRtrWizData->m_fNatUseSimpleServers ) 
        m_pRtrWizData->m_fNatUseExternal = TRUE;
    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizNatDHCPWarning
 ---------------------------------------------------------------------------*/
CNewRtrWizNatDHCPWarning::CNewRtrWizNatDHCPWarning() :
   CNewRtrWizPageBase(CNewRtrWizNatDHCPWarning::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_NAT_A_DHCP_WARNING_TITLE,
              IDS_NEWWIZ_NAT_A_DHCP_WARNING_SUBTITLE);
}


BEGIN_MESSAGE_MAP(CNewRtrWizNatDHCPWarning, CNewRtrWizPageBase)
END_MESSAGE_MAP()


BOOL CNewRtrWizNatDHCPWarning::OnSetActive()
{
    CNewRtrWizPageBase::OnSetActive();
    RtrWizInterface *   pRtrWizIf = NULL;

    // Get the information for the private interface

    // If we are in "VPN and NAT" wizard, use m_stNATPrivateInterfaceId
    // else use the m_stPrivateInterfaceId
    if (m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT)
    {
        m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stNATPrivateInterfaceId,
                                      pRtrWizIf);
    }
    else
    {
        m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                      pRtrWizIf);
    }
    
    if (pRtrWizIf)
    {
        DWORD   netAddress, netMask;
        CString st;

        // We have to calculate the beginning of the subnet
        netAddress = INET_ADDR(pRtrWizIf->m_stIpAddress);
        netMask = INET_ADDR(pRtrWizIf->m_stMask);

        netAddress = netAddress & netMask;

        st = INET_NTOA(netAddress);

        // Now write out the subnet information for the page
        SetDlgItemText(IDC_NEWWIZ_TEXT_SUBNET, st);
        SetDlgItemText(IDC_NEWWIZ_TEXT_MASK, pRtrWizIf->m_stMask);
    }
    else
    {
        // An error! we do not have a private interface
        // Just leave things blank
        SetDlgItemText(IDC_NEWWIZ_TEXT_SUBNET, _T(""));
        SetDlgItemText(IDC_NEWWIZ_TEXT_MASK, _T(""));
    }

    return TRUE;
}

/*---------------------------------------------------------------------------
    CNewRtrWizNatDDWarning
 ---------------------------------------------------------------------------*/
CNewRtrWizNatDDWarning::CNewRtrWizNatDDWarning() :
   CNewRtrWizPageBase(CNewRtrWizNatDDWarning::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_NAT_A_DD_WARNING_TITLE,
              IDS_NEWWIZ_NAT_A_DD_WARNING_SUBTITLE);
}


BEGIN_MESSAGE_MAP(CNewRtrWizNatDDWarning, CNewRtrWizPageBase)
END_MESSAGE_MAP()


BOOL CNewRtrWizNatDDWarning::OnSetActive()
{
    CNewRtrWizPageBase::OnSetActive();

    // If we came back here from the DD error page, then
    // we don't allow them to go anywhere else.
    if (!FHrOK(m_pRtrWizData->m_hrDDError))
    {
        CancelToClose();
        GetHolder()->SetWizardButtons(PSWIZB_NEXT);
    }

    return TRUE;
}


HRESULT CNewRtrWizNatDDWarning::OnSavePage()
{
    HRESULT     hr = hrOK;
    BOOL        fDhcpHelp = m_pRtrWizData->m_fShowDhcpHelp;


    CWaitCursor wait;

    if (m_pRtrWizData->m_fTest)
        return hr;
    
    m_pRtrWizData->m_fShowDhcpHelp = FALSE;
    //Save the Dhcp Flag in a temp va

    // Save the wizard data, the service will be started
    OnWizardFinish();

    // Ok, at this point, all of the changes have been committed
    // so we can't go away or go back
    CancelToClose();
    GetHolder()->SetWizardButtons(PSWIZB_NEXT);

    // Start the DD wizard
    Assert(m_pRtrWizData->m_fCreateDD);

    hr = CallRouterEntryDlg(GetSafeHwnd(),
                            m_pRtrWizData,
                            RASEDFLAG_NAT);

    // We need to force the RouterInfo to reload it's information
    // ----------------------------------------------------------------
    if (m_pRtrWiz && m_pRtrWiz->m_spRouter)
    {
        m_pRtrWiz->m_spRouter->DoDisconnect();
        m_pRtrWiz->m_spRouter->Unload();
        m_pRtrWiz->m_spRouter->Load(m_pRtrWiz->m_spRouter->GetMachineName(), NULL);
    }

    if (FHrSucceeded(hr))
    {
        // If we're setting up NAT, we can now add IGMP/NAT because
        // the dd interface will have been created.
        // ----------------------------------------------------------------
        if (m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT )
        {
            // Setup the data structure for the next couple of functions
            m_pRtrWizData->m_RtrConfigData.m_ipData.m_stPrivateAdapterGUID = m_pRtrWizData->m_stPrivateInterfaceId;
            m_pRtrWizData->m_RtrConfigData.m_ipData.m_stPublicAdapterGUID = m_pRtrWizData->m_stPublicInterfaceId;

            AddIGMPToNATServer(m_pRtrWizData, &m_pRtrWizData->m_RtrConfigData, 
                                m_pRtrWiz->m_spRouter, 
                                ( m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT));
            AddNATToServer(m_pRtrWizData, &m_pRtrWizData->m_RtrConfigData, m_pRtrWiz->m_spRouter, m_pRtrWizData->m_fCreateDD, FALSE);
        }

    }
    else {
	//Disable RRAS
	DisableRRAS((TCHAR *)(LPCTSTR)m_pRtrWizData->m_stServerName);
    }

    m_pRtrWizData->m_fShowDhcpHelp = fDhcpHelp;

    m_pRtrWizData->m_hrDDError = hr;

    // Ignore the error, always go on to the next page
    return hrOK;
}



/*---------------------------------------------------------------------------
    CNewRtrWizNatFinish
 ---------------------------------------------------------------------------*/
CNewRtrWizNatFinish::CNewRtrWizNatFinish() :
   CNewRtrWizFinishPageBase(CNewRtrWizNatFinish::IDD, SaveFlag_Advanced, HelpFlag_GeneralNAT)
{
    InitWiz97(TRUE, 0, 0);
}

BEGIN_MESSAGE_MAP(CNewRtrWizNatFinish, CNewRtrWizFinishPageBase)
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizNatFinish::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizNatFinish::OnHelpClick )
END_MESSAGE_MAP()

void CNewRtrWizNatFinish::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch3_06b.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizNatFinish::OnSetActive()
{
    CNewRtrWizFinishPageBase::OnSetActive();
    RtrWizInterface *   pRtrWizIf = NULL;
    CString sFormat;
    CString sText;
    CString sPublicInterfaceName;
    CString sFirewall;

    CNewRtrWizFinishPageBase::OnSetActive();
    // If we just got here because we created a DD interface
    // we can't go back.
    if (m_pRtrWizData->m_fCreateDD)
    {
        CancelToClose();
        GetHolder()->SetWizardButtons(PSWIZB_FINISH);
    }

    //Setup the text that goes in the summary box
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPublicInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPublicInterfaceName = m_pRtrWizData->m_stPublicInterfaceId;
    }


    CString sIPAddr;
    CString sIPMask;
    // Get the information for the private interface
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
    {
        DWORD   netAddress, netMask;
        CString st;

        // We have to calculate the beginning of the subnet
        netAddress = INET_ADDR(pRtrWizIf->m_stIpAddress);
        netMask = INET_ADDR(pRtrWizIf->m_stMask);

        netAddress = netAddress & netMask;

        sIPAddr = INET_NTOA(netAddress);
        sIPMask = pRtrWizIf->m_stMask;
    }
    else
    {
        // An error! we do not have a private interface
        // Just leave things blank
        sIPAddr = L"192.168.0.0";
        sIPMask = L"255.255.0.0";
    }
/*
    if ( m_pRtrWizData->m_fNatUseExternal )
    {
        sFormat.LoadString(IDS_NAT_A_FINISH_SUMMARY_SIMPLE);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );

    }
    else
    {
*/
    sFirewall.LoadString(IDS_NAT_SUMMARY_BASIC_FIREWALL);

     if ( m_pRtrWizData->m_dwExpressType == MPRSNAP_CYS_EXPRESS_NAT )
    {
        sFormat.LoadString(IDS_NAT_EXTERNAL_FINISH_SUMMARY_CYS);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );
    }
    else {
        sFormat.LoadString(IDS_NAT_A_FINISH_SUMMARY);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName, sIPAddr, sIPMask );
    }

    SetDlgItemText(IDC_TXT_NAT_SUMMARY, sText);

//    GetDlgItem(IDC_NEWWIZ_CHK_HELP)->SetFocus();
    SetFocus();
    
    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizNatFinishExternal
 ---------------------------------------------------------------------------*/
CNewRtrWizNatFinishExternal::CNewRtrWizNatFinishExternal() :
   CNewRtrWizFinishPageBase(CNewRtrWizNatFinishExternal::IDD, SaveFlag_Advanced, HelpFlag_GeneralNAT)
{
    InitWiz97(TRUE, 0, 0);
}

BEGIN_MESSAGE_MAP(CNewRtrWizNatFinishExternal, CNewRtrWizFinishPageBase)
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizNatFinishExternal::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizNatFinishExternal::OnHelpClick )
END_MESSAGE_MAP()

void CNewRtrWizNatFinishExternal::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch3_06b.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizNatFinishExternal::OnSetActive()
{
    CNewRtrWizFinishPageBase::OnSetActive();
    RtrWizInterface *   pRtrWizIf = NULL;
    CString sFormat;
    CString sText;
    CString sPublicInterfaceName;
    CString sFirewall;

    CNewRtrWizFinishPageBase::OnSetActive();
    // If we just got here because we created a DD interface
    // we can't go back.
    if (m_pRtrWizData->m_fCreateDD)
    {
        CancelToClose();
        GetHolder()->SetWizardButtons(PSWIZB_FINISH);
    }
    
    //Setup the text that goes in the summary box
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPublicInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPublicInterfaceName = m_pRtrWizData->m_stPublicInterfaceId;
    }

    sFirewall.LoadString(IDS_NAT_SUMMARY_BASIC_FIREWALL);

    if ( m_pRtrWizData->m_dwExpressType == MPRSNAP_CYS_EXPRESS_NAT )
    {
        sFormat.LoadString(IDS_NAT_EXTERNAL_FINISH_SUMMARY_CYS);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );

    }
    else if ( m_pRtrWizData->m_fNatUseExternal )
    {
        sFormat.LoadString(IDS_NAT_A_FINISH_SUMMARY_SIMPLE);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );

    }
    else if (FHrOK(m_pRtrWizData->HrIsDHCPRunningOnInterface()) ||
             FHrOK(m_pRtrWizData->HrIsDNSRunningOnInterface())
            )
    {
        //
        //Dhcp enabled on private interface.  
        //
        sFormat.LoadString(IDS_NAT_EXTERNAL_FINISH_SUMMARY_DHCP_PRIVATE);
        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );

    }
    else
    {


        sFormat.LoadString(IDS_NAT_EXTERNAL_FINISH_SUMMARY);

        sText.Format(sFormat, 
            (m_pRtrWizData->m_fNATEnableFireWall?sFirewall:""),
                        sPublicInterfaceName );


    }

    SetDlgItemText(IDC_TXT_NAT_EXTERNAL_FINISH_SUMMARY, sText);

  //  GetDlgItem(IDC_NEWWIZ_CHK_HELP)->SetFocus();
  SetFocus();
    

    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizNatDDError
 ---------------------------------------------------------------------------*/

CNewRtrWizNatFinishDDError::CNewRtrWizNatFinishDDError() :
   CNewRtrWizFinishPageBase(CNewRtrWizNatFinishDDError::IDD, SaveFlag_DoNothing, HelpFlag_Nothing)
{
    InitWiz97(TRUE, 0, 0);
}

BEGIN_MESSAGE_MAP(CNewRtrWizNatFinishDDError, CNewRtrWizFinishPageBase)
END_MESSAGE_MAP()

BOOL CNewRtrWizNatFinishDDError::OnInitDialog()
{
	CFont font;
	CWnd * wnd;
	
	CNewRtrWizFinishPageBase::OnInitDialog();

	font.CreatePointFont( 120, TEXT("Verdana Bold"), NULL);

	if(wnd = GetDlgItem(IDC_COMPLETE_ERROR)){
		wnd->SetFont(&font);
	}

	return TRUE;
}

BOOL CNewRtrWizNatFinishDDError::OnSetActive()
{
     CNewRtrWizFinishPageBase::OnSetActive();
     GetHolder()->SetWizardButtons(PSWIZB_FINISH);

     return TRUE;
}

/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishNeedProtocols Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNeedProtocols,
                                SaveFlag_DoNothing,
                                HelpFlag_AddProtocol);

/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishNeedProtocolsNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNeedProtocolsNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);



/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNeedProtocols Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNeedProtocols,
                                SaveFlag_DoNothing,
                                HelpFlag_AddProtocol);

/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNeedProtocolsNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNeedProtocolsNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);

/*---------------------------------------------------------------------------
    CNewRtrWizRouterFinishNeedProtocols Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRouterFinishNeedProtocols,
                                SaveFlag_DoNothing,
                                HelpFlag_AddProtocol);

/*---------------------------------------------------------------------------
    CNewRtrWizRouterFinishNeedProtocolsNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRouterFinishNeedProtocolsNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);



/*---------------------------------------------------------------------------
    CNewRtrWizSelectNetwork implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizSelectNetwork::CNewRtrWizSelectNetwork(UINT uDialogId) :
   CNewRtrWizPageBase(uDialogId, CNewRtrWizPageBase::Middle)
{
}


void CNewRtrWizSelectNetwork::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);
}

BEGIN_MESSAGE_MAP(CNewRtrWizSelectNetwork, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizSelectNetwork::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizSelectNetwork::OnInitDialog()
{
//    DWORD   dwNICs;

    CNewRtrWizPageBase::OnInitDialog();

//    m_pRtrWizData->GetNumberOfNICS(&dwNICs);

    InitializeInterfaceListControl(NULL,
                                   &m_listCtrl,
                                   NULL,
                                   0,
                                   m_pRtrWizData);
    RefreshInterfaceListControl(NULL,
                                &m_listCtrl,
                                NULL,
                                0,
                                m_pRtrWizData);

    m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED );

    return TRUE;
}

HRESULT CNewRtrWizSelectNetwork::OnSavePage()
{
    INT     iSel;

    // Check to see that we actually selected an item
    iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iSel == -1)
    {
        // We did not select an item
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_INTERFACE);
        return E_FAIL;
    }
    m_pRtrWizData->m_fCreateDD = FALSE;

    m_pRtrWizData->m_stPrivateInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CNewRtrWizRasSelectNetwork implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRasSelectNetwork::CNewRtrWizRasSelectNetwork() :
   CNewRtrWizSelectNetwork(CNewRtrWizRasSelectNetwork::IDD)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_RAS_A_SELECT_NETWORK_TITLE,
              IDS_NEWWIZ_RAS_A_SELECT_NETWORK_SUBTITLE);
}


/*---------------------------------------------------------------------------
    CNewRtrWizRasNoNICs implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRasNoNICs::CNewRtrWizRasNoNICs() :
   CNewRtrWizPageBase(CNewRtrWizRasNoNICs::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_RAS_NONICS_TITLE,
              IDS_NEWWIZ_RAS_NONICS_SUBTITLE);
}


void CNewRtrWizRasNoNICs::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRasNoNICs, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizRasNoNICs::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizRasNoNICs::OnInitDialog()
{

    CNewRtrWizPageBase::OnInitDialog();

    CheckRadioButton(IDC_NEWWIZ_BTN_YES, IDC_NEWWIZ_BTN_NO,
                     IDC_NEWWIZ_BTN_YES);

    // The default is to create a new connection
    // That is, to leave the button unchecked.
    return TRUE;
}

HRESULT CNewRtrWizRasNoNICs::OnSavePage()
{
    m_pRtrWizData->m_fNoNicsAreOk = IsDlgButtonChecked(IDC_NEWWIZ_BTN_NO);
    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishNoNICs Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizRasFinishNoNICs,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);





/*---------------------------------------------------------------------------
    CNewRtrWizAddressing implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizAddressing::CNewRtrWizAddressing() :
CNewRtrWizPageBase(CNewRtrWizAddressing::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_ADDRESS_ASSIGNMENT_TITLE,
              IDS_NEWWIZ_ADDRESS_ASSIGNMENT_SUBTITLE);

}


void CNewRtrWizAddressing::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CNewRtrWizAddressing, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizAddressing::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizAddressing::OnInitDialog()
{
    CNewRtrWizPageBase::OnInitDialog();

    CheckRadioButton(IDC_NEWWIZ_BTN_YES, IDC_NEWWIZ_BTN_NO,
                     m_pRtrWizData->m_fUseDHCP ? IDC_NEWWIZ_BTN_YES : IDC_NEWWIZ_BTN_NO);

    return TRUE;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizAddressing::OnSavePage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CNewRtrWizAddressing::OnSavePage()
{
    m_pRtrWizData->m_fUseDHCP = IsDlgButtonChecked(IDC_NEWWIZ_BTN_YES);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizAddressPool implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizAddressPool::CNewRtrWizAddressPool() :
CNewRtrWizPageBase(CNewRtrWizAddressPool::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_ADDRESS_POOL_TITLE,
              IDS_NEWWIZ_ADDRESS_POOL_SUBTITLE);

}


void CNewRtrWizAddressPool::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);
}

BEGIN_MESSAGE_MAP(CNewRtrWizAddressPool, CNewRtrWizPageBase)
ON_BN_CLICKED(IDC_NEWWIZ_BTN_NEW, OnBtnNew)
ON_BN_CLICKED(IDC_NEWWIZ_BTN_EDIT, OnBtnEdit)
ON_BN_CLICKED(IDC_NEWWIZ_BTN_DELETE, OnBtnDelete)
ON_NOTIFY(NM_DBLCLK, IDC_NEWWIZ_LIST, OnListDblClk)
ON_NOTIFY(LVN_ITEMCHANGED, IDC_NEWWIZ_LIST, OnNotifyListItemChanged)
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
    CNewRtrWizAddressPool::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizAddressPool::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CNewRtrWizPageBase::OnInitDialog();

    InitializeAddressPoolListControl(&m_listCtrl,
                                     0,
                                     &(m_pRtrWizData->m_addressPoolList));

    MultiEnableWindow(GetSafeHwnd(),
                      FALSE,
                      IDC_NEWWIZ_BTN_EDIT,
                      IDC_NEWWIZ_BTN_DELETE,
                      0);

    Assert(m_pRtrWizData->m_addressPoolList.GetCount() == 0);
    return TRUE;
}

BOOL CNewRtrWizAddressPool::OnSetActive()
{
    CNewRtrWizPageBase::OnSetActive();

    if (m_listCtrl.GetItemCount() == 0)
        GetHolder()->SetWizardButtons(PSWIZB_BACK);
    else
        GetHolder()->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

HRESULT CNewRtrWizAddressPool::OnSavePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    // No need to save the information, the list should be kept
    // up to date.

    if (m_pRtrWizData->m_addressPoolList.GetCount() == 0)
    {
        AfxMessageBox(IDS_ERR_ADDRESS_POOL_IS_EMPTY);
		//we dont return this to client
        return E_FAIL;
    }
    return hrOK;
}

void CNewRtrWizAddressPool::OnBtnNew()
{
    OnNewAddressPool(GetSafeHwnd(),
                     &m_listCtrl,
                     0,
                     &(m_pRtrWizData->m_addressPoolList));

    if (m_listCtrl.GetItemCount() > 0)
        GetHolder()->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    // Reset the focus
    if (m_listCtrl.GetNextItem(-1, LVIS_SELECTED) != -1)
    {
        MultiEnableWindow(GetSafeHwnd(),
                          TRUE,
                          IDC_NEWWIZ_BTN_EDIT,
                          IDC_NEWWIZ_BTN_DELETE,
                          0);
    }
}

void CNewRtrWizAddressPool::OnListDblClk(NMHDR *pNMHdr, LRESULT *pResult)
{
    OnBtnEdit();

    *pResult = 0;
}

void CNewRtrWizAddressPool::OnNotifyListItemChanged(NMHDR *pNmHdr, LRESULT *pResult)
{
    NMLISTVIEW *    pnmlv = reinterpret_cast<NMLISTVIEW *>(pNmHdr);
    BOOL            fEnable = !!(pnmlv->uNewState & LVIS_SELECTED);

    MultiEnableWindow(GetSafeHwnd(),
                      fEnable,
                      IDC_NEWWIZ_BTN_EDIT,
                      IDC_NEWWIZ_BTN_DELETE,
                      0);
    *pResult = 0;
}

void CNewRtrWizAddressPool::OnBtnEdit()
{
    INT     iPos;

    OnEditAddressPool(GetSafeHwnd(),
                      &m_listCtrl,
                      0,
                      &(m_pRtrWizData->m_addressPoolList));

    // reset the selection
    if ((iPos = m_listCtrl.GetNextItem(-1, LVNI_SELECTED)) != -1)
    {
        MultiEnableWindow(GetSafeHwnd(),
                          TRUE,
                          IDC_NEWWIZ_BTN_EDIT,
                          IDC_NEWWIZ_BTN_DELETE,
                          0);
    }

    SetFocus();

}

void CNewRtrWizAddressPool::OnBtnDelete()
{
    OnDeleteAddressPool(GetSafeHwnd(),
                        &m_listCtrl,
                        0,
                        &(m_pRtrWizData->m_addressPoolList));

    // There are no items, don't let them go forward
    if (m_listCtrl.GetItemCount() == 0)
        GetHolder()->SetWizardButtons(PSWIZB_BACK);

    SetFocus();

}


/*---------------------------------------------------------------------------
    CNewRtrWizRadius implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRadius::CNewRtrWizRadius() :
CNewRtrWizPageBase(CNewRtrWizRadius::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_USERADIUS_TITLE,
              IDS_NEWWIZ_USERADIUS_SUBTITLE);
}


void CNewRtrWizRadius::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRadius, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizRadius::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizRadius::OnInitDialog()
{
    CNewRtrWizPageBase::OnInitDialog();

    CheckRadioButton(IDC_NEWWIZ_BTN_YES, IDC_NEWWIZ_BTN_NO,
                     m_pRtrWizData->m_fUseRadius ? IDC_NEWWIZ_BTN_YES : IDC_NEWWIZ_BTN_NO);

    return TRUE;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizRadius::OnSavePage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CNewRtrWizRadius::OnSavePage()
{
    m_pRtrWizData->m_fUseRadius = IsDlgButtonChecked(IDC_NEWWIZ_BTN_YES);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizRadiusConfig implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRadiusConfig::CNewRtrWizRadiusConfig() :
   CNewRtrWizPageBase(IDD_NEWRTRWIZ_RADIUS_CONFIG, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_RADIUS_CONFIG_TITLE,
              IDS_NEWWIZ_RADIUS_CONFIG_SUBTITLE);

}


void CNewRtrWizRadiusConfig::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRadiusConfig, CNewRtrWizPageBase)
END_MESSAGE_MAP()


#define MAX_RADIUS_SRV_LEN  255

/*!--------------------------------------------------------------------------
    CNewRtrWizRadiusConfig::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizRadiusConfig::OnInitDialog()
{
    CNewRtrWizPageBase::OnInitDialog();

    GetDlgItem(IDC_NEWWIZ_EDIT_PRIMARY)->SendMessage(EM_LIMITTEXT, MAX_RADIUS_SRV_LEN, 0L);
    GetDlgItem(IDC_NEWWIZ_EDIT_SECONDARY)->SendMessage(EM_LIMITTEXT, MAX_RADIUS_SRV_LEN, 0L);

    return TRUE;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizRadiusConfig::OnSavePage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CNewRtrWizRadiusConfig::OnSavePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CString st;
    DWORD   netAddress;
    CWaitCursor wait;
    WSADATA             wsadata;
    DWORD               wsaerr = 0;
    HRESULT             hr = hrOK;
    BOOL                fWSInitialized = FALSE;

    // Check to see that we have non-blank names
    // ----------------------------------------------------------------
    GetDlgItemText(IDC_NEWWIZ_EDIT_PRIMARY, m_pRtrWizData->m_stRadius1);
    m_pRtrWizData->m_stRadius1.TrimLeft();
    m_pRtrWizData->m_stRadius1.TrimRight();

    GetDlgItemText(IDC_NEWWIZ_EDIT_SECONDARY, m_pRtrWizData->m_stRadius2);
    m_pRtrWizData->m_stRadius2.TrimLeft();
    m_pRtrWizData->m_stRadius2.TrimRight();

    if (m_pRtrWizData->m_stRadius1.IsEmpty() &&
        m_pRtrWizData->m_stRadius2.IsEmpty())
    {
        AfxMessageBox(IDS_ERR_NO_RADIUS_SERVERS_SPECIFIED);
        return E_FAIL;
    }


    // Start up winsock (for the ResolveName())
    // ----------------------------------------------------------------
    wsaerr = WSAStartup(0x0101, &wsadata);
    if (wsaerr)
        CORg( E_FAIL );
    fWSInitialized = TRUE;

    // Convert name into an IP address
    if (!m_pRtrWizData->m_stRadius1.IsEmpty())
    {
        m_pRtrWizData->m_netRadius1IpAddress = ResolveName(m_pRtrWizData->m_stRadius1);
        if (m_pRtrWizData->m_netRadius1IpAddress == INADDR_NONE)
        {
            CString st;
            st.Format(IDS_WRN_RTRWIZ_CANNOT_RESOLVE_RADIUS,
                      (LPCTSTR) m_pRtrWizData->m_stRadius1);
            if (AfxMessageBox(st, MB_OKCANCEL) == IDCANCEL)
            {
                GetDlgItem(IDC_NEWWIZ_EDIT_PRIMARY)->SetFocus();
                return E_FAIL;
            }
        }
    }


    // Convert name into an IP address
    if (!m_pRtrWizData->m_stRadius2.IsEmpty())
    {
        m_pRtrWizData->m_netRadius2IpAddress = ResolveName(m_pRtrWizData->m_stRadius2);
        if (m_pRtrWizData->m_netRadius2IpAddress == INADDR_NONE)
        {
            CString st;
            st.Format(IDS_WRN_RTRWIZ_CANNOT_RESOLVE_RADIUS,
                      (LPCTSTR) m_pRtrWizData->m_stRadius2);
            if (AfxMessageBox(st, MB_OKCANCEL) == IDCANCEL)
            {
                GetDlgItem(IDC_NEWWIZ_EDIT_SECONDARY)->SetFocus();
                return E_FAIL;
            }
        }
    }

    // Now get the password and encode it
    // ----------------------------------------------------------------
    GetDlgItemText(IDC_NEWWIZ_EDIT_SECRET, m_pRtrWizData->m_stRadiusSecret);

    // Pick a seed value
    m_pRtrWizData->m_uSeed = 0x9a;
    RtlEncodeW(&m_pRtrWizData->m_uSeed,
               m_pRtrWizData->m_stRadiusSecret.GetBuffer(0));
    m_pRtrWizData->m_stRadiusSecret.ReleaseBuffer(-1);

Error:
    if (fWSInitialized)
        WSACleanup();

    return hr;
}

DWORD CNewRtrWizRadiusConfig::ResolveName(LPCTSTR pszServerName)
{
    CHAR    szName[MAX_PATH+1];
    DWORD   netAddress = INADDR_NONE;

    StrnCpyAFromT(szName, pszServerName, MAX_PATH);
    netAddress = inet_addr(szName);
    if (netAddress == INADDR_NONE)
    {
        // resolve name
        struct hostent *    phe = gethostbyname(szName);
        if (phe != NULL)
        {
            if (phe->h_addr_list[0] != NULL)
                netAddress = *((PDWORD) phe->h_addr_list[0]);
        }
        else
        {
            Assert(::WSAGetLastError() != WSANOTINITIALISED);
        }
    }
    return netAddress;
}

/*---------------------------------------------------------------------------
    CNewRtrWizRasFinishAdvanced Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRasFinishAdvanced::CNewRtrWizRasFinishAdvanced() :                             
   CNewRtrWizFinishPageBase(CNewRtrWizRasFinishAdvanced::IDD, SaveFlag_Advanced, HelpFlag_GeneralRAS) 
{                                                   
    InitWiz97(TRUE, 0, 0);                          
}                                                   
                                                    
BEGIN_MESSAGE_MAP(CNewRtrWizRasFinishAdvanced, CNewRtrWizFinishPageBase)
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizRasFinishAdvanced::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizRasFinishAdvanced::OnHelpClick )
END_MESSAGE_MAP()                                   

void CNewRtrWizRasFinishAdvanced::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch1_1.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizRasFinishAdvanced::OnSetActive()
{
    CString sText = L"";
    CString sFormat;
    CString sPolicy;
    CString sPrivateInterfaceName;
    RtrWizInterface *   pRtrWizIf = NULL;

    CNewRtrWizFinishPageBase::OnSetActive();
    sFormat.LoadString(IDS_RAS_A_FINISH_SUMMARY);
    if ( m_pRtrWizData->m_fUseRadius )
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_RADIUS);
    }
    else
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_POLICIES);
    }
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPrivateInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPrivateInterfaceName = m_pRtrWizData->m_stPrivateInterfaceId;
    }

    sText.Format (  sFormat, 
                    sPrivateInterfaceName,
                    sPolicy
                 );

    SetDlgItemText(IDC_TXT_RAS_SUMMARY, sText);

    DestroyCaret(); 
   	
    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNoNICs Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoNICs,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);


/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNoIP Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoIP,
                                SaveFlag_DoNothing,
                                HelpFlag_AddIp);


/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishNoIPNonLocal Implementation
 ---------------------------------------------------------------------------*/
IMPLEMENT_NEWRTRWIZ_FINISH_PAGE(CNewRtrWizVpnFinishNoIPNonLocal,
                                SaveFlag_DoNothing,
                                HelpFlag_Nothing);


/*---------------------------------------------------------------------------
    CNewRtrWizNATVpnFinishAdvanced Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizNATVpnFinishAdvanced::CNewRtrWizNATVpnFinishAdvanced() :                             
   CNewRtrWizFinishPageBase(CNewRtrWizNATVpnFinishAdvanced::IDD, SaveFlag_Advanced, HelpFlag_Nothing) 
{                                                   
    InitWiz97(TRUE, 0, 0);                          
}                                                   
                                                    
BEGIN_MESSAGE_MAP(CNewRtrWizNATVpnFinishAdvanced, CNewRtrWizFinishPageBase)    
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizNATVpnFinishAdvanced::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizNATVpnFinishAdvanced::OnHelpClick )
END_MESSAGE_MAP()                                   

void CNewRtrWizNATVpnFinishAdvanced::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch1_46.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizNATVpnFinishAdvanced::OnSetActive()
{
    CString sText = L"";
    CString sTextNAT;

    CString sFormat;
    CString sPolicy;
    CString sPrivateInterfaceName;
    CString sPublicInterfaceName;
    RtrWizInterface *   pRtrWizIf = NULL;

    CNewRtrWizFinishPageBase::OnSetActive();
    sFormat.LoadString(IDS_RAS_VPN_A_FINISH_SUMMARY);
    if ( m_pRtrWizData->m_fUseRadius )
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_RADIUS);
    }
    else
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_POLICIES);
    }
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPublicInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPublicInterfaceName = m_pRtrWizData->m_stPublicInterfaceId;
    }

    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPrivateInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPrivateInterfaceName = m_pRtrWizData->m_stPrivateInterfaceId;
    }

    sText.Format (  sFormat, 
                    sPublicInterfaceName,
                    sPrivateInterfaceName,
                    sPolicy
                 );

    CString sIPAddr;
    CString sIPMask;


    // Now generate the NAT related information
    
    // Get the information for the private interface
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stNATPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
    {
        DWORD   netAddress, netMask;
        CString st;

        // We have to calculate the beginning of the subnet
        netAddress = INET_ADDR(pRtrWizIf->m_stIpAddress);
        netMask = INET_ADDR(pRtrWizIf->m_stMask);

        netAddress = netAddress & netMask;

        sIPAddr = INET_NTOA(netAddress);
        sIPMask = pRtrWizIf->m_stMask;
    }
    else
    {
        // An error! we do not have a private interface
        // Just leave things blank
        sIPAddr = L"192.168.0.0";
        sIPMask = L"255.255.0.0";
    }


    sFormat.LoadString(IDS_NAT_A_FINISH_SUMMARY);
    sTextNAT.Format(sFormat, "", sPublicInterfaceName, sIPAddr, sIPMask );
    sText = sText + L"\r\n" + sTextNAT;
    SetDlgItemText(IDC_TXT_NAT_VPN_SUMMARY, sText);

    
    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizRASVpnFinishAdvanced Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRASVpnFinishAdvanced::CNewRtrWizRASVpnFinishAdvanced() :                             
   CNewRtrWizFinishPageBase(CNewRtrWizRASVpnFinishAdvanced::IDD, SaveFlag_Advanced, HelpFlag_UserAccounts) 
{                                                   
    InitWiz97(TRUE, 0, 0);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRASVpnFinishAdvanced, CNewRtrWizFinishPageBase)    
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizRASVpnFinishAdvanced::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizRASVpnFinishAdvanced::OnHelpClick )
END_MESSAGE_MAP()                                   

void CNewRtrWizRASVpnFinishAdvanced::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch1_46.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizRASVpnFinishAdvanced::OnSetActive()
{
    CString sText = L"";
    CString sFormat;
    CString sPolicy;
    CString sPrivateInterfaceName;
    CString sPublicInterfaceName;
    RtrWizInterface *   pRtrWizIf = NULL;

    CNewRtrWizFinishPageBase::OnSetActive();

    sFormat.LoadString(IDS_RAS_VPN_A_FINISH_SUMMARY);
    if ( m_pRtrWizData->m_fUseRadius )
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_RADIUS);
    }
    else
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_POLICIES);
    }
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPublicInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPublicInterfaceName = m_pRtrWizData->m_stPublicInterfaceId;
    }

    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPrivateInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPrivateInterfaceName = m_pRtrWizData->m_stPrivateInterfaceId;
    }

    sText.Format (  sFormat, 
                    sPublicInterfaceName,
                    sPrivateInterfaceName,
                    sPolicy
                 );
    SetDlgItemText(IDC_TXT_RAS_VPN_SUMMARY, sText);
    GetDlgItem(IDC_DUMMY_CONTROL)->SetFocus();
    
    return TRUE;
}



/*---------------------------------------------------------------------------
    CNewRtrWizVpnFinishAdvanced Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizVpnFinishAdvanced::CNewRtrWizVpnFinishAdvanced() :                             
   CNewRtrWizFinishPageBase(CNewRtrWizVpnFinishAdvanced::IDD, SaveFlag_Advanced, HelpFlag_UserAccounts) 
{                                                   
    InitWiz97(TRUE, 0, 0); 
}
                                                    
BEGIN_MESSAGE_MAP(CNewRtrWizVpnFinishAdvanced, CNewRtrWizFinishPageBase)    
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizVpnFinishAdvanced::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizVpnFinishAdvanced::OnHelpClick )
END_MESSAGE_MAP()                                   

void CNewRtrWizVpnFinishAdvanced::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch1_46.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizVpnFinishAdvanced::OnSetActive()
{
    CString sText = L"";
    CString sFormat;
    CString sPolicy;
    CString sPrivateInterfaceName;
    CString sPublicInterfaceName;
    RtrWizInterface *   pRtrWizIf = NULL;

    CNewRtrWizFinishPageBase::OnSetActive();
    sFormat.LoadString(IDS_VPN_A_FINISH_SUMMARY);
    if ( m_pRtrWizData->m_fUseRadius )
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_RADIUS);
    }
    else
    {
        sPolicy.LoadString(IDS_VPN_A_FINISH_POLICIES);
    }
    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPublicInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPublicInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPublicInterfaceName = m_pRtrWizData->m_stPublicInterfaceId;
    }

    m_pRtrWizData->m_ifMap.Lookup(m_pRtrWizData->m_stPrivateInterfaceId,
                                  pRtrWizIf);

    if (pRtrWizIf)
        sPrivateInterfaceName = pRtrWizIf->m_stName;
    else
    {
        // This may be the dd interface case.  If we are creating
        // a DD interface the name will never have been added to the
        // interface map.
        sPrivateInterfaceName = m_pRtrWizData->m_stPrivateInterfaceId;
    }

    sText.Format (  sFormat, 
                    sPublicInterfaceName,
                    sPrivateInterfaceName,
                    sPolicy
                 );
    SetDlgItemText(IDC_TXT_VPN_SUMMARY, sText);
//    GetDlgItem(IDC_NEWWIZ_CHK_HELP)->SetFocus();
    SetFocus();
    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizVpnSelectPublic implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizVpnSelectPublic::CNewRtrWizVpnSelectPublic() :
   CNewRtrWizPageBase(CNewRtrWizVpnSelectPublic::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_VPN_A_SELECT_PUBLIC_TITLE,
              IDS_NEWWIZ_VPN_A_SELECT_PUBLIC_SUBTITLE);
}


void CNewRtrWizVpnSelectPublic::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);
}

BEGIN_MESSAGE_MAP(CNewRtrWizVpnSelectPublic, CNewRtrWizPageBase)
//{{AFX_MSG_MAP(CNewRtrWizVpnSelectPublic)
ON_BN_CLICKED(IDC_CHK_ENABLE_SECURITY, OnButtonClick)
ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizVpnSelectPublic::OnHelpClick )
ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizVpnSelectPublic::OnHelpClick )
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CNewRtrWizVpnSelectPublic::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/mpr_und_interfaces.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizVpnSelectPublic::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizVpnSelectPublic::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CString st;

    CNewRtrWizPageBase::OnInitDialog();

    // Setup the dialog and add the NICs
    m_pRtrWizData->m_fSetVPNFilter = TRUE;

    InitializeInterfaceListControl(NULL,
                                   &m_listCtrl,
                                   NULL,
                                   0,
                                   m_pRtrWizData);
    RefreshInterfaceListControl(NULL,
                                &m_listCtrl,
                                NULL,
                                0,
                                m_pRtrWizData);

    
    /*
    if (dwNICs == 0)
    {
        //
        // There are no NICS, you cannot set an interface
        // pointing to the Internet, and hence no filters
        // on it.
        //

        m_pRtrWizData->m_fSetVPNFilter = FALSE;

        GetDlgItem(IDC_NEWWIZ_VPN_BTN_YES)->EnableWindow(FALSE);
        GetDlgItem(IDC_VPN_YES_TEXT)->EnableWindow(FALSE);
    }
*/
    
#if 0
    // Windows NT Bug : 389587 - for the VPN case, we have to allow
    // for the case where they want only a single VPN connection (private
    // and no public connection).
    // Thus I add a <<None>> option to the list of interfaces.
    // ----------------------------------------------------------------
    st.LoadString(IDS_NO_PUBLIC_INTERFACE);
    {
        LV_ITEM     lvItem;
        int         iPos;

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        lvItem.iItem = 0;
        lvItem.iSubItem = 0;
        lvItem.pszText = (LPTSTR)(LPCTSTR) st;
        lvItem.lParam = NULL; //same functionality as SetItemData()

        iPos = m_listCtrl.InsertItem(&lvItem);

        if (iPos != -1)
        {
            m_listCtrl.SetItemText(iPos, IFLISTCOL_NAME,
                                   (LPCTSTR) st);
            m_listCtrl.SetItemData(iPos, NULL);
        }
    }

    m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED );
#endif

    CheckDlgButton(IDC_CHK_ENABLE_SECURITY, 
                    m_pRtrWizData-> m_fSetVPNFilter );    

    //
    //Preselect an interface if there is no public interface yet
    //
    if( m_pRtrWizData->m_stPublicInterfaceId.IsEmpty() )
        m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED ); 
    return TRUE;
}

BOOL CNewRtrWizVpnSelectPublic::OnSetActive()
{
    CNewRtrWizPageBase::OnSetActive();

    if(m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT)
    {
	CString st;
	st.LoadString(IDS_BASIC_FIREWALL);
	SetDlgItemText(IDC_CHK_ENABLE_SECURITY, st);
	st.LoadString(IDS_BASIC_FIREWALL_TEXT);
	SetDlgItemText(IDC_VPN_PUBLIC_TEXT, st);
    }
    else {
	CString st;
	st.LoadString(IDS_STATIC_FILTER);
	SetDlgItemText(IDC_CHK_ENABLE_SECURITY, st);
	st.LoadString(IDS_STATIC_FILTER_TEXT);
	SetDlgItemText(IDC_VPN_PUBLIC_TEXT, st);
    }

    return TRUE;
}

void CNewRtrWizVpnSelectPublic::OnButtonClick()
{
    
    m_pRtrWizData->m_fSetVPNFilter = 
        IsDlgButtonChecked(IDC_CHK_ENABLE_SECURITY);
        
}

HRESULT CNewRtrWizVpnSelectPublic::OnSavePage()
{
    INT     iSel;
    
    // Check to see that we actually selected an item
    iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iSel == -1)
    {
        // We did not select an item
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_INTERFACE);
        return E_FAIL;
    }
    m_pRtrWizData->m_fCreateDD = FALSE;

    m_pRtrWizData->m_stPublicInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);

    if ( m_pRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT )
    {
        m_pRtrWizData->m_fNATEnableFireWall = m_pRtrWizData->m_fSetVPNFilter;
    }

    return hrOK;
}


/*---------------------------------------------------------------------------
    CNewRtrWizVpnSelectPrivate
 ---------------------------------------------------------------------------*/
CNewRtrWizVpnSelectPrivate::CNewRtrWizVpnSelectPrivate() :
   CNewRtrWizPageBase(CNewRtrWizVpnSelectPrivate::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_VPN_A_SELECT_PRIVATE_TITLE,
              IDS_NEWWIZ_VPN_A_SELECT_PRIVATE_SUBTITLE);
}


void CNewRtrWizVpnSelectPrivate::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_NEWWIZ_LIST, m_listCtrl);

}

BEGIN_MESSAGE_MAP(CNewRtrWizVpnSelectPrivate, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizVpnSelectPrivate::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizVpnSelectPrivate::OnInitDialog()
{
    DWORD   dwNICs;

    CNewRtrWizPageBase::OnInitDialog();

    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);

    InitializeInterfaceListControl(NULL,
                                   &m_listCtrl,
                                   NULL,
                                   0,
                                   m_pRtrWizData);
    return TRUE;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizVpnSelectPrivate::OnSetActive
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizVpnSelectPrivate::OnSetActive()
{
    DWORD   dwNICs;
    int     iSel = 0;

    CNewRtrWizPageBase::OnSetActive();

    m_pRtrWizData->GetNumberOfNICS_IP(&dwNICs);

    RefreshInterfaceListControl(NULL,
                                &m_listCtrl,
                                (LPCTSTR) m_pRtrWizData->m_stPublicInterfaceId,
                                0,
                                m_pRtrWizData);

    if (!m_pRtrWizData->m_stPrivateInterfaceId.IsEmpty())
    {
        // Try to reselect the previously selected NIC
        LV_FINDINFO lvfi;

        lvfi.flags = LVFI_PARTIAL | LVFI_STRING;
        lvfi.psz = (LPCTSTR) m_pRtrWizData->m_stPrivateInterfaceId;
        iSel = m_listCtrl.FindItem(&lvfi, -1);
        if (iSel == -1)
            iSel = 0;
    }

    m_listCtrl.SetItemState(iSel, LVIS_SELECTED, LVIS_SELECTED );

    return TRUE;
}

/*!--------------------------------------------------------------------------
    CNewRtrWizVpnSelectPrivate::OnSavePage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CNewRtrWizVpnSelectPrivate::OnSavePage()
{
    INT     iSel;

    // Check to see that we actually selected an item
    iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iSel == LB_ERR)
    {
        // We did not select an item
        AfxMessageBox(IDS_PROMPT_PLEASE_SELECT_INTERFACE);
        return E_FAIL;
    }

    m_pRtrWizData->m_stPrivateInterfaceId = (LPCTSTR) m_listCtrl.GetItemData(iSel);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CNewRtrWizRouterUseDD implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRouterUseDD::CNewRtrWizRouterUseDD() :
   CNewRtrWizPageBase(CNewRtrWizRouterUseDD::IDD, CNewRtrWizPageBase::Middle)
{
    InitWiz97(FALSE,
              IDS_NEWWIZ_ROUTER_USEDD_TITLE,
              IDS_NEWWIZ_ROUTER_USEDD_SUBTITLE);
}


void CNewRtrWizRouterUseDD::DoDataExchange(CDataExchange *pDX)
{
    CNewRtrWizPageBase::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CNewRtrWizRouterUseDD, CNewRtrWizPageBase)
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    CNewRtrWizRouterUseDD::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNewRtrWizRouterUseDD::OnInitDialog()
{

    CNewRtrWizPageBase::OnInitDialog();

    CheckRadioButton(IDC_NEWWIZ_BTN_YES, IDC_NEWWIZ_BTN_NO,
                     m_pRtrWizData->m_fUseDD ? IDC_NEWWIZ_BTN_YES : IDC_NEWWIZ_BTN_NO);

    // The default is to create a new connection
    // That is, to leave the button unchecked.
    return TRUE;
}

HRESULT CNewRtrWizRouterUseDD::OnSavePage()
{
    m_pRtrWizData->m_fUseDD = IsDlgButtonChecked(IDC_NEWWIZ_BTN_YES);
    return hrOK;
}



/*---------------------------------------------------------------------------
    CNewRtrWizRouterFinish Implementation
 ---------------------------------------------------------------------------*/
CNewRtrWizRouterFinish::CNewRtrWizRouterFinish () :
    CNewRtrWizFinishPageBase(CNewRtrWizRouterFinish::IDD, SaveFlag_Advanced, HelpFlag_Nothing) 
{
    InitWiz97(TRUE, 0, 0);                          
}

BEGIN_MESSAGE_MAP(CNewRtrWizRouterFinish, CNewRtrWizFinishPageBase)    
END_MESSAGE_MAP()                                   

BOOL CNewRtrWizRouterFinish::OnSetActive ()
{
    CString sText;
    CNewRtrWizFinishPageBase::OnSetActive();
    sText.LoadString(IDS_ROUTER_FINISH_DD_SUMMARY);
    SetDlgItemText(IDC_TXT_ROUTER_FINISH_SUMMARY, sText);
    return TRUE;
}


/*---------------------------------------------------------------------------
    CNewRtrWizRouterFinishDD Implementation
 ---------------------------------------------------------------------------*/

CNewRtrWizRouterFinishDD::CNewRtrWizRouterFinishDD () :
    CNewRtrWizFinishPageBase(CNewRtrWizRouterFinishDD::IDD, SaveFlag_Advanced, HelpFlag_DemandDial) 
{
    InitWiz97(TRUE, 0, 0);                          
}

BEGIN_MESSAGE_MAP(CNewRtrWizRouterFinishDD, CNewRtrWizFinishPageBase)    
	ON_NOTIFY( NM_CLICK, IDC_HELP_LINK, CNewRtrWizRouterFinishDD::OnHelpClick )
	ON_NOTIFY( NM_RETURN, IDC_HELP_LINK, CNewRtrWizRouterFinishDD::OnHelpClick )
END_MESSAGE_MAP()                                   

void CNewRtrWizRouterFinishDD::OnHelpClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!pNMHDR || !pResult) 
		return;
	if((pNMHDR->idFrom != IDC_HELP_LINK) ||((pNMHDR->code != NM_CLICK) && (pNMHDR->code != NM_RETURN)))
		return;
	
	HtmlHelpA(NULL, "RRASconcepts.chm::/sag_RRAS-Ch3_08d.htm", HH_DISPLAY_TOPIC, 0);		
	*pResult = 0;
}

BOOL CNewRtrWizRouterFinishDD::OnSetActive ()
{
    CString sText;
    CNewRtrWizFinishPageBase::OnSetActive();
    sText.LoadString(IDS_ROUTER_FINISH_DD_SUMMARY);
    SetDlgItemText(IDC_TXT_ROUTER_FINISH_DD_SUMMARY, sText);
    return TRUE;
}

/*---------------------------------------------------------------------------
    CNewRtrWizManualFinish Implementation
 ---------------------------------------------------------------------------*/

CNewRtrWizManualFinish::CNewRtrWizManualFinish () :                             
   CNewRtrWizFinishPageBase(CNewRtrWizManualFinish ::IDD, SaveFlag_Advanced, HelpFlag_Nothing) 
{                                                   
    InitWiz97(TRUE, 0, 0);                          
}                                                   
                                                    
BEGIN_MESSAGE_MAP(CNewRtrWizManualFinish, CNewRtrWizFinishPageBase)    
END_MESSAGE_MAP()                                   

BOOL CNewRtrWizManualFinish ::OnSetActive()
{
    CString sText = L"";
    CString sTemp = L"";
    CString sBullet = L"";
    WCHAR   * pwszLineBreak = L"\r\n";
    //
    //Check to see which options are set and based on that,
    //make the display message
    //
    CNewRtrWizFinishPageBase::OnSetActive();
    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_VPN )
    {
        sText  += sBullet;
        sTemp.LoadString(IDS_SUMMARY_VPN_ACCESS);
        sText += sTemp;
        sText += pwszLineBreak;
    }

    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DIALUP )
    {
        sText  += sBullet;
        sTemp.LoadString(IDS_SUMMARY_DIALUP_ACCESS);
        sText += sTemp;
        sText += pwszLineBreak;
    }

    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_DOD )
    {
        sText  += sBullet;
        sTemp.LoadString(IDS_SUMMARY_DEMAND_DIAL);
        sText += sTemp;
        sText += pwszLineBreak;
    }

    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_NAT )
    {            
        sText  += sBullet;
        sTemp.LoadString(IDS_SUMMARY_NAT);
        sText += sTemp;
    }
    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_BASIC_FIREWALL )
    {
    	//kmurthy: this should always come with type NAT
        sTemp.LoadString(IDS_SUMMARY_BASIC_FIREWALL);
        sText += sTemp;
        sText += pwszLineBreak;
    }
    if ( m_pRtrWizData->m_dwNewRouterType & NEWWIZ_ROUTER_TYPE_LAN_ROUTING )
    {
        sText  += sBullet;
        sTemp.LoadString(IDS_SUMMARY_LAN_ROUTING);
        sText += sTemp;
        sText += pwszLineBreak;
    }
    SetDlgItemText(IDC_TXT_SUMMARY, sText);
    GetDlgItem(IDC_STATIC_DUMMY)->SetFocus();
    return TRUE;
}


CRasWarning::CRasWarning(char * helpTopic, int strId, CWnd* pParent /*=NULL*/)
	:CDialog(CRasWarning::IDD, pParent)
{
	m_helpTopic = helpTopic;
	m_strId = strId;
}

void CRasWarning::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CRasWarning, CDialog)
	//{{AFX_MSG_MAP(CDhcp)
	ON_BN_CLICKED(ID_OK, OnOkBtn)
	ON_BN_CLICKED(ID_HELP_BTN, OnHelpBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CRasWarning::OnInitDialog()
{
	CString stText;
	CDialog::OnInitDialog();

	stText.LoadString(m_strId);
	SetDlgItemText(IDC_RAS_WARNING, stText);
	return TRUE;
}

void CRasWarning::OnOkBtn()
{
	CDialog::OnOK();
}

void CRasWarning::OnHelpBtn()
{
	if(m_helpTopic)
	       HtmlHelpA(NULL, m_helpTopic, HH_DISPLAY_TOPIC, 0);
	
	CDialog::OnOK();
}

//This function disables RRAS on the server(basically what cliking Disable RRAs on menu does)
HRESULT DisableRRAS(TCHAR * szMachineName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	DWORD           dwErr = ERROR_SUCCESS;
	RtrConfigData   wizData;
	NewRtrWizData  rtrWizData;
	IRouterInfo	  * pRouterInfo = NULL;    
	TCHAR			szLocalName[MAX_COMPUTERNAME_LENGTH + 1] ={0};
	DWORD			dw = MAX_COMPUTERNAME_LENGTH;
	
       GUID              guidConfig = GUID_RouterNull;
       IRouterProtocolConfig	* spRouterConfig = NULL;
       IRtrMgrProtocolInfo   * spRmProt = NULL;
       RtrMgrProtocolCB    RmProtCB;        
	CWaitCursor                wait;
	HRESULT                 hr = hrOK;
	RouterVersionInfo   RVI;

	if(!szMachineName || szMachineName[0] == 0){
	    	//Get local Machine Name 
		GetComputerName ( szLocalName, &dw );
	    	szMachineName = szLocalName;
	}

	//Create the RouterInfo    
	hr = CreateRouterInfo(&pRouterInfo, NULL, szMachineName);
	Assert(pRouterInfo != NULL);

       // Stop the router service
        hr = StopRouterService((LPCTSTR) szMachineName);
        if (!FHrSucceeded(hr))
        {
            AddHighLevelErrorStringId(IDS_ERR_COULD_NOT_REMOVE_ROUTER);
            CORg(hr);
        }

	//
	//Do some of the SecureRouterInfo functionality here
	//
	CORg(InitiateServerConnection(szMachineName,
                              NULL,
                              FALSE,
                              pRouterInfo));

	CORg(pRouterInfo->Load(T2COLE(szMachineName),
	                          NULL));
	
        {
            USES_CONVERSION;
            if(S_OK == pRouterInfo->GetRouterVersionInfo(&RVI) && RVI.dwRouterVersion >= 5)
            {
                hr = RRASDelRouterIdObj(T2W(szMachineName));
                Assert(hr == S_OK);
            }
        }

        // Windows NT Bug : 389469
        // This is hardcoded for NAT (not to change too much).
        // Find the config GUID for NAT, and then remove the protocol.
        hr = LookupRtrMgrProtocol(pRouterInfo,
                                  PID_IP,
                                  MS_IP_NAT,
                                  &spRmProt);
        
        // If the lookup returns S_FALSE, then it couldn't find the
        // protocol.
        if (FHrOK(hr))
        {
            spRmProt->CopyCB(&RmProtCB);
            
            CORg( CoCreateProtocolConfig(RmProtCB.guidConfig,
                                         pRouterInfo,
                                         PID_IP,
                                         MS_IP_NAT,
                                         &spRouterConfig) );
            
            if (spRouterConfig)                
                hr = spRouterConfig->RemoveProtocol(pRouterInfo->GetMachineName(),
                    PID_IP,
                    MS_IP_NAT,
                    NULL,
                    0,
                    pRouterInfo,
                    0);
        }
        
    
        // Perform any removal/cleanup action
        UninstallGlobalSettings(szMachineName,
                                pRouterInfo,
                                RVI.dwRouterVersion == 4,
                                TRUE);

        // Remove the router from the domain
        if (pRouterInfo->GetRouterType() != ROUTER_TYPE_LAN)
            RegisterRouterInDomain(szMachineName, FALSE);
        
        // Disable the service
        SetRouterServiceStartType((LPCTSTR) szMachineName,
                                  SERVICE_DISABLED);

        //
        // Bug 519414
        //  Since IAS now has a Microsoft policy with the appropriate settings,
        //  there is no longer a single default policy.  In addition there is
        //  no need to update any policy to have the required settings since the
        //  Microsoft VPN server policy does the job.
        //
    
#if __DEFAULT_POLICY

        //Now update the default policy
        CORg( UpdateDefaultPolicy(szMachineName,
                        FALSE,
                        FALSE,
                        0
                        ) );

#endif

Error:
    if (!FHrSucceeded(hr)) 
    {
        AddSystemErrorMessage(hr);
    }


    return hr;    
}

/*!--------------------------------------------------------------------------
    InitializeInterfaceListControl
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InitializeInterfaceListControl(IRouterInfo *pRouter,
                                       CListCtrl *pListCtrl,
                                       LPCTSTR pszExcludedIf,
                                       LPARAM flags,
                                       NewRtrWizData *pWizData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    HRESULT     hr = hrOK;
    LV_COLUMN   lvCol;  // list view column struct for radius servers
    RECT        rect;
    CString     stColCaption;
    LV_ITEM     lvItem;
    int         iPos;
    CString     st;
    int         nColWidth;

    Assert(pListCtrl);

    ListView_SetExtendedListViewStyle(pListCtrl->GetSafeHwnd(),
                                      LVS_EX_FULLROWSELECT);

    // Add the columns to the list control
      pListCtrl->GetClientRect(&rect);

    if (!FHrOK(pWizData->HrIsIPInstalled()))
        flags |= IFLIST_FLAGS_NOIP;

    // Determine the width of the columns (we assume three equal width columns)

    if (flags & IFLIST_FLAGS_NOIP)
        nColWidth = rect.right / (IFLISTCOL_COUNT - 1 );
    else
        nColWidth = rect.right / IFLISTCOL_COUNT;

    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = nColWidth;

    for(int index = 0; index < IFLISTCOL_COUNT; index++)
    {
        // If IP is not installed, do not add the column
        if ((index == IFLISTCOL_IPADDRESS) &&
            (flags & IFLIST_FLAGS_NOIP))
            continue;

        stColCaption.LoadString( s_rgIfListColumnHeaders[index] );
        lvCol.pszText = (LPTSTR)((LPCTSTR) stColCaption);
        pListCtrl->InsertColumn(index, &lvCol);
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    RefreshInterfaceListControl
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RefreshInterfaceListControl(IRouterInfo *pRouter,
                                    CListCtrl *pListCtrl,
                                    LPCTSTR pszExcludedIf,
                                    LPARAM flags,
                                    NewRtrWizData *pWizData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    HRESULT     hr = hrOK;
    LV_COLUMN   lvCol;  // list view column struct for radius servers
    LV_ITEM     lvItem;
    int         iPos;
    CString     st;
    POSITION    pos;
    RtrWizInterface *   pRtrWizIf;

    Assert(pListCtrl);

    // If a pointer to a blank string was passed in, set the
    // pointer to NULL.
    if (pszExcludedIf && (*pszExcludedIf == 0))
        pszExcludedIf = NULL;

    // Clear the list control
    pListCtrl->DeleteAllItems();

    // This means that we should use the test data, rather
    // than the actual machine data
    {
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        int nCount = 0;

        pos = pWizData->m_ifMap.GetStartPosition();

        while (pos)
        {
            pWizData->m_ifMap.GetNextAssoc(pos, st, pRtrWizIf);

            if (pszExcludedIf &&
                (pRtrWizIf->m_stId.CompareNoCase(pszExcludedIf) == 0))
                continue;

            lvItem.iItem = nCount;
            lvItem.iSubItem = 0;
            lvItem.pszText = (LPTSTR)(LPCTSTR) pRtrWizIf->m_stName;
            lvItem.lParam = NULL; //same functionality as SetItemData()

            iPos = pListCtrl->InsertItem(&lvItem);

            if (iPos != -1)
            {
                pListCtrl->SetItemText(iPos, IFLISTCOL_NAME,
                                       (LPCTSTR) pRtrWizIf->m_stName);
                pListCtrl->SetItemText(iPos, IFLISTCOL_DESC,
                                       (LPCTSTR) pRtrWizIf->m_stDesc);

                if (FHrOK(pWizData->HrIsIPInstalled()))
                {
                    CString stAddr;

                    stAddr = pRtrWizIf->m_stIpAddress;

                    if (pRtrWizIf->m_fDhcpObtained)
                        stAddr += _T(" (DHCP)");

                    pListCtrl->SetItemText(iPos, IFLISTCOL_IPADDRESS,
                                           (LPCTSTR) stAddr);
                }

                pListCtrl->SetItemData(iPos,
                                       (LPARAM) (LPCTSTR) pRtrWizIf->m_stId);
            }

            nCount++;
        }
    }


    return hr;
}



/*!--------------------------------------------------------------------------
    CallRouterEntryDlg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CallRouterEntryDlg(HWND hWnd, NewRtrWizData *pWizData, LPARAM flags)
{
    HRESULT hr = hrOK;
    HINSTANCE   hInstanceRasDlg = NULL;
    PROUTERENTRYDLG pfnRouterEntry = NULL;
    CString     stRouter, stPhoneBook;
    BOOL    bStatus;
    RASENTRYDLG info;
    SPSZ        spsz;
    SPIInterfaceInfo    spIf;
    SPIInfoBase spInfoBase;
    LPCTSTR     pszServerName = pWizData->m_stServerName;

    // Get the library (we are dynamically linking to the function).
    // ----------------------------------------------------------------
    hInstanceRasDlg = AfxLoadLibrary(_T("rasdlg.dll"));
    if (hInstanceRasDlg == NULL)
        CORg( E_FAIL );

    pfnRouterEntry = (PROUTERENTRYDLG) ::GetProcAddress(hInstanceRasDlg,
        SZROUTERENTRYDLG);
    if (pfnRouterEntry == NULL)
        CORg( E_FAIL );

    // First create the phone book entry.
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hWnd;
    info.dwFlags |= RASEDFLAG_NewEntry;

    if(flags == RASEDFLAG_NAT)
	    info.dwFlags |= 	RASEDFLAG_NAT;

    stRouter = pszServerName;
    IfAdminNodeHandler::GetPhoneBookPath(stRouter, &stPhoneBook);

    if (stRouter.GetLength() == 0)
    {
        stRouter = CString(_T("\\\\")) + GetLocalMachineName();
    }

    bStatus = pfnRouterEntry((LPTSTR)(LPCTSTR)stRouter,
                             (LPTSTR)(LPCTSTR)stPhoneBook,
                             NULL,
                             &info);
    Trace2("RouterEntryDlg=%f,e=%d\n", bStatus, info.dwError);

    if (!bStatus)
    {
        if (info.dwError != NO_ERROR)
        {
            AddHighLevelErrorStringId(IDS_ERR_UNABLETOCONFIGPBK);
            CWRg( info.dwError );
        }

        //$ ASSUMPTION
        // If the dwError field has not been filled, we assume that
        // the user cancelled out of the wizard.
        CWRg( ERROR_CANCELLED );
    }


    // Ok, at this point we have an interface
    // We need to add the IP/IPX routermangers to the interface

    // Create a dummy InterfaceInfo
    CORg( CreateInterfaceInfo(&spIf,
                              info.szEntry,
                              ROUTER_IF_TYPE_FULL_ROUTER) );

    // This call to get the name doesn't matter (for now).  The
    // reason is that DD interfaces do not return GUIDs, but this
    // will work when they do return a GUID.
    // ----------------------------------------------------------------
    hr = InterfaceInfo::FindInterfaceTitle(pszServerName,
                                           info.szEntry,
                                           &spsz);
    if (!FHrOK(hr))
    {
        spsz.Free();
        spsz = StrDup(info.szEntry);
    }

    CORg( spIf->SetTitle(spsz) );
    CORg( spIf->SetMachineName(pszServerName) );

    // Load an infobase for use by the routines
    CORg( CreateInfoBase(&spInfoBase) );


    if (info.reserved2 & RASNP_Ip)
    {
        AddIpPerInterfaceBlocks(spIf, spInfoBase);

        // ok, setup the public interface
        Assert(pWizData->m_stPublicInterfaceId.IsEmpty());
        pWizData->m_stPublicInterfaceId = spIf->GetTitle();

        HANDLE              hMachine = INVALID_HANDLE_VALUE;
        HKEY                hkeyMachine = NULL;
        RouterVersionInfo   routerversion;
        InfoBlock *         pBlock;

        DWORD dwErr = ::MprConfigServerConnect((LPWSTR)pszServerName, &hMachine);

        if(dwErr != NOERROR || hMachine == INVALID_HANDLE_VALUE)
           goto Error;

        if (ERROR_SUCCESS == ConnectRegistry(pszServerName, &hkeyMachine))
            QueryRouterVersionInfo(hkeyMachine, &routerversion);
        else
            routerversion.dwRouterVersion = 5;

        if (hkeyMachine)
            DisconnectRegistry(hkeyMachine);

        // Get the IP_ROUTE_INFO block from the interface
        spInfoBase->GetBlock(IP_ROUTE_INFO, &pBlock, 0);

        //
        //Add static routes here if any
        //
        SROUTEINFOLIST * pSRouteList = (SROUTEINFOLIST * )info.reserved;
        MIB_IPFORWARDROW    * pForwardRow = NULL;
        MIB_IPFORWARDROW    * pRoute = NULL;
        DWORD               dwItemCount = 0;

        while ( pSRouteList )
        {
                        
            LPVOID pTemp; 

            dwItemCount ++;
            if ( pForwardRow == NULL )
            {
                pTemp = LocalAlloc(LPTR, sizeof(MIB_IPFORWARDROW));
            }
            else
            {
                pTemp = LocalReAlloc(pForwardRow , 
                                            sizeof(MIB_IPFORWARDROW) * dwItemCount, 
                                            LMEM_ZEROINIT|LMEM_MOVEABLE);
            }

            if(pTemp)
            {
                pForwardRow = (MIB_IPFORWARDROW *)pTemp;
                pRoute = pForwardRow + ( dwItemCount - 1 );

                pRoute->dwForwardDest = INET_ADDR(pSRouteList->RouteInfo.pszDestIP);
                pRoute->dwForwardMask = INET_ADDR(pSRouteList->RouteInfo.pszNetworkMask);
                pRoute->dwForwardMetric1 = _ttol(pSRouteList->RouteInfo.pszMetric );
                pRoute->dwForwardMetric5 = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;
                pRoute->dwForwardNextHop = 0;


                if (routerversion.dwRouterVersion < 5)
                    pRoute->dwForwardProto = PROTO_IP_LOCAL;
                else
                    pRoute->dwForwardProto = PROTO_IP_NT_STATIC;
            }
            else 
            {
                dwItemCount--;
            }

            //Free all the entry items
            pTemp = pSRouteList->pNext;
            GlobalFree(pSRouteList->RouteInfo.pszDestIP);
            GlobalFree(pSRouteList->RouteInfo.pszNetworkMask);
            GlobalFree(pSRouteList->RouteInfo.pszMetric);
            GlobalFree(pSRouteList);
            pSRouteList = (SROUTEINFOLIST *)pTemp;            
        }
    
        if ( dwItemCount )
        {
            CORg( AddStaticRoute(pForwardRow, spInfoBase, pBlock, dwItemCount) );
            LocalFree(pForwardRow);
        }

        // Save this back to the IP RmIf
        RouterEntrySaveInfoBase(pszServerName,
                                spIf->GetId(),
                                spInfoBase,
                                PID_IP);

        // disconnect it
        if(hMachine != INVALID_HANDLE_VALUE)
        {
            ::MprAdminServerDisconnect(hMachine);        
        }
    }
    if (info.reserved2 & RASNP_Ipx)
    {
        // Remove anything that was loaded previously
        spInfoBase->Unload();

        AddIpxPerInterfaceBlocks(spIf, spInfoBase);

        // Save this back to the IPX RmIf
        RouterEntrySaveInfoBase(pszServerName,
                                spIf->GetId(),
                                spInfoBase,
                                PID_IPX);
    }

Error:

    if (!FHrSucceeded(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
    {
        TCHAR    szErr[2048] = _T(" ");

        if (hr != E_FAIL)    // E_FAIL doesn't give user any information
        {
            FormatRasError(hr, szErr, DimensionOf(szErr));
        }
        AddLowLevelErrorString(szErr);

        // If there is no high level error string, add a
        // generic error string.  This will be used if no other
        // high level error string is set.
        SetDefaultHighLevelErrorStringId(IDS_ERR_GENERIC_ERROR);

        DisplayTFSErrorMessage(NULL);
    }

    if (hInstanceRasDlg)
        ::FreeLibrary(hInstanceRasDlg);
    return hr;
}


/*!--------------------------------------------------------------------------
    RouterEntrySaveInfoBase
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterEntrySaveInfoBase(LPCTSTR pszServerName,
                                LPCTSTR pszIfName,
                                IInfoBase *pInfoBase,
                                DWORD dwTransportId)
{
    HRESULT hr = hrOK;
    MPR_SERVER_HANDLE   hMprServer = NULL;
    HANDLE              hInterface = NULL;
    DWORD               dwErr = ERROR_SUCCESS;
    MPR_INTERFACE_0     mprInterface;
    LPBYTE              pInfoData = NULL;
    DWORD               dwInfoSize = 0;
    MPR_CONFIG_HANDLE   hMprConfig = NULL;
    HANDLE              hIfTransport = NULL;

    Assert(pInfoBase);

    // Convert the infobase into a byte array
    // ----------------------------------------------------------------
    CWRg( pInfoBase->WriteTo(&pInfoData, &dwInfoSize) );


    // Connect to the server
    // ----------------------------------------------------------------
    dwErr = MprAdminServerConnect((LPWSTR) pszServerName, &hMprServer);

    if (dwErr == ERROR_SUCCESS)
    {
        // Get a handle to the interface
        // ------------------------------------------------------------
        dwErr = MprAdminInterfaceGetHandle(hMprServer,
                                           (LPWSTR) pszIfName,
                                           &hInterface,
                                           FALSE);
        if (dwErr != ERROR_SUCCESS)
        {
            // We couldn't get a handle the interface, so let's try
            // to create the interface.
            // --------------------------------------------------------
            ZeroMemory(&mprInterface, sizeof(mprInterface));

            StrCpyWFromT(mprInterface.wszInterfaceName, pszIfName);
            mprInterface.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
            mprInterface.fEnabled = TRUE;

            CWRg( MprAdminInterfaceCreate(hMprServer,
                                          0,
                                          (LPBYTE) &mprInterface,
                                          &hInterface) );

        }

        // Try to write the info out
        // ------------------------------------------------------------
        dwErr = MprAdminInterfaceTransportSetInfo(hMprServer,
            hInterface,
            dwTransportId,
            pInfoData,
            dwInfoSize);
        if (dwErr != NO_ERROR && dwErr != RPC_S_SERVER_UNAVAILABLE)
        {
            // Attempt to add the router-manager on the interface
            // --------------------------------------------------------
            dwErr = ::MprAdminInterfaceTransportAdd(hMprServer,
                hInterface,
                dwTransportId,
                pInfoData,
                dwInfoSize);
            CWRg( dwErr );
        }
    }

    // Ok, now that we've written the info out to the running router,
    // let's try to write the info to the store.
    // ----------------------------------------------------------------
    dwErr = MprConfigServerConnect((LPWSTR) pszServerName, &hMprConfig);
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                            (LPWSTR) pszIfName,
                                            &hInterface);
        if (dwErr != ERROR_SUCCESS)
        {
            // We couldn't get a handle the interface, so let's try
            // to create the interface.
            // --------------------------------------------------------
            ZeroMemory(&mprInterface, sizeof(mprInterface));

            StrCpyWFromT(mprInterface.wszInterfaceName, pszIfName);
            mprInterface.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
            mprInterface.fEnabled = TRUE;

            CWRg( MprConfigInterfaceCreate(hMprConfig,
                                           0,
                                           (LPBYTE) &mprInterface,
                                           &hInterface) );
        }

        dwErr = MprConfigInterfaceTransportGetHandle(hMprConfig,
            hInterface,
            dwTransportId,
            &hIfTransport);
        if (dwErr != ERROR_SUCCESS)
        {
            CWRg( MprConfigInterfaceTransportAdd(hMprConfig,
                hInterface,
                dwTransportId,
                NULL,
                pInfoData,
                dwInfoSize,
                &hIfTransport) );
        }
        else
        {
            CWRg( MprConfigInterfaceTransportSetInfo(hMprConfig,
                hInterface,
                hIfTransport,
                pInfoData,
                dwInfoSize) );
        }
    }

Error:
    if (hMprConfig)
        MprConfigServerDisconnect(hMprConfig);

    if (hMprServer)
        MprAdminServerDisconnect(hMprServer);

    if (pInfoData)
        CoTaskMemFree(pInfoData);

    return hr;
}


/*!--------------------------------------------------------------------------
    RouterEntryLoadInfoBase
        This will load the RtrMgrInterfaceInfo infobase.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterEntryLoadInfoBase(LPCTSTR pszServerName,
                                LPCTSTR pszIfName,
                                DWORD dwTransportId,
                                IInfoBase *pInfoBase)
{
    HRESULT hr = hrOK;
    MPR_SERVER_HANDLE   hMprServer = NULL;
    HANDLE              hInterface = NULL;
    DWORD               dwErr = ERROR_SUCCESS;
    MPR_INTERFACE_0     mprInterface;
    LPBYTE              pByte = NULL;
    DWORD               dwSize = 0;
    MPR_CONFIG_HANDLE   hMprConfig = NULL;
    HANDLE              hIfTransport = NULL;

    Assert(pInfoBase);

    // Connect to the server
    // ----------------------------------------------------------------
    dwErr = MprAdminServerConnect((LPWSTR) pszServerName, &hMprServer);
    if (dwErr == ERROR_SUCCESS)
    {
        // Get a handle to the interface
        // ------------------------------------------------------------
        dwErr = MprAdminInterfaceGetHandle(hMprServer,
                                           (LPWSTR) pszIfName,
                                           &hInterface,
                                           FALSE);
        if (dwErr != ERROR_SUCCESS)
        {
            // We couldn't get a handle the interface, so let's try
            // to create the interface.
            // --------------------------------------------------------
            ZeroMemory(&mprInterface, sizeof(mprInterface));

            StrCpyWFromT(mprInterface.wszInterfaceName, pszIfName);
            mprInterface.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
            mprInterface.fEnabled = TRUE;

            CWRg( MprAdminInterfaceCreate(hMprServer,
                                          0,
                                          (LPBYTE) &mprInterface,
                                          &hInterface) );

        }

        // Try to read the info
        // ------------------------------------------------------------
        dwErr = MprAdminInterfaceTransportGetInfo(hMprServer,
            hInterface,
            dwTransportId,
            &pByte,
            &dwSize);

        if (dwErr == ERROR_SUCCESS)
            pInfoBase->LoadFrom(dwSize, pByte);

        if (pByte)
            MprAdminBufferFree(pByte);
        pByte = NULL;
        dwSize = 0;
    }

    if (dwErr != ERROR_SUCCESS)
    {
        // Ok, we've tried to use the running router but that
        // failed, let's try to read the info from the store.
        // ----------------------------------------------------------------
        dwErr = MprConfigServerConnect((LPWSTR) pszServerName, &hMprConfig);
        if (dwErr == ERROR_SUCCESS)
        {

            dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                                (LPWSTR) pszIfName,
                                                &hInterface);
            if (dwErr != ERROR_SUCCESS)
            {
                // We couldn't get a handle the interface, so let's try
                // to create the interface.
                // --------------------------------------------------------
                ZeroMemory(&mprInterface, sizeof(mprInterface));

                StrCpyWFromT(mprInterface.wszInterfaceName, pszIfName);
                mprInterface.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
                mprInterface.fEnabled = TRUE;

                CWRg( MprConfigInterfaceCreate(hMprConfig,
                                               0,
                                               (LPBYTE) &mprInterface,
                                               &hInterface) );
            }

            CWRg( MprConfigInterfaceTransportGetHandle(hMprConfig,
                hInterface,
                dwTransportId,
                &hIfTransport) );

            CWRg( MprConfigInterfaceTransportGetInfo(hMprConfig,
                hInterface,
                hIfTransport,
                &pByte,
                &dwSize) );

            pInfoBase->LoadFrom(dwSize, pByte);

            if (pByte)
                MprConfigBufferFree(pByte);
            pByte = NULL;
            dwSize = 0;
        }
    }

    CWRg(dwErr);

Error:
    if (hMprConfig)
        MprConfigServerDisconnect(hMprConfig);

    if (hMprServer)
        MprAdminServerDisconnect(hMprServer);

    return hr;
}



/*!--------------------------------------------------------------------------
    LaunchHelpTopic
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void LaunchHelpTopic(LPCTSTR pszHelpString)
{
    TCHAR               szBuffer[1024];
    CString             st;
    STARTUPINFO            si;
    PROCESS_INFORMATION    pi;

    if ((pszHelpString == NULL) || (*pszHelpString == 0))
        return;

    ::ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.wShowWindow = SW_SHOW;
    ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    ExpandEnvironmentStrings(pszHelpString,
                             szBuffer,
                             DimensionOf(szBuffer));

    st.Format(_T("hh.exe %s"), pszHelpString);

    ::CreateProcess(NULL,          // ptr to name of executable
                    (LPTSTR) (LPCTSTR) st,   // pointer to command line string
                    NULL,            // process security attributes
                    NULL,            // thread security attributes
                    FALSE,            // handle inheritance flag
                    CREATE_NEW_CONSOLE,// creation flags
                    NULL,            // ptr to new environment block
                    NULL,            // ptr to current directory name
                    &si,
                    &pi);
    ::CloseHandle(pi.hProcess);
    ::CloseHandle(pi.hThread);
}

#define REGKEY_NETBT_PARAM_W        L"System\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\Tcpip_%s"
#define REGVAL_DISABLE_NETBT        2
#define TCPIP_PARAMETERS_KEY        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\%s"
#define REGISTRATION_ENABLED        L"RegistrationEnabled"
#define REGVAL_NETBIOSOPTIONS_W     L"NetbiosOptions"

HRESULT DisableDDNSandNetBtOnInterface ( IRouterInfo *pRouter, LPCTSTR pszIfName, RtrWizInterface*    pIf)
{
	HRESULT		hr = hrOK;
	DWORD		dwErr = ERROR_SUCCESS;
	RegKey		regkey;
	DWORD		dw = 0;
	WCHAR		szKey[1024] = {0};
	
	//SPIRouter	spRouter = pRouter;
	
	wsprintf ( szKey, TCPIP_PARAMETERS_KEY, pszIfName);
	//Disable Dynamic DNS
	dwErr = regkey.Open(	HKEY_LOCAL_MACHINE, 
						szKey, 
						KEY_ALL_ACCESS, 
						pRouter->GetMachineName()
					  );
	if ( ERROR_SUCCESS != dwErr )
		goto Error;
	
	dwErr = regkey.SetValue ( REGISTRATION_ENABLED, dw );
	if ( ERROR_SUCCESS != dwErr )
		goto Error;

	dwErr = regkey.Close();
	if ( ERROR_SUCCESS != dwErr )
		goto Error;

	//Disable netbt on this interface
	wsprintf ( szKey, REGKEY_NETBT_PARAM_W, pszIfName );
	dwErr = regkey.Open (	HKEY_LOCAL_MACHINE,
							szKey,
							KEY_ALL_ACCESS,
							pRouter->GetMachineName()
						);

	if ( ERROR_SUCCESS != dwErr )
		goto Error;

	dw = REGVAL_DISABLE_NETBT;
	dwErr = regkey.SetValue ( REGVAL_NETBIOSOPTIONS_W, dw );
	if ( ERROR_SUCCESS != dwErr )
		goto Error;
	
	CWRg(dwErr);
Error:

	
	regkey.Close();   
	
    return hr;
}
/*!--------------------------------------------------------------------------
    AddVPNFiltersToInterface
        This will the PPTP and L2TP filters to the public interface.

        This code will OVERWRITE any filters currently in the filter list.

        (for PPTP)
            input/output    IP protocol ID 47
            input/output    TCP source port 1723
            input/output    TCP destination port 1723

        (for L2TP)
            input/output    UDP port 500 (for IPSEC)
            input/output    UDP port 1701
    Author: KennT
 ---------------------------------------------------------------------------*/


// Look at the code below.  After copying the filter over, we will
// convert the source/dest port fields from host to network order!!


static const FILTER_INFO    s_rgVpnInputFilters[] =
{
    // GRE PPTP filter (protocol ID 47)
    { 0, 0, 0, 0, 47,               0,  0,      0 },

    // PPTP filter (source port 1723), TCP established (0x40)
    { 0, 0, 0, 0, FILTER_PROTO_TCP, 0x40,  1723,   0 },

    // PPTP filter (dest port 1723)
    { 0, 0, 0, 0, FILTER_PROTO_TCP, 0,  0,      1723 },

    // IKE filter (dest port = 500)
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  0,    500 },

    // L2TP filter (dest port = 1701)
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  0,   1701 },

    // IKE NAT-T filter (dest port = 4500)
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  0,   4500 }
    
};

static const FILTER_INFO    s_rgVpnOutputFilters[] =
{
    // GRE PPTP filter (protocol ID 47)
    { 0, 0, 0, 0, 47,               0,  0,      0 },

    // PPTP filter (source port 1723)
    { 0, 0, 0, 0, FILTER_PROTO_TCP, 0,  1723,   0 },

    // PPTP filter (dest port 1723)
    { 0, 0, 0, 0, FILTER_PROTO_TCP, 0,  0,      1723 },

    // IKE filter (source port = 500)
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  500,    0 },

    // L2TP filter (source port = 1701
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  1701,   0 },

    // IKE NAT-T filter (source port = 4500)
    { 0, 0, 0, 0, FILTER_PROTO_UDP, 0,  4500,   0 }

};


HRESULT AddVPNFiltersToInterface(IRouterInfo *pRouter, LPCTSTR pszIfName, RtrWizInterface*    pIf)
{
    HRESULT     hr = hrOK;
    SPIInfoBase spInfoBase;
    DWORD       dwSize = 0;
    DWORD       cFilters = 0;
    DWORD        dwIpAddress = 0;
    LPBYTE      pData = NULL;
    FILTER_DESCRIPTOR * pIpfDescriptor = NULL;
    CString        tempAddrList;
    CString        singleAddr;
    FILTER_INFO *pIpfInfo = NULL;
    CDWordArray    arrIpAddr;
    int         i, j;
    USES_CONVERSION;

    CORg( CreateInfoBase( &spInfoBase ) );

    // First, get the proper infobase (the RmIf)
    // ----------------------------------------------------------------
    CORg( RouterEntryLoadInfoBase(pRouter->GetMachineName(),
                                  pszIfName,
                                  PID_IP,
                                  spInfoBase) );

    // collect all the ip addresses on the interface
    tempAddrList = pIf->m_stIpAddress;
    while (!tempAddrList.IsEmpty())
    {
        i = tempAddrList.Find(_T(','));

        if ( i != -1 )
        {
            singleAddr = tempAddrList.Left(i);
            tempAddrList = tempAddrList.Mid(i + 1);
        }
        else
        {
            singleAddr = tempAddrList;
            tempAddrList.Empty();
        }

        dwIpAddress = inet_addr(T2A((LPCTSTR)singleAddr));

        if (INADDR_NONE != dwIpAddress)    // successful
            arrIpAddr.Add(dwIpAddress);
    }

    // Setup the data structure for input filters
    // ----------------------------------------------------------------

    // Calculate the size needed
    // ----------------------------------------------------------------
    cFilters = DimensionOf(s_rgVpnInputFilters);

    // cFilters-1 because FILTER_DESCRIPTOR has one FILTER_INFO object
    // ----------------------------------------------------------------
    dwSize = sizeof(FILTER_DESCRIPTOR) +
                 (cFilters * arrIpAddr.GetSize() - 1) * sizeof(FILTER_INFO);
    pData = new BYTE[dwSize];

    ::ZeroMemory(pData, dwSize);

    // Setup the filter descriptor
    // ----------------------------------------------------------------
    pIpfDescriptor = (FILTER_DESCRIPTOR *) pData;
    pIpfDescriptor->faDefaultAction = DROP;
    pIpfDescriptor->dwNumFilters = cFilters * arrIpAddr.GetSize();
    pIpfDescriptor->dwVersion = IP_FILTER_DRIVER_VERSION_1;


    // Add the various filters to the list
    // input filters
    pIpfInfo = (FILTER_INFO *) pIpfDescriptor->fiFilter;

    // for each ip address on the interface
    for ( j = 0; j < arrIpAddr.GetSize(); j++)
    {

        dwIpAddress = arrIpAddr.GetAt(j);

        for (i=0; i<cFilters; i++, pIpfInfo++)
        {
            *pIpfInfo = s_rgVpnInputFilters[i];

            // Now we convert the appropriate fields from host to
            // network order.
            pIpfInfo->wSrcPort = htons(pIpfInfo->wSrcPort);
            pIpfInfo->wDstPort = htons(pIpfInfo->wDstPort);

            // change dest address and mask
            pIpfInfo->dwDstAddr = dwIpAddress;
            pIpfInfo->dwDstMask = 0xffffffff;
        }


        // inet_addr
    }
    // This will overwrite any of the current filters in the
    // filter list.
    // ----------------------------------------------------------------
    CORg( spInfoBase->AddBlock(IP_IN_FILTER_INFO, dwSize, pData, 1, TRUE) );

    delete [] pData;



    // output filters
    // ----------------------------------------------------------------
    // Setup the data structure for output filters
    // ----------------------------------------------------------------

    // Calculate the size needed
    // ----------------------------------------------------------------
    cFilters = DimensionOf(s_rgVpnOutputFilters);

    // cFilters-1 because FILTER_DESCRIPTOR has one FILTER_INFO object
    // ----------------------------------------------------------------
    dwSize = sizeof(FILTER_DESCRIPTOR) +
                 (cFilters * arrIpAddr.GetSize() - 1) * sizeof(FILTER_INFO);
    pData = new BYTE[dwSize];

    ::ZeroMemory(pData, dwSize);

    // Setup the filter descriptor
    // ----------------------------------------------------------------
    pIpfDescriptor = (FILTER_DESCRIPTOR *) pData;
    pIpfDescriptor->faDefaultAction = DROP;
    pIpfDescriptor->dwNumFilters = cFilters * arrIpAddr.GetSize();
    pIpfDescriptor->dwVersion = IP_FILTER_DRIVER_VERSION_1;


    // Add the various filters to the list
    // input filters
    pIpfInfo = (FILTER_INFO *) pIpfDescriptor->fiFilter;

    // for each ip address on the interface
    for ( j = 0; j < arrIpAddr.GetSize(); j++)
    {

        dwIpAddress = arrIpAddr.GetAt(j);

        for (i=0; i<cFilters; i++, pIpfInfo++)
        {
            *pIpfInfo = s_rgVpnOutputFilters[i];

            // Now we convert the appropriate fields from host to
            // network order.
            pIpfInfo->wSrcPort = htons(pIpfInfo->wSrcPort);
            pIpfInfo->wDstPort = htons(pIpfInfo->wDstPort);

            // change source address and mask
            pIpfInfo->dwSrcAddr = dwIpAddress;
            pIpfInfo->dwSrcMask = 0xffffffff;
        }

    }    // loop for each ip address on the interface

    // This will overwrite any of the current filters in the
    // filter list.
    // ----------------------------------------------------------------
    CORg( spInfoBase->AddBlock(IP_OUT_FILTER_INFO, dwSize, pData, 1, TRUE) );

    // Save the infobase back
    // ----------------------------------------------------------------
    CORg( RouterEntrySaveInfoBase(pRouter->GetMachineName(),
                                  pszIfName,
                                  spInfoBase,
                                  PID_IP) );

Error:
    delete [] pData;
    return hr;
}


HRESULT WINAPI SetupWithCYS (DWORD dwType, PVOID * pOutData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    IRemoteNetworkConfig	*	spNetwork;
	IRouterInfo			*	spRouterInfo;
    COSERVERINFO				csi;
    COAUTHINFO					cai;
    COAUTHIDENTITY				caid;
    IUnknown *					punk = NULL;
    CNewRtrWiz *				pRtrWiz = NULL;
	HRESULT						hr = hrOK;
	TCHAR						szMachineName[MAX_COMPUTERNAME_LENGTH + 1] ={0};
	CString						strRtrWizTitle;
	DWORD						dw = MAX_COMPUTERNAME_LENGTH;
	NewRtrWizData *				pRtrWizData = NULL;

	
	if ( MPRSNAP_CYS_EXPRESS_NAT != dwType && MPRSNAP_CYS_EXPRESS_NONE != dwType )
	{
		hr = HResultFromWin32(ERROR_INVALID_PARAMETER);
		goto Error;
	}

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr) && (RPC_E_CHANGED_MODE != hr))
    {
        return hr;
    }

    //Get Machine Name 
	GetComputerName ( szMachineName, &dw );

	//Create the RouterInfo
    
	hr = CreateRouterInfo(&spRouterInfo, NULL, szMachineName);
	Assert(spRouterInfo != NULL);

    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));

    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;

    hr = CoCreateRouterConfig(szMachineName,
                              spRouterInfo,
                              &csi,
                              IID_IRemoteNetworkConfig,
                              &punk);

    if (FHrOK(hr))
    {
        spNetwork = (IRemoteNetworkConfig *) punk;
        punk = NULL;

        // Upgrade the configuration (ensure that the registry keys
        // are populated correctly).
        // ------------------------------------------------------------
        spNetwork->UpgradeRouterConfig();
    }
    else
    {
        goto Error;
    }

	//
	//Do some of the SecureRouterInfo functionality here
	//
	hr = InitiateServerConnection(szMachineName,
                              NULL,
                              FALSE,
                              spRouterInfo);
    if (!FHrOK(hr))
    {
        // though this case when user chooses cancel on user/password dlg,
        // this is considered as FAIL to connect
        if (hr == S_FALSE)
            hr = HResultFromWin32(ERROR_CANCELLED);
        goto Error;
    }

    hr = spRouterInfo->Load(T2COLE(szMachineName),
                              NULL);

	if ( hrOK != hr )
	{
		goto Error;
	}

    //If ICS/ICF/IC is enabled, then do not allow RRAS to be configured
    if(IsIcsIcfIcEnabled(spRouterInfo)){
       hr = HResultFromWin32(ERROR_CANCELLED);
	goto Error;
    }

	//Create a new router wizard and show it here
    strRtrWizTitle.LoadString(IDS_MENU_RTRWIZ);

    //Load the watermark and
    //set it in  m_spTFSCompData

    InitWatermarkInfo( AfxGetInstanceHandle(),
                       &g_wmi,
                       IDB_WIZBANNER,        // Header ID
                       IDB_WIZWATERMARK,     // Watermark ID
                       NULL,                 // hPalette
                       FALSE);                // bStretch

    
    //
    //we dont have to free handles.  MMC does it for us
    //

    pRtrWiz = new CNewRtrWiz(NULL,
                             spRouterInfo,
                             NULL,
                             NULL,
                             strRtrWizTitle,                             
							 FALSE,
							 MPRSNAP_CYS_EXPRESS_NAT);

    hr = pRtrWiz->Init( spRouterInfo->GetMachineName() );
	if ( hrOK != hr )
    {        
		hr = S_FALSE;
        goto Error;
    }
    else
    {
        hr = pRtrWiz->DoModalWizard();
		//
		//now if the error is S_OK then 
		//send the interface information back to cys
		//
		if ( hrOK == hr )
		{
			//get the interface id and send it back
			if ( MPRSNAP_CYS_EXPRESS_NAT == dwType )
			{
				pRtrWizData = pRtrWiz->GetWizData();
				//
				//get the private interface id
				//and send it back to CYS
				//$TODO: Find a better way of doing this
				//
				//ppvoid that comes in get's the private interface back if any
				//
				if ( !pRtrWizData->m_stPrivateInterfaceId.IsEmpty() )
				{
					*pOutData = LocalAlloc(LPTR, (pRtrWizData->m_stPrivateInterfaceId.GetLength()+ 1) * sizeof(WCHAR) );
					if ( NULL == *pOutData )
					{
						hr = E_OUTOFMEMORY;
						goto Error;
					}
					lstrcpy ( (LPTSTR)(*pOutData), (LPTSTR)(LPCTSTR)pRtrWizData->m_stPrivateInterfaceId );
				}
			}
		}
    }
Error:
	if ( spNetwork ) 
        spNetwork->Release();

    if ( spRouterInfo) 
        spRouterInfo->Release();
    if (
        csi.pAuthInfo && 
        csi.pAuthInfo->pAuthIdentityData->Password
        )
    {    
        delete csi.pAuthInfo->pAuthIdentityData->Password;
    }
    if (pRtrWiz)
        delete pRtrWiz;
	CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrcfg.h ===
///============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    rtrcfg.h
//
// Router configuration property pages
//
//============================================================================

#ifndef _RTRCFG_H
#define _RTRCFG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef __IPCTRL_H
#include "ipctrl.h"
#endif

#ifndef __ATLKENV_H
#include "atlkenv.h"
#endif

#ifndef __IPCTRL_H
#include "ipctrl.h"
#endif

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _ADDRPOOL_H
#include "addrpool.h"
#endif

template <class T> class Ptr {
public:
    T* p;
    Ptr(T* p_=NULL) : p(p_) {}
    ~Ptr(void) { delete p;}
    operator T*(void) { return p; }
    T& operator*(void) { return *p; }
    T* operator->(void) { return p; }
   Ptr& operator=(T* p_)
      {
         delete p;
         p = p_;
         return *this;
      }
};

class RtrCfgSheet;




/*---------------------------------------------------------------------------
   Struct:  AdapterData

   This structure is used to hold information about NICs and their GUIDs
 ---------------------------------------------------------------------------*/
struct AdapterData
{
   CString  m_stFriendlyName;
   CString  m_stGuid;         // the identifying guid
};

typedef CList<AdapterData, AdapterData&> AdapterList;





/*---------------------------------------------------------------------------
	Class:	DATA_SRV_IP

	Data inteface class for IP data.
 ---------------------------------------------------------------------------*/

class DATA_SRV_IP
{
public:

    DWORD   m_dwAllowNetworkAccess;  
    DWORD   m_dwOldAllowNetworkAccess;  
    DWORD   m_dwUseDhcp;             
    AddressPoolList m_addressPoolList;
    CString m_stNetworkAdapterGUID;

    DWORD   m_dwEnableIn;            
	AdapterList m_adapterList;

	//
	// Member variable that control forwarding of NETBT
	// name request broadcasts
	//

	DWORD	m_dwEnableNetbtBcastFwd;
	DWORD	m_dwOldEnableNetbtBcastFwd;
	
    // The next two variables are used by the install wizard
    // specifically for NAT
    CString m_stPrivateAdapterGUID;
    CString m_stPublicAdapterGUID;
    
    DATA_SRV_IP();

    HRESULT	LoadFromReg(LPCTSTR pServerName,
                        const RouterVersionInfo& routerVersion);
    HRESULT SaveToReg(IRouterInfo *pRouter,
                     const RouterVersionInfo& routerVersion);
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
    void	GetDefault();

    BOOL    FNeedRestart();

	HRESULT  LoadAdapters(IRouterInfo *pRouter, AdapterList *pAdapterList);
private:
	BOOL m_fNT4;
    RegKey m_regkey;
    RegKey m_regkeyNT4;
    CString         m_stServerName;
    SPIRouterInfo   m_spRouterInfo;
    RouterVersionInfo   m_routerVersion;
};




/*---------------------------------------------------------------------------
	Class:	DATA_SRV_IPX
 ---------------------------------------------------------------------------*/

class DATA_SRV_IPX
{
public:

    DWORD   m_dwAllowNetworkAccess;
    DWORD   m_dwUseAutoAddr;
    DWORD   m_dwUseSameNetNum;
    DWORD   m_dwAllowClientNetNum;
    DWORD   m_dwIpxNetFirst;
    DWORD   m_dwIpxNetLast;
    DWORD   m_dwEnableIn;

    DWORD   m_fEnableType20Broadcasts;

	DATA_SRV_IPX();

    HRESULT LoadFromReg(LPCTSTR pServerName=NULL, BOOL fNT4 =FALSE);
    HRESULT SaveToReg(IRouterInfo *pRouter);
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
    void GetDefault();

    static const int mc_nIpxNetNumRadix;

private:
	BOOL m_fNT4;
    RegKey m_regkeyNT4;
    RegKey m_regkey;
};




/*---------------------------------------------------------------------------
	Class:	DATA_SRV_NBF
 ---------------------------------------------------------------------------*/

class DATA_SRV_NBF
{
public:
    DWORD   m_dwAllowNetworkAccess;
    DWORD   m_dwOldAllowNetworkAccess;
    DWORD   m_dwEnableIn;            
	DWORD	m_dwOldEnableIn;

    DATA_SRV_NBF();

    HRESULT	LoadFromReg(LPCTSTR pServerName = NULL, BOOL fNT4 = FALSE);
    HRESULT SaveToReg();
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
    void GetDefault();

    BOOL    FNeedRestart();

private:
	BOOL	m_fNT4;
    RegKey	m_regkey;
    RegKey	m_regkeyNT4;
	CString	m_stServerName;
};




/*---------------------------------------------------------------------------
	Class:	DATA_SRV_ARAP
 ---------------------------------------------------------------------------*/

class DATA_SRV_ARAP
{
public:

    DWORD   m_dwEnableIn;             

    DATA_SRV_ARAP();

    HRESULT LoadFromReg(LPCTSTR pServerName = NULL, BOOL fNT4 = FALSE);
    HRESULT SaveToReg();
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
    void GetDefault();

private:
    RegKey m_regkey;
};




/*---------------------------------------------------------------------------
	Class:	DATA_SRV_GENERAL
 ---------------------------------------------------------------------------*/

class DATA_SRV_GENERAL
{
public:

    DWORD   m_dwRouterType;
	DWORD	m_dwOldRouterType;

    DATA_SRV_GENERAL();

    HRESULT	LoadFromReg(LPCTSTR pServerName = NULL);
    HRESULT SaveToReg();
    void	GetDefault();

    BOOL    FNeedRestart();

private:
    RegKey	m_regkey;
    CString m_stServerName;
};




//*****************************************************************
//  PPP configuration
//*****************************************************************

class DATA_SRV_PPP
{
public:

	BOOL  m_fUseMultilink;
	BOOL  m_fUseBACP;
	BOOL  m_fUseLCPExtensions;
	BOOL  m_fUseSwCompression;
	
	DATA_SRV_PPP();
	
    HRESULT LoadFromReg(LPCTSTR pServerName,
						const RouterVersionInfo& routerVersion);
    HRESULT SaveToReg();
    void GetDefault();

private:
    RegKey m_regkey;
	
};




/*---------------------------------------------------------------------------
   Struct:  AuthProviderData

   This structure is used to hold information for Authentication AND
   Accounting providers.
 ---------------------------------------------------------------------------*/
struct AuthProviderData
{
   // The following fields will hold data for ALL auth/acct/EAP providers
   CString  m_stTitle;
   CString  m_stConfigCLSID;  // CLSID for config object
   CString	m_stProviderTypeGUID;	// GUID for the provider type

   // These fields are used by auth/acct providers.
   CString  m_stGuid;         // the identifying guid
   
   // This flag is used for EAP providers
   CString	m_stKey;			// name of registry key (for this provider)
   BOOL  m_fSupportsEncryption;  // used by EAP provider data
   DWORD	m_dwFlags;

   BOOL		m_fConfiguredInThisSession;
};

typedef CList<AuthProviderData, AuthProviderData&> AuthProviderList;





/*---------------------------------------------------------------------------
	Class:	DATA_SRV_AUTH
 ---------------------------------------------------------------------------*/
#define DATA_SRV_AUTH_MAX_SHARED_KEY_LEN		255
class DATA_SRV_AUTH
{
public:

	// The authentication data (as read in from the Rasman flags parameter)
	DWORD m_dwFlags;
	
	// The original auth provider
	CString  m_stGuidOriginalAuthProv;
	
	// The original acct provider
	CString  m_stGuidOriginalAcctProv;
	
	// The current authentication provider
	CString  m_stGuidActiveAuthProv;
	
	// The current accounting provider
	CString  m_stGuidActiveAcctProv;

	//Flag which tells us if the router service is running
	BOOL	m_fRouterRunning;
	// Flag indicating whether or not to use Custom IPSEC policy ( preshared key )
	BOOL	m_fUseCustomIPSecPolicy;

    // Flag which tells whether a restart is required due to changes to PSK
    BOOL    m_fNeedRestart;     

	// Current Preshared Key
	//kmurthy: +1, for the null char
	TCHAR	m_szPreSharedKey[DATA_SRV_AUTH_MAX_SHARED_KEY_LEN+1];

    DATA_SRV_AUTH();

	HRESULT LoadFromReg(LPCTSTR pServerName,
						const RouterVersionInfo& routerVersion);
	HRESULT SaveToReg(HWND hWnd);
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
	void GetDefault();
    BOOL    FNeedRestart() 
    { 
        if ( m_fNeedRestart )
        {
            m_fNeedRestart = FALSE;
            return TRUE; 
        }
        return FALSE;
    }
    
	
	AuthProviderList  m_authProvList;
	AuthProviderList  m_acctProvList;
	AuthProviderList  m_eapProvList;
		
	AuthProviderData *   FindProvData(AuthProviderList &provList,
									  const TCHAR *pszGuid);

private:
	RegKey   m_regkeyAuth;  // reg key of the Router\Auth
	RegKey   m_regkeyAcct;  // reg key of the Router\Acct
	RegKey   m_regkeyRasmanPPP;
	RegKey	 m_regkeyRemoteAccess;	// regkey for RemoteAccess\Parameters
	
	HRESULT  LoadEapProviders(HKEY hkeyBase, AuthProviderList *pProvList);
	HRESULT  LoadProviders(HKEY hkeyBase, AuthProviderList *pProvList);
	HRESULT	 LoadPSK();
	HRESULT  SetNewActiveAuthProvider(HWND hWnd);
	HRESULT  SetNewActiveAcctProvider(HWND hWnd);
	HRESULT  SetPSK();
	CString  m_stServer;
};



/*---------------------------------------------------------------------------
	Class:	DATA_SRV_RASERRLOG
 ---------------------------------------------------------------------------*/
class DATA_SRV_RASERRLOG
{
public:

	DWORD	m_dwLogLevel;
    DWORD   m_dwEnableFileTracing;
    DWORD   m_dwOldEnableFileTracing;
	
	DATA_SRV_RASERRLOG();
	
    HRESULT LoadFromReg(LPCTSTR pszServerName=NULL);
    HRESULT SaveToReg();
    HRESULT	UseDefaults(LPCTSTR pServerName, BOOL fNT4);
    void GetDefault();

    BOOL    FNeedRestart();


private:
    RegKey	m_regkey;
    RegKey  m_regkeyFileLogging;
	CString	m_stServer;
};




/*---------------------------------------------------------------------------
	Class:	RtrGenCfgPage

	General configuration UI
 ---------------------------------------------------------------------------*/

class RtrGenCfgPage : public RtrPropertyPage
{
public:
	RtrGenCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrGenCfgPage();

	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
    
    // Copy the control settings into the DATA_SRV_GENERAL
    void SaveSettings();

	
	//{{AFX_DATA(RtrGenCfgPage)
	//}}AFX_DATA
	
	DATA_SRV_GENERAL m_DataGeneral;
	
	//{{AFX_VIRTUAL(RtrIPCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	void EnableRtrCtrls();

protected:

	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	
	//{{AFX_MSG(RtrGenCfgPage)
	afx_msg void OnButtonClick();
	afx_msg void OnCbSrvAsRtr();
	//}}AFX_MSG
	
	virtual BOOL OnInitDialog();
	
	DECLARE_MESSAGE_MAP()
			
};




/*---------------------------------------------------------------------------
	Class:	RtrAuthCfgPage

	Authentication configuration UI
 ---------------------------------------------------------------------------*/

class RtrAuthCfgPage : public RtrPropertyPage
{

// Construction
public:
	RtrAuthCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrAuthCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
	
	//{{AFX_DATA(RtrAuthCfgPage)
	CComboBox   m_authprov;
	CComboBox   m_acctprov;	
	//}}AFX_DATA
		   
	DATA_SRV_AUTH m_DataAuth;
	
	//{{AFX_VIRTUAL(RtrAuthCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
		
protected:
		
	DWORD				m_dwAuthFlags;    // Flags as enabled
	CString				m_stActiveAuthProv;
	CString				m_stActiveAcctProv;
	RouterVersionInfo	m_RouterInfo;
	void  FillProviderListBox(CComboBox &provCtrl,
							  AuthProviderList &provList,
							  const CString& stGuid);

	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	
	//{{AFX_MSG(RtrAuthCfgPage)
	afx_msg void OnChangeAuthProv();
	afx_msg void OnChangeAcctProv();
	afx_msg void OnConfigureAcctProv();
	afx_msg void OnConfigureAuthProv();
    afx_msg void OnAuthSettings();
	afx_msg void OnChangeCustomPolicySettings();
	afx_msg void OnChangePreSharedKey();
	//}}AFX_MSG
	
	virtual BOOL OnInitDialog();
	
	DECLARE_MESSAGE_MAP()
			
};




/*---------------------------------------------------------------------------
	Class:	RtrIPCfgPage

	IP configuration UI
 ---------------------------------------------------------------------------*/

class RtrIPCfgPage : public RtrPropertyPage
{

// Construction
public:
	RtrIPCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrIPCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
    HRESULT  SaveSettings(HWND hWnd);
	
	//{{AFX_DATA(RtrIPCfgPage)
	enum { IDD = IDD_RTR_IP };
	CComboBox   m_adapter;
	//}}AFX_DATA
	
	DATA_SRV_IP m_DataIP;
	
	//{{AFX_VIRTUAL(RtrIPCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	
protected:
    CListCtrl   m_listCtrl;
	BOOL m_bReady;

	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	void EnableStaticPoolCtrls(BOOL fEnable) ;
	void  FillAdapterListBox(CComboBox &adapterCtrl,
							  AdapterList &adapterList,
							  const CString& stGuid);

	//{{AFX_MSG(RtrIPCfgPage)
	afx_msg void OnAllowRemoteTcpip();
	afx_msg void OnRtrEnableIPRouting();
	afx_msg void OnRtrIPRbDhcp();
	afx_msg void OnRtrIPRbPool();
	afx_msg void OnSelendOkAdapter();
	virtual BOOL OnInitDialog();
    afx_msg void OnBtnAdd();
    afx_msg void OnBtnEdit();
    afx_msg void OnBtnRemove();
	afx_msg void OnEnableNetbtBcastFwd();
    afx_msg void OnListDblClk(NMHDR *, LRESULT *);
    afx_msg void OnListChange(NMHDR *, LRESULT *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};






/*---------------------------------------------------------------------------
	Class:	RtrIPXCfgPage

	IPX configuration UI
 ---------------------------------------------------------------------------*/

class RtrIPXCfgPage : public RtrPropertyPage
{
public:
	RtrIPXCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrIPXCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
	
	DATA_SRV_IPX m_DataIPX;

	//{{AFX_VIRTUAL(RtrIPXCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	
	void EnableNetworkRangeCtrls(BOOL fEnable); 
	
	//{{AFX_MSG(RtrIPXCfgPage)
	afx_msg void OnRtrIPxRbAuto();
	afx_msg void OnRtrIPxRbPool();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSomething();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
			
};


/*---------------------------------------------------------------------------
	Class:	RtrNBFCfgPage

	NetBEUI router configuration UI
 ---------------------------------------------------------------------------*/
class RtrNBFCfgPage : public RtrPropertyPage
{

public:
	RtrNBFCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrNBFCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
	
	DATA_SRV_NBF m_DataNBF;
	
	//{{AFX_VIRTUAL(RtrNBFCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    // Copy the control settings into the DATA_SRV_GENERAL
    void SaveSettings();

protected:
	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	
	//{{AFX_MSG(RtrNBFCfgPage)
	afx_msg void OnButtonClick();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	Class:	RtrARAPCfgPage

	Appletalk routing configuration UI
 ---------------------------------------------------------------------------*/

class RtrARAPCfgPage : public RtrPropertyPage
{
public:
	RtrARAPCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrARAPCfgPage();

	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);

	void EnableSettings(BOOL bEnable);

	//{{AFX_DATA(RtrARAPCfgPage)
	enum { IDD = IDD_RTR_ARAP };
	//}}AFX_DATA

	DATA_SRV_ARAP	m_DataARAP;

	// if the page is changed and applied
	BOOL			m_bApplied;	

	// need to access from the property sheet
    CATLKEnv m_AdapterInfo;

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(RtrARAPCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:

	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;

	//{{AFX_MSG(RtrARAPCfgPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRtrArapCbRemotearap();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};




/*---------------------------------------------------------------------------
	Class:	RtrPPPCfgPage

	PPP options configuration UI
 ---------------------------------------------------------------------------*/

class RtrPPPCfgPage : public RtrPropertyPage
{

// Construction
public:
	RtrPPPCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrPPPCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
	
	//{{AFX_DATA(RtrPPPCfgPage)
	//}}AFX_DATA
	
	DATA_SRV_PPP m_DataPPP;
	
	//{{AFX_VIRTUAL(RtrPPPCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:

	virtual BOOL OnApply();
	RtrCfgSheet* m_pRtrCfgSheet;
	
	//{{AFX_MSG(RtrPPPCfgPage)
	afx_msg void OnButtonClickMultilink();
	afx_msg void OnButtonClick();
	//}}AFX_MSG
	
	virtual BOOL OnInitDialog();
	
	DECLARE_MESSAGE_MAP()

};


/*---------------------------------------------------------------------------
	Class:	RtrLogLevelCfgPage
 ---------------------------------------------------------------------------*/
class RtrLogLevelCfgPage : public RtrPropertyPage
{

// Construction
public:
	RtrLogLevelCfgPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~RtrLogLevelCfgPage();
	
	HRESULT  Init(RtrCfgSheet * pRtrCfgSheet,
				  const RouterVersionInfo& routerVersion);
	
	//{{AFX_DATA(RtrLogLevelCfgPage)
	//}}AFX_DATA
	
	DATA_SRV_RASERRLOG m_DataRASErrLog;
	
	//{{AFX_VIRTUAL(RtrLogLevelCfgPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:

	virtual BOOL OnApply();
	
	RtrCfgSheet* m_pRtrCfgSheet;
	
	//{{AFX_MSG(RtrLogLevelCfgPage)
	afx_msg void OnButtonClick();
	//}}AFX_MSG
	
	virtual BOOL OnInitDialog();
	
    // Copy the control settings into the DATA_SRV_GENERAL
    void SaveSettings();

	DECLARE_MESSAGE_MAP()

};



/*---------------------------------------------------------------------------
	Class:	RtrCfgSheet

	Router configuration property sheet
 ---------------------------------------------------------------------------*/
class RtrCfgSheet :
   public RtrPropertySheet
{
public:
	RtrCfgSheet(ITFSNode *pNode,
				IRouterInfo *pRouter,
				IComponentData *pComponentData,
				ITFSComponentData *pTFSCompData,
				LPCTSTR pszSheetName,
				CWnd *pParent = NULL,
				UINT iPage=0,
				BOOL fScopePane = TRUE);
	
	~RtrCfgSheet();
	
	HRESULT  Init(LPCTSTR pServerName);
	
	virtual BOOL SaveSheetData();
	
	CString m_stServerName;
	BOOL    m_fNT4;
    RouterVersionInfo   m_routerVersion;
	
	SPIRouterInfo	m_spRouter;

    // Helper function - this will prompt the user, stop the service,
    // save changes, and then restart.  This is for those changes
    // that require a restart.  It is placed in a separate function
    // so that the various pages may call this.  The restart will occur
    // only once though.
    // ----------------------------------------------------------------
    HRESULT SaveRequiredRestartChanges(HWND hWnd);
    
	
protected:

	friend class	RtrGenCfgPage;
	friend class	RtrAuthCfgPage;
	friend class	RtrIPCfgPage;
	friend class	RtrIPXCfgPage;
	friend class	RtrNBFCfgPage;
	friend class	RtrARAPCfgPage;

	BOOL m_fIpxLoaded;
	BOOL m_fIpLoaded;
	BOOL m_fNbfLoaded;
	BOOL m_fARAPLoaded;
	
	Ptr<RtrIPCfgPage>       m_pRtrIPCfgPage;
	Ptr<RtrIPXCfgPage>      m_pRtrIPXCfgPage;
	Ptr<RtrNBFCfgPage>      m_pRtrNBFCfgPage;
	Ptr<RtrARAPCfgPage>     m_pRtrARAPCfgPage;
	Ptr<RtrGenCfgPage>      m_pRtrGenCfgPage;
	Ptr<RtrAuthCfgPage>     m_pRtrAuthCfgPage;
	Ptr<RtrPPPCfgPage>      m_pRtrPPPCfgPage;
	Ptr<RtrLogLevelCfgPage>	m_pRtrLogLevelCfgPage;
	
   SPITFSNode           m_spNode;
};



/*---------------------------------------------------------------------------
   class:   EAPConfigurationDlg

   Brings up the list of EAP providers (along with a configure button).
 ---------------------------------------------------------------------------*/

class EAPConfigurationDialog : public CBaseDialog
{
public:
	EAPConfigurationDialog(LPCTSTR pszMachine,
						   AuthProviderList *pProvList) :
			CBaseDialog(IDD_RTR_EAP_CFG),
			m_pProvList(pProvList),
			m_stMachine(pszMachine)
   {};
	~EAPConfigurationDialog();

protected:
	AuthProviderList *m_pProvList;   
	CString        m_stMachine;   // name of the server
	
	CListBox    m_listBox;
	
	//{{AFX_VIRTUAL(EAPConfigurationDialog)
protected:
	virtual VOID   DoDataExchange(CDataExchange *pDX);
	virtual BOOL OnInitDialog();  
	//}}AFX_VIRTUAL
	
	afx_msg  void  OnListChange();

	// config buttion is moved to NAP/Profile/Authentication page
	//	afx_msg  void  OnConfigure();
	
	DECLARE_MESSAGE_MAP()

};

/*---------------------------------------------------------------------------
	Class: AuthenticationSettingsDialog
 ---------------------------------------------------------------------------*/
class AuthenticationSettingsDialog : public CBaseDialog
{
public:
	AuthenticationSettingsDialog(LPCTSTR pszServerName,
                                 AuthProviderList *pProvList) :
			CBaseDialog(IDD_AUTHENTICATION_SETTINGS),
            m_dwFlags(0),
            m_stMachine(pszServerName),
            m_pProvList(pProvList)
   {};

    void    SetAuthFlags(DWORD dwFlags);
    DWORD   GetAuthFlags();

protected:

	void  CheckAuthenticationControls(DWORD dwFlags);
    
    // Read the state of the flags from the checkboxes in the UI
    void    ReadFlagState();

    DWORD   m_dwFlags;

    // Used by the EAP dialog
	AuthProviderList *m_pProvList;   
	CString        m_stMachine;   // name of the server
    
	//{{AFX_VIRTUAL(AuthenticationSettingsDialog)
protected:
	afx_msg void    OnRtrAuthCfgEAP();
	virtual VOID    DoDataExchange(CDataExchange *pDX);
	virtual BOOL    OnInitDialog();
    virtual void    OnOK();
	//}}AFX_VIRTUAL
	

	DECLARE_MESSAGE_MAP()

};




#endif _RTRCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrdata.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    rtrdata.h
	Implementation for router data objects in the MMC

    FILE HISTORY:
	
*/

#ifndef _RTRDATA_H
#define _RTRDATA_H


#ifndef _COMPDATA_H_
#include "compdata.h"
#endif

#ifndef _EXTRACT_H
#include "extract.h"
#endif

class CRouterDataObject :
	public CDataObject
{
public:
	// Derived class should override this for custom behavior
	virtual HRESULT QueryGetMoreData(LPFORMATETC lpFormatEtc);
	virtual HRESULT GetMoreDataHere(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpMedium);

public:
// Construction/Destruction
	// Normal constructor
    CRouterDataObject()
	{
	    DEBUG_INCREMENT_INSTANCE_COUNTER(CRouterDataObject);
	};

    virtual ~CRouterDataObject() 
	{
	    DEBUG_DECREMENT_INSTANCE_COUNTER(CRouterDataObject);
	};

// Implementation
public:
	static unsigned int m_cfComputerName;
	void SetComputerName(LPCTSTR pszComputerName);

    // This gets set if the data object is for the local machine
    static unsigned int m_cfComputerAddedAsLocal;
    void SetComputerAddedAsLocal(BOOL fLocal);

private:
	HRESULT	CreateComputerName(LPSTGMEDIUM lpMedium);
	CString	m_stComputerName;


    HRESULT CreateComputerAddedAsLocal(LPSTGMEDIUM lpMedium);
    BOOL    m_fComputerAddedAsLocal;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrguid.c ===
/*----------------------------------------------------------------------------
	rtrguid.c
		Initialize router GUIDs.

	Copyright (C) Microsoft Corporation, 1993 - 1998
	All rights reserved.

	Authors:
		KennT	Kenn M. Takara, Microsoft

	History:
		05/27/97	kennt	Created
 ----------------------------------------------------------------------------*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "rtrguid.h"
#include <cmnquery.h>
#include <dsquery.h>
#include "ncglobal.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrdata.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    rtrdata.cpp
        Implementation for data objects in the MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrdata.h"
#include "extract.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

// Clipboard formats
unsigned int CRouterDataObject::m_cfComputerName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
unsigned int CRouterDataObject::m_cfComputerAddedAsLocal = RegisterClipboardFormat(L"MMC_MPRSNAP_COMPUTERADDEDASLOCAL");

/////////////////////////////////////////////////////////////////////////////
// CRouterDataObject implementations
DEBUG_DECLARE_INSTANCE_COUNTER(CRouterDataObject);

HRESULT CRouterDataObject::GetMoreDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

	if (cf == m_cfComputerName)
	{
		hr = CreateComputerName(lpMedium);
	}
    else if (cf == m_cfComputerAddedAsLocal)
        hr = CreateComputerAddedAsLocal(lpMedium);

	return hr;
}

HRESULT CRouterDataObject::QueryGetMoreData(LPFORMATETC lpFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    // of these then return invalid.
	if ((lpFormatEtc->cfFormat == m_cfComputerName) ||
        (lpFormatEtc->cfFormat == m_cfComputerAddedAsLocal))
		hr = S_OK;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRouterDataObject creation members

void CRouterDataObject::SetComputerName(LPCTSTR pszComputerName)
{
	m_stComputerName = pszComputerName;
}

HRESULT CRouterDataObject::CreateComputerName(LPSTGMEDIUM lpMedium)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	USES_CONVERSION;

	LPCWSTR	pswz = T2CW((LPCTSTR) m_stComputerName);

	// Create the computer name object
	return Create(pswz, (StrLenW(pswz)+1) * sizeof(WCHAR), lpMedium);
}

void CRouterDataObject::SetComputerAddedAsLocal(BOOL fComputerAddedAsLocal)
{
    m_fComputerAddedAsLocal = fComputerAddedAsLocal;
}

HRESULT CRouterDataObject::CreateComputerAddedAsLocal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_fComputerAddedAsLocal, sizeof(m_fComputerAddedAsLocal),
                  lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrcfg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/
 
/*
   rtrcfg.cpp
      Router configuration property sheet and pages
      
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutilp.h"
#include "ipaddr.h"
#include "rtrcfg.h"
#include "ipctrl.h"
#include "atlkenv.h"
#include "cservice.h"
#include "register.h"
#include "helper.h"
#include "rtrutil.h"
#include "iphlpapi.h"
#include "rtrwiz.h"
#include "snaputil.h"
#include "addrpool.h"
#include "rasdiagp.h"   //rasdiag stuff for trace all command

extern "C" {
#include "rasman.h"
#include "rasppp.h"
};

#include "ipxrtdef.h"
#include "raseapif.h"


#define RAS_LOGGING_NONE        0
#define RAS_LOGGING_ERROR        1
#define RAS_LOGGING_WARN        2
#define RAS_LOGGING_INFO        3

const int c_nRadix10 = 10;

typedef DWORD (APIENTRY* PRASRPCCONNECTSERVER)(LPTSTR, HANDLE *);
typedef DWORD (APIENTRY* PRASRPCDISCONNECTSERVER)(HANDLE);



//**********************************************************************
// General router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrGenCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrGenCfgPage)
ON_BN_CLICKED(IDC_RTR_GEN_CB_SVRASRTR, OnCbSrvAsRtr)
ON_BN_CLICKED(IDC_RTR_GEN_RB_LAN, OnButtonClick)
ON_BN_CLICKED(IDC_RTR_GEN_RB_LANWAN, OnButtonClick)
ON_BN_CLICKED(IDC_RTR_GEN_CB_RAS, OnButtonClick)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
    RtrGenCfgPage::RtrGenCfgPage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
RtrGenCfgPage::RtrGenCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrGenCfgPage)
    //}}AFX_DATA_INIT
}

/*!--------------------------------------------------------------------------
    RtrGenCfgPage::~RtrGenCfgPage
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
RtrGenCfgPage::~RtrGenCfgPage()
{
}

/*!--------------------------------------------------------------------------
    RtrGenCfgPage::DoDataExchange
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrGenCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrGenCfgPage)
    //}}AFX_DATA_MAP
}

/*!--------------------------------------------------------------------------
    RtrGenCfgPage::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  RtrGenCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                             const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataGeneral.LoadFromReg(m_pRtrCfgSheet->m_stServerName);

    return S_OK;
};


/*!--------------------------------------------------------------------------
    RtrGenCfgPage::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RtrGenCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;

    RtrPropertyPage::OnInitDialog();

    CheckRadioButton(IDC_RTR_GEN_RB_LAN,IDC_RTR_GEN_RB_LANWAN,
                     (m_DataGeneral.m_dwRouterType & ROUTER_TYPE_WAN) ? IDC_RTR_GEN_RB_LANWAN : IDC_RTR_GEN_RB_LAN);

    CheckDlgButton(IDC_RTR_GEN_CB_SVRASRTR,
                   (m_DataGeneral.m_dwRouterType & ROUTER_TYPE_LAN) || (m_DataGeneral.m_dwRouterType & ROUTER_TYPE_WAN));

    CheckDlgButton(IDC_RTR_GEN_CB_RAS, m_DataGeneral.m_dwRouterType & ROUTER_TYPE_RAS );

    EnableRtrCtrls();

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}


/*!--------------------------------------------------------------------------
    RtrGenCfgPage::OnApply
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RtrGenCfgPage::OnApply()
{
    BOOL    fReturn=TRUE;
    HRESULT     hr = hrOK;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    // Windows NT Bug : 153007
    // One of the options MUST be selected
    // ----------------------------------------------------------------
    if ((m_DataGeneral.m_dwRouterType & (ROUTER_TYPE_LAN | ROUTER_TYPE_WAN | ROUTER_TYPE_RAS)) == 0)
    {
        AfxMessageBox(IDS_WRN_MUST_SELECT_ROUTER_TYPE);

        // Return to this page
        GetParent()->PostMessage(PSM_SETCURSEL, 0, (LPARAM) GetSafeHwnd());
        return FALSE;
    }

    // This will save the m_DataGeneral, if needed.
    // ----------------------------------------------------------------
    hr = m_pRtrCfgSheet->SaveRequiredRestartChanges(GetSafeHwnd());

    
    if (FHrSucceeded(hr))
            fReturn = RtrPropertyPage::OnApply();
        
    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;
    return fReturn;
}


/*!--------------------------------------------------------------------------
    RtrGenCfgPage::OnButtonClick
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrGenCfgPage::OnButtonClick() 
{
    SaveSettings();
    SetDirty(TRUE);
    SetModified();
}


/*!--------------------------------------------------------------------------
    RtrGenCfgPage::OnCbSrvAsRtr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrGenCfgPage::OnCbSrvAsRtr() 
{
    EnableRtrCtrls();  

    SaveSettings();
    SetDirty(TRUE);
    SetModified();
}

/*!--------------------------------------------------------------------------
    RtrGenCfgPage::EnableRtrCtrls
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrGenCfgPage::EnableRtrCtrls() 
{
    BOOL fEnable=(IsDlgButtonChecked(IDC_RTR_GEN_CB_SVRASRTR)!=0);
    GetDlgItem(IDC_RTR_GEN_RB_LAN)->EnableWindow(fEnable);
    GetDlgItem(IDC_RTR_GEN_RB_LANWAN)->EnableWindow(fEnable);
}

/*!--------------------------------------------------------------------------
    RtrGenCfgPage::SaveSettings
        
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrGenCfgPage::SaveSettings()
{
    // Clear the router type of flags
    // ----------------------------------------------------------------
    m_DataGeneral.m_dwRouterType &= ~(ROUTER_TYPE_LAN | ROUTER_TYPE_WAN | ROUTER_TYPE_RAS);

    // Get the actual type
    // ----------------------------------------------------------------
    if ( IsDlgButtonChecked(IDC_RTR_GEN_CB_SVRASRTR) )
    {
        if ( IsDlgButtonChecked(IDC_RTR_GEN_RB_LAN) )
            m_DataGeneral.m_dwRouterType |=  ROUTER_TYPE_LAN;
        else
            m_DataGeneral.m_dwRouterType |=  (ROUTER_TYPE_WAN | ROUTER_TYPE_LAN);
    }

    if ( IsDlgButtonChecked(IDC_RTR_GEN_CB_RAS) )
    {
        m_DataGeneral.m_dwRouterType |=  ROUTER_TYPE_RAS;
    }    
}


//**********************************************************************
// Authentication router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrAuthCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrAuthCfgPage)
ON_BN_CLICKED(IDC_RTR_AUTH_BTN_AUTHCFG, OnConfigureAuthProv)
ON_BN_CLICKED(IDC_RTR_AUTH_BTN_ACCTCFG, OnConfigureAcctProv)
ON_BN_CLICKED(IDC_RTR_AUTH_BTN_SETTINGS, OnAuthSettings)
ON_BN_CLICKED(IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY, OnChangeCustomPolicySettings)
ON_CBN_SELENDOK(IDC_RTR_AUTH_COMBO_AUTHPROV, OnChangeAuthProv)
ON_CBN_SELENDOK(IDC_RTR_AUTH_COMBO_ACCTPROV, OnChangeAcctProv)
ON_EN_CHANGE(IDC_TXT_PRESHARED_KEY, OnChangePreSharedKey)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RtrAuthCfgPage::RtrAuthCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption),
m_dwAuthFlags(0)
{
    //{{AFX_DATA_INIT(RtrAuthCfgPage)
    //}}AFX_DATA_INIT
}

RtrAuthCfgPage::~RtrAuthCfgPage()
{
}

void RtrAuthCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrAuthCfgPage)
    DDX_Control(pDX, IDC_RTR_AUTH_COMBO_AUTHPROV, m_authprov);
    DDX_Control(pDX, IDC_RTR_AUTH_COMBO_ACCTPROV, m_acctprov);    
    //}}AFX_DATA_MAP

}

HRESULT  RtrAuthCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                              const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataAuth.LoadFromReg(m_pRtrCfgSheet->m_stServerName,
                           routerVersion);

    // initialize our settings
    // ----------------------------------------------------------------
    m_dwAuthFlags = m_DataAuth.m_dwFlags;
    m_stActiveAuthProv = m_DataAuth.m_stGuidActiveAuthProv;
    m_stActiveAcctProv = m_DataAuth.m_stGuidActiveAcctProv;    
    m_RouterInfo = routerVersion;
    return S_OK;
};


BOOL RtrAuthCfgPage::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr= hrOK;
    int         iRow;
    CString     st;

    RtrPropertyPage::OnInitDialog();

    // Add the providers to the listboxes
    // ----------------------------------------------------------------
    FillProviderListBox(m_authprov, m_DataAuth.m_authProvList,
                        m_stActiveAuthProv);


    // Trigger the changes made to the combo box
    // ----------------------------------------------------------------
    OnChangeAuthProv();

    if ( m_DataAuth.m_authProvList.GetCount() == 0 )
    {
        m_authprov.InsertString(0, _T("No providers available"));
        m_authprov.SetCurSel(0);
        m_authprov.EnableWindow(FALSE);
        GetDlgItem(IDC_RTR_AUTH_BTN_AUTHCFG)->EnableWindow(FALSE);
    }

    FillProviderListBox(m_acctprov, m_DataAuth.m_acctProvList,
                        m_stActiveAcctProv);

    // Windows NT bug : 132649, need to add <none> as an option
    // ----------------------------------------------------------------
    st.LoadString(IDS_ACCOUNTING_PROVIDERS_NONE);
    iRow = m_acctprov.InsertString(0, st);
    Assert(iRow == 0);
    m_acctprov.SetItemData(iRow, 0);
    if ( m_acctprov.GetCurSel() == LB_ERR )
        m_acctprov.SetCurSel(0);

    // Trigger the changes made to the combo box
    // ----------------------------------------------------------------
    OnChangeAcctProv();

    //Check to see if the router version 
    if ( m_RouterInfo.dwOsBuildNo > RASMAN_PPP_KEY_LAST_WIN2k_VERSION)
    {
        //If this is > win2k then 
        //Set the initial state state etc.
        //if ( IsRouterServiceRunning(m_pRtrCfgSheet->m_stServerName, NULL) == hrOK )
        if ( m_DataAuth.m_fRouterRunning )
        {
            CheckDlgButton(IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY, m_DataAuth.m_fUseCustomIPSecPolicy);
            //kmurthy: adding +1 because, we need to have space for the null char
            GetDlgItem(IDC_TXT_PRESHARED_KEY)->SendMessage(EM_LIMITTEXT, DATA_SRV_AUTH_MAX_SHARED_KEY_LEN, 0L);
            if ( m_DataAuth.m_fUseCustomIPSecPolicy )
            {
                //populate the pre-shared key field            
                GetDlgItem(IDC_TXT_PRESHARED_KEY)->SetWindowText(m_DataAuth.m_szPreSharedKey);
            }
            else
            {
                GetDlgItem(IDC_STATIC_PRESHARED_KEY1)->EnableWindow(FALSE);
                GetDlgItem(IDC_TXT_PRESHARED_KEY)->EnableWindow(FALSE);
            }
        }
        else
        {
            GetDlgItem(IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY)->EnableWindow(FALSE);
            GetDlgItem(IDC_STATIC_PRESHARED_KEY1)->EnableWindow(FALSE);
            GetDlgItem(IDC_TXT_PRESHARED_KEY)->EnableWindow(FALSE);
        }

    }
    else
    {
        //hide all the related fields
        GetDlgItem(IDC_STATIC_PRESHARED_KEY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC_PRESHARED_KEY1)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->ShowWindow(SW_HIDE);

    }

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}




/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::OnApply
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RtrAuthCfgPage::OnApply()
{
    BOOL fReturn=TRUE;
    HRESULT     hr = hrOK;
    RegKey      regkey;
    DWORD       dwAuthMask;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    // check to see if user's chosen a new provider without configure it 
    // authentication
    // ----------------------------------------------------------------
    if ( m_stActiveAuthProv != m_DataAuth.m_stGuidActiveAuthProv )
    {
        AuthProviderData *   pData = NULL;

        // Find if configure has been called
        // ----------------------------------------------------------------
        pData = m_DataAuth.FindProvData(m_DataAuth.m_authProvList, m_stActiveAuthProv);

        // ------------------------------------------------------------
        if (pData && !pData->m_stConfigCLSID.IsEmpty() && !pData->m_fConfiguredInThisSession)
        {
            CString    str1, str;
            str1.LoadString(IDS_WRN_AUTH_CONFIG_AUTH);
            str.Format(str1, pData->m_stTitle);
            
            if ( AfxMessageBox(str, MB_YESNO) == IDYES )
                OnConfigureAuthProv();
        }
    }
        
    // accounting
    // Warn the user that they will need to restart the server in
    // order to change the accounting provider.
    // ----------------------------------------------------------------
    if ( m_stActiveAcctProv != m_DataAuth.m_stGuidOriginalAcctProv )
    {
        AuthProviderData *   pData = NULL;

        // Find if configure has been called
        // ----------------------------------------------------------------
        pData = m_DataAuth.FindProvData(m_DataAuth.m_acctProvList, m_stActiveAcctProv);

        // 
        if (pData && !pData->m_stConfigCLSID.IsEmpty() && !pData->m_fConfiguredInThisSession)
        {
            CString    str1, str;
            str1.LoadString(IDS_WRN_AUTH_CONFIG_ACCT);
            str.Format(str1, pData->m_stTitle);
            
            if ( AfxMessageBox(str, MB_YESNO) == IDYES )
                OnConfigureAcctProv();
        }
    }
    
    
    

    // Check to see if one of the "special" provider flags has
    // changed.  If so, then we bring up a help dialog.
    // ----------------------------------------------------------------

    // Create a mask of the authorization flags
    // Add in IPSec so that it doesn't cause us to bring up the
    // dialog unnecessarily.
    dwAuthMask = ~((m_DataAuth.m_dwFlags | PPPCFG_RequireIPSEC) & USE_PPPCFG_AUTHFLAGS);

    // Check to see if any of the bits were flipped
    if (dwAuthMask & (m_dwAuthFlags & USE_PPPCFG_AUTHFLAGS))
    {
        // Bring up the messsagebox here.
        if (AfxMessageBox(IDS_WRN_MORE_STEPS_FOR_AUTHEN, MB_YESNO) == IDYES)
        {
            HtmlHelpA(NULL, c_sazAuthenticationHelpTopic, HH_DISPLAY_TOPIC, 0);
        }
    }
    
    // Check to see if user has chosen a custom ipsec policy with no preshared key 
    if ( m_DataAuth.m_fUseCustomIPSecPolicy )
    {
        //Get the preshared key
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->GetWindowText(m_DataAuth.m_szPreSharedKey, DATA_SRV_AUTH_MAX_SHARED_KEY_LEN+1);

        if ( !_tcslen(m_DataAuth.m_szPreSharedKey) )
        {
            //Show a error message
            AfxMessageBox ( IDS_ERR_NO_PRESHARED_KEY, MB_OK);
            return FALSE;
        }
    }
    

    // Windows NT Bug : 292661
    // Only do these checks if the router is started, if it's not
    // started, then they don't matter.
    // ----------------------------------------------------------------
    //if (FHrOK(IsRouterServiceRunning(m_pRtrCfgSheet->m_stServerName, NULL)))
    if ( m_DataAuth.m_fRouterRunning )
    {
/*
// fix 121763
        // fix 8155    rajeshp    06/15/1998    RADIUS: Updating of the radius server entries in the snapin requires a restart of remoteaccess.
        DWORD    dwMajor = 0, dwMinor = 0, dwBuildNo = 0;
        HKEY    hkeyMachine = NULL;

        // Ignore the failure code, what else can we do?
        // ------------------------------------------------------------
        DWORD    dwErr = ConnectRegistry(m_pRtrCfgSheet->m_stServerName, &hkeyMachine);
        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = GetNTVersion(hkeyMachine, &dwMajor, &dwMinor, &dwBuildNo);            
            DisconnectRegistry(hkeyMachine);
        }

        DWORD    dwVersionCombine = MAKELONG( dwBuildNo, MAKEWORD(dwMinor, dwMajor));
        DWORD    dwVersionCombineNT50 = MAKELONG ( VER_BUILD_WIN2K, MAKEWORD(VER_MINOR_WIN2K, VER_MAJOR_WIN2K));

        // if the version is greater than Win2K release
        if(dwVersionCombine > dwVersionCombineNT50)
            ;    // skip the restart message
        else
*/
// end if fix 8155
       {
            // Warn the user that they will need to restart the server in
            // order to change the authentication provider.
            // ----------------------------------------------------------------
            if ( m_stActiveAuthProv != m_DataAuth.m_stGuidActiveAuthProv )
            {
                if ( AfxMessageBox(IDS_WRN_AUTH_RESTART_NEEDED, MB_OKCANCEL) != IDOK )
                    return FALSE;
            }
        
            // Warn the user that they will need to restart the server in
            // order to change the accounting provider.
            // ----------------------------------------------------------------
            if ( m_stActiveAcctProv != m_DataAuth.m_stGuidOriginalAcctProv )
            {
                if ( AfxMessageBox(IDS_WRN_ACCT_RESTART_NEEDED, MB_OKCANCEL) != IDOK )
                    return FALSE;
            }
        }
    }
        
    // Copy the data over to the DataAuth
    // ----------------------------------------------------------------
    m_DataAuth.m_dwFlags = m_dwAuthFlags;
    m_DataAuth.m_stGuidActiveAuthProv = m_stActiveAuthProv;
    m_DataAuth.m_stGuidActiveAcctProv = m_stActiveAcctProv;


    hr = m_pRtrCfgSheet->SaveRequiredRestartChanges(GetSafeHwnd());

    fReturn = RtrPropertyPage::OnApply();

    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;
    return fReturn;
}


/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::FillProviderListBox
      Fill in provCtrl with the data provider from provList.
   Author: KennT
 ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::FillProviderListBox(CComboBox& provCtrl,
                                         AuthProviderList& provList,
                                         const CString& stGuid)
{
    POSITION pos;
    AuthProviderData *   pData;
    int         cRows = 0;
    int         iSel = -1;
    int         iRow;
    TCHAR        szAcctGuid[128];
    TCHAR        szAuthGuid[128];

    StringFromGUID2(GUID_AUTHPROV_RADIUS, szAuthGuid, DimensionOf(szAuthGuid));
    StringFromGUID2(GUID_ACCTPROV_RADIUS, szAcctGuid, DimensionOf(szAcctGuid));

    pos = provList.GetHeadPosition();

    while ( pos )
    {
        pData = &provList.GetNext(pos);
        
        // Windows NT Bug : 127189
        // If IP is not installed, and this is RADIUS, do not
        // show the RADIUS provider. (For both auth and acct).
        // ------------------------------------------------------------
        if (!m_pRtrCfgSheet->m_fIpLoaded &&
            ((pData->m_stProviderTypeGUID.CompareNoCase(szAuthGuid) == 0) ||
             (pData->m_stProviderTypeGUID.CompareNoCase(szAcctGuid) == 0))
           )
        {
            continue;
        }

        // Ok, this is a valid entry, add it to the list box
        // ------------------------------------------------------------
        iRow = provCtrl.InsertString(cRows, pData->m_stTitle);
        provCtrl.SetItemData(iRow, (LONG_PTR) pData);

        // Now we need to look for the match with the active provider
        // ------------------------------------------------------------
        if ( StriCmp(pData->m_stGuid, stGuid) == 0 )
            iSel = iRow;

        cRows ++;
    }

    if ( iSel != -1 )
        provCtrl.SetCurSel(iSel);
}

void RtrAuthCfgPage::OnChangePreSharedKey()
{
    SetDirty(TRUE);
    SetModified();
}

void RtrAuthCfgPage::OnChangeCustomPolicySettings()
{
    
    //Custom policy check box has been toggled.
    //Get the state here and either 
    m_DataAuth.m_fUseCustomIPSecPolicy = IsDlgButtonChecked(IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY);
    
    if ( m_DataAuth.m_fUseCustomIPSecPolicy )
    {
        //populate the pre-shared key field            
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->SetWindowText(m_DataAuth.m_szPreSharedKey);
        GetDlgItem(IDC_STATIC_PRESHARED_KEY1)->EnableWindow(TRUE);
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->EnableWindow(TRUE);

    }
    else
    {
        //erase the pre-shared key
        
        m_DataAuth.m_szPreSharedKey[0]= 0;
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->SetWindowText(m_DataAuth.m_szPreSharedKey);
        GetDlgItem(IDC_STATIC_PRESHARED_KEY1)->EnableWindow(FALSE);
        GetDlgItem(IDC_TXT_PRESHARED_KEY)->EnableWindow(FALSE);
    }
    SetDirty(TRUE);
    SetModified();
}
/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::OnChangeAuthProv
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::OnChangeAuthProv()
{
    AuthProviderData *   pData;
    int               iSel;

    iSel = m_authprov.GetCurSel();
    if ( iSel == LB_ERR )
    {
        GetDlgItem(IDC_RTR_AUTH_BTN_AUTHCFG)->EnableWindow(FALSE);
        return;
    }

    pData = (AuthProviderData *) m_authprov.GetItemData(iSel);
    Assert(pData);

    m_stActiveAuthProv = pData->m_stGuid;

    GetDlgItem(IDC_RTR_AUTH_BTN_AUTHCFG)->EnableWindow(
                                                      !pData->m_stConfigCLSID.IsEmpty());

    SetDirty(TRUE);
    SetModified();
}

/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::OnChangeAcctProv
      -
   Author: KennT
   ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::OnChangeAcctProv()
{
    AuthProviderData *   pData;
    int               iSel;

    iSel = m_acctprov.GetCurSel();
    if ( iSel == LB_ERR )
    {
        GetDlgItem(IDC_RTR_AUTH_BTN_ACCTCFG)->EnableWindow(FALSE);
        return;
    }

    pData = (AuthProviderData *) m_acctprov.GetItemData(iSel);
    if ( pData )
    {
        m_stActiveAcctProv = pData->m_stGuid;

        GetDlgItem(IDC_RTR_AUTH_BTN_ACCTCFG)->EnableWindow(
                                                          !pData->m_stConfigCLSID.IsEmpty());
    }
    else
    {
        m_stActiveAcctProv.Empty();
        GetDlgItem(IDC_RTR_AUTH_BTN_ACCTCFG)->EnableWindow(FALSE);
    }

    SetDirty(TRUE);
    SetModified();  
}

/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::OnConfigureAcctProv
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::OnConfigureAcctProv()
{
    AuthProviderData *   pData = NULL;
    GUID     guid;
    SPIAccountingProviderConfig   spAcctConfig;
    HRESULT     hr = hrOK;
    ULONG_PTR    uConnection = 0;

    // Find the ConfigCLSID for this Guid
    // ----------------------------------------------------------------
    pData = m_DataAuth.FindProvData(m_DataAuth.m_acctProvList,
                                    m_stActiveAcctProv);

    // Did we find a provider?
    // ----------------------------------------------------------------
    if ( pData == NULL )
    {
        Panic0("Should have found a provider");
        return;
    }

    CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID), &guid) );

    // Create the EAP provider object
    // ----------------------------------------------------------------
    CORg( CoCreateInstance(guid,
                           NULL,
                           CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                           IID_IAccountingProviderConfig,
                           (LPVOID *) &spAcctConfig) );

    hr = spAcctConfig->Initialize(m_pRtrCfgSheet->m_stServerName,
                                  &uConnection);

    if ( FHrSucceeded(hr) )
    {
        hr = spAcctConfig->Configure(uConnection,
                                     GetSafeHwnd(),
                                     m_dwAuthFlags,
                                     0, 0);
        // mark this provider has been configured                                     
        if (hr == S_OK)
            pData->m_fConfiguredInThisSession = TRUE;
            

        spAcctConfig->Uninitialize(uConnection);
    }
    if ( hr == E_NOTIMPL )
        hr = hrOK;
    CORg( hr );

    Error:
    if ( !FHrSucceeded(hr) )
        DisplayTFSErrorMessage(GetSafeHwnd());
}

/*!--------------------------------------------------------------------------
   RtrAuthCfgPage::OnConfigureAuthProv
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::OnConfigureAuthProv()
{
    AuthProviderData *   pData = NULL;
    GUID     guid;
    SPIAuthenticationProviderConfig  spAuthConfig;
    HRESULT     hr = hrOK;
    ULONG_PTR    uConnection = 0;

    // Find the ConfigCLSID for this Guid
    // ----------------------------------------------------------------
    pData = m_DataAuth.FindProvData(m_DataAuth.m_authProvList,
                                    m_stActiveAuthProv);

    // Did we find a provider?
    // ----------------------------------------------------------------
    if ( pData == NULL )
    {
        Panic0("Should have found a provider");
        return;
    }

    CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID), &guid) );

    // Create the EAP provider object
    // ----------------------------------------------------------------
    CORg( CoCreateInstance(guid,
                           NULL,
                           CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                           IID_IAuthenticationProviderConfig,
                           (LPVOID *) &spAuthConfig) );

    hr = spAuthConfig->Initialize(m_pRtrCfgSheet->m_stServerName,
                                  &uConnection);

    if (FHrSucceeded(hr))
    {
        hr = spAuthConfig->Configure(uConnection,
                                     GetSafeHwnd(),
                                     m_dwAuthFlags,
                                     0, 0);
                                     
        // mark this provider has been configured                                     
        if (hr == S_OK)
            pData->m_fConfiguredInThisSession = TRUE;
            
        spAuthConfig->Uninitialize(uConnection);
    }
    if ( hr == E_NOTIMPL )
        hr = hrOK;
    CORg( hr );

    Error:
    if ( !FHrSucceeded(hr) )
        DisplayTFSErrorMessage(GetSafeHwnd());

}

/*!--------------------------------------------------------------------------
    RtrAuthCfgPage::OnAuthSettings
        Bring up the settings dialog
    Author: KennT
 ---------------------------------------------------------------------------*/
void RtrAuthCfgPage::OnAuthSettings()
{
    AuthenticationSettingsDialog    dlg(m_pRtrCfgSheet->m_stServerName,
                                        &m_DataAuth.m_eapProvList);

    dlg.SetAuthFlags(m_dwAuthFlags);

    if (dlg.DoModal() == IDOK)
    {
        m_dwAuthFlags = dlg.GetAuthFlags();
        
        SetDirty(TRUE);
        SetModified();  
    }
}

//**********************************************************************
// ARAP router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrARAPCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrARAPCfgPage)
ON_BN_CLICKED(IDC_RTR_ARAP_CB_REMOTEARAP, OnRtrArapCbRemotearap)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

RtrARAPCfgPage::RtrARAPCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrARAPCfgPage)
    //}}AFX_DATA_INIT

    m_bApplied = FALSE;
}

RtrARAPCfgPage::~RtrARAPCfgPage()
{
}

HRESULT  RtrARAPCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                              const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;

    m_DataARAP.LoadFromReg(m_pRtrCfgSheet->m_stServerName, m_pRtrCfgSheet->m_fNT4);

    return S_OK;
};


BOOL RtrARAPCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;
    CWaitCursor wait;
    BOOL        bEnable;

    m_bApplied = FALSE;
    RtrPropertyPage::OnInitDialog();

    if ( m_pRtrCfgSheet->m_fNT4 )
    {
        bEnable = FALSE;
        GetDlgItem(IDC_RTR_ARAP_CB_REMOTEARAP)->EnableWindow(FALSE);
    }
    else
    {
        CheckDlgButton(IDC_RTR_ARAP_CB_REMOTEARAP, m_DataARAP.m_dwEnableIn );
        bEnable = m_DataARAP.m_dwEnableIn;
    }

    m_AdapterInfo.SetServerName(m_pRtrCfgSheet->m_stServerName);
    m_AdapterInfo.GetAdapterInfo();
    if ( !FHrSucceeded(m_AdapterInfo.GetAdapterInfo()) )
    {
        wait.Restore();
        AfxMessageBox(IDS_ERR_ARAP_NOADAPTINFO);
    }

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}

BOOL RtrARAPCfgPage::OnApply()
{
    BOOL fReturn=TRUE;
    HRESULT     hr = hrOK;
    CString szLower, szUpper;
    CString szZone;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    m_DataARAP.m_dwEnableIn = IsDlgButtonChecked(IDC_RTR_ARAP_CB_REMOTEARAP);
    
    m_bApplied = TRUE;

    fReturn = RtrPropertyPage::OnApply();

    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;

    return fReturn;
}


void RtrARAPCfgPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrARAPCfgPage)
    //}}AFX_DATA_MAP
}

void RtrARAPCfgPage::OnRtrArapCbRemotearap() 
{
    SetDirty(TRUE);
    SetModified();
}

//**********************************************************************
// IP router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrIPCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrIPCfgPage)
ON_BN_CLICKED(IDC_RTR_IP_CB_ALLOW_REMOTETCPIP, OnAllowRemoteTcpip)
ON_BN_CLICKED(IDC_RTR_IP_BTN_ENABLE_IPROUTING, OnRtrEnableIPRouting)
ON_BN_CLICKED(IDC_RTR_IP_RB_DHCP, OnRtrIPRbDhcp)
ON_BN_CLICKED(IDC_RTR_IP_RB_POOL, OnRtrIPRbPool)
ON_CBN_SELENDOK(IDC_RTR_IP_COMBO_ADAPTER, OnSelendOkAdapter)
ON_BN_CLICKED(IDC_RTR_IP_BTN_ADD, OnBtnAdd)
ON_BN_CLICKED(IDC_RTR_IP_BTN_EDIT, OnBtnEdit)
ON_BN_CLICKED(IDC_RTR_IP_BTN_REMOVE, OnBtnRemove)
ON_BN_CLICKED(IDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD, OnEnableNetbtBcastFwd)
ON_NOTIFY(NM_DBLCLK, IDC_RTR_IP_LIST, OnListDblClk)
ON_NOTIFY(LVN_ITEMCHANGED, IDC_RTR_IP_LIST, OnListChange)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RtrIPCfgPage::RtrIPCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption), m_bReady(FALSE)
{
    //{{AFX_DATA_INIT(RtrIPCfgPage)
    //}}AFX_DATA_INIT
}

RtrIPCfgPage::~RtrIPCfgPage()
{
}

void RtrIPCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrIPCfgPage)
    DDX_Control(pDX, IDC_RTR_IP_COMBO_ADAPTER, m_adapter);
    DDX_Control(pDX, IDC_RTR_IP_LIST, m_listCtrl);
    //}}AFX_DATA_MAP
}

HRESULT  RtrIPCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                            const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataIP.LoadFromReg(m_pRtrCfgSheet->m_stServerName,
                         routerVersion);

    return S_OK;
};

void RtrIPCfgPage::FillAdapterListBox(CComboBox& adapterCtrl,
                                         AdapterList& adapterList,
                                         const CString& stGuid)
{
    POSITION pos;
    AdapterData *   pData;
    int         cRows = 0;
    int         iSel = -1;
    int         iRow;

    pos = adapterList.GetHeadPosition();

    while ( pos )
    {
        pData = &adapterList.GetNext(pos);
        iRow = adapterCtrl.InsertString(cRows, pData->m_stFriendlyName);
        adapterCtrl.SetItemData(iRow, (LONG_PTR) pData);

        // Now we need to look for the match with the active provider
        // ------------------------------------------------------------
        if ( StriCmp(pData->m_stGuid, stGuid) == 0 )
            iSel = iRow;

        cRows ++;
    }

    if ( iSel != -1 )
        adapterCtrl.SetCurSel(iSel);

    if ( cRows <= 2 )
    {
        // 2: One for the NIC and one for "allow RAS to select"
        adapterCtrl.ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RTR_IP_TEXT_ADAPTER)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RTR_IP_TEXT_LABEL_ADAPTER)->ShowWindow(SW_HIDE);
    }
}


/*!--------------------------------------------------------------------------
    RtrIPCfgPage::OnInitDialog
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RtrIPCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;

    RtrPropertyPage::OnInitDialog();

    CheckDlgButton(IDC_RTR_IP_CB_ALLOW_REMOTETCPIP,
                   m_DataIP.m_dwEnableIn);

    CheckRadioButton(IDC_RTR_IP_RB_DHCP, IDC_RTR_IP_RB_POOL,
                     (m_DataIP.m_dwUseDhcp) ? IDC_RTR_IP_RB_DHCP : IDC_RTR_IP_RB_POOL);

    CheckDlgButton(IDC_RTR_IP_BTN_ENABLE_IPROUTING, m_DataIP.m_dwAllowNetworkAccess );

    CheckDlgButton(
        IDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD,
        m_DataIP.m_dwEnableNetbtBcastFwd
        );
                
    m_bReady=TRUE;

    InitializeAddressPoolListControl(&m_listCtrl,
                                     ADDRPOOL_LONG,
                                     &m_DataIP.m_addressPoolList);

    //enable/disable static pools fields
    // ----------------------------------------------------------------
    EnableStaticPoolCtrls( m_DataIP.m_dwUseDhcp==0 );

    // Load the information for all of the adapters
    // ----------------------------------------------------------------
    m_DataIP.LoadAdapters(m_pRtrCfgSheet->m_spRouter,
                          &m_DataIP.m_adapterList);

    // Add the adapters to the listbox
    // ----------------------------------------------------------------
    FillAdapterListBox(m_adapter, m_DataIP.m_adapterList,
                       m_DataIP.m_stNetworkAdapterGUID);

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}



BOOL RtrIPCfgPage::OnApply()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    BOOL fReturn=TRUE;
    HRESULT     hr = hrOK;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    hr = m_pRtrCfgSheet->SaveRequiredRestartChanges(GetSafeHwnd());

    fReturn = RtrPropertyPage::OnApply();

    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;
    return fReturn;
}

HRESULT RtrIPCfgPage::SaveSettings(HWND hWnd)
{
    DWORD    dwAddr;
    DWORD    dwMask;
    DWORD    dwUseDhcp;
    AdapterData *   pData;
    int     iSel;
    CString    stAddr, stMask, stRange, stInvalidRange;
    HRESULT hr = hrOK;

    if (!IsDirty())
        return hr;
    
    dwUseDhcp = IsDlgButtonChecked(IDC_RTR_IP_RB_DHCP);
    
    if (dwUseDhcp)
    {
//24323    Static IP address pools should be persisted in UI, even when DCHP is chosen.

//        m_DataIP.m_addressPoolList.RemoveAll();
    }
    else
    {
        // Check to see that we have at least one address pool
        // ------------------------------------------------------------
        if (m_DataIP.m_addressPoolList.GetCount() == 0)
        {
            AfxMessageBox(IDS_ERR_ADDRESS_POOL_IS_EMPTY);
            return E_FAIL;
        }
    }

    if (FHrSucceeded(hr))
    {
        m_DataIP.m_dwEnableIn = IsDlgButtonChecked(IDC_RTR_IP_CB_ALLOW_REMOTETCPIP);
        m_DataIP.m_dwAllowNetworkAccess = IsDlgButtonChecked(IDC_RTR_IP_BTN_ENABLE_IPROUTING);
        m_DataIP.m_dwUseDhcp = dwUseDhcp;
        m_DataIP.m_dwEnableNetbtBcastFwd = 
            IsDlgButtonChecked(IDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD);
    }

    iSel = m_adapter.GetCurSel();
    if ( iSel == LB_ERR )
    {
        iSel = 0;
    }

    pData = (AdapterData *) m_adapter.GetItemData(iSel);
    Assert(pData);

    m_DataIP.m_stNetworkAdapterGUID = pData->m_stGuid;

    return hr;
}

void RtrIPCfgPage::OnAllowRemoteTcpip() 
{
    SetDirty(TRUE);
    SetModified();
}

void RtrIPCfgPage::OnRtrEnableIPRouting() 
{
    SetDirty(TRUE);
    SetModified();
}

void RtrIPCfgPage::OnRtrIPRbDhcp() 
{
    EnableStaticPoolCtrls(FALSE);
    SetDirty(TRUE);
    SetModified();
}


void RtrIPCfgPage::EnableStaticPoolCtrls(BOOL fEnable) 
{
    MultiEnableWindow(GetSafeHwnd(),
                      fEnable,
                      IDC_RTR_IP_BTN_ADD,
                      IDC_RTR_IP_BTN_EDIT,
                      IDC_RTR_IP_BTN_REMOVE,
                      IDC_RTR_IP_LIST,
                      0);

    if (fEnable)
    {
        if ((m_listCtrl.GetItemCount() == 0) ||
            (m_listCtrl.GetNextItem(-1, LVNI_SELECTED) == -1))
        {
            MultiEnableWindow(GetSafeHwnd(),
                              FALSE,
                              IDC_RTR_IP_BTN_EDIT,
                              IDC_RTR_IP_BTN_REMOVE,
                              0);
        }

        // If we have > 0 items and we do not support multiple
        // address pools then stop
        if ((m_listCtrl.GetItemCount() > 0) &&
            !m_DataIP.m_addressPoolList.FUsesMultipleAddressPools())
        {
            MultiEnableWindow(GetSafeHwnd(),
                              FALSE,
                              IDC_RTR_IP_BTN_ADD,
                              0);
        }
    }    
}


void RtrIPCfgPage::OnRtrIPRbPool() 
{
    EnableStaticPoolCtrls(TRUE);
    SetDirty(TRUE);
    SetModified();
}


void RtrIPCfgPage::OnSelendOkAdapter() 
{
    SetDirty(TRUE);
    SetModified();
}


void RtrIPCfgPage::OnBtnAdd()
{
    OnNewAddressPool(GetSafeHwnd(),
                     &m_listCtrl,
                     ADDRPOOL_LONG,
                     &(m_DataIP.m_addressPoolList));
    
    // Disable the ADD button if it's ok to add pools.
    if ((m_listCtrl.GetItemCount() > 0) &&
        !m_DataIP.m_addressPoolList.FUsesMultipleAddressPools())
    {
        MultiEnableWindow(GetSafeHwnd(),
                          FALSE,
                          IDC_RTR_IP_BTN_ADD,
                          0);
    }
    
    SetDirty(TRUE);
    SetModified();
}


void RtrIPCfgPage::OnBtnEdit()
{
    INT     iPos;
    OnEditAddressPool(GetSafeHwnd(),
                      &m_listCtrl,
                      ADDRPOOL_LONG,
                      &(m_DataIP.m_addressPoolList));
    
    // reset the selection
    if ((iPos = m_listCtrl.GetNextItem(-1, LVNI_SELECTED)) != -1)
    {
        MultiEnableWindow(GetSafeHwnd(),
                          TRUE,
                          IDC_RTR_IP_BTN_EDIT,
                          IDC_RTR_IP_BTN_REMOVE,
                          0);
    }
    
    SetDirty(TRUE);
    SetModified();
    SetFocus();
}

void RtrIPCfgPage::OnBtnRemove()
{
    OnDeleteAddressPool(GetSafeHwnd(),
                        &m_listCtrl,
                        ADDRPOOL_LONG,
                        &(m_DataIP.m_addressPoolList));
    
    // Enable the ADD button if it's ok to add pools.
    if ((m_listCtrl.GetItemCount() == 0) ||
        m_DataIP.m_addressPoolList.FUsesMultipleAddressPools())
    {
        MultiEnableWindow(GetSafeHwnd(),
                          TRUE,
                          IDC_RTR_IP_BTN_ADD,
                          0);
    }
    
    SetDirty(TRUE);
    SetModified();
    SetFocus();
}

void RtrIPCfgPage::OnEnableNetbtBcastFwd() 
{
    SetDirty(TRUE);
    SetModified();
}

void RtrIPCfgPage::OnListDblClk(NMHDR *pNMHdr, LRESULT *pResult)
{
    OnBtnEdit();

    *pResult = 0;
}

void RtrIPCfgPage::OnListChange(NMHDR *pNmHdr, LRESULT *pResult)
{
    NMLISTVIEW *    pnmlv = reinterpret_cast<NMLISTVIEW *>(pNmHdr);
    BOOL            fEnable = ((!!(pnmlv->uNewState & LVIS_SELECTED)) || ((m_listCtrl.GetNextItem(-1, LVNI_SELECTED)) != -1));

    MultiEnableWindow(GetSafeHwnd(),
                      fEnable,
                      IDC_RTR_IP_BTN_EDIT,
                      IDC_RTR_IP_BTN_REMOVE,
                      0);
    *pResult = 0;
}



//**********************************************************************
// IPX router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrIPXCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrIPXCfgPage)
ON_BN_CLICKED(IDC_RB_ENTIRE_NETWORK, OnChangeSomething)
ON_BN_CLICKED(IDC_RTR_IPX_CB_ALLOW_CLIENT, OnChangeSomething)
ON_BN_CLICKED(IDC_RTR_IPX_CB_REMOTEIPX, OnChangeSomething)
ON_BN_CLICKED(IDC_RTR_IPX_CB_SAME_ADDRESS, OnChangeSomething)
ON_BN_CLICKED(IDC_RTR_IPX_RB_AUTO, OnRtrIPxRbAuto)
ON_BN_CLICKED(IDC_RTR_IPX_RB_POOL, OnRtrIPxRbPool)
ON_EN_CHANGE(IDC_RTR_IPX_EB_FIRST, OnChangeSomething)
ON_EN_CHANGE(IDC_RTR_IPX_EB_LAST, OnChangeSomething)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RtrIPXCfgPage::RtrIPXCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrIPXCfgPage)
    //}}AFX_DATA_INIT
}

RtrIPXCfgPage::~RtrIPXCfgPage()
{
}

void RtrIPXCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrIPXCfgPage)
    //}}AFX_DATA_MAP
}

HRESULT  RtrIPXCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                             const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataIPX.LoadFromReg(m_pRtrCfgSheet->m_stServerName, m_pRtrCfgSheet->m_fNT4);

    return S_OK;
};


BOOL RtrIPXCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;
    RtrPropertyPage::OnInitDialog();

    CheckDlgButton(IDC_RB_ENTIRE_NETWORK,
                   m_DataIPX.m_dwAllowNetworkAccess);

    CheckRadioButton(IDC_RTR_IPX_RB_AUTO, IDC_RTR_IPX_RB_POOL,
                     (m_DataIPX.m_dwUseAutoAddr) ? IDC_RTR_IPX_RB_AUTO : IDC_RTR_IPX_RB_POOL);

    CheckDlgButton(IDC_RTR_IPX_CB_SAME_ADDRESS, m_DataIPX.m_dwUseSameNetNum );
    CheckDlgButton(IDC_RTR_IPX_CB_ALLOW_CLIENT, m_DataIPX.m_dwAllowClientNetNum );
    CheckDlgButton(IDC_RTR_IPX_CB_REMOTEIPX, m_DataIPX.m_dwEnableIn );

    if ( m_DataIPX.m_dwIpxNetFirst || m_DataIPX.m_dwIpxNetLast )
    {
        TCHAR szNumFirst [40] = TEXT("");
        _ultot(m_DataIPX.m_dwIpxNetFirst, szNumFirst, DATA_SRV_IPX::mc_nIpxNetNumRadix);
        if ( szNumFirst[0] == TEXT('\0') ) 
            return FALSE;

        TCHAR szNumLast [40] = TEXT("");
        _ultot(m_DataIPX.m_dwIpxNetLast, szNumLast, DATA_SRV_IPX::mc_nIpxNetNumRadix);
        if ( szNumLast[0] == TEXT('\0') )
            return FALSE;

        GetDlgItem(IDC_RTR_IPX_EB_FIRST)->SetWindowText(szNumFirst);
        GetDlgItem(IDC_RTR_IPX_EB_LAST)->SetWindowText(szNumLast);
    }

    EnableNetworkRangeCtrls(!m_DataIPX.m_dwUseAutoAddr);

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();

    return FHrSucceeded(hr) ? TRUE : FALSE;
}

void RtrIPXCfgPage::EnableNetworkRangeCtrls(BOOL fEnable) 
{
    MultiEnableWindow(GetSafeHwnd(),
                      fEnable,
                      IDC_RTR_IPX_EB_FIRST,
                      IDC_RTR_IPX_EB_LAST,
                      0);
}


BOOL RtrIPXCfgPage::OnApply()
{
    BOOL fReturn=TRUE;
    HRESULT     hr = hrOK;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    // Only get the information if we are using them
    if (IsDlgButtonChecked(IDC_RTR_IPX_RB_POOL))
    {
        TCHAR szNumFirst [16] = {0};
        GetDlgItemText(IDC_RTR_IPX_EB_FIRST, szNumFirst, DimensionOf(szNumFirst));
        m_DataIPX.m_dwIpxNetFirst = _tcstoul(szNumFirst, NULL,
                                             DATA_SRV_IPX::mc_nIpxNetNumRadix);
        
        TCHAR szNumLast [16] = {0};
        GetDlgItemText(IDC_RTR_IPX_EB_LAST, szNumLast, DimensionOf(szNumLast));
        m_DataIPX.m_dwIpxNetLast = _tcstoul(szNumLast, NULL,
                                            DATA_SRV_IPX::mc_nIpxNetNumRadix);
        
        // Check to see that the last is bigger than the first
        if (m_DataIPX.m_dwIpxNetLast < m_DataIPX.m_dwIpxNetFirst)
        {
            AfxMessageBox(IDS_ERR_IPX_LAST_MUST_BE_MORE_THAN_FIRST);
            return TRUE;
        }
    }



    m_DataIPX.m_dwUseSameNetNum  = IsDlgButtonChecked(IDC_RTR_IPX_CB_SAME_ADDRESS);  
    m_DataIPX.m_dwAllowClientNetNum  = IsDlgButtonChecked(IDC_RTR_IPX_CB_ALLOW_CLIENT);  

    m_DataIPX.m_dwAllowNetworkAccess = IsDlgButtonChecked(IDC_RB_ENTIRE_NETWORK);  
    m_DataIPX.m_dwUseAutoAddr = IsDlgButtonChecked(IDC_RTR_IPX_RB_AUTO);  

    m_DataIPX.m_dwEnableIn  = IsDlgButtonChecked(IDC_RTR_IPX_CB_REMOTEIPX);  

    fReturn = RtrPropertyPage::OnApply();

    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;

    return fReturn;
}


void RtrIPXCfgPage::OnChangeSomething()
{
    SetDirty(TRUE);
    SetModified();
}

void RtrIPXCfgPage::OnRtrIPxRbAuto() 
{
    EnableNetworkRangeCtrls(FALSE);
    SetDirty(TRUE);
    SetModified();
}

void RtrIPXCfgPage::OnRtrIPxRbPool() 
{
    EnableNetworkRangeCtrls(TRUE);
    SetDirty(TRUE);
    SetModified();
}

//**********************************************************************
// NetBEUI router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrNBFCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrNBFCfgPage)
ON_BN_CLICKED(IDC_RB_ENTIRE_NETWORK, OnButtonClick)
ON_BN_CLICKED(IDC_RB_THIS_COMPUTER, OnButtonClick)
ON_BN_CLICKED(IDC_RTR_IPX_CB_REMOTENETBEUI, OnButtonClick)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

RtrNBFCfgPage::RtrNBFCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrNBFCfgPage)
    //}}AFX_DATA_INIT
}

RtrNBFCfgPage::~RtrNBFCfgPage()
{
}

void RtrNBFCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrNBFCfgPage)
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


HRESULT  RtrNBFCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                             const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataNBF.LoadFromReg(m_pRtrCfgSheet->m_stServerName, m_pRtrCfgSheet->m_fNT4);

    return S_OK;
};

BOOL RtrNBFCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;
    RtrPropertyPage::OnInitDialog();

    CheckRadioButton(IDC_RB_ENTIRE_NETWORK,IDC_RB_THIS_COMPUTER,
                     (m_DataNBF.m_dwAllowNetworkAccess) ? IDC_RB_ENTIRE_NETWORK : IDC_RB_THIS_COMPUTER);

    CheckDlgButton(IDC_RTR_IPX_CB_REMOTENETBEUI, m_DataNBF.m_dwEnableIn );

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();

    return FHrSucceeded(hr) ? TRUE : FALSE;
}

BOOL RtrNBFCfgPage::OnApply()
{
    BOOL    fReturn = TRUE;
    HRESULT     hr = hrOK;
    BOOL    fRestartNeeded = FALSE;
    BOOL    dwNewAllowNetworkAccess;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;


    hr = m_pRtrCfgSheet->SaveRequiredRestartChanges(GetSafeHwnd());

    if (FHrSucceeded(hr))
        fReturn = RtrPropertyPage::OnApply();
        
    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;

    return fReturn;
}


void RtrNBFCfgPage::OnButtonClick() 
{
    SaveSettings();
    SetDirty(TRUE);
    SetModified();
}

void RtrNBFCfgPage::SaveSettings()
{
    m_DataNBF.m_dwAllowNetworkAccess = IsDlgButtonChecked(IDC_RB_ENTIRE_NETWORK);  
    m_DataNBF.m_dwEnableIn = IsDlgButtonChecked(IDC_RTR_IPX_CB_REMOTENETBEUI);

}

//******************************************************************************
//
// Router configuration property sheet
//
//******************************************************************************
RtrCfgSheet::RtrCfgSheet(ITFSNode *pNode,
                         IRouterInfo *pRouter,
                         IComponentData *pComponentData,
                         ITFSComponentData *pTFSCompData,
                         LPCTSTR pszSheetName,
                         CWnd *pParent,
                         UINT iPage,
                         BOOL fScopePane)
: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
                   pszSheetName, pParent, iPage, fScopePane)
{
    m_fNT4=FALSE;
    m_spNode.Set(pNode);
    m_spRouter.Set(pRouter);
    m_fIpLoaded=FALSE;
    m_fIpxLoaded=FALSE;
    m_fNbfLoaded=FALSE;
    m_fARAPLoaded=FALSE;
}

RtrCfgSheet::~RtrCfgSheet()
{

}


/*!--------------------------------------------------------------------------
   RtrCfgSheet::Init
      Initialize the property sheets.  The general action here will be
      to initialize/add the various pages.
 ---------------------------------------------------------------------------*/
HRESULT RtrCfgSheet::Init(LPCTSTR pServerName)
{
    HKEY hkey=NULL;
    RegKey regkey;

    m_stServerName=pServerName;

    {
    HKEY hkeyMachine = 0;

    // Connect to the registry
    // ----------------------------------------------------------------
    if ( FHrSucceeded( ConnectRegistry(pServerName, &hkeyMachine)) )
        IsNT4Machine(hkeyMachine, &m_fNT4);

    // Get the version information for this machine.
    // ----------------------------------------------------------------
    QueryRouterVersionInfo(hkeyMachine, &m_routerVersion);

    if(hkeyMachine != NULL)
        DisconnectRegistry(hkeyMachine);
    }

    // The pages are embedded members of the class
    // do not delete them.
    // ----------------------------------------------------------------
    m_bAutoDeletePages = FALSE;

    //load General Page
    // ----------------------------------------------------------------
    m_pRtrGenCfgPage = new RtrGenCfgPage(IDD_RTR_GENERAL);
    m_pRtrGenCfgPage->Init(this, m_routerVersion);
    AddPageToList((CPropertyPageBase*) m_pRtrGenCfgPage);

    //load Authentication Page
    // ----------------------------------------------------------------
    m_pRtrAuthCfgPage = new RtrAuthCfgPage(IDD_RTR_AUTHENTICATION);
    m_pRtrAuthCfgPage->Init(this, m_routerVersion);
    AddPageToList((CPropertyPageBase*) m_pRtrAuthCfgPage);

    //load IP page
    // ----------------------------------------------------------------
    if (HrIsProtocolSupported(pServerName,
                              c_szRegKeyTcpip,
                              c_szRegKeyRasIp,
                              c_szRegKeyRasIpRtrMgr) == hrOK)
    {
        m_pRtrIPCfgPage = new RtrIPCfgPage(IDD_RTR_IP);
        m_pRtrIPCfgPage->Init(this, m_routerVersion);
        AddPageToList((CPropertyPageBase*) m_pRtrIPCfgPage);
        m_fIpLoaded=TRUE;
    }

#if (WINVER >= 0x0501)
    //load IPX page
    // ----------------------------------------------------------------
    if ( m_routerVersion.dwOsBuildNo < ROUTER_LAST_IPX_VERSION )
    {
        if (HrIsProtocolSupported(pServerName,
                                  c_szRegKeyNwlnkIpx,
                                  c_szRegKeyRasIpx,
                                  NULL) == hrOK)
        {
            m_pRtrIPXCfgPage = new RtrIPXCfgPage(IDD_RTR_IPX);
            m_pRtrIPXCfgPage->Init(this, m_routerVersion);
            AddPageToList((CPropertyPageBase*) m_pRtrIPXCfgPage);
            m_fIpxLoaded=TRUE;
        }
    }
#endif

    //load NetBEUI page
    // ----------------------------------------------------------------
    if ( m_routerVersion.dwOsBuildNo <= RASMAN_PPP_KEY_LAST_WIN2k_VERSION )
    {
        //If this is Win2k or less
        if (HrIsProtocolSupported(pServerName,
                                  c_szRegKeyNbf,
                                  c_szRegKeyRasNbf,
                                  NULL) == hrOK)
        {
            m_pRtrNBFCfgPage = new RtrNBFCfgPage(IDD_RTR_NBF);
            m_pRtrNBFCfgPage->Init(this, m_routerVersion);
            AddPageToList((CPropertyPageBase*) m_pRtrNBFCfgPage);
            m_fNbfLoaded=TRUE;
        }
    }

    // Check to see if this is the local machine,
    // if so then we can check to see if we should add ARAP
    // ----------------------------------------------------------------
    BOOL    fLocal = IsLocalMachine(pServerName);

    if ( fLocal )
    {
        //load ARAP page
        if (HrIsProtocolSupported(NULL,
                                  c_szRegKeyAppletalk,
                                  c_szRegKeyRasAppletalk,
                                  NULL) == hrOK)
        {
            m_pRtrARAPCfgPage = new RtrARAPCfgPage(IDD_RTR_ARAP);
            m_pRtrARAPCfgPage->Init(this, m_routerVersion);
            AddPageToList((CPropertyPageBase*) m_pRtrARAPCfgPage);
            m_fARAPLoaded=TRUE;
        }
    }

    // load PPP Page
    // ----------------------------------------------------------------
    m_pRtrPPPCfgPage = new RtrPPPCfgPage(IDD_PPP_CONFIG);
    m_pRtrPPPCfgPage->Init(this, m_routerVersion);
    AddPageToList((CPropertyPageBase*) m_pRtrPPPCfgPage);

    // Load RAS Error logging page
    // ----------------------------------------------------------------
    m_pRtrLogLevelCfgPage = new RtrLogLevelCfgPage(IDD_RTR_EVENTLOGGING);
    m_pRtrLogLevelCfgPage->Init(this, m_routerVersion);
    AddPageToList((CPropertyPageBase *) m_pRtrLogLevelCfgPage);

//    if ( m_fNbfLoaded || m_fIpxLoaded || m_fIpLoaded || m_fARAPLoaded)
//     return hrOK;
// else
// { 
//       //this call to Notify is a hack so that it can be properly deleted
//    int nMessage = TFS_NOTIFY_RESULT_CREATEPROPSHEET;
//       m_spNode->Notify(nMessage, (DWORD) this);
//
//     return hrFail;
// }
    return hrOK;
}


/*!--------------------------------------------------------------------------
   RtrCfgSheet::SaveSheetData
      -
 ---------------------------------------------------------------------------*/
BOOL RtrCfgSheet::SaveSheetData()
{
    HRESULT     hr = hrOK;

    if (IsCancel())
        return TRUE;
    
    if ( m_fIpLoaded )
        CORg( m_pRtrIPCfgPage->m_DataIP.SaveToReg(m_spRouter, m_routerVersion) );
    if ( m_fIpxLoaded )
        CORg( m_pRtrIPXCfgPage->m_DataIPX.SaveToReg(NULL) );
    if ( m_fNbfLoaded )
        CORg( m_pRtrNBFCfgPage->m_DataNBF.SaveToReg() );
    if ( m_fARAPLoaded )
    {
        CORg( m_pRtrARAPCfgPage->m_DataARAP.SaveToReg() );

        // PnP notification
        if(m_pRtrARAPCfgPage->m_bApplied)
        {
            CStop_StartAppleTalkPrint    MacPrint;

            CORg( m_pRtrARAPCfgPage->m_AdapterInfo.HrAtlkPnPReconfigParams(TRUE) );
            m_pRtrARAPCfgPage->m_bApplied = FALSE;
        }
    }

    //CORg( m_pRtrAuthCfgPage->m_DataAuth.SaveToReg(NULL) );

    CORg( m_pRtrPPPCfgPage->m_DataPPP.SaveToReg() );

    CORg( m_pRtrLogLevelCfgPage->m_DataRASErrLog.SaveToReg() );

    CORg( m_pRtrGenCfgPage->m_DataGeneral.SaveToReg() );

Error:
    
    ForceGlobalRefresh(m_spRouter);

    return FHrSucceeded(hr);
}


/*!--------------------------------------------------------------------------
    RtrCfgSheet::SaveRequiredRestartChanges
        This does require that the changes to the various DATA_SRV_XXX
        structures be saved BEFORE this function gets called.  This means
        that the pages cannot wait till the OnApply() before saving the
        data back.  They have to do as the control is changed.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RtrCfgSheet::SaveRequiredRestartChanges(HWND hWnd)
{
    HRESULT     hr = hrOK;
    BOOL        fRestart = FALSE;

    // First, tell the various pages to save their settings (this
    // is the same as an OnApply()).
    // ----------------------------------------------------------------
    if (m_pRtrIPCfgPage)
        CORg( m_pRtrIPCfgPage->SaveSettings(hWnd) );

    if ( m_pRtrAuthCfgPage )
        m_pRtrAuthCfgPage->m_DataAuth.SaveToReg(NULL);

    // Second, determine if we need to stop the router
    // If so, stop the router (and mark it for restart).
    // There are three pages that need to be asked,
    // the general page, log level, and nbf.
    // ----------------------------------------------------------------
    if (m_pRtrGenCfgPage->m_DataGeneral.FNeedRestart() ||
        m_pRtrLogLevelCfgPage->m_DataRASErrLog.FNeedRestart() ||
        (m_pRtrNBFCfgPage && m_pRtrNBFCfgPage->m_DataNBF.FNeedRestart()) ||
        (m_pRtrIPCfgPage && m_pRtrIPCfgPage->m_DataIP.FNeedRestart() ||
         m_pRtrAuthCfgPage && m_pRtrAuthCfgPage->m_DataAuth.FNeedRestart())
       )
    {
        BOOL    fRouterIsRunning = FALSE;
        
        fRouterIsRunning = FHrOK(IsRouterServiceRunning(m_stServerName, NULL));

        // If the router is running, tell the user that it is necessary
        // to restart the router.
        // ------------------------------------------------------------
        if (fRouterIsRunning)
        {
            // Ask the user if they want to restart.
            // --------------------------------------------------------
            if (AfxMessageBox(IDS_WRN_CHANGING_ROUTER_CONFIG, MB_YESNO)==IDNO)
                CORg( HResultFromWin32(ERROR_CANCELLED) );
            
            hr = StopRouterService(m_stServerName);

            // We have successfully stopped the router.  Set the flag
            // so that the router will be restarted after the change
            // has been made.
            // --------------------------------------------------------
            if (FHrSucceeded(hr))
                fRestart = TRUE;
            else
            {
                DisplayIdErrorMessage2(NULL,
                                       IDS_ERR_COULD_NOT_STOP_ROUTER,
                                       hr);
            }
        }


        if (m_pRtrIPCfgPage)
            CORg( m_pRtrIPCfgPage->m_DataIP.SaveToReg(m_spRouter, m_routerVersion) );
        
        // Windows NT Bug : 183083, 171594 - a change to the NetBEUI config
        // requires that the service be restarted.
        // ----------------------------------------------------------------
        if (m_pRtrNBFCfgPage)
            CORg( m_pRtrNBFCfgPage->m_DataNBF.SaveToReg() );
        
        CORg( m_pRtrLogLevelCfgPage->m_DataRASErrLog.SaveToReg() );

        CORg( m_pRtrGenCfgPage->m_DataGeneral.SaveToReg() );

    }
    

    // Restart the router if needed.
    // ----------------------------------------------------------------
            
    // If this call fails, it's not necessary to abort the whole
    // procedure.
    // ------------------------------------------------------------
    if (fRestart)
        StartRouterService(m_stServerName);

Error:
    return hr;
}


//------------------------------------------------------------------------
// DATA_SRV_GENERAL
//------------------------------------------------------------------------
DATA_SRV_GENERAL::DATA_SRV_GENERAL()
{
    GetDefault();
}


/*!--------------------------------------------------------------------------
    DATA_SRV_GENERAL::LoadFromReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_GENERAL::LoadFromReg(LPCTSTR pServerName /*=NULL*/)
{
    DWORD    dwErr = ERROR_SUCCESS;
    HKEY    hkMachine = 0;
    LPCTSTR    pszRouterTypeKey = NULL;

    m_stServerName = pServerName;

    // Windows NT Bug : 137200
    // Look for the RemoteAccess\Parameters location first, then
    // try the RAS\Protocols.
    // If neither key exists, return failure.
    // ----------------------------------------------------------------

    // Connect to the machine and get its version informatioin
    // ----------------------------------------------------------------
    dwErr = ConnectRegistry(m_stServerName, &hkMachine);
    if (dwErr != ERROR_SUCCESS)
        return HResultFromWin32(dwErr);

    for (int i=0; i<2; i++)
    {
        if (i == 0)
            pszRouterTypeKey = c_szRegKeyRemoteAccessParameters;
        else
            pszRouterTypeKey = c_szRegKeyRasProtocols;
        
        // Try to connect to the key
        // ------------------------------------------------------------
        m_regkey.Close();
        dwErr = m_regkey.Open(hkMachine, pszRouterTypeKey);
        
        if (dwErr != ERROR_SUCCESS)
        {
            if (i != 0)
            {
                // Setup the registry error
                // ----------------------------------------------------
                SetRegError(0, HResultFromWin32(dwErr),
                            IDS_ERR_REG_OPEN_CALL_FAILED,
                            c_szHKLM, pszRouterTypeKey, NULL);
            }
            continue;
        }
        
        dwErr = m_regkey.QueryValue( c_szRouterType, m_dwRouterType);

        // If we succeeded, great!  break out of the loop
        // ------------------------------------------------------------
        if (dwErr == ERROR_SUCCESS)
            break;
        
        if (i != 0)
        {
            // Setup the registry error
            // ----------------------------------------------------
            SetRegError(0, HResultFromWin32(dwErr),
                        IDS_ERR_REG_QUERYVALUE_CALL_FAILED,
                        c_szHKLM, pszRouterTypeKey, c_szRouterType, NULL);
        }
    }
    

//Error:
    m_dwOldRouterType = m_dwRouterType;
    
    if (hkMachine)
        DisconnectRegistry(hkMachine);

    return HResultFromWin32(dwErr);
}


HRESULT DATA_SRV_GENERAL::SaveToReg()
{
    HRESULT     hr = hrOK;
    DWORD dw=0;

    if (m_dwOldRouterType != m_dwRouterType)
    {
        CWRg( m_regkey.SetValue( c_szRouterType,m_dwRouterType) );

        // If the configuration is a LAN-only router, remove the
        // router.pbk
        // ------------------------------------------------------------
        if (m_dwRouterType == ROUTER_TYPE_LAN)
        {
            DeleteRouterPhonebook( m_stServerName );
        }

        m_dwOldRouterType = m_dwRouterType;
    }

Error:
    return hr;
}

void DATA_SRV_GENERAL::GetDefault()
{
    // Windows NT Bug : 273419
    // Change default to be RAS-server only
    m_dwRouterType = ROUTER_TYPE_RAS;
    m_dwOldRouterType = m_dwRouterType;
};


/*!--------------------------------------------------------------------------
    DATA_SRV_GENERAL::FNeedRestart
        Returns TRUE if a restart is needed.
        Returns FALSE otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL DATA_SRV_GENERAL::FNeedRestart()
{
    // We need a restart only if the router type changed.
    // ----------------------------------------------------------------
    return (m_dwRouterType != m_dwOldRouterType);
}


//------------------------------------------------------------------------
// DATA_SRV_IP
//------------------------------------------------------------------------
DATA_SRV_IP::DATA_SRV_IP()
{
    GetDefault();
}


/*!--------------------------------------------------------------------------
    DATA_SRV_IP::LoadFromReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_IP::LoadFromReg(LPCTSTR pServerName,
                                 const RouterVersionInfo& routerVersion)
{
    HRESULT     hr = hrOK;
    
    m_fNT4 = (routerVersion.dwRouterVersion <= 4);
    m_routerVersion = routerVersion;

    m_stServerName = pServerName;

    m_regkey.Close();

    if ( ERROR_SUCCESS == m_regkey.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRasIp, KEY_ALL_ACCESS,   pServerName) )
    {
        if ( m_fNT4 )
        {
            if ( ERROR_SUCCESS == m_regkeyNT4.Open(HKEY_LOCAL_MACHINE,
                        c_szRegKeyRasProtocols,
                        KEY_ALL_ACCESS,
                        pServerName) )
                m_regkeyNT4.QueryValue( c_szRegValTcpIpAllowed,
                                        m_dwAllowNetworkAccess);
        }
        else
        {
            m_regkey.QueryValue(c_szRegValAllowNetAccess,
                                m_dwAllowNetworkAccess);
        }
        m_regkey.QueryValue(c_szRegValDhcpAddressing, m_dwUseDhcp);        
        m_regkey.QueryValue(c_szRegValNetworkAdapterGUID, m_stNetworkAdapterGUID);
        m_regkey.QueryValue(c_szRegValEnableIn,m_dwEnableIn);

        //
        // Query whether NETBT broadcasts need to be forwarded
        //
        
        if ( ERROR_SUCCESS != 
                m_regkey.QueryValue(
                    c_szRegValEnableNetbtBcastFwd, 
                    m_dwEnableNetbtBcastFwd
                ) )
        {
            //
            // if query fails, set bcast fwd to be TRUE (default)
            // and set the registry key
            //
            
            m_dwEnableNetbtBcastFwd = TRUE;
            m_regkey.SetValueExplicit(
                c_szRegValEnableNetbtBcastFwd,
                REG_DWORD,
                sizeof(DWORD),
                (LPBYTE)&m_dwEnableNetbtBcastFwd
                );
        }

        
        // Load the addressing information
        m_addressPoolList.RemoveAll();

        // Always load the list
        m_addressPoolList.LoadFromReg(m_regkey, routerVersion.dwOsBuildNo);
        
        m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;
        
        m_dwOldEnableNetbtBcastFwd = m_dwEnableNetbtBcastFwd;
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    DATA_SRV_IP::UseDefaults
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_IP::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;
    
    m_fNT4 = fNT4;
    m_stServerName = pServerName;

    m_regkey.Close();
    hr = m_regkey.Open(HKEY_LOCAL_MACHINE,
                       c_szRegKeyRasIp,
                       KEY_ALL_ACCESS,
                       pServerName);
    GetDefault();

    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;
    m_dwOldEnableNetbtBcastFwd = m_dwEnableNetbtBcastFwd;

    m_stPublicAdapterGUID.Empty();
//Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_IP::SaveToReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_IP::SaveToReg(IRouterInfo *pRouter,
                               const RouterVersionInfo& routerVersion)
{
    HRESULT     hr = hrOK;

    if ( m_fNT4 )
        CWRg( m_regkeyNT4.SetValue(c_szRegValTcpIpAllowed, m_dwAllowNetworkAccess) );
    else
        CWRg(m_regkey.SetValue( c_szRegValAllowNetAccess, m_dwAllowNetworkAccess));
    CWRg( m_regkey.SetValue( c_szRegValDhcpAddressing, m_dwUseDhcp) );

    m_addressPoolList.SaveToReg(m_regkey, routerVersion.dwOsBuildNo);
    
    CWRg( m_regkey.SetValue( c_szRegValNetworkAdapterGUID, (LPCTSTR) m_stNetworkAdapterGUID) );
    CWRg( m_regkey.SetValue( c_szRegValEnableIn,m_dwEnableIn ) );
    CWRg( m_regkey.SetValue( c_szRegValEnableNetbtBcastFwd, m_dwEnableNetbtBcastFwd ) );
    
    if (m_dwAllowNetworkAccess != m_dwOldAllowNetworkAccess)
    {
        // We need to change the registry keys appropriately
        // and do the proper notifications.
        if (m_dwAllowNetworkAccess)
        {
            InstallGlobalSettings((LPCTSTR) m_stServerName,
                                  pRouter);
        }        
        else
        {
            UninstallGlobalSettings((LPCTSTR) m_stServerName,
                                   pRouter,
                                   m_fNT4,
                                   FALSE /* fSnapinChanges */);
        }
    }

    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;
    m_dwOldEnableNetbtBcastFwd = m_dwEnableNetbtBcastFwd;

    Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_IP::GetDefault
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DATA_SRV_IP::GetDefault()
{
    m_dwAllowNetworkAccess = TRUE;
    m_dwOldAllowNetworkAccess = TRUE;
    m_dwUseDhcp = TRUE;
    m_dwEnableIn = TRUE;
    m_dwOldEnableNetbtBcastFwd = TRUE;
    m_dwEnableNetbtBcastFwd = TRUE;
    m_addressPoolList.RemoveAll();
};

/*!--------------------------------------------------------------------------
    DATA_SRV_IP::FNeedRestart
        Returns TRUE if a restart is needed.
        Returns FALSE otherwise.
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL DATA_SRV_IP::FNeedRestart()
{
    // we need to do this check ONLY on recent builds
    // Otherwise, we need to do this.
    // ----------------------------------------------------------------
    if (m_routerVersion.dwOsBuildNo <= USE_IPENABLEROUTER_VERSION)
    {
        // We need a restart only if the dwAllowNetworkAccess flag
        // was toggled.
        // ----------------------------------------------------------------
        return (m_dwAllowNetworkAccess != m_dwOldAllowNetworkAccess);
    }
    else
    {
        return ( m_dwOldEnableNetbtBcastFwd != m_dwEnableNetbtBcastFwd );

        // (Awaiting the signal from vijay/amritansh)
        // A restart is no longer needed, now that the router will call
        // the EnableRouter function.
        // return FALSE;
    }
}


typedef DWORD (WINAPI* PGETADAPTERSINFO)(PIP_ADAPTER_INFO, PULONG);

HRESULT  DATA_SRV_IP::LoadAdapters(IRouterInfo *pRouter, AdapterList *pAdapterList)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    AdapterData         data;
    SPIInterfaceInfo    spIf;
    SPIEnumInterfaceInfo spEnumIf;
    HRESULT                hr = hrOK;

    data.m_stGuid = _T("");
    data.m_stFriendlyName.LoadString(IDS_DEFAULT_ADAPTER);
    pAdapterList->AddTail(data);

    pRouter->EnumInterface(&spEnumIf);

    for (;spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
    {
        if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
        {
            // Windows NT Bug : ?
            // Need to filter out the non-IP adapters
            if (spIf->FindRtrMgrInterface(PID_IP, NULL) == hrOK)
            {
                data.m_stFriendlyName = spIf->GetTitle();
                data.m_stGuid = spIf->GetId();
                pAdapterList->AddTail(data);
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------
// DATA_SRV_IPX
//------------------------------------------------------------------------
DATA_SRV_IPX::DATA_SRV_IPX()
{
    GetDefault();
}

// IPX network numbers are shown in hex.
//
const int DATA_SRV_IPX::mc_nIpxNetNumRadix = 16;


HRESULT DATA_SRV_IPX::LoadFromReg (LPCTSTR pServerName /*=NULL*/, BOOL fNT4 /*=FALSE*/)
{
    HRESULT    hr = hrOK;

    m_fNT4=fNT4;

    m_regkey.Close();
    m_regkeyNT4.Close();

    if ( ERROR_SUCCESS == m_regkey.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRasIpx,KEY_ALL_ACCESS,   pServerName) )
    {
        if ( m_fNT4 )
        {
            if ( ERROR_SUCCESS == m_regkeyNT4.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRasProtocols,KEY_ALL_ACCESS,pServerName) )
                m_regkeyNT4.QueryValue( c_szRegValIpxAllowed, m_dwAllowNetworkAccess);
        }
        else
        {
            m_regkey.QueryValue( c_szRegValAllowNetAccess, m_dwAllowNetworkAccess);
        }
        m_regkey.QueryValue( c_szRegValAutoWanNet, m_dwUseAutoAddr);
        m_regkey.QueryValue( c_szRegValGlobalWanNet, m_dwUseSameNetNum);
        m_regkey.QueryValue( c_szRegValRemoteNode, m_dwAllowClientNetNum);
        m_regkey.QueryValue( c_szRegValFirstWanNet, m_dwIpxNetFirst);

        // Windows NT Bug : 260262
        // We need to look at the WanNetPoolSize value
        // rather than the LastWanNet value.
        // We've just read in the pool size, now we need to adjust
        // the last value.
        // last = first + size - 1;
        // ------------------------------------------------------------

        if (m_regkey.QueryValue( c_szRegValWanNetPoolSize, m_dwIpxNetLast) == ERROR_SUCCESS)
        {
            m_dwIpxNetLast += (m_dwIpxNetFirst - 1);
        }
        else
        {
            // If there is no key, assume a pool size of 1.
            // --------------------------------------------------------
            m_dwIpxNetLast = m_dwIpxNetFirst;
        }

        
        m_regkey.QueryValue( c_szRegValEnableIn, m_dwEnableIn);
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_IPX::UseDefaults
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_IPX::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;
    
    m_fNT4 = fNT4;

    m_regkey.Close();
    m_regkeyNT4.Close();

    CWRg( m_regkey.Open(HKEY_LOCAL_MACHINE,
                        c_szRegKeyRasIpx,
                        KEY_ALL_ACCESS,
                        pServerName) );
    
    if ( m_fNT4 )
    {
        CWRg( m_regkeyNT4.Open(HKEY_LOCAL_MACHINE,
                               c_szRegKeyRasProtocols,
                               KEY_ALL_ACCESS,
                               pServerName) );
    }

    GetDefault();
    
Error:
    return hr;
}

HRESULT DATA_SRV_IPX::SaveToReg (IRouterInfo *pRouter)
{
    HRESULT     hr = hrOK;
    DWORD       dwTemp;    

    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    SPIInfoBase    spInfoBase;
    IPX_IF_INFO    *    pIpxIf = NULL;


    if ( m_fNT4 )
        CWRg( m_regkeyNT4.SetValue( c_szRegValIpxAllowed, m_dwAllowNetworkAccess) );
    else
        CWRg( m_regkey.SetValue( c_szRegValAllowNetAccess, m_dwAllowNetworkAccess) );
    CWRg( m_regkey.SetValue( c_szRegValAutoWanNet, m_dwUseAutoAddr) );
    CWRg( m_regkey.SetValue( c_szRegValGlobalWanNet, m_dwUseSameNetNum) );
    CWRg( m_regkey.SetValue( c_szRegValRemoteNode, m_dwAllowClientNetNum) );
    CWRg( m_regkey.SetValue( c_szRegValFirstWanNet, m_dwIpxNetFirst) );
    
    // Windows NT Bug : 260262
    // We need to look at the WanNetPoolSize value
    // rather than the LastWanNet value.
    dwTemp = m_dwIpxNetLast - m_dwIpxNetFirst + 1;
    CWRg( m_regkey.SetValue( c_szRegValWanNetPoolSize, dwTemp ) );
        
    CWRg( m_regkey.SetValue( c_szRegValEnableIn, m_dwEnableIn) );


    // Windows NT Bug : 281100
    // If the pRouter argument is non-NULL, then we will set the
    // interfaces up for Type20 broadcast.

    // Optimization!  The only time this case should get invoked is
    // upon initial configuration.  In that case, the default is
    // ADMIN_STATE_ENABLED and we do not need to run this code!
    // ----------------------------------------------------------------

    if (pRouter && (m_fEnableType20Broadcasts == FALSE))
    {
        pRouter->EnumInterface(&spEnumIf);
        
        for (spEnumIf->Reset();
             spEnumIf->Next(1, &spIf, NULL) == hrOK;
             spIf.Release())
        {
            if (spIf->GetInterfaceType() != ROUTER_IF_TYPE_DEDICATED)
                continue;
            
            // Now look for IPX
            // ------------------------------------------------------------
            spRmIf.Release();
            if (FHrOK(spIf->FindRtrMgrInterface(PID_IPX, &spRmIf)))
            {
                spInfoBase.Release();
                if (spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) != hrOK)
                    continue;
                
                spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (PBYTE *) &pIpxIf);

                if (pIpxIf == NULL)
                {
                    IPX_IF_INFO        ipx;
                    
                    ipx.AdminState = ADMIN_STATE_ENABLED;
                    ipx.NetbiosAccept = ADMIN_STATE_DISABLED;
                    ipx.NetbiosDeliver = ADMIN_STATE_DISABLED;
                    
                    // We couldn't find a block for this interface,
                    // we need to add a block.
                    // ------------------------------------------------
                    spInfoBase->AddBlock(IPX_INTERFACE_INFO_TYPE,
                                         sizeof(ipx),
                                         (PBYTE) &ipx,
                                         1 /* count */,
                                         FALSE /* bRemoveFirst */);
                }
                else
                {
                    pIpxIf->NetbiosDeliver = ADMIN_STATE_DISABLED;
                }
                
                spRmIf->Save(spIf->GetMachineName(),
                             NULL, NULL, NULL, spInfoBase, 0);
                
            }
        }
    }
        

Error:
    return hr;
}

void DATA_SRV_IPX::GetDefault ()
{
    m_dwAllowNetworkAccess = TRUE;
    m_dwUseAutoAddr = TRUE;
    m_dwUseSameNetNum = TRUE;
    m_dwAllowClientNetNum  = FALSE;
    m_dwIpxNetFirst = 0;
    m_dwIpxNetLast = 0;
    m_dwEnableIn = 0;

    // The default is TRUE so that the code to set it won't be run
    // by default.  This is especially important for the Router
    // properties.
    // ----------------------------------------------------------------
    m_fEnableType20Broadcasts = TRUE;
};


//------------------------------------------------------------------------
// DATA_SRV_NBF
//------------------------------------------------------------------------
DATA_SRV_NBF::DATA_SRV_NBF()
{
    GetDefault();
}


/*!--------------------------------------------------------------------------
    DATA_SRV_NBF::LoadFromReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_NBF::LoadFromReg(LPCTSTR pServerName /*=NULL*/, BOOL fNT4 /*=FALSE*/)
{
    HRESULT    hr = hrOK;
    
    m_fNT4 = fNT4;
    m_stServerName = pServerName;

    m_regkey.Close();
    m_regkeyNT4.Close();
    
    // Get Access to the base NBF key
    // ----------------------------------------------------------------
    CWRg( m_regkey.Open(HKEY_LOCAL_MACHINE, c_szRegKeyRasNbf, KEY_ALL_ACCESS,
                        pServerName) );

    if ( m_fNT4 )
    {
        if ( ERROR_SUCCESS == m_regkeyNT4.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRasProtocols,KEY_ALL_ACCESS,pServerName) )
            m_regkeyNT4.QueryValue( c_szRegValNetBeuiAllowed, m_dwAllowNetworkAccess);
    }
    else
    {
        m_regkey.QueryValue( c_szRegValAllowNetAccess, m_dwAllowNetworkAccess);
    }
    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;

    
    m_regkey.QueryValue( c_szRegValEnableIn, m_dwEnableIn);
    m_dwOldEnableIn = m_dwEnableIn;

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_NBF::UseDefaults
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_NBF::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;
    
    m_fNT4 = fNT4;
    m_stServerName = pServerName;
    m_regkey.Close();
    m_regkeyNT4.Close();
    
    // Get Access to the base NBF key
    // ----------------------------------------------------------------
    CWRg( m_regkey.Open(HKEY_LOCAL_MACHINE, c_szRegKeyRasNbf, KEY_ALL_ACCESS,
                        pServerName) );

    if ( m_fNT4 )
    {
        CWRg( m_regkeyNT4.Open(HKEY_LOCAL_MACHINE,
                               c_szRegKeyRasProtocols,
                               KEY_ALL_ACCESS,
                               pServerName) );
    }

    GetDefault();
    m_dwOldEnableIn = m_dwEnableIn;
    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_NBF::SaveToReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_NBF::SaveToReg()
{
    HRESULT  hr = hrOK;

    if ( m_fNT4 )
        CWRg( m_regkeyNT4.SetValue( c_szRegValNetBeuiAllowed, m_dwAllowNetworkAccess) );
    else
        CWRg( m_regkey.SetValue( c_szRegValAllowNetAccess, m_dwAllowNetworkAccess) );
    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;

    CWRg( m_regkey.SetValue( c_szRegValEnableIn, m_dwEnableIn) );
    m_dwOldEnableIn = m_dwEnableIn;

    // Windows NT Bug: 106486
    // Update the NetBIOS LANA map when we toggle the config
    // ----------------------------------------------------------------
    UpdateLanaMapForDialinClients(m_stServerName, m_dwAllowNetworkAccess);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_NBF::GetDefault
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DATA_SRV_NBF::GetDefault()
{
    m_dwAllowNetworkAccess = TRUE;
    m_dwOldAllowNetworkAccess = m_dwAllowNetworkAccess;
    m_dwEnableIn = TRUE;
    m_dwOldEnableIn = m_dwEnableIn;
};


/*!--------------------------------------------------------------------------
    DATA_SRV_NBF::FNeedRestart
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
BOOL DATA_SRV_NBF::FNeedRestart()
{
    return  ((m_dwOldEnableIn != m_dwEnableIn) ||
             (m_dwOldAllowNetworkAccess != m_dwAllowNetworkAccess));
}


//------------------------------------------------------------------------
// DATA_SRV_ARAP
//------------------------------------------------------------------------
DATA_SRV_ARAP::DATA_SRV_ARAP()
{
    GetDefault();
}

HRESULT DATA_SRV_ARAP::LoadFromReg(LPCTSTR pServerName /*=NULL*/, BOOL fNT4 /*=FALSE*/)
{
    HRESULT    hr = hrOK;
    if ( ERROR_SUCCESS == m_regkey.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRasAppletalk,KEY_ALL_ACCESS,pServerName) )
    {
        m_regkey.QueryValue( c_szRegValEnableIn,m_dwEnableIn);
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    DATA_SRV_ARAP::UseDefaults
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_ARAP::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;
    CWRg( m_regkey.Open(HKEY_LOCAL_MACHINE,
                        c_szRegKeyRasAppletalk,
                        KEY_ALL_ACCESS,
                        pServerName) );
    GetDefault();
    
Error:
    return hr;
}

HRESULT DATA_SRV_ARAP::SaveToReg()
{
    HRESULT  hr = hrOK;

    CWRg( m_regkey.SetValue( c_szRegValEnableIn,m_dwEnableIn) );

Error:
    return hr;
}

void DATA_SRV_ARAP::GetDefault()
{
    m_dwEnableIn = TRUE;
    
};


//------------------------------------------------------------------------
// DATA_SRV_AUTH
//------------------------------------------------------------------------
DATA_SRV_AUTH::DATA_SRV_AUTH()
{
    GetDefault();
}

HRESULT DATA_SRV_AUTH::LoadFromReg(LPCTSTR pServerName,
                                   const RouterVersionInfo& routerVersion)
{
    HRESULT     hr = hrOK;
    RegKey      regkeyAuthProv;    
    CString     stActive;
    AuthProviderData *   pAcctProv;
    AuthProviderData *   pAuthProv;
    RegKey      regkeyEap;
    LPCTSTR        pszServerFlagsKey = NULL;
    
    // Setup initial defaults
    // ----------------------------------------------------------------
    GetDefault();

    m_stServer = pServerName;
    //Check to see if the router service is running
    
    m_fRouterRunning = FHrOK(IsRouterServiceRunning(m_stServer, NULL));

    // Depending on the version depends on where we look for the
    // key.
    // ----------------------------------------------------------------
    if (routerVersion.dwOsBuildNo < RASMAN_PPP_KEY_LAST_VERSION)
        pszServerFlagsKey = c_szRasmanPPPKey;
    else
        pszServerFlagsKey = c_szRegKeyRemoteAccessParameters;

    // Get the flags for the current settings
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyRemoteAccess.Open(HKEY_LOCAL_MACHINE,
        pszServerFlagsKey,
        KEY_ALL_ACCESS,pServerName) )
    {
        m_regkeyRemoteAccess.QueryValue( c_szServerFlags, m_dwFlags );
    }

    // Get the list of EAP providers
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyRasmanPPP.Open(HKEY_LOCAL_MACHINE,c_szRasmanPPPKey,KEY_ALL_ACCESS,pServerName) )
    {
        if ( ERROR_SUCCESS == regkeyEap.Open(m_regkeyRasmanPPP, c_szEAP) )
            LoadEapProviders(regkeyEap, &m_eapProvList);
    }

    // Get to the currently active auth provider
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyAuth.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRouterAuthenticationProviders,KEY_ALL_ACCESS,pServerName) )
    {
        m_regkeyAuth.QueryValue( c_szActiveProvider, stActive );
        m_stGuidActiveAuthProv = stActive;
        m_stGuidOriginalAuthProv = stActive;

        // Now read in the list of active providers (and their data)
        // ------------------------------------------------------------
        LoadProviders(m_regkeyAuth, &m_authProvList);
    }

    // Get the accounting provider
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyAcct.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRouterAccountingProviders,KEY_ALL_ACCESS,pServerName) )
    {
        m_regkeyAcct.QueryValue( c_szActiveProvider, stActive );
        m_stGuidActiveAcctProv = stActive;
        m_stGuidOriginalAcctProv = stActive;

        // Now read in the list of active providers (and their data)
        // ------------------------------------------------------------
        LoadProviders(m_regkeyAcct, &m_acctProvList);
    }
    //Get the preshared key if one is set
    if ( m_fRouterRunning )
    {
        hr = LoadPSK();
    }
    return hr;
}


HRESULT DATA_SRV_AUTH::LoadPSK()
{
    DWORD                    dwErr = ERROR_SUCCESS;    
    HANDLE                    hMprServer = NULL;
    HRESULT                    hr = hrOK;
    PMPR_CREDENTIALSEX_0    pMprCredentials = NULL;

    dwErr = ::MprAdminServerConnect((LPWSTR)(LPCWSTR)m_stServer, &hMprServer);

    if ( ERROR_SUCCESS != dwErr )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }

    dwErr = MprAdminServerGetCredentials( hMprServer, 0, (LPBYTE *)&pMprCredentials );
    if ( ERROR_SUCCESS != dwErr )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }
    
    if ( pMprCredentials->dwSize )
    {
        m_fUseCustomIPSecPolicy = TRUE;
        ::SecureZeroMemory ( m_szPreSharedKey, DATA_SRV_AUTH_MAX_SHARED_KEY_LEN * sizeof(TCHAR) );
        CopyMemory ( m_szPreSharedKey, pMprCredentials->lpbCredentialsInfo, pMprCredentials->dwSize );
        
    }
    else
    {
        m_fUseCustomIPSecPolicy = FALSE;
        m_szPreSharedKey[0] = 0;
    }
    
Error:
    if ( pMprCredentials )
        ::MprAdminBufferFree(pMprCredentials);

    if ( hMprServer )
        ::MprAdminServerDisconnect(hMprServer);
    return hr;

}

HRESULT DATA_SRV_AUTH::SetPSK()
{
    DWORD                    dwErr = ERROR_SUCCESS;    
    HANDLE                    hMprServer = NULL;
    HRESULT                    hr = hrOK;
    MPR_CREDENTIALSEX_0        MprCredentials;

    dwErr = ::MprAdminServerConnect((LPWSTR)(LPCWSTR) m_stServer, &hMprServer);
    if ( ERROR_SUCCESS != dwErr )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }

    ::SecureZeroMemory(&MprCredentials, sizeof(MprCredentials));
    //Setup the MprCredentials structure
    MprCredentials.dwSize = _tcslen(m_szPreSharedKey) * sizeof(TCHAR);
    MprCredentials.lpbCredentialsInfo = (LPBYTE)m_szPreSharedKey;
    //irrespective of whether the flag is set, we need to set the credentials.
    dwErr = MprAdminServerSetCredentials( hMprServer, 0, (LPBYTE)&MprCredentials );
    if ( ERROR_SUCCESS != dwErr )
    {
        if ( ERROR_IPSEC_MM_AUTH_IN_USE == dwErr )
        {
            //Special case.  This means that IPSEC is currently using the
            //psk and we need to restart rras to let IPSEC re-pickup the PSK
            //Show a message telling the user that router needs to be restarted.
            m_fNeedRestart = TRUE;
            /*
            CString sMessage;
            sMessage.LoadString(IDS_RESTART_RRAS_PSK);
            CString sTitle;
            sTitle.LoadString(IDS_SNAPIN_DISPLAY_NAME);
            ::MessageBox(NULL, sTitle, sMessage, MB_OK|MB_ICONINFORMATION);
            */
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Error;
        }
    }



Error:

    if ( hMprServer )
        ::MprAdminServerDisconnect(hMprServer);
    return hr;

}
/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::SaveToReg
      -
   Author: KennT
 ---------------------------------------------------------------------------*/

// This is the list of flags that we use
#define PPPPAGE_MASK (PPPCFG_NegotiateMultilink | PPPCFG_NegotiateBacp | PPPCFG_UseLcpExtensions | PPPCFG_UseSwCompression)

HRESULT DATA_SRV_AUTH::SaveToReg(HWND hWnd)
{
    HRESULT  hr = hrOK;
    DWORD dwFlags;

    // Save the flags key
    // ----------------------------------------------------------------

    // Reread the key so that any changes made to the key by the
    // PPP page don't get overwritten
    // ----------------------------------------------------------------
    m_regkeyRemoteAccess.QueryValue(c_szServerFlags, dwFlags);

    // Apply whatever settings are in the PPP key to the m_dwFlags
    // ----------------------------------------------------------------

    // Clear the bits
    // ----------------------------------------------------------------
    m_dwFlags &= ~PPPPAGE_MASK;

    // Now reset the bits
    // ----------------------------------------------------------------
    m_dwFlags |= (dwFlags & PPPPAGE_MASK);

    m_regkeyRemoteAccess.SetValue( c_szServerFlags, m_dwFlags );

    CORg( SetNewActiveAuthProvider(hWnd) );
    CORg( SetNewActiveAcctProvider(hWnd) );
    if ( m_fRouterRunning )
        CORg( SetPSK() );
    Error:
    return hr;
}

void DATA_SRV_AUTH::GetDefault()
{
    TCHAR   szGuid[DATA_SRV_AUTH_MAX_SHARED_KEY_LEN];
    m_dwFlags = 0;

    m_stGuidActiveAuthProv.Empty();
    m_stGuidActiveAcctProv.Empty();
    m_stGuidOriginalAuthProv.Empty();
    m_stGuidOriginalAcctProv.Empty();

    // Default is Windows NT Authentication
    StringFromGUID2(CLSID_RouterAuthNT, szGuid, DimensionOf(szGuid));
    m_stGuidActiveAuthProv = szGuid;

    // Default is Windows NT Accounting
    StringFromGUID2(CLSID_RouterAcctNT, szGuid, DimensionOf(szGuid));
    m_stGuidActiveAcctProv = szGuid;
    //By default the router is not running
    m_fRouterRunning = FALSE;
    m_stServer.Empty();
    m_fUseCustomIPSecPolicy = FALSE;    
    m_szPreSharedKey[0] = 0;
    m_fNeedRestart = FALSE;
    
};


HRESULT DATA_SRV_AUTH::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;
    LPCTSTR        pszServerFlagsKey = NULL;
    RegKey      regkeyEap;
    CString     stActive;
    
    m_stServer = pServerName;
    
    // Depending on the version depends on where we look for the
    // key.
    // ----------------------------------------------------------------
    if (fNT4)
        pszServerFlagsKey = c_szRasmanPPPKey;
    else
        pszServerFlagsKey = c_szRegKeyRemoteAccessParameters;

    // Get the various registry keys.
    // ----------------------------------------------------------------

    CWRg( m_regkeyRemoteAccess.Open(HKEY_LOCAL_MACHINE,
                                    pszServerFlagsKey,
                                    KEY_ALL_ACCESS,pServerName) );
    
    // Get the list of EAP providers
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyRasmanPPP.Open(HKEY_LOCAL_MACHINE,c_szRasmanPPPKey,KEY_ALL_ACCESS,pServerName) )
    {
        if ( ERROR_SUCCESS == regkeyEap.Open(m_regkeyRasmanPPP, c_szEAP) )
            LoadEapProviders(regkeyEap, &m_eapProvList);
    }

    // Get to the currently active auth provider
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyAuth.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRouterAuthenticationProviders,KEY_ALL_ACCESS,pServerName) )
    {
        m_regkeyAuth.QueryValue( c_szActiveProvider, stActive );
        m_stGuidActiveAuthProv = stActive;
        m_stGuidOriginalAuthProv = stActive;

        m_authProvList.RemoveAll();
        
        // Now read in the list of active providers (and their data)
        // ------------------------------------------------------------
        LoadProviders(m_regkeyAuth, &m_authProvList);
    }

    // Get the accounting provider
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkeyAcct.Open(HKEY_LOCAL_MACHINE,c_szRegKeyRouterAccountingProviders,KEY_ALL_ACCESS,pServerName) )
    {
        m_regkeyAcct.QueryValue( c_szActiveProvider, stActive );
        m_stGuidActiveAcctProv = stActive;
        m_stGuidOriginalAcctProv = stActive;

        m_acctProvList.RemoveAll();
        
        // Now read in the list of active providers (and their data)
        // ------------------------------------------------------------
        LoadProviders(m_regkeyAcct, &m_acctProvList);
    }

    // Now get the defaults
    // This may overwrite some of the previous data.
    // ----------------------------------------------------------------
    GetDefault();


Error:
    return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::LoadProviders
      Load the data for a given provider type (accounting/authentication).
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  DATA_SRV_AUTH::LoadProviders(HKEY hkeyBase, AuthProviderList *pProvList)
{
    RegKey      regkeyProviders;
    HRESULT     hr = hrOK;
    HRESULT     hrIter;
    RegKeyIterator regkeyIter;
    CString     stKey;
    RegKey      regkeyProv;
    AuthProviderData  data;
    DWORD    dwErr;

    Assert(hkeyBase);
    Assert(pProvList);

    // Open the providers key
    // ----------------------------------------------------------------
    regkeyProviders.Attach(hkeyBase);

    CORg( regkeyIter.Init(&regkeyProviders) );

    for ( hrIter=regkeyIter.Next(&stKey); hrIter == hrOK;
        hrIter=regkeyIter.Next(&stKey), regkeyProv.Close() )
    {
        // Open the key
        // ------------------------------------------------------------
        dwErr = regkeyProv.Open(regkeyProviders, stKey, KEY_READ);
        if ( dwErr != ERROR_SUCCESS )
            continue;

        // Initialize the data structure
        // ------------------------------------------------------------
        data.m_stTitle.Empty();
        data.m_stConfigCLSID.Empty();
        data.m_stProviderTypeGUID.Empty();
        data.m_stGuid.Empty();
        data.m_fSupportsEncryption = FALSE;
        data.m_fConfiguredInThisSession = FALSE;

        // Read in the values that we require
        // ------------------------------------------------------------
        data.m_stGuid = stKey;
        regkeyProv.QueryValue(c_szDisplayName, data.m_stTitle);
        regkeyProv.QueryValue(c_szConfigCLSID, data.m_stConfigCLSID);
        regkeyProv.QueryValue(c_szProviderTypeGUID, data.m_stProviderTypeGUID);

        pProvList->AddTail(data);
    }

    Error:
    regkeyProviders.Detach();
    return hr;
}


/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::LoadEapProviders
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  DATA_SRV_AUTH::LoadEapProviders(HKEY hkeyBase, AuthProviderList *pProvList)
{
    RegKey      regkeyProviders;
    HRESULT     hr = hrOK;
    HRESULT     hrIter;
    RegKeyIterator regkeyIter;
    CString     stKey;
    RegKey      regkeyProv;
    AuthProviderData  data;
    DWORD    dwErr;
    DWORD    dwData;

    Assert(hkeyBase);
    Assert(pProvList);

    // Open the providers key
    // ----------------------------------------------------------------
    regkeyProviders.Attach(hkeyBase);

    CORg( regkeyIter.Init(&regkeyProviders) );

    for ( hrIter=regkeyIter.Next(&stKey); hrIter == hrOK;
        hrIter=regkeyIter.Next(&stKey), regkeyProv.Close() )
    {
        // Open the key
        // ------------------------------------------------------------
        dwErr = regkeyProv.Open(regkeyProviders, stKey, KEY_READ);
        if ( dwErr != ERROR_SUCCESS )
            continue;

        dwData = 0;
        regkeyProv.QueryValue(c_szRegValRolesSupported, dwData);

        if ( dwData & RAS_EAP_ROLE_EXCLUDE_IN_EAP )
            continue;

        // Initialize the data structure
        // ------------------------------------------------------------
        data.m_stKey = stKey;
        data.m_stTitle.Empty();
        data.m_stConfigCLSID.Empty();
        data.m_stGuid.Empty();
        data.m_fSupportsEncryption = FALSE;
        data.m_dwFlags = 0;

        // Read in the values that we require
        // ------------------------------------------------------------
        regkeyProv.QueryValue(c_szFriendlyName, data.m_stTitle);
        regkeyProv.QueryValue(c_szConfigCLSID, data.m_stConfigCLSID);
        regkeyProv.QueryValue(c_szMPPEEncryptionSupported, dwData);
        data.m_fSupportsEncryption = (dwData != 0);

        // Read in the standalone supported value.
        // ------------------------------------------------------------
        if (!FHrOK(regkeyProv.QueryValue(c_szStandaloneSupported, dwData)))
            dwData = 1;    // the default
        data.m_dwFlags = dwData;

        pProvList->AddTail(data);
    }

    Error:
    regkeyProviders.Detach();
    return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::SetNewActiveAuthProvider
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_AUTH::SetNewActiveAuthProvider(HWND hWnd)
{
    GUID     guid;
    HRESULT     hr = hrOK;
    SPIAuthenticationProviderConfig  spAuthConfigOld;
    SPIAuthenticationProviderConfig  spAuthConfigNew;
    AuthProviderData *   pData;
    ULONG_PTR    uConnectionNew = 0;
    ULONG_PTR    uConnectionOld = 0;

    if ( m_stGuidOriginalAuthProv == m_stGuidActiveAuthProv )
        return hrOK;


    // Create an instance of the old auth provider
    // ----------------------------------------------------------------
    if ( !m_stGuidOriginalAuthProv.IsEmpty() )
    {
        pData = FindProvData(m_authProvList,
                             m_stGuidOriginalAuthProv);

        //$ TODO : need better error handling
        // ------------------------------------------------------------
        if ( pData == NULL )
            CORg( E_FAIL );

        if ( !pData->m_stConfigCLSID.IsEmpty() )
        {
            CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID),
                                  &guid) );
            CORg( CoCreateInstance(guid,
                                   NULL,
                                   CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                                   IID_IAuthenticationProviderConfig,
                                   (LPVOID *) &spAuthConfigOld) );

            Assert(spAuthConfigOld);
            CORg( spAuthConfigOld->Initialize(m_stServer,
                                              &uConnectionOld) );
        }
    }

    // Create an instance of the new auth provider
    // ----------------------------------------------------------------
    if ( !m_stGuidActiveAuthProv.IsEmpty() )
    {
        pData = FindProvData(m_authProvList,
                             m_stGuidActiveAuthProv);

        //$ TODO : need better error handling
        // ------------------------------------------------------------
        if ( pData == NULL )
            CORg( E_FAIL );

        if ( !pData->m_stConfigCLSID.IsEmpty() )
        {
            CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID),
                                  &guid) );
            CORg( CoCreateInstance(guid,
                                   NULL,
                                   CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                                   IID_IAuthenticationProviderConfig,
                                   (LPVOID *) &spAuthConfigNew) );
            Assert(spAuthConfigNew);
            CORg( spAuthConfigNew->Initialize(m_stServer, &uConnectionNew) );
        }
    }


    // Deactivate the current auth provider
    //$ TODO : need to enhance the error reporting
    // ----------------------------------------------------------------
    if ( spAuthConfigOld )
        CORg( spAuthConfigOld->Deactivate(uConnectionOld, 0, 0) );

    // Set the new GUID in the registry
    // ----------------------------------------------------------------
    m_regkeyAuth.SetValue(c_szActiveProvider, m_stGuidActiveAuthProv);
    m_stGuidOriginalAuthProv = m_stGuidActiveAuthProv;

    // Activate the new auth provider
    // ----------------------------------------------------------------
    if ( spAuthConfigNew )
        CORg( spAuthConfigNew->Activate(uConnectionNew, 0, 0) );

Error:

    // Cleanup
    if (spAuthConfigOld && uConnectionOld)
        spAuthConfigOld->Uninitialize(uConnectionOld);
    if (spAuthConfigNew && uConnectionNew)
        spAuthConfigNew->Uninitialize(uConnectionNew);
        
    if ( !FHrSucceeded(hr) )
        Trace1("DATA_SRV_AUTH::SetNewActiveAuthProvider failed.  Hr = %lx", hr);
    
    return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::SetNewActiveAcctProvider
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DATA_SRV_AUTH::SetNewActiveAcctProvider(HWND hWnd)
{
    GUID     guid;
    HRESULT     hr = hrOK;
    SPIAccountingProviderConfig   spAcctConfigOld;
    SPIAccountingProviderConfig   spAcctConfigNew;
    AuthProviderData *   pData;
    ULONG_PTR    uConnectionOld = 0;
    ULONG_PTR    uConnectionNew = 0;

    if ( m_stGuidOriginalAcctProv == m_stGuidActiveAcctProv )
        return hrOK;


    // Create an instance of the old Acct provider
    // ----------------------------------------------------------------
    if ( !m_stGuidOriginalAcctProv.IsEmpty() )
    {
        pData = FindProvData(m_acctProvList,
                             m_stGuidOriginalAcctProv);

        //$ TODO : need better error handling
        // ------------------------------------------------------------
        if ( pData == NULL )
            CORg( E_FAIL );

        if ( !pData->m_stConfigCLSID.IsEmpty() )
        {
            CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID),
                                  &guid) );
            CORg( CoCreateInstance(guid,
                                   NULL,
                                   CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                                   IID_IAccountingProviderConfig,
                                   (LPVOID *) &spAcctConfigOld) );
            Assert(spAcctConfigOld);
            CORg( spAcctConfigOld->Initialize(m_stServer, &uConnectionOld) );
        }
    }

    // Create an instance of the new Acct provider
    // ----------------------------------------------------------------
    if ( !m_stGuidActiveAcctProv.IsEmpty() )
    {
        pData = FindProvData(m_acctProvList,
                             m_stGuidActiveAcctProv);

        //$ TODO : need better error handling
        // ------------------------------------------------------------
        if ( pData == NULL )
            CORg( E_FAIL );

        if ( !pData->m_stConfigCLSID.IsEmpty() )
        {
            CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID), &guid) );
            CORg( CoCreateInstance(guid,
                                   NULL,
                                   CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                                   IID_IAccountingProviderConfig,
                                   (LPVOID *) &spAcctConfigNew) );
            Assert(spAcctConfigNew);
            CORg( spAcctConfigNew->Initialize(m_stServer, &uConnectionNew) );
        }
    }


    // Deactivate the current Acct provider
    //$ TODO : need to enhance the error reporting
    // ----------------------------------------------------------------
    if ( spAcctConfigOld )
        CORg( spAcctConfigOld->Deactivate(uConnectionOld, 0, 0) );

    // Set the new GUID in the registry
    // ----------------------------------------------------------------
    m_regkeyAcct.SetValue(c_szActiveProvider, m_stGuidActiveAcctProv);
    m_stGuidOriginalAcctProv = m_stGuidActiveAcctProv;


    // Activate the new Acct provider
    // ----------------------------------------------------------------
    if ( spAcctConfigNew )
        CORg( spAcctConfigNew->Activate(uConnectionNew, 0, 0) );

Error:

    if (spAcctConfigOld && uConnectionOld)
        spAcctConfigOld->Uninitialize(uConnectionOld);
    if (spAcctConfigNew && uConnectionNew)
        spAcctConfigNew->Uninitialize(uConnectionNew);
    
    if ( !FHrSucceeded(hr) )
        Trace1("DATA_SRV_AUTH::SetNewActiveAcctProvider failed. hr = %lx", hr);

    return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::FindProvData
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
AuthProviderData * DATA_SRV_AUTH::FindProvData(AuthProviderList &provList,
                                               const TCHAR *pszGuid)
{
    POSITION pos;
    AuthProviderData * pData = NULL;

    pos = provList.GetHeadPosition();
    while ( pos )
    {
        pData = &provList.GetNext(pos);

        if ( pData->m_stGuid == pszGuid )
            break;

        pData = NULL;
    }
    return pData;
}


/*---------------------------------------------------------------------------
   EAPConfigurationDialog implementation
 ---------------------------------------------------------------------------*/


BEGIN_MESSAGE_MAP(EAPConfigurationDialog, CBaseDialog)
//{{AFX_MSG_MAP(EAPConfigurationDialog)
// ON_COMMAND(IDC_RTR_EAPCFG_BTN_CFG, OnConfigure)
ON_CONTROL(LBN_SELCHANGE, IDC_RTR_EAPCFG_LIST, OnListChange)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
   EAPConfigurationDialog::~EAPConfigurationDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
EAPConfigurationDialog::~EAPConfigurationDialog()
{
}

void EAPConfigurationDialog::DoDataExchange(CDataExchange *pDX)
{
    CBaseDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_RTR_EAPCFG_LIST, m_listBox);
}

/*!--------------------------------------------------------------------------
   EAPConfigurationDialog::OnInitDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL EAPConfigurationDialog::OnInitDialog()
{
    HRESULT     hr = hrOK;
    BOOL        fStandalone;
    POSITION pos;
    AuthProviderData *pData;
    int         cRows = 0;
    int         iIndex;

    CBaseDialog::OnInitDialog();

    // Are we a standalone server?
    // ----------------------------------------------------------------
    fStandalone = (HrIsStandaloneServer(m_stMachine) == hrOK);

    // Now add what is in the cfg list to the listbox
    // ----------------------------------------------------------------
    pos = m_pProvList->GetHeadPosition();

    while ( pos )
    {
        pData = &m_pProvList->GetNext(pos);

        // Windows NT Bug : 180374
        // If this is a standalone machine and the standalone flag
        // is not here, then do not add this machine to the list.
        // ------------------------------------------------------------
        if (fStandalone && ((pData->m_dwFlags & 0x1) == 0))
            continue;

        if (pData->m_stTitle.IsEmpty())
        {
            CString    stTemp;
            stTemp.Format(IDS_ERR_EAP_BOGUS_NAME, pData->m_stKey);
            iIndex = m_listBox.AddString(stTemp);
        }
        else
        {
            iIndex = m_listBox.AddString(pData->m_stTitle);
        }
        if ( iIndex == LB_ERR )
            break;

        // Store a pointer to the EAPCfgData in the list box item data
        // ------------------------------------------------------------
        m_listBox.SetItemData(iIndex, (LONG_PTR) pData);

        cRows++;
    }

    
    // enable/disable the configure button depending if something
    // is selected.
    // ----------------------------------------------------------------
//    GetDlgItem(IDC_RTR_EAPCFG_BTN_CFG)->EnableWindow(
//                                                    m_listBox.GetCurSel() != LB_ERR);

//Error:

    if ( !FHrSucceeded(hr) )
        OnCancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
   EAPConfigurationDialog::OnListChange
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void EAPConfigurationDialog::OnListChange()
{
    int   iSel;

    iSel = m_listBox.GetCurSel();

    // Enable/disable the window appropriately
    // ----------------------------------------------------------------
//    GetDlgItem(IDC_RTR_EAPCFG_BTN_CFG)->EnableWindow(iSel != LB_ERR);
}


/*!--------------------------------------------------------------------------
   EAPConfigurationDialog::OnConfigure
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
 /* configure button is moved to NAP/Profile/Authentication page
void EAPConfigurationDialog::OnConfigure()
{
    // Bring up the configuration UI for this EAP
    // ----------------------------------------------------------------
    AuthProviderData *   pData;
    int            iSel;
    SPIEAPProviderConfig spEAPConfig;
    GUID        guid;
    HRESULT        hr = hrOK;
    ULONG_PTR    uConnection = 0;

    iSel = m_listBox.GetCurSel();
    if ( iSel == LB_ERR )
        return;

    pData = (AuthProviderData *) m_listBox.GetItemData(iSel);
    Assert(pData);
    if ( pData == NULL )
        return;

    if ( pData->m_stConfigCLSID.IsEmpty() )
    {
        AfxMessageBox(IDS_ERR_NO_EAP_PROVIDER_CONFIG);
        return;
    }

    CORg( CLSIDFromString((LPTSTR) (LPCTSTR)(pData->m_stConfigCLSID), &guid) );

    // Create the EAP provider object
    // ----------------------------------------------------------------
    CORg( CoCreateInstance(guid,
                           NULL,
                           CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                           IID_IEAPProviderConfig,
                           (LPVOID *) &spEAPConfig) );

    // Configure this EAP provider
    // ----------------------------------------------------------------
    hr = spEAPConfig->Initialize(m_stMachine, &uConnection);
    if ( FHrSucceeded(hr) )
    {
        hr = spEAPConfig->Configure(uConnection, GetSafeHwnd(), 0, 0);
        spEAPConfig->Uninitialize(uConnection);
    }
    if ( hr == E_NOTIMPL )
        hr = hrOK;
    CORg( hr );

    Error:
    if ( !FHrSucceeded(hr) )
    {
        // Bring up an error message
        // ------------------------------------------------------------
        DisplayTFSErrorMessage(GetSafeHwnd());
    }
}

*/

//------------------------------------------------------------------------
// DATA_SRV_PPP
//------------------------------------------------------------------------
DATA_SRV_PPP::DATA_SRV_PPP()
{
    GetDefault();
}


HRESULT DATA_SRV_PPP::LoadFromReg(LPCTSTR pServerName,
                                  const RouterVersionInfo& routerVersion)
{
    HRESULT                hr = hrOK;
    DWORD               dwFlags = 0;
    LPCTSTR                pszServerFlagsKey = NULL;
    CServiceManager     sm;
    CService            svr;
    DWORD               dwState;
    // Depending on the version depends on where we look for the
    // key.
    // ----------------------------------------------------------------
    if (routerVersion.dwOsBuildNo < RASMAN_PPP_KEY_LAST_VERSION)
        pszServerFlagsKey = c_szRasmanPPPKey;
    else
        pszServerFlagsKey = c_szRegKeyRemoteAccessParameters;

    
    // If we have any error reading in the data, go with the defaults
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == m_regkey.Open(HKEY_LOCAL_MACHINE,
                                        pszServerFlagsKey,
                                        KEY_ALL_ACCESS,
                                        pServerName) )
    {
        if (ERROR_SUCCESS == m_regkey.QueryValue( c_szServerFlags, dwFlags))
        {
            m_fUseMultilink = ((dwFlags & PPPCFG_NegotiateMultilink) != 0);
            m_fUseBACP = ((dwFlags & PPPCFG_NegotiateBacp) != 0);
            m_fUseLCPExtensions = ((dwFlags & PPPCFG_UseLcpExtensions) != 0);
            m_fUseSwCompression = ((dwFlags & PPPCFG_UseSwCompression) != 0);
            
        }
    }
    return hr;
}

HRESULT DATA_SRV_PPP::SaveToReg()
{
    HRESULT  hr = hrOK;
    DWORD dwFlags = 0;

    // Need to reread server flags in case some other page set the flags
    // ----------------------------------------------------------------
    CWRg( m_regkey.QueryValue( c_szServerFlags, dwFlags) );

    if ( m_fUseMultilink )
        dwFlags |= PPPCFG_NegotiateMultilink;
    else
        dwFlags &= ~PPPCFG_NegotiateMultilink;

    if ( m_fUseBACP )
        dwFlags |= PPPCFG_NegotiateBacp;
    else
        dwFlags &= ~PPPCFG_NegotiateBacp;

    if ( m_fUseLCPExtensions )
        dwFlags |= PPPCFG_UseLcpExtensions;
    else
        dwFlags &= ~PPPCFG_UseLcpExtensions;

    if ( m_fUseSwCompression )
        dwFlags |= PPPCFG_UseSwCompression;
    else
        dwFlags &= ~PPPCFG_UseSwCompression;

        
    CWRg( m_regkey.SetValue( c_szServerFlags, dwFlags) );

    //TODO$:now call rasman api to load the qos stuff.
Error:
    return hr;
}

void DATA_SRV_PPP::GetDefault()
{
    m_fUseMultilink = TRUE;
    m_fUseBACP = TRUE;
    m_fUseLCPExtensions = TRUE;
    m_fUseSwCompression = TRUE;
;
    
};


//**********************************************************************
// PPP router configuration page
//**********************************************************************
BEGIN_MESSAGE_MAP(RtrPPPCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrPPPCfgPage)
ON_BN_CLICKED(IDC_PPPCFG_BTN_MULTILINK, OnButtonClickMultilink)
ON_BN_CLICKED(IDC_PPPCFG_BTN_BACP, OnButtonClick)
ON_BN_CLICKED(IDC_PPPCFG_BTN_LCP, OnButtonClick)
ON_BN_CLICKED(IDC_PPPCFG_BTN_SWCOMP, OnButtonClick)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RtrPPPCfgPage::RtrPPPCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrPPPCfgPage)
    //}}AFX_DATA_INIT
}

RtrPPPCfgPage::~RtrPPPCfgPage()
{
}

void RtrPPPCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrPPPCfgPage)
    //}}AFX_DATA_MAP
}

HRESULT  RtrPPPCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                             const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataPPP.LoadFromReg(m_pRtrCfgSheet->m_stServerName,
                          routerVersion);
    
    return S_OK;
};


BOOL RtrPPPCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;

    RtrPropertyPage::OnInitDialog();

    CheckDlgButton(IDC_PPPCFG_BTN_MULTILINK, m_DataPPP.m_fUseMultilink);
    CheckDlgButton(IDC_PPPCFG_BTN_BACP, m_DataPPP.m_fUseBACP);
    CheckDlgButton(IDC_PPPCFG_BTN_LCP, m_DataPPP.m_fUseLCPExtensions);
    CheckDlgButton(IDC_PPPCFG_BTN_SWCOMP, m_DataPPP.m_fUseSwCompression);


    BOOL fMultilink = IsDlgButtonChecked(IDC_PPPCFG_BTN_MULTILINK);
    GetDlgItem(IDC_PPPCFG_BTN_BACP)->EnableWindow(fMultilink);


    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}


BOOL RtrPPPCfgPage::OnApply()
{
    BOOL fReturn=TRUE;
    HRESULT     hr = hrOK;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    m_DataPPP.m_fUseMultilink = IsDlgButtonChecked(IDC_PPPCFG_BTN_MULTILINK);
    m_DataPPP.m_fUseBACP = IsDlgButtonChecked(IDC_PPPCFG_BTN_BACP);
    m_DataPPP.m_fUseLCPExtensions = IsDlgButtonChecked(IDC_PPPCFG_BTN_LCP);
    m_DataPPP.m_fUseSwCompression = IsDlgButtonChecked(IDC_PPPCFG_BTN_SWCOMP);

    fReturn = RtrPropertyPage::OnApply();

    
    return fReturn;
}


void RtrPPPCfgPage::OnButtonClick() 
{
    SetDirty(TRUE);
    SetModified();
}

void RtrPPPCfgPage::OnButtonClickMultilink()
{
    BOOL fMultilink = IsDlgButtonChecked(IDC_PPPCFG_BTN_MULTILINK);

    GetDlgItem(IDC_PPPCFG_BTN_BACP)->EnableWindow(fMultilink);
    
    
    SetDirty(TRUE);
    SetModified();
}


//------------------------------------------------------------------------
// DATA_SRV_RASERRLOG
//------------------------------------------------------------------------
DATA_SRV_RASERRLOG::DATA_SRV_RASERRLOG()
{
    GetDefault();
}


HRESULT DATA_SRV_RASERRLOG::LoadFromReg(LPCTSTR pszServerName /*=NULL*/)
{
    HRESULT    hr = hrOK;
    RAS_DIAGNOSTIC_FUNCTIONS        rdf;
    // Default value is to have maximum logging (per Gibbs)
    // ----------------------------------------------------------------
    DWORD   dwFlags = RAS_LOGGING_WARN;
    DWORD                           dwTracing = FALSE;
    DiagGetDiagnosticFunctions        diagfunc;
    HMODULE hModule = LoadLibrary ( L"rasmontr.dll");

    if ( NULL != hModule )
    {
        diagfunc = (DiagGetDiagnosticFunctions)GetProcAddress ( hModule, "GetDiagnosticFunctions" );

        if ( NULL != diagfunc )
        {
            if ( diagfunc(&rdf) == NO_ERROR )
            {
                if ( rdf.Init() == NO_ERROR )
                {
                    dwTracing = rdf.GetState();
                    rdf.UnInit();
                }
            }
        }
        FreeLibrary(hModule);
    }
    if ( ERROR_SUCCESS == m_regkey.Open(HKEY_LOCAL_MACHINE,
                                        c_szRegKeyRemoteAccessParameters,
                                        KEY_ALL_ACCESS,
                                        pszServerName) )
    {
        if (m_regkey.QueryValue( c_szRegValLoggingFlags, dwFlags) != ERROR_SUCCESS)
            dwFlags = RAS_LOGGING_WARN;
    }

    
/*
    if ( ERROR_SUCCESS == m_regkeyFileLogging.Open(HKEY_LOCAL_MACHINE,
                                               c_szRegKeyPPPTracing,
                                               KEY_ALL_ACCESS,
                                               pszServerName) )
    {
        if (m_regkeyFileLogging.QueryValue(c_szRegValEnableFileTracing, dwTracing) != ERROR_SUCCESS)
            dwTracing = FALSE;
    }
*/  
    m_stServer = pszServerName;
    m_dwLogLevel = dwFlags;
    m_dwEnableFileTracing = dwTracing;
    m_dwOldEnableFileTracing = dwTracing;

    return hr;
}

HRESULT DATA_SRV_RASERRLOG::SaveToReg()
{
    HRESULT  hr = hrOK;

    if ((HKEY) m_regkey == 0)
    {
        // Try to create the regkey
        // ------------------------------------------------------------
        CWRg( m_regkey.Create(HKEY_LOCAL_MACHINE,
                              c_szRegKeyRemoteAccessParameters,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              (LPCTSTR) m_stServer
                             ) );
    }

    CWRg( m_regkey.SetValue( c_szRegValLoggingFlags, m_dwLogLevel) );

    
    if (m_dwOldEnableFileTracing != m_dwEnableFileTracing)
    {
        RAS_DIAGNOSTIC_FUNCTIONS        rdf;
        DiagGetDiagnosticFunctions        diagfunc = NULL;

        HMODULE hModule = LoadLibrary ( L"rasmontr.dll");

        if ( NULL != hModule )
        {
            diagfunc = (DiagGetDiagnosticFunctions)GetProcAddress ( hModule, "GetDiagnosticFunctions" );

            if ( NULL != diagfunc )
            {
                if ( diagfunc(&rdf) == NO_ERROR )
                {
                    if ( rdf.Init() == NO_ERROR )
                    {
                        rdf.SetAllRas(m_dwEnableFileTracing);
                        rdf.UnInit();
                    }
                }
            }
            FreeLibrary(hModule);
        }
/*
        if ((HKEY) m_regkeyFileLogging == 0)
        {
            // Try to create the regkey
            // ------------------------------------------------------------
            CWRg( m_regkeyFileLogging.Create(HKEY_LOCAL_MACHINE,
                                             c_szRegKeyPPPTracing,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS,
                                             NULL,
                                             (LPCTSTR) m_stServer
                                            ) );
        }
        
        CWRg( m_regkeyFileLogging.SetValue( c_szRegValEnableFileTracing,
                                            m_dwEnableFileTracing) );
*/
        m_dwOldEnableFileTracing = m_dwEnableFileTracing;
    }
    
Error:
    return hr;
}

void DATA_SRV_RASERRLOG::GetDefault()
{
    // Default value is to log errors and warnings (per Gibbs)
    // ----------------------------------------------------------------
    m_dwLogLevel = RAS_LOGGING_WARN;

    // Default is to have no file logging
    // ----------------------------------------------------------------
    m_dwEnableFileTracing = FALSE;
    m_dwOldEnableFileTracing = FALSE;
};


HRESULT DATA_SRV_RASERRLOG::UseDefaults(LPCTSTR pServerName, BOOL fNT4)
{
    HRESULT    hr = hrOK;

    m_stServer = pServerName;    
    GetDefault();

//Error:
    return hr;
}

BOOL DATA_SRV_RASERRLOG::FNeedRestart()
{
    // We only need a restart if the enable file tracing is changed.
    // ----------------------------------------------------------------
    return FALSE;
    //BugID:390829.  Enable tracing does not require a restart.
    //return (m_dwEnableFileTracing != m_dwOldEnableFileTracing);
}




/*---------------------------------------------------------------------------
    RtrLogLevelCfgPage implementation
 ---------------------------------------------------------------------------*/


BEGIN_MESSAGE_MAP(RtrLogLevelCfgPage, RtrPropertyPage)
//{{AFX_MSG_MAP(RtrLogLevelCfgPage)
ON_BN_CLICKED(IDC_ELOG_BTN_LOGNONE, OnButtonClick)
ON_BN_CLICKED(IDC_ELOG_BTN_LOGERROR, OnButtonClick)
ON_BN_CLICKED(IDC_ELOG_BTN_LOGWARN, OnButtonClick)
ON_BN_CLICKED(IDC_ELOG_BTN_LOGINFO, OnButtonClick)
ON_BN_CLICKED(IDC_ELOG_BTN_PPP, OnButtonClick)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RtrLogLevelCfgPage::RtrLogLevelCfgPage(UINT nIDTemplate, UINT nIDCaption /* = 0*/)
: RtrPropertyPage(nIDTemplate, nIDCaption)
{
    //{{AFX_DATA_INIT(RtrLogLevelCfgPage)
    //}}AFX_DATA_INIT
}

RtrLogLevelCfgPage::~RtrLogLevelCfgPage()
{
}

void RtrLogLevelCfgPage::DoDataExchange(CDataExchange* pDX)
{
    RtrPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(RtrLogLevelCfgPage)
    //}}AFX_DATA_MAP
}

HRESULT  RtrLogLevelCfgPage::Init(RtrCfgSheet * pRtrCfgSheet,
                                  const RouterVersionInfo& routerVersion)
{
    Assert (pRtrCfgSheet);
    m_pRtrCfgSheet=pRtrCfgSheet;
    m_DataRASErrLog.LoadFromReg(m_pRtrCfgSheet->m_stServerName);

    return S_OK;
};


BOOL RtrLogLevelCfgPage::OnInitDialog() 
{
    HRESULT     hr= hrOK;
    int            nButton;

    RtrPropertyPage::OnInitDialog();

    switch (m_DataRASErrLog.m_dwLogLevel)
    {
        case RAS_LOGGING_NONE:
            nButton = IDC_ELOG_BTN_LOGNONE;
            break;
        case RAS_LOGGING_ERROR:
            nButton = IDC_ELOG_BTN_LOGERROR;
            break;
        case RAS_LOGGING_WARN:
            nButton = IDC_ELOG_BTN_LOGWARN;
            break;
        case RAS_LOGGING_INFO:
            nButton = IDC_ELOG_BTN_LOGINFO;
            break;
        default:
            Panic0("Unknown logging type");
            break;
    }
    CheckRadioButton(IDC_ELOG_BTN_LOGNONE,
                     IDC_ELOG_BTN_LOGINFO,
                     nButton);

    CheckDlgButton(IDC_ELOG_BTN_PPP, m_DataRASErrLog.m_dwEnableFileTracing);

    SetDirty(FALSE);

    if ( !FHrSucceeded(hr) )
        Cancel();
    return FHrSucceeded(hr) ? TRUE : FALSE;
}


BOOL RtrLogLevelCfgPage::OnApply()
{
    BOOL fReturn=TRUE;

    HRESULT     hr = hrOK;

    if ( m_pRtrCfgSheet->IsCancel() )
        return TRUE;

    // This will save the data if needed.
    // ----------------------------------------------------------------
    hr = m_pRtrCfgSheet->SaveRequiredRestartChanges(GetSafeHwnd());

    if (FHrSucceeded(hr))
        fReturn = RtrPropertyPage::OnApply();

    if ( !FHrSucceeded(hr) )
        fReturn = FALSE;
    return fReturn;
}


void RtrLogLevelCfgPage::OnButtonClick() 
{
    SaveSettings();
    SetDirty(TRUE);
    SetModified();
}


void RtrLogLevelCfgPage::SaveSettings()
{
    if (IsDlgButtonChecked(IDC_ELOG_BTN_LOGERROR))
    {
        m_DataRASErrLog.m_dwLogLevel = RAS_LOGGING_ERROR;
    }
    else if (IsDlgButtonChecked(IDC_ELOG_BTN_LOGNONE))
    {
        m_DataRASErrLog.m_dwLogLevel = RAS_LOGGING_NONE;
    }
    else if (IsDlgButtonChecked(IDC_ELOG_BTN_LOGINFO))
    {
        m_DataRASErrLog.m_dwLogLevel = RAS_LOGGING_INFO;
    }
    else if (IsDlgButtonChecked(IDC_ELOG_BTN_LOGWARN))
    {
        m_DataRASErrLog.m_dwLogLevel = RAS_LOGGING_WARN;
    }
    else
    {
        Panic0("Nothing is selected");
    }

    m_DataRASErrLog.m_dwEnableFileTracing = IsDlgButtonChecked(IDC_ELOG_BTN_PPP);
    
}




/*---------------------------------------------------------------------------
    AuthenticationSettingsDialog Implementation
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(AuthenticationSettingsDialog, CBaseDialog)
//{{AFX_MSG_MAP(AuthenticationSettingsDialog)
ON_BN_CLICKED(IDC_RTR_AUTH_BTN_DETAILS, OnRtrAuthCfgEAP)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


const DWORD s_rgdwAuth[] =
{
    IDC_RTR_AUTH_BTN_NOAUTH,   PPPCFG_AllowNoAuthentication,
    IDC_RTR_AUTH_BTN_EAP,      PPPCFG_NegotiateEAP,
    IDC_RTR_AUTH_BTN_CHAP,     PPPCFG_NegotiateMD5CHAP,
    IDC_RTR_AUTH_BTN_MSCHAP,   PPPCFG_NegotiateMSCHAP,
    IDC_RTR_AUTH_BTN_PAP,      PPPCFG_NegotiatePAP,
    IDC_RTR_AUTH_BTN_SPAP,     PPPCFG_NegotiateSPAP,
    IDC_RTR_AUTH_BTN_MSCHAPV2, PPPCFG_NegotiateStrongMSCHAP,
    0, 0,
};

/*!--------------------------------------------------------------------------
    AuthenticationSettingsDialog::SetAuthFlags
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void AuthenticationSettingsDialog::SetAuthFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

/*!--------------------------------------------------------------------------
    AuthenticationSettingsDialog::GetAuthFlags
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
DWORD AuthenticationSettingsDialog::GetAuthFlags()
{
    return m_dwFlags;
}

/*!--------------------------------------------------------------------------
    AuthenticationSettingsDialog::ReadFlagState
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void AuthenticationSettingsDialog::ReadFlagState()
{
    int      iPos = 0;
    DWORD dwTemp;

    for ( iPos = 0; s_rgdwAuth[iPos] != 0; iPos += 2 )
    {
        dwTemp = s_rgdwAuth[iPos+1];
        if ( IsDlgButtonChecked(s_rgdwAuth[iPos]) )
            m_dwFlags |= dwTemp;
        else
            m_dwFlags &= ~dwTemp;

        Assert(iPos < DimensionOf(s_rgdwAuth));
    }
}


/*!--------------------------------------------------------------------------
    AuthenticationSettingsDialog::CheckAuthenticationControls
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void AuthenticationSettingsDialog::CheckAuthenticationControls(DWORD dwFlags)
{
    int      iPos = 0;

    for ( iPos = 0; s_rgdwAuth[iPos] != 0; iPos += 2 )
    {
        CheckDlgButton(s_rgdwAuth[iPos],
                       (dwFlags & s_rgdwAuth[iPos+1]) != 0);
    }

}

void AuthenticationSettingsDialog::DoDataExchange(CDataExchange *pDX)
{
    CBaseDialog::DoDataExchange(pDX);
}

BOOL AuthenticationSettingsDialog::OnInitDialog()
{
    CBaseDialog::OnInitDialog();
    
    CheckAuthenticationControls(m_dwFlags);
    
    return TRUE;
}

void AuthenticationSettingsDialog::OnOK()
{
    ReadFlagState();

    // Windows NT Bug : ???
    // At least one of the authentication checkboxes must be checked.
    // ----------------------------------------------------------------
    if (!(m_dwFlags & USE_PPPCFG_ALL_METHODS))
    {
        // None of the flags are checked!
        // ------------------------------------------------------------
        AfxMessageBox(IDS_ERR_NO_AUTH_PROTOCOLS_SELECTED, MB_OK);
        return;        
    }

    CBaseDialog::OnOK();
}


/*!--------------------------------------------------------------------------
   AuthenticationSettingsDialog::OnRtrAuthCfgEAP
      Brings up the EAP configuration dialog.
   Author: KennT
 ---------------------------------------------------------------------------*/
void AuthenticationSettingsDialog::OnRtrAuthCfgEAP()
{
    EAPConfigurationDialog     eapdlg(m_stMachine, m_pProvList);

    eapdlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   rtrsnap.cpp
      Snapin entry points/registration functions
      
      Note: Proxy/Stub Information
         To build a separate proxy/stub DLL, 
         run nmake -f Snapinps.mak in the project directory.

   FILE HISTORY:
        
*/

#include "stdafx.h"
#include <advpub.h>         // For REGINSTALL
#include "dmvcomp.h"
#include "register.h"
#include "rtrguid.h"
#include "atlkcomp.h"
#include "radcfg.h"           // for RouterAuthRadiusConfig
#include "qryfrm.h"
#include "ncglobal.h"  // network console global defines
#include "cmptrmgr.h"   // computer management snapin node types
#include "rtrutilp.h"

#include "dialog.h"

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_ATLKAdminExtension, CATLKComponentData)
   OBJECT_ENTRY(CLSID_ATLKAdminAbout, CATLKAbout)
   OBJECT_ENTRY(CLSID_RouterSnapin, CDomainViewSnap)
   OBJECT_ENTRY(CLSID_RouterSnapinExtension, CDomainViewSnapExtension)
   OBJECT_ENTRY(CLSID_RouterSnapinAbout, CDomainViewSnapAbout)
   OBJECT_ENTRY(CLSID_RouterAuthRADIUS, RouterAuthRadiusConfig)
   OBJECT_ENTRY(CLSID_RouterAcctRADIUS, RouterAcctRadiusConfig)
   OBJECT_ENTRY(CLSID_RRASQueryForm, CRRASQueryForm)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
   This is a list of nodetypes that need to be registered.
 ---------------------------------------------------------------------------*/

struct RegisteredNodeTypes
{
   const GUID *m_pGuid;
   LPCTSTR     m_pszName;
};

const static RegisteredNodeTypes s_rgNodeTypes[] =
{
   { &GUID_RouterDomainNodeType, _T("Root of Router Domain Snapin") },
   { &GUID_RouterIfAdminNodeType, _T("Routing Interfaces") },
   { &GUID_RouterMachineErrorNodeType, _T("Router - Error") },
   { &GUID_RouterMachineNodeType, _T("Router Machine - General (7)") },
   { &GUID_RouterDialInNodeType, _T("Routing dial-in users") },
   { &GUID_RouterPortsNodeType, _T("Ports") },
};



class CRouterSnapinApp : public CWinApp
{
public:
   virtual BOOL InitInstance();
   virtual int ExitInstance();
};

CRouterSnapinApp theApp;

BOOL CRouterSnapinApp::InitInstance()
{
   TCHAR        tszHelpFilePath[MAX_PATH+1]={0};
 
   _Module.Init(ObjectMap, m_hInstance);
   
   InitializeTFSError();
   CreateTFSErrorInfo(0);

   // Setup the global help function
   extern DWORD * MprSnapHelpMap(DWORD dwIDD);
   SetGlobalHelpMapFunction(MprSnapHelpMap);
   
   IPAddrInit(m_hInstance);
   //Set the help file path
   free((void*)m_pszHelpFilePath);
   GetWindowsDirectory(tszHelpFilePath, MAX_PATH);
   _tcscat(tszHelpFilePath, TEXT("\\help\\mprsnap.hlp"));
   m_pszHelpFilePath = _tcsdup(tszHelpFilePath); 

   return CWinApp::InitInstance();
}

int CRouterSnapinApp::ExitInstance()
{
    RemoveAllNetConnections();
    
   _Module.Term();

   DestroyTFSErrorInfo(0);
   CleanupTFSError();

   DEBUG_VERIFY_INSTANCE_COUNTS;

   return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

const static GUID *  s_pExtensionGuids[] =
{
   &GUID_RouterMachineNodeType,
};


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}

HRESULT CallRegInstall(LPSTR szSection);

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT  hr = hrOK;
   CString  stDisplayName, stAtlkDisplayName, stNameStringIndirect;
   TCHAR	moduleFileName[MAX_PATH * 2];

   GetModuleFileNameOnly(_Module.GetModuleInstance(), moduleFileName, MAX_PATH * 2);

   int      i;

   // registers object, typelib and all interfaces in typelib
   //
   hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
   Assert(SUCCEEDED(hr));

   CORg( hr );

   // Load the name of the router snapins
   stDisplayName.LoadString(IDS_SNAPIN_DISPLAY_NAME);
   stAtlkDisplayName.LoadString(IDS_ATLK_DISPLAY_NAME);
   stNameStringIndirect.Format(L"@%s,-%-d", moduleFileName, IDS_SNAPIN_DISPLAY_NAME);
   
   // register the snapin into the console snapin list
   // ~domain view snapin
    CORg( RegisterSnapinGUID(&CLSID_RouterSnapin,
                  NULL,
                  &CLSID_RouterSnapinAbout,
                  stDisplayName,
                  _T("1.0"),
                  TRUE,
				  stNameStringIndirect
                  ) );

    CORg( RegisterSnapinGUID(&CLSID_RouterSnapinExtension, 
                  NULL, 
                  &CLSID_RouterSnapinAbout,
                  stDisplayName, 
                  _T("1.0"), 
                  FALSE,
                  stNameStringIndirect));

   stNameStringIndirect.Format(L"@%s,-%-d", moduleFileName, IDS_ATLK_DISPLAY_NAME);
    CORg( RegisterSnapinGUID(&CLSID_ATLKAdminExtension,
                  NULL,
                  &CLSID_ATLKAdminAbout,
                  stAtlkDisplayName,
                  _T("1.0"),
                  FALSE,
                  stNameStringIndirect) );
   
   // register the snapin nodes into the console node list
   //
   for (i=0; i<DimensionOf(s_rgNodeTypes); i++)
   {
      CORg( RegisterNodeTypeGUID(&CLSID_RouterSnapin,
                           s_rgNodeTypes[i].m_pGuid,
                           s_rgNodeTypes[i].m_pszName) );
   }

   // register apple talk as extension of machine
   for (i=0; i<DimensionOf(s_pExtensionGuids); i++)
   {
      CORg( RegisterAsRequiredExtensionGUID(s_pExtensionGuids[i],
                                   &CLSID_ATLKAdminExtension,
                                   stAtlkDisplayName,
                                   EXTENSION_TYPE_NAMESPACE,
                                   &CLSID_RouterSnapin) );
   }

#ifdef  __NETWORK_CONSOLE__
   // register as extension of network console
   CORg( RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_RouterSnapinExtension,
                                         stDisplayName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &GUID_NetConsRootNodeType));   // doesn't matter what this is, just 
                                                                         // needs to be non-null guid
#endif

   // register as extension of computer management
   CORg( RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_RouterSnapinExtension,
                                         stDisplayName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS));
   // Register DS Query Forms -- WeiJiang 1-29-98
   CORg(CallRegInstall("RegDll")); 
   // End of DS Query
   
Error:

   if (!FHrSucceeded(hr))
   {
      // Now we need to get the error object and display it
      if (!FHrSucceeded(DisplayTFSErrorMessage(NULL)))
      {
         TCHAR szBuffer[1024];
         
         // Couldn't find a TFS error, bring up a general
         // error message
         FormatError(hr, szBuffer, DimensionOf(szBuffer));
         AfxMessageBox(szBuffer);
      }
   }

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
   int      i;
   HRESULT  hr = hrOK;
   
   // Initialize the error handling system
   InitializeTFSError();

   // Create an error object for this thread
   Verify( CreateTFSErrorInfo(0) == hrOK );
   

   hr  = _Module.UnregisterServer();
   Assert(SUCCEEDED(hr));
   CORg( hr );

   // un register the snapin 
   //
   // We don't care about the error return for this
   UnregisterSnapinGUID(&CLSID_OldRouterSnapin);

   
   // Domain View Snapin   -- weijiang 1-14-98
   hr = UnregisterSnapinGUID(&CLSID_RouterSnapin);
   Assert(SUCCEEDED(hr));
   // ~Domain View Snapin


   // Unregister the nodes that Appletalk extends
   for (i=0; i<DimensionOf(s_pExtensionGuids); i++)
   {
      hr = UnregisterAsRequiredExtensionGUID(s_pExtensionGuids[i],
                                    &CLSID_ATLKAdminExtension, 
                                    EXTENSION_TYPE_NAMESPACE,
                                    &CLSID_RouterSnapin);
      Assert(SUCCEEDED(hr));
   }

   
   // Unregister the appletalk extension snapin
   // -----------------------------------------------------------------
   hr = UnregisterSnapinGUID(&CLSID_ATLKAdminExtension);
   Assert(SUCCEEDED(hr));

   
   // Unregister the router snapin extension snapin
   // -----------------------------------------------------------------
   hr = UnregisterSnapinGUID(&CLSID_RouterSnapinExtension);
   Assert(SUCCEEDED(hr));


   // unregister the snapin nodes 
   // -----------------------------------------------------------------
   for (i=0; i<DimensionOf(s_rgNodeTypes); i++)
   {
      hr = UnregisterNodeTypeGUID(s_rgNodeTypes[i].m_pGuid);
      Assert(SUCCEEDED(hr));
   }
    // computer manangement
    hr = UnregisterAsExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                   &CLSID_RouterSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));


   // Unregister DS Query Form -- WeiJiang 1-29-98
   hr = CallRegInstall("UnRegDll");
   Assert(SUCCEEDED(hr));

   // End of DS Query FOrm
Error:
   if (!FHrSucceeded(hr))
   {
      // Now we need to get the error object and display it
      if (!FHrSucceeded(DisplayTFSErrorMessage(NULL)))
      {
         TCHAR szBuffer[1024];
         
         // Couldn't find a TFS error, bring up a general
         // error message
         FormatError(hr, szBuffer, DimensionOf(szBuffer));
         AfxMessageBox(szBuffer);
      }
   }

   // Destroy the TFS error information for this thread
   DestroyTFSErrorInfo(0);

   // Cleanup the entire error system
   CleanupTFSError();
   
   return hr;
}

/*-----------------------------------------------------------------------------
/ CallRegInstall
/ --------------
/   Call ADVPACK for the given section of our resource based INF>
/
/ In:
/   szSection = section name to invoke
/
/ Out:
/   HRESULT:
/----------------------------------------------------------------------------*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

#ifdef UNICODE
        if ( pfnri )
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(_Module.m_hInst, szSection, &stReg);
        }
#else
        if (pfnri)
        {
            hr = pfnri(_Module.m_hInst, szSection, NULL);
        }

#endif
        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
	extern void TFSCore_DbgVerifyInstanceCounts();
	TFSCore_DbgVerifyInstanceCounts();
	
	DEBUG_VERIFY_INSTANCE_COUNT(MachineNodeData);
	DEBUG_VERIFY_INSTANCE_COUNT(InfoBase);
	DEBUG_VERIFY_INSTANCE_COUNT(InfoBlockEnumerator);
	DEBUG_VERIFY_INSTANCE_COUNT(RouterInfo);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrInfo);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrProtocolInfo);
	DEBUG_VERIFY_INSTANCE_COUNT(InterfaceInfo);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrInterfaceInfo);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrProtocolInterfaceInfo);
	
	DEBUG_VERIFY_INSTANCE_COUNT(EnumRtrMgrCB);
	DEBUG_VERIFY_INSTANCE_COUNT(EnumRtrMgrProtocolCB);
	DEBUG_VERIFY_INSTANCE_COUNT(EnumInterfaceCB);
	DEBUG_VERIFY_INSTANCE_COUNT(EnumRtrMgrInterfaceCB);
	DEBUG_VERIFY_INSTANCE_COUNT(EnumRtrMgrProtocolInterfaceCB);

	DEBUG_VERIFY_INSTANCE_COUNT(InterfaceNodeHandler);
	DEBUG_VERIFY_INSTANCE_COUNT(MachineHandler);
	
	DEBUG_VERIFY_INSTANCE_COUNT(RouterInfoAggregationWrapper);
	DEBUG_VERIFY_INSTANCE_COUNT(InterfaceInfoAggregationWrapper);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrInfoAggregationWrapper);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrProtocolInfoAggregationWrapper);
	DEBUG_VERIFY_INSTANCE_COUNT(RtrMgrProtocolInterfaceInfoAggregationWrapper);

	DEBUG_VERIFY_INSTANCE_COUNT(RouterRefreshObjectGroup);
	DEBUG_VERIFY_INSTANCE_COUNT(RefreshItem);

}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rtrhelp.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "rtrsnap.hm"
#include "resource.h"


//
// What follows is the data that gets generated from
//		mkdlg.exe -c rtrsnap.rc
//


// "File rtrsnap.rc line 479 : Resource - DIALOG : IDD_QRY_GENERAL"
static const DWORD rgdw_IDD_QRY_GENERAL[] = 
{
    IDC_QRY_CHECK_LANTOLAN, HIDC_QRY_CHECK_LANTOLAN,
    IDC_QRY_CHECK_DEMANDDIAL, HIDC_QRY_CHECK_DEMANDDIAL,
    IDC_QRY_CHECK_RAS, HIDC_QRY_CHECK_RAS,
	0,0 
};




// "File rtrsnap.rc line 470 : Resource - DIALOG : IDD_QRY_ADVANCED"
static const DWORD rgdw_IDD_QRY_ADVANCED[] = 
{
    IDC_QRY_LIST_VALUES, HIDC_QRY_LIST_VALUES,
    IDC_QRY_BUTTON_CLEARALL, HIDC_QRY_BUTTON_CLEARALL,
    IDC_QRY_BUTTON_SELECTALL, HIDC_QRY_BUTTON_SELECTALL,
	0,0 
};


// "File rtrsnap.rc line 483 : Resource - DIALOG : IDD_QRY_ADDSERVER"
static const DWORD rgdw_IDD_QRY_ADDSERVER[] = 
{
    IDC_QRY_RADIO_THIS, HIDC_QRY_RADIO_THIS,
    IDC_QRY_RADIO_ANOTHER, HIDC_QRY_RADIO_ANOTHER,
    IDC_QRY_EDIT_MACHINE, HIDC_QRY_EDIT_MACHINE,
    IDC_QRY_RADIO_NT4, HIDC_QRY_RADIO_NT4,
    IDC_QRY_EDIT_DOMAIN, HIDC_QRY_EDIT_DOMAIN,
    IDC_QRY_RADIO_NT5, HIDC_QRY_RADIO_NT5,
    IDNEXT, HIDNEXT,
	0,0 
};


// "File rtrsnap.rc line 509 : Resource - DIALOG : IDD_CONNECTING"
static const DWORD rgdw_IDD_CONNECTING[] = 
{
    IDC_EDIT_INTERFACENAME, HIDC_EDIT_INTERFACENAME,
    IDC_TEXT_IFSTATUS, HIDC_TEXT_IFSTATUS,
    IDC_TEXT_ELAPSED, HIDC_TEXT_ELAPSED,
	0,0 
};


// "File rtrsnap.rc line 524 : Resource - DIALOG : IDD_IF_CREDENTIALS"
static const DWORD rgdw_IDD_IF_CREDENTIALS[] = 
{
    IDC_EDIT_IC_USERNAME, HIDC_EDIT_IC_USERNAME,
    IDC_EDIT_IC_DOMAIN, HIDC_EDIT_IC_DOMAIN,
    IDC_EDIT_IC_PASSWORD, HIDC_EDIT_IC_PASSWORD,
    IDC_EDIT_IC_PASSWORD2, HIDC_EDIT_IC_PASSWORD2,
	0,0 
};



// "File rtrsnap.rc line 738 : Resource - DIALOG : IDD_CONNECT_AS"
static const DWORD rgdw_IDD_CONNECT_AS[] = 
{
    IDC_TEXT_INACCESSIBLE_RESOURCE, HIDC_TEXT_INACCESSIBLE_RESOURCE,
    IDC_TEXT_USER, HIDC_TEXT_USER,
    IDC_EDIT_USERNAME, HIDC_EDIT_USERNAME,
    IDC_TEXT_PASSWORD, HIDC_TEXT_PASSWORD,
    IDC_EDIT_USER_PASSWORD, HIDC_EDIT_USER_PASSWORD,
	0,0 
};


// "File rtrsnap.rc line 755 : Resource - DIALOG : IDD_RTR_IP"
static const DWORD rgdw_IDD_RTR_IP[] = 
{
    IDC_RTR_IP_BTN_ENABLE_IPROUTING, HIDC_RTR_IP_BTN_ENABLE_IPROUTING,
    IDC_RTR_IP_CB_ALLOW_REMOTETCPIP, HIDC_RTR_IP_CB_ALLOW_REMOTETCPIP,
    IDC_RTR_IP_DHCP_TEXT, HIDC_RTR_IP_DHCP_TEXT,
    IDC_RTR_IP_RB_DHCP, HIDC_RTR_IP_RB_DHCP,
    IDC_RTR_IP_RB_POOL, HIDC_RTR_IP_RB_POOL,
    IDC_RTR_IP_LIST, HIDC_RTR_IP_LIST,
    IDC_RTR_IP_BTN_ADD, HIDC_RTR_IP_BTN_ADD,
    IDC_RTR_IP_BTN_EDIT, HIDC_RTR_IP_BTN_EDIT,
    IDC_RTR_IP_BTN_REMOVE, HIDC_RTR_IP_BTN_REMOVE,
    IDC_RTR_IP_TEXT_ADAPTER, HIDC_RTR_IP_TEXT_ADAPTER,
    IDC_RTR_IP_TEXT_LABEL_ADAPTER, HIDC_RTR_IP_TEXT_LABEL_ADAPTER,
    IDC_RTR_IP_COMBO_ADAPTER, HIDC_RTR_IP_COMBO_ADAPTER,
    IDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD, HIDC_RTR_IP_BTN_ENABLE_NETBT_BCAST_FWD,
	0,0 
};


// "File rtrsnap.rc line 787 : Resource - DIALOG : IDD_RTR_IPX"
static const DWORD rgdw_IDD_RTR_IPX[] = 
{
    IDC_RTR_IPX_CB_REMOTEIPX, HIDC_RTR_IPX_CB_REMOTEIPX,
    IDC_RB_ENTIRE_NETWORK, HIDC_RB_ENTIRE_NETWORK,
    IDC_RTR_IPX_RB_AUTO, HIDC_RTR_IPX_RB_AUTO,
    IDC_RTR_IPX_RB_POOL, HIDC_RTR_IPX_RB_POOL,
    IDC_RTR_IPX_TEXT_FIRST, HIDC_RTR_IPX_TEXT_FIRST,
    IDC_RTR_IPX_EB_FIRST, HIDC_RTR_IPX_EB_FIRST,
    IDC_RTR_IPX_TEXT_LAST, HIDC_RTR_IPX_TEXT_LAST,
    IDC_RTR_IPX_EB_LAST, HIDC_RTR_IPX_EB_LAST,
    IDC_RTR_IPX_CB_SAME_ADDRESS, HIDC_RTR_IPX_CB_SAME_ADDRESS,
    IDC_RTR_IPX_CB_ALLOW_CLIENT, HIDC_RTR_IPX_CB_ALLOW_CLIENT,
	0,0 
};


// "File rtrsnap.rc line 819 : Resource - DIALOG : IDD_RTR_ARAP"
static const DWORD rgdw_IDD_RTR_ARAP[] = 
{
    IDC_RTR_ARAP_CB_REMOTEARAP, HIDC_RTR_ARAP_CB_REMOTEARAP,
	0,0 
};


// "File rtrsnap.rc line 829 : Resource - DIALOG : IDD_RTR_NBF"
static const DWORD rgdw_IDD_RTR_NBF[] = 
{
    IDC_RTR_IPX_CB_REMOTENETBEUI, HIDC_RTR_IPX_CB_REMOTENETBEUI,
    IDC_RB_THIS_COMPUTER, HIDC_RB_THIS_COMPUTER,
    IDC_RB_ENTIRE_NETWORK, HIDC_RB_ENTIRE_NETWORK,
	0,0 
};


// "File rtrsnap.rc line 844 : Resource - DIALOG : IDD_CONNECTREG"
static const DWORD rgdw_IDD_CONNECTREG[] = 
{
    IDC_EDIT_MACHINENAME, HIDC_EDIT_MACHINENAME,
	0,0 
};


// "File rtrsnap.rc line 855 : Resource - DIALOG : IDD_REFRESHRATE"
static const DWORD rgdw_IDD_REFRESHRATE[] = 
{
    IDC_EDIT_REFRESHRATE, HIDC_EDIT_REFRESHRATE,
	0,0 
};


// "File rtrsnap.rc line 870 : Resource - DIALOGEX : IDD_DDM_PORT"
static const DWORD rgdw_IDD_DDM_PORT[] = 
{
    IDC_DP_COMBO_PORTLIST, HIDC_DP_COMBO_PORTLIST,
    IDC_DP_EDIT_CONDITION, HIDC_DP_EDIT_CONDITION,
    IDC_DP_TEXT_LINEBPS, HIDC_DP_TEXT_LINEBPS,
    IDC_DP_TEXT_DURATION, HIDC_DP_TEXT_DURATION,
    IDC_DP_TEXT_BYTESIN, HIDC_DP_TEXT_BYTESIN,
    IDC_DP_TEXT_BYTESOUT, HIDC_DP_TEXT_BYTESOUT,
    IDC_DP_TEXT_CRC, HIDC_DP_TEXT_CRC,
    IDC_DP_TEXT_TIMEOUT, HIDC_DP_TEXT_TIMEOUT,
    IDC_DP_TEXT_ALIGNMENT, HIDC_DP_TEXT_ALIGNMENT,
    IDC_DP_TEXT_FRAMING, HIDC_DP_TEXT_FRAMING,
    IDC_DP_TEXT_HWOVERRUN, HIDC_DP_TEXT_HWOVERRUN,
    IDC_DP_TEXT_BUFOVERRUN, HIDC_DP_TEXT_BUFOVERRUN,
    IDC_DP_TEXT_IPADDRESS, HIDC_DP_TEXT_IPADDRESS,
    IDC_DP_TEXT_IPXADDRESS, HIDC_DP_TEXT_IPXADDRESS,
    IDC_DP_TEXT_NBFADDRESS, HIDC_DP_TEXT_NBFADDRESS,
    IDC_DP_TEXT_ATLKADDRESS, HIDC_DP_TEXT_ATLKADDRESS,
    IDC_DP_BTN_REFRESH, HIDC_DP_BTN_REFRESH,
    IDC_DP_BTN_RESET, HIDC_DP_BTN_RESET,
    IDC_DP_BTN_HANGUP, HIDC_DP_BTN_HANGUP,
	0,0 
};


// "File rtrsnap.rc line 919 : Resource - DIALOGEX : IDD_DDM_CONN"
static const DWORD rgdw_IDD_DDM_CONN[] = 
{
    IDC_DC_COMBO_CONNLIST, HIDC_DC_COMBO_CONNLIST,
    IDC_DC_TEXT_DURATION, HIDC_DC_TEXT_DURATION,
    IDC_DC_TEXT_BYTESIN, HIDC_DC_TEXT_BYTESIN,
    IDC_DC_TEXT_FRAMESIN, HIDC_DC_TEXT_FRAMESIN,
    IDC_DC_TEXT_COMPIN, HIDC_DC_TEXT_COMPIN,
    IDC_DC_TEXT_BYTESOUT, HIDC_DC_TEXT_BYTESOUT,
    IDC_DC_TEXT_FRAMESOUT, HIDC_DC_TEXT_FRAMESOUT,
    IDC_DC_TEXT_COMPOUT, HIDC_DC_TEXT_COMPOUT,
    IDC_DC_TEXT_CRC, HIDC_DC_TEXT_CRC,
    IDC_DC_TEXT_TIMEOUT, HIDC_DC_TEXT_TIMEOUT,
    IDC_DC_TEXT_ALIGNMENT, HIDC_DC_TEXT_ALIGNMENT,
    IDC_DC_TEXT_FRAMING, HIDC_DC_TEXT_FRAMING,
    IDC_DC_TEXT_HWOVERRUN, HIDC_DC_TEXT_HWOVERRUN,
    IDC_DC_TEXT_BUFOVERRUN, HIDC_DC_TEXT_BUFOVERRUN,
    IDC_DC_TEXT_IPADDRESS, HIDC_DC_TEXT_IPADDRESS,
    IDC_DC_TEXT_IPXADDRESS, HIDC_DC_TEXT_IPXADDRESS,
    IDC_DC_TEXT_NBFADDRESS, HIDC_DC_TEXT_NBFADDRESS,
    IDC_DC_TEXT_ATLKADDRESS, HIDC_DC_TEXT_ATLKADDRESS,
    IDC_DC_BTN_REFRESH, HIDC_DC_BTN_REFRESH,
    IDC_DC_BTN_RESET, HIDC_DC_BTN_RESET,
    IDC_DC_BTN_HANGUP, HIDC_DC_BTN_HANGUP,
	0,0 
};


// "File rtrsnap.rc line 970 : Resource - DIALOG : IDD_DDM_MESSAGE"
static const DWORD rgdw_IDD_DDM_MESSAGE[] = 
{
    IDC_DM_EDIT_TO, HIDC_DM_EDIT_TO,
    IDC_DM_EDIT_MESSAGE, HIDC_DM_EDIT_MESSAGE,
	0,0 
};


// "File rtrsnap.rc line 985 : Resource - DIALOG : IDD_PORTS_GLOBAL_GENERAL"
static const DWORD rgdw_IDD_PORTS_GLOBAL_GENERAL[] = 
{
    IDC_PGG_LIST, HIDC_PGG_LIST,
    IDC_PGG_BTN_CONFIGURE, HIDC_PGG_BTN_CONFIGURE,
    IDC_PGG_TXT_NOINFO, HIDC_PGG_TXT_NOINFO,
	0,0 
};


// "File rtrsnap.rc line 998 : Resource - DIALOG : IDD_RTR_ATLK"
static const DWORD rgdw_IDD_RTR_ATLK[] = 
{
    IDC_RTR_ATLK_SEEDNETWORK, HIDC_RTR_ATLK_SEEDNETWORK,
    IDC_RTR_ATLK_S_RANGE, HIDC_RTR_ATLK_S_RANGE,
    IDC_RTR_ATLK_S_LOWER, HIDC_RTR_ATLK_S_LOWER,
    IDC_RTR_ATLK_FROM, HIDC_RTR_ATLK_FROM,
    IDC_RTR_ATLK_S_UPPER, HIDC_RTR_ATLK_S_UPPER,
    IDC_RTR_ATLK_TO, HIDC_RTR_ATLK_TO,
    IDC_RTR_ATLK_S_DEF, HIDC_RTR_ATLK_S_DEF,
//    IDC_CMB_ATLK_ZONEDEF, HIDC_CMB_ATLK_ZONEDEF,
    IDC_BTN_ATLK_ZONEADD, HIDC_BTN_ATLK_ZONEADD,
    IDC_RTR_ATLK_LB_DEFZONES, HIDC_RTR_ATLK_LB_DEFZONES,
    IDC_BTN_ATLK_GETZONES, HIDC_BTN_ATLK_GETZONES,
    IDC_BTN_ATLK_ZONEREMOVE, HIDC_BTN_ATLK_ZONEREMOVE,
	IDC_ATLK_SPIN_FROM, HIDC_RTR_ATLK_FROM,
	IDC_ATLK_SPIN_TO, HIDC_RTR_ATLK_TO,
	IDC_RTR_ATLK_DEFAULTZONE_PROMPT, HIDC_CMB_ATLK_ZONEDEF,
	IDC_RTR_ATLK_DEFAULTZONE_DISPLAY, HIDC_RTR_ATLK_DEFAULTZONE_DISPLAY,
	0,0 
};


// "File rtrsnap.rc line 1026 : Resource - DIALOG : IDD_RTR_GENERAL"
static const DWORD rgdw_IDD_RTR_GENERAL[] = 
{
    IDC_RTR_GEN_CB_SVRASRTR, HIDC_RTR_GEN_CB_SVRASRTR,
    IDC_RTR_GEN_RB_LAN, HIDC_RTR_GEN_RB_LAN,
    IDC_RTR_GEN_RB_LANWAN, HIDC_RTR_GEN_RB_LANWAN,
    IDC_RTR_GEN_CB_RAS, HIDC_RTR_GEN_CB_RAS,
	0,0 
};


// "File rtrsnap.rc line 1050 : Resource - DIALOG : IDD_RTR_AUTHENTICATION"
static const DWORD rgdw_IDD_RTR_AUTHENTICATION[] = 
{
    IDC_RTR_AUTH_COMBO_AUTHPROV, HIDC_RTR_AUTH_COMBO_AUTHPROV,
    IDC_RTR_AUTH_BTN_AUTHCFG, HIDC_RTR_AUTH_BTN_AUTHCFG,
    IDC_RTR_AUTH_BTN_SETTINGS, HIDC_RTR_AUTH_BTN_SETTINGS,
    IDC_RTR_AUTH_COMBO_ACCTPROV, HIDC_RTR_AUTH_COMBO_ACCTPROV,
    IDC_RTR_AUTH_BTN_ACCTCFG, HIDC_RTR_AUTH_BTN_ACCTCFG,
    IDC_AUTH_CHK_CUSTOM_IPSEC_POLICY, HIDC_AUTH_CHK_CUSTOM_IPSEC_POLICY,
    IDC_STATIC_PRESHARED_KEY1, HIDC_STATIC_PRESHARED_KEY1,
    IDC_TXT_PRESHARED_KEY, HIDC_STATIC_PRESHARED_KEY1,
	0,0 
};


// "File rtrsnap.rc line 1071 : Resource - DIALOG : IDD_RTR_EAP_CFG"
static const DWORD rgdw_IDD_RTR_EAP_CFG[] = 
{
    IDC_RTR_EAPCFG_LIST, HIDC_RTR_EAPCFG_LIST,
	0,0 
};


// "File rtrsnap.rc line 1086 : Resource - DIALOG : IDD_RADIUS_AUTH"
static const DWORD rgdw_IDD_RADIUS_AUTH[] = 
{
    IDC_RADAUTH_LIST, HIDC_RADAUTH_LIST,
    IDC_RADAUTH_BTN_ADD, HIDC_RADAUTH_BTN_ADD,
    IDC_RADAUTH_BTN_EDIT, HIDC_RADAUTH_BTN_EDIT,
    IDC_RADAUTH_BTN_DELETE, HIDC_RADAUTH_BTN_DELETE,
	0,0 
};


// "File rtrsnap.rc line 1105 : Resource - DIALOG : IDD_RADIUS_AUTH_CONFIG"
static const DWORD rgdw_IDD_RADIUS_AUTH_CONFIG[] = 
{
    IDC_RAC_EDIT_SERVER, HIDC_RAC_EDIT_SERVER,
    IDC_RAC_EDIT_SECRET, HIDC_RAC_EDIT_SECRET,
    IDC_RAC_BTN_CHANGE, HIDC_RAC_BTN_CHANGE,
    IDC_RAC_EDIT_TIMEOUT, HIDC_RAC_EDIT_TIMEOUT,
    IDC_RAC_SPIN_TIMEOUT, HIDC_RAC_SPIN_TIMEOUT,
    IDC_RAC_EDIT_SCORE, HIDC_RAC_EDIT_SCORE,
    IDC_RAC_SPIN_SCORE, HIDC_RAC_SPIN_SCORE,
    IDC_RAC_EDIT_PORT, HIDC_RAC_EDIT_PORT,
    IDC_RAC_BTN_DIGITALSIG, HIDC_RAC_BTN_DIGITALSIG,
	0,0 
};


// "File rtrsnap.rc line 1139 : Resource - DIALOG : IDD_PPP_CONFIG"
static const DWORD rgdw_IDD_PPP_CONFIG[] = 
{
    IDC_PPPCFG_BTN_MULTILINK, HIDC_PPPCFG_BTN_MULTILINK,
    IDC_PPPCFG_BTN_BACP, HIDC_PPPCFG_BTN_BACP,
    IDC_PPPCFG_BTN_LCP, HIDC_PPPCFG_BTN_LCP,
    IDC_PPPCFG_BTN_SWCOMP, HIDC_PPPCFG_BTN_SWCOMP,
    IDC_PPPCFG_BTN_AUDIO_ACC, HIDC_PPPCFG_BTN_AUDIO_ACC,
	0,0 
};


// "File rtrsnap.rc line 1160 : Resource - DIALOG : IDD_CHANGE_SECRET"
static const DWORD rgdw_IDD_CHANGE_SECRET[] = 
{
    IDC_SECRET_EDIT_NEW, HIDC_SECRET_EDIT_NEW,
    IDC_SECRET_EDIT_NEW_CONFIRM, HIDC_SECRET_EDIT_NEW_CONFIRM,
	0,0 
};


// "File rtrsnap.rc line 1177 : Resource - DIALOG : IDD_RADIUS_ACCT_CONFIG"
static const DWORD rgdw_IDD_RADIUS_ACCT_CONFIG[] = 
{
    IDC_RAC_EDIT_SERVER, HIDC_RAC_EDIT_SERVER,
    IDC_RAC_EDIT_SECRET, HIDC_RAC_EDIT_SECRET,
    IDC_RAC_BTN_CHANGE, HIDC_RAC_BTN_CHANGE,
    IDC_RAC_EDIT_TIMEOUT, HIDC_RAC_EDIT_TIMEOUT,
    IDC_RAC_SPIN_TIMEOUT, HIDC_RAC_SPIN_TIMEOUT,
    IDC_RAC_EDIT_SCORE, HIDC_RAC_EDIT_SCORE,
    IDC_RAC_SPIN_SCORE, HIDC_RAC_SPIN_SCORE,
    IDC_RAC_TXT_PORT, HIDC_RAC_TXT_PORT,
    IDC_RAC_EDIT_PORT, HIDC_RAC_EDIT_PORT,
    IDC_RAC_BTN_ONOFF, HIDC_RAC_BTN_ONOFF,
	0,0 
};


// "File rtrsnap.rc line 1210 : Resource - DIALOG : IDD_PORTS_DEVICE_CONFIG"
static const DWORD rgdw_IDD_PORTS_DEVICE_CONFIG[] = 
{
    IDC_DEVCFG_BTN_RAS, HIDC_DEVCFG_BTN_RAS,
    IDC_DEVCFG_BTN_ROUTING, HIDC_DEVCFG_BTN_ROUTING,
    IDC_DEVCFG_BTN_OUTBOUND_ROUTING, HIDC_DEVCFG_BTN_OUTBOUND_ROUTING,
    IDC_DEVCFG_TEXT_CALLEDID, HIDC_DEVCFG_TEXT_CALLEDID,
    IDC_DEVCFG_EDIT_CALLEDID, HIDC_DEVCFG_EDIT_CALLEDID,
    IDC_DEVCFG_TEXT, HIDC_DEVCFG_TEXT,
    IDC_DEVCFG_TEXT_PORTS, HIDC_DEVCFG_TEXT_PORTS,
    IDC_DEVCFG_EDIT_PORTS, HIDC_DEVCFG_EDIT_PORTS,
    IDC_DEVCFG_SPIN_PORTS, HIDC_DEVCFG_SPIN_PORTS,
	0,0 
};


// "File rtrsnap.rc line 1240 : Resource - DIALOG : IDD_RTR_EVENTLOGGING"
static const DWORD rgdw_IDD_RTR_EVENTLOGGING[] = 
{
    IDC_ELOG_BTN_LOGERROR, HIDC_ELOG_BTN_LOGERROR,
    IDC_ELOG_BTN_LOGWARN, HIDC_ELOG_BTN_LOGWARN,
    IDC_ELOG_BTN_LOGINFO, HIDC_ELOG_BTN_LOGINFO,
    IDC_ELOG_BTN_LOGNONE, HIDC_ELOG_BTN_LOGNONE,
    IDC_ELOG_BTN_PPP, HIDC_ELOG_BTN_PPP,
	0,0 
};


// "File rtrsnap.rc line 1261 : Resource - DIALOG : IDD_TUNNEL"
static const DWORD rgdw_IDD_TUNNEL[] = 
{
    IDC_TUNNEL_EDIT_NAME, HIDC_TUNNEL_EDIT_NAME,
	0,0 
};


// "File rtrsnap.rc line 1272 : Resource - DIALOG : IDD_RTR_ATLK_NEWZONE"
static const DWORD rgdw_IDD_RTR_ATLK_NEWZONE[] = 
{
    IDC_RTR_ATLK_NEWZONE_STATIC, HIDC_RTR_ATLK_NEWZONE_STATIC,
    IDC_RTR_ATLK_NEWZONE_EDIT, HIDC_RTR_ATLK_NEWZONE_EDIT,
	0,0 
};


// "File rtrsnap.rc line 1287 : Resource - DIALOGEX : IDD_AUTHENTICATION_SETTINGS"
static const DWORD rgdw_IDD_AUTHENTICATION_SETTINGS[] = 
{
    IDC_RTR_AUTH_TXT_DETAILS, HIDC_RTR_AUTH_TXT_DETAILS,
    IDC_RTR_AUTH_BTN_EAP, HIDC_RTR_AUTH_BTN_EAP,
    IDC_RTR_AUTH_BTN_DETAILS, HIDC_RTR_AUTH_BTN_DETAILS,
    IDC_RTR_AUTH_BTN_MSCHAPV2, HIDC_RTR_AUTH_BTN_MSCHAPV2,
    IDC_RTR_AUTH_BTN_MSCHAP, HIDC_RTR_AUTH_BTN_MSCHAP,
    IDC_RTR_AUTH_BTN_CHAP, HIDC_RTR_AUTH_BTN_CHAP,
    IDC_RTR_AUTH_BTN_SPAP, HIDC_RTR_AUTH_BTN_SPAP,
    IDC_RTR_AUTH_BTN_PAP, HIDC_RTR_AUTH_BTN_PAP,
    IDC_RTR_AUTH_BTN_NOAUTH, HIDC_RTR_AUTH_BTN_NOAUTH,
	0,0 
};


// "File rtrsnap.rc line 1321 : Resource - DIALOG : IDD_IPPOOL"
static const DWORD rgdw_IDD_IPPOOL[] = 
{
    IDC_IPPOOL_IP_START, HIDC_IPPOOL_IP_START,
    IDC_IPPOOL_IP_END, HIDC_IPPOOL_IP_END,
    IDC_IPPOOL_EDIT_RANGE, HIDC_IPPOOL_EDIT_RANGE,
	0,0 
};
//
// End of mkdlg.exe output
//


// Have to include the dialogs in common
#include "commhelp.cpp"


static BOOL				s_fInitHelpMap = FALSE;
static CMapWordToPtr	s_IDDHelpMap;
void InitHelpMap();

DWORD *	MprSnapHelpMap(DWORD dwIDD)
{
	LPVOID	pvHelpMap = NULL;
	
	if (!s_fInitHelpMap)
	{
		InitHelpMap();
		s_fInitHelpMap = TRUE;
	}

	// Look in the help map
	s_IDDHelpMap.Lookup((WORD) dwIDD, pvHelpMap);
	return (DWORD *) pvHelpMap;
}

void InitHelpMap()
{
	// Add all of the help maps to the DWORD map
	s_IDDHelpMap.SetAt(IDD_QRY_GENERAL, (LPVOID) rgdw_IDD_QRY_GENERAL);
	s_IDDHelpMap.SetAt(IDD_QRY_ADVANCED, (LPVOID) rgdw_IDD_QRY_ADVANCED);
	s_IDDHelpMap.SetAt(IDD_QRY_ADDSERVER, (LPVOID) rgdw_IDD_QRY_ADDSERVER);
	s_IDDHelpMap.SetAt(IDD_CONNECTING, (LPVOID) rgdw_IDD_CONNECTING);
	s_IDDHelpMap.SetAt(IDD_IF_CREDENTIALS, (LPVOID) rgdw_IDD_IF_CREDENTIALS);
	s_IDDHelpMap.SetAt(IDD_CONNECT_AS, (LPVOID) rgdw_IDD_CONNECT_AS);
	s_IDDHelpMap.SetAt(IDD_RTR_IP, (LPVOID) rgdw_IDD_RTR_IP);
	s_IDDHelpMap.SetAt(IDD_RTR_IPX, (LPVOID) rgdw_IDD_RTR_IPX);
	s_IDDHelpMap.SetAt(IDD_RTR_ARAP, (LPVOID) rgdw_IDD_RTR_ARAP);
	s_IDDHelpMap.SetAt(IDD_RTR_NBF, (LPVOID) rgdw_IDD_RTR_NBF);
	s_IDDHelpMap.SetAt(IDD_CONNECTREG, (LPVOID) rgdw_IDD_CONNECTREG);
	s_IDDHelpMap.SetAt(IDD_REFRESHRATE, (LPVOID) rgdw_IDD_REFRESHRATE);
	s_IDDHelpMap.SetAt(IDD_DDM_PORT, (LPVOID) rgdw_IDD_DDM_PORT);
	s_IDDHelpMap.SetAt(IDD_DDM_CONN, (LPVOID) rgdw_IDD_DDM_CONN);
	s_IDDHelpMap.SetAt(IDD_DDM_MESSAGE, (LPVOID) rgdw_IDD_DDM_MESSAGE);
	s_IDDHelpMap.SetAt(IDD_PORTS_GLOBAL_GENERAL, (LPVOID) rgdw_IDD_PORTS_GLOBAL_GENERAL);
	s_IDDHelpMap.SetAt(IDD_RTR_ATLK, (LPVOID) rgdw_IDD_RTR_ATLK);
	s_IDDHelpMap.SetAt(IDD_RTR_GENERAL, (LPVOID) rgdw_IDD_RTR_GENERAL);
	s_IDDHelpMap.SetAt(IDD_RTR_AUTHENTICATION, (LPVOID) rgdw_IDD_RTR_AUTHENTICATION);
	s_IDDHelpMap.SetAt(IDD_RTR_EAP_CFG, (LPVOID) rgdw_IDD_RTR_EAP_CFG);
	s_IDDHelpMap.SetAt(IDD_RADIUS_AUTH, (LPVOID) rgdw_IDD_RADIUS_AUTH);
	s_IDDHelpMap.SetAt(IDD_RADIUS_AUTH_CONFIG, (LPVOID) rgdw_IDD_RADIUS_AUTH_CONFIG);
	s_IDDHelpMap.SetAt(IDD_PPP_CONFIG, (LPVOID) rgdw_IDD_PPP_CONFIG);
	s_IDDHelpMap.SetAt(IDD_CHANGE_SECRET, (LPVOID) rgdw_IDD_CHANGE_SECRET);
	s_IDDHelpMap.SetAt(IDD_RADIUS_ACCT_CONFIG, (LPVOID) rgdw_IDD_RADIUS_ACCT_CONFIG);
	s_IDDHelpMap.SetAt(IDD_PORTS_DEVICE_CONFIG, (LPVOID) rgdw_IDD_PORTS_DEVICE_CONFIG);
	s_IDDHelpMap.SetAt(IDD_RTR_EVENTLOGGING, (LPVOID) rgdw_IDD_RTR_EVENTLOGGING);
	s_IDDHelpMap.SetAt(IDD_TUNNEL, (LPVOID) rgdw_IDD_TUNNEL);
	s_IDDHelpMap.SetAt(IDD_RTR_ATLK_NEWZONE, (LPVOID) rgdw_IDD_RTR_ATLK_NEWZONE);
    s_IDDHelpMap.SetAt(IDD_AUTHENTICATION_SETTINGS, (LPVOID) rgdw_IDD_AUTHENTICATION_SETTINGS);
    s_IDDHelpMap.SetAt(IDD_IPPOOL, (LPVOID) rgdw_IDD_IPPOOL);
    
    // Include the entries for common
    s_IDDHelpMap.SetAt(IDD_STATS, (LPVOID) rgdw_IDD_STATS);
    s_IDDHelpMap.SetAt(IDD_STATS_NARROW, (LPVOID) rgdw_IDD_STATS_NARROW);
    s_IDDHelpMap.SetAt(IDD_COMMON_SELECT_COLUMNS, (LPVOID) rgdw_IDD_COMMON_SELECT_COLUMNS);
    s_IDDHelpMap.SetAt(IDD_BUSY, (LPVOID) rgdw_IDD_BUSY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	rtrstrm.h
		Root node configuration data.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _RTRSTRM_H
#define _RTRSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _IFADMIN_H
#include "ifadmin.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

enum RTRSTRM_TAG
{
	RTRSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	RTRSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	RTRSTRM_TAG_SERVER =		XFER_TAG(3, XFER_DWORD) ,
	RTRSTRM_TAG_NAME =			XFER_TAG(4, XFER_STRING),
	RTRSTRM_TAG_OVERRIDE =		XFER_TAG(5, XFER_DWORD),
};

class RouterAdminConfigStream : public ConfigStream
{
public:
	RouterAdminConfigStream();

	HRESULT	InitNew();				// set defaults
	HRESULT	SaveTo(IStream *pstm);
	HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	HRESULT LoadFrom(IStream *pstm);

	HRESULT GetSize(ULONG *pcbSize);

	BOOL	GetDirty() { return m_fDirty; } 
	void	SetDirty(BOOL fDirty) { m_fDirty = fDirty; };


	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);
	
	HRESULT	GetLocationInfo(BOOL *pfServer, CString *pstName, BOOL *pfOverride);
	HRESULT SetLocationInfo(BOOL fServer, LPCTSTR pszName, BOOL fOverride);

private:
	DWORD	m_nVersionAdmin;
	DWORD	m_nVersion;
	DWORD	m_fServer;
	DWORD	m_fOverride;
	CString	m_stName;
	BOOL	m_fDirty;

	HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};


class RouterComponentConfigStream : public ConfigStream
{
protected:
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};

#endif _RTRSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	rtrstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrstrm.h"
#include "xstream.h"

#define CURRENT_RTRSTRM_VERSION	0x00020001

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::RouterAdminConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
RouterAdminConfigStream::RouterAdminConfigStream()
	: m_nVersion(-1), m_fDirty(FALSE)
{
	m_nVersionAdmin = 0x00020000;
	m_nVersion = CURRENT_RTRSTRM_VERSION;
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::InitNew()
{
	// Setup the appropriate defaults
//	m_nVersionAdmin = 0x00020000;
//	m_nVersion = 0x00020000;
//	m_fServer = TRUE;
//	m_stName.Empty();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::GetLocationInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::GetLocationInfo(BOOL *pfServer,
	CString *pstName, BOOL *pfOverride)
{
	if (pfServer)
		*pfServer = m_fServer;
	if (pstName)
		*pstName = m_stName;
	if (pfOverride)
		*pfOverride = m_fOverride;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::SetLocationInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::SetLocationInfo(BOOL fServer,
	LPCTSTR pszName, BOOL fOverride)
{
	m_fServer = fServer;
	m_stName = pszName;
	m_fOverride = fOverride;
	SetDirty(TRUE);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RouterAdminConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RouterAdminConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( RTRSTRM_TAG_VERSION, &m_nVersion ) );
	
	AssertSz(m_nVersion == CURRENT_RTRSTRM_VERSION, "Wrong saved console version!");
	
	CORg( xstm.XferDWORD( RTRSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );
	CORg( xstm.XferDWORD( RTRSTRM_TAG_SERVER, &m_fServer ) );
	CORg( xstm.XferCString( RTRSTRM_TAG_NAME, &m_stName ) );
	CORg( xstm.XferDWORD( RTRSTRM_TAG_OVERRIDE, &m_fOverride ) );

	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}


enum 
{
	INTERFACES_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	INTERFACES_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	INTERFACES_TAG_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	INTERFACES_TAG_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
	INTERFACES_TAG_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),
};

HRESULT RouterComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( INTERFACES_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( INTERFACES_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	CORg( m_rgViewInfo[0].Xfer(&xstm,
								INTERFACES_TAG_SORT_COLUMN,
								INTERFACES_TAG_SORT_ASCENDING,
								INTERFACES_TAG_COLUMNS) );
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrwiz.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   rtrwiz.h

   FILE HISTORY:

*/

#if !defined _RTRWIZ_H_
#define _RTRWIZ_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "listctrl.h"
#include "ports.h"
#include "rasppp.h"		// for PPPCFG_XXX constants
#include "rtrcfg.h"		// for DATA_SRV_??? structures

// forward declarations
class NewRtrWizData;



// Use these flags to help determine what the allowed encryption settings are

#define USE_PPPCFG_AUTHFLAGS \
			(	PPPCFG_NegotiateSPAP | \
				PPPCFG_NegotiateMSCHAP | \
				PPPCFG_NegotiateEAP | \
				PPPCFG_NegotiatePAP | \
				PPPCFG_NegotiateMD5CHAP | \
				PPPCFG_NegotiateStrongMSCHAP | \
				PPPCFG_AllowNoAuthentication \
            )

//
// Note: this is also used to define ALL of the authentication methods.
// At least one of these has to be set!
//
#define USE_PPPCFG_ALL_METHODS \
			 (	PPPCFG_NegotiateSPAP | \
				PPPCFG_NegotiateMSCHAP | \
				PPPCFG_NegotiateEAP | \
				PPPCFG_NegotiatePAP | \
                PPPCFG_NegotiateMD5CHAP | \
                PPPCFG_AllowNoAuthentication | \
				PPPCFG_NegotiateStrongMSCHAP )

//
// This is used to define the methods selected
// when the "use all methods" in the wizard
//
#define USE_PPPCFG_ALLOW_ALL_METHODS \
			 (	PPPCFG_NegotiateSPAP | \
				PPPCFG_NegotiateMSCHAP | \
				PPPCFG_NegotiateEAP | \
				PPPCFG_NegotiatePAP | \
				PPPCFG_NegotiateStrongMSCHAP )

#define USE_PPPCFG_SECURE \
			(	PPPCFG_NegotiateMSCHAP | \
				PPPCFG_NegotiateEAP | \
				PPPCFG_NegotiateStrongMSCHAP \
			)

//
// This is used to define the default set of methods 
// selected by the wizard
//
#define USE_PPPCFG_DEFAULT_METHODS \
            (   PPPCFG_NegotiateMSCHAP | \
                PPPCFG_NegotiateEAP | \
                PPPCFG_NegotiateStrongMSCHAP \
            )


enum RtrConfigFlags
{
    RTRCONFIG_SETUP_NAT = 0x00000001,
    RTRCONFIG_SETUP_DNS_PROXY = 0x00000002,
    RTRCONFIG_SETUP_DHCP_ALLOCATOR = 0x00000004,
    RTRCONFIG_SETUP_H323 = 0x00000008,  // deonb added
    RTRCONFIG_SETUP_ALG = 0x00000010   // savasg added
};

struct RtrConfigData
{
    CString			m_stServerName;
    BOOL			m_fRemote;

    // These are flags that have meaning outside of this context.
    // For example, if you are setting up NAT, you would set a flag
    // here.
    DWORD           m_dwConfigFlags;


	// This is the router type chosen by the user:
	//		ROUTER_TYPE_LAN  ROUTER_TYPE_WAN  ROUTER_TYPE_RAS
    DWORD			m_dwRouterType;

	// This is the network access or local only
	// this setting is then propagated down to the individual
	// transports structures.
	BOOL			m_dwAllowNetworkAccess;

	// This is set if IP is installed.
	BOOL			m_fUseIp;
	// If this is set to FALSE, then the IP address choice needs
	// to be reset depending on the router type
	BOOL			m_fIpSetup;
	DATA_SRV_IP		m_ipData;

	// This is set if IPX is installed.
	BOOL			m_fUseIpx;
	DATA_SRV_IPX	m_ipxData;

	// This is set if NetBEUI is installed
	BOOL			m_fUseNbf;
	DATA_SRV_NBF	m_nbfData;

	// This is set if Appletalk is installed AND we are running locally
	BOOL			m_fUseArap;
	DATA_SRV_ARAP	m_arapData;

    // Use this for the error logging
    // Note, this is not used in the UI but we use this to set the
    // defaults.
    DATA_SRV_RASERRLOG  m_errlogData;

    // Use this for authentication
    // Note, this is not used in the UI but we use this to set the
    // defaults.
    DATA_SRV_AUTH   m_authData;

    RtrConfigData()
     {
		m_dwRouterType		= ROUTER_TYPE_RAS;
		m_fRemote			= 0;
		m_fUseIp			= FALSE;
		m_fUseIpx			= FALSE;
		m_fUseNbf			= FALSE;
		m_fUseArap			= FALSE;

        // This contains the default values for the authentication flags.
        // The only flags that can be set in this variable are the
        // flags in USE_PPPCFG_AUTHFLAGS
        m_dwConfigFlags     = 0;

		m_dwAllowNetworkAccess = TRUE;

		m_fIpSetup			= FALSE;
     }


   HRESULT  Init(LPCTSTR pszServerName, IRouterInfo *pRouter);
};

DWORD   RtrWizFinish(RtrConfigData* pRtrConfigData, IRouterInfo *pRouterInfo);
HRESULT AddIGMPToRasServer(RtrConfigData* pRtrConfigData,
                           IRouterInfo *pRouterInfo);
HRESULT AddIGMPToNATServer(NewRtrWizData *pNewRtrWizData,
                           RtrConfigData* pRtrConfigData,
                           IRouterInfo *pRouterInfo,
                           BOOL fAddInternal);
HRESULT AddNATToServer(NewRtrWizData *pNewRtrWizData,
                       RtrConfigData *pRtrConfigData,
                       IRouterInfo *pRouter,
                       BOOL fDemandDial,
					   BOOL fAddProtocolOnly
					   );

#ifdef KSL_IPINIP
DWORD   CleanupTunnelFriendlyNames(IRouterInfo *pRouter);
#endif //KSL_IPINIP

HRESULT AddIPBOOTPToServer(RtrConfigData* pRtrConfigData,
                           IRouterInfo *pRouterInfo,
                           DWORD dwDhcpServer);

#endif // !defined _RTRWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrutilp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rtrutilp.h
//
//--------------------------------------------------------------------------

// Private RtrUtil header file.
// This is for everything that shouldn't be exported.


#ifndef _RTRUTILP_H_
#define _RTRUTILP_H_

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _RTRUTIL_H
#include "rtrutil.h"
#endif

#include "svcctrl.h"

#ifndef _PORTS_H_
#include "ports.h"
#endif

CString GetLocalMachineName();

//----------------------------------------------------------------------------
// Class:       CInterfaceConnectDialog
//
// Controls the 'Interface Connection' dialog, which shows elapsed time
// for interface-connection as well as connection status.
//----------------------------------------------------------------------------

class CInterfaceConnectDialog : public CDialog
{
public:
	CInterfaceConnectDialog(
				   HANDLE      hServer,
				   HANDLE      hInterface,
				   LPCTSTR     pszInterface,
				   CWnd*       pParent     = NULL );
	
	//{{AFX_VIRTUAL(CInterfaceConnectDialog)
protected:
	virtual VOID    DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

protected:
	MPR_SERVER_HANDLE m_hServer;
	HANDLE			m_hInterface;
	CString         m_sInterface;
	UINT            m_nIDEvent;
	DWORD           m_dwConnectionState;
	DWORD           m_dwTimeElapsed;
	
	//{{AFX_MSG(CInterfaceConnectDialog)
	virtual BOOL    OnInitDialog( );
	virtual VOID    OnCancel( );
	virtual VOID    OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	CIfCredentials

	The credentials dialog.
 ---------------------------------------------------------------------------*/

class CIfCredentials : public CBaseDialog
{
    public:
    
        CIfCredentials(
            LPCTSTR         pszMachine,
            LPCTSTR         pszInterface,
            BOOL            bNewInterface = FALSE,
            CWnd*           pParent     = NULL
            ) : CBaseDialog(IDD_IF_CREDENTIALS, pParent),
                m_sMachine(pszMachine ? pszMachine : TEXT("")),
                m_sInterface(pszInterface ? pszInterface : TEXT("")),
                m_bNewIf( bNewInterface )
				{  /*SetHelpMap(m_dwHelpMap);*/ }

    protected:
		static DWORD		m_dwHelpMap[];

        CString             m_sMachine;
        CString             m_sInterface;
        BOOL                m_bNewIf;

        virtual BOOL
        OnInitDialog( );

        virtual VOID
        OnOK( );

		DECLARE_MESSAGE_MAP()
};


/*!--------------------------------------------------------------------------
	ConnectAsAdmin
		Connect to remote as administrator with user-supplied credentials.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConnectAsAdmin(IN LPCTSTR	szRouterName, IN IRouterInfo *pRouter);


DWORD ValidateMachine(const CString &sName, BOOL bDisplayErr = FALSE);

/*!--------------------------------------------------------------------------
	InitiateServerConnection
		This should be called when attempting to connect to the server
		for the very first time (The parameters are the same as the
		ConnectRegistry() function).  This will validate the server
		and return the HKLM key for that server.

		This call will bring up the connecting dialog as well as
		prompting the user for credentials if need be.

		Returns:
			S_OK	- if the call succeeded, *phkey contains a valid HKEY.
			S_FALSE - user cancelled, *phkey contains NULL
			other	- error condition, *phkey unchanged
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InitiateServerConnection(LPCTSTR szMachine,
                                 HKEY *phkey,
                                 BOOL fNoConnectingUI,
                                 IRouterInfo *pRouter);

void DisplayConnectErrorMessage(DWORD dwr);

void FormatRasPortName(BYTE *pRasPort0, LPTSTR pszBuffer, UINT cchMax);

CString&	PortConditionToCString(DWORD dwPortCondition);




/*!--------------------------------------------------------------------------
	RegFindInterfaceKey
		-
	This function returns the HKEY of the router interface with this ID.

	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RegFindInterfaceKey(LPCTSTR pszInterface,
								 HKEY hkeyMachine,
								 REGSAM regAccess,
								 HKEY *pHKey);


void StrListToHourMap(CStringList& stlist, BYTE* map) ;
void HourMapToStrList(BYTE* map, CStringList& stList) ;


// Versions before this rely on the snapin to set the IPEnableRouter key
// Versions after this do not.
// --------------------------------------------------------------------
#define USE_IPENABLEROUTER_VERSION  2094

/*!--------------------------------------------------------------------------
	InstallGlobalSettings
		Sets the global settings (i.e. registry settings) on this machine
		when the router is installed.

		For a specific description of the actions involved, look at
		the comments in the code.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InstallGlobalSettings(LPCTSTR pszMachineName,
                              IRouterInfo *pRouter);



/*!--------------------------------------------------------------------------
	UninstallGlobalSettings
		Clears the global settings (i.e. registry settings) on this machine
		when the router is installed.
		
		For a specific description of the actions involved, look at
		the comments in the code.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT UninstallGlobalSettings(LPCTSTR pszMachineName,
                                IRouterInfo *pRouter,
                                BOOL fNt4,
                                BOOL fSnapinChanges);

HRESULT WriteErasePSKReg (LPCTSTR pszServerName, DWORD dwErasePSK );
HRESULT ReadErasePSKReg(LPCTSTR pszServerName, DWORD *pdwErasePSK);

/*!--------------------------------------------------------------------------
	WriteRouterConfiguredReg
		Writes the BOOLEAN that describes whether or not the router
		is configured.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT WriteRouterConfiguredReg(LPCTSTR pszServerName, DWORD dwConfigured);


/*!--------------------------------------------------------------------------
	ReadRouterConfiguredReg
		Reads the BOOLEAN that describes whether or not the router is
		configured.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ReadRouterConfiguredReg(LPCTSTR pszServerName, DWORD *pdwConfigured);


/*!--------------------------------------------------------------------------
	WriteRRASExtendsComputerManagementKey
		Writes the GUID of the RRAS snapin so that it extends Computer
        Management.

        If dwConfigured is TRUE the key is written/created.
        If dwConfigured is FALSE, the key is removed.
        
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT WriteRRASExtendsComputerManagementKey(LPCTSTR pszServer, DWORD dwConfigured);


/*!--------------------------------------------------------------------------
	NotifyTcpipOfChanges
		Triggers the TCPIP notification (for the local machine).
	Author: KennT
 ---------------------------------------------------------------------------*/
void	NotifyTcpipOfChanges(LPCTSTR pszMachineName,
                             IRouterInfo *pRouter,
                             BOOL fEnableRouter,
							 UCHAR uPerformRouterDiscovery);


/*!--------------------------------------------------------------------------
	UpdateLanaMapForDialinClients
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	UpdateLanaMapForDialinClients(LPCTSTR pszServerName, DWORD dwAllowNetworkAccess);


/*!--------------------------------------------------------------------------
	HrIsProtocolSupported

		This function will check the existence of the first two
		registry keys (these two are required).  The third key will
		also be checked, but this is an optional parameter.

		The reason for the third key is that, for IP, we need to
		check one more key.  It turns out that if we uninstall IP
		the first two keys still exist.
	
		Returns S_OK if the protocol is installed on the machine (checks
		the two registry keys passed in).
		Returns S_FALSE if the protocol is not supported.
		Error code otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT HrIsProtocolSupported(LPCTSTR pszServerName,
							  LPCTSTR pszServiceKey,
							  LPCTSTR pszRasServiceKey,
							  LPCTSTR pszExtraKey);



/*!--------------------------------------------------------------------------
	RegisterRouterInDomain
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RegisterRouterInDomain(LPCTSTR pszRouterName, BOOL fRegister);


/*!--------------------------------------------------------------------------
	SetDeviceType
		Sets the type of the various WAN devices depending on the
		router type.  Thus, if we select the router to be a LAN-only
		router, we or in the routing-only flags.

        The dwTotalPorts is the number of ports that will be split
        up between L2TP/PPTP.  This value is ignored if it is 0.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetDeviceType(LPCTSTR pszMachineName,
                      DWORD dwRouterType,
                      DWORD dwTotalPorts);
HRESULT SetDeviceTypeEx(PortsDeviceList *pDevList, DWORD dwRouterType);
HRESULT SetPortSize(PortsDeviceList *pDeviceList, DWORD dwPorts);



// Marks the sections of the code that read the serverflags from
// the Rasman PPP key rather than RemoteAccess\Parameters.
// This corresponds to NT 4 build number
#define RASMAN_PPP_KEY_LAST_VERSION		1841
// This is a new W2k build number to see if any W2k specific 
// logic needs to be performed.  Currently it is used
// only to hide/show the Ras Audio Acceleration checkbox.
#define RASMAN_PPP_KEY_LAST_WIN2k_VERSION	2195
#define ROUTER_LAST_IPX_VERSION             2600


CString&	PortsDeviceTypeToCString(DWORD dwRasRouter);

HRESULT SetRouterInstallRegistrySettings(LPCWSTR pswzServer,
                                         BOOL fInstall,
                                         BOOL fChangeEnableRouter);

// Use to help debug problems during unattended install
void TraceInstallError(LPCSTR pszString, HRESULT hr);
void TraceInstallResult(LPCSTR pszString, HRESULT hr);
void TraceInstallSz(LPCSTR pszString);
void TraceInstallPrintf(LPCSTR pszFormat, ...);

CString&	PortTypeToCString(DWORD dwPortType);


/*---------------------------------------------------------------------------
	Class:  CWaitForRemoteAccessDlg
    This class implements the wait dialog.  We wait for the RemoteAccess
    service to report that its up and running.
 ---------------------------------------------------------------------------*/
class CWaitForRemoteAccessDlg : public CWaitDlg
{
public:
    CWaitForRemoteAccessDlg(LPCTSTR pszServerName,
                            LPCTSTR pszText,
                            LPCTSTR pszTitle,
                            CWnd *pParent = NULL);  // standard constructor
    virtual void    OnTimerTick();
};

/*---------------------------------------------------------------------------
	Class:	CRestartRouterDlg 
	This class implemnts the wait dialog when we restart the router

 ---------------------------------------------------------------------------*/
class CRestartRouterDlg : public CWaitDlg
{
public:
	CRestartRouterDlg(LPCTSTR pszServerName,
					  LPCTSTR pszText,
					  LPCTSTR pszTitle,
					  CTime*  pTimeStart,
					  CWnd*	pParent = NULL);
	virtual void OnTimerTick();

	BOOL m_fTimeOut;
	DWORD m_dwError;
private:
	CTime* m_pTimeStart;
	DWORD  m_dwTimeElapsed;
};


HRESULT AddNetConnection(LPCTSTR pszConnection);
HRESULT RemoveNetConnection(LPCTSTR pszServer);
HRESULT RemoveAllNetConnections();


// Utility functions
HRESULT RefreshMprConfig(LPCTSTR pszServerName);
HRESULT WINAPI
IsWindows64Bit(	LPCWSTR pwszMachine, 
				LPCWSTR pwszUserName,
				LPCWSTR pwszPassword,
				LPCWSTR pwszDomain,
				BOOL * pf64Bit);

HRESULT WINAPI TransferCredentials ( IRouterInfo * spRISource, 
									 IRouterInfo * spRIDest
								   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    rtrutil.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutilp.h"
#include "cnctdlg.h"
#include "cncting.h"
#include "rtrstr.h"
#include "ndisutil.h"
#include "netcfgx.h"
#include "register.h"
#include "raseapif.h"
#include "strings.h"
#include "reg.h"            // IsNT4Machine


#include "ports.h"

#include "helper.h"         // CStrParser

// Include headers needed for IP-specific infobase stuff
#include <rtinfo.h>
#include <fltdefs.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include "iprtinfo.h"

// Headers needed for IPX-specific infobase stuff
#include "ipxrtdef.h"

#include <routprot.h>       // protocol ids
#include <Wbemidl.h>
#define _PNP_POWER_
#include "ustringp.h"
#include "ntddip.h"         // IP_PNP_RECONFIG_REQUEST
#include "ndispnp.h"

#include "globals.h"        // structure defaults

#include "raserror.h"

#include "lsa.h"            // RtlEncode/RtlDecode
#include "dsgetdc.h"        // for DsGetDcName
#include "cmptrmgr.h"       // for the computer management nodetype guid

extern "C"
{
#include "mprapip.h"        // for MprAdminDomain functions
};

#include "rtutils.h"        // Tracing functions

#include "rtrcomn.h"    // CoCreateRouterConfig
#include "rrasutil.h"



//
// Timeouts used to control the behavior of ServiceStartPrompt/ServiceStop
//

#define TIMEOUT_START   5000
#define TIMEOUT_MAX     60000
#define TIMEOUT_POLL    5

#define MAX_WAIT_RESTART    60

extern "C" DWORD APIENTRY
MprConfigCreateIpInterfaceInfo(DWORD dwIfType, PBYTE ExistingHeader,
    PBYTE* NewHeader );


//----------------------------------------------------------------------------
// Function:    ConnectRouter
//
// Connects to the router on the specified machine
//----------------------------------------------------------------------------

TFSCORE_API(DWORD)
ConnectRouter(
    IN  LPCTSTR                 pszMachine,
    OUT MPR_SERVER_HANDLE *     phrouter
    )
{
    USES_CONVERSION;
    //
    // Connect to the router
    //
    Assert(*phrouter == NULL);

    return ::MprAdminServerConnect(
                T2W((LPTSTR) pszMachine),
                phrouter
                );
}


TFSCORE_API(DWORD)
GetRouterUpTime(IN LPCTSTR      pszMachine,
                OUT DWORD *     pdwUpTime
                )
{
    DWORD dwError = NO_ERROR;
    MPR_SERVER_HANDLE hMprServer = NULL;
    
    Assert(pdwUpTime);

    dwError = ConnectRouter(pszMachine, &hMprServer);

    if (NO_ERROR == dwError && hMprServer)
    {
        MPR_SERVER_0* pServer0 = NULL;
        dwError = MprAdminServerGetInfo(hMprServer, 0, (LPBYTE *) &pServer0);

        if (NO_ERROR == dwError && pServer0)
        {
            *pdwUpTime = pServer0->dwUpTime;
            MprAdminBufferFree(pServer0);
        }

        MprAdminServerDisconnect(hMprServer);
    }

    return dwError;
}

//----------------------------------------------------------------------------
// Function:    GetRouterPhonebookPath
//
// Constructs the path to the router-phonebook file on the given machine.
//----------------------------------------------------------------------------

HRESULT
GetRouterPhonebookPath(
    IN  LPCTSTR     pszMachine,
    IN  CString *   pstPath
    )
{
    HRESULT hr = hrOK;

    if (!IsLocalMachine(pszMachine))
    {
        // Assuming '\\\\' is appended before the call
        Assert(StrnCmp(_T("\\\\"), pszMachine, 2) == 0);
        
        //
        // Supply the path via the 'ADMIN' share
        //
        *pstPath = pszMachine;
        *pstPath += TEXT('\\');
        *pstPath += c_szAdminShare;
        *pstPath += TEXT('\\');
        *pstPath += c_szSystem32;
        *pstPath += TEXT('\\');
    }
    else
    {

        UINT i, j;
        TCHAR* pszDir;

        //
        // Supply the path on the local machine
        //
        if (!(i = GetSystemDirectory(NULL, 0)))
            return HResultFromWin32(GetLastError());

        pszDir = new TCHAR[++i];

        if (!GetSystemDirectory(pszDir, i))
        {
            hr = HResultFromWin32(GetLastError());
            delete [] pszDir;
            return hr;
        }

        *pstPath = pszDir;
        *pstPath += TEXT('\\');

        delete [] pszDir;
    }

    *pstPath += c_szRAS;
    *pstPath += TEXT('\\');
    *pstPath += c_szRouterPbk;

    return hr;
}


/*!--------------------------------------------------------------------------
    DeleteRouterPhonebook
        Deletes the router.pbk of a machine
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DeleteRouterPhonebook(LPCTSTR pszMachine)
{
    HRESULT     hr = hrOK;
    CString     stMachine, stPhonebookPath;
    
    // Setup the server.  If this is not the local machine, it will
    // need to have \\ as a prefix.
    // ----------------------------------------------------------------
    stMachine = pszMachine;
    if (!IsLocalMachine((LPCTSTR) stMachine))
    {        
        // add on the two slashes to the beginning of the machine name
        // ------------------------------------------------------------
        if (stMachine.Left(2) != _T("\\\\"))
        {
            stMachine = _T("\\\\");
            stMachine += pszMachine;
        }
    }

    if (FHrOK(GetRouterPhonebookPath(stMachine, &stPhonebookPath)))
    {
        // For bug 581673, Add synchronization to ras phonebook file
        HANDLE hPbFile = NULL;

        hPbFile = ::OpenMutexA( SYNCHRONIZE, FALSE,  "RasPbFile" );

        if( NULL == hPbFile )
        {
            hr = HResultFromWin32( ::DeleteFile(stPhonebookPath) );
        }
        else
        {
            ::WaitForSingleObject( hPbFile, INFINITE );

            hr = HResultFromWin32( ::DeleteFile(stPhonebookPath) );
   
            ::ReleaseMutex( hPbFile );
            
            ::CloseHandle( hPbFile );
        }
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    GetLocalMachineName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
CString GetLocalMachineName()
{
    CString stMachine;
    TCHAR   szMachine[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    Verify(GetComputerName(szMachine, &dwSize));
    stMachine = szMachine;
    return stMachine;
}

TFSCORE_API(DWORD) ConnectInterfaceEx(
                        IN MPR_SERVER_HANDLE    hRouter,
                        IN HANDLE hInterface,
                        IN BOOL bConnect,
                        IN HWND hwndParent,
                        IN LPCTSTR pszInterface)
{
    DWORD dwErr;

    Assert(hRouter);
    Assert(hInterface);

    //
    // Initiate the interface connection/disconnection
    //
    if (!bConnect)
    {
        dwErr = ::MprAdminInterfaceDisconnect(hRouter, hInterface);
    }
    else
    {
        dwErr = ::MprAdminInterfaceConnect(hRouter, hInterface, NULL, FALSE);

        if (dwErr == PENDING) { dwErr = NO_ERROR; }

        //
        // Display a dialog so user knows connection is in progress
        //
        CInterfaceConnectDialog dlg(hRouter, hInterface, pszInterface,
                           CWnd::FromHandle(hwndParent));

        dlg.DoModal();
    }


    return dwErr;
}

/*!--------------------------------------------------------------------------
    ConnectInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) ConnectInterface(
                       IN  LPCTSTR  pszMachine,
                       IN  LPCTSTR  pszInterface,
                       IN  BOOL     bConnect,
                       IN  HWND     hwndParent)
{
    DWORD dwErr;
    SPMprServerHandle   sphRouter;
    MPR_SERVER_HANDLE   hRouter = NULL;
    HANDLE              hInterface;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];

    //
    // Connect to the specified machine, if necessary
    //
    dwErr = ConnectRouter(pszMachine, &hRouter);
    if (dwErr != NO_ERROR)
        return dwErr;

    sphRouter.Attach(hRouter);  // so that it gets released

    //
    // Retrieve the interface handle, if necessary
    //
    StrCpyWFromT(wszInterface, pszInterface);

    dwErr = ::MprAdminInterfaceGetHandle(
                                         hRouter,
                                         wszInterface,
                                         &hInterface,
                                         FALSE
                                        );

    if (dwErr != NO_ERROR)
        return dwErr;

    return ConnectInterfaceEx(hRouter, hInterface, bConnect, hwndParent,
                              pszInterface);
}



/*---------------------------------------------------------------------------
    CInterfaceConnectDialog
 ---------------------------------------------------------------------------*/

CInterfaceConnectDialog::CInterfaceConnectDialog(
                               MPR_SERVER_HANDLE    hServer,
                               HANDLE      hInterface,
                               LPCTSTR     pszInterface,
                               CWnd*       pParent
    ) : CDialog(IDD_CONNECTING, pParent),
        m_hServer(hServer),
        m_hInterface(hInterface),
        m_sInterface(pszInterface),
        m_dwTimeElapsed(0),
        m_dwConnectionState(ROUTER_IF_STATE_CONNECTING),
        m_nIDEvent(1) { }


void
CInterfaceConnectDialog::DoDataExchange(CDataExchange* pDX) {

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CInterfaceConnectDialog)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInterfaceConnectDialog, CDialog)
    //{{AFX_MSG_MAP(CInterfaceConnectDialog)
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL
CInterfaceConnectDialog::OnInitDialog()
{

    SetDlgItemText(IDC_EDIT_INTERFACENAME, m_sInterface);

    OnTimer(m_nIDEvent);

    m_nIDEvent = SetTimer(m_nIDEvent, 1000, NULL);

    GetDlgItem(IDCANCEL)->SetFocus();

    return FALSE;
}


VOID CInterfaceConnectDialog::OnCancel()
{
    ::MprAdminInterfaceDisconnect(m_hServer, m_hInterface);
    CDialog::OnCancel();
}


VOID
CInterfaceConnectDialog::OnTimer(
    UINT    nIDEvent
    ) {

    DWORD dwErr;
    CString sTime, sPrompt;
    SPMprAdminBuffer    spMprBuffer;

    if (nIDEvent != m_nIDEvent)
    {
        CWnd::OnTimer(nIDEvent);
        return;
    }

    ++m_dwTimeElapsed;


    if (!(m_dwTimeElapsed % TIMEOUT_POLL))
    {
        MPR_INTERFACE_0* pInfo;

        dwErr = ::MprAdminInterfaceGetInfo(
                    m_hServer,
                    m_hInterface,
                    0,
                    (LPBYTE*)&spMprBuffer
                    );
        pInfo = (MPR_INTERFACE_0 *) (LPBYTE) spMprBuffer;

        if (dwErr == NO_ERROR)
        {
            m_dwConnectionState = pInfo->dwConnectionState;

            if (m_dwConnectionState == ROUTER_IF_STATE_CONNECTED)
            {
                KillTimer(m_nIDEvent);
                EndDialog(IDOK);
            }
            else if (m_dwConnectionState != ROUTER_IF_STATE_CONNECTING)
            {
                KillTimer(m_nIDEvent);

                BringWindowToTop();

                if (pInfo->dwLastError == NO_ERROR)
                {
                    AfxMessageBox(IDS_ERR_IF_DISCONNECTED);
                }
                else
                {
                    //Workaround for bugid: 96347.  Change this once
                    //schannel has an alert for SEC_E_MULTIPLE_ACCOUNTS

                    if ( pInfo->dwLastError == SEC_E_CERT_UNKNOWN )
                    {
                        pInfo->dwLastError = SEC_E_MULTIPLE_ACCOUNTS;
                    }
                    FormatSystemError(HResultFromWin32(pInfo->dwLastError),
                                      sPrompt.GetBuffer(1024),
                                      1024,
                                      IDS_ERR_IF_CONNECTFAILED,
                                      FSEFLAG_ANYMESSAGE
                                     );
                    sPrompt.ReleaseBuffer();
                    AfxMessageBox(sPrompt);
                }

                EndDialog(IDCANCEL);
            }
        }
    }

    sPrompt = ConnectionStateToCString(m_dwConnectionState);
    SetDlgItemText(IDC_TEXT_IFSTATUS, sPrompt);

    FormatNumber(m_dwTimeElapsed, sTime.GetBuffer(1024), 1024, FALSE);
    sTime.ReleaseBuffer();
    AfxFormatString1(sPrompt, IDS_SECONDSFMT, sTime);
    SetDlgItemText(IDC_TEXT_ELAPSED, sPrompt);
}

/*!--------------------------------------------------------------------------
    PromptForCredentials
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) PromptForCredentials(LPCTSTR pszMachine,
                                        LPCTSTR pszInterface,
                                        BOOL fNT4,
                                        BOOL fNewInterface,
                                        HWND hwndParent)
{
    HRESULT                 hr;
    DWORD                   dwErr;
    ULONG_PTR               uConnection             = 0;
    SPMprServerHandle       sphRouter;
    MPR_SERVER_HANDLE       hRouter                 = NULL;
    HANDLE                  hInterface;
    PMPR_INTERFACE_2        pmprInterface           = NULL;
    PMPR_CREDENTIALSEX_0    pmprCredentials         = NULL;
    BYTE*                   pUserDataOut            = NULL;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];

    CIfCredentials dlg(pszMachine, pszInterface,
                       fNewInterface, CWnd::FromHandle(hwndParent));

    if (fNT4)
    {
        dlg.DoModal();
        return NO_ERROR;
    }

    //
    // Connect to the specified machine
    //
    dwErr = ConnectRouter(pszMachine, &hRouter);
    if (dwErr != NO_ERROR)
        goto L_ERR;

    //
    // so that it gets released
    //
    sphRouter.Attach(hRouter);

    //
    // Retrieve the interface handle
    //
    StrCpyWFromT(wszInterface, pszInterface);

    dwErr = ::MprAdminInterfaceGetHandle(
                                         hRouter,
                                         wszInterface,
                                         &hInterface,
                                         FALSE
                                        );

    if (dwErr != NO_ERROR)
        goto L_ERR;

    dwErr = ::MprAdminInterfaceGetInfo(hRouter, hInterface, 2,
                                       (LPBYTE*)&pmprInterface);

    if (dwErr != NO_ERROR)
        goto L_ERR;

    if (pmprInterface->dwfOptions & RASEO_RequireEAP)
    {
        GUID                        guid;
        RegKey                      regkeyEAP;
        RegKey                      regkeyEAPType;
        CString                     stConfigCLSID;
        DWORD                       dwInvokeUsername;
        DWORD                       dwId;
        DWORD                       dwSizeOfUserDataOut;
        CComPtr<IEAPProviderConfig> spEAPConfig;

        dwId = pmprInterface->dwCustomAuthKey;

        TCHAR szStr[40];
        _ltot((LONG)dwId, szStr, 10);
        CString str(szStr);

        dwErr = regkeyEAP.Open(HKEY_LOCAL_MACHINE,
                           c_szEAPKey, KEY_ALL_ACCESS, pszMachine);

        if (ERROR_SUCCESS != dwErr)
            goto L_ERR;

        dwErr = regkeyEAPType.Open(regkeyEAP, str, KEY_READ);

        if (ERROR_SUCCESS != dwErr)
            goto L_ERR;

        dwErr = regkeyEAPType.QueryValue(c_szInvokeUsernameDialog,
                    dwInvokeUsername);

        if ((ERROR_SUCCESS == dwErr) && !dwInvokeUsername)
        {
            dwErr = ::MprAdminInterfaceGetCredentialsEx(hRouter, hInterface, 0,
                                               (LPBYTE*)&pmprCredentials);

            if (dwErr != NO_ERROR)
                goto L_ERR;

            dwErr = regkeyEAPType.QueryValue(c_szConfigCLSID, stConfigCLSID);

            if (ERROR_SUCCESS != dwErr)
                goto L_ERR;

            CHECK_HR(hr = CLSIDFromString((LPTSTR)(LPCTSTR)stConfigCLSID,
                                &guid));

            // Create the EAP provider object
            CHECK_HR( hr = CoCreateInstance(
                                guid,
                                NULL,
                                CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
                                IID_IEAPProviderConfig,
                                (LPVOID *) &spEAPConfig) );

            // Configure this EAP provider
            hr = spEAPConfig->Initialize(pszMachine, dwId, &uConnection);

            if ( !FAILED(hr) )
            {
                hr = spEAPConfig->RouterInvokeCredentialsUI(dwId, uConnection,
                        hwndParent, RAS_EAP_FLAG_ROUTER,
                        pmprInterface->lpbCustomAuthData,
                        pmprInterface->dwCustomAuthDataSize,
                        pmprCredentials->lpbCredentialsInfo, 
                        pmprCredentials->dwSize,
                        &pUserDataOut, &dwSizeOfUserDataOut);

                spEAPConfig->Uninitialize(dwId, uConnection); // Ignore errors
            }

            if ( !FAILED(hr) )
            {
                pmprCredentials->lpbCredentialsInfo = pUserDataOut;
                pmprCredentials->dwSize = dwSizeOfUserDataOut;

                dwErr = ::MprAdminInterfaceSetCredentialsEx(hRouter, hInterface,
                                    0, (LPBYTE)pmprCredentials);

                if (dwErr != NO_ERROR)
                    goto L_ERR;
            }

            goto L_ERR;
        }
    }

    dlg.DoModal();

L_ERR:

    if (NULL != pmprInterface)
    {
        ::MprAdminBufferFree(pmprInterface);
    }

    if (NULL != pmprCredentials)
    {
        ::MprAdminBufferFree(pmprCredentials);
    }

    CoTaskMemFree(pUserDataOut);

    return dwErr;
}

/*---------------------------------------------------------------------------
    CIfCredentials
 ---------------------------------------------------------------------------*/


BEGIN_MESSAGE_MAP(CIfCredentials, CBaseDialog)  
END_MESSAGE_MAP()

DWORD CIfCredentials::m_dwHelpMap[] =
{
    IDC_EDIT_IC_USERNAME, 0,
    IDC_EDIT_IC_DOMAIN, 0,
    IDC_EDIT_IC_PASSWORD, 0,
    IDC_EDIT_IC_PASSWORD2, 0,
    0,0
};


BOOL
CIfCredentials::OnInitDialog(
    ) {

    CBaseDialog::OnInitDialog();

    ((CEdit*)GetDlgItem(IDC_EDIT_IC_USERNAME))->LimitText(UNLEN);
    ((CEdit*)GetDlgItem(IDC_EDIT_IC_DOMAIN))->LimitText(DNLEN);
    ((CEdit*)GetDlgItem(IDC_EDIT_IC_PASSWORD))->LimitText(PWLEN);
    ((CEdit*)GetDlgItem(IDC_EDIT_IC_PASSWORD2))->LimitText(PWLEN);

    //
    // if you are editing a new interface, then you are done.
    //
    if ( m_bNewIf )
        return FALSE;

    //
    // existing interface.  
    //
    WCHAR wszPassword[PWLEN+1];
    WCHAR wszPassword2[PWLEN+1];

    do
    {
        DWORD dwErr = (DWORD) -1;
        CString sErr;

        WCHAR wszUsername[UNLEN+1];
        WCHAR wszDomain[DNLEN+1];

        WCHAR *pswzMachine = NULL;
        WCHAR *pswzInterface = NULL;

        //
        // Retrieve its credentials
        //

        pswzMachine = (WCHAR *) alloca((m_sMachine.GetLength()+3) * sizeof(WCHAR));
        StrCpyWFromT(pswzMachine, m_sMachine);
        
        pswzInterface = (WCHAR *) alloca((m_sInterface.GetLength()+1) * sizeof(WCHAR));
        StrCpyWFromT(pswzInterface, m_sInterface);



        ::SecureZeroMemory( wszUsername, sizeof( wszUsername ) );
        ::SecureZeroMemory( wszDomain, sizeof( wszDomain ) );
        
        dwErr = MprAdminInterfaceGetCredentials(
                    pswzMachine,
                    pswzInterface,
                    wszUsername,
#if 1
                    NULL,
#else
                    wszPassword,
#endif
                    wszDomain
                );

        //
        // if credentials were not retrieved successfully do not pop 
        // up message.  It might mean that credentials have never been
        // set before.
        // Fix for bug # 79607.
        //        
        if ( dwErr != NO_ERROR )
        {
            // FormatSystemError(dwErr, sErr, IDS_SET_CREDENTIALS_FAILED);
            // AfxMessageBox(sErr);
            break;
        }


        //
        // fill the edit boxes with the values retrieved.
        //
        
        SetDlgItemTextW( IDC_EDIT_IC_USERNAME, wszUsername );
        SetDlgItemTextW( IDC_EDIT_IC_DOMAIN, wszDomain );

    } while ( FALSE );

    ::SecureZeroMemory(wszPassword, sizeof(wszPassword));
    ::SecureZeroMemory(wszPassword2, sizeof(wszPassword2));
    
//    SetDlgItemText(IDC_EDIT_IC_USERNAME, m_sInterface);

    return FALSE;
}


VOID
CIfCredentials::OnOK(
    ) {

    DWORD dwErr;
    CString sErr;
    WCHAR wszMachine[MAX_COMPUTERNAME_LENGTH+3];
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
    WCHAR wszUsername[UNLEN+1];
    WCHAR wszDomain[DNLEN+1];
    WCHAR wszPassword[PWLEN+1];
    WCHAR wszPassword2[PWLEN+1];
    WCHAR* pwszPassword = NULL;

    do {

        //
        // Retrieve the edit-controls' contents
        //

        wszUsername[0] = L'\0';
        wszDomain[0] = L'\0';
        wszPassword[0] = L'\0';
        wszPassword2[0] = L'\0';

        GetDlgItemTextW(IDC_EDIT_IC_USERNAME, wszUsername, UNLEN + 1);
        GetDlgItemTextW(IDC_EDIT_IC_DOMAIN, wszDomain, DNLEN + 1);
        GetDlgItemTextW(IDC_EDIT_IC_PASSWORD, wszPassword, PWLEN + 1);
        GetDlgItemTextW(IDC_EDIT_IC_PASSWORD2, wszPassword2, PWLEN + 1);

        //
        // Make sure the password matches its confirmation
        //

        if (lstrcmpW(wszPassword, wszPassword2)) {

            AfxMessageBox(IDS_ERR_PASSWORD_MISMATCH);
            SetDlgItemText(IDC_EDIT_IC_PASSWORD, TEXT(""));
            SetDlgItemText(IDC_EDIT_IC_PASSWORD2, TEXT(""));
            GetDlgItem(IDC_EDIT_IC_PASSWORD)->SetFocus();
            break;
        }


        //
        // If no Password is present, see if the user wants to remove
        // the password or just leave it unreplaced
        //

        if (lstrlen(wszPassword)) {

            pwszPassword = wszPassword;
        }
        else {

            INT id;

            id = AfxMessageBox(IDS_PROMPT_NOPASSWORD, MB_YESNOCANCEL|MB_DEFBUTTON2);

            if (id == IDYES) { pwszPassword = wszPassword; }
            else
            if (id == IDCANCEL) { break; }
        }

        

        //
        // Save the credentials;
        //

        StrCpyWFromT(wszMachine, m_sMachine);

        StrCpyWFromT(wszInterface, m_sInterface);

        dwErr = MprAdminInterfaceSetCredentials(
                    wszMachine,
                    wszInterface,
                    wszUsername,
                    wszDomain,
                    pwszPassword
                    );

        if (dwErr) {
            FormatSystemError(dwErr, sErr.GetBuffer(1024), 1024, IDS_ERR_SET_CREDENTIALS_FAILED, 0xFFFFFFFF);
            sErr.ReleaseBuffer();
            AfxMessageBox(sErr);
            break;
        }

        CBaseDialog::OnOK();

    } while(FALSE);

    //
    // Erase the passwords from the stack.
    //

    ::SecureZeroMemory(wszPassword, sizeof(wszPassword));
    ::SecureZeroMemory(wszPassword2, sizeof(wszPassword2));

    return;
}


TFSCORE_API(DWORD)  UpdateDDM(IInterfaceInfo *pIfInfo)
{

    BOOL                bStatus     = FALSE;
    DWORD               dwErr       = (DWORD) -1;
    CString             sErr;

    MPR_SERVER_HANDLE   hServer     = NULL;
    HANDLE              hInterface  = NULL;

    WCHAR               wszMachine[ MAX_COMPUTERNAME_LENGTH + 3 ];
    WCHAR               wszInterface[ MAX_INTERFACE_NAME_LEN + 1 ];

    do
    {
        // Verify that the router service is running.
        StrCpyWFromT( wszMachine, pIfInfo->GetMachineName() );
        StrCpyWFromT( wszInterface, pIfInfo->GetId() );
        
        bStatus = ::MprAdminIsServiceRunning( wszMachine );
        if ( !bStatus )
        {
            dwErr = NO_ERROR;
            break;
        }

        
        dwErr = ConnectRouter( pIfInfo->GetMachineName(), &hServer );
        if ( dwErr != NO_ERROR )
            break;

        
        dwErr = ::MprAdminInterfaceGetHandle(
                    hServer,
                    wszInterface,
                    &hInterface,
                    FALSE);
        if ( dwErr != NO_ERROR )
            break;

        
        // update phone book info. in DDM
        dwErr = ::MprAdminInterfaceUpdatePhonebookInfo(
                    hServer,
                    hInterface
                  );
        if (dwErr != NO_ERROR )
            break;

    } while ( FALSE );


    if (hServer) { ::MprAdminServerDisconnect(hServer); }

    if ( dwErr != NO_ERROR && dwErr != ERROR_NO_SUCH_INTERFACE ) 
    {
        FormatSystemError( dwErr, sErr.GetBuffer(1024), 1024, IDS_ERR_IF_CONNECTFAILED, 0xffffffff);
        sErr.ReleaseBuffer();
        AfxMessageBox( sErr );
    }

    return dwErr;
}

/*!--------------------------------------------------------------------------
    UpdateRoutes
    
    Performs an autostatic update on the given machine's interface,
    for a specific transport.

    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) UpdateRoutesEx(IN MPR_SERVER_HANDLE hRouter,
                                IN HANDLE hInterface,
                                IN DWORD dwTransportId,
                                IN HWND hwndParent,
                                IN LPCTSTR pszInterface)
{
    DWORD dwErr, dwState;
    MPR_INTERFACE_0* pmprif0=NULL;

    do {
        // See if the interface is connected
        dwErr = ::MprAdminInterfaceGetInfo(hRouter,
                                           hInterface,
                                           0,
                                           (LPBYTE*)&pmprif0);      
        if (dwErr != NO_ERROR || pmprif0 == NULL) { break; }

        dwState = pmprif0->dwConnectionState;
        ::MprAdminBufferFree(pmprif0);

        // Establish the connection if necessary
        if (dwState != (DWORD)ROUTER_IF_STATE_CONNECTED)
        {
            // Connect the interface
            dwErr = ::ConnectInterfaceEx(hRouter,
                                         hInterface,
                                         TRUE,
                                         hwndParent,
                                         pszInterface);
            if (dwErr != NO_ERROR) { break; }
        }

        //
        // Now perform the route-update
        //
        dwErr = ::MprAdminInterfaceUpdateRoutes(
                    hRouter,
                    hInterface,
                    dwTransportId,
                    NULL
                    );
        if (dwErr != NO_ERROR) { break; }

    } while(FALSE);

    return dwErr;
}

TFSCORE_API(DWORD) UpdateRoutes(IN LPCTSTR pszMachine,
                                  IN LPCTSTR pszInterface,
                                  IN DWORD dwTransportId,
                                  IN HWND hwndParent)
{
    DWORD dwErr, dwState;
    HANDLE hInterface = INVALID_HANDLE_VALUE;
    MPR_INTERFACE_0* pmprif0;
    SPMprServerHandle   sphRouter;
    MPR_SERVER_HANDLE   hMachine = NULL;;


    //
    // open a handle
    //

    dwErr = ConnectRouter(pszMachine, &hMachine);
    if (dwErr != NO_ERROR)
        return dwErr;

    sphRouter.Attach(hMachine); // so that it gets released
    

    do {

        //
        // open a handle to the interface
        //

        WCHAR wszInterface[MAX_INTERFACE_NAME_LEN + 1];

        StrCpyWFromT(wszInterface, pszInterface);

        dwErr = MprAdminInterfaceGetHandle(
                                           hMachine,
                                           wszInterface,
                                           &hInterface,
                                           FALSE
                                          );
        
        if (dwErr != NO_ERROR) { break; }


        dwErr = ::UpdateRoutesEx(hMachine,
                               hInterface,
                               dwTransportId,
                               hwndParent,
                               pszInterface);
    } while (FALSE);


    return dwErr;
}


/*!--------------------------------------------------------------------------
    ConnectAsAdmin
        Connect to the remote machine as administrator with user-supplied
        credentials.

        Returns
            S_OK    - if a connection was established
            S_FALSE - if user cancelled out
            other   - error condition
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConnectAsAdmin( IN LPCTSTR szRouterName, IN IRouterInfo *pRouter)
{

    //
    // allow user to specify credentials
    //

    DWORD           dwRes           = (DWORD) -1;
    HRESULT         hr = hrOK;
    
    CConnectAsDlg   caDlg;
    CString         stIPCShare;
    CString         stRouterName;
    CString         stPassword;

    stRouterName = szRouterName;
    
    //
    // set message text in connect as dialog.
    //
    
    caDlg.m_sRouterName = szRouterName;


    //
    // loop till connect succeeds or user cancels
    //
    
    while ( TRUE )
    {

        // We need to ensure that this dialog is brought to
        // the top (if it gets lost behind the main window, we
        // are in trouble).
        dwRes = caDlg.DoModal();

        if ( dwRes == IDCANCEL )
        {
            hr = S_FALSE;
            break;
        }


        //
        // Create remote resource name
        //

        stIPCShare.Empty();
        
        if ( stRouterName.Left(2) != TEXT( "\\\\" ) )
        {
            stIPCShare = TEXT( "\\\\" );
        }
                
        stIPCShare += stRouterName;
        stIPCShare += TEXT( "\\" );
        stIPCShare += c_szIPCShare;


        NETRESOURCE nr;

        nr.dwType       = RESOURCETYPE_ANY;
        nr.lpLocalName  = NULL;
        nr.lpRemoteName = (LPTSTR) (LPCTSTR) stIPCShare;
        nr.lpProvider   = NULL;
            

        //
        // connect to \\router\ipc$ to try and establish credentials.
        // May not be the best way to establish credentials but is 
        // the most expendient for now.
        //

        // Need to unencode the password in the ConnectAsDlg
        stPassword = caDlg.m_sPassword;

        RtlDecodeW(caDlg.m_ucSeed, stPassword.GetBuffer(0));
        stPassword.ReleaseBuffer();
        //Remove Net Connections if there are any present
        RemoveNetConnection( stIPCShare);
        dwRes = WNetAddConnection2(
                    &nr,
                    (LPCTSTR) stPassword,
                    (LPCTSTR) caDlg.m_sUserName,
                    0
                );

        // We need to save off the user name and password
        if (dwRes == NO_ERROR)
        {
            // Parse out the user name, use an arbitrary key for
            // the encoding.
            SPIRouterAdminAccess    spAdmin;

            // For every connection that succeeds we have to ensure
            // that the connection gets removed.  Do this by storing
            // the connections globally.  This will get freed up in
            // the IComponentData destructor.
            // --------------------------------------------------------
            AddNetConnection((LPCTSTR) stIPCShare);

            spAdmin.HrQuery(pRouter);
            if (spAdmin)
            {
                UCHAR   ucSeed = 0x83;
                CString         stName;
                CString         stUser;
                CString         stDomain;
                LPCTSTR         pszUser = NULL;
                LPCTSTR         pszDomain = NULL;
                int             iPos = 0;
                
                // Break the user name into domain\user
                // look for the first forward slash
                stName = caDlg.m_sUserName;
                if ((iPos = stName.FindOneOf(_T("\\"))) == -1)
                {
                    // Couldn't find one, there is no domain info
                    pszUser = (LPCTSTR) stName;
                    pszDomain = NULL;
                }
                else
                {
                    stUser = stName.Right(stName.GetLength() - iPos - 1);
                    stDomain = stName.Left(iPos);
                    
                    pszUser = (LPCTSTR) stUser;
                    pszDomain = (LPCTSTR) stDomain;
                }

                
                // Use the key 0x83 for the password
                RtlEncodeW(&ucSeed, stPassword.GetBuffer(0));
                stPassword.ReleaseBuffer();
                
                spAdmin->SetInfo(pszUser,
                                 pszDomain,
                                 (BYTE *) (LPCTSTR) stPassword,
                                 stPassword.GetLength() * sizeof(WCHAR));
            }
        }

        
        ::SecureZeroMemory(stPassword.GetBuffer(0),
                   stPassword.GetLength() * sizeof(TCHAR));
        stPassword.ReleaseBuffer();

        if ( dwRes != NO_ERROR )
        {
            PBYTE           pbMsgBuf        = NULL;
            
            ::FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwRes,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                (LPTSTR) &pbMsgBuf,
                0,
                NULL 
            );

            AfxMessageBox( (LPCTSTR) pbMsgBuf );

            LocalFree( pbMsgBuf );
        }

        else
        {
            //
            // connection succeeded
            //

            hr = hrOK;
            break;
        }
    }

    return hr;
}
    
DWORD ValidateMachine(const CString &sName, BOOL bDisplayErr)
{
    //  We don't use this info just
    //  make the call to see if the server is out there.  Hopefully
    //  this will be faster than the RegConnectRegistry call.
    //  We get info level 102 because this will also tell
    //  us if we have the correct permissions for the machine.
    SERVER_INFO_102 *psvInfo102;
    DWORD dwr = NetServerGetInfo((LPTSTR)(LPCTSTR)sName,
                                 102, (LPBYTE*)&psvInfo102);
    if (dwr == ERROR_SUCCESS)
    {
        NetApiBufferFree(psvInfo102);

    }
    else if (bDisplayErr)
    {
        CString str;
        str.Format(IDS_ERR_THEREHASBEEN, sName);
        AfxMessageBox(str);
    }
    
    return dwr;
}

/*!--------------------------------------------------------------------------
    InitiateServerConnection
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InitiateServerConnection(LPCTSTR pszMachine,
                                 HKEY *phkey,
                                 BOOL fNoConnectingUI,
                                 IRouterInfo *pRouter)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CConnectingDlg      cnctingdlg;
    DWORD               dwRes = IDOK;
    HRESULT             hr = hrOK;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;
    IUnknown *              punk = NULL;

    Assert(phkey);

    cnctingdlg.m_sName = pszMachine;
    
    // Display the connecting dialog if requested
    if (fNoConnectingUI)
    {
        if (!cnctingdlg.Connect())
            dwRes = 0;
    }
    else
    {
        dwRes = cnctingdlg.DoModal();
    }

    if ( !IsLocalMachine(pszMachine) )
    {
        ZeroMemory(&csi, sizeof(csi));
        ZeroMemory(&cai, sizeof(cai));
        ZeroMemory(&caid, sizeof(caid));
        csi.pAuthInfo = &cai;
        cai.pAuthIdentityData = &caid;

        hr = CoCreateRouterConfig(pszMachine,
                                   pRouter,
                                   &csi,
                                   IID_IRemoteNetworkConfig,
                                   &punk) ;
        if ( hrOK != hr )
        {
           cnctingdlg.m_dwr = ERROR_ACCESS_DENIED;
           dwRes =  0;
        }
        else
        {
            if ( punk ) punk->Release();
        }
    }
    // check and see if we were successful
    if (dwRes == IDCANCEL)
    {
        *phkey = NULL;
        hr = S_FALSE;
        goto Error;
    }
    else if (dwRes != IDOK)
    {
        DisplayConnectErrorMessage(cnctingdlg.m_dwr);
        hr = HResultFromWin32(cnctingdlg.m_dwr);

        if ((cnctingdlg.m_dwr != ERROR_ACCESS_DENIED) &&
            (cnctingdlg.m_dwr != ERROR_LOGON_FAILURE))
        {
            hr = HResultFromWin32(cnctingdlg.m_dwr);
            goto Error;         
        }

        // If there was an access denied error, we ask the
        // user to see if they can supply different credentials
        hr = ConnectAsAdmin(pszMachine, pRouter);

        if (!FHrOK(hr))
        {
            *phkey = NULL;
            hr = HResultFromWin32(ERROR_CANCELLED);
            goto Error;
        }

        // try it again with the new credentials
        dwRes = cnctingdlg.DoModal();
        if (dwRes != IDOK)
        {
            DisplayConnectErrorMessage(cnctingdlg.m_dwr);
            hr = HResultFromWin32(cnctingdlg.m_dwr);
            goto Error;
        }
    }
    
    // successful connection
    if(phkey)
        *phkey = cnctingdlg.m_hkMachine;
    else
        DisconnectRegistry(cnctingdlg.m_hkMachine);

Error:
    return hr;
}


void DisplayConnectErrorMessage(DWORD dwr)
{
    switch (dwr)
    {
        case ERROR_ACCESS_DENIED:
            AfxMessageBox(IDS_ERR_ACCESSDENIED);
            break;
        case ERROR_BAD_NETPATH:
            AfxMessageBox(IDS_ERR_NETPATHNOTFOUND);
            break;
        default:
            DisplayIdErrorMessage2(NULL, IDS_ERR_ERRORCONNECT,
                                   HResultFromWin32(dwr));
            break;
    }
}


/*!--------------------------------------------------------------------------
    IsRouterServiceRunning
        This will return hrOK if the service is running.
        This will return hrFalse if the service is stopped (and no error).
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) IsRouterServiceRunning(IN LPCWSTR pszMachine,
                                            OUT DWORD *pdwErrorCode)
{
    HRESULT     hr = hrOK;
    DWORD       dwServiceStatus = 0;

    hr = GetRouterServiceStatus(pszMachine, &dwServiceStatus, pdwErrorCode);

    if (FHrSucceeded(hr))
    {
        hr = (dwServiceStatus == SERVICE_STOPPED) ? hrFalse : hrOK;
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    GetRouterServiceStatus
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) GetRouterServiceStatus(LPCWSTR pszMachine,
                                            DWORD *pdwStatus,
                                            DWORD *pdwErrorCode)
{
    HRESULT     hr = hrOK;
    DWORD       dwServiceStatus = 0;

    Assert(pdwStatus);

    // First check the Router service (for Steelhead)
    // ----------------------------------------------------------------
    hr = HResultFromWin32(TFSGetServiceStatus(pszMachine,
                                              c_szRouter,
                                              &dwServiceStatus,
                                              pdwErrorCode));

    
    // If that failed, then we look at the RemoteAccess
    // ----------------------------------------------------------------
    if (!FHrSucceeded(hr) || (dwServiceStatus == SERVICE_STOPPED))
    {
        hr = HResultFromWin32(TFSGetServiceStatus(pszMachine,
            c_szRemoteAccess,
            &dwServiceStatus,
            pdwErrorCode) );
        
    }

    if (FHrSucceeded(hr))
    {
        *pdwStatus = dwServiceStatus;
    }
    return hr;
}


TFSCORE_API(HRESULT) GetRouterServiceStartType(LPCWSTR pszMachine, DWORD *pdwStartType)
{
    HRESULT     hr = hrOK;
    DWORD       dwStartType = 0;

    Assert(pdwStartType);

    // First check the Router service (for Steelhead)
    // ----------------------------------------------------------------
    hr = HResultFromWin32(TFSGetServiceStartType(pszMachine,
        c_szRouter, &dwStartType) );

    // If that failed, then we look at the RemoteAccess service
    // ----------------------------------------------------------------
    if (!FHrSucceeded(hr))
    {
        hr = HResultFromWin32(TFSGetServiceStartType(pszMachine,
            c_szRemoteAccess,
            &dwStartType) );
        
    }

//Error:
    if (FHrSucceeded(hr))
    {
        *pdwStartType = dwStartType;
    }
    return hr;
}


TFSCORE_API(HRESULT) SetRouterServiceStartType(LPCWSTR pszMachine, DWORD dwStartType)
{
    HRESULT     hr = hrOK;

    // Set the start type for both the Router and RemoteAccess
    // ---------------------------------------------------------------- 
    hr = HResultFromWin32(TFSSetServiceStartType(pszMachine,
        c_szRouter, dwStartType) );

    hr = HResultFromWin32(TFSSetServiceStartType(pszMachine,
        c_szRemoteAccess,
        dwStartType) );
        
    return hr;
}

TFSCORE_API(HRESULT) ErasePSK(LPCWSTR pszMachine )
{
    DWORD                   dwErr = ERROR_SUCCESS;
    HANDLE                  hMprServer = NULL;
    WCHAR                   szEmptyPSK[5] = {0};
    HRESULT                 hr = hrOK;
    MPR_CREDENTIALSEX_0     MprCredentials;

    dwErr = ::MprAdminServerConnect((LPWSTR)pszMachine , &hMprServer);
    if ( ERROR_SUCCESS != dwErr )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }

    ::SecureZeroMemory(&MprCredentials, sizeof(MprCredentials));
    //Setup the MprCredentials structure
    MprCredentials.dwSize = 0;
    MprCredentials.lpbCredentialsInfo = (LPBYTE)szEmptyPSK;
    dwErr = MprAdminServerSetCredentials( hMprServer, 0, (LPBYTE)&MprCredentials );
    if ( ERROR_SUCCESS != dwErr )
    {
        //Special case! If 13011 is returned, ignore it.
        //This is because, the ipsec filter is not yet loaded and
        //we are making calls to remove it.
        if ( ERROR_IPSEC_MM_AUTH_NOT_FOUND != dwErr )
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Error;
        }
    }



Error:

    if ( hMprServer )
        ::MprAdminServerDisconnect(hMprServer);
    return hr;
}
/*!--------------------------------------------------------------------------
    StartRouterService
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) StartRouterService(LPCWSTR pszMachine)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    CString     stServiceDesc;
    DWORD       dwErr;
    BOOL        fNt4 = FALSE;
    LPCTSTR     pszServiceName = NULL;
    HKEY        hkeyMachine = NULL;
    DWORD       dwErasePSK = 0;

    COM_PROTECT_TRY
    {
        // Ignore the failure code, what else can we do?
        // ------------------------------------------------------------
        dwErr = ConnectRegistry(pszMachine, &hkeyMachine);
        if (dwErr == ERROR_SUCCESS)
        {
            IsNT4Machine(hkeyMachine, &fNt4);            
            DisconnectRegistry(hkeyMachine);
        }

        // Windows Nt Bug : 277121
        // If this is an NT4 machine, try to start the Router service
        // rather than the RemoteAccess service.
        // ------------------------------------------------------------
        // pszServiceName = (fNt4 ? c_szRouter : c_szRemoteAccess);
        pszServiceName = c_szRemoteAccess;
        
        stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
        dwErr = TFSStartService(pszMachine,
                                pszServiceName,
                                stServiceDesc);

        hr = HResultFromWin32(dwErr);

        if (FHrOK(hr))
        {
            BOOL    fIsRunning = FALSE;

            // Windows NT Bug : 254167
            // Need to check to see if the service is running
            // (an error could have occurred in the StartService).
            // --------------------------------------------------------
            dwErr = TFSIsServiceRunning(pszMachine,
                                        pszServiceName,
                                        &fIsRunning);
            if ((dwErr == ERROR_SUCCESS) && fIsRunning)
            {            
                // Now we need to wait for the router to actually start
                // running.

                CString stText;
                CString stTitle;
                stText.LoadString(IDS_WAIT_FOR_RRAS);
                stTitle.LoadString(IDS_WAIT_FOR_RRAS_TITLE);
                    
                CWaitForRemoteAccessDlg dlg(pszMachine, stText, stTitle, NULL);
                dlg.DoModal();
            }
            //Now that the router service is started, check to see if PSK 
            //needs to be cleaned up
            if ( FHrSucceeded (ReadErasePSKReg(pszMachine, &dwErasePSK) ) )
            {
                if ( dwErasePSK )
                {
                    //What if the thing fails here.  Cannot do much
                    if ( FHrSucceeded(ErasePSK (pszMachine)) )
                    {
                        WriteErasePSKReg(pszMachine, 0 );
                    }
                    
                }
            }
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*!--------------------------------------------------------------------------
    StopRouterService
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) StopRouterService(LPCWSTR pszMachine)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    CString     stServiceDesc;
    DWORD       dwErr;

    COM_PROTECT_TRY
    {

        // Load the description for the SAP Agent
        stServiceDesc.LoadString(IDS_SAPAGENT_SERVICE_DESC);
        
        // Stop the SAP Agent
        // ------------------------------------------------------------
        dwErr = TFSStopService(pszMachine,
                               c_szNWSAPAgent,
                               stServiceDesc);

        
        // Load the description for the router
        // ------------------------------------------------------------
        stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
        
        // Stop the router service
        // ------------------------------------------------------------
        dwErr = TFSStopService(pszMachine,
                               c_szRouter,
                               stServiceDesc);

        // Stop the RemoteAccess service
        // ------------------------------------------------------------
        dwErr = TFSStopService(pszMachine,
                               c_szRemoteAccess,
                               stServiceDesc);

        // If we get the ERROR_SERVICE_NOT_ACTIVE, this is ok since
        // we are trying to stop the service anyway.
        // ------------------------------------------------------------
        if (dwErr == ERROR_SERVICE_NOT_ACTIVE)
            hr = hrOK;
        else
            hr = HResultFromWin32(dwErr);
    }
    COM_PROTECT_CATCH;

    return hr;
}



/*!--------------------------------------------------------------------------
    ForceGlobalRefresh
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) ForceGlobalRefresh(IRouterInfo *pRouter)
{
    // Call through to the refresh object to start a refresh action
    SPIRouterRefresh    spRefresh;
    HRESULT             hr = hrOK;
    DWORD               dwSize;
    static TCHAR        szName[MAX_PATH];
    
    
    if (pRouter == NULL)
        CORg( E_INVALIDARG );

    //
    // In some timing windows/code paths, IRouterInfo.m_stMachine can be an 
    // empty string for local machines. This leads to protocol nodes like IGMP, 
    // NAT etc to either not appear, or appear twice when refreshing the IPSnap.
    // So in case when the name is an empty string, we determine name of the 
    // local machine and call IRouterInfo.SetMachineName to update 
    // IRouterInfo.m_stMachine.
    //
    if (pRouter->GetMachineName() == NULL ||
        !(lstrcmp(pRouter->GetMachineName(), TEXT(""))) ) {

        dwSize = MAX_PATH;
        if ( GetComputerNameEx(ComputerNamePhysicalNetBIOS,
                            szName,
                            &dwSize) ) {
            pRouter->SetMachineName(szName);
        }
        else {
            dwSize = MAX_PATH;
            if ( GetComputerNameEx(ComputerNamePhysicalDnsHostname,
                                szName,
                                &dwSize) ) {
                pRouter->SetMachineName(szName);
            }
        }
    }
    
    CORg( pRouter->GetRefreshObject(&spRefresh) );

    if (spRefresh)
        CORg( spRefresh->Refresh() );
Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    FormatRasPortName
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void FormatRasPortName(BYTE *pRasPort0, LPTSTR pszBuffer, UINT cchMax)
{
    RAS_PORT_0 *    prp0 = (RAS_PORT_0 *) pRasPort0;
    CString         stName;
    
    stName.Format(_T("%ls (%ls)"), prp0->wszDeviceName, prp0->wszPortName);
    StrnCpy(pszBuffer, (LPCTSTR) stName, cchMax);
    pszBuffer[cchMax-1] = 0;
}

static CString  s_PortNonOperational;
static CString  s_PortDisconnected;
static CString  s_PortCallingBack;
static CString  s_PortListening;
static CString  s_PortAuthenticating;
static CString  s_PortAuthenticated;
static CString  s_PortInitializing;
static CString  s_PortUnknown;

static const CStringMapEntry    s_PortConditionMap[] =
{
    { RAS_PORT_NON_OPERATIONAL, &s_PortNonOperational,  IDS_PORT_NON_OPERATIONAL },
    { RAS_PORT_DISCONNECTED,    &s_PortDisconnected,    IDS_PORT_DISCONNECTED },
    { RAS_PORT_CALLING_BACK,    &s_PortCallingBack,     IDS_PORT_CALLING_BACK },
    { RAS_PORT_LISTENING,       &s_PortListening,       IDS_PORT_LISTENING },
    { RAS_PORT_AUTHENTICATING,  &s_PortAuthenticating,  IDS_PORT_AUTHENTICATING },
    { RAS_PORT_AUTHENTICATED,   &s_PortAuthenticated,   IDS_PORT_AUTHENTICATED },
    { RAS_PORT_INITIALIZING,    &s_PortInitializing,    IDS_PORT_INITIALIZING },
    { -1,                       &s_PortUnknown,         IDS_PORT_UNKNOWN },
};

/*!--------------------------------------------------------------------------
    PortConditionToCString
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
CString&    PortConditionToCString(DWORD dwPortCondition)
{
    return MapDWORDToCString(dwPortCondition, s_PortConditionMap);
}


static  CString s_stPortsDeviceTypeNoUsage;
static  CString s_stPortsDeviceTypeRouting;
static  CString s_stPortsDeviceTypeRas;
static  CString s_stPortsDeviceTypeRasRouting;
static  CString s_stPortsDeviceTypeUnknown;

static const CStringMapEntry    s_PortsDeviceTypeMap[] =
{
    { 0,    &s_stPortsDeviceTypeNoUsage,    IDS_PORTSDLG_COL_NOUSAGE },
    { 1,    &s_stPortsDeviceTypeRouting,    IDS_PORTSDLG_COL_ROUTING },
    { 2,    &s_stPortsDeviceTypeRas,    IDS_PORTSDLG_COL_RAS },
    { 3,    &s_stPortsDeviceTypeRasRouting, IDS_PORTSDLG_COL_RASROUTING },
    { -1,   &s_stPortsDeviceTypeUnknown,    IDS_PORTSDLG_COL_UNKNOWN },
};

CString&    PortsDeviceTypeToCString(DWORD dwRasRouter)
{
    return MapDWORDToCString(dwRasRouter, s_PortsDeviceTypeMap);
}


/*!--------------------------------------------------------------------------
    RegFindInterfaceKey
        -
    This function returns the HKEY of the router interface with this ID.

    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RegFindInterfaceKey(LPCTSTR pszInterface,
                                 HKEY hkeyMachine,
                                 REGSAM regAccess,
                                 HKEY *pHKey)
{
    HRESULT     hr = hrFalse;
    HKEY        hkey = 0;
    RegKey      regkey;
    RegKey      regkeyIf;
    RegKeyIterator  regkeyIter;
    HRESULT     hrIter;
    CString     stValue;
    CString     stKey;
    DWORD       dwErr;

    COM_PROTECT_TRY
    {
        // Open up the remoteaccess key
        CWRg( regkey.Open(hkeyMachine, c_szInterfacesKey) );

        // Now look for the key that matches this one
        CORg( regkeyIter.Init(&regkey) );

        for (hrIter = regkeyIter.Next(&stKey); hrIter == hrOK; hrIter = regkeyIter.Next(&stKey))
        {
            regkeyIf.Close();

            // Open the key
            dwErr = regkeyIf.Open(regkey, stKey, regAccess);
            if (dwErr != ERROR_SUCCESS)
                continue;

            CORg( regkeyIf.QueryValue(c_szInterfaceName, stValue) );

            if (stValue.CompareNoCase(pszInterface) == 0)
            {
                // Ok, we found the key that we want
                if (pHKey)
                {
                    *pHKey = regkeyIf.Detach();
                    hr = hrOK;
                }
            }
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}


// hour map ( one bit for an hour of a week )
static BYTE     s_bitSetting[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

//====================================================
// convert a List of Strings to Hour Map
// Strings in following format: 0 1:00-12:00 15:00-17:00
// hour map: a bit for an hour, 7 * 24 hours = 7 * 3 bytes
void StrListToHourMap(CStringList& stList, BYTE* map) 
{
    CStrParser  Parser;
    int         sh, sm, eh, em = 0; // start hour, (min), end hour (min)
    int         day;
    BYTE*       pHourMap;
    int         i;
    POSITION    pos;

    pos = stList.GetHeadPosition();
    
    memset(map, 0, sizeof(BYTE) * 21);

    while (pos)
    {
        Parser.SetStr( stList.GetNext(pos) );

        Parser.SkipBlank();
        day = Parser.DayOfWeek();
        Parser.SkipBlank();
        if(day == -1) continue;

        pHourMap = map + sizeof(BYTE) * 3 * day;

        while(-1 != (sh = Parser.GetUINT())) // sh:sm-eh:em
        {
            Parser.GotoAfter(_T(':'));
            if(-1 == (sm = Parser.GetUINT()))   // min
                break;
            Parser.GotoAfter(_T('-'));
            if(-1 == (eh = Parser.GetUINT()))   // hour
                break;
            if(-1 == (sm = Parser.GetUINT()))   // min
                break;
            sm %= 60; sh %= 24; em %= 60; eh %= 25; // since we have end hour of 24:00
            for(i = sh; i < eh; i++)
            {
                *(pHourMap + i / 8) |= s_bitSetting[i % 8];
            }
        }
    }
}

//=====================================================
// convert value from map to strings
void HourMapToStrList(BYTE* map, CStringList& stList) 
{
    int         sh, eh; // start hour, (min), end hour (min)
    BYTE*       pHourMap;
    int         i, j;
    CString*    pStr;
    CString     tmpStr;

    // update the profile table
    pHourMap = map;
    stList.RemoveAll();

    for( i = 0; i < 7; i++) // for each day
    {
        // if any value for this day
        if(*pHourMap || *(pHourMap + 1) || *(pHourMap + 2))
        {
            // the string for this day
            try{
                pStr = NULL;
                pStr = new CString;

                // Print out the day, the day of the week is
                // represented by an integer (0-6)
                pStr->Format(_T("%d"), i);

                sh = -1; eh = -1;   // not start yet
                for(j = 0; j < 24; j++) // for every hour
                {
                    int k = j / 8;
                    int m = j % 8;
                    if(*(pHourMap + k) & s_bitSetting[m])   // this hour is on
                    {
                        if(sh == -1)    sh = j;         // set start hour is empty
                        eh = j;                         // extend end hour
                    }
                    else    // this is not on
                    {
                        if(sh != -1)        // some hours need to write out
                        {
                            tmpStr.Format(_T(" %02d:00-%02d:00"), sh, eh + 1);
                            *pStr += tmpStr;
                            sh = -1; eh = -1;
                        }
                    }
                }
                if(sh != -1)
                {
                    tmpStr.Format(_T(" %02d:00-%02d:00"), sh, eh + 1);
                    *pStr += tmpStr;
                    sh = -1; eh = -1;
                }
        
                stList.AddTail(*pStr);
            }
            catch(CMemoryException* pException)
            {
                pException->Delete();
//              AfxMessageBox(IDS_OUTOFMEMORY);
                delete pStr;
                stList.RemoveAll();
                return;
            }
            
        }
        pHourMap += 3;
    }
}

/*!--------------------------------------------------------------------------
    SetGlobalRegistrySettings
        hkeyMachine - HKEY of the local machine key
        fInstall - TRUE if we are installing
        fChangeEnableRouter - TRUE if we can change the router key
        (This is NOT the value of IpEnableRouter, but only if we are
        allowed to change the value of this key).
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetGlobalRegistrySettings(HKEY hkeyMachine,
                                  BOOL fInstall,
                                  BOOL fChangeEnableRouter)
{
    HRESULT hr = hrOK;
    RegKey  regkey;
    DWORD   dwInstall = fInstall;
    DWORD   dwNotInstall = !fInstall;
    DWORD   dwErr;

    // Open the TcpIp parmeters key 
    if (regkey.Open(hkeyMachine, c_szRegKeyTcpipParameters) != ERROR_SUCCESS)
    {
        // No need to set the error return code, if an error occurs
        // assume that the key doesn't exist.
        goto Error;
    }

    //  Set IPEnableRouter to (fInstall)
    if (fChangeEnableRouter)
        CWRg( regkey.SetValue(c_szRegValIpEnableRouter, dwInstall) );
//  regkey.SetValue(c_szRegValIpEnableRouterBackup, dwNotInstall);

    
    //  Set EnableICMPRedirect to (!fInstall)
    CWRg( regkey.SetValue(c_szRegValEnableICMPRedirect, dwNotInstall) );

    
    // Set the defaults for the new adapters

    CWRg( regkey.SetValue(c_szRegValDeadGWDetectDefault, dwNotInstall) );
    CWRg( regkey.SetValue(c_szRegValDontAddDefaultGatewayDefault, dwInstall) );
    
Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    SetPerInterfaceRegistrySettings
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetPerInterfaceRegistrySettings(HKEY hkeyMachine, BOOL fInstall)
{
    HRESULT hr = hrOK;
    DWORD   dwInstall = fInstall;
    DWORD   dwNotInstall = !fInstall;
    RegKey  rkAdapters;
    RegKey  rkAdapter;
    RegKeyIterator  rkIter;
    HRESULT hrIter;
    CString stAdapter;
    CStringList stIfList;
    DWORD   dwErr;
    POSITION    posIf;
    RegKey  rkIf;
    CString stKey;
    CString stIf;

    // Get the key to the adapters section of TcpIp services
    if (rkAdapters.Open(hkeyMachine, c_szRegKeyTcpipAdapters) != ERROR_SUCCESS)
    {
        // No need to set the error return code, if an error occurs
        // assume that the key doesn't exist.
        goto Error;
    }
    
    CORg( rkIter.Init(&rkAdapters) );

    // Iterate through all of the adapters and set the key
    for ( hrIter = rkIter.Next(&stAdapter); hrIter == hrOK; hrIter=rkIter.Next(&stAdapter) )
    {
        rkAdapter.Close();

        // Open the adapter key
        // ------------------------------------------------------------
        dwErr = rkAdapter.Open(rkAdapters, stAdapter);
        if (dwErr != ERROR_SUCCESS)
        {
            continue;
        }

        // Now that we have the adapter, we open up the IpConfig key
        // to get the list of interfaces that match up to this adapter.
        // ------------------------------------------------------------
        CWRg( rkAdapter.QueryValue(c_szRegValIpConfig, stIfList) );

        
        // Iterate through the interface list and set these values
        // on each interface
        // ------------------------------------------------------------
        posIf = stIfList.GetHeadPosition();
        while (posIf)
        {
            stIf = stIfList.GetNext(posIf);

            // Create the right key
            // --------------------------------------------------------
            stKey = c_szSystemCCSServices;
            stKey += _T('\\');
            stKey += stIf;

            rkIf.Close();
            CWRg( rkIf.Open(hkeyMachine, stKey) );

            
            
            //  Set DeadGWDetect to (!fInstall) for each interface
            // --------------------------------------------------------
            dwErr = rkIf.SetValue(c_szRegValDeadGWDetect, dwNotInstall);

            
            // Windows NT Bug: 168546
            // Set DontAddDefaultGateway to (fInstall) only on Ndiswan adapters
            // not ALL adapters.
            // --------------------------------------------------------
            if (stAdapter.Left(7).CompareNoCase(_T("NdisWan")) == 0)
            {
                dwErr = rkIf.SetValue(c_szRegValDontAddDefaultGateway, dwInstall);
            }
        }       
    }

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    InstallGlobalSettings
        Sets the global settings (i.e. registry settings) on this machine
        when the router is installed.

        For a specific description of the actions involved, look at
        the comments in the code.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InstallGlobalSettings(LPCTSTR pszMachineName, IRouterInfo *pRouter)
{
    HRESULT     hr = hrOK;
    RouterVersionInfo   routerVersion;
    BOOL        fSetIPEnableRouter = FALSE;

    // We can change the IPEnableRouter only if this is the right build.
    // ----------------------------------------------------------------
    if (pRouter)
    {
        pRouter->GetRouterVersionInfo(&routerVersion);
    }
    else
    {
        // Need to get the version info manually
        // ------------------------------------------------------------
        HKEY    hkeyMachine = NULL;
        
        if (ERROR_SUCCESS == ConnectRegistry(pszMachineName, &hkeyMachine))
            QueryRouterVersionInfo(hkeyMachine, &routerVersion);
        
        if (hkeyMachine)
            DisconnectRegistry(hkeyMachine);
    }
    
    if (routerVersion.dwOsBuildNo <= USE_IPENABLEROUTER_VERSION)
        fSetIPEnableRouter = TRUE;

    CORg( SetRouterInstallRegistrySettings(pszMachineName, TRUE, fSetIPEnableRouter) );

    NotifyTcpipOfChanges(pszMachineName,
                         pRouter,
                         fSetIPEnableRouter /*fEnableRouter*/,
                         IP_IRDP_DISABLED /*uPerformRouterDiscovery*/);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    UninstallGlobalSettings
        Clears the global settings (i.e. registry settings) on this machine
        when the router is installed.

        Set fSnapinChanges to TRUE if you want to write out the various
        snapin changes.

        For a specific description of the actions involved, look at
        the comments in the code.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT UninstallGlobalSettings(LPCTSTR pszMachineName,
                                IRouterInfo *pRouter,
                                BOOL fNt4,
                                BOOL fSnapinChanges)
{
    HRESULT     hr = hrOK;
    DWORD       dwStatus = SERVICE_RUNNING;
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fChange;

    // Windows NT Bug : 273047
    // Check to see if the SharedAccess service is running.
    // We need to check this only for NT4
    // ----------------------------------------------------------------
    if (!fNt4)
    {
        DWORD   dwErrT;
        
        // Get the status of the SharedAccess service. If we cannot
        // get the status of the service, we assume that the service
        // is stopped.
        // ------------------------------------------------------------
        dwErrT = TFSGetServiceStatus(pszMachineName, c_szSharedAccess,
                                     &dwStatus, &dwErr);

        // If we have a problem with the API, or if the API reported
        // a service-specific error, we assume the service is stopped.
        // ------------------------------------------------------------
        if ((dwErrT != ERROR_SUCCESS) || (dwErr != ERROR_SUCCESS))
            dwStatus = SERVICE_STOPPED;
    }

    // If the SharedAccess service is running, then we do NOT want to
    // change the IpEnableRouter key.
    // ----------------------------------------------------------------
    fChange = (dwStatus == SERVICE_RUNNING);

    // This will ALWAYS set the IPEnableRouter key to 0, which is fine
    // with us.  (We do not need to check the version).
    // ----------------------------------------------------------------
    CORg( SetRouterInstallRegistrySettings(pszMachineName, FALSE, !fChange) );

    if (fSnapinChanges)
    {
        CORg( WriteRouterConfiguredReg(pszMachineName, FALSE) );

        CORg( WriteRRASExtendsComputerManagementKey(pszMachineName, FALSE) );
    }

    NotifyTcpipOfChanges(pszMachineName,
                         pRouter,
                         FALSE /* fEnableRouter */,
                         IP_IRDP_DISABLED_USE_DHCP /* uPerformRouterDiscovery */);
    
Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    WriteErasePSKReg
        -
    Author: Vivekk
 ---------------------------------------------------------------------------*/

HRESULT WriteErasePSKReg (LPCTSTR pszServerName, DWORD dwErasePSK )
{
    HRESULT hr = hrOK;
    RegKey  regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szRemoteAccessKey,KEY_ALL_ACCESS,  pszServerName) )
        CWRg(regkey.SetValue( c_szRouterPSK, dwErasePSK));

Error:
    return hr;

}
/*!--------------------------------------------------------------------------
    ReadErasePSKReg
        -
    Author: Vivekk
 ---------------------------------------------------------------------------*/
HRESULT ReadErasePSKReg(LPCTSTR pszServerName, DWORD *pdwErasePSK)
{
    HRESULT hr = hrOK;
    RegKey      regkey;

    Assert(pdwErasePSK);

    CWRg( regkey.Open(HKEY_LOCAL_MACHINE,
                      c_szRemoteAccessKey,
                      KEY_ALL_ACCESS,
                      pszServerName) );

    CWRg( regkey.QueryValue( c_szRouterPSK, *pdwErasePSK) );

Error:
    // If we can't find the key, we assume that the router has not
    // been configured.
    // ----------------------------------------------------------------
    if (hr == HResultFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = hrOK;
        *pdwErasePSK = FALSE;
    }

   return hr;
}


/*!--------------------------------------------------------------------------
    WriteRouterConfiguredReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT WriteRouterConfiguredReg(LPCTSTR pszServerName, DWORD dwConfigured)
{
    HRESULT hr = hrOK;
    RegKey      regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szRemoteAccessKey,KEY_ALL_ACCESS,  pszServerName) )
        CWRg(regkey.SetValue( c_szRtrConfigured, dwConfigured));

Error:
   return hr;
}



/*!--------------------------------------------------------------------------
    ReadRouterConfiguredReg
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ReadRouterConfiguredReg(LPCTSTR pszServerName, DWORD *pdwConfigured)
{
    HRESULT hr = hrOK;
    RegKey      regkey;

    Assert(pdwConfigured);

    CWRg( regkey.Open(HKEY_LOCAL_MACHINE,
                      c_szRemoteAccessKey,
                      KEY_ALL_ACCESS,
                      pszServerName) );
    
    CWRg( regkey.QueryValue( c_szRtrConfigured, *pdwConfigured) );

Error:
    // If we can't find the key, we assume that the router has not
    // been configured.
    // ----------------------------------------------------------------
    if (hr == HResultFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = hrOK;
        *pdwConfigured = FALSE;
    }
    
   return hr;
}


/*!--------------------------------------------------------------------------
    WriteRRASExtendsComputerManagement
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT WriteRRASExtendsComputerManagementKey(LPCTSTR pszServer, DWORD dwConfigured)
{
    HRESULT hr = hrOK;
    RegKey  rkMachine;
    TCHAR   szGuid[128];

    // Stringize the RRAS GUID
    ::StringFromGUID2(CLSID_RouterSnapinExtension, szGuid, DimensionOf(szGuid));
    
    CWRg( rkMachine.Open(HKEY_LOCAL_MACHINE, c_szRegKeyServerApplications,
                         KEY_ALL_ACCESS, pszServer) );
        
    if (dwConfigured)
    {
        // Need to add the following key
        //  HKLM \ System \ CurrentControlSet \ Control \ Server Applications
        //      <GUID> : REG_SZ : some string
        CWRg( rkMachine.SetValue(szGuid, _T("Remote Access and Routing")) );
    }
    else
    {
        // Need to remove the following key
        //  HKLM \ System \ CurrentControlSet \ Control \ Server Applications
        //      <GUID> : REG_SZ : some string
        CWRg( rkMachine.DeleteValue( szGuid ) );
    }

Error:
    return hr;
}



/*!--------------------------------------------------------------------------
    NotifyTcpipOfChanges
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void NotifyTcpipOfChanges(LPCTSTR pszMachineName,
                          IRouterInfo *pRouter,
                          BOOL fEnableRouter,
                          UCHAR uPerformRouterDiscovery)
{
    HRESULT     hr = hrOK;
    RegKey  rkInterfaces;
    RegKey  rkIf;
    RegKeyIterator  rkIter;
    HRESULT hrIter;
    CString stKey;
    DWORD   dwErr;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;

    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));
    
    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;
    

    
    // For now, notify the user that they will have to
    // reboot the machine locally.

    if (!IsLocalMachine(pszMachineName))
    {

        SPIRemoteTCPIPChangeNotify  spNotify;
        // Create the remote config object
        // ----------------------------------------------------------------
        hr = CoCreateRouterConfig(pszMachineName,
                                  pRouter,
                                  &csi,
                                  IID_IRemoteTCPIPChangeNotify,
                                  (IUnknown**)&spNotify);
        if (FAILED(hr)) goto Error;

        // Upgrade the configuration (ensure that the registry keys
        // are populated correctly).
        // ------------------------------------------------------------

        // Still do the notification for remote machines in case it is running
        // an old build
        Assert(spNotify);
        hr = spNotify->NotifyChanges(fEnableRouter, uPerformRouterDiscovery);
        
        spNotify.Release();

        if (csi.pAuthInfo)
            delete csi.pAuthInfo->pAuthIdentityData->Password;
    }
    else
    {
        // For the local case, 
        // Don't need to do any notification after bug 405636 and 345700 got fixed
    }

Error:
    if (!FHrSucceeded(hr))
    {
        if (hr == NETCFG_S_REBOOT)
            AfxMessageBox(IDS_WRN_INSTALL_REBOOT_NOTIFICATION);
        else
            DisplayErrorMessage(NULL, hr);
    }
        

}


/*!--------------------------------------------------------------------------
    AddIpPerInterfaceBlocks
        Setup this interface's infobase for IP.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIpPerInterfaceBlocks(IInterfaceInfo *pIf, IInfoBase *pInfoBase)
{
    HRESULT     hr = hrOK;
    BYTE*       pInfo;
    BYTE*       pNewInfo = NULL;
    DWORD       dwErr;
    DWORD       dwSize;

    CORg( pInfoBase->WriteTo(&pInfo, &dwSize) );
    
    dwErr = MprConfigCreateIpInterfaceInfo(
                pIf->GetInterfaceType(), pInfo, &pNewInfo );
    CoTaskMemFree(pInfo);
    if (dwErr != NO_ERROR) { return E_OUTOFMEMORY; }
    dwSize = ((RTR_INFO_BLOCK_HEADER*)pNewInfo)->Size;
    CORg( pInfoBase->LoadFrom(dwSize, pNewInfo) );

Error:
    if (pNewInfo) { MprInfoDelete(pNewInfo); }
    return hr;
}

/*!--------------------------------------------------------------------------
    MprConfigCreateIpInterfaceInfo
        Constructs an infobase containing required IP interface configuration.
        The infobase should freed by calling 'MprInfoDelete'.
    Author: AboladeG (based on AddIpPerInterfaceBlocks by KennT).
 ---------------------------------------------------------------------------*/
extern "C"
DWORD APIENTRY MprConfigCreateIpInterfaceInfo(DWORD dwIfType,
    PBYTE ExistingHeader, PBYTE* NewHeader )
{
    DWORD dwErr;
    PBYTE Header = NULL;

    if (ExistingHeader)
    {
        dwErr = MprInfoDuplicate(ExistingHeader, (VOID**)&Header);
    }
    else
    {
        dwErr = MprInfoCreate(RTR_INFO_BLOCK_VERSION, (VOID**)&Header);
    }

    if (dwErr) { return dwErr; }
    
    do {

        //
        // Check that there is a block for interface-status in the info,
        // and insert the default block if none is found.
        //
        if ( !MprInfoBlockExists(Header, IP_MCAST_HEARBEAT_INFO) )
        {
            dwErr =
                MprInfoBlockAdd(
                    Header,
                    IP_MCAST_HEARBEAT_INFO,
                    sizeof(MCAST_HBEAT_INFO),
                    1,
                    g_pIpIfMulticastHeartbeatDefault,
                    (VOID**)NewHeader
                    );
            if (dwErr) { break; }

            MprInfoDelete(Header); Header = *NewHeader;
        }
    
        //
        // Check that there is a block for multicast in the info,
        // and insert the default block if none is found.
        //

        if ( !MprInfoBlockExists(Header, IP_INTERFACE_STATUS_INFO) )
        {
            dwErr =
                MprInfoBlockAdd(
                    Header,
                    IP_INTERFACE_STATUS_INFO,
                    sizeof(INTERFACE_STATUS_INFO),
                    1,
                    g_pIpIfStatusDefault,
                    (VOID**)NewHeader
                    );     
            if (dwErr) { break; }

            MprInfoDelete(Header); Header = *NewHeader;
        }
    
    
        //
        // Check that there is a block for router-discovery,
        // inserting the default block if none is found
        //

        if ( !MprInfoBlockExists(Header, IP_ROUTER_DISC_INFO) )
        {
            //
            // Select the default configuration which is appropriate
            // for the type of interface being configured (LAN/WAN)
            //

            BYTE *pDefault;
            pDefault =
                (dwIfType == ROUTER_IF_TYPE_DEDICATED)
                    ? g_pRtrDiscLanDefault
                    : g_pRtrDiscWanDefault;
    
            dwErr =
                MprInfoBlockAdd(
                    Header,
                    IP_ROUTER_DISC_INFO,
                    sizeof(RTR_DISC_INFO),
                    1,
                    pDefault,
                    (VOID**)NewHeader
                    );
            if (dwErr) { break; }

            MprInfoDelete(Header); Header = *NewHeader;
        }

        *NewHeader = Header;

    } while(FALSE);

    if (dwErr) { MprInfoDelete(Header); *NewHeader = NULL; }

    return dwErr;
}

/*!--------------------------------------------------------------------------
    AddIpxPerInterfaceBlocks
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIpxPerInterfaceBlocks(IInterfaceInfo *pIf, IInfoBase *pInfoBase)
{
    HRESULT     hr = hrOK;
#ifdef DEBUG
    InfoBlock * pTestBlock;
#endif
    
    //
    // Check that there is a block for interface-status in the info,
    // and insert the default block if none is found.
    //
    if (pInfoBase->BlockExists(IPX_INTERFACE_INFO_TYPE) == hrFalse)
    {
        IPX_IF_INFO     ipx;

        ipx.AdminState = ADMIN_STATE_ENABLED;
        ipx.NetbiosAccept = ADMIN_STATE_DISABLED;
        ipx.NetbiosDeliver = ADMIN_STATE_DISABLED;
        CORg( pInfoBase->AddBlock(IPX_INTERFACE_INFO_TYPE,
                                   sizeof(ipx),
                                   (PBYTE) &ipx,
                                   1 /* count */,
                                   FALSE /* bRemoveFirst */) );
        Assert( pInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE,
                &pTestBlock, 0) == hrOK);
    }

    //
    // Check that there is a block for WAN interface-status in the info,
    // and insert the default block if none is found.
    //
    if (pInfoBase->BlockExists(IPXWAN_INTERFACE_INFO_TYPE) == hrFalse)
    {
        IPXWAN_IF_INFO      ipxwan;

        ipxwan.AdminState = ADMIN_STATE_DISABLED;
        CORg( pInfoBase->AddBlock(IPXWAN_INTERFACE_INFO_TYPE,
                                   sizeof(ipxwan),
                                   (PBYTE) &ipxwan,
                                   1 /* count */,
                                   FALSE /* bRemoveFirst */) );
        
        Assert( pInfoBase->GetBlock(IPXWAN_INTERFACE_INFO_TYPE,
                &pTestBlock, 0) == hrOK);
    }

    // HACK! HACK!
    // For IPX we have to add the RIP/SAP info blocks otherwise
    // adding IPX to the interface will fail
    // ----------------------------------------------------------------
    if (!FHrOK(pInfoBase->BlockExists(IPX_PROTOCOL_RIP)))
    {
        // Add a RIP_IF_CONFIG block
        BYTE *  pDefault;
        
        if (pIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
            pDefault = g_pIpxRipLanInterfaceDefault;
        else
            pDefault = g_pIpxRipInterfaceDefault;
        pInfoBase->AddBlock(IPX_PROTOCOL_RIP,
                            sizeof(RIP_IF_CONFIG),
                            pDefault,
                            1,
                            0);
        
    }

    if (!FHrOK(pInfoBase->BlockExists(IPX_PROTOCOL_SAP)))
    {
        // Add a SAP_IF_CONFIG block
        BYTE *  pDefault;
        
        if (pIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
            pDefault = g_pIpxSapLanInterfaceDefault;
        else
            pDefault = g_pIpxSapInterfaceDefault;
        
        pInfoBase->AddBlock(IPX_PROTOCOL_SAP,
                            sizeof(SAP_IF_CONFIG),
                            pDefault,
                            1,
                            0);
        
    }


    
Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    UpdateLanaMapForDialinClients
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT UpdateLanaMapForDialinClients(LPCTSTR pszServerName, DWORD dwAllowNetworkAccess)
{
    HRESULT     hr = hrOK;
    DWORD       dwErr;
    RegKey      regkeyNetBIOS;
    CStringList rgstBindList;
    CByteArray  rgLanaMap;
    int         i, cEntries;
    UINT        cchNdisWanNbfIn;
    POSITION    pos;
    CString     st;
    BYTE        bValue;
    
    // Get to the NetBIOS key
    // ----------------------------------------------------------------
    dwErr = regkeyNetBIOS.Open(HKEY_LOCAL_MACHINE,
                               c_szRegKeyNetBIOSLinkage,
                               KEY_ALL_ACCESS,
                               pszServerName);
    if (dwErr != ERROR_SUCCESS)
    {
        // Setup the registry error
        // ------------------------------------------------------------
        SetRegError(0, HResultFromWin32(dwErr),
                    IDS_ERR_REG_OPEN_CALL_FAILED,
                    c_szHKLM, c_szRegKeyNetBIOSLinkage, NULL);
        goto Error;
    }

    // Get the BIND key (this is a multivalued string)
    // ----------------------------------------------------------------
    dwErr = regkeyNetBIOS.QueryValue(c_szBind, rgstBindList);
    if (dwErr != ERROR_SUCCESS)
    {
        SetRegError(0, HResultFromWin32(dwErr),
                    IDS_ERR_REG_QUERYVALUE_CALL_FAILED,
                    c_szHKLM, c_szRegKeyNetBIOSLinkage, c_szBind, NULL);
        goto Error;
    }

    // Get the LanaMap key (this is a byte array)
    // ----------------------------------------------------------------
    dwErr = regkeyNetBIOS.QueryValue(c_szRegValLanaMap, rgLanaMap);
    if (dwErr != ERROR_SUCCESS)
    {
        SetRegError(0, HResultFromWin32(dwErr),
                    IDS_ERR_REG_QUERYVALUE_CALL_FAILED,
                    c_szHKLM, c_szRegKeyNetBIOSLinkage, c_szRegValLanaMap, NULL);
        goto Error;
    }

    // Find the entries that prefix match the "Nbf_NdisWanNbfIn" string.
    // Set the corresponding entries in the LanaMap key to
    // 0 or 1 (entry value = !dwAllowNetworkAccess).
    // ----------------------------------------------------------------
    cEntries = rgstBindList.GetCount();
    pos = rgstBindList.GetHeadPosition();
    cchNdisWanNbfIn = StrLen(c_szDeviceNbfNdisWanNbfIn);
    
    for (i=0; i<cEntries; i++)
    {
        st = rgstBindList.GetNext(pos);
        if (st.IsEmpty())
            continue;

        if (StrnCmp((LPCTSTR) st, c_szDeviceNbfNdisWanNbfIn, cchNdisWanNbfIn) == 0)
        {
            // Set the appropriate bit in the byte array
            // --------------------------------------------------------

            // We set the value to the opposite of dwAllowNetworkAccess
            // --------------------------------------------------------
            bValue = (dwAllowNetworkAccess ? 0 : 1);
            rgLanaMap.SetAt(2*i, bValue);
        }
    }

    // Write the info back out to the LanaMap key
    // ----------------------------------------------------------------
    dwErr = regkeyNetBIOS.SetValue(c_szRegValLanaMap, rgLanaMap);
    if (dwErr != ERROR_SUCCESS)
    {
        SetRegError(0, HResultFromWin32(dwErr),
                    IDS_ERR_REG_SETVALUE_CALL_FAILED,
                    c_szHKLM, c_szRegKeyNetBIOSLinkage, c_szRegValLanaMap, NULL);
        goto Error;
    }

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    HrIsProtocolSupported
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT HrIsProtocolSupported(LPCTSTR pszServerName,
                              LPCTSTR pszServiceKey,
                              LPCTSTR pszRasServiceKey,
                              LPCTSTR pszExtraKey)
{
    HRESULT     hr = hrFalse;
    HRESULT     hrTemp;
    DWORD       dwErr;
    RegKey      regkey;
    HKEY        hkeyMachine = NULL;

    COM_PROTECT_TRY
    {
        CWRg( ConnectRegistry(pszServerName, &hkeyMachine) );

        // Try to open both keys, if both succeed, then we
        // consider the protocol to be installed.
        // ------------------------------------------------------------
        dwErr = regkey.Open(hkeyMachine, pszServiceKey, KEY_READ);
        hrTemp = HResultFromWin32(dwErr);
        if (FHrOK(hrTemp))
        {
            regkey.Close();
            dwErr = regkey.Open(hkeyMachine, pszRasServiceKey, KEY_READ);
            hrTemp = HResultFromWin32(dwErr);

            // If pszExtraKey == NULL, then there is no extra key
            // for us to test.
            if (FHrOK(hrTemp) && pszExtraKey)
            {
                regkey.Close();
                dwErr = regkey.Open(hkeyMachine, pszExtraKey, KEY_READ);
                hrTemp = HResultFromWin32(dwErr);
            }
        }

        // Both keys succeeded, so return hrOK
        // ------------------------------------------------------------
        if (FHrOK(hrTemp))
            hr = hrOK;
        else
            hr = hrFalse;

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);

    return hr;
    
}


/*!--------------------------------------------------------------------------
    RegisterRouterInDomain
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RegisterRouterInDomain(LPCTSTR pszRouterName, BOOL fRegister)
{
    DOMAIN_CONTROLLER_INFO * pDcInfo = NULL;
    HRESULT                 hr = hrOK;
    HRESULT                 hrT = hrOK;

    // If this fails, we assume this is standalone.
    hrT = HrIsStandaloneServer(pszRouterName);
    if (hrT == S_FALSE)
    {

        CWRg( DsGetDcName(pszRouterName, NULL, NULL, NULL, 0, &pDcInfo) );
        
        CWRg( MprDomainRegisterRasServer(pDcInfo->DomainName,
                                         (LPTSTR) pszRouterName,
                                         fRegister) );
    }
    
Error:
    if (pDcInfo)
        NetApiBufferFree(pDcInfo);
    return hr;
}
       
       


/*!--------------------------------------------------------------------------
    SetDeviceType
        For the given machine, this API will set the ports for this
        machine accordingly (given the dwRouterType).

        If dwTotalPorts is non-zero, then the max ports for L2TP/PPTP
        will be adjusted (each will get 1/2 of dwTotalPorts).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetDeviceType(LPCTSTR pszMachineName,
                      DWORD dwRouterType,
                      DWORD dwTotalPorts)
{
    PortsDataEntry      portsDataEntry;
    PortsDeviceList     portsList;
    PortsDeviceEntry *  pEntry = NULL;
    HRESULT             hr = hrOK;
    POSITION            pos;

    CORg( portsDataEntry.Initialize(pszMachineName) );

    CORg( portsDataEntry.LoadDevices( &portsList ) );

    CORg( SetDeviceTypeEx( &portsList, dwRouterType ) );

    if (dwTotalPorts)
    {
        // Set the port sizes for L2TP and PPTP
        CORg( SetPortSize(&portsList, dwTotalPorts/2) );
    }

    // Save the data back
    // ----------------------------------------------------------------
    CORg( portsDataEntry.SaveDevices( &portsList ) );

Error:
    // Clear out the ports list, we don't need the data anymore
    // ----------------------------------------------------------------
    while (!portsList.IsEmpty())
        delete portsList.RemoveHead();
    
    return hr;
}


/*!--------------------------------------------------------------------------
    SetPortSize
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetPortSize(PortsDeviceList *pDeviceList, DWORD dwPorts)
{
    HRESULT     hr = hrOK;
    POSITION    pos;
    PortsDeviceEntry *  pEntry = NULL;

    pos = pDeviceList->GetHeadPosition();
    while (pos)
    {
        pEntry = pDeviceList->GetNext(pos);
        
        if ((RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_Pptp) ||
            (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Tunnel_L2tp))
        {
            pEntry->m_fModified = TRUE;
            pEntry->m_dwPorts = dwPorts;
        }
    }
    
    return hr;
}


/*!--------------------------------------------------------------------------
    SetDeviceTypeEx
        This is the core of the function above.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetDeviceTypeEx(PortsDeviceList *pDeviceList,
                        DWORD dwRouterType)
{
    PortsDeviceEntry *  pEntry = NULL;
    HRESULT             hr = hrOK;
    POSITION            pos;

    Assert(pDeviceList);
    Assert(dwRouterType);

    // Ok now we go through and set the type of all of the devices
    // ----------------------------------------------------------------

    pos = pDeviceList->GetHeadPosition();

    while (pos)
    {
        pEntry = pDeviceList->GetNext(pos);

        // If we have enabled routing and if this port did not
        // have routing enabled, enable routing.
        // ------------------------------------------------------------
        if ((dwRouterType & (ROUTER_TYPE_LAN | ROUTER_TYPE_WAN)))
        {
            if (!pEntry->m_dwEnableRouting)
            {
                pEntry->m_dwEnableRouting = TRUE;
                pEntry->m_fModified = TRUE;
            }
        }
        else
        {
            // If this port does NOT have routing enabled
            // and routing is enabled, disable it.
            // --------------------------------------------------------
            if (pEntry->m_dwEnableRouting)
            {
                pEntry->m_dwEnableRouting = FALSE;
                pEntry->m_fModified = TRUE;
            }
        }

        // Windows NT Bug : 292615
        // If this is a parallel port, do not enable RAS.
        // ------------------------------------------------------------
        if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_Parallel)
        {
            if (pEntry->m_dwEnableRas)
            {
                pEntry->m_dwEnableRas = FALSE;
                pEntry->m_fModified = TRUE;
            }
            continue;
        }

        //
        // For PPPoE devices disable Ras and Routing.  Only outbound 
        // routing can be set for PPPoE devices

        if (RAS_DEVICE_TYPE(pEntry->m_eDeviceType) == RDT_PPPoE)
        {
            if (pEntry->m_dwEnableRas)
            {
                pEntry->m_dwEnableRas = FALSE;
                pEntry->m_fModified = TRUE;
            }

            if (pEntry->m_dwEnableRouting)
            {
                pEntry->m_dwEnableRouting = FALSE;
                pEntry->m_fModified = TRUE;
            }

            //
            // Enable outbound routing if this is a router
            //

            if (dwRouterType & (ROUTER_TYPE_WAN | ROUTER_TYPE_RAS))
            {
                if (!pEntry->m_dwEnableOutboundRouting)
                {
                    pEntry->m_dwEnableOutboundRouting = TRUE;
                    pEntry->m_fModified = TRUE;
                }
            }
            
            continue;
        }

        
        // Similarly for RAS
        // ------------------------------------------------------------
        if (dwRouterType & ROUTER_TYPE_RAS)
        {
            if (!pEntry->m_dwEnableRas)
            {
                pEntry->m_dwEnableRas = TRUE;
                pEntry->m_fModified = TRUE;
            }
        }        
        else
        {
            if (pEntry->m_dwEnableRas)
            {
                pEntry->m_dwEnableRas = FALSE;
                pEntry->m_fModified = TRUE;
            }
        }
    }


    return hr;
}


HRESULT SetRouterInstallRegistrySettings(LPCWSTR pswzServer,
                                         BOOL fInstall,
                                         BOOL fChangeEnableRouter)
{
    HRESULT     hr = hrOK;
    HKEY        hklm = NULL;

    CWRg( ConnectRegistry(pswzServer, &hklm) );

    // Write out the global registry settings
    CORg( SetGlobalRegistrySettings(hklm, fInstall, fChangeEnableRouter) );

    // Write the per-interface registry settings
    CORg( SetPerInterfaceRegistrySettings(hklm, fInstall) );

Error:

    if (hklm)
    {
        DisconnectRegistry(hklm);
        hklm = NULL;
    }

    return hr;
}



static CString  s_PortDeviceTypeModem;
static CString  s_PortDeviceTypeX25;
static CString  s_PortDeviceTypeIsdn;
static CString  s_PortDeviceTypeSerial;
static CString  s_PortDeviceTypeFrameRelay;
static CString  s_PortDeviceTypeAtm;
static CString  s_PortDeviceTypeSonet;
static CString  s_PortDeviceTypeSw56;
static CString  s_PortDeviceTypePptp;
static CString  s_PortDeviceTypeL2tp;
static CString  s_PortDeviceTypeIrda;
static CString  s_PortDeviceTypeParallel;
static CString  s_PortDeviceTypePPPoE;
static CString  s_PortDeviceTypeOther;

static const CStringMapEntry    s_PortTypeMap[] =
{
    { RDT_Modem,        &s_PortDeviceTypeModem,         IDS_PORTSDLG_DEVTYPE_MODEM },
    { RDT_X25,          &s_PortDeviceTypeX25,           IDS_PORTSDLG_DEVTYPE_X25 },
    { RDT_Isdn,         &s_PortDeviceTypeIsdn,          IDS_PORTSDLG_DEVTYPE_ISDN },
    { RDT_Serial,       &s_PortDeviceTypeSerial,        IDS_PORTSDLG_DEVTYPE_SERIAL },
    { RDT_FrameRelay,   &s_PortDeviceTypeFrameRelay,    IDS_PORTSDLG_DEVTYPE_FRAMERELAY },
    { RDT_Atm,          &s_PortDeviceTypeAtm,           IDS_PORTSDLG_DEVTYPE_ATM },
    { RDT_Sonet,        &s_PortDeviceTypeSonet,         IDS_PORTSDLG_DEVTYPE_SONET },
    { RDT_Sw56,         &s_PortDeviceTypeSw56,          IDS_PORTSDLG_DEVTYPE_SW56 },
    { RDT_Tunnel_Pptp,  &s_PortDeviceTypePptp,          IDS_PORTSDLG_DEVTYPE_PPTP },
    { RDT_Tunnel_L2tp,  &s_PortDeviceTypeL2tp,          IDS_PORTSDLG_DEVTYPE_L2TP },
    { RDT_Irda,         &s_PortDeviceTypeIrda,          IDS_PORTSDLG_DEVTYPE_IRDA },
    { RDT_Parallel,     &s_PortDeviceTypeParallel,      IDS_PORTSDLG_DEVTYPE_PARALLEL },
    { RDT_PPPoE,        &s_PortDeviceTypePPPoE,         IDS_PORTSDLG_DEVTYPE_PPPOE },
    { RDT_Other,        &s_PortDeviceTypeOther,         IDS_PORTSDLG_DEVTYPE_OTHER },
    { -1,               &s_PortUnknown,                 IDS_PORT_UNKNOWN },
};

/*!--------------------------------------------------------------------------
    PortTypeToCString
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
CString&    PortTypeToCString(DWORD dwPortType)
{
    // Make sure that the class info has been "stripped" from the port
    // type mask.
    DWORD dw = static_cast<DWORD>(RAS_DEVICE_TYPE(dwPortType));

    // For now, if we don't know what the type is we'll default to "Other"
    // as an answer. FUTURE: Someone may want to change this in the future.
    if (dw > RDT_Other)
        dw = RDT_Other;

    return MapDWORDToCString(dwPortType, s_PortTypeMap);
}



/*---------------------------------------------------------------------------
    CWaitForRemoteAccessDlg implementation
 ---------------------------------------------------------------------------*/
CWaitForRemoteAccessDlg::CWaitForRemoteAccessDlg(LPCTSTR pszServerName,
    LPCTSTR pszText, LPCTSTR pszTitle, CWnd *pParent)
    : CWaitDlg(pszServerName, pszText, pszTitle, pParent)
{
}
    
void CWaitForRemoteAccessDlg::OnTimerTick()
{
    HRESULT     hr = hrOK;
    DWORD       dwErrorCode = ERROR_SUCCESS;
    
    // Windows NT Bug : 266364
    // 266364 - If we got this far we assume that the service has
    // already started, but it may then exit out after that point (due
    // to some other configuration error).  So we need to check to see
    // if the service is running.
    hr = IsRouterServiceRunning(m_strServerName, &dwErrorCode);
    if (FHrOK(hr))
    {
        if (MprAdminIsServiceRunning(T2W((LPTSTR)(LPCTSTR) m_strServerName)) == TRUE)
            CDialog::OnOK();
        
        // If the service is running, but MprAdmin is not finished yet,
        // party on.        
    }
    else
    {
        // Stop the timer
        CloseTimer();
        
        CDialog::OnOK();

        // Ensure that an error info was created
        CreateTFSErrorInfo(NULL);

        // The service is not running.  We can exit out of this dialog.
        // An error may have occurred, if we have the error code, report
        // the error.
        if (dwErrorCode != ERROR_SUCCESS)
        {
            TCHAR   szBuffer[2048];
            
            AddHighLevelErrorStringId(IDS_ERR_SERVICE_FAILED_TO_START);

            FormatSystemError(dwErrorCode,
                              szBuffer,
                              DimensionOf(szBuffer),
                              0,
                              FSEFLAG_SYSMESSAGE | FSEFLAG_MPRMESSAGE);
            FillTFSError(0, HResultFromWin32(dwErrorCode), FILLTFSERR_LOW,
                         0, szBuffer, 0);

            DisplayTFSErrorMessage(GetSafeHwnd());
        }
        else
        {
            AddHighLevelErrorStringId(IDS_ERR_SERVICE_FAILED_TO_START_UNKNOWN);
        }
        
    }
    
}


/////////////////////////////////////////////////////////////////////////////
// CRestartRouterDlg dialog

CRestartRouterDlg::CRestartRouterDlg
(
    LPCTSTR         pszServerName,
    LPCTSTR         pszText,
    LPCTSTR         pszTitle,
    CTime*          pTimeStart,
    CWnd*           pParent /*= NULL*/
)
    : CWaitDlg(pszServerName, pszText, pszTitle, pParent)
{
    m_pTimeStart = pTimeStart;
    m_dwTimeElapsed = 0;
    m_fTimeOut = FALSE;
    m_dwError = NO_ERROR;
}

void CRestartRouterDlg::OnTimerTick()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dwTimeElapsed++;
    if (!(m_dwTimeElapsed % TIMEOUT_POLL))
    {
        HRESULT     hr = hrOK;
        DWORD       dwError = NO_ERROR;
        DWORD        dwServiceStatus = 0;
        BOOL        fFinished = FALSE;

        hr = GetRouterServiceStatus((LPCTSTR)m_strServerName, &dwServiceStatus, &dwError);

        if (FHrSucceeded(hr) && SERVICE_RUNNING == dwServiceStatus)
        {
            USES_CONVERSION;
            if (MprAdminIsServiceRunning(T2W((LPTSTR)((LPCTSTR)m_strServerName))))
            {
                DWORD dwUpTime;
                dwError = GetRouterUpTime(m_strServerName, &dwUpTime);
        
                if (NO_ERROR == dwError && 
                    dwUpTime <= (DWORD) ((CTime::GetCurrentTime() - *m_pTimeStart).GetTotalSeconds()))
                {
                    CDialog::OnOK();
                    fFinished = TRUE;
                    m_fTimeOut = FALSE;
                }
            }
        }

        if (NO_ERROR != dwError)
        {
            CDialog::OnOK();
            m_dwError = dwError;
        }

//NTBUG: ID=249775.  The behavior of this dialog has to be same as the start 
//                   dialog.  So, timeout feature is disabled.
/*
        //if the waiting time has been longer to 60 seconds, we assume someting is wrong
        else if (!fFinished && 
                (CTime::GetCurrentTime() - *m_pTimeStart).GetTotalSeconds() > MAX_WAIT_RESTART)
        {
            CDialog::OnOK();
            m_fTimeOut = TRUE;
        }
*/
    }
}



TFSCORE_API(HRESULT) PauseRouterService(LPCWSTR pszMachine)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    CString     stServiceDesc;
    DWORD       dwErr;

    COM_PROTECT_TRY
    {

        // Load the description for the SAP Agent
        stServiceDesc.LoadString(IDS_SAPAGENT_SERVICE_DESC);
        
        // Pause the SAP Agent
        // ------------------------------------------------------------
        dwErr = TFSPauseService(pszMachine,
                                c_szNWSAPAgent,
                                stServiceDesc);
        if ((dwErr == ERROR_SERVICE_NOT_ACTIVE) ||
            (dwErr == ERROR_SERVICE_DOES_NOT_EXIST))
            hr = hrOK;
        else
            CWRg( dwErr );

        
        // Load the description for the router
        // ------------------------------------------------------------
        stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);

        
        // Pause the router service
        // ------------------------------------------------------------
        dwErr = TFSPauseService(pszMachine,
                               c_szRouter,
                               stServiceDesc);
        if ((dwErr == ERROR_SERVICE_NOT_ACTIVE) ||
            (dwErr == ERROR_SERVICE_DOES_NOT_EXIST))
            hr = hrOK;
        else
            CWRg( dwErr );

        
        // Pause the RemoteAccess service
        // ------------------------------------------------------------
        dwErr = TFSPauseService(pszMachine,
                               c_szRemoteAccess,
                               stServiceDesc);
        if ((dwErr == ERROR_SERVICE_NOT_ACTIVE) ||
            (dwErr == ERROR_SERVICE_DOES_NOT_EXIST))
            hr = hrOK;
        else
            CWRg( dwErr );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}

TFSCORE_API(HRESULT) ResumeRouterService(LPCWSTR pszMachine)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    CString     stServiceDesc;
    DWORD       dwErr;

    COM_PROTECT_TRY
    {

        // Load the description for the SAP Agent
        stServiceDesc.LoadString(IDS_SAPAGENT_SERVICE_DESC);
        
        // Resume the SAP Agent
        // ------------------------------------------------------------
        dwErr = TFSResumeService(pszMachine,
                               c_szNWSAPAgent,
                               stServiceDesc);
        if (dwErr == ERROR_SERVICE_NOT_ACTIVE)
            hr = hrOK;
        else
            hr = HResultFromWin32(dwErr);

        
        // Load the description for the router
        // ------------------------------------------------------------
        stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
        
        // Resume the router service
        // ------------------------------------------------------------
        dwErr = TFSResumeService(pszMachine,
                               c_szRouter,
                               stServiceDesc);
        if (dwErr == ERROR_SERVICE_NOT_ACTIVE)
            hr = hrOK;
        else
            hr = HResultFromWin32(dwErr);

        
        // Resume the RemoteAccess service
        // ------------------------------------------------------------
        dwErr = TFSResumeService(pszMachine,
                               c_szRemoteAccess,
                               stServiceDesc);
        if (dwErr == ERROR_SERVICE_NOT_ACTIVE)
            hr = hrOK;
        else
            hr = HResultFromWin32(dwErr);
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*---------------------------------------------------------------------------
    CNetConnection
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Class : CNetConnection

    This class maintains a list of net connections (those connected using
    WNetAddConnection2).

    When told, it will release all of its connections.
 ---------------------------------------------------------------------------*/

class CNetConnection
{
public:
    CNetConnection();
    ~CNetConnection();

    HRESULT Add(LPCTSTR pszConnection);
    HRESULT RemoveAll();
    HRESULT Remove(LPCTSTR pszConnection);
    
private:
    CStringList     m_listConnections;
};



CNetConnection::CNetConnection()
{
}

CNetConnection::~CNetConnection()
{
    RemoveAll();
}

HRESULT CNetConnection::Add(LPCTSTR pszConnection)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_listConnections.AddTail(pszConnection);
    }
    COM_PROTECT_CATCH;

    return hr;
}
HRESULT CNetConnection::Remove(LPCTSTR pszConnection)
{
    HRESULT hr = hrOK;
    POSITION p;
    COM_PROTECT_TRY
    {
        p = m_listConnections.Find(pszConnection);
        if ( p )
        {
            m_listConnections.RemoveAt(p);
            WNetCancelConnection2(pszConnection,
                               0 /* dwFlags */,
                                 TRUE /* fForce */);
        }
    }
    COM_PROTECT_CATCH;
    return hr;
}
HRESULT CNetConnection::RemoveAll()
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        while (!m_listConnections.IsEmpty())
        {
            CString st;

            st = m_listConnections.RemoveHead();
            WNetCancelConnection2((LPCTSTR) st,
                                  0 /* dwFlags */,
                                  TRUE /* fForce */);
        }
    }
    COM_PROTECT_CATCH;

    return hr;    
}


// Global functions to add/remove net connections
// --------------------------------------------------------------------
static CNetConnection   g_NetConnections;

HRESULT AddNetConnection(LPCTSTR pszConnection)
{
    return g_NetConnections.Add(pszConnection);
}

HRESULT RemoveAllNetConnections()
{
    return g_NetConnections.RemoveAll();
}

HRESULT RemoveNetConnection(LPCTSTR szServerName)
{
    //Make the connection name
   CString stIPCShare;
   CString stRouterName = szServerName;
   if ( stRouterName.Left(2) != TEXT( "\\\\" ) )
   {
    stIPCShare = TEXT( "\\\\" );
   }

   stIPCShare += stRouterName;
   stIPCShare += TEXT( "\\" );
   stIPCShare += c_szIPCShare; 
   return g_NetConnections.Remove(stIPCShare);
}

/*!--------------------------------------------------------------------------
    RefreshMprConfig
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RefreshMprConfig(LPCTSTR pszServerName)
{
    HRESULT hr = hrOK;
    SPMprConfigHandle    sphConfig;

    CWRg( ::MprConfigServerConnect((LPWSTR) pszServerName,
                                   &sphConfig) );

    MprConfigServerRefresh(sphConfig);

Error:
    return hr;
}

HRESULT WINAPI
IsWindows64Bit(    LPCWSTR pwszMachine, 
                LPCWSTR pwszUserName,
                LPCWSTR pwszPassword,
                LPCWSTR pwszDomain,
                BOOL * pf64Bit)
{
    HRESULT                            hr = S_OK;    
    RouterVersionInfo                routerVersion;
    IWbemLocator *                    pIWbemLocator = NULL;
    IWbemServices *                    pIWbemServices = NULL;
    SEC_WINNT_AUTH_IDENTITY_W        stAuthIdentity;
    HKEY                            hkeyMachine = NULL;
    *pf64Bit = FALSE;

    //Check to see if the version is <= 2195.  If yes then there is no 64 bit there...

    if (ERROR_SUCCESS == ConnectRegistry(pwszMachine, &hkeyMachine))
        QueryRouterVersionInfo(hkeyMachine, &routerVersion);
    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);
    
    if ( routerVersion.dwOsBuildNo <= RASMAN_PPP_KEY_LAST_WIN2k_VERSION )
    {
        return hr;
    }
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr) && (RPC_E_CHANGED_MODE != hr))
    {
        return hr;
    }
    // Create an instance of the WbemLocator interface.

    hr = CoCreateInstance(    CLSID_WbemLocator,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (LPVOID *) &pIWbemLocator
                         );


    if (hrOK != hr)
    {
        return hr;
    }

    // Using the locator, connect to CIMOM in the given namespace.
    BSTR    pNamespace;
    WCHAR    szPath[MAX_PATH];
    WCHAR    szTemp[MAX_PATH];
    BSTR    bstrUserName = NULL, bstrPassword = NULL, bstrDomain = NULL;
    if ( pwszUserName )
    {
         bstrUserName = SysAllocString(pwszUserName);
         if ( pwszPassword )
             bstrPassword = SysAllocString(pwszPassword);
         if ( pwszDomain )
         {
             wsprintf ( szTemp, L"NTLMDOMAIN:%s", pwszDomain );
             bstrDomain = SysAllocString(szTemp);
         }
    }
    
    
    wsprintf(szPath, L"\\\\%s\\root\\cimv2", (!pwszMachine || (pwszMachine[0] ==0)) ? L"." : pwszMachine);
    pNamespace = SysAllocString(szPath);

    hr = pIWbemLocator->ConnectServer(    pNamespace,
                                        (pwszUserName?bstrUserName:NULL), //UserName
                                        (pwszPassword?bstrPassword:NULL), //Password
                                        0L,        // locale
                                        0L,        // securityFlags
                                        ( pwszDomain?bstrDomain:NULL),    // authority (domain for NTLM)                                        
                                        NULL,    // context
                                        &pIWbemServices); 
    if (SUCCEEDED(hr))
    {
       if ( pwszUserName )
       {
            ::SecureZeroMemory ( &stAuthIdentity, sizeof(stAuthIdentity));
            stAuthIdentity.User = (LPWSTR)pwszUserName;
            stAuthIdentity.UserLength = lstrlenW(pwszUserName );

            stAuthIdentity.Password = (LPWSTR)pwszPassword;
            stAuthIdentity.PasswordLength = lstrlenW( pwszPassword );

            if ( pwszDomain )
            {
                stAuthIdentity.Domain = (LPWSTR)pwszDomain;
                stAuthIdentity.DomainLength = lstrlenW(pwszDomain);
            }
            stAuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;


       }
       hr = CoSetProxyBlanket(pIWbemServices,
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE,
                               NULL,
                               RPC_C_AUTHN_LEVEL_CALL,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               (pwszUserName?&stAuthIdentity:NULL),
                               EOAC_NONE);

        if (SUCCEEDED(hr))
        {

            IEnumWbemClassObject *    pEnum = NULL;
            BSTR                    bstrWQL  = SysAllocString(L"WQL");
            VARIANT                    varArchitecture;
            BSTR                    bstrPath;

            bstrPath = SysAllocString(L"select * from Win32_Processor");
       
            hr = pIWbemServices->ExecQuery(bstrWQL, bstrPath, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);
            if (SUCCEEDED(hr))
            {
                hr = CoSetProxyBlanket(pEnum,
                                       RPC_C_AUTHN_WINNT,
                                       RPC_C_AUTHZ_NONE,
                                       NULL,
                                       RPC_C_AUTHN_LEVEL_CALL,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       (pwszUserName?&stAuthIdentity:NULL),
                                       EOAC_NONE);
                if ( SUCCEEDED(hr) )
                {
                    IWbemClassObject *pNSClass;
                    ULONG uReturned;
                    pEnum->Next(WBEM_INFINITE, 1, &pNSClass, &uReturned );
                    if (SUCCEEDED(hr))
                    {
                        if (uReturned)
                        {
                            CIMTYPE ctpeType;
                            hr = pNSClass->Get(L"Architecture", NULL, &varArchitecture, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                VariantChangeType(&varArchitecture, &varArchitecture, 0, VT_UINT);
                                if ( varArchitecture.uintVal == 6 )        //64 bit
                                {
                                    *pf64Bit = TRUE;
                                }
                            }
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                        pNSClass->Release();
                    }
                }
                pEnum->Release();
            }
            SysFreeString(bstrPath);
        
            SysFreeString(bstrWQL);
            pIWbemServices->Release();
        }
        pIWbemLocator->Release();
        if ( bstrUserName ) SysFreeString(bstrUserName);
        if ( bstrPassword ) SysFreeString(bstrPassword);
        if ( bstrDomain ) SysFreeString(bstrDomain);
    }
    SysFreeString(pNamespace);

    CoUninitialize();
    
    // Translate any WMI errors into Win32 errors:
    switch (hr)
    {
        case WBEM_E_NOT_FOUND:
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            break;

        case WBEM_E_ACCESS_DENIED:
            hr = E_ACCESSDENIED;
            break;

        case WBEM_E_PROVIDER_FAILURE:
            hr = E_FAIL;
            break;

        case WBEM_E_TYPE_MISMATCH:
        case WBEM_E_INVALID_CONTEXT:
        case WBEM_E_INVALID_PARAMETER:
            hr = E_INVALIDARG;
            break;

        case WBEM_E_OUT_OF_MEMORY:
            hr = E_OUTOFMEMORY;
            break;

    }
    
    return hr;

}

HRESULT WINAPI TransferCredentials ( IRouterInfo  * pRISource, 
                                     IRouterInfo  * pRIDest
                                   )
{
    HRESULT                    hr = S_OK;
    SPIRouterAdminAccess    spAdminSrc;
    SPIRouterAdminAccess    spAdminDest;
    SPIRouterInfo            spRISource;
    SPIRouterInfo            spRIDest;
    PBYTE                    pbPassword = NULL;
    int                        nPasswordLen = 0;

    COM_PROTECT_TRY
    {
        spRISource.Set(pRISource);
        spRIDest.Set(pRIDest);
        spAdminSrc.HrQuery(spRISource);
        spAdminDest.HrQuery(spRIDest);
        if (spAdminSrc && spAdminSrc->IsAdminInfoSet() && spAdminDest)
        {
            spAdminSrc->GetUserPassword(NULL, &nPasswordLen );

            pbPassword = (PBYTE) new BYTE [nPasswordLen];
            spAdminSrc->GetUserPassword( pbPassword, &nPasswordLen  );
            
            spAdminDest->SetInfo( spAdminSrc->GetUserName(), 
                                    spAdminSrc->GetDomainName(),
                                    pbPassword,
                                    nPasswordLen
                                  );
            delete pbPassword;
        }
    }
    COM_PROTECT_CATCH;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\rtrwiz.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   rtrwiz.cpp
      Router & Remote access configuration wizard

   FILE HISTORY:

*/

#include "stdafx.h"
#include "rtrwiz.h"
#include "rtrutilp.h"
#include "rtrcomn.h"    // CoCreateRouterConfig
#include "rrasutil.h"
#include "rtutils.h"        // Tracing functions
#include "helper.h"     // HrIsStandaloneServer
#include "infoi.h"      // SRtrMgrProtocolCBList
#include "routprot.h"   // MS_IP_XXXX
#include "snaputil.h"
#include "globals.h"
#include "rraswiz.h"
#include "iprtrmib.h"   // MIB_IPFORWARDROW


// Include headers for IP-specific stuff
extern "C"
{
#include <ipnat.h>
#include <ipnathlp.h>
#include <sainfo.h>
};



#include "igmprm.h"
#include "ipbootp.h"



#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



HRESULT AddIGMPToInterface(IInterfaceInfo *pIf, BOOL fRouter);
HRESULT AddIPBOOTPToInterface(IInterfaceInfo *pIf);
HRESULT AddNATSimpleServers(NewRtrWizData *pNewRtrWizData,
                            RtrConfigData *pRtrConfigData);
HRESULT AddNATToInterfaces(NewRtrWizData *pNewRtrWizData,
                           RtrConfigData *pRtrConfigData,
                           IRouterInfo *pRouter,
                           BOOL fCreateDD);
HRESULT AddNATToInterface(MPR_SERVER_HANDLE hMprServer,
                          HANDLE hMprConfig,
                          NewRtrWizData *pNewRtrWizData,
                          RtrConfigData *pRtrConfigData,
                          LPCTSTR pszInterface,
                          BOOL fDemandDial,
                          BOOL fPublic);
HRESULT AddDhcpServerToBOOTPGlobalInfo(LPCTSTR pszServerName,
                                       DWORD netDhcpServer);


/*---------------------------------------------------------------------------
    Defaults
 ---------------------------------------------------------------------------*/


//
// Default values for LAN-interface IGMP configuration
//
// NOTE: Any changes made here should also be made to ipsnap\globals.cpp
//
IGMP_MIB_IF_CONFIG g_IGMPLanDefault = {
    IGMP_VERSION_3,             //Version
    0,                          //IfIndex (readOnly)
    0,                          //IpAddr  (readOnly)
    IGMP_IF_NOT_RAS,            //IfType;
    IGMP_INTERFACE_ENABLED_IN_CONFIG, //Flags
    IGMP_ROUTER_V3,             //IgmpProtocolType;
    2,                          //RobustnessVariable;
    31,                         //StartupQueryInterval;
    2,                          //StartupQueryCount;
    125,                        //GenQueryInterval;
    10,                         //GenQueryMaxResponseTime;
    1000,                       //LastMemQueryInterval; (msec)
    2,                          //LastMemQueryCount;
    255,                        //OtherQuerierPresentInterval;
    260,                        //GroupMembershipTimeout;
    0                           //NumStaticGroups
};


//----------------------------------------------------------------------------
// DHCP Relay-agent default configuration
//
//----------------------------------------------------------------------------
//
// Default values for LAN-interface DHCP Relay-agent configuration
//

IPBOOTP_IF_CONFIG
g_relayLanDefault = {
    0,                                  // State (read-only)
    IPBOOTP_RELAY_ENABLED,              // Relay-mode
    4,                                  // Max hop-count
    4                                   // Min seconds-since-boot
};



/*!--------------------------------------------------------------------------
    RtrWizFinish
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RtrWizFinish(RtrConfigData* pRtrConfigData, IRouterInfo *pRouter)
{
    HRESULT                    hr = hrOK;
    LPCTSTR                    pszServerFlagsKey = NULL;
    LPCTSTR                    pszRouterTypeKey = NULL;
    RegKey                    rkey;
    RouterVersionInfo        routerVersion;
    HKEY                    hkeyMachine = NULL;
    CString                 stMachine, stPhonebookPath;


    // Connect to the remote machine's registry
    // ----------------------------------------------------------------
    CWRg( ConnectRegistry(pRtrConfigData->m_stServerName, &hkeyMachine) );


    QueryRouterVersionInfo(hkeyMachine, &routerVersion);

    if (routerVersion.dwOsBuildNo < RASMAN_PPP_KEY_LAST_VERSION)
        pszRouterTypeKey = c_szRegKeyRasProtocols;
    else
        pszRouterTypeKey = c_szRegKeyRemoteAccessParameters;

    // enable routing & RAS page
    // ----------------------------------------------------------------
    if ( ERROR_SUCCESS == rkey.Open(hkeyMachine, pszRouterTypeKey) )
    {
        rkey.SetValue( c_szRouterType,pRtrConfigData->m_dwRouterType);
    }

    // protocols page
    // ----------------------------------------------------------------

    // RAS routing
    // ----------------------------------------------------------------

    if ((pRtrConfigData->m_fUseIp) &&
        (pRtrConfigData->m_dwRouterType & (ROUTER_TYPE_RAS | ROUTER_TYPE_WAN)))
        pRtrConfigData->m_ipData.SaveToReg(pRouter, routerVersion);

    if ( pRtrConfigData->m_dwRouterType & ROUTER_TYPE_RAS )
    {
        if (pRtrConfigData->m_fUseIpx)
        {
            pRtrConfigData->m_ipxData.SaveToReg(pRouter);
        }

        if (pRtrConfigData->m_fUseNbf)
            pRtrConfigData->m_nbfData.SaveToReg();

        if (pRtrConfigData->m_fUseArap)
            pRtrConfigData->m_arapData.SaveToReg();
    }

    // Save the err log data
    pRtrConfigData->m_errlogData.SaveToReg();

    // Save the auth data
    pRtrConfigData->m_authData.SaveToReg(NULL);

    // Set some global registry settings (that need to get set,
    // independent of the router type).
    // ----------------------------------------------------------------
    InstallGlobalSettings(pRtrConfigData->m_stServerName, pRouter);


    // router only will start service and return
    // ----------------------------------------------------------------
    if ( !(pRtrConfigData->m_dwRouterType & (ROUTER_TYPE_RAS | ROUTER_TYPE_WAN)) )
    {
        // implies LAN routing; so start router & return
        // ------------------------------------------------------------
        goto EndConfig;
    }


    // security page
    // ----------------------------------------------------------------

    // Depending on the version depends on where we look for the
    // key.
    // ----------------------------------------------------------------
    if (routerVersion.dwOsBuildNo < RASMAN_PPP_KEY_LAST_VERSION)
        pszServerFlagsKey = c_szRasmanPPPKey;
    else
        pszServerFlagsKey = c_szRegKeyRemoteAccessParameters;

    if ( ERROR_SUCCESS == rkey.Open(HKEY_LOCAL_MACHINE,
                                    pszServerFlagsKey,
                                    KEY_ALL_ACCESS, pRtrConfigData->m_stServerName) )
    {
        DWORD       dwServerFlags = 0;

        // Windows NT Bug : 299456
        // Query for the server flags before overwriting it.  This way
        // we don't overwrite the old values.
        // ------------------------------------------------------------
        rkey.QueryValue( c_szServerFlags, dwServerFlags );

        // Add in the defaults (minus MSCHAP) for the PPP Settings.
        // ------------------------------------------------------------
        dwServerFlags |= (PPPCFG_UseSwCompression |
                          PPPCFG_UseLcpExtensions |
                          PPPCFG_NegotiateMultilink |
                          PPPCFG_NegotiateBacp);

        // Set the value
        // ------------------------------------------------------------
        rkey.SetValue( c_szServerFlags, dwServerFlags );
    }

    // Delete the router.pbk
    // ----------------------------------------------------------------
    DeleteRouterPhonebook( pRtrConfigData->m_stServerName );


EndConfig:

    WriteRouterConfiguredReg(pRtrConfigData->m_stServerName, TRUE);

    WriteRRASExtendsComputerManagementKey(pRtrConfigData->m_stServerName, TRUE);

    WriteErasePSKReg ( pRtrConfigData->m_stServerName, TRUE );
Error:

    if (hkeyMachine)
        DisconnectRegistry(hkeyMachine);

    return hr;
}



extern "C"
HRESULT APIENTRY MprConfigServerInstallPrivate( VOID )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD           dwErr = ERROR_SUCCESS;
    RtrConfigData   wizData;

    //
    // We removed this smart pointer definition as it was causing
    // a warning during build on alpha 32 bit.  Looks like the extern "C"
    // of the function definition is conflicting with the smart pointer.
    //
    // SPIRemoteNetworkConfig     spNetwork;
    IRemoteNetworkConfig *    pNetwork = NULL;
    IUnknown *                punk = NULL;
    CWaitCursor                wait;
    HRESULT                 hr = hrOK;

    // Create the remote config object
    // ----------------------------------------------------------------
    CORg( CoCreateRouterConfig(NULL,
                               NULL,
                               NULL,
                               IID_IRemoteNetworkConfig,
                               &punk) );

    pNetwork = (IRemoteNetworkConfig *) punk;
    punk = NULL;

    // Upgrade the configuration (ensure that the registry keys
    // are populated correctly).
    // ------------------------------------------------------------
    CORg( pNetwork->UpgradeRouterConfig() );


    wizData.m_stServerName.Empty();
    wizData.m_dwRouterType = (ROUTER_TYPE_RAS|ROUTER_TYPE_LAN|ROUTER_TYPE_WAN);

    // Need to get version information and initialize
    // the RAS structures (IP only)
    // Assume that this is on NT5
    wizData.m_fUseIp = TRUE;
    wizData.m_ipData.UseDefaults(_T(""), FALSE);
    wizData.m_ipData.m_dwAllowNetworkAccess = TRUE;

    wizData.m_authData.UseDefaults(NULL, FALSE);
    wizData.m_errlogData.UseDefaults(NULL, FALSE);

    dwErr = RtrWizFinish(&wizData, NULL);
    hr = HResultFromWin32(dwErr);

    SetDeviceType(NULL, wizData.m_dwRouterType, 10);

    RegisterRouterInDomain(NULL, TRUE);

Error:
    if (pNetwork)
        pNetwork->Release();

    return hr;
}



/*!--------------------------------------------------------------------------
    MprConfigServerUnattendedInstall
        Call this function to setup the registry entries for the server.
        This works only with the local machine for now.

        pswzServer - name of the server
        fInstall - TRUE if we are installing, FALSE if we are removing

    Author: KennT
 ---------------------------------------------------------------------------*/

extern "C"
HRESULT APIENTRY MprConfigServerUnattendedInstall(LPCWSTR pswzServer, BOOL fInstall)
{
    HRESULT        hr = hrOK;

#if 0    // remove this restriciton and see what happens
    // We only the local machine (for now).
    // ----------------------------------------------------------------
    if (pswzServer)
    {
        return HResultFromWin32( ERROR_INVALID_PARAMETER );
    }
#endif

    // Write out the various registry settings
    // ----------------------------------------------------------------
//    CORg( SetRouterInstallRegistrySettings(pswzServer, fInstall, TRUE) );


    // Write the "router is configured" flag
    // ----------------------------------------------------------------
    CORg( WriteRouterConfiguredReg(pswzServer, fInstall) );

    // Write out the RRAS extend Computer Management key
    CORg( WriteRRASExtendsComputerManagementKey(pswzServer, fInstall) );


    if (fInstall)
    {
        // Set the state of the router to Autostart
        // ------------------------------------------------------------
        SetRouterServiceStartType(pswzServer,
                                  SERVICE_AUTO_START);
    }

Error:

    return hr;
}



/*!--------------------------------------------------------------------------
    AddIGMPToRasServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIGMPToRasServer(RtrConfigData *pRtrConfigData,
                           IRouterInfo *pRouter)
{
    HRESULT                 hr = hrOK;
    SPIRouterProtocolConfig    spRouterConfig;
    SRtrMgrProtocolCBList   SRmProtCBList;
    POSITION                pos;
    SRtrMgrProtocolCB *        pSRmProtCB;
    BOOL                    fFoundDedicatedInterface;
    GUID                    guidConfig = GUID_RouterNull;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    DWORD                   dwIfType;
    SPIEnumInterfaceInfo    spEnumInterface;

    // Check to see if IP is enabled
    // ------------------------------------------------------------
    if (pRtrConfigData->m_ipData.m_dwEnableIn &&
        pRtrConfigData->m_fIpSetup)
    {
        // If so, then we can add IGMP.
        // --------------------------------------------------------

        // Find the GUID for the IGMP Configuration.
        // We get the list directly (rather than from the pRouter)
        // because the data for the RtrMgrProtocols has not been
        // loaded yet.  The IRouterInfo only has information on the
        // interfaces and not for the protocols (since the router
        // is not yet configured).
        // --------------------------------------------------------
        RouterInfo::LoadInstalledRtrMgrProtocolList(pRtrConfigData->m_stServerName,
            PID_IP, &SRmProtCBList, pRouter);


        // Now iterate through this list looking for the igmp entry.
        // ------------------------------------------------------------
        pos = SRmProtCBList.GetHeadPosition();
        while (pos)
        {
            pSRmProtCB = SRmProtCBList.GetNext(pos);
            if ((pSRmProtCB->dwTransportId == PID_IP) &&
                (pSRmProtCB->dwProtocolId == MS_IP_IGMP))
            {
                guidConfig = pSRmProtCB->guidConfig;
                break;
            }
        }

        if (guidConfig == GUID_RouterNull)
            goto Error;

        // Now add IGMP.
        // --------------------------------------------------------
        CORg( CoCreateProtocolConfig(guidConfig,
                                     pRouter,
                                     PID_IP,
                                     MS_IP_IGMP,
                                     &spRouterConfig) );

        if (spRouterConfig)
            hr = spRouterConfig->AddProtocol(pRtrConfigData->m_stServerName,
                                             PID_IP,
                                             MS_IP_IGMP,
                                             NULL,
                                             0,
                                             pRouter,
                                             0);
        CORg( hr );

        // In addition, we will also need to add IGMP router to the
        // internal interface and IGMP proxy to one of the LAN
        // interfaces.
        // ------------------------------------------------------------


        // Do we have the router managers for the interfaces?
        // ------------------------------------------------------------

        pRouter->EnumInterface(&spEnumInterface);
        fFoundDedicatedInterface = FALSE;

        for (spEnumInterface->Reset();
             spEnumInterface->Next(1, &spIf, NULL) == hrOK;
             spIf.Release())
        {
            dwIfType = spIf->GetInterfaceType();

            // Add IGMP if this is an internal interface or
            // if this is the first dedicated interface.
            // --------------------------------------------------------
            if ((dwIfType == ROUTER_IF_TYPE_INTERNAL) ||
                (!fFoundDedicatedInterface &&
                 (dwIfType == ROUTER_IF_TYPE_DEDICATED)))
            {
                // Ok, add IGMP to this interface
                // ----------------------------------------------------

                // If this is a dedicated interface and a private network
                // is specified, use that.
                // ----------------------------------------------------
                if ((dwIfType == ROUTER_IF_TYPE_DEDICATED) &&
                    !pRtrConfigData->m_ipData.m_stNetworkAdapterGUID.IsEmpty() &&
                    (pRtrConfigData->m_ipData.m_stNetworkAdapterGUID != spIf->GetId()))
                    continue;

                // Get the IP Router Manager
                // ----------------------------------------------------
                spRmIf.Release();
                CORg( spIf->FindRtrMgrInterface(PID_IP, &spRmIf) );

                if (!spRmIf)
                    break;

                if (dwIfType == ROUTER_IF_TYPE_DEDICATED)
                    fFoundDedicatedInterface = TRUE;

                if (dwIfType == ROUTER_IF_TYPE_INTERNAL)
                    AddIGMPToInterface(spIf, TRUE /* fRouter */);
                else
                    AddIGMPToInterface(spIf, FALSE /* fRouter */);
            }
        }

    }

Error:
    while (!SRmProtCBList.IsEmpty())
        delete SRmProtCBList.RemoveHead();

    return hr;
}


/*!--------------------------------------------------------------------------
    AddIGMPToNATServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIGMPToNATServer(NewRtrWizData *pNewRtrWizData,
                           RtrConfigData *pRtrConfigData,
                           IRouterInfo *pRouter,
                           BOOL fAddInternal)
{
    HRESULT                 hr = hrOK;
    SPIRouterProtocolConfig spRouterConfig;
    SRtrMgrProtocolCBList   SRmProtCBList;
    POSITION                pos;
    SRtrMgrProtocolCB *     pSRmProtCB;
    GUID                    guidConfig = GUID_RouterNull;
    SPIInterfaceInfo        spIf;
    SPIEnumInterfaceInfo    spEnumInterface;
    DWORD                   dwIfType;
    CString                 stTempGUID;

    Assert(pNewRtrWizData);
    
    // Check to see if IP is enabled
    // ------------------------------------------------------------
    if (pRtrConfigData->m_ipData.m_dwEnableIn &&
        pRtrConfigData->m_fIpSetup)
    {
        // If so, then we can add IGMP.
        // --------------------------------------------------------

        // Find the GUID for the IGMP Configuration.
        // We get the list directly (rather than from the pRouter)
        // because the data for the RtrMgrProtocols has not been
        // loaded yet.  The IRouterInfo only has information on the
        // interfaces and not for the protocols (since the router
        // is not yet configured).
        // --------------------------------------------------------
        RouterInfo::LoadInstalledRtrMgrProtocolList(pRtrConfigData->m_stServerName,
            PID_IP, &SRmProtCBList, pRouter);


        // Now iterate through this list looking for the igmp entry.
        // ------------------------------------------------------------
        pos = SRmProtCBList.GetHeadPosition();
        while (pos)
        {
            pSRmProtCB = SRmProtCBList.GetNext(pos);
            if ((pSRmProtCB->dwTransportId == PID_IP) &&
                (pSRmProtCB->dwProtocolId == MS_IP_IGMP))
            {
                guidConfig = pSRmProtCB->guidConfig;
                break;
            }
        }

        if (guidConfig == GUID_RouterNull)
            goto Error;

        // Now add IGMP.
        // --------------------------------------------------------
        CORg( CoCreateProtocolConfig(guidConfig,
                                     pRouter,
                                     PID_IP,
                                     MS_IP_IGMP,
                                     &spRouterConfig) );

        if (spRouterConfig)
            hr = spRouterConfig->AddProtocol(pRtrConfigData->m_stServerName,
                                             PID_IP,
                                             MS_IP_IGMP,
                                             NULL,
                                             0,
                                             pRouter,
                                             0);
        CORg( hr );

        if (pNewRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT) 
        {
            stTempGUID = pNewRtrWizData->m_stNATPrivateInterfaceId;
        }
        else
        {
            stTempGUID = pNewRtrWizData->m_stPrivateInterfaceId;
        }

        pRouter->EnumInterface(&spEnumInterface);

        for (spEnumInterface->Reset();
             spEnumInterface->Next(1, &spIf, NULL) == hrOK;
             spIf.Release())
        {
            if (pRtrConfigData->m_ipData.m_stPublicAdapterGUID.CompareNoCase(spIf->GetId()) == 0)
            {
                // Ok, add the public interface as the proxy
                AddIGMPToInterface(spIf, FALSE /* fRouter */);
            }

            if (stTempGUID.CompareNoCase(spIf->GetId()) == 0)
            {
                // Ok, add the private interface as the router
                AddIGMPToInterface(spIf, TRUE /* fRouter */);
            }

            dwIfType = spIf->GetInterfaceType();
            if ( fAddInternal && dwIfType == ROUTER_IF_TYPE_INTERNAL)
            {
                //
                //If we have been instructed to add internal interface
                //then add it.
                //
                AddIGMPToInterface(spIf, TRUE /* fRouter */);
            }


        }

    }

Error:
    while (!SRmProtCBList.IsEmpty())
        delete SRmProtCBList.RemoveHead();

    return hr;
}


HRESULT AddIGMPToInterface(IInterfaceInfo *pIf, BOOL fRouter)
{
    HRESULT hr = hrOK;
    SPIRtrMgrInterfaceInfo   spRmIf;
    SPIInfoBase     spInfoBase;
    IGMP_MIB_IF_CONFIG      igmpConfig;
	BOOL bVersion2=TRUE;
	CString str;
	
    // Get the IP Router Manager
    // ----------------------------------------------------
    CORg( pIf->FindRtrMgrInterface(PID_IP, &spRmIf) );
    if (spRmIf == NULL)
        CORg( E_FAIL );

    CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );

    igmpConfig = g_IGMPLanDefault;
	{
	    if(pIf)
    	{
		    CString			szMachineName;
		    LPWSTR			lpcwMachine = NULL;

		    WKSTA_INFO_100*	pWkstaInfo100 = NULL;
	    
    		szMachineName = pIf->GetMachineName();

    		if(!szMachineName.IsEmpty() && szMachineName[0] != L'\\')
    		// append \\ prefix the machine name before call NetWks
    		{
    			str = L"\\\\";
    			str += szMachineName;
    			lpcwMachine = (LPWSTR)(LPCWSTR)str;

    		}

   			if( NERR_Success == NetWkstaGetInfo(lpcwMachine, 100, (LPBYTE*)&pWkstaInfo100))
   			{
				Assert(pWkstaInfo100);

				if(pWkstaInfo100->wki100_ver_major > 5 || ( pWkstaInfo100->wki100_ver_major == 5 && pWkstaInfo100->wki100_ver_minor > 0))
				// dont support IGMPv3
					bVersion2 = FALSE;
				NetApiBufferFree(pWkstaInfo100);
   			}
		}
	}

    if (fRouter)
    {
        igmpConfig.IgmpProtocolType = bVersion2? IGMP_ROUTER_V2: IGMP_ROUTER_V3;
	}
    else
        igmpConfig.IgmpProtocolType = IGMP_PROXY;

	if (bVersion2)
		igmpConfig.Version = IGMP_VERSION_1_2;
		
		
    CORg( spInfoBase->AddBlock(MS_IP_IGMP,
                               sizeof(IGMP_MIB_IF_CONFIG),
                               (LPBYTE) &igmpConfig,
                               1,
                               TRUE) );

    CORg( spRmIf->Save(pIf->GetMachineName(),
                       NULL, NULL, NULL, spInfoBase, 0) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    RtrConfigData::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  RtrConfigData::Init(LPCTSTR pszServerName, IRouterInfo *pRouter)
{
    RouterVersionInfo    routerVersion;
    BOOL        fNt4 = FALSE;
    BOOL        fRemote;

    pRouter->GetRouterVersionInfo(&routerVersion);
    fNt4 = (routerVersion.dwRouterVersion == 4);

    m_fRemote = !IsLocalMachine(pszServerName);

    m_stServerName = pszServerName;

    // Load data from the registry
    m_ipData.UseDefaults(pszServerName, fNt4);
    m_ipxData.UseDefaults(pszServerName, fNt4);
    m_nbfData.UseDefaults(pszServerName, fNt4);
    m_arapData.UseDefaults(pszServerName, fNt4);
    m_errlogData.UseDefaults(pszServerName, fNt4);
    m_authData.UseDefaults(pszServerName, fNt4);


    // Determine what protocols are installed
    // ----------------------------------------------------------------
    m_fUseIp = (HrIsProtocolSupported(pszServerName,
                                      c_szRegKeyTcpip,
                                      c_szRegKeyRasIp,
                                      c_szRegKeyRasIpRtrMgr) == hrOK);
#if (WINVER >= 0x0501)
    m_fUseIpx = FALSE;
#else
    m_fUseIpx = (HrIsProtocolSupported(pszServerName,
                                       c_szRegKeyNwlnkIpx,
                                       c_szRegKeyRasIpx,
                                       NULL) == hrOK);
#endif
    m_fUseNbf = (HrIsProtocolSupported(pszServerName,
                                       c_szRegKeyNbf,
                                       c_szRegKeyRasNbf,
                                       NULL) == hrOK);

    m_fUseArap = (HrIsProtocolSupported(pszServerName,
                                        c_szRegKeyAppletalk,
                                        c_szRegKeyRasAppletalk,
                                        NULL) == hrOK);
    return hrOK;
}


#ifdef KSL_IPINIP
/*!--------------------------------------------------------------------------
    CleanupTunnelFriendlyNames
        Removes the list of Ip-in-Ip tunnel friendly names.  This should
        be used ONLY if we have already removed the interfaces.
    Author: KennT
 ---------------------------------------------------------------------------*/
DWORD CleanupTunnelFriendlyNames(IRouterInfo *pRouter)
{
    LPBYTE  pBuffer = NULL;
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   dwEntriesRead = 0;
    MPR_IPINIP_INTERFACE_0  *pTunnel0 = NULL;

    // Get the list of Ip-in-Ip tunnels
    // ----------------------------------------------------------------
    dwErr = MprSetupIpInIpInterfaceFriendlyNameEnum((LPWSTR) pRouter->GetMachineName(),
                                           &pBuffer,
                                           &dwEntriesRead);
    pTunnel0 = (MPR_IPINIP_INTERFACE_0 *) pBuffer;

    if (dwErr == ERROR_SUCCESS)
    {
        // Now go through the tunnels and delete all of them
        // ------------------------------------------------------------
        for (DWORD i=0; i<dwEntriesRead; i++, pTunnel0++)
        {
            MprSetupIpInIpInterfaceFriendlyNameDelete(
                (LPWSTR) pRouter->GetMachineName(),
                &(pTunnel0->Guid));
        }
    }

    // Free up the buffer returned from the enum
    // ----------------------------------------------------------------
    if (pBuffer)
        MprSetupIpInIpInterfaceFriendlyNameFree(pBuffer);

    return dwErr;
}
#endif //KSL_IPINIP



/*!--------------------------------------------------------------------------
    AddNATToServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddNATToServer(NewRtrWizData *pNewRtrWizData,
                       RtrConfigData *pRtrConfigData,
                       IRouterInfo *pRouter,
                       BOOL fCreateDD,
					   BOOL fAddProtocolOnly		//Do not add interfaces.  Just add the protocol and nothing else
					   )
{
    HRESULT                 hr = hrOK;
    SPIRouterProtocolConfig spRouterConfig;
    SRtrMgrProtocolCBList   SRmProtCBList;
    POSITION                pos;
    SRtrMgrProtocolCB *     pSRmProtCB;
    GUID                    guidConfig = GUID_RouterNull;
    SPIInfoBase             spInfoBase;
    BOOL                    fSave = FALSE;

    Assert(pNewRtrWizData);
    Assert(pRtrConfigData);

    Assert(pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_NAT);

    // Check to see if IP is enabled
    // ------------------------------------------------------------
    if (!pRtrConfigData->m_ipData.m_dwEnableIn ||
        !pRtrConfigData->m_fIpSetup)
        return hrOK;

    // If so, then we can add NAT.
    // --------------------------------------------------------

    // Find the GUID for the NAT Configuration.
    // Manually load this since the IRouterInfo has not yet
    // loaded the RtrMgrProtocol info since the router is
    // still in an unconfigured state.
    // --------------------------------------------------------
    RouterInfo::LoadInstalledRtrMgrProtocolList(pRtrConfigData->m_stServerName,
                                                PID_IP, &SRmProtCBList, pRouter);


    // Now iterate through this list looking for the nat entry.
    // ------------------------------------------------------------
    pos = SRmProtCBList.GetHeadPosition();
    while (pos)
    {
        pSRmProtCB = SRmProtCBList.GetNext(pos);
        if ((pSRmProtCB->dwTransportId == PID_IP) &&
            (pSRmProtCB->dwProtocolId == MS_IP_NAT))
        {
            guidConfig = pSRmProtCB->guidConfig;
            break;
        }
    }

    if (guidConfig == GUID_RouterNull)
        goto Error;

    // Now add NAT.
    // --------------------------------------------------------
    CORg( CoCreateProtocolConfig(guidConfig,
                                 pRouter,
                                 PID_IP,
                                 MS_IP_NAT,
                                 &spRouterConfig) );

    if (spRouterConfig)
        hr = spRouterConfig->AddProtocol(pRtrConfigData->m_stServerName,
                                         PID_IP,
                                         MS_IP_NAT,
                                         NULL,
                                         0,
                                         pRouter,
                                         0);
    CORg( hr );

	if ( !fAddProtocolOnly )
	{
		// Check the flags to see if we have to add the DNS proxy
		// and the DHCP allocator.
		// ------------------------------------------------------------

		// Get the router manager for IP
		// We have to do this manually since the IRouterInfo will not
		// have RtrMgr or RtrMgrProtocol information since the router
		// is still in the unconfigured state.
		// ------------------------------------------------------------
		if (FHrSucceeded(hr))
			CORg( AddNATSimpleServers(pNewRtrWizData, pRtrConfigData) );


		// Now that we've added the DNS proxy/DHCP allocator, add
		// NAT to the specific interfaces involved.
		// ----------------------------------------------------------------
		if (FHrSucceeded(hr))
			CORg( AddNATToInterfaces(pNewRtrWizData, pRtrConfigData, pRouter, fCreateDD) );
	}


Error:
    while (!SRmProtCBList.IsEmpty())
        delete SRmProtCBList.RemoveHead();

    return hr;
}



/*!--------------------------------------------------------------------------
    AddNATSimpleServers
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddNATSimpleServers(NewRtrWizData *pNewRtrWizData,
                            RtrConfigData *pRtrConfigData)
{
    HRESULT     hr = hrOK;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwErrT = ERROR_SUCCESS;
    MPR_SERVER_HANDLE   hMprServer = NULL;
    MPR_CONFIG_HANDLE   hMprConfig = NULL;
    LPBYTE      pByte = NULL;
    DWORD       dwSize = 0;
    SPIInfoBase spInfoBase;
    HANDLE      hTransport = NULL;
    BOOL        fSave = FALSE;

    CORg( CreateInfoBase(&spInfoBase) );

    // Connect to the server
    // ----------------------------------------------------------------
    dwErr = MprAdminServerConnect((LPWSTR) (LPCTSTR) pRtrConfigData->m_stServerName, &hMprServer);
    if (dwErr == ERROR_SUCCESS)
    {
        // Ok, get the infobase from the server
        dwErr = MprAdminTransportGetInfo(hMprServer,
                                         PID_IP,
                                         &pByte,
                                         &dwSize,
                                         NULL,
                                         NULL);

        if (dwErr == ERROR_SUCCESS)
        {
            spInfoBase->LoadFrom(dwSize, pByte);

            MprAdminBufferFree(pByte);
            pByte = NULL;
            dwSize = 0;
        }
    }

    // We also have to open the hMprConfig, but we can ignore the error
    dwErrT = MprConfigServerConnect((LPWSTR) (LPCTSTR) pRtrConfigData->m_stServerName, &hMprConfig);
    if (dwErrT == ERROR_SUCCESS)
    {
        dwErrT = MprConfigTransportGetHandle(hMprConfig, PID_IP, &hTransport);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        // Ok, try to use the MprConfig calls.
        CWRg( MprConfigTransportGetInfo(hMprConfig,
                                        hTransport,
                                        &pByte,
                                        &dwSize,
                                        NULL,
                                        NULL,
                                        NULL) );


        spInfoBase->LoadFrom(dwSize, pByte);

        MprConfigBufferFree(pByte);
        pByte = NULL;
        dwSize = 0;
    }

    Assert(spInfoBase);

    // deonb - add H323 & Directplay support
    if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_H323)
    {
        IP_H323_GLOBAL_INFO    globalInfo;

        globalInfo = *( (IP_H323_GLOBAL_INFO *)g_pH323GlobalDefault);

        CORg( spInfoBase->AddBlock(MS_IP_H323,
                                   sizeof(IP_H323_GLOBAL_INFO),
                                   (LPBYTE) &globalInfo, 1, TRUE));
        fSave = TRUE;
    }
    // deonb - add H323 & Directplay support <end>

    // savasg - add ALG support 
    if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_ALG)
    {
        IP_ALG_GLOBAL_INFO    globalInfo;

        globalInfo = *( (IP_ALG_GLOBAL_INFO *)g_pAlgGlobalDefault);

        CORg( spInfoBase->AddBlock(MS_IP_ALG,
                                   sizeof(IP_ALG_GLOBAL_INFO),
                                   (LPBYTE) &globalInfo, 1, TRUE));
        fSave = TRUE;
    } // savasg - end

    if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_DNS_PROXY)
    {
        IP_DNS_PROXY_GLOBAL_INFO    globalInfo;

        globalInfo = *( (IP_DNS_PROXY_GLOBAL_INFO *)g_pDnsProxyGlobalDefault);

        // Windows NT Bug : 393749
        // Remove the WINS flag
        globalInfo.Flags &= ~IP_DNS_PROXY_FLAG_ENABLE_WINS;

        CORg( spInfoBase->AddBlock(MS_IP_DNS_PROXY,
                                   sizeof(IP_DNS_PROXY_GLOBAL_INFO),
                                   (LPBYTE) &globalInfo, 1, TRUE));
        fSave = TRUE;
    }

    if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_DHCP_ALLOCATOR)
    {
        IP_AUTO_DHCP_GLOBAL_INFO    dhcpGlobalInfo;
        RtrWizInterface *           pRtrWizIf = NULL;
        CString                     stTempInterfaceId;

        dhcpGlobalInfo = * ( (IP_AUTO_DHCP_GLOBAL_INFO *) g_pAutoDhcpGlobalDefault);

        // Windows NT Bug : 385112
        // Due to the problems with changing the IP Address of the
        // adapter, let's just set the DHCP scope to be the scope of the
        // underlying subnet.

        if ( pNewRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT )
        {
            stTempInterfaceId = pNewRtrWizData->m_stNATPrivateInterfaceId;
        }
        else
        {
            stTempInterfaceId = pNewRtrWizData->m_stPrivateInterfaceId;
        }
        
        // Need to get the IP address of the private interface
        pNewRtrWizData->m_ifMap.Lookup(stTempInterfaceId,
                                       pRtrWizIf);

        // If we cannot find this interface, go with the default values
        // for the subnet/mask.  Otherwise use the IP address of the private
        // interface.
        if (pRtrWizIf && !pRtrWizIf->m_stIpAddress.IsEmpty())
        {
            CString stFirstIp;
            CString stFirstMask;
            int     iPos;

            // Just take the first IP Address
            stFirstIp = pRtrWizIf->m_stIpAddress;
            iPos = pRtrWizIf->m_stIpAddress.Find(_T(','));
            if (iPos >= 0)
                stFirstIp = pRtrWizIf->m_stIpAddress.Left(iPos);
            else
                stFirstIp = pRtrWizIf->m_stIpAddress;

            stFirstMask = pRtrWizIf->m_stMask;
            iPos = pRtrWizIf->m_stMask.Find(_T(','));
            if (iPos >= 0)
                stFirstMask = pRtrWizIf->m_stMask.Left(iPos);
            else
                stFirstMask = pRtrWizIf->m_stMask;

            // Now convert this into a net address
            dhcpGlobalInfo.ScopeMask = INET_ADDR(stFirstMask);
            dhcpGlobalInfo.ScopeNetwork = INET_ADDR(stFirstIp) & dhcpGlobalInfo.ScopeMask;
        }

        CORg( spInfoBase->AddBlock(MS_IP_DHCP_ALLOCATOR,
                                   sizeof(dhcpGlobalInfo),
                                   (PBYTE) &dhcpGlobalInfo, 1, TRUE) );
        fSave = TRUE;
    }

    if (fSave)
    {
        spInfoBase->WriteTo(&pByte, &dwSize);

        if (hMprServer)
        {
            MprAdminTransportSetInfo(hMprServer,
                                     PID_IP,
                                     pByte,
                                     dwSize,
                                     NULL,
                                     0);
        }

        if (hMprConfig && hTransport)
        {
            MprConfigTransportSetInfo(hMprConfig,
                                      hTransport,
                                      pByte,
                                      dwSize,
                                      NULL,
                                      NULL,
                                      NULL);
        }

        if (pByte)
            CoTaskMemFree(pByte);
    }

Error:
    if (hMprConfig)
        MprConfigServerDisconnect(hMprConfig);

    if (hMprServer)
        MprAdminServerDisconnect(hMprServer);

    return hr;
}


/*!--------------------------------------------------------------------------
    AddNATToInterfaces
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddNATToInterfaces(NewRtrWizData *pNewRtrWizData,
                           RtrConfigData *pRtrConfigData,
                           IRouterInfo *pRouter,
                           BOOL fCreateDD)
{
    HRESULT     hr = hrOK;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwErrT = ERROR_SUCCESS;
    MPR_SERVER_HANDLE   hMprServer = NULL;
    MPR_CONFIG_HANDLE   hMprConfig = NULL;
    LPBYTE      pByte = NULL;
    DWORD       dwSize = 0;
    SPIInfoBase spInfoBase;
    HANDLE      hTransport = NULL;
    CString     stIfName;
    CString     stTempGUID;
    DWORD       dwIfType;
    SPIEnumInterfaceInfo    spEnumInterface;
    SPIInterfaceInfo        spIf;



    CORg( CreateInfoBase(&spInfoBase) );

    // Connect to the server
    // ----------------------------------------------------------------
    MprAdminServerConnect((LPWSTR) (LPCTSTR) pRtrConfigData->m_stServerName, &hMprServer);

    MprConfigServerConnect((LPWSTR) (LPCTSTR) pRtrConfigData->m_stServerName, &hMprConfig);

    // Install public NAT on public interface
    AddNATToInterface(hMprServer,
                      hMprConfig,
                      pNewRtrWizData,
                      pRtrConfigData,
                      pRtrConfigData->m_ipData.m_stPublicAdapterGUID,
                      fCreateDD,
                      TRUE);

    if ( (pNewRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_NAT) ||
         (pNewRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT) )
    {
        // Install private NAT on private interface
        if (pNewRtrWizData->m_wizType == NewRtrWizData::NewWizardRouterType_VPNandNAT) 
        {
            stTempGUID = pNewRtrWizData->m_stNATPrivateInterfaceId;
        }
        else
        {
            stTempGUID = pNewRtrWizData->m_stPrivateInterfaceId;
        }
        
        AddNATToInterface(hMprServer,
                          hMprConfig,
                          pNewRtrWizData,
                          pRtrConfigData,
                          stTempGUID,
                          FALSE,
                          FALSE);
    }
    
    //
    //Need to add NAT on internal interface also in case this is a VPN/NAT
    //path.
    //
    pRouter->EnumInterface(&spEnumInterface);
    

    for (spEnumInterface->Reset();
         spEnumInterface->Next(1, &spIf, NULL) == hrOK;
         spIf.Release())
    {
        dwIfType = spIf->GetInterfaceType();
        if (dwIfType == ROUTER_IF_TYPE_INTERNAL)
        {
            AddNATToInterface(  hMprServer,
                                hMprConfig,
                                pNewRtrWizData,
                                pRtrConfigData,
                                spIf->GetId(),
                                FALSE,
                                FALSE);
            break;
        }

    }

    
Error:
    if (hMprConfig)
        MprConfigServerDisconnect(hMprConfig);

    if (hMprServer)
        MprAdminServerDisconnect(hMprServer);

    return hr;
}

//
// Default values for LAN-interface NAT configuration
//
IP_NAT_INTERFACE_INFO
g_ipnatLanDefault = {
    0,                                  // Index (unused)
    0,                                  // Flags
    { IP_NAT_VERSION, sizeof(RTR_INFO_BLOCK_HEADER), 0,
        { 0, 0, 0, 0}}                  // Header
};

BYTE* g_pIpnatLanDefault                = (BYTE*)&g_ipnatLanDefault;


//
// Default values for WAN-interface NAT configuration
//
IP_NAT_INTERFACE_INFO
g_ipnatWanDefault = {
    0,                                  // Index (unused)
    IP_NAT_INTERFACE_FLAGS_BOUNDARY|
    IP_NAT_INTERFACE_FLAGS_NAPT,        // Flags
    { IP_NAT_VERSION, sizeof(RTR_INFO_BLOCK_HEADER), 0,
        { 0, 0, 0, 0}}                  // Header
};

BYTE* g_pIpnatWanDefault                = (BYTE*)&g_ipnatWanDefault;


DWORD CreatePortMappingsForVPNFilters(  
                NewRtrWizData *pNewRtrWizData,
                IP_NAT_PORT_MAPPING **ppPortMappingsForVPNFilters,
                DWORD *dwNumPortMappings)
{
    DWORD           i, j, dwSize, dwNumMappingsPerAddress;
    DWORD           dwIpAddress = 0;
    CString         singleAddr;
    CString         tempAddrList;
    CDWordArray     arrIpAddr;
    RtrWizInterface *pIf = NULL;
    IP_NAT_PORT_MAPPING *pMappings = NULL;
    USES_CONVERSION;

    //
    // The set of generic Port Mappings corresponding to 
    // VPN server specific filters
    //
    IP_NAT_PORT_MAPPING 
    GenericPortMappingsArray[] = 
    {
        {
            NAT_PROTOCOL_TCP,
            htons(1723),
            htonl(IP_NAT_ADDRESS_UNSPECIFIED),
            htons(1723),
            htonl(INADDR_LOOPBACK)
        },
    
        {
            NAT_PROTOCOL_UDP,
            htons(500),
            htonl(IP_NAT_ADDRESS_UNSPECIFIED),
            htons(500),
            htonl(INADDR_LOOPBACK)
        },
    
        {
            NAT_PROTOCOL_UDP,
            htons(1701),
            htonl(IP_NAT_ADDRESS_UNSPECIFIED),
            htons(1701),
            htonl(INADDR_LOOPBACK)
        },

        {
            NAT_PROTOCOL_UDP,
            htons(4500),
            htonl(IP_NAT_ADDRESS_UNSPECIFIED),
            htons(4500),
            htonl(INADDR_LOOPBACK)
        }
        
    };

    dwSize = sizeof(GenericPortMappingsArray);

    pMappings = (PIP_NAT_PORT_MAPPING) new BYTE[dwSize];

    if ( pMappings == NULL )
    {
        *ppPortMappingsForVPNFilters = NULL;
        *dwNumPortMappings = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy( 
        (LPVOID) pMappings, 
        (LPVOID) &(GenericPortMappingsArray[0]),
        sizeof(GenericPortMappingsArray));

    *ppPortMappingsForVPNFilters = pMappings;
    *dwNumPortMappings = 
            sizeof(GenericPortMappingsArray)/sizeof(IP_NAT_PORT_MAPPING);
    
    return ERROR_SUCCESS;
}



/*!--------------------------------------------------------------------------
    AddNATToInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddNATToInterface(MPR_SERVER_HANDLE hMprServer,
                          HANDLE hMprConfig,
                          NewRtrWizData *pNewRtrWizData,
                          RtrConfigData *pRtrConfigData,
                          LPCTSTR pszInterface,
                          BOOL fDemandDial,
                          BOOL fPublic)
{
    HRESULT     hr = hrOK;
    HANDLE      hInterface = NULL;
    HANDLE      hIfTransport = NULL;
    LPBYTE      pByte = NULL;
    DWORD       dwSize = 0, dwIfBlkSize = 0;
    LPBYTE      pDefault = NULL;
    IP_NAT_INTERFACE_INFO   ipnat;
    PIP_NAT_INTERFACE_INFO  pipnat = NULL;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwNumPortMappings = 0;
    PIP_NAT_PORT_MAPPING pPortMappingsForVPNFilters = NULL;
    
    SPIInfoBase spInfoBase;
    
    IP_DNS_PROXY_INTERFACE_INFO dnsIfInfo;
    MIB_IPFORWARDROW    row;


    ::ZeroMemory(&dnsIfInfo, sizeof(dnsIfInfo));

    if ((pszInterface == NULL) || (*pszInterface == 0))
        return hrOK;

    // Setup the data structures
    // ----------------------------------------------------------------
    if (pNewRtrWizData->m_fSetVPNFilter && fPublic )
    {
        SPIInfoBase spIB;
        
        CORg( CreateInfoBase( &spIB ) );

        dwErr = CreatePortMappingsForVPNFilters(
            pNewRtrWizData,
            &pPortMappingsForVPNFilters,
            &dwNumPortMappings
            );

        if ( dwErr == ERROR_SUCCESS && pPortMappingsForVPNFilters)
        {

            spIB->AddBlock(
                IP_NAT_PORT_MAPPING_TYPE,
                sizeof( IP_NAT_PORT_MAPPING ),
                (PBYTE)pPortMappingsForVPNFilters,
                dwNumPortMappings,
                TRUE
                );
            
            spIB->WriteTo(&pByte, &dwIfBlkSize);

            pipnat = (PIP_NAT_INTERFACE_INFO)
                        new BYTE[
                            FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
                            dwIfBlkSize ];

            memcpy(&(pipnat->Header), pByte, dwIfBlkSize);

            if (  pNewRtrWizData->m_wizType != NewRtrWizData::NewWizardRouterType_VPNandNAT )
            {
                //
                //If this is not a VPN NAT combo, then setup as firewall only
                //
                pipnat->Flags = IP_NAT_INTERFACE_FLAGS_FW;
            }
            else
            {
                //
                //Otherwise this is a boundary also and firewall
                //
                pipnat->Flags = IP_NAT_INTERFACE_FLAGS_BOUNDARY |
                                IP_NAT_INTERFACE_FLAGS_NAPT |
                                IP_NAT_INTERFACE_FLAGS_FW;
            }

            pipnat->Index = 0;
            pDefault = (LPBYTE) pipnat;
            dwIfBlkSize += FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header);

            CoTaskMemFree( pByte );
            spIB.Release();
            pByte = NULL;
        }
        else
        {
            ipnat = g_ipnatLanDefault;
            pDefault = (LPBYTE) &ipnat;
            dwIfBlkSize = sizeof(IP_NAT_INTERFACE_INFO);
        }
    }

    else
    {
        if (fDemandDial)
            ipnat = g_ipnatWanDefault;
        else
            ipnat = g_ipnatLanDefault;

        if (fPublic)
        {
            ipnat.Flags |= IP_NAT_INTERFACE_FLAGS_BOUNDARY;
            if ( pNewRtrWizData->m_fNATEnableFireWall == TRUE )
                ipnat.Flags |= IP_NAT_INTERFACE_FLAGS_FW;

            // Windows NT Bug : 393731
            // This will enable the "Translate TCP/UDP headers in the UI"
            // ------------------------------------------------------------
            ipnat.Flags |= IP_NAT_INTERFACE_FLAGS_NAPT;

            // Windows NT Bug : 393809
            // Enable the DNS resolution
            // ------------------------------------------------------------
            if (fDemandDial)
                dnsIfInfo.Flags |= IP_DNS_PROXY_INTERFACE_FLAG_DEFAULT;
        }

        pDefault = (LPBYTE) &ipnat;
        dwIfBlkSize = sizeof(IP_NAT_INTERFACE_INFO);
    }
    

    ::ZeroMemory(&row, sizeof(row));

    // Windows Nt Bug : 389441
    // If this is a demand-dial interface, we will have to add
    // a static route to the interface
    // ----------------------------------------------------------------
    if (fDemandDial && fPublic)
    {
        // Note: this is a new interface so there should not be
        // any blocks.
        // ------------------------------------------------------------
        // What is the index of the demand-dial interface?
        row.dwForwardMetric1 = 1;
        row.dwForwardProto = PROTO_IP_NT_STATIC;
    }



    CORg( CreateInfoBase( &spInfoBase ) );

    // ok, we need to get the RmIf
    if (hMprServer)
    {
        dwErr = MprAdminInterfaceGetHandle(hMprServer,
                                           (LPWSTR) pszInterface,
                                           &hInterface,
                                           FALSE);

        if (dwErr == ERROR_SUCCESS)
            dwErr = MprAdminInterfaceTransportGetInfo(hMprServer,
                hInterface,
                PID_IP,
                &pByte,
                &dwSize);

        if (dwErr == ERROR_SUCCESS)
        {
            spInfoBase->LoadFrom(dwSize, pByte);
            MprAdminBufferFree(pByte);
        }

        pByte = NULL;
        dwSize = 0;

        if (dwErr == ERROR_SUCCESS)
        {
            // Manipulate the infobase
            spInfoBase->AddBlock(MS_IP_NAT,
                                 dwIfBlkSize,
                                 pDefault,
                                 1,
                                 TRUE);

            if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_DNS_PROXY)
            {
                spInfoBase->AddBlock(MS_IP_DNS_PROXY,
                                     sizeof(dnsIfInfo),
                                     (LPBYTE) &dnsIfInfo,
                                     1,
                                     TRUE);
            }

            // Windows NT Bug : 389441
            // Add the default route to the internet.
            // --------------------------------------------------------
            if (fDemandDial && fPublic)
            {
                // Note: this assumes that there are no routes
                // already defined for this interface
                // ----------------------------------------------------
                if ( spInfoBase->BlockExists(IP_ROUTE_INFO) == S_FALSE)
                {
                    //
                    //Add a route default route iff there are no
                    //routes already present for this dd interface
                    //
                    spInfoBase->AddBlock(IP_ROUTE_INFO,
                                         sizeof(row),
                                         (PBYTE) &row,
                                         1, TRUE);
                }
            }

            spInfoBase->WriteTo(&pByte, &dwSize);
        }

        if (dwErr == ERROR_SUCCESS)
        {
            MprAdminInterfaceTransportSetInfo(hMprServer,
                                              hInterface,
                                              PID_IP,
                                              pByte,
                                              dwSize);
        }

        if (pByte)
            CoTaskMemFree(pByte);
        pByte = NULL;
        dwSize = 0;
    }

    hInterface = NULL;

    if (hMprConfig)
    {
        dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                           (LPWSTR) pszInterface,
                                           &hInterface);

        if (dwErr == ERROR_SUCCESS)
            dwErr = MprConfigInterfaceTransportGetHandle(hMprConfig,
                hInterface,
                PID_IP,
                &hIfTransport);

        if (dwErr == ERROR_SUCCESS)
            dwErr = MprConfigInterfaceTransportGetInfo(hMprConfig,
                hInterface,
                hIfTransport,
                &pByte,
                &dwSize);

        if (dwErr == ERROR_SUCCESS)
        {
            spInfoBase->LoadFrom(dwSize, pByte);
            MprConfigBufferFree(pByte);
        }

        pByte = NULL;
        dwSize = 0;

        if (dwErr == ERROR_SUCCESS)
        {
            // Manipulate the infobase
            spInfoBase->AddBlock(MS_IP_NAT,
                                 dwIfBlkSize,
                                 pDefault,
                                 1,
                                 TRUE);

            if (pRtrConfigData->m_dwConfigFlags & RTRCONFIG_SETUP_DNS_PROXY)
            {
                spInfoBase->AddBlock(MS_IP_DNS_PROXY,
                                     sizeof(dnsIfInfo),
                                     (LPBYTE) &dnsIfInfo,
                                     1,
                                     TRUE);
            }

            // Windows NT Bug : 389441
            // Add the default route to the internet.
            // --------------------------------------------------------
            if (fDemandDial && fPublic)
            {
                // Note: this assumes that there are no routes
                // already defined for this interface
                // ----------------------------------------------------
                if (spInfoBase->BlockExists(IP_ROUTE_INFO) == S_FALSE) 
                {
                    spInfoBase->AddBlock(IP_ROUTE_INFO,
                                         sizeof(row),
                                         (PBYTE) &row,
                                         1, TRUE);
                }
            }

            spInfoBase->WriteTo(&pByte, &dwSize);
        }

        if (dwErr == ERROR_SUCCESS)
        {
            MprConfigInterfaceTransportSetInfo(hMprConfig,
                                               hInterface,
                                               hIfTransport,
                                               pByte,
                                               dwSize);
        }

        if (pByte)
            CoTaskMemFree(pByte);
        pByte = NULL;
        dwSize = 0;

        spInfoBase.Release();
    }

Error:
    if (pipnat != NULL) { delete [] pipnat; }
    return HResultFromWin32(dwErr);
}



/*!--------------------------------------------------------------------------
    AddIPBOOTPToServer
        If dwDhcpServer is 0, then we do not set it in the global list.

        dwDhcpServer is the IP address of the DHCP Server in network order.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIPBOOTPToServer(RtrConfigData *pRtrConfigData,
                           IRouterInfo *pRouter,
                           DWORD dwDhcpServer)
{
    HRESULT                 hr = hrOK;
    SPIRouterProtocolConfig    spRouterConfig;
    SRtrMgrProtocolCBList   SRmProtCBList;
    POSITION                pos;
    SRtrMgrProtocolCB *        pSRmProtCB;
    GUID                    guidConfig = GUID_RouterNull;
    SPIInterfaceInfo        spIf;
    SPIEnumInterfaceInfo    spEnumInterface;

    // Check to see if IP is enabled
    // ------------------------------------------------------------
    if (pRtrConfigData->m_ipData.m_dwEnableIn &&
        pRtrConfigData->m_fIpSetup)
    {
        // If so, then we can add IPBOOTP.
        // --------------------------------------------------------

        // Find the GUID for the IPBOOTP Configuration.
        // We get the list directly (rather than from the pRouter)
        // because the data for the RtrMgrProtocols has not been
        // loaded yet.  The IRouterInfo only has information on the
        // interfaces and not for the protocols (since the router
        // is not yet configured).
        // --------------------------------------------------------
        RouterInfo::LoadInstalledRtrMgrProtocolList(pRtrConfigData->m_stServerName,
            PID_IP, &SRmProtCBList, pRouter);


        // Now iterate through this list looking for the igmp entry.
        // ------------------------------------------------------------
        pos = SRmProtCBList.GetHeadPosition();
        while (pos)
        {
            pSRmProtCB = SRmProtCBList.GetNext(pos);
            if ((pSRmProtCB->dwTransportId == PID_IP) &&
                (pSRmProtCB->dwProtocolId == MS_IP_BOOTP))
            {
                guidConfig = pSRmProtCB->guidConfig;
                break;
            }
        }

        if (guidConfig == GUID_RouterNull)
            goto Error;

        // Now add IGMP.
        // --------------------------------------------------------
        CORg( CoCreateProtocolConfig(guidConfig,
                                     pRouter,
                                     PID_IP,
                                     MS_IP_BOOTP,
                                     &spRouterConfig) );

        if (spRouterConfig)
            hr = spRouterConfig->AddProtocol(pRtrConfigData->m_stServerName,
                                             PID_IP,
                                             MS_IP_BOOTP,
                                             NULL,
                                             0,
                                             pRouter,
                                             0);
        CORg( hr );

        // In order to do this, we'll have to get the IPBOOTP global
        // info and add the server to the list.
        // ------------------------------------------------------------
        if ((dwDhcpServer != 0) &&
            (dwDhcpServer != MAKEIPADDRESS(255,255,255,255)))
        {
            AddDhcpServerToBOOTPGlobalInfo(pRtrConfigData->m_stServerName,
                                           dwDhcpServer);
        }

        pRouter->EnumInterface(&spEnumInterface);

        for (spEnumInterface->Reset();
             spEnumInterface->Next(1, &spIf, NULL) == hrOK;
             spIf.Release())
        {

            // Look for the internal interface
            if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_INTERNAL)
            {
                AddIPBOOTPToInterface(spIf);
                break;
            }
        }

    }

Error:
    while (!SRmProtCBList.IsEmpty())
        delete SRmProtCBList.RemoveHead();

    return hr;
}



/*!--------------------------------------------------------------------------
    AddIPBOOTPToInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddIPBOOTPToInterface(IInterfaceInfo *pIf)
{
    HRESULT hr = hrOK;
    SPIRtrMgrInterfaceInfo   spRmIf;
    SPIInfoBase     spInfoBase;

    // Get the IP Router Manager
    // ----------------------------------------------------
    CORg( pIf->FindRtrMgrInterface(PID_IP, &spRmIf) );
    if (spRmIf == NULL)
        CORg( E_FAIL );

    CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );

    CORg( spInfoBase->AddBlock(MS_IP_BOOTP,
                               sizeof(IPBOOTP_IF_CONFIG),
                               (LPBYTE) &g_relayLanDefault,
                               1,
                               TRUE) );

    CORg( spRmIf->Save(pIf->GetMachineName(),
                       NULL, NULL, NULL, spInfoBase, 0) );

Error:
    return hr;
}


HRESULT AddDhcpServerToBOOTPGlobalInfo(LPCTSTR pszServerName,
                                       DWORD netDhcpServer)
{
    HRESULT     hr = hrOK;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwErrT = ERROR_SUCCESS;
    MPR_SERVER_HANDLE   hMprServer = NULL;
    MPR_CONFIG_HANDLE   hMprConfig = NULL;
    LPBYTE      pByte = NULL;
    DWORD       dwSize = 0;
    SPIInfoBase spInfoBase;
    HANDLE      hTransport = NULL;
    BOOL        fSave = FALSE;
    IPBOOTP_GLOBAL_CONFIG * pgc = NULL;
    IPBOOTP_GLOBAL_CONFIG * pgcNew = NULL;

    CORg( CreateInfoBase(&spInfoBase) );

    // Connect to the server
    // ----------------------------------------------------------------
    dwErr = MprAdminServerConnect((LPWSTR) pszServerName, &hMprServer);
    if (dwErr == ERROR_SUCCESS)
    {
        // Ok, get the infobase from the server
        dwErr = MprAdminTransportGetInfo(hMprServer,
                                         PID_IP,
                                         &pByte,
                                         &dwSize,
                                         NULL,
                                         NULL);

        if (dwErr == ERROR_SUCCESS)
        {
            spInfoBase->LoadFrom(dwSize, pByte);

            MprAdminBufferFree(pByte);
            pByte = NULL;
            dwSize = 0;
        }
    }

    // We also have to open the hMprConfig, but we can ignore the error
    // ----------------------------------------------------------------
    dwErrT = MprConfigServerConnect((LPWSTR) pszServerName, &hMprConfig);
    if (dwErrT == ERROR_SUCCESS)
    {
        dwErrT = MprConfigTransportGetHandle(hMprConfig, PID_IP, &hTransport);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        // No errors from the MprConfig calls
        // ------------------------------------------------------------
        CWRg( dwErrT );

        // Ok, try to use the MprConfig calls.
        // ------------------------------------------------------------
        CWRg( MprConfigTransportGetInfo(hMprConfig,
                                        hTransport,
                                        &pByte,
                                        &dwSize,
                                        NULL,
                                        NULL,
                                        NULL) );


        spInfoBase->LoadFrom(dwSize, pByte);

        MprConfigBufferFree(pByte);
        pByte = NULL;
        dwSize = 0;
    }


    Assert(spInfoBase);

    // Ok, get the current global config and add on this particular
    // DHCP server
    // ----------------------------------------------------------------
    spInfoBase->GetData(MS_IP_BOOTP, 0, (PBYTE *) &pgc);


    // Resize the struct for the increased address
    // ----------------------------------------------------------------
    dwSize = sizeof(IPBOOTP_GLOBAL_CONFIG) +
                      ((pgc->GC_ServerCount + 1) * sizeof(DWORD));
    pgcNew = (IPBOOTP_GLOBAL_CONFIG *) new BYTE[dwSize];


    // Copy over the original information
    // ----------------------------------------------------------------
    CopyMemory(pgcNew, pgc, IPBOOTP_GLOBAL_CONFIG_SIZE(pgc));


    // Add in the new DHCP server
    // ----------------------------------------------------------------
    IPBOOTP_GLOBAL_SERVER_TABLE(pgcNew)[pgc->GC_ServerCount] = netDhcpServer;
    pgcNew->GC_ServerCount++;

    spInfoBase->AddBlock(MS_IP_BOOTP,
                         dwSize,
                         (LPBYTE) pgcNew,
                         1,
                         TRUE);


    spInfoBase->WriteTo(&pByte, &dwSize);

    if (hMprServer)
    {
        MprAdminTransportSetInfo(hMprServer,
                                 PID_IP,
                                 pByte,
                                 dwSize,
                                 NULL,
                                 0);
    }

    if (hMprConfig && hTransport)
    {
        MprConfigTransportSetInfo(hMprConfig,
                                  hTransport,
                                  pByte,
                                  dwSize,
                                  NULL,
                                  NULL,
                                  NULL);
    }

    if (pByte)
        CoTaskMemFree(pByte);

Error:
    delete [] pgcNew;

    if (hMprConfig)
        MprConfigServerDisconnect(hMprConfig);

    if (hMprServer)
        MprAdminServerDisconnect(hMprServer);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "strings.h"
#define _STRINGS_DEFINE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    stdafx.cpp
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include "stdafx.h"
//nclude <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxdlgs.h>
#include <afxtempl.h>

#include <atlbase.h>

//
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

//
// Constants used in samples
//
const int NUM_FOLDERS = 2;
const int MAX_COLUMNS = 1;

//
// Types of folders
//
enum FOLDER_TYPES
{
    SAMPLE_ROOT,
    NONE
};

extern LPCWSTR g_lpszNullString;

#include "rtrguid.h"		// GUIDs/CLSIDs/etc...

//
// New Clipboard format that has the Type and Cookie 
//
extern const wchar_t*   SNAPIN_INTERNAL;

//
// NOTE: Right now all header files are included from here.  It might be a good
// idea to move the snapin specific header files out of the precompiled header.
//
#include "resource.h"
#include "..\common\snapbase.h"

#include "dbgutil.h"
#include "errutil.h"
#include "std.h"

#include <lm.h>
#include <shlobj.h>
#include <dsclient.h>

#include <advpub.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <routprot.h>
#include "tfsint.h"
#include "tfschar.h"
#include "images.h"
#include "tregkey.h"		// registry routines
#include "router.h"			// router.idl
#include "info.h"			// IRouterInfo utilities
#include "strings.h"		// constant strings
#include "infopriv.h"		// misc. RouterInfo utilities

#include "strmap.h"			// XXXtoCString functions
#include "format.h"			// DisplayErrorMessage
#include "reg.h"			// registry utilities
#include "util.h"
#include "rtrutil.h"
#include "service.h"

#include "infobase.h"


#include "mprapi.h"
#include "mprerror.h"

#include "..\common\commres.h"
#include "..\tfscore\tfsres.h"

#include "htmlhelp.h"		// HTML help APIs

#include "rtrres.h"

#define	VER_MAJOR_WIN2K		5
#define	VER_MINOR_WIN2K		0
#define	VER_BUILD_WIN2K		2195


// Windows NT Bug 325173
// Undefine or remove this line once we reopen for checkins
// This is a fix for 325173
#define SNAPIN_WRITES_TCPIP_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\remras_p_stub.c ===
#include "remras_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\inc\rrasutil.h ===
/**********************************************************************/
/** RRASUTIL.h :                                                     **/
/**                                                                  **/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(C) Microsoft Corporation, 1997 - 1999      **/
/**********************************************************************/
#ifndef _RRASUTIL_H_
#define _RRASUTIL_H_

#include "remras.h"

typedef ComSmartPointer<IRemoteRouterConfig, &IID_IRemoteRouterConfig> SPIRemoteRouterConfig;
typedef ComSmartPointer<IRemoteNetworkConfig, &IID_IRemoteNetworkConfig> SPIRemoteNetworkConfig;
typedef ComSmartPointer<IRemoteTCPIPChangeNotify, &IID_IRemoteTCPIPChangeNotify> SPIRemoteTCPIPChangeNotify;
typedef ComSmartPointer<IRemoteRouterRestart, &IID_IRemoteRouterRestart> SPIRemoteRouterRestart;
typedef ComSmartPointer<IRemoteSetDnsConfig, &IID_IRemoteSetDnsConfig> SPIRemoteSetDnsConfig;
typedef ComSmartPointer<IRemoteICFICSConfig, &IID_IRemoteICFICSConfig> SPIRemoteICFICSConfig;

#endif	/* ! _RRASUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDR_Remrras		101
#define IDR_REMCFG		102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\rrasuid\remras_i_stub.c ===
#include "remras_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    stdafx.cpp
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include "stdafx.h"
//nclude <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/
//#include <afxwin.h>
//#include <afxdisp.h>
//#include <afxcmn.h>
//#include <afxdlgs.h>
//#include <afxtempl.h>

//#include <atlbase.h>

//
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//
//extern CComModule _Module;
//#include <atlcom.h>

//#include <mmc.h>
//#include "rtrguid.h"		// GUIDs/CLSIDs/etc...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\prxydll\rrasprxy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rrasprxy.cpp
//
//--------------------------------------------------------------------------


#include <stdafx.h>
#include <windows.h>

#include "remras.h"
#include "resource.h"

#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
CExeModule _Module;
#include <atlcom.h>

#undef _ATL_DLL
#include <statreg.h>
#include <statreg.cpp>
#define _ATL_DLL

#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
//	OBJECT_ENTRY(CLSID_RemoteRouterConfig, CRemCfg)
END_OBJECT_MAP()


extern "C" {
extern BOOL WINAPI MidlGeneratedDllMain(HINSTANCE, DWORD, LPVOID);
extern HRESULT STDAPICALLTYPE MidlGeneratedDllRegisterServer();
extern HRESULT STDAPICALLTYPE MidlGeneratedDllUnregisterServer();
extern HRESULT STDAPICALLTYPE MidlGeneratedDllGetClassObject(REFCLSID,REFIID,
										 void **);
extern HRESULT STDAPICALLTYPE MidlGeneratedDllCanUnloadNow();
};



LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}



/*!--------------------------------------------------------------------------
	DllMain
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hInstance,
					DWORD dwReason,
					LPVOID	pvReserved)
{
	BOOL	fReturn = TRUE;
	
    if(dwReason == DLL_PROCESS_ATTACH){
	    _Module.Init(ObjectMap, hInstance);
	    _Module.dwThreadID = GetCurrentThreadId();

    	fReturn = MidlGeneratedDllMain(hInstance, dwReason, pvReserved);
    }
    else if(dwReason == DLL_PROCESS_DETACH){
        _Module.Term();
    }
	
    return fReturn;
}


/*!--------------------------------------------------------------------------
	DllRegisterServer
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT STDAPICALLTYPE DllRegisterServer()
{
	CRegObject ro;
	WCHAR				swzPath[MAX_PATH*2 + 1] = {0};
	WCHAR				swzModule[MAX_PATH*2 + 1] = {0};
	HRESULT				hRes;
	int					i, cLen;

	if ( !GetModuleFileNameW(_Module.GetModuleInstance(), swzPath, MAX_PATH*2) )
    {
        return GetLastError();
    }
	lstrcpyW(swzModule, swzPath);

	
	// Given this path, substitue remrras.exe for rrasprxy.dll
	// ----------------------------------------------------------------
	cLen = lstrlenW(swzPath);
	for (i=cLen; --i>=0; )
	{
		// Ok, this is a path marker, copy over it
		// ------------------------------------------------------------
		if (swzPath[i] == L'\\')
		{
			lstrcpyW(swzPath+i+1, L"remrras.exe");
			break;
		}
	}
	
	// Add in the substitute for the %REMRRAS%
	// ----------------------------------------------------------------
	ro.AddReplacement(L"REMRRAS", swzPath);

	
	// We need to fix up the registrar.
	// Go through and register the object CLSID for remrras.exe
	// ----------------------------------------------------------------
	ro.ResourceRegister(swzModule, ((UINT) LOWORD((DWORD)IDR_Remrras)), L"REGISTRY");

	// Register the APPIDs
	// ----------------------------------------------------------------
	ro.ResourceRegister(swzModule, ((UINT) LOWORD((DWORD) IDR_REMCFG)), L"REGISTRY");


	// Register the type library for REMRRAS
	// ----------------------------------------------------------------
	hRes = AtlModuleRegisterTypeLib(&_Module, NULL);

	
	// Call the MIDL-generated registration (to register the
	// proxy dll).
	// ----------------------------------------------------------------
	if (SUCCEEDED(hRes))
		hRes = MidlGeneratedDllRegisterServer();

	return hRes;
}


/*!--------------------------------------------------------------------------
	DllUnregisterServer
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT STDAPICALLTYPE DllUnregisterServer()
{
	CRegObject ro;
	WCHAR				swzPath[MAX_PATH*2 + 1] = {0};
	WCHAR				swzModule[MAX_PATH*2 + 1] = {0};
	HRESULT				hRes;
	int					i, cLen;


	if ( !GetModuleFileNameW(_Module.GetModuleInstance(), swzPath, MAX_PATH*2) )
    {
        return GetLastError();
    }
	lstrcpynW(swzModule, swzPath, MAX_PATH);


	
	// Given this path, substitue remrras.exe for rrasprxy.dll
	// ----------------------------------------------------------------
	cLen = lstrlenW(swzPath);
	for (i=cLen; --i>=0; )
	{
		// Ok, this is a path marker, copy over it
		// ------------------------------------------------------------
		if (swzPath[i] == L'\\')
		{
			lstrcpyW(swzPath+i+1, L"remrras.exe");
			break;
		}
	}

	
	// Add in the substitute for the %REMRRAS%
	// ----------------------------------------------------------------
	ro.AddReplacement(L"REMRRAS", swzPath);

	
	// We need to fix up the registrar.
	// Go through and register the object CLSID for remrras.exe
	// ----------------------------------------------------------------
	ro.ResourceUnregister(swzModule, ((UINT) LOWORD((DWORD)IDR_Remrras)), L"REGISTRY");

	// Unregister the APPID
	// ----------------------------------------------------------------
	ro.ResourceUnregister(swzModule, ((UINT) LOWORD((DWORD)IDR_REMCFG)), L"REGISTRY");

	// Unregister the type library
	// ----------------------------------------------------------------
	hRes = UnRegisterTypeLib(LIBID_REMRRASLib,
							 1, 0,	// version 1.0
							 LOCALE_SYSTEM_DEFAULT,
							 SYS_WIN32);
	
	// Call the MIDL-generated registration (to unregister the
	// proxy dll).
	// ----------------------------------------------------------------
	hRes = MidlGeneratedDllUnregisterServer();

	return hRes;
}


/*!--------------------------------------------------------------------------
	DllGetClassObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid,
										 REFIID	riid,
										 void **ppv)
{
	return MidlGeneratedDllGetClassObject(rclsid, riid, ppv);
}


/*!--------------------------------------------------------------------------
	DllCanUnloadNow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT STDAPICALLTYPE DllCanUnloadNow()
{
	return MidlGeneratedDllCanUnloadNow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\bindobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       B I N D O B J . H
//
//  Contents:   Declaration of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
//nclude <notifval.h>
#include "netcfgx.h"
#include "resource.h"
//#include "rasaf.h"
//nclude "rasdata.h"
#include "ncutil.h"

class CRasBindObject
{
public:
    // Make these members public for now. Since this object
    // is instantiated from the modem class installer. We
    // need to set the INetCfg member.
    //
    INetCfg*                m_pnc;
    CRasBindObject          ();

    ~CRasBindObject         ()
    {
        ReleaseObj (m_pnc);
		m_pnc = NULL;
    }

    // You must call ReleaseOtherComponents after calling this.
    HRESULT HrFindOtherComponents   ();

    // You can only call this once per call to HrFindOtherComponents.
    VOID    ReleaseOtherComponents  () NOTHROW;

protected:
    // We keep an array of INetCfgComponent pointers.  This enum
    // defines the indicies of the array.  The static arrays of
    // class guids and component ids identify the respecitive components.
    // HrFindOtherComonents initializes the array of component pointers
    // and ReleaseOtherComponents releases them.  Note, however, that this
    // action is refcounted.  This is because we are re-entrant.
    // HrFindOtherComponents only finds the components if the refcount is
    // zero.  After every call, it increments the refcount.
    // ReleaseOtherComponents always decrements the refcount and only
    // releases the components if the refcount is zero.
    //
    enum OTHER_COMPONENTS
    {
        c_ipnccRasCli = 0,
        c_ipnccRasSrv,
        c_ipnccRasRtr,
        c_ipnccIp,
        c_ipnccIpx,
        c_ipnccNbf,
        c_ipnccAtalk,
        c_ipnccNetMon,
        c_ipnccNdisWan,
        c_cOtherComponents,
    };
    static const GUID*      c_apguidComponentClasses [c_cOtherComponents];
    static const LPCTSTR    c_apszComponentIds       [c_cOtherComponents];
    INetCfgComponent*       m_apnccOther             [c_cOtherComponents];
    ULONG                   m_ulOtherComponents;

protected:
    INetCfgComponent*   PnccRasCli  () NOTHROW;
    INetCfgComponent*   PnccRasSrv  () NOTHROW;
    INetCfgComponent*   PnccIp      () NOTHROW;
    INetCfgComponent*   PnccIpx     () NOTHROW;
};

extern const TCHAR c_szInfId_MS_NdisWanAtalk[];
extern const TCHAR c_szInfId_MS_NdisWanIpIn[];
extern const TCHAR c_szInfId_MS_NdisWanIpOut[];
extern const TCHAR c_szInfId_MS_NdisWanIpx[];
extern const TCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const TCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const TCHAR c_szInfId_MS_NdisWanBh[];


inline
INetCfgComponent*
CRasBindObject::PnccRasCli () NOTHROW
{
    return m_apnccOther [c_ipnccRasCli];
}

inline
INetCfgComponent*
CRasBindObject::PnccRasSrv () NOTHROW
{
    return m_apnccOther [c_ipnccRasSrv];
}

inline
INetCfgComponent*
CRasBindObject::PnccIp () NOTHROW
{
    return m_apnccOther [c_ipnccIp];
}

inline
INetCfgComponent*
CRasBindObject::PnccIpx () NOTHROW
{
    return m_apnccOther [c_ipnccIpx];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\nccom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       N C C O M . H
//
//  Contents:   Common routines for dealing with COM.
//
//  Notes:
//
//  Author:     shaunco   25 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCCOM_H_
#define _NCCOM_H_

#include "ncutil.h"

HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    void**  ppv);

HRESULT
HrCoTaskMemAllocAndDupSz (
    LPCWSTR pszwSrc,
    LPWSTR* ppszwDst);


//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumIUnknown
//
//  Tenum is of type IEnumXXX (the enumeration interface)
//  Telt is of type XXX (the type of the element being enumerated)
//
//  HrNext(Telt* pelt) retreives next interface pointer and returns S_OK
//  if it is non-null.  S_FALSE is returned if *pelt is null (at end of list).
//  An error code will be returned for other failures (and *pelt will be
//  null of course.)
//
template <class Tenum, class Telt>
class CIEnumIter
{
public:
    CIEnumIter (Tenum* penum) NOTHROW;
    ~CIEnumIter () NOTHROW { ReleaseRemainingBatch (); }

    HRESULT HrNext(Telt* pelt) NOTHROW;
    void    SetEnumerator(Tenum* penum) NOTHROW
                { /*AssertSzH(!m_penum, "Enumerator already set."); */
                  m_penum = penum;
                  /*AssertSzH(m_penum, "Can't use a null enumerator."); */}

protected:
    void ReleaseRemainingBatch () NOTHROW;

    Tenum*  m_penum;        // pointer to the enumerator.  not addref'd.
    Telt*   m_aelt;         // array of enumerated types.
    Telt*   m_peltNext;     // pointer to next type to be returned.
    ULONG   m_celtFetched;  // number of elements fetched.
    HRESULT m_hrLast;       // last error
};


//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumXXX
//
template <class Tenum, class Telt>
inline CIEnumIter<Tenum, Telt>::CIEnumIter(Tenum* penum)
{
    m_penum         = penum;
    m_aelt          = NULL;
    m_peltNext      = NULL;
    m_celtFetched   = NULL;
    m_hrLast        = S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIEnumIter<Tenum, Telt>::HrNext
//
//  Purpose:    Returns the next item in the enumeration.
//
//  Arguments:
//      pelt [out]  Pointer to the returned elemnt.  Null if not available.
//
//  Returns:    S_OK if *pelt is valid.  S_FALSE if it is NULL.  Error
//              otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
template <class Tenum, class Telt>
inline HRESULT CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt) NOTHROW
{
//    AssertH(pelt);

    const ULONG c_celtBatch = 512;

    // If we failed for any reason before, return that failure.
    //
    if (FAILED(m_hrLast))
    {
        *pelt = NULL;
        goto error;
    }

//    AssertSzH(m_penum, "m_penum is null.  Did you forget to call SetEnumerator()?");
//    AssertSzH(c_celtBatch, "c_celtBatch can't be zero.");

    // If we already have the next interface pointer, and we're
    // not at the end of the batch, return it and advance.
    // This if should be caught most of the time.
    //
    if (m_peltNext && (m_peltNext < m_aelt + m_celtFetched))
    {
        *pelt = *m_peltNext;
        m_peltNext++;
    }

    // Otherwise, if we don't have the next interface pointer (first time),
    // or we're at the end of the batch, get the next batch and return
    // the first pointer in it.
    // This if should be caught the first time through.
    //
    else if (!m_peltNext || (m_celtFetched == c_celtBatch))
    {
        // Indicate that m_peltNext is invalid.
        //
        m_peltNext = NULL;

        // Free the old block of pointers
        free (m_aelt);

        // Allocate the next block of pointers
        m_aelt = reinterpret_cast<Telt *>(malloc(c_celtBatch * sizeof(Telt *)));
        if (!m_aelt)
        {
            *pelt = NULL;
            m_hrLast = E_OUTOFMEMORY;
            goto error;
        }

//        Assert (m_aelt);

        // Get the next batch.
        //
        m_hrLast = m_penum->Next(c_celtBatch, m_aelt, &m_celtFetched);

        // Make sure the implementor of Next is obeying the rules.
//        AssertH (FImplies((S_OK == m_hrLast), (m_celtFetched == c_celtBatch)));
//        AssertH (FImplies((SUCCEEDED(m_hrLast) && (0 == m_celtFetched)), (NULL == *m_aelt)));

        // If we were successful, set the next pointer and return
        // S_OK if we returned a valid pointer or S_FALSE if we
        // returned NULL.
        //
        if (SUCCEEDED(m_hrLast))
        {
            m_peltNext = m_aelt + 1;
            if (m_celtFetched)
            {
                *pelt = *m_aelt;
                m_hrLast = S_OK;
            }
            else
            {
                *pelt = NULL;
                m_hrLast = S_FALSE;
            }
        }
        else
        {
            *pelt = NULL;
        }
    }

    // Otherwise we've completely iterated the last batch and there are
    // no more batches.
    //
    else
    {
//        AssertH(m_peltNext >= m_aelt + m_celtFetched);
//        AssertH(m_celtFetched != c_celtBatch);

        *pelt = NULL;
        m_hrLast = S_FALSE;
    }

error:
//    AssertH(FIff(S_OK == m_hrLast, NULL != *pelt));
//    AssertH(FImplies(S_FALSE == m_hrLast, NULL == *pelt));

//    TraceError("CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt)",
//               (S_FALSE == m_hrLast) ? S_OK : m_hrLast);
    return m_hrLast;
}

template <class Tenum, class Telt>
inline void CIEnumIter<Tenum, Telt>::ReleaseRemainingBatch () NOTHROW
{
    // This needs to be run if the user doesn't completely iterate the
    // batch.  Finish releasing the interface pointers and free the batch.
    //
    if (m_peltNext && m_aelt)
    {
        while (m_peltNext < m_aelt + m_celtFetched)
        {
            ReleaseObj (*m_peltNext);
            m_peltNext++;
        }

        free (m_aelt);
    }

    // If this method is ever called from anywhere other than just
    // the destructor, uncomment the following lines.
    // m_peltNext = NULL;
    // m_aelt = NULL;
}


#endif // _NCCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\bindobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       B I N D O B J . C P P
//
//  Contents:   Implementation of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#pragma hdrstop
#include "bindobj.h"
#include "ncnetcfg.h"
#include "assert.h"
#include "ncutil.h"
//nclude "ncreg.h"
//nclude "ncsvc.h"


extern const TCHAR c_szBiNdisCoWan[];
extern const TCHAR c_szBiNdisWan[];
extern const TCHAR c_szBiNdisWanAsync[];
extern const TCHAR c_szBiNdisWanAtalk[];
extern const TCHAR c_szBiNdisWanBh[];
extern const TCHAR c_szBiNdisWanIp[];
extern const TCHAR c_szBiNdisWanIpx[];
extern const TCHAR c_szBiNdisWanNbf[];

extern const TCHAR c_szInfId_MS_AppleTalk[];
extern const TCHAR c_szInfId_MS_NWIPX[];
extern const TCHAR c_szInfId_MS_NdisWanIpArp[];
extern const TCHAR c_szInfId_MS_NdisWan[];
extern const TCHAR c_szInfId_MS_NetBEUI[];
extern const TCHAR c_szInfId_MS_NetMon[];
extern const TCHAR c_szInfId_MS_RasCli[];
extern const TCHAR c_szInfId_MS_RasRtr[];
extern const TCHAR c_szInfId_MS_RasSrv[];
extern const TCHAR c_szInfId_MS_TCPIP[];
extern const TCHAR c_szInfId_MS_Wanarp[];

extern const TCHAR c_szRegValWanEndpoints[] = TEXT("WanEndpoints");

const GUID GUID_DEVCLASS_NETSERVICE ={0x4D36E974,0xE325,0x11CE,{0xbf,0xc1,0x08,0x00,0x2b,0xe1,0x03,0x18}};
const GUID GUID_DEVCLASS_NETTRANS ={0x4D36E975,0xE325,0x11CE,{0xbf,0xc1,0x08,0x00,0x2b,0xe1,0x03,0x18}};


//----------------------------------------------------------------------------
// Data used for finding the other components we have to deal with.
//
const GUID* CRasBindObject::c_apguidComponentClasses [c_cOtherComponents] =
{
    &GUID_DEVCLASS_NETSERVICE,      // RasCli
    &GUID_DEVCLASS_NETSERVICE,      // RasSrv
    &GUID_DEVCLASS_NETSERVICE,      // RasRtr
    &GUID_DEVCLASS_NETTRANS,        // Ip
    &GUID_DEVCLASS_NETTRANS,        // Ipx
    &GUID_DEVCLASS_NETTRANS,        // Nbf
    &GUID_DEVCLASS_NETTRANS,        // Atalk
    &GUID_DEVCLASS_NETTRANS,        // NetMon
    &GUID_DEVCLASS_NETTRANS,        // NdisWan
};

const LPCTSTR CRasBindObject::c_apszComponentIds [c_cOtherComponents] =
{
    c_szInfId_MS_RasCli,
    c_szInfId_MS_RasSrv,
    c_szInfId_MS_RasRtr,
    c_szInfId_MS_TCPIP,
    c_szInfId_MS_NWIPX,
    c_szInfId_MS_NetBEUI,
    c_szInfId_MS_AppleTalk,
    c_szInfId_MS_NetMon,
    c_szInfId_MS_NdisWan,
};


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseAll
//
//  Purpose:    Releases an array of IUnknown pointers.
//
//  Arguments:
//      cpunk [in]  count of pointers to release
//      apunk [in]  array of pointers to release
//
//  Returns:    Nothing
//
//  Author:     shaunco   23 Mar 1997
//
//  Notes:      Any of the pointers in the array can be NULL.
//
VOID
ReleaseAll (
    ULONG       cpunk,
    IUnknown**  apunk) NOTHROW
{
    Assert (cpunk);
    Assert (apunk);

    while (cpunk--)
    {
        ReleaseObj (*apunk);
		*apunk = NULL;
        apunk++;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::CRasBindObject
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CRasBindObject::CRasBindObject ()
{
    m_ulOtherComponents = 0;
    m_pnc               = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::HrFindOtherComponents
//
//  Purpose:    Find the components listed in our OTHER_COMPONENTS enum.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:      We ref-count this action.  If called again (before
//              ReleaseOtherComponents) we increment a refcount.
//
//
HRESULT
CRasBindObject::HrFindOtherComponents ()
{
    AssertSz (c_cOtherComponents == celems(c_apguidComponentClasses),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(c_apszComponentIds),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(m_apnccOther),
              "Uhh...you broke something.");

    HRESULT hr = S_OK;

    if (!m_ulOtherComponents)
    {
        hr = HrFindComponents (
                m_pnc, c_cOtherComponents,
                c_apguidComponentClasses,
                c_apszComponentIds,
                m_apnccOther);
    }
    if (SUCCEEDED(hr))
    {
        m_ulOtherComponents++;
    }
    TraceResult ("CRasBindObject::HrFindOtherComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::ReleaseOtherComponents
//
//  Purpose:    Releases the components found by a previous call to
//              HrFindOtherComponents.  (But only if the refcount is zero.)
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void
CRasBindObject::ReleaseOtherComponents () NOTHROW
{
    AssertSz (m_ulOtherComponents,
              "You have not called HrFindOtherComponents yet or you have "
              "called ReleaseOtherComponents too many times.");

    if (0 == --m_ulOtherComponents)
    {
        ReleaseAll (c_cOtherComponents, (IUnknown**)m_apnccOther);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------


#undef CONST_STRING
#undef CONST_STRINGA
#undef CONST_STRINGW

#ifdef _STRINGS_DEFINE_STRINGS

    #define CONST_STRING(rg,s)   const TCHAR rg[] = TEXT(s);
    #define CONST_STRINGA(rg,s) const char rg[] = s;
    #define CONST_STRINGW(rg,s)  const WCHAR rg[] = s;

#else

    #define CONST_STRING(rg,s)   extern const TCHAR rg[];
    #define CONST_STRINGA(rg,s) extern const char rg[];
    #define CONST_STRINGW(rg,s)  extern const WCHAR rg[];

#endif


CONST_STRING(c_szAarpRetries,       "AarpRetries")
CONST_STRING(c_szActiveProvider,    "ActiveProvider")
CONST_STRING(c_szAdminShare,        "ADMIN$")
CONST_STRING(c_szAdminUICLSID,      "AdminUICLSID")
CONST_STRING(c_szAtlk,                  "AppleTalk")
CONST_STRING(c_szAttachedTo,        "AttachedTo")
CONST_STRING(c_szAcctPort,          "AcctPort")
CONST_STRING(c_szAppleTalkService,   "System\\CurrentControlSet\\Services\\AppleTalk\\Parameters")
CONST_STRING(c_szAuthPort,          "AuthPort")
CONST_STRING(c_szBind,              "Bind")
CONST_STRING(c_szClientsRasKey,     "Clients\\Ras")
CONST_STRING(c_szConfigCLSID,       "ConfigCLSID")
CONST_STRING(c_szInvokeUsernameDialog, "InvokeUsernameDialog")
CONST_STRING(c_szCSDVersion,        "CSDVersion")
CONST_STRING(c_szCurrentBuildNumber,"CurrentBuildNumber")
CONST_STRING(c_szCurrentVersion,    "CurrentVersion")
CONST_STRING(c_szDdpCheckSums,      "DdpCheckSums")
CONST_STRING(c_szDefaultZone,       "DefaultZone")
CONST_STRING(c_szDescription,       "Description")
CONST_STRING(c_szDevice,             "\\Device\\")
CONST_STRING(c_szDeviceNbfNdisWanNbfIn, "\\Device\\Nbf_NdisWanNbfIn")
CONST_STRING(c_szDialOutHours,      "DialOutHours")
CONST_STRING(c_szDisabled,          "Disabled")
CONST_STRING(c_szDisplayName,       "DisplayName")
CONST_STRING(c_szDLLName,           "DLLName")
CONST_STRING(c_szDLLPath,           "DLLPath")
CONST_STRING(c_szEAP,               "EAP")
CONST_STRING(c_szEnableAccounting,  "EnableAccounting")
CONST_STRING(c_szEnableAccountingOnOff, "EnableAccountingOnOff")
CONST_STRING(c_szEnableAuthentication, "EnableAuthentication")
CONST_STRING(c_szEnableForRas,      "EnableForRas")
CONST_STRING(c_szEnableForRouting,  "EnableForRouting")
CONST_STRING(c_szEnableForOutboundRouting,  "EnableForOutboundRouting")
CONST_STRING(c_szEnableRouter,       "EnableRouter")
CONST_STRING(c_szFlags,          "Flags")
CONST_STRING(c_szFriendlyName,      "FriendlyName")
CONST_STRING(c_szHKLM,                "HKLM")
CONST_STRING(c_szInterfacesKey,     "System\\CurrentControlSet\\Services\\RemoteAccess\\Interfaces")
CONST_STRING(c_szIPCShare,       "IPC$")
CONST_STRING(c_szL2TPMiniPort,        "ms_l2tpminiport")
CONST_STRING(c_szLinkage,        "Linkage")
CONST_STRING(c_szMacPrint,              "MacPrint")
CONST_STRING(c_szMaxWanEndpoints,   "MaxWanEndpoints")
CONST_STRING(c_szMicrosoft,         "Microsoft")
CONST_STRING(c_szMinWanEndpoints,   "MinWanEndpoints")
CONST_STRING(c_szModemKey,       "System\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}")
CONST_STRING(c_szMPPEEncryptionSupported, "MPPEEncryptionSupported")
CONST_STRING(c_szNetworkCardsKey,   "Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards")
CONST_STRING(c_szNWSAPAgent,        "NWSAPAgent")
CONST_STRING(c_szPortName ,          "PortName")
CONST_STRING(c_szPPTPMiniPort,        "ms_pptpminiport")
CONST_STRING(c_szProtocolId,        "ProtocolId")
CONST_STRING(c_szProviders,         "Providers")
CONST_STRING(c_szProviderTypeGUID,    "ProviderTypeGUID")
CONST_STRING(c_szPtiMiniPort,       "ms_ptiminiport")
CONST_STRING(c_szPPPoEMiniPort,     "ms_pppoeminiport")
CONST_STRING(c_szRadiusKey,         "Software\\Microsoft\\Ras\\Radius")
CONST_STRING(c_szRadiusAcctServersKey,    "System\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers\\{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}\\Servers")
CONST_STRING(c_szRadiusAuthServersKey,    "System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers\\{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}\\Servers")
CONST_STRING(c_szRAS,               "RAS")
CONST_STRING(c_szRasmanParameters,  "System\\CurrentControlSet\\Services\\Rasman\\Parameters")
CONST_STRING(c_szRasmanPPPKey,      "System\\CurrentControlSet\\Services\\Rasman\\PPP")
CONST_STRING(c_szEAPKey,            "System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")
CONST_STRING(c_szRemoteAccess,      "RemoteAccess")
CONST_STRING(c_szRemoteAccessKey,     "System\\CurrentControlSet\\Services\\RemoteAccess")
CONST_STRING(c_szRouter,            "Router")
CONST_STRING(c_szRouterManagers,    "RouterManagers")
CONST_STRING(c_szRouterManagersKey, "Software\\Microsoft\\Router\\CurrentVersion\\RouterManagers")
CONST_STRING(c_szRouterPbk,         "Router.Pbk")
CONST_STRING(c_szRouterPramNode,     "RouterPramNode")
CONST_STRING(c_szRouterType,        "RouterType")
CONST_STRING(c_szRtrConfigured,     "ConfigurationFlags")
CONST_STRING(c_szRouterPSK,         "RouterPSK")
CONST_STRING(c_szScore,             "Score")
CONST_STRING(c_szSeedingNetwork,     "SeedingNetwork")
CONST_STRING(c_szServerFlags,       "ServerFlags")
CONST_STRING(c_szSharedAccess,      "SharedAccess")
CONST_STRING(c_szSoftware,          "Software")
CONST_STRING(c_szSvcRouter,             "RemoteAccess")
CONST_STRING(c_szSvcEnableRouter,       "EnableRouter")
CONST_STRING(c_szSvcRasMan,             "RasMan")
CONST_STRING(c_szSystem32,          "System32")
CONST_STRING(c_szTimeout,           "Timeout")
CONST_STRING(c_szTitle,             "Title")
CONST_STRING(c_szUnlimited,         "Unlimited")
CONST_STRING(c_szUserPramNode1,      "UserPramNode1")
CONST_STRING(c_szUserPramNode2,      "UserPramNode2")
CONST_STRING(c_szVendorName,        "VendorName")
CONST_STRING(c_szWanEndpoints,      "WanEndpoints")
CONST_STRING(c_szWindowsNT,         "Windows NT")
CONST_STRING(c_szWinNT,                "WinNT")
CONST_STRING(c_szZoneList,          "ZoneList")
CONST_STRING(c_szMediaType,          "MediaType")

CONST_STRING(c_szServerNT,          "ServerNT")
CONST_STRING(c_szEnterprise,        "Enterprise")
CONST_STRING(c_szDataCenter,        "DataCenter")
CONST_STRING(c_szSecurityAppliance, "Security Appliance")

CONST_STRING(c_szDash,                  "-")
CONST_STRING(c_szBlank,                  "")

// Temporary strings - mainly for NT5 Beta1 compatibility
CONST_STRING(c_szClass,             "Class")
CONST_STRING(c_szControl,           "Control")
CONST_STRING(c_szDriver,            "Driver")
CONST_STRING(c_szEnum,              "Enum")
CONST_STRING(c_szNetworkCardsNT5Key,"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}")
CONST_STRING(c_szPnpInstanceID,     "PnpInstanceID")
CONST_STRING(c_szService,           "Service")
CONST_STRING(c_szServiceName,       "ServiceName")
CONST_STRING(c_szSystemCCS,         "SYSTEM\\CurrentControlSet")



// Registery key strings
CONST_STRING(c_szRegKeyAppletalk,"System\\CurrentControlSet\\Services\\AppleTalk")
CONST_STRING(c_szRegKeyAppletalkAdapter,"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters\\Adapters\\")
CONST_STRING(c_szRegKeyAppletalkParams,"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters")
CONST_STRING(c_szRegKeyComponentClasses, "System\\CurrentControlSet\\Control\\Network")
CONST_STRING(c_szRegKeyConnection,  "Connection")
CONST_STRING(c_szRegKeyGUID_DEVCLASS_NET,"System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}")
CONST_STRING(c_szRegKeyNbf,            "System\\CurrentControlSet\\Services\\Nbf")
CONST_STRING(c_szRegKeyNetBIOSLinkage,    "System\\CurrentControlSet\\Services\\NetBIOS\\Linkage")
CONST_STRING(c_szRegKeyNwlnkIpx,    "System\\CurrentControlSet\\Services\\NwlnkIpx")
CONST_STRING(c_szRegKeyPPPTracing,  "Software\\Microsoft\\Tracing\\PPP")
CONST_STRING(c_szRegKeyPptpProtocolParam, "System\\CurrentControlSet\\Services\\PptpProtocol\\Parameters")
CONST_STRING(c_szRegKeyProductOptions, "System\\CurrentControlSet\\Control\\ProductOptions")
CONST_STRING(c_szRegKeyRasAppletalk,"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AppleTalk")
CONST_STRING(c_szRegKeyRasIp,        "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip")
CONST_STRING(c_szRegKeyRasIpRtrMgr,  "System\\CurrentControlSet\\Services\\RemoteAccess\\RouterManagers\\Ip")
CONST_STRING(c_szRegKeyRasIpx,      "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ipx")
CONST_STRING(c_szRegKeyRasNbf,      "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Nbf")
CONST_STRING(c_szRegKeyRasProtocols,  "Software\\Microsoft\\RAS\\Protocols")
CONST_STRING(c_szRegKeyRemoteAccessParameters, "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters")
CONST_STRING(c_szRegKeyRouter,        "Software\\Microsoft\\Router")
CONST_STRING(c_szRegKeyRouterAccountingProviders,  "System\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers")
CONST_STRING(c_szRegKeyRouterAuthenticationProviders,  "System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers")
CONST_STRING(c_szRegKeyServerApplications, "System\\CurrentControlSet\\Control\\Server Applications")
CONST_STRING(c_szRegKeyTcpip,        "System\\CurrentControlSet\\Services\\Tcpip")
CONST_STRING(c_szRegKeyTcpipAdapters,    "System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters")
CONST_STRING(c_szRegKeyTcpipInterfaces,    "System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces")
CONST_STRING(c_szRegKeyTcpipParameters, "System\\CurrentControlSet\\Services\\Tcpip\\Parameters")

// Registry value strings
CONST_STRING(c_szRegValAllowNetAccess,  "AllowNetworkAccess")
CONST_STRING(c_szRegValAutoWanNet,      "AutoWanNetAllocation")
CONST_STRING(c_szRegValCalledIdInformation, "CalledIDInformation")
CONST_STRING(c_szRegValClientIp,        "AllowClientIpAddresses")
CONST_STRING(c_szRegValComponentId,        "ComponentId")
CONST_STRING(c_szRegValDeadGWDetect,    "EnableDeadGWDetect")
CONST_STRING(c_szRegValDeadGWDetectDefault,    "DeadGWDetectDefault")
CONST_STRING(c_szRegValDefaultPort,     "DefaultPort")
CONST_STRING(c_szRegValDhcpAddressing,  "UseDhcpAddressing")
CONST_STRING(c_szRegValDisAllowZones,   "DisAllowedZones")
CONST_STRING(c_szRegValDontAddDefaultGateway, "DontAddDefaultGateway")
CONST_STRING(c_szRegValDontAddDefaultGatewayDefault, "DontAddDefaultGatewayDefault")
CONST_STRING(c_szRegValDriverDesc,        "DriverDesc")
CONST_STRING(c_szRegValDynNetAddr,      "DynamicNetAddrAllocation")
CONST_STRING(c_szRegValEnableFileTracing, "EnableFileTracing")
CONST_STRING(c_szRegValEnableICMPRedirect, "EnableICMPRedirect")
CONST_STRING(c_szRegValEnableIn,    "EnableIn")
CONST_STRING(c_szRegValEnableNetbtBcastFwd, "EnableNetbtBcastFwd")
CONST_STRING(c_szRegValFirstWanNet,     "FirstWanNet")
CONST_STRING(c_szRegValFrom,            "From")
CONST_STRING(c_szRegValGlobalWanNet,    "GlobalWanNet")
CONST_STRING(c_szRegValInstallerAction, "InstallerAction")
CONST_STRING(c_szRegValIpAddr,          "IpAddress")
CONST_STRING(c_szRegValIpConfig,        "IpConfig")
CONST_STRING(c_szRegValIpEnableRouter,   "IPEnableRouter")
CONST_STRING(c_szRegValIpEnableRouterBackup,   "IpEnableRouterBackup")
CONST_STRING(c_szRegValIpMask,          "IpMask")
CONST_STRING(c_szRegValMatchingDeviceId,    "MatchingDeviceId")
CONST_STRING(c_szRegValNetCfgInstanceId,    "NetCfgInstanceID")
CONST_STRING(c_szRegValNetworkAdapterGUID, "NetworkAdapterGUID")
CONST_STRING(c_szRegValIpxAllowed,      "fIpxAllowed")
CONST_STRING(c_szRegValLanaMap,            "LanaMap")
CONST_STRING(c_szRegValLoggingFlags,    "LoggingFlags")
CONST_STRING(c_szRegValManPass,         "ManualPasswordRequired")
CONST_STRING(c_szRegValName,            "Name")
CONST_STRING(c_szRegValMask,            "Mask")
CONST_STRING(c_szRegValNetAccess,       "NetworkAccess")
CONST_STRING(c_szRegValNetBeuiAllowed,  "fNetbeuiAllowed")
CONST_STRING(c_szRegValNetRangeLower,   "NetworkRangeLowerEnd")
CONST_STRING(c_szRegValNetRangeUpper,   "NetworkRangeUpperEnd")
CONST_STRING(c_szRegValNumberLineDevices, "NumberLineDevices")
CONST_STRING(c_szRegValProductName,     "ProductName")
CONST_STRING(c_szRegValProductType,     "ProductType")
CONST_STRING(c_szRegValRemoteNode,      "AcceptRemoteNodeNumber")
CONST_STRING(c_szRegValRolesSupported,  "RolesSupported")
CONST_STRING(c_szRegValSendSignature,   "SendSignature")
CONST_STRING(c_szStandaloneSupported,   "StandaloneSupported")
CONST_STRING(c_szRegValStaticAddressPool,"StaticAddressPool")
CONST_STRING(c_szRegValTcpIpAllowed,    "fTcpIpAllowed")
CONST_STRING(c_szRegValTo,              "To")
CONST_STRING(c_szRegValWanNetPoolSize,  "WanNetPoolSize")
CONST_STRING(c_szRegValOpenIPSnap,      "OpenIPSnap" )
CONST_STRING(c_szRegValOpenMPRSnap,     "OpenMPRSnap" )
CONST_STRING(c_szRegValProductSuite,    "ProductSuite" )

CONST_STRINGA(c_sazAuthenticationHelpTopic, "RRASconcepts.chm::/sag_RRAS-Ch1_44.htm")
CONST_STRINGA(c_sazRRASDomainHelpTopic, "RRASconcepts.chm::/ras_how_enable_rras.htm")


////All the nat related constant strings
CONST_STRINGA(c_sazIPSnapHelpFile,   "mprsnap.chm")
CONST_STRING(c_szIPSnapHelpFile,   "mprsnap.chm")
CONST_STRING(c_szProtocolNameMapKey, "Software\\Microsoft\\Router\\CurrentVersion\\UI\\Ip\\ProtocolNameMap")
CONST_STRING(c_szDefault,        "Default")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ncnetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       N C N E T C F G . C P P
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <stdafx.h>
#pragma hdrstop
#include "netcfgx.h"
#include "assert.h"
//nclude "netcfgn.h"
//nclude "ncdebug.h"
//nclude "ncbase.h"
//nclude "ncmisc.h"
#include "ncnetcfg.h"
//nclude "ncreg.h"
//nclude "ncvalid.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrFindComponents
//
//  Purpose:    Find multiple INetCfgComponents with one call.  This makes
//              the error handling associated with multiple calls to
//              QueryNetCfgClass and Find much easier.
//
//  Arguments:
//      pnc              [in] pointer to INetCfg object
//      cComponents      [in] count of class guid pointers, component id
//                            pointers, and INetCfgComponent output pointers.
//      apguidClass      [in] array of class guid pointers.
//      apszwComponentId [in] array of component id pointers.
//      apncc           [out] array of returned INetCfgComponet pointers.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   22 Mar 1997
//
//  Notes:      cComponents is the count of pointers in all three arrays.
//              S_OK will still be returned even if no components were
//              found!  This is by design.
//
HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const LPCWSTR*      apszwComponentId,
    INetCfgComponent**  apncc)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszwComponentId);
    Assert (apncc);

    // Initialize the output parameters.
    //
    ZeroMemory (apncc, cComponents * sizeof(*apncc));

    // Find all of the components requested.
    // Variable initialization is important here.
    HRESULT hr = S_OK;
    ULONG i;
    for (i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        // Get the class object for this component.
        INetCfgClass* pncclass = NULL;
        hr = pnc->QueryNetCfgClass (apguidClass[i], IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
        if (SUCCEEDED(hr) && pncclass)
        {
            // Find the component.
            hr = pncclass->FindComponent (apszwComponentId[i], &apncc[i]);

            AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");

            ReleaseObj (pncclass);
			pncclass = NULL;
        }
    }

    // On any error, release what we found and set the output to NULL.
    if (FAILED(hr))
    {
        for (i = 0; i < cComponents; i++)
        {
            ReleaseObj (apncc[i]);
            apncc[i] = NULL;
        }
    }
    // Otherwise, normalize the HRESULT.  (i.e. don't return S_FALSE)
    else
    {
        hr = S_OK;
    }

    TraceResult ("HrFindComponents", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ncnetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCNETCFG_H_
#define _NCNETCFG_H_

#include "netcfgx.h"
#include "nccom.h"


HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const LPCWSTR*      apszwComponentId,
    INetCfgComponent**  apncc);


//------------------------------------------------------------------------
// CIterNetCfgComponent - iterator for IEnumNetCfgComponent
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgClass::EnumComponents to get the enumerator.
//
class CIterNetCfgComponent : public CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*>
{
public:
    CIterNetCfgComponent (INetCfg* pnc, const GUID* pguid) NOTHROW;
    CIterNetCfgComponent (INetCfgClass* pncclass) NOTHROW;
    ~CIterNetCfgComponent () NOTHROW { ReleaseObj(m_pec); m_pec = NULL; }

protected:
    IEnumNetCfgComponent* m_pec;
};


inline CIterNetCfgComponent::CIterNetCfgComponent(INetCfg* pnc, const GUID* pguid) NOTHROW
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    INetCfgClass* pncclass = NULL;
    m_hrLast = pnc->QueryNetCfgClass(pguid, IID_INetCfgClass,
                reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(m_hrLast) && pncclass)
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pncclass->EnumComponents(&m_pec);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pec);
        }

        ReleaseObj(pncclass);
		pncclass = NULL;
    }

//    TraceHr (ttidError, FAL, m_hrLast, FALSE,
//        "CIterNetCfgComponent::CIterNetCfgComponent");
}

inline CIterNetCfgComponent::CIterNetCfgComponent(INetCfgClass* pncclass) NOTHROW
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
//    AssertH(pncclass);

    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    m_hrLast = pncclass->EnumComponents(&m_pec);
    if (SUCCEEDED(m_hrLast))
    {
        SetEnumerator(m_pec);
    }

//    TraceHr (ttidError, FAL, m_hrLast, FALSE,
//        "CIterNetCfgComponent::CIterNetCfgComponent");
}

#endif // _NCNETCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ncutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//  File:       S T E E L H E A D . C P P
//
//  Contents:   Implementation of Steelhead configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#pragma hdrstop
#include "ncutil.h"


extern DWORD	g_dwTraceHandle;

void TraceError(LPCSTR pszString, HRESULT hr)
{
	if (!SUCCEEDED(hr))
	{
		TraceResult(pszString, hr);
	}
}

void TraceResult(LPCSTR pszString, HRESULT hr)
{
	if (SUCCEEDED(hr))
		TracePrintf(g_dwTraceHandle,
					_T("%hs succeeded : hr = %08lx"),
					pszString, hr);
	else
		TracePrintf(g_dwTraceHandle,
					_T("%hs failed : hr = %08lx"),
					pszString, hr);
}

void TraceSz(LPCSTR pszString)
{
	TracePrintf(g_dwTraceHandle,
				_T("%hs"),
				pszString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ncutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ncutil.h
//
//--------------------------------------------------------------------------

#pragma once

#define NOTHROW
inline void AddRefObj(IUnknown *punk)
{
	if (punk)
		punk->AddRef();
}

inline void ReleaseObj(IUnknown * punk)
{
	if (punk)
		punk->Release();
}

#define Assert(x)	assert(x)
#define AssertSz(x,sz)	assert(x)


#define celems(rgx)		(sizeof(rgx) / sizeof(*rgx))
#define TraceTag(a,b,c)
#define TraceErrorOptional(a,b,c)

void TraceError(LPCSTR pszString, HRESULT hr);
void TraceResult(LPCSTR pszString, HRESULT hr);
void TraceSz(LPCSTR pszString);





/*---------------------------------------------------------------------------
	Class:	RtrCriticalSection

	This class is used to support entering/leaving of critical sections.
	Put this class at the top of a function that you want protected.
 ---------------------------------------------------------------------------*/

class RtrCriticalSection
{
public:
	RtrCriticalSection(CRITICAL_SECTION *pCritSec)
			: m_pCritSec(pCritSec)
	{
//		IfDebug(m_cEnter=0;)
//		Assert(m_pCritSec);
		Enter();
	}
	
	~RtrCriticalSection()
	{
		Detach();
	}

	void	Enter()
	{
		if (m_pCritSec)
		{
//			IfDebug(m_cEnter++;)
			EnterCriticalSection(m_pCritSec);
//			AssertSz(m_cEnter==1, "EnterCriticalSection called too much!");
		}
	}
	
	BOOL	TryToEnter()
	{
		if (m_pCritSec)
			return TryEnterCriticalSection(m_pCritSec);
		return TRUE;
	}
	
	void	Leave()
	{
		if (m_pCritSec)
		{
//			IfDebug(m_cEnter--;)
			LeaveCriticalSection(m_pCritSec);
//			Assert(m_cEnter==0);
		}
	}

	void	Detach()
	{
		Leave();
		m_pCritSec = NULL;
	}
	
private:
	CRITICAL_SECTION *	m_pCritSec;
//	IfDebug(int m_cEnter;)
};



inline LPWSTR StrDupW(LPCWSTR pswz)
{
	LPWSTR	pswzcpy = new WCHAR[lstrlenW(pswz)+1];
	return lstrcpyW(pswzcpy, pswz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ndisutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) 1997-1999, Microsoft Corporation     **/
/**********************************************************************/

/*
	ndisutil.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ndisutil.h"
#include "rtrstr.h"

#include "raserror.h"

#include "ustringp.h"
#include <wchar.h>
#include <assert.h>
#include "ncutil.h"
#include <ndispnp.h>


#define c_szDevice             L"\\Device\\"
#define c_szEmpty			L""
//-------------------------------------------------------------------
// Function:    SetUnicodeString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      psz - the WSTR to use to initialize the UNICODE_STRING
//
// Notes:  This differs from the RtlInitUnicodeString in that the
//      MaximumLength value contains the terminating null
//
//-------------------------------------------------------------------
void
SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( psz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = (USHORT)(lstrlenW(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//-------------------------------------------------------------------
// Function:    SetUnicodeMultiString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//              multi string buffer
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      pmsz - the multi sz WSTR to use to initialize the UNICODE_STRING
//
//-------------------------------------------------------------------
void
SetUnicodeMultiString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          pmsz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);
	// Note: Length does NOT include terminating NULL
    pustr->Length = wcslen(pustr->Buffer) * sizeof(WCHAR);
    pustr->MaximumLength = pustr->Length;
}




//-------------------------------------------------------------------
// Function:    HrSendNdisHandlePnpEvent
//
// Purpose:     Send to Ndis a HandlePnpEvent notification
//
// Parameters:
//      uiLayer - either NDIS or TDI
//      uiOperation - either BIND, RECONFIGURE, or UNBIND
//      pszUpper - a WIDE string containing the upper component name
//      pszLower - a WIDE string containing the lower component name
//            This is one of the Export names from that component
//            The values NULL and c_szEmpty are both supported
//      pmszBindList - a WIDE string containing the NULL terminiated list of strings
//            representing the bindlist, vaid only for reconfigure
//            The values NULL and c_szEmpty are both supported
//      pvData - Pointer to ndis component notification data. Content
//            determined by each component.
//      dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:  Do not use this routine directly, see...
//                  HrSendNdisPnpBindOrderChange,
//                  HrSendNdisPnpBindStateChange, or
//                  HrSendNdisPnpReconfig
//
//-------------------------------------------------------------------
HRESULT
HrSendNdisHandlePnpEvent (
        UINT        uiLayer,
        UINT        uiOperation,
        LPCWSTR     pszUpper,
        LPCWSTR     pszLower,
        LPCWSTR     pmszBindList,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));
    Assert( (BIND == uiOperation) || (RECONFIGURE == uiOperation) || (UNBIND == uiOperation) );
//    AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
//            (RECONFIGURE == uiOperation) &&
//            (TDI == uiLayer) &&
//            (0 == lstrlenW( pszLower ))),
//            "bind order change requires a bind list, no lower, only for TDI, and with Reconfig for the operation" );

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
		hr = HRESULT_FROM_WIN32(GetLastError());
    }

//    TraceError( "HrSendNdisHandlePnpEvent", hr );
    return( hr );
}



//-------------------------------------------------------------------
// Function:    HrSendNdisPnpReconfig
//
// Purpose:     Send to Ndis a HandlePnpEvent reconfig notification
//
// Parameters:  uiLayer - either NDIS or TDI
//              wszUpper - a WIDE string containing the upper component name
//                         (typically a protocol)
//              wszLower - a WIDE string containing the lower component name
//                         (typically an adapter bindname) The values NULL and
//                         c_szEmpty are both supported
//              pvData - Pointer to ndis component notification data. Content
//                       determined by each component.
//              dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
//-------------------------------------------------------------------
HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        LPCWSTR     wszUpper,
        LPCWSTR     wszLower,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    Assert(NULL != wszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));

    if (NULL == wszLower)
    {
        wszLower = c_szEmpty;
    }

	WCHAR*	pLower = NULL;
//    tstring strLower;

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if ( wszLower && lstrlenW(wszLower))
    {
    	pLower = (WCHAR*)_alloca((lstrlenW(wszLower) + lstrlenW(c_szDevice) + 2) * sizeof(WCHAR));
        wcscpy(pLower, c_szDevice);
        wcscat(pLower, wszLower);
    }

    HRESULT hr = HrSendNdisHandlePnpEvent( uiLayer,
                RECONFIGURE,
                wszUpper,
                pLower,
                c_szEmpty,
                pvData,
                dwSizeData);
//    TraceError( "HrSendNdisPnpReconfig", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\remcfg.cpp ===
/**********************************************************************/
/** RemCfg.cpp : Implementation of CRemCfg                           **/
/**                                                                  **/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(C) Microsoft Corporation, 1997 - 1999      **/
/**********************************************************************/

#include "stdafx.h"
#include <ntsecapi.h>
#include <iptypes.h>
#define _PNP_POWER_
#include <ndispnp.h>
#define _USTRINGP_NO_UNICODE_STRING
#include "ustringp.h"
#include <ntddip.h>
#include <iphlpapi.h>
#include "ndisutil.h"
#include "assert.h"
#include "remras.h"

#include "atlapp.h"
#include "atltmp.h"

#include "RemCfg.h"

#include "netcfgp.h"    // private INetCfg stuff
#include "devguid.h"

#include <dnsapi.h>		// for DnsSetConfigDword()

EXTERN_C const CLSID CLSID_CNetCfg;

#include "update.h"

/////////////////////////////////////////////////////////////////////////////
// CRemCfg


BOOL                s_fWriteIPConfig;
BOOL                s_fRestartRouter;
RemCfgIPEntryList   s_IPEntryList;
extern DWORD    g_dwTraceHandle;



CRemCfg::~CRemCfg()
{
    TraceSz("CRemCfg destructor");

    DeleteCriticalSection(&m_critsec);
}

STDMETHODIMP CRemCfg::NotifyChanges(/* [in] */ BOOL fEnableRouter,
                             /* [in] */ BYTE uPerformRouterDiscovery)
{
	//Do nothing to fix bug 405636 and 345700
	//But still keep to method for compatibility with old builds
    return S_OK;
}


/*!--------------------------------------------------------------------------
    CRemCfg::SetRasEndpoints
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::SetRasEndpoints(DWORD dwFlags, DWORD dwTotalEndpoints, DWORD dwTotalIncoming, DWORD dwTotalOutgoing)
{
    return E_NOTIMPL;
}

/*!--------------------------------------------------------------------------
    CRemCfg::GetIpxVirtualNetworkNumber
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::GetIpxVirtualNetworkNumber(DWORD * pdwVNetworkNumber)
{
    //$ TODO : need to add a try/catch block around the whole thing!
    INetCfg *   pNetCfg = NULL;
    IIpxAdapterInfo *   pIpxAdapterInfo = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;

    TraceSz("CRemCfg::GetIpxVirtualNetworkNumber entered");

    if (pdwVNetworkNumber == NULL)
        return E_INVALIDARG;


    // Create the INetCfg, we're only reading so we don't
    // need to grab the write lock.
    hr = HrCreateAndInitializeINetCfg(NULL, /* &fInitCom, */
                                      &pNetCfg,
                                      FALSE /* fGetWriteLock */,
                                      0     /* cmsTimeout */,
                                      NULL  /* swzClientDesc */,
                                      NULL  /* ppszwClientDesc */);

    if (hr == S_OK)
        hr = HrGetIpxPrivateInterface(pNetCfg, &pIpxAdapterInfo);

    if (hr == S_OK)
        hr = pIpxAdapterInfo->GetVirtualNetworkNumber(&dwNetwork);

    if (hr == S_OK)
        *pdwVNetworkNumber = dwNetwork;

    if (pIpxAdapterInfo)
        pIpxAdapterInfo->Release();

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE, /* fInitCom, */
                                        pNetCfg,
                                        FALSE   /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::GetIpxVirtualNetworkNumber", hr);
    return hr;
}

/*!--------------------------------------------------------------------------
    CRemCfg::SetIpxVirtualNetworkNumber
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::SetIpxVirtualNetworkNumber(DWORD dwVNetworkNumber)
{
    //$ TODO : need to add a try/catch block around the whole thing!
    INetCfg *   pNetCfg = NULL;
    IIpxAdapterInfo *   pIpxAdapterInfo = NULL;
    HRESULT     hr = S_OK;
    CString     st;

    TraceSz("CRemCfg::SetIpxVirtualNetworkNumber entered");

    try
    {
        st.LoadString(IDS_CLIENT_DESC);
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    };

    // Create the INetCfg, we're only reading so we don't
    // need to grab the write lock.
    if (hr == S_OK)
        hr = HrCreateAndInitializeINetCfg(NULL, /* &fInitCom, */
                                          &pNetCfg,
                                          TRUE  /* fGetWriteLock */,
                                          500   /* cmsTimeout */,
                                          (LPCTSTR) st  /* swzClientDesc */,
                                          NULL  /* ppszwClientDesc */);

    if (hr == S_OK)
        hr = HrGetIpxPrivateInterface(pNetCfg, &pIpxAdapterInfo);

    if (hr == S_OK)
        hr = pIpxAdapterInfo->SetVirtualNetworkNumber(dwVNetworkNumber);

    if (hr == S_OK)
        hr = pNetCfg->Apply();

    if (pIpxAdapterInfo)
        pIpxAdapterInfo->Release();

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE, /*fInitCom, */
                                        pNetCfg,
                                        TRUE    /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::SetIpxVirtualNetworkNumber", hr);
    return hr;
}

/*!--------------------------------------------------------------------------
    CRemCfg::GetIpInfo
        -
    Author: TongLu, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::GetIpInfo(const GUID *pGuid, REMOTE_RRAS_IPINFO * * ppInfo)
{
    // TODO: Add your implementation code here

    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_RRAS_IPINFO * pRemoteRrasIpInfo = NULL;

    TraceSz("CRemCfg::GetIpInfo entered");

    if ((pGuid == NULL) || (ppInfo == NULL))
        return E_INVALIDARG;

    // Create the INetCfg, we're only reading so we don't
    // need to grab the write lock.
    hr = HrCreateAndInitializeINetCfg(NULL, /* &fInitCom, */
                                      &pNetCfg,
                                      FALSE /* fGetWriteLock */,
                                      0     /* cmsTimeout */,
                                      NULL  /* swzClientDesc */,
                                      NULL  /* ppszwClientDesc */);

    if (hr == S_OK)
    {
        hr = HrGetIpPrivateInterface(pNetCfg, &pTcpipProperties);
        TraceResult("HrGetIpPrivateInterface", hr);
    }

    if (hr == S_OK)
    {
        hr = pTcpipProperties->GetIpInfoForAdapter(pGuid, &pRemoteIpInfo);

        if (hr != S_OK)
        {
            OLECHAR szBuffer[256];
            CHAR    szOutBuffer[256];

            StringFromGUID2(*pGuid, szBuffer, 256);

            wsprintfA(szOutBuffer, "ITcpipProperties::GetIpInfoForAdapter(%ls)",
                      szBuffer);
            TraceResult(szOutBuffer, hr);
        }
    }

    if (hr == S_OK)
    {
        // Need to duplicate the functionality (best to keep the
        // memory allocations separate).

        // Need to allocate the memory for the structure
        pRemoteRrasIpInfo = (REMOTE_RRAS_IPINFO *) CoTaskMemAlloc(sizeof(REMOTE_RRAS_IPINFO));
        if (!pRemoteRrasIpInfo)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        ::ZeroMemory(pRemoteRrasIpInfo, sizeof(*pRemoteRrasIpInfo));

        // Set dhcp
        pRemoteRrasIpInfo->dwEnableDhcp = pRemoteIpInfo->dwEnableDhcp;
//      pRemoteRrasIpInfo->dwEnableDhcp = FALSE;

        // Allocate space for each string and copy the data
//      pRemoteRrasIpInfo->bstrIpAddrList =
//                  SysAllocString(_T("1.2.3.4,1.2.3.5"));
//      pRemoteRrasIpInfo->bstrSubnetMaskList =
//                  SysAllocString(_T("255.0.0.0,255.0.0.0"));
//      pRemoteRrasIpInfo->bstrOptionList =
//                  SysAllocString(_T("12.12.13.15,12.12.13.14"));
        pRemoteRrasIpInfo->bstrIpAddrList =
                    SysAllocString(pRemoteIpInfo->pszwIpAddrList);
        if (!pRemoteRrasIpInfo->bstrIpAddrList &&
            pRemoteIpInfo->pszwIpAddrList)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        pRemoteRrasIpInfo->bstrSubnetMaskList =
                    SysAllocString(pRemoteIpInfo->pszwSubnetMaskList);
        if (!pRemoteRrasIpInfo->bstrSubnetMaskList &&
            pRemoteIpInfo->pszwSubnetMaskList)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        pRemoteRrasIpInfo->bstrOptionList =
                    SysAllocString(pRemoteIpInfo->pszwOptionList);
        if (!pRemoteRrasIpInfo->bstrOptionList &&
            pRemoteIpInfo->pszwOptionList)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

Error:
    if (!SUCCEEDED(hr))
    {
        if (pRemoteRrasIpInfo)
        {
            SysFreeString(pRemoteRrasIpInfo->bstrIpAddrList);
            SysFreeString(pRemoteRrasIpInfo->bstrSubnetMaskList);
            SysFreeString(pRemoteRrasIpInfo->bstrOptionList);
            CoTaskMemFree(pRemoteRrasIpInfo);
        }
    }
    else
    {
        *ppInfo = pRemoteRrasIpInfo;
        pRemoteRrasIpInfo = NULL;
    }

    if (pRemoteIpInfo)
    {
        CoTaskMemFree(pRemoteIpInfo);
        pRemoteIpInfo = NULL;
    }

    if (pTcpipProperties)
        pTcpipProperties->Release();

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE,
                                        pNetCfg,
                                        FALSE   /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::GetIpInfo", hr);
    return hr;
}

/*!--------------------------------------------------------------------------
    CRemCfg::SetIpInfo
        -
    Author: TongLu, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::SetIpInfo(const GUID *pGuid, REMOTE_RRAS_IPINFO * pIpInfo)
{
    // TODO: Add your implementation code here

    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    CString     st;
    RemCfgIPEntry * pIpEntry = NULL;
    RtrCriticalSection  cs(&m_critsec);

    TraceSz("CRemCfg::SetIpInfo entered");

    if ((pGuid == NULL) || (pIpInfo == NULL))
    {
        TraceResult("CRemCfg::SetIpInfo", E_INVALIDARG);
        return E_INVALIDARG;
    }

    try
    {
        st.LoadString(IDS_CLIENT_DESC);
        pIpEntry = new RemCfgIPEntry;
        pIpEntry->m_newIPInfo.pszwIpAddrList = NULL;
        pIpEntry->m_newIPInfo.pszwSubnetMaskList = NULL;
        pIpEntry->m_newIPInfo.pszwOptionList = NULL;

    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    };

    // Create the INetCfg, we're only reading so we don't
    // need to grab the write lock.
    if (hr == S_OK)
        hr = HrCreateAndInitializeINetCfg(NULL,
                                          &pNetCfg,
                                          TRUE  /* fGetWriteLock */,
                                          500   /* cmsTimeout */,
                                          (LPCTSTR) st  /* swzClientDesc */,
                                          NULL  /* ppszwClientDesc */);

    if (hr == S_OK)
        hr = HrGetIpPrivateInterface(pNetCfg, &pTcpipProperties);

    if (hr == S_OK)
    {
        pIpEntry->m_IPGuid = *pGuid;
        pIpEntry->m_newIPInfo.dwEnableDhcp = pIpInfo->dwEnableDhcp;
        pIpEntry->m_newIPInfo.pszwIpAddrList = StrDupW((LPWSTR) pIpInfo->bstrIpAddrList);
        pIpEntry->m_newIPInfo.pszwSubnetMaskList = StrDupW((LPWSTR) pIpInfo->bstrSubnetMaskList);
        pIpEntry->m_newIPInfo.pszwOptionList = StrDupW((LPWSTR) pIpInfo->bstrOptionList);

        hr = pTcpipProperties->SetIpInfoForAdapter(pGuid, &(pIpEntry->m_newIPInfo));
    }

    if (hr == S_OK)
    {
        // Add this to the list of OK IP address changes
        s_IPEntryList.Add(pIpEntry);
        pIpEntry = NULL;
        s_fWriteIPConfig = TRUE;
    }

    // this now gets done in CommitIPInfo
//  if (hr == S_OK)
//      hr = pNetCfg->Apply();

//Error:
    if (pTcpipProperties)
        pTcpipProperties->Release();

    if (pIpEntry)
    {
        delete pIpEntry->m_newIPInfo.pszwIpAddrList;
        delete pIpEntry->m_newIPInfo.pszwSubnetMaskList;
        delete pIpEntry->m_newIPInfo.pszwOptionList;
        delete pIpEntry;
    }

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE,
                                        pNetCfg,
                                        TRUE    /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::SetIpInfo", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrCleanRouterManagerEntries
//
//  Purpose:    Remove all Router Manager entries from the registry.
//
//  Arguments:
//
//  Returns:
//
//  Author:     MikeG (a-migall)    6 Nov 1998
//
//  Notes:
//
HRESULT
HrCleanRouterManagerEntries()
{
    // Open a connection to the registry key so we can "clean"
    // the registry entries before an install/update to ensure
    // that we can start with a "clean" state.
    CRegKey rk;
    long lRes = rk.Open(HKEY_LOCAL_MACHINE,
                        _T("System\\CurrentControlSet\\Services\\RemoteAccess\\RouterManagers"));
    Assert(rk.m_hKey != NULL);
    HRESULT hr = S_OK;
    if (lRes == ERROR_FILE_NOT_FOUND)   // if key doesn't exist, exit...
        return hr;
    if (lRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRes);
        TraceError ("HrCleanRouterManagerEntries", hr);
        return hr;
    }

    // Eliminate the IP transport subkey.
    lRes = rk.DeleteSubKey(_T("Ip"));
    if (lRes > ERROR_FILE_NOT_FOUND)
    {
        hr = HRESULT_FROM_WIN32(lRes);
        TraceError ("HrCleanRouterManagerEntries", hr);
        return hr;
    }

    // Eliminate the IPX transport subkey.
    lRes = rk.DeleteSubKey(_T("Ipx"));
    if (lRes > ERROR_FILE_NOT_FOUND)
        hr = HRESULT_FROM_WIN32(lRes);

    TraceError ("HrCleanRouterManagerEntries", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     RecurseDeleteKey
//
//  Purpose:    Delete a named registry key and all of its subkeys.
//
//  Arguments:
//
//  Returns:
//
//  Author:     MikeG (a-migall)    6 Nov 1998
//
//  Notes:      Shamelessly stolen from Kenn's code in ...\tfscore\tregkey.h.
//
long
RecurseDeleteKey(
    IN CRegKey  &rk,
    IN LPCTSTR lpszKey)
{
    Assert(!::IsBadReadPtr(&rk, sizeof(CRegKey)));
    Assert(rk.m_hKey != NULL);
    Assert(!::IsBadStringPtr(lpszKey, ::lstrlen(lpszKey)));

    CRegKey key;
    long lRes = key.Open(HKEY(rk), lpszKey);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = 256;

    while (::RegEnumKeyEx(HKEY(key),
                          0,
                          szBuffer,
                          &dwSize,
                          NULL,
                          NULL,
                          NULL,
                          &time) == ERROR_SUCCESS)
    {
        lRes = RecurseDeleteKey(key, szBuffer);
        if (lRes != ERROR_SUCCESS)
            return lRes;
        dwSize = 256;
    }

    key.Close();
    return rk.DeleteSubKey(lpszKey);
}


//+---------------------------------------------------------------------------
//
//  Member:     HrCleanRouterInterfacesEntries
//
//  Purpose:    Remove all Router Interface entries from the registry.
//
//  Arguments:
//
//  Returns:
//
//  Author:     MikeG (a-migall)    6 Nov 1998
//
//  Notes:
//
HRESULT
HrCleanRouterInterfacesEntries()
{
    // Open a connection to the registry key so we can "clean" the
    // registry entries before an install/update to ensure that we
    // can start with a "clean" state.
    CRegKey rk;
    long lRes = rk.Open(HKEY_LOCAL_MACHINE,
                        _T("System\\CurrentControlSet\\Services\\RemoteAccess\\Interfaces"));
    Assert(rk.m_hKey != NULL);
    HRESULT hr = S_OK;
    if (lRes == ERROR_FILE_NOT_FOUND)   // if key doesn't exist, exit...
        return hr;
    if (lRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRes);
        TraceError ("HrCleanRouterInterfacesEntries", hr);
        return hr;
    }

    // Determine how many interfaces have been defined.
    DWORD dwSubKeyCnt = 0;
    lRes = ::RegQueryInfoKey(HKEY(rk),          // handle to key to query
                             NULL,              // address of buffer for class string
                             NULL,              // address of size of class string buffer
                             NULL,              // reserved...
                             &dwSubKeyCnt,      // address of buffer for number of subkeys
                             NULL,              // address of buffer for longest subkey name length
                             NULL,              // address of buffer for longest class string length
                             NULL,              // address of buffer for number of value entries
                             NULL,              // address of buffer for longest value name length
                             NULL,              // address of buffer for longest value data length
                             NULL,              // address of buffer for security descriptor length
                             NULL);             // address of buffer for last write time
    if (lRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRes);
        TraceError ("HrCleanRouterInterfacesEntries", hr);
        return hr;
    }

    // Eliminate each of the subkeys.
    CString st;
    DWORD dwStrSize = 256;
    LPTSTR pszKeyName = st.GetBuffer(dwStrSize);
//    while (dwSubKeyCnt >= 0)
    while (TRUE)	// change from above to TRUE, and lRes from the API will cause loop to end
    {
        // Get the name of the subkey to be deleted.
        lRes = ::RegEnumKeyEx(HKEY(rk),         // handle to key to enumerate
                              --dwSubKeyCnt,    // index of subkey to enumerate
                              pszKeyName,       // address of buffer for subkey name
                              &dwStrSize,       // address for size of subkey buffer
                              NULL,             // reserved...
                              NULL,             // address of buffer for class string
                              NULL,             // address for size of class buffer
                              NULL);            // address for time key last written to
        if (lRes != ERROR_SUCCESS)
        {
            if ((lRes == ERROR_FILE_NOT_FOUND) ||
                (lRes == ERROR_NO_MORE_ITEMS))
            {
                lRes = 0;   // we've run out of keys; so, we can successfuly exit.
            }
            break;
        }

        // Delete the key and all of its children.
        lRes = RecurseDeleteKey(rk, pszKeyName);
        if (lRes > ERROR_FILE_NOT_FOUND)
            break;

        // Cleanup for next pass.
        dwStrSize = 256;
        ::ZeroMemory(pszKeyName, (dwStrSize*sizeof(TCHAR)));
    }
    st.ReleaseBuffer();

    hr = HRESULT_FROM_WIN32(lRes);
    TraceError ("HrCleanRouterInterfacesEntries", hr);
    return hr;
}


STDMETHODIMP  CRemCfg::UpgradeRouterConfig()
{
    HRESULT     hr = S_OK;
    INetCfg *   pNetCfg = NULL;

    TraceSz("CRemCfg::UpgradeRouterConfig entered");

    try
    {
        // This is a two-step process
        CSteelhead      update;
        CString     st;

        st.LoadString(IDS_CLIENT_DESC);

        // First get the INetCfg
        hr = HrCreateAndInitializeINetCfg(NULL, /* &fInitCom, */
                                          &pNetCfg,
                                          FALSE /* fGetWriteLock */,
                                          500       /* cmsTimeout */,
                                          (LPCTSTR) st  /* swzClientDesc */,
                                          NULL  /* ppszwClientDesc */);

        if (hr == S_OK)
        {
            update.Initialize(pNetCfg);
            hr = update.HrFindOtherComponents();
        }

        if (hr == S_OK)
        {
            // Delete all previous router configs so we can get back
            // to a "clean" install point.
            hr = HrCleanRouterManagerEntries();
            Assert(SUCCEEDED(hr));
            hr = HrCleanRouterInterfacesEntries();
            Assert(SUCCEEDED(hr));

            // Now create the router config info.
            hr = update.HrUpdateRouterConfiguration();
            Assert(SUCCEEDED(hr));

            update.ReleaseOtherComponents();

            RegFlushKey(HKEY_LOCAL_MACHINE);
        }
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE, /* fInitCom, */
                                        pNetCfg,
                                        FALSE    /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::UpgradeRouterConfig", hr);
    return hr;
}

STDMETHODIMP CRemCfg::SetUserConfig(LPCOLESTR pszService,
                                    LPCOLESTR pszNewGroup)
{
    DWORD       err;
    HRESULT     hr = S_OK;

    try
    {
        err = SvchostChangeSvchostGroup(pszService, pszNewGroup);

        hr = HRESULT_FROM_WIN32(err);
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }

    TraceResult("CRemCfg::SetUserConfig", hr);
    return hr;
}

/*!--------------------------------------------------------------------------
	CRemCfg::RestartRouter
		Implementation of IRemoteRouterRestart::RestartRouter
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::RestartRouter(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    try
    {
        // the router will be restarted when remrras.exe shuts down
        // ------------------------------------------------------------
        s_fRestartRouter = TRUE;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    

    return hr;
}


/*!--------------------------------------------------------------------------
	CRemCfg::SetDnsConfig
		Implementation of IRemoteSetDnsConfig::SetDnsConfig
	Author: kmurthy
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::SetDnsConfig(/* [in] */ DWORD dwConfigId,
								   /* [in] */ DWORD dwNewValue)
{
    HRESULT hr = S_OK;
	long ret;

    try
    {
		ret = DnsSetConfigDword((DNS_CONFIG_TYPE)dwConfigId, NULL, dwNewValue);
    }
    catch(...)
    {
        hr = E_FAIL;
    }
    

    return hr;
}

#include<hnetcfg.h>
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

/*!--------------------------------------------------------------------------
	CRemCfg::GetIcfEnabled
		Implementation of IRemoteICFICSConfig::GetIcfEnabled
		Returns TRUE if ICF (firewall) is enabled on the machine
	Author: kmurthy
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::GetIcfEnabled(/* [out] */ BOOL * status)
{
    HRESULT hr = S_OK, retHr = S_OK;
	IHNetCfgMgr *pCfgMgr = NULL;
	IHNetFirewallSettings *pFwSettings = NULL;
	IEnumHNetFirewalledConnections *pFwEnum = NULL;
	IHNetFirewalledConnection *pFwConn = NULL;
	BOOL fwEnabled = FALSE;
	ULONG ulCount = 0;

	try
	{
		//Check for connection firewall (ICF)
		do {
			// Create the homenet configuration manager
			hr = CoCreateInstance(
				CLSID_HNetCfgMgr,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_PPV_ARG(IHNetCfgMgr,
				&pCfgMgr));
			
			if (FAILED(hr))
			{
				break;
			}
			//Get pointer to Firewall settings interface
			hr = pCfgMgr->QueryInterface(IID_PPV_ARG(IHNetFirewallSettings, &pFwSettings));
			if (FAILED(hr))
			{
				break;
			}
			
			//Enumurate the firewalled connections
			hr = pFwSettings->EnumFirewalledConnections(&pFwEnum);
			if (FAILED(hr))
			{
				break;
			}
			
			hr = pFwEnum->Next(1, &pFwConn, &ulCount);
			if(FAILED(hr) || ulCount != 1){
				break;
			}
			
			//If it comes here, that means firewall is enabled on atleast
			// one connection
			fwEnabled = TRUE;
			
		} while(FALSE);
		
		if(pCfgMgr) pCfgMgr->Release();
		if(pFwSettings) pFwSettings->Release();
		if(pFwEnum) pFwEnum->Release();
		if(pFwConn) pFwConn->Release();
		
		*status = fwEnabled;
		
	}
    catch(...)
    {
        retHr = E_FAIL;
    }
    

    return retHr;
}

/*!--------------------------------------------------------------------------
	CRemCfg::GetIcsEnabled
		Implementation of IRemoteICFICSConfig::GetIcsEnabled
		Returns TRUE if ICS (connection sharing) is enabled on the machine
	Author: kmurthy
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRemCfg::GetIcsEnabled(/* [out] */ BOOL * status)
{
    HRESULT hr = S_OK, retHr = S_OK;
	IHNetCfgMgr *pCfgMgr = NULL;
	IHNetIcsSettings *pIcsSettings = NULL;
	IEnumHNetIcsPublicConnections* pHNetEnumPub = NULL;
	IHNetIcsPublicConnection *pIHNetIcsPublic = NULL;
	BOOL csEnabled = FALSE;
	ULONG ulCount = 0;

	try
	{
		//Check for connection firewall (ICF)
		do {
			// Create the homenet configuration manager
			hr = CoCreateInstance(
				CLSID_HNetCfgMgr,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_PPV_ARG(IHNetCfgMgr,
				&pCfgMgr));
			
			if (FAILED(hr))
			{
				break;
			}
			// Get the ICS settings interface
			hr = pCfgMgr->QueryInterface(IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings));
			if (FAILED(hr))
			{
				break;
			}
			
			hr = pIcsSettings->EnumIcsPublicConnections( &pHNetEnumPub );
			if (FAILED(hr))
			{
				break;
			}
			
			hr = pHNetEnumPub->Next( 1, &pIHNetIcsPublic, &ulCount);
			if(FAILED(hr) || ulCount != 1){
				break;
			}
			
			//If it comes here, that means connection sharing is enabled on atleast
			// one connection
			csEnabled = TRUE;
			
		} while(FALSE);
		
       if(pCfgMgr) pCfgMgr->Release();
       if(pIcsSettings) pIcsSettings->Release();
       if(pHNetEnumPub) pHNetEnumPub->Release();
       if(pIHNetIcsPublic) pIHNetIcsPublic->Release();
		
		*status = csEnabled;
		
	}
    catch(...)
    {
        retHr = E_FAIL;
    }
    

    return retHr;
}





HRESULT CommitIPInfo()
{
    // TODO: Add your implementation code here

    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    CString     st;
    WCHAR       swzGuid[256];

    TraceSz("CRemCfg::CommitIpInfo entered");

    try
    {
        st.LoadString(IDS_CLIENT_DESC);
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    };

    // Create the INetCfg, we're only reading so we don't
    // need to grab the write lock.
    if (hr == S_OK)
        hr = HrCreateAndInitializeINetCfg(NULL,
                                          &pNetCfg,
                                          TRUE  /* fGetWriteLock */,
                                          500   /* cmsTimeout */,
                                          (LPCTSTR) st  /* swzClientDesc */,
                                          NULL  /* ppszwClientDesc */);

    if (hr == S_OK)
        hr = HrGetIpPrivateInterface(pNetCfg, &pTcpipProperties);

    if (hr == S_OK)
    {
        RemCfgIPEntry * pIpEntry = NULL;

        for (int i=0; i<s_IPEntryList.GetSize(); i++)
        {
            pIpEntry = s_IPEntryList[i];

            hr = pTcpipProperties->SetIpInfoForAdapter(
                &(pIpEntry->m_IPGuid),
                &(pIpEntry->m_newIPInfo));

            StringFromGUID2(pIpEntry->m_IPGuid,
                            swzGuid, 128);

            TracePrintf(g_dwTraceHandle,
                        _T("Setting IP info for %ls returned 0x%08lx"),
                        swzGuid, hr);
            TracePrintf(g_dwTraceHandle,
                        _T("DHCP Enabled : %d"),
                        pIpEntry->m_newIPInfo.dwEnableDhcp);
            if (pIpEntry->m_newIPInfo.pszwIpAddrList)
                TracePrintf(g_dwTraceHandle,
                            _T("    IP Address : %ls"),
                            pIpEntry->m_newIPInfo.pszwIpAddrList);
            if (pIpEntry->m_newIPInfo.pszwSubnetMaskList)
                TracePrintf(g_dwTraceHandle,
                            _T("    Subnet masks : %ls"),
                            pIpEntry->m_newIPInfo.pszwSubnetMaskList);
            if (pIpEntry->m_newIPInfo.pszwOptionList)
                TracePrintf(g_dwTraceHandle,
                            _T("    Gateway List : %ls"),
                            pIpEntry->m_newIPInfo.pszwOptionList);

        }
    }

    if (hr == S_OK)
    {
        hr = pNetCfg->Apply();
        TraceResult("CRemCfg::CommitIpInfo calling Apply", hr);
    }

    if (hr == S_OK)
    {
        // Release all memory
        for (int i=0; i<s_IPEntryList.GetSize(); i++)
        {
            RemCfgIPEntry * pIpEntry = s_IPEntryList[i];
            delete pIpEntry->m_newIPInfo.pszwIpAddrList;
            delete pIpEntry->m_newIPInfo.pszwSubnetMaskList;
            delete pIpEntry->m_newIPInfo.pszwOptionList;
            delete pIpEntry;
        }
        s_IPEntryList.RemoveAll();
        s_fWriteIPConfig = FALSE;
    }


//Error:
    if (pTcpipProperties)
        pTcpipProperties->Release();

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE,
                                        pNetCfg,
                                        TRUE    /* fHasLock */);
        pNetCfg = NULL;
    }

    TraceResult("CRemCfg::CommitIpInfo", hr);
    return hr;
}


/*!--------------------------------------------------------------------------
    HrGetIpxPrivateInterface
        -
    Author: ScottBri, KennT
 ---------------------------------------------------------------------------*/
HRESULT HrGetIpxPrivateInterface(INetCfg* pNetCfg,
                                 IIpxAdapterInfo** ppIpxAdapterInfo)
{
    HRESULT hr;
    INetCfgClass* pncclass = NULL;

    if ((pNetCfg == NULL) || (ppIpxAdapterInfo == NULL))
        return E_INVALIDARG;

    hr = pNetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NETTRANS, IID_INetCfgClass,
                reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        INetCfgComponent * pnccItem = NULL;

        // Find the component.
        hr = pncclass->FindComponent(TEXT("MS_NWIPX"), &pnccItem);
        //AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");
        if (S_OK == hr)
        {
            INetCfgComponentPrivate* pinccp = NULL;
            hr = pnccItem->QueryInterface(IID_INetCfgComponentPrivate,
                                          reinterpret_cast<void**>(&pinccp));
            if (SUCCEEDED(hr))
            {
                hr = pinccp->QueryNotifyObject(IID_IIpxAdapterInfo,
                                     reinterpret_cast<void**>(ppIpxAdapterInfo));
                pinccp->Release();
            }
        }

        if (pnccItem)
            pnccItem->Release();
    }

    if (pncclass)
        pncclass->Release();

    // S_OK indicates success (interface returned)
    // S_FALSE indicates Ipx not installed
    // other values are errors
    TraceResult("HrGetIpxPrivateInterface", hr);
    return hr;
}


/*!--------------------------------------------------------------------------
    HrGetIpPrivateInterface
        -
    Author: TongLu, KennT
 ---------------------------------------------------------------------------*/
HRESULT HrGetIpPrivateInterface(INetCfg* pNetCfg,
                                ITcpipProperties **ppTcpProperties)
{
    HRESULT hr;
    INetCfgClass* pncclass = NULL;

    if ((pNetCfg == NULL) || (ppTcpProperties == NULL))
        return E_INVALIDARG;

    hr = pNetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NETTRANS, IID_INetCfgClass,
                reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        INetCfgComponent * pnccItem = NULL;

        // Find the component.
        hr = pncclass->FindComponent(TEXT("MS_TCPIP"), &pnccItem);
        //AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");
        if (S_OK == hr)
        {
            INetCfgComponentPrivate* pinccp = NULL;
            hr = pnccItem->QueryInterface(IID_INetCfgComponentPrivate,
                                          reinterpret_cast<void**>(&pinccp));
            if (SUCCEEDED(hr))
            {
                hr = pinccp->QueryNotifyObject(IID_ITcpipProperties,
                                     reinterpret_cast<void**>(ppTcpProperties));
                pinccp->Release();
            }
        }

        if (pnccItem)
            pnccItem->Release();
    }

    if (pncclass)
        pncclass->Release();

    // S_OK indicates success (interface returned)
    // S_FALSE indicates Ipx not installed
    // other values are errors
    TraceResult("HrGetIpPrivateInterface", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::LockForWrite
//      szwClientDesc   [in]   See INetCfg::LockForWrite
//      ppszwClientDesc [out]   See INetCfg::LockForWrite
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR *    ppszwClientDesc)
{
//    ASSERT (ppnc);

    // Initialize the output parameter.
    *ppnc = NULL;

    if (ppszwClientDesc)
        *ppszwClientDesc = NULL;

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, reinterpret_cast<void**>(&pnc));
        TraceResult("HrCreateAndInitializeINetCfg - CoCreateInstance(CLSID_CNetCfg)", hr);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                TraceResult("HrCreateAndInitializeINetCfg - QueryInterface(IID_INetCfgLock", hr);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, szwClientDesc,
                                               ppszwClientDesc);
                    TraceResult("HrCreateAndInitializeINetCfg - INetCfgLock::LockForWrite", hr);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                TraceResult("HrCreateAndInitializeINetCfg - Initialize", hr);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    if (pnc)
                        pnc->AddRef();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);
            pnclock = NULL;

            ReleaseObj(pnc);
            pnc = NULL;
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    TraceResult("HrCreateAndInitializeINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
//    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);
    pnc = NULL;

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    TraceResult("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
            pnclock = NULL;
        }
    }

    TraceResult("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ndisutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ndisutil.h
//
//--------------------------------------------------------------------------

// NdisUtil header file.
// This is for everything that shouldn't be exported.


#ifndef _NDISUTIL_H_
#define _NDISUTIL_H_


void	NotifyTcpipOfChanges(LPCTSTR pszMachineName);


HRESULT
HrSendNdisHandlePnpEvent (
        UINT        uiLayer,
        UINT        uiOperation,
        LPCWSTR     pszUpper,
        LPCWSTR     pszLower,
        LPCWSTR     pmszBindList,
        PVOID       pvData,
        DWORD       dwSizeData);

HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        LPCWSTR     wszUpper,
        LPCWSTR     wszLower,
        PVOID       pvData,
        DWORD       dwSizeData);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\remrras.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       REMRRAS.CPP
//
//----------------------------------------------------------------------------


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f remrrasps.mk in the project directory.

#include "stdafx.h"
#include <iaccess.h>   // IAccessControl

#include "resource.h"
#include "initguid.h"
#include "remras.h"
#include "ncutil.h"

#include "atlapp.h"
#include "atltmp.h"

//nclude "remrras_i.c"
#include "RemCfg.h"

#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>

HRESULT CommitIPInfo();
void RestartRouter();
DWORD WaitForServiceToStop(SC_HANDLE hService);


LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RemoteRouterConfig, CRemCfg)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

DWORD	g_dwTraceHandle = 0;
extern BOOL s_fWriteIPConfig;
extern BOOL s_fRestartRouter;


HRESULT	GrantAdministratorsGroupAccess()
{
    TCHAR   szBuffer[1024];
    
    IAccessControl* pAccessControl = NULL;     
    HRESULT hr = CoCreateInstance(CLSID_DCOMAccessControl, NULL, CLSCTX_INPROC_SERVER,
		IID_IAccessControl, (void**)&pAccessControl);
    if(FAILED(hr))
    	goto Error;

    // Setup the property list. We use the NULL property because we are
    // trying to adjust the security of the object itself
    ACTRL_ACCESSW access;
    ACTRL_PROPERTY_ENTRYW propEntry;
    access.cEntries = 1;
    access.pPropertyAccessList = &propEntry;
    
    ACTRL_ACCESS_ENTRY_LISTW entryList;
    propEntry.lpProperty = NULL;
    propEntry.pAccessEntryList = &entryList;
    propEntry.fListFlags = 0;

    // Setup the access control list for the default property
    ACTRL_ACCESS_ENTRYW entry;
    entryList.cEntries = 1;
    entryList.pAccessList = &entry;

    // Setup the access control entry
    entry.fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry.Access = COM_RIGHTS_EXECUTE;
    entry.ProvSpecificAccess = 0;
    entry.Inheritance = NO_INHERITANCE;
    entry.lpInheritProperty = NULL;

    // NT requires the system account to have access (for launching)
    entry.Trustee.pMultipleTrustee = NULL;
    entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    entry.Trustee.TrusteeType = TRUSTEE_IS_GROUP;

    ::LoadString(NULL, IDS_NT_AUTHORITY_ADMINISTRATORS, szBuffer,
                 256);
    entry.Trustee.ptstrName = szBuffer;
    

    hr = pAccessControl->GrantAccessRights(&access);
    if(FAILED(hr))
	{
#ifdef	__PRIVATE_DEBUG
		TCHAR	msg[1024];
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 1024, 0);
		MessageBox(NULL,msg, L"Error", MB_OK);
#endif
		goto Error;
	}

	hr = CoInitializeSecurity(pAccessControl, -1, NULL, NULL, 
					RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IDENTIFY, 
					NULL, EOAC_ACCESS_CONTROL, NULL);

Error:
	if(pAccessControl)
	    pAccessControl->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	HRESULT hRes = CoInitialize(NULL);

	hRes = GrantAdministratorsGroupAccess();
	
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance);
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	s_fWriteIPConfig = FALSE;
    s_fRestartRouter = FALSE;
	
	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Remrras, FALSE);
			nRet = _Module.UnregisterServer();
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_Remrras, TRUE);
			nRet = _Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
        if (lstrcmpi(lpszToken, _T("Restart")) == 0)
        {
            RestartRouter();
            bRun = FALSE;
            nRet = 0;
            break;
        }
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		g_dwTraceHandle = TraceRegister(_T("remrras"));
		TraceSz("Entering remrras.exe");
		
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
			REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
			DispatchMessage(&msg);

		_Module.RevokeClassObjects();

		// At this point, check the global flag to see if there is work
		// to be done.
		if (s_fWriteIPConfig)
		{
			TraceSz("The IP Configuration is being changed.");

			CoUninitialize();
			CoInitialize(NULL);
			CommitIPInfo();
		}

        if (s_fRestartRouter)
        {
            // There's no point in doing any kind of error code
            RestartRouter();
        }

		TraceSz("Exiting remrras.exe\n");
		TraceDeregister(g_dwTraceHandle);
	}

	CoUninitialize();
	return nRet;
}


static DWORD    s_dwTickBegin = 0;
static DWORD    s_dwLastCheckPoint = -1;
static DWORD    s_dwWaitPeriod = 18000;

void RestartRouter()
{
    DWORD       dwErr = ERROR_SUCCESS;
    SC_HANDLE	hScManager = 0;
    SC_HANDLE   hService = 0;
    
    //
    // Open the SCManager so that we can try to stop the service
    //
    hScManager = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hScManager == NULL)
        dwErr = ::GetLastError();


    if (hScManager && (dwErr == ERROR_SUCCESS))
    {
        hService = ::OpenService(hScManager,
                                 _T("RemoteAccess"),
                                 SERVICE_STOP | SERVICE_START |
                                 SERVICE_QUERY_STATUS);

        if (hService == NULL)
            dwErr = ::GetLastError();
    }

    if (hService && (dwErr == ERROR_SUCCESS))
    {
        SERVICE_STATUS serviceStatus;
        
        // Stop the RemoteAccess Service        
        if (::ControlService(hService, SERVICE_CONTROL_STOP,
                              &serviceStatus))
        {
            // We are now stopping the service, we need to wait
            // the proper amount of time
            s_dwTickBegin = GetTickCount();
            
            // get the wait period 
            ::ZeroMemory(&serviceStatus, sizeof(serviceStatus));
            
            if (QueryServiceStatus(hService, &serviceStatus))
                s_dwWaitPeriod = serviceStatus.dwWaitHint;
            
            dwErr = WaitForServiceToStop(hService);
        }
        else
        {
            dwErr = ::GetLastError();

            // Is the service already stopped?
            if (dwErr == ERROR_SERVICE_NOT_ACTIVE)
            {
                dwErr = ERROR_SUCCESS;
            }
        }
    }

    if (hService && (dwErr == ERROR_SUCCESS))
    {
        SERVICE_STATUS serviceStatus;
        
        // Start the RemoteAccess Service
        ::StartService(hService, NULL, NULL);
    }

    if (hService)
        ::CloseServiceHandle(hService);
    if (hScManager)
        ::CloseServiceHandle(hScManager);
}

BOOL CheckForError(SERVICE_STATUS * pServiceStats)
{
    BOOL fError = FALSE;

    DWORD dwTickCurrent = GetTickCount();

	if (pServiceStats->dwCheckPoint == 0)
	{
		// the service is in some state, not pending anything.
		// before calling this function the code should check to see if
		// the service is in the correct state.  This means it is in 
		// some unexpected state.
		fError = TRUE;
	}
	else
    if ((dwTickCurrent - s_dwTickBegin) > s_dwWaitPeriod)
    {
        // ok to check the dwCheckPoint field to see if 
        // everything is going ok
        if (s_dwLastCheckPoint == -1)
        {
            s_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        }
        else
        {
            if (s_dwLastCheckPoint >= pServiceStats->dwCheckPoint)
            {
                fError = TRUE;
            }
        }

        s_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        s_dwTickBegin = dwTickCurrent;
        s_dwWaitPeriod = pServiceStats->dwWaitHint;
    }

    return fError;
}

DWORD WaitForServiceToStop(SC_HANDLE hService)
{
	SERVICE_STATUS  serviceStatus;
    DWORD           dwErr = ERROR_SUCCESS;

    do
    {
        ::ZeroMemory(&serviceStatus, sizeof(serviceStatus));
        
        if (!QueryServiceStatus(hService, &serviceStatus))
        {
            dwErr = ::GetLastError();
            break;
        }

        // If the dwCheckpoint value is 0, then there is no start/stop/pause
        // or continue action pending (in which case we can exit no matter
        // what happened).
        if (serviceStatus.dwCurrentState == SERVICE_STOPPED)
            break;

        if (CheckForError(&serviceStatus))
        {
            // Something failed.  Report an error.
            if (serviceStatus.dwWin32ExitCode)
                dwErr = serviceStatus.dwWin32ExitCode;
            else
                dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
            break;
        }

        // Now we sleep
        Sleep(5000);
	}
    while (TRUE);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\remcfg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       remcfg.h
//
//--------------------------------------------------------------------------

// RemCfg.h : Declaration of the CRemCfg

#ifndef __REMCFG_H_
#define __REMCFG_H_


#include "resource.h"       // main symbols
#include "remras.h"
#include "ncutil.h"



/*---------------------------------------------------------------------------
	This structure contains a list of IP interfaces that have
	changed.  This information will be committed in the order in
	which they appear in the list.
 ---------------------------------------------------------------------------*/
class RemCfgIPEntry
{
public:
	GUID	m_IPGuid;
	REMOTE_IPINFO	m_newIPInfo;
};



typedef CSimpleArray<RemCfgIPEntry *> RemCfgIPEntryList;
//typedef CList<RemCfgIPEntry *, RemCfgIPEntry *> RemCfgIPEntryList;



/////////////////////////////////////////////////////////////////////////////
// CRemCfg
class ATL_NO_VTABLE CRemCfg : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRemCfg, &CLSID_RemoteRouterConfig>,
	public IRemoteRouterConfig,
	public IRemoteTCPIPChangeNotify,
	public IRemoteNetworkConfig,
    public IRemoteRouterRestart,
	public IRemoteSetDnsConfig,
	public IRemoteICFICSConfig
{
public:
	CRemCfg()
	{
		TraceSz("CRemCfg constructor");

		InitializeCriticalSection(&m_critsec);
	};
	~CRemCfg();


DECLARE_REGISTRY_RESOURCEID(IDR_REMCFG)

BEGIN_COM_MAP(CRemCfg)
	COM_INTERFACE_ENTRY(IRemoteRouterConfig)
	COM_INTERFACE_ENTRY(IRemoteNetworkConfig)
	COM_INTERFACE_ENTRY(IRemoteTCPIPChangeNotify)
    COM_INTERFACE_ENTRY(IRemoteRouterRestart)
	COM_INTERFACE_ENTRY(IRemoteSetDnsConfig)
	COM_INTERFACE_ENTRY(IRemoteICFICSConfig)
END_COM_MAP()

// IRemoteTCPIPChangeNotify
	STDMETHOD(NotifyChanges)(/* [in] */ BOOL fEnableRouter,
                          	 /* [in] */ BYTE uPerformRouterDiscovery);


// IRemoteRouterConfig
public:
	STDMETHOD(SetIpInfo)(/*[in]*/ const GUID *pGuid, /*[in]*/ REMOTE_RRAS_IPINFO *pIpInfo);
	STDMETHOD(GetIpInfo)(/*[in]*/ const GUID *pGuid, /*[out]*/ REMOTE_RRAS_IPINFO**ppInfo);
	STDMETHOD(SetIpxVirtualNetworkNumber)(/*[in]*/ DWORD dwVNetworkNumber);
	STDMETHOD(GetIpxVirtualNetworkNumber)(/*[out]*/ DWORD *pdwVNetworkNumber);
	STDMETHOD(SetRasEndpoints)(/*[in]*/ DWORD dwFlags, /*[in]*/ DWORD dwTotalEndpoints, /*[in]*/ DWORD dwTotalIncoming, /*[in]*/ DWORD dwTotalOutgoing);

// IRemoteNetworkConfig
public:
	STDMETHOD(UpgradeRouterConfig)();
	STDMETHOD(SetUserConfig)(/*[in]*/ LPCOLESTR pszService,
							 /*[in]*/ LPCOLESTR pszNewGroup);

// IRemoteRouterRestart
public:
    STDMETHOD(RestartRouter)(/*[in]*/ DWORD dwFlags);


// IRemoteSetDnsConfig
public:
    STDMETHOD(SetDnsConfig)(/* [in] */ DWORD dwConfigId,
							/* [in] */ DWORD dwNewValue);

// IRemoteICFICSConfig
public:
    STDMETHOD(GetIcfEnabled)(/* [out] */ BOOL * status);
public:
    STDMETHOD(GetIcsEnabled)(/* [out] */ BOOL * status);


protected:
	CRITICAL_SECTION	m_critsec;

	HRESULT	CommitIPInfo();
};


HRESULT HrGetIpxPrivateInterface(INetCfg* pNetCfg, 
                                 IIpxAdapterInfo** ppIpxAdapterInfo);

HRESULT HrGetIpPrivateInterface(INetCfg* pNetCfg,
								ITcpipProperties **ppTcpProperties);

HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR *    ppstrClientDesc);


HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock);

HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc);


//
// This is a private function implemented in netcfgx.dll by ShaunCo.
//
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RASCONFIGENDPOINTS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    INT     cTotalEndpoints;
    INT     cLimitSimultaneousIncomingCalls;
    INT     cLimitSimultaneousOutgoingCalls;
} RASCONFIGENDPOINTS;

typedef HRESULT (APIENTRY *PRASCONFIGUREENDPOINTS)(IN OUT RASCONFIGENDPOINTS *);

#ifdef __cplusplus
}
#endif

#endif //__REMCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\rtrstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       rtrstr.h
//
//--------------------------------------------------------------------------


#undef RTRLIB_STRING
#undef RTRLIB_STRINGA
#undef RTRLIB_STRINGW

#ifdef _RTRLIB_STRINGS_DEFINE_STRINGS

	#define RTRLIB_STRING(rg,s)	const TCHAR rg[] = TEXT(s);
	#define RTRLIB_STRINGA(rg,s) const char rg[] = s;
	#define RTRLIB_STRINGW(rg,s)	const WCHAR rg[] = s;

#else

	#define RTRLIB_STRING(rg,s)	extern const TCHAR rg[];
	#define RTRLIB_STRINGA(rg,s) extern const char rg[];
	#define RTRLIB_STRINGW(rg,s)	extern const WCHAR rg[];

#endif

RTRLIB_STRING(c_szEmpty,			"")
RTRLIB_STRING(c_szEthernetII,		"/EthII")
RTRLIB_STRING(c_szEthernetSNAP,		"/SNAP")
RTRLIB_STRING(c_szEthernet8022,		"/802.2")
RTRLIB_STRING(c_szEthernet8023,		"/802.3")
RTRLIB_STRING(c_szHexCharacters,	"0123456789ABCDEF")
RTRLIB_STRING(c_szInterfaceName,		"InterfaceName")
RTRLIB_STRING(c_szRouterInterfacesKey, "SYSTEM\\CurrentControlSet\\Services\\Router\\Interfaces")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

// BUGID: 198218 - This is imported from net\config\netcfg\rascfg\resource.h
#include <ncres.h>

#define IDS_RAS_INTERNAL_ADAPTER    (IDS_NC_RASCFG + 0)
#define IDS_RAS_LOOPBACK_ADAPTER    (IDS_NC_RASCFG + 1)
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by remrras.rc
//
#define IDS_PROJNAME                    100
#define IDR_Remrras                     101
#define IDR_REMCFG                      102
#define IDS_CLIENT_DESC					103
#define IDS_INTERNAL_ADAPTER            104
#define IDS_LOOPBACK_ADAPTER            105
#define IDS_NT_AUTHORITY_ADMINISTRATORS 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\netinfid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       N E T I N F I D . H
//
//  Contents:   Network Component IDs
//
//  Notes:
//
//  Author:     kumarp  13 Mar 1997
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#pragma hdrstop
#include "netcfgx.h"

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const __declspec(selectany)

//+---------------------------------------------------------------------------
// Network Adapters: GUID_DEVCLASS_NET

CONST_GLOBAL WCHAR c_szInfId_MS_AtmElan[]       = L"MS_AtmElan";
CONST_GLOBAL WCHAR c_szInfId_MS_IrdaMiniport[]  = L"MS_IrdaMiniport";
CONST_GLOBAL WCHAR c_szInfId_MS_L2tpMiniport[]  = L"MS_L2tpMiniport";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanAtalk[]  = L"MS_NdisWanAtalk";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanBh[]     = L"MS_NdisWanBh";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIp[]     = L"MS_NdisWanIp";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpArp[]  = L"MS_NdisWanIpArp";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpIn[]   = L"MS_NdisWanIpIn";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpOut[]  = L"MS_NdisWanIpOut";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpx[]    = L"MS_NdisWanIpx";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfIn[]  = L"MS_NdisWanNbfIn";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfOut[] = L"MS_NdisWanNbfOut";
CONST_GLOBAL WCHAR c_szInfId_MS_PptpMiniport[]  = L"MS_PptpMiniport";
CONST_GLOBAL WCHAR c_szInfId_MS_PtiMiniport[]   = L"MS_PtiMiniport";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedMP[]      = L"MS_PSchedMP";
CONST_GLOBAL WCHAR c_szInfId_MS_Wanarp[]        = L"MS_Wanarp";


//+---------------------------------------------------------------------------
// Network Protocols: GUID_DEVCLASS_NETTRANS

CONST_GLOBAL WCHAR c_szInfId_MS_AppleTalk[]     = L"MS_AppleTalk";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmArps[]       = L"MS_ATMARPS";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmLane[]       = L"MS_AtmLANE";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmUni[]        = L"MS_ATMUNI";
CONST_GLOBAL WCHAR c_szInfId_MS_DLC[]           = L"MS_DLC";
CONST_GLOBAL WCHAR c_szInfId_MS_IrDA[]          = L"MS_IrDA";
CONST_GLOBAL WCHAR c_szInfId_MS_L2TP[]          = L"MS_L2TP";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT[]         = L"MS_NetBT";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT_SMB[]     = L"MS_NetBT_SMB";
CONST_GLOBAL WCHAR c_szInfId_MS_NetMon[]        = L"MS_NetMon";
CONST_GLOBAL WCHAR c_szInfId_MS_NWIPX[]         = L"MS_NWIPX";
CONST_GLOBAL WCHAR c_szInfId_MS_NWNB[]          = L"MS_NWNB";
CONST_GLOBAL WCHAR c_szInfId_MS_NWSPX[]         = L"MS_NWSPX";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWan[]       = L"MS_NdisWan";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBEUI[]       = L"MS_NetBEUI";
CONST_GLOBAL WCHAR c_szInfId_MS_PPTP[]          = L"MS_PPTP";
CONST_GLOBAL WCHAR c_szInfId_MS_PSched[]        = L"MS_PSched";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedPC[]      = L"MS_PSchedPC";
CONST_GLOBAL WCHAR c_szInfId_MS_RawWan[]        = L"MS_RAWWAN";
CONST_GLOBAL WCHAR c_szInfId_MS_TCPIP[]         = L"MS_TCPIP";


//+---------------------------------------------------------------------------
// Network Services: GUID_DEVCLASS_NETSERVICE

CONST_GLOBAL WCHAR c_szInfId_MS_DHCPServer[]    = L"MS_DHCPServer";
CONST_GLOBAL WCHAR c_szInfId_MS_GPC[]           = L"MS_GPC";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBIOS[]       = L"MS_NetBIOS";
CONST_GLOBAL WCHAR c_szInfId_MS_NwSapAgent[]    = L"MS_NwSapAgent";
CONST_GLOBAL WCHAR c_szInfId_MS_RasCli[]        = L"MS_RasCli";
CONST_GLOBAL WCHAR c_szInfId_MS_RasMan[]        = L"MS_RasMan";
CONST_GLOBAL WCHAR c_szInfId_MS_RasRtr[]        = L"MS_RasRtr";
CONST_GLOBAL WCHAR c_szInfId_MS_RasSrv[]        = L"MS_RasSrv";;
CONST_GLOBAL WCHAR c_szInfId_MS_Server[]        = L"MS_Server";
CONST_GLOBAL WCHAR c_szInfId_MS_Steelhead[]     = L"MS_Steelhead";

//+---------------------------------------------------------------------------
// Network Clients: GUID_DEVCLASS_NETCLIENT

CONST_GLOBAL WCHAR c_szInfId_MS_MSClient[]      = L"MS_MSClient";
CONST_GLOBAL WCHAR c_szInfId_MS_NWClient[]      = L"MS_NWClient";


// Taken from ncstrs.cpp
CONST_GLOBAL WCHAR c_szBiNdis5[]                = L"ndis5";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       STDAFX.CPP
//
//----------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
//#include <statreg.h>
//#include <statreg.cpp>
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A49C3E9C_A3F8_11D1_9369_00C04FC9DA04__INCLUDED_)
#define AFX_STDAFX_H__A49C3E9C_A3F8_11D1_9369_00C04FC9DA04__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>

#include "rtutils.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A49C3E9C_A3F8_11D1_9369_00C04FC9DA04__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\update.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       U P D A T E . H
//
//  Contents:   Declaration of RAS configuration objects.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
//nclude <ncxbase.h>
//nclude <nceh.h>
//nclude <notifval.h>
#include <mprapi.h>
//nclude "ndiswan.h"
#include "resource.h"
//nclude "rasaf.h"
//nclude "rasdata.h"
//nclude "ncutil.h"
#include "netcfgx.h"


#include "bindobj.h"

//
// Frame type definitions
//

#define ISN_FRAME_TYPE_ETHERNET_II  0
#define ISN_FRAME_TYPE_802_3        1
#define ISN_FRAME_TYPE_802_2        2
#define ISN_FRAME_TYPE_SNAP         3
#define ISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define ISN_FRAME_TYPE_MAX          4    // of the four standard ones

#define ISN_FRAME_TYPE_AUTO         0xff


//
// OPT - Move the isnipx.h definitions over here
//
// Frame types.  For now these mirror those in isnipx.h.
//
#define MISN_FRAME_TYPE_ETHERNET_II  0
#define MISN_FRAME_TYPE_802_3        1
#define MISN_FRAME_TYPE_802_2        2
#define MISN_FRAME_TYPE_SNAP         3
#define MISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define MISN_FRAME_TYPE_MAX          4    // of the four standard ones



//+---------------------------------------------------------------------------
// Steelhead
//
typedef void (WINAPI* PFN_MAKE_INTERFACE_INFO)(LPCWSTR pszwAdapterName,
                                               DWORD   dwPacketType,
                                               LPBYTE* ppb);
typedef void (WINAPI* PFN_MAKE_TRANSPORT_INFO)(LPBYTE* ppbGlobal,
                                               LPBYTE* ppbClient);

struct ROUTER_MANAGER_INFO
{
    DWORD                   dwTransportId;
    DWORD                   dwPacketType;
    LPCWSTR                 pszwTransportName;
    LPCWSTR                 pszwDllPath;
    PFN_MAKE_INTERFACE_INFO pfnMakeInterfaceInfo;
    PFN_MAKE_TRANSPORT_INFO pfnMakeTransportInfo;
};

class CSteelhead : public CRasBindObject
{
public:
protected:
    HANDLE              m_hMprConfig;


    BOOL    FAdapterExistsWithMatchingBindName  (LPCWSTR pszwAdapterName,
                                                 INetCfgComponent** ppnccAdapter);
    BOOL    FIpxFrameTypeInUseOnAdapter         (DWORD dwwFrameType,
                                                 LPCWSTR pszwAdapterName);
    BOOL    FIpxFrameTypeInUseOnAdapter         (LPCWSTR pszwFrameType,
                                                 LPCWSTR pszwAdapterName);

    HRESULT HrEnsureRouterInterfaceForAdapter   (ROUTER_INTERFACE_TYPE dwIfType,
                                                 DWORD dwPacketType,
                                                 LPCWSTR pszwAdapterName,
                                                 LPCWSTR pszwInterfaceName,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureIpxRouterInterfacesForAdapter   (LPCWSTR pszwAdapterName);
    HRESULT HrEnsureRouterInterface             (ROUTER_INTERFACE_TYPE dwIfType,
                                                 LPCWSTR pszwInterfaceName,
                                                 HANDLE* phInterface);
    HRESULT HrEnsureRouterInterfaceTransport    (LPCWSTR pszwAdapterName,
                                                 DWORD dwPacketType,
                                                 HANDLE hInterface,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManager               (const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManagerDeleted        (const ROUTER_MANAGER_INFO& rmi);

    HRESULT HrPassToAddInterfaces               ();
    HRESULT HrPassToRemoveInterfaces            ();
    HRESULT HrPassToRemoveInterfaceTransports   (MPR_INTERFACE_0* pri0,
                                                 LPCWSTR pszwAdapterName,
                                                 INetCfgComponent* pnccAdapter);

#if (WINVER >= 0x0501)
    HRESULT HrRemoveIPXRouterConfiguration      ();
#endif

public:
    CSteelhead  ();
    ~CSteelhead ();

    HRESULT HrUpdateRouterConfiguration         ();

    STDMETHOD (Initialize)          (INetCfg* pnc);


    // Use these buffers to store the names for the internal
    // and loopback adapters.
    WCHAR       m_swzInternal[256];
    WCHAR       m_swzLoopback[256];

};

void MakeIpInterfaceInfo (
        LPCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff);
void MakeIpTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient);
void MakeIpxInterfaceInfo (
        LPCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff);
void MakeIpxTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient);
HRESULT
HrMprConfigServerConnect(
    IN      LPWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
);
HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
);
HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);
HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);
HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
);
HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
);

HRESULT
HrMprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
);

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
);
HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
);
HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport);
HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
);
HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT LPWSTR*                 lplpwsDLLPath               OPTIONAL
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\update.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       S T E E L H E A D . C P P
//
//  Contents:   Implementation of Steelhead configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#pragma hdrstop
#include <mprerror.h>
#include "assert.h"
//nclude <tdi.h>        // must include for isnkrnl.h
//nclude <isnkrnl.h>
#include <rtinfo.h>
#include "update.h"
//nclude "ncreg.h"
//nclude "ncsvc.h"
#include "netcfgp.h"
//nclude "router.h"
#include "netcfgn.h"
#include "netcfgx.h"
#include "iprtrmib.h"
#include "ipxrtdef.h"
#include "routprot.h"
#include "ipinfoid.h"
#include "fltdefs.h"
#include "iprtinfo.h"
#include "ncnetcfg.h"
#include "ncutil.h"

extern const TCHAR c_szBiNdis5[];
extern const TCHAR c_szRegKeyServices[];
extern const TCHAR c_szSvcRemoteAccess[];
extern const TCHAR c_szSvcRouter[];


const GUID GUID_DEVCLASS_NET ={0x4D36E972,0xE325,0x11CE,{0xbf,0xc1,0x08,0x00,0x2b,0xe1,0x03,0x18}};
//nst GUID IID_INetCfgComponentBindings ={0xC0E8AE9E,0x306E,0x11D1,{0xaa,0xcf,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

//+---------------------------------------------------------------------------
// Static data for adding router managers.
//
static const WCHAR c_szwRtrMgrIp    []  = L"Ip";
static const WCHAR c_szwRtrMgrDllIp []  = L"%SystemRoot%\\System32\\iprtrmgr.dll";
static const WCHAR c_szwRtrMgrIpx   []  = L"Ipx";
static const WCHAR c_szwRtrMgrDllIpx[]  = L"%SystemRoot%\\System32\\ipxrtmgr.dll";

static const ROUTER_MANAGER_INFO c_rmiIp =
{
    PID_IP,
    0,
    c_szwRtrMgrIp,
    c_szwRtrMgrDllIp,
    MakeIpInterfaceInfo,
    MakeIpTransportInfo,
};

static const ROUTER_MANAGER_INFO c_rmiIpx =
{
    PID_IPX,
	ISN_FRAME_TYPE_AUTO,
    c_szwRtrMgrIpx,
    c_szwRtrMgrDllIpx ,
    MakeIpxInterfaceInfo,
    MakeIpxTransportInfo,
};


// For Ipx, the adapter name is the bind name.
// We need to create an interface per frame type.
// The interface name is the adapter name followed
// by these strings.
//
struct MAP_SZW_DWORD
{
    LPCWSTR pszwValue;
    DWORD   dwValue;
};

static const MAP_SZW_DWORD c_mapFrameType [] =
{
    L"/EthII",  MISN_FRAME_TYPE_ETHERNET_II,
    L"/802.3",  MISN_FRAME_TYPE_802_3,
    L"/802.2",  MISN_FRAME_TYPE_802_2,
    L"/SNAP",   MISN_FRAME_TYPE_SNAP,
};

BOOL
FMapFrameTypeToString (
    DWORD       dwFrameType,
    LPCWSTR*    ppszwFrameType) 
{
    Assert (ppszwFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (dwFrameType == c_mapFrameType[i].dwValue)
        {
            *ppszwFrameType = c_mapFrameType[i].pszwValue;
            return TRUE;
        }
    }

    *ppszwFrameType = NULL;
    return FALSE;
}

BOOL
FMapStringToFrameType (
    LPCWSTR pszwFrameType,
    DWORD*  pdwFrameType) 
{
    Assert (pszwFrameType);
    Assert (pdwFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (0 == lstrcmpW (pszwFrameType, c_mapFrameType[i].pszwValue))
        {
            *pdwFrameType = c_mapFrameType[i].dwValue;
            return TRUE;
        }
    }

    *pdwFrameType = NULL;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShouldRouteOverAdapter
//
//  Purpose:
//
//  Arguments:
//      pnccAdapter     [in]
//      pszwBindName   [out]
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
HrShouldRouteOverAdapter (
    INetCfgComponent*   pnccAdapter,
    LPWSTR*             ppszwBindName)
{

    if (ppszwBindName)
    {
        *ppszwBindName = NULL;
    }

    // We should return S_OK if the adapter is physical or it supports
    // a binding interface of ndis5.  S_FALSE otherwise.
    //
    DWORD dwCharacter;
    HRESULT hr = pnccAdapter->GetCharacteristics (&dwCharacter);
    if (SUCCEEDED(hr) && !(dwCharacter & NCF_PHYSICAL))
    {
        INetCfgComponentBindings* pnccBindings = NULL;
        hr = pnccAdapter->QueryInterface (IID_INetCfgComponentBindings,
                reinterpret_cast<void**>(&pnccBindings));
        if (SUCCEEDED(hr) && pnccBindings)
        {
            hr = pnccBindings->SupportsBindingInterface (NCF_UPPER, c_szBiNdis5);
            ReleaseObj (pnccBindings);
			pnccBindings = NULL;
        }
    }

    // SupportsBindingInterface may return S_OK or S_FALSE.
    // We only want the bind name if we're going to return S_OK.
    //
    if ((S_OK == hr) && ppszwBindName)
    {
        hr = pnccAdapter->GetBindName (ppszwBindName);
    }

    TraceResult ("HrShouldRouteOverAdapter", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::CSteelhead
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::CSteelhead ()
{
    m_hMprConfig                    = NULL;
    HMODULE hModule = NULL;
    hModule = LoadLibrary (  L"netcfgx.dll" );
    if ( NULL != hModule )
    {
        ::LoadString(hModule,
                     IDS_RAS_INTERNAL_ADAPTER,
                     m_swzInternal,
                     sizeof(m_swzInternal) / sizeof(*m_swzInternal));
        ::LoadString(hModule,
                     IDS_RAS_LOOPBACK_ADAPTER,
                     m_swzLoopback,
                     sizeof(m_swzLoopback) / sizeof(*m_swzLoopback));
        FreeLibrary ( hModule );
    }
    else
    {
        ::LoadString(_Module.GetResourceInstance(),
                     IDS_INTERNAL_ADAPTER,
                     m_swzInternal,
                     sizeof(m_swzInternal) / sizeof(*m_swzInternal));
        ::LoadString(_Module.GetResourceInstance(),
                     IDS_LOOPBACK_ADAPTER,
                     m_swzLoopback,
                     sizeof(m_swzLoopback) / sizeof(*m_swzLoopback));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::~CSteelhead
//
//  Purpose:    Destructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::~CSteelhead ()
{
    Assert (!m_hMprConfig);

	ReleaseObj(m_pnc);
	m_pnc = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FAdapterExistsWithMatchingBindName
//
//  Purpose:
//
//  Arguments:
//      pszwAdapterName [in]
//      ppnccAdapter    [out]
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FAdapterExistsWithMatchingBindName (
    LPCWSTR             pszwAdapterName,
    INetCfgComponent**  ppnccAdapter)
{
    Assert (pszwAdapterName);
    Assert (ppnccAdapter);

    *ppnccAdapter = NULL;

    BOOL fFound = FALSE;

    // Enumerate physical adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter = NULL;
    while (!fFound && SUCCEEDED(hr) &&
           S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
		LPWSTR pszwBindName = NULL;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszwBindName);
        if (S_OK == hr)
        {
            if (0 == lstrcmpW (pszwAdapterName, pszwBindName))
            {
                fFound = TRUE;

                *ppnccAdapter = pnccAdapter;
                AddRefObj (pnccAdapter);
            }
            CoTaskMemFree (pszwBindName);
        }

        ReleaseObj (pnccAdapter);
		pnccAdapter = NULL;
    }
    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      dwFrameType   []
//      pszwAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    DWORD   dwFrameType,
    LPCWSTR pszwAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL fRet = FALSE;
    if (PnccIpx())
    {
        // Get the private interface off of the INetCfgComponent for IPX
        // then we can query for a notify object interface
        //
        INetCfgComponentPrivate* pinccp;
        HRESULT hr = PnccIpx()->QueryInterface(
                                IID_INetCfgComponentPrivate,
                                reinterpret_cast<void**>(&pinccp));

        if (SUCCEEDED(hr))
        {
            IIpxAdapterInfo* pIpxAdapterInfo;
            hr = pinccp->QueryNotifyObject(
                                 IID_IIpxAdapterInfo,
                                 reinterpret_cast<void**>(&pIpxAdapterInfo));
            if (SUCCEEDED(hr) && pIpxAdapterInfo)
            {
                // Get the frametypes in use for this adapter.
                //
                DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
                DWORD cdwFrameType;
                hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                        pszwAdapterName,
                        celems (adwFrameType),
                        adwFrameType,
                        &cdwFrameType);
                if (SUCCEEDED(hr))
                {
                    for (DWORD i = 0; i < cdwFrameType; i++)
                    {
                        if (dwFrameType == adwFrameType[i])
                        {
                            fRet = TRUE;
                            break;
                        }
                    }
                }

                ReleaseObj (pIpxAdapterInfo);
				pIpxAdapterInfo = NULL;
            }

            ReleaseObj (pinccp);
			pinccp = NULL;
        }
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      pszwFrameType   []
//      pszwAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    LPCWSTR pszwFrameType,
    LPCWSTR pszwAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL    fRet = FALSE;
    DWORD   dwFrameType;
    if (PnccIpx() && FMapStringToFrameType (pszwFrameType, &dwFrameType))
    {
        fRet = FIpxFrameTypeInUseOnAdapter (dwFrameType, pszwAdapterName);
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceForAdapter
//
//  Purpose:    Ensures the router interface block for the specified
//              interface (adapter) is present and that the specified router
//              manger is configured for that interface.
//
//  Arguments:
//      dwIfType          [in] Interface type
//      dwPacketType      [in] The packet type (IPX only, ignored othewise)
//      pszwAdapterName   [in] The adapter name
//      pszwInterfaceName [in] The interface name
//      rmi               [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceForAdapter (
    ROUTER_INTERFACE_TYPE       dwIfType,
    DWORD                       dwPacketType,
    LPCWSTR                     pszwAdapterName,
    LPCWSTR                     pszwInterfaceName,
    const ROUTER_MANAGER_INFO&  rmi)
{
    // Make sure the interface is created.
    //
    HANDLE hInterface;
    HRESULT hr = HrEnsureRouterInterface (
                    dwIfType,
                    pszwInterfaceName,
                    &hInterface);
    if (SUCCEEDED(hr))
    {
        // Ensure the router manager is added to the interface.
        //
        hr = HrEnsureRouterInterfaceTransport (
                pszwAdapterName,
                dwPacketType,
                hInterface,
                rmi);
    }
    TraceResult ("CSteelhead::HrEnsureRouterInterfaceForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureIpxRouterInterfacesForAdapter
//
//  Purpose:
//
//  Arguments:
//      pszwAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureIpxRouterInterfacesForAdapter (
    LPCWSTR pszwAdapterName)
{
    AssertSz (PnccIpx(), "Why is this being called if IPX isn't installed?");

    // Get the private interface off of the INetCfgComponent for IPX
    // then we can query for a notify object interface
    //
    INetCfgComponentPrivate* pinccp;
    HRESULT hr = PnccIpx()->QueryInterface(
                            IID_INetCfgComponentPrivate,
                            reinterpret_cast<void**>(&pinccp));

    if (SUCCEEDED(hr))
    {
        // Get the IIpxAdapterInfo interface from the IPX notify object.
        // We'll use it to find out how adapters are configured under IPX.
        //
        IIpxAdapterInfo* pIpxAdapterInfo = NULL;
        hr = pinccp->QueryNotifyObject(
                             IID_IIpxAdapterInfo,
                             reinterpret_cast<void**>(&pIpxAdapterInfo));
        if (SUCCEEDED(hr) && pIpxAdapterInfo)
        {
            // Get the frametypes in use for this adapter.
            //
            DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
            DWORD cdwFrameType;
            hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                    pszwAdapterName,
                    celems (adwFrameType),
                    adwFrameType,
                    &cdwFrameType);
            if (SUCCEEDED(hr) && cdwFrameType)
            {
                // If more than one frame type is in use, or if there is only
                // one and it isn't auto, then we'll be creating interfaces
                // for those frame types explicitly.
                //
                if ((cdwFrameType > 1) ||
                    ((1 == cdwFrameType) &&
                     (ISN_FRAME_TYPE_AUTO != adwFrameType[0])))
                {
                    for (DWORD i = 0; SUCCEEDED(hr) && (i < cdwFrameType); i++)
                    {
                        LPCWSTR pszwFrameType;
                        if (FMapFrameTypeToString (adwFrameType[i], &pszwFrameType))
                        {
                            // Make the interface name by catenating the
                            // adapter (bind) name with the frame type.
                            //
                            WCHAR szwInterfaceName [512];
                            lstrcpyW (szwInterfaceName, pszwAdapterName);
                            lstrcatW (szwInterfaceName, pszwFrameType);

                            hr = HrEnsureRouterInterfaceForAdapter (
                                    ROUTER_IF_TYPE_DEDICATED,
                                    adwFrameType[i],
                                    pszwAdapterName,
                                    szwInterfaceName,
                                    c_rmiIpx);
                        }
                    }
                }

                // Otherwise, we'll create the interface for the auto frame
                // type case.
                //
                else
                {
    #ifdef DBG
                    AssertSz (1 == cdwFrameType,
                            "IPX should report at least one frame type.  "
                            "You may continue without a problem.");
                    if (1 == cdwFrameType)
                    {
                        AssertSz (ISN_FRAME_TYPE_AUTO == adwFrameType[0],
                                "Frame type should be auto here.  "
                                "You may continue without a problem.");
                    }
    #endif
                    hr = HrEnsureRouterInterfaceForAdapter (
                            ROUTER_IF_TYPE_DEDICATED,
                            ISN_FRAME_TYPE_AUTO,
                            pszwAdapterName,
                            pszwAdapterName,
                            c_rmiIpx);
                }
            }

            ReleaseObj (pIpxAdapterInfo);
			pIpxAdapterInfo = NULL;
        }

        ReleaseObj (pinccp);
		pinccp = NULL;
    }

    TraceResult ("CSteelhead::HrEnsureIpxRouterInterfacesForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterface
//
//  Purpose:    Ensures the specified router interface is present and
//              returns a handle to it.
//
//  Arguments:
//      pszwInterfaceName [in]  The interface (adapter) name
//      phInterface       [out] Returned handle to the interface
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterface (
    ROUTER_INTERFACE_TYPE   dwIfType,
    LPCWSTR                 pszwInterfaceName,
    HANDLE*                 phInterface)
{
    Assert (pszwInterfaceName);
    Assert (phInterface);

    HRESULT hr = HrMprConfigInterfaceGetHandle (m_hMprConfig,
                        const_cast<LPWSTR>(pszwInterfaceName),
                        phInterface);
    if (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE ) == hr)
    {
        // It's not installed, we'll create it.
        //

        // The name of the interface will be the adatper instance.
        //
        MPR_INTERFACE_0 ri0;
        ZeroMemory (&ri0, sizeof(ri0));
        ri0.hInterface = INVALID_HANDLE_VALUE;
        ri0.fEnabled   = TRUE;  // thanks gibbs
        ri0.dwIfType   = dwIfType;

        // Copy the interface name into the buffer.
        //
        AssertSz (lstrlen (pszwInterfaceName) < celems (ri0.wszInterfaceName),
                  "Bindname too big for MPR_INTERFACE_0 buffer.");
        lstrcpy (ri0.wszInterfaceName, pszwInterfaceName);

        // Create the interface.
        //
        hr = HrMprConfigInterfaceCreate (m_hMprConfig,
                                         0, (LPBYTE)&ri0,
                                         phInterface);
    }
    TraceResult ("CSteelhead::HrEnsureRouterInterface", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceTransport
//
//  Purpose:    Ensures the specified router manager is configured over
//              the specified interface.
//
//  Arguments:
//      pszwAdapterName     [in] The adapter name
//      dwPacketType        [in] The packet type (IPX only, ignored otherwise)
//      hInterface          [in] Handle to the interface
//      rmi                 [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceTransport (
    LPCWSTR                     pszwAdapterName,
    DWORD                       dwPacketType,
    HANDLE                      hInterface,
    const ROUTER_MANAGER_INFO&  rmi)
{
	HRESULT	hr;
    Assert (hInterface);

	// Ensure the router manager is present
	//
	hr = HrEnsureRouterManager (rmi);

	if (SUCCEEDED(hr))
	{
		// See if the router manager is present on the interface.
		//
		HANDLE hIfTransport;
		hr = HrMprConfigInterfaceTransportGetHandle (m_hMprConfig,
			hInterface,
			rmi.dwTransportId,
			&hIfTransport);
	
		if (FAILED(hr))
		{
			// Create the interface info and add the router manager to
			// the interface.
			//
			PRTR_INFO_BLOCK_HEADER  pibh;
			
			Assert (rmi.pfnMakeInterfaceInfo);
			rmi.pfnMakeInterfaceInfo (pszwAdapterName,
									  dwPacketType,
                                      (LPBYTE*)&pibh);

            hr = HrMprConfigInterfaceTransportAdd (
                            m_hMprConfig,
                            hInterface,
                            rmi.dwTransportId,
                            const_cast<LPWSTR>(rmi.pszwTransportName),
                            (LPBYTE)pibh,
                            pibh->Size,
                            &hIfTransport);

            delete (LPBYTE*)pibh;
        }
    }
    TraceResult ("CSteelhead::HrEnsureRouterInterfaceTransport", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManager
//
//  Purpose:    Ensures that the specified router manager is installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterManager (
    const ROUTER_MANAGER_INFO& rmi)
{
    PRTR_INFO_BLOCK_HEADER  pibhGlobal;
    BOOL                    fCreate = FALSE;

    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
    {
        // It's not installed, we'll create it.
        //
        fCreate = TRUE;
    }
    else if (SUCCEEDED(hr))
    {
        // Its installed, see if its transport info is available.
        //
        DWORD dwSize;
        hr = HrMprConfigTransportGetInfo (m_hMprConfig, hTransport,
                                          (LPBYTE*)&pibhGlobal, &dwSize,
                                          NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (!pibhGlobal)
            {
                // Global info is missing, we'll create it.
                //
                fCreate = TRUE;
            }
            else
            {
                MprConfigBufferFree (pibhGlobal);
            }
        }
    }

    if (fCreate)
    {
        // Install the router manager.
        //
        Assert (rmi.pfnMakeTransportInfo);
        PRTR_INFO_BLOCK_HEADER  pibhClient;
        rmi.pfnMakeTransportInfo ((LPBYTE*)&pibhGlobal,
                                  (LPBYTE*)&pibhClient);

        hr = HrMprConfigTransportCreate (
                     m_hMprConfig,
                     rmi.dwTransportId,
                     const_cast<LPWSTR>(rmi.pszwTransportName),
                     (LPBYTE)pibhGlobal, (pibhGlobal) ? pibhGlobal->Size : 0,
                     (LPBYTE)pibhClient, (pibhClient) ? pibhClient->Size : 0,
                     const_cast<LPWSTR>(rmi.pszwDllPath),
                     &hTransport);

        delete (LPBYTE*)pibhGlobal;
        delete (LPBYTE*)pibhClient;
    }
    TraceResult ("CSteelhead::HrEnsureRouterManager", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManagerDeleted
//
//  Purpose:    Ensures that the specified router manager is not installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Sep 1997
//
//  Notes:
//
HRESULT CSteelhead::HrEnsureRouterManagerDeleted (
    const ROUTER_MANAGER_INFO& rmi)
{
    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (SUCCEEDED(hr))
    {
        // It is installed, so we need to delete it.
        //
        (void) HrMprConfigTransportDelete (m_hMprConfig, hTransport);
    }
    TraceResult ("CSteelhead::HrEnsureRouterManagerDeleted",
                (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
                ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToAddInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToAddInterfaces ()
{
    HRESULT hr = S_OK;

    // Enumerate physical adapters in the system.
    //
    CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while (SUCCEEDED(hr) && S_OK == (hr = nccIter.HrNext(&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
		LPWSTR pszwBindName = NULL;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszwBindName);
        if (S_OK == hr)
        {
            INetCfgComponentBindings* pnccBindingsIp = NULL;
            INetCfgComponentBindings* pnccBindingsIpx  = NULL;

            // If Ip is bound to the adapter, create and interface
            // for it.
            //
            if (PnccIp())
            {
                hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<void**>(&pnccBindingsIp) );
            }
            if (PnccIp() && SUCCEEDED(hr) &&
                (S_OK == (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
            {
                // Interface name is the same as the adapter name
                // is the same as the bind name.
                //
                hr = HrEnsureRouterInterfaceForAdapter (
                        ROUTER_IF_TYPE_DEDICATED,
                        0,
                        pszwBindName,
                        pszwBindName,
                        c_rmiIp);

            }
            ReleaseObj (pnccBindingsIp);
			pnccBindingsIp = NULL;

            // If Ipx is bound to the adapter, create the interface(s)
            // for it.
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<void**>(&pnccBindingsIpx));
            }
            if (PnccIpx() &&
                (S_OK == (hr = pnccBindingsIpx->IsBoundTo( pnccAdapter )) ))
            {
#if (WINVER < 0x0501)
                hr = HrEnsureIpxRouterInterfacesForAdapter (pszwBindName);
#endif
            }
    
            ReleaseObj (pnccBindingsIpx);
			pnccBindingsIpx = NULL;

			CoTaskMemFree(pszwBindName);
        }

        ReleaseObj (pnccAdapter);
		pnccAdapter = NULL;
    }
    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceResult ("CSteelhead::HrPassToAddInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaces ()
{
    // Enumerate all of the installed router interfaces.
    //
    MPR_INTERFACE_0*    ari0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT hr = HrMprConfigInterfaceEnum (m_hMprConfig, 0,
                    reinterpret_cast<LPBYTE*>(&ari0),
                    -1, &dwEntriesRead, &dwTotalEntries, NULL);
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        // Iterate all of the interfaces.
        //
        for (MPR_INTERFACE_0* pri0 = ari0; dwEntriesRead--; pri0++)
        {
            BOOL fDeleteInterface = FALSE;

            // If its the internal interface and IP and IPX are no longer
            // installed delete the interface.
            //
            if ((ROUTER_IF_TYPE_INTERNAL == pri0->dwIfType) &&
                !PnccIpx() && !PnccIp() &&
                (0 == lstrcmpW (pri0->wszInterfaceName, m_swzInternal)))
            {
                fDeleteInterface = TRUE;
            }
            else if (ROUTER_IF_TYPE_DEDICATED != pri0->dwIfType)
            {
                // Skip non-dedicated interfaces.
                //
                continue;
            }

            BOOL                fSpecialIpxInterface = FALSE;
            INetCfgComponent*   pnccAdapter          = NULL;

            // Get the name of the interface and look for a '/' separator.
            // If present, it means this is a special IPX interface where
            // the first substring is the adapter name, and the second
            // substring is the frame type.
            //
            WCHAR* pchwSep = wcschr (pri0->wszInterfaceName, L'/');
            if (!fDeleteInterface && pchwSep)
            {
                fSpecialIpxInterface = TRUE;

                // Point to the frame type string.
                //
                LPCWSTR pszwFrameType = pchwSep;

                // Copy the adapter name into its own buffer.
                //
                WCHAR   szwAdapterName [MAX_INTERFACE_NAME_LEN+1];
                lstrcpynW (szwAdapterName, pri0->wszInterfaceName,
                            (int)(pchwSep - pri0->wszInterfaceName + 1));

                // If the frame type is not in use for the adapter, we need
                // to delete this interface.  This condition happens when
                // IPX configuration is changed and the frame type is removed
                // from the adapter.
                //
                if (!FIpxFrameTypeInUseOnAdapter (pszwFrameType,
                        szwAdapterName))
                {
                    fDeleteInterface = TRUE;
                }
            }

            // Its not a special interface, so just make sure an adapter
            // exists with a matching bind name.  If not, we will delete
            // the interface.
            //
            else if (!fDeleteInterface)
            {
                if (!FAdapterExistsWithMatchingBindName (
                        pri0->wszInterfaceName,
                        &pnccAdapter))
                {
                    fDeleteInterface = TRUE;
                }
            }

            // Delete the interface if we need to.
            //
            if (fDeleteInterface)
            {
                MprConfigInterfaceDelete (m_hMprConfig, pri0->hInterface);
            }

            // If we don't need to delete the entire interface, check
            // for transports on the interface that we may need to delete.
            //
            else
            {
                // If its not an IPX special interface, the adapter
                // is the interface name.  If it is an IPX special
                // interface, then we would have already remove the entire
                // interfce above if it were invalid.
                //
                (void) HrPassToRemoveInterfaceTransports (
                        pri0,
                        (!fSpecialIpxInterface) ? pri0->wszInterfaceName
                                                : NULL,
                        pnccAdapter);
            }

            ReleaseObj (pnccAdapter);
			pnccAdapter = NULL;
        }

        MprConfigBufferFree (ari0);
    }
    else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }
    TraceResult ("CSteelhead::HrPassToRemoveInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaceTransports
//
//  Purpose:
//
//  Arguments:
//      hInterface      []
//      pszwAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaceTransports (
    MPR_INTERFACE_0*    pri0,
    LPCWSTR             pszwAdapterName,
    INetCfgComponent*   pnccAdapter)
{
//    Assert (FImplies(pnccAdapter, pszwAdapterName));

    // Enumerate all of the transports active on the router interface.
    //
    MPR_IFTRANSPORT_0*  arit0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT hr = HrMprConfigInterfaceTransportEnum (m_hMprConfig,
                    pri0->hInterface, 0,
                    reinterpret_cast<LPBYTE*>(&arit0),
                    -1, &dwEntriesRead, &dwTotalEntries, NULL);
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        INetCfgComponentBindings* pnccBindingsIpx = NULL;
        INetCfgComponentBindings* pnccBindingsIp  = NULL;

        if (PnccIp())
        {
            hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                    reinterpret_cast<void**>(&pnccBindingsIp));
        }
        if (SUCCEEDED(hr))
        {
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<void**>(&pnccBindingsIpx));
            }
            if (SUCCEEDED(hr))
            {
                // Iterate all of the transports.
                //
                for (MPR_IFTRANSPORT_0* prit0 = arit0; dwEntriesRead--; prit0++)
                {
                    BOOL fDeleteInterfaceTransport = FALSE;

                    if (prit0->dwTransportId == c_rmiIp.dwTransportId)
                    {
                        if (!PnccIp())
                        {
                            fDeleteInterfaceTransport = TRUE;
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                        }
                    }
                    else if (prit0->dwTransportId == c_rmiIpx.dwTransportId)
                    {
                        if (!PnccIpx())
                        {
                            fDeleteInterfaceTransport = TRUE;
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIpx->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                        }
                        else if (pszwAdapterName)
                        {
                            Assert (PnccIpx());

                            // if frame type is not auto on this adapter, delete
                            // the transport
                            if (!FIpxFrameTypeInUseOnAdapter (ISN_FRAME_TYPE_AUTO,
                                    pszwAdapterName))
                            {
                                fDeleteInterfaceTransport = TRUE;
                            }
                        }
                    }

                    if (fDeleteInterfaceTransport)
                    {
                        MprConfigInterfaceTransportRemove (
                            m_hMprConfig,
                            pri0->hInterface,
                            prit0->hIfTransport);
                    }

                }
                MprConfigBufferFree (arit0);

                ReleaseObj (pnccBindingsIpx);
				pnccBindingsIpx = NULL;
            }

            ReleaseObj (pnccBindingsIp);
			pnccBindingsIp = NULL;
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        // If there are no transports for this interface, that's okay.
        //
        hr = S_OK;
    }

    TraceResult ("CSteelhead::HrPassToRemoveInterfaceTransports", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrUpdateRouterConfiguration
//
//  Purpose:    Updates the router configuration by ensuring router managers
//              are installed for the protocols present on the system (IP and
//              IPX).  Further, router interfaces are created for each
//              physical netcard present on the system.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrUpdateRouterConfiguration ()
{
    Assert (!m_hMprConfig);

    HRESULT hr = HrMprConfigServerConnect (NULL, &m_hMprConfig);
    if (SUCCEEDED(hr))
    {
        // Ensure router managers are installed for the protocols
        // we know about.  Good to do this in case no physical adapters.
        // are found below.  We actually do this by ensuring the internal
        // interface exists.  This will implicitly ensure the router
        // manger is created.
        //
        if (PnccIp())
        {
            (void) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_LOOPBACK,
                    c_rmiIp.dwPacketType,
                    m_swzLoopback,
                    m_swzLoopback,
                    c_rmiIp);

            (void) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIp.dwPacketType,
                    m_swzInternal,
                    m_swzInternal,
                    c_rmiIp);
        }
        else
        {
            (void) HrEnsureRouterManagerDeleted (c_rmiIp);
        }
        if (PnccIpx())
        {
            (void) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIpx.dwPacketType,
                    m_swzInternal,
                    m_swzInternal,
                    c_rmiIpx);
        }
        else
        {
            (void) HrEnsureRouterManagerDeleted (c_rmiIpx);
        }

        (void) HrPassToAddInterfaces ();

        (void) HrPassToRemoveInterfaces ();

#if (WINVER >= 0x0501)
        (VOID) HrRemoveIPXRouterConfiguration();

        //
        // Remove IPX router Manager configuration
        //

        (VOID) HrEnsureRouterManagerDeleted(c_rmiIpx);

        //
        // Remove IPX keys under HKLM\Software\Microsoft\Router\CurrentVersion
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Router\\CurrentVersion\\RouterManagers",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"Ipx");
            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // Remove IPX keys under HKLM\Software\Microsoft\IPXMibAgent
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"IPXMibAgent");
            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // Remove keys for NWLNKFWD and NWLNKFLT
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\Services",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"NwlnkFwd");
            (VOID) SHDeleteKey(hKey, L"NwlnkFlt");
            RegCloseKey(hKey);
            hKey = NULL;
        }

#endif
        MprConfigServerDisconnect (m_hMprConfig);
        m_hMprConfig = NULL;
    }

    TraceResult ("CSteelhead::HrUpdateRouterConfiguration", hr);
    return hr;
}

#if (WINVER >= 0x0501)
//+---------------------------------------------------------------------------
//
//  Member :    CSteelhead::HrRemoveIPXRouterConfiguration
//
//  Purpose:    Updates the router configuration to remove all the IPX related 
//              configuration
//
//  Arguments:
//      fRouter -   Remove from running instance of router
//
//  Returns:    S_OK or an error code.
//
//  Author:     vraman 17 April 2002
//
//  Notes:
//

HRESULT
CSteelhead::HrRemoveIPXRouterConfiguration  ()
{

    HRESULT             hr = S_OK;
    MPR_INTERFACE_0     *ari0;
    DWORD               dwIfRead, dwIfTotal, dwIfTransRead, dwIfTransTotal;
    HANDLE              hIfTransport;

    //
    // Enumerate interfaces
    //

    hr = HrMprConfigInterfaceEnum(
            m_hMprConfig, 
            0,
            reinterpret_cast<LPBYTE*>(&ari0),
            -1, 
            &dwIfRead, 
            &dwIfTotal, 
            NULL
            );

    if (SUCCEEDED(hr))
    {
        for (MPR_INTERFACE_0 *pri0 = ari0; dwIfRead--; pri0++)
        {
            //
            // For each interface, remove RRAS IPX config
            //

            hr = HrMprConfigInterfaceTransportGetHandle(
                    m_hMprConfig,
                    pri0->hInterface,
                    PID_IPX,
                    &hIfTransport
                    );

            if (SUCCEEDED(hr))
            {
                hr = HrMprConfigInterfaceTransportRemove(
                        m_hMprConfig,
                        pri0->hInterface,
                        hIfTransport
                        );
            }
        }
    }

    TraceError ("CSteelhead::HrRemoveIPXRouterConfiguration", hr);
    return hr;
}

#endif


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CSteelhead::Initialize (
    INetCfg*            pnc)
{
//    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnc = pnc);

    return S_OK;
}



#define PAD8(_p)    (((ULONG_PTR)(_p) + ALIGN_SHIFT) & ALIGN_MASK)


//+---------------------------------------------------------------------------
//
//  Function:   MakeIpInterfaceInfo
//
//  Purpose:    Create the router interface block for IP.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpInterfaceInfo (
        LPCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    UNREFERENCED_PARAMETER (pszwAdapterName);
    UNREFERENCED_PARAMETER (dwPacketType);
    Assert (ppBuff);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof( INTERFACE_STATUS_INFO )
                    + sizeof( RTR_DISC_INFO )
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) new BYTE [dwSize];
    *ppBuff                     = (LPBYTE) pIBH;

    if(pIBH == NULL)
    	return;
    	
    ZeroMemory (pIBH, dwSize);

    // Initialize infobase fields.
    //
    pIBH->Version               = RTR_INFO_BLOCK_VERSION;
    pIBH->Size                  = dwSize;
    pIBH->TocEntriesCount       = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Create empty route info block
    //
    pTocEntry->InfoType         = IP_ROUTE_INFO;
    pTocEntry->InfoSize         = sizeof( MIB_IPFORWARDROW );
    pTocEntry->Count            = 0;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create interface status block.
    //
    pTocEntry->InfoType         = IP_INTERFACE_STATUS_INFO;
    pTocEntry->InfoSize         = sizeof( INTERFACE_STATUS_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    PINTERFACE_STATUS_INFO pifStat = (PINTERFACE_STATUS_INFO)pbDataPtr;
    pifStat->dwAdminStatus      = MIB_IF_ADMIN_STATUS_UP;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create Router Disc. Info.
    //
    pTocEntry->InfoType         = IP_ROUTER_DISC_INFO;
    pTocEntry->InfoSize         = sizeof( RTR_DISC_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    PRTR_DISC_INFO pRtrDisc     = (PRTR_DISC_INFO)pbDataPtr;
    pRtrDisc->bAdvertise        = FALSE;
    pRtrDisc->wMaxAdvtInterval  = DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->wMinAdvtInterval  = (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
    pRtrDisc->wAdvtLifetime     = DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->lPrefLevel        = DEFAULT_PREF_LEVEL;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpTransportInfo
//
//  Purpose:    Create the router transport blocks for IP.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    *ppBuffClient = NULL;

    const int c_cTocEntries = 2;
    const int c_cProtocols  = 7;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(GLOBAL_INFO)
                    + SIZEOF_PRIORITY_INFO(c_cProtocols)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) new BYTE [dwSize];
    *ppBuffGlobal = (LPBYTE) pIBH;

    if(pIBH == NULL)
    	return;
    ZeroMemory (pIBH, dwSize);

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IP router manager global info.
    //
    pTocEntry->InfoType         = IP_GLOBAL_INFO;
    pTocEntry->InfoSize         = sizeof(GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PGLOBAL_INFO pGlbInfo       = (PGLOBAL_INFO) pbDataPtr;
    pGlbInfo->bFilteringOn      = FALSE;
    pGlbInfo->dwLoggingLevel    = IPRTR_LOGGING_ERROR;

    pbDataPtr += pTocEntry->Count * pTocEntry-> InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make IP router manager priority info.
    //
    pTocEntry->InfoType         = IP_PROT_PRIORITY_INFO;
    pTocEntry->InfoSize         = SIZEOF_PRIORITY_INFO(c_cProtocols);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PPRIORITY_INFO pPriorInfo   = (PPRIORITY_INFO) pbDataPtr;
    pPriorInfo->dwNumProtocols  = c_cProtocols;

    pPriorInfo->ppmProtocolMetric[ 0 ].dwProtocolId   = PROTO_IP_LOCAL;
    pPriorInfo->ppmProtocolMetric[ 0 ].dwMetric       = 1;

    pPriorInfo->ppmProtocolMetric[ 1 ].dwProtocolId   = PROTO_IP_NT_STATIC;
    pPriorInfo->ppmProtocolMetric[ 1 ].dwMetric       = 3;

    pPriorInfo->ppmProtocolMetric[ 2 ].dwProtocolId   = PROTO_IP_NT_STATIC_NON_DOD;
    pPriorInfo->ppmProtocolMetric[ 2 ].dwMetric       = 5;

    pPriorInfo->ppmProtocolMetric[ 3 ].dwProtocolId   = PROTO_IP_NT_AUTOSTATIC;
    pPriorInfo->ppmProtocolMetric[ 3 ].dwMetric       = 7;

    pPriorInfo->ppmProtocolMetric[ 4 ].dwProtocolId   = PROTO_IP_NETMGMT;
    pPriorInfo->ppmProtocolMetric[ 4 ].dwMetric       = 10;

    pPriorInfo->ppmProtocolMetric[ 5 ].dwProtocolId   = PROTO_IP_OSPF;
    pPriorInfo->ppmProtocolMetric[ 5 ].dwMetric       = 110;

    pPriorInfo->ppmProtocolMetric[ 6 ].dwProtocolId   = PROTO_IP_RIP;
    pPriorInfo->ppmProtocolMetric[ 6 ].dwMetric       = 120;
    
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxInterfaceInfo
//
//  Purpose:    Create the router interface block for IPX.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxInterfaceInfo (
        LPCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    Assert (ppBuff);

    const BOOL fDialInInterface = (NULL == pszwAdapterName);

    const int c_cTocEntries = 5;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_IF_INFO)
                    + sizeof(IPX_ADAPTER_INFO)
                    + sizeof(IPXWAN_IF_INFO)
                    + sizeof(RIP_IF_CONFIG)
                    + sizeof(SAP_IF_CONFIG)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) new BYTE [dwSize];
    *ppBuff = (LPBYTE) pIBH;

	if(pIBH == NULL)
		return;
		
    ZeroMemory (pIBH, dwSize);

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager interface info.
    //
    pTocEntry->InfoType         = IPX_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PIPX_IF_INFO pIfInfo        = (PIPX_IF_INFO) pbDataPtr;
    pIfInfo->AdminState         = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosAccept      = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosDeliver     = (fDialInInterface) ? ADMIN_STATE_DISABLED
                                                     : ADMIN_STATE_ENABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make adapter info.
    //
    pTocEntry->InfoType         = IPX_ADAPTER_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_ADAPTER_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PIPX_ADAPTER_INFO pAdInfo   = (PIPX_ADAPTER_INFO) pbDataPtr;
    if (ISN_FRAME_TYPE_AUTO == dwPacketType)
    {
        dwPacketType = AUTO_DETECT_PACKET_TYPE;
    }
    pAdInfo->PacketType         = dwPacketType;
    if (pszwAdapterName)
    {
        AssertSz (lstrlen (pszwAdapterName) < celems (pAdInfo->AdapterName),
                  "Bindname too big for pAdInfo->AdapterName buffer.");
        lstrcpy (pAdInfo->AdapterName, pszwAdapterName);
    }
    else
    {
        AssertSz (0 == pAdInfo->AdapterName[0],
                    "Who removed the ZeroMemory call above?");
    }

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make wan info.
    //
    pTocEntry->InfoType         = IPXWAN_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPXWAN_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PIPXWAN_IF_INFO pWanInfo    = (PIPXWAN_IF_INFO) pbDataPtr;
    pWanInfo->AdminState        = ADMIN_STATE_DISABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PRIP_IF_CONFIG pRipInfo     = (PRIP_IF_CONFIG) pbDataPtr;
    pRipInfo->RipIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pRipInfo->RipIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pRipInfo->RipIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.PeriodicUpdateInterval  = 60;
    pRipInfo->RipIfInfo.AgeIntervalMultiplier   = 3;
    pRipInfo->RipIfFilters.SupplyFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.SupplyFilterCount    = 0;
    pRipInfo->RipIfFilters.ListenFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.ListenFilterCount    = 0;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PSAP_IF_CONFIG pSapInfo     = (PSAP_IF_CONFIG) pbDataPtr;
    pSapInfo->SapIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pSapInfo->SapIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pSapInfo->SapIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.GetNearestServerReply   = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.PeriodicUpdateInterval  = 60;
    pSapInfo->SapIfInfo.AgeIntervalMultiplier   = 3;
    pSapInfo->SapIfFilters.SupplyFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.SupplyFilterCount    = 0;
    pSapInfo->SapIfFilters.ListenFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.ListenFilterCount    = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxTransportInfo
//
//  Purpose:    Create the router transport blocks for IPX.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    MakeIpxInterfaceInfo (NULL, ISN_FRAME_TYPE_AUTO, ppBuffClient);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_GLOBAL_INFO)
                    + sizeof(RIP_GLOBAL_INFO)
                    + sizeof(SAP_GLOBAL_INFO)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) new BYTE [dwSize];
    *ppBuffGlobal = (LPBYTE) pIBH;

    if (pIBH == NULL)
    	return;
    	
    ZeroMemory (pIBH, dwSize);

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager global info.
    //
    pTocEntry->InfoType         = IPX_GLOBAL_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PIPX_GLOBAL_INFO pGlbInfo       = (PIPX_GLOBAL_INFO) pbDataPtr;
    pGlbInfo->RoutingTableHashSize  = IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE;
    pGlbInfo->EventLogMask          = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PRIP_GLOBAL_INFO pRipInfo   = (PRIP_GLOBAL_INFO) pbDataPtr;
    pRipInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (int)(pbDataPtr - (PBYTE)pIBH);

    PSAP_GLOBAL_INFO pSapInfo   = (PSAP_GLOBAL_INFO) pbDataPtr;
    pSapInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;
}



//+---------------------------------------------------------------------------
//
// mprapi.h wrappers to return HRESULTs and obey rules of COM in regard
// to output parameters.
//

HRESULT
HrMprConfigServerConnect(
    IN      LPWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigServerConnect (lpwsServerName, phMprConfig);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phMprConfig = NULL;
    }
    TraceError ("HrMprConfigServerConnect", hr);
    return hr;
}

HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceCreate (hMprConfig, dwLevel, lpbBuffer,
                                         phRouterInterface);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceErrorOptional ("HrMprConfigInterfaceCreate", hr,
                        (HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr));
    return hr;
}

HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceEnum (hMprConfig, dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceErrorOptional ("HrMprConfigInterfaceCreate", hr,
                        (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr));
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportEnum (hMprConfig, hRouterInterface,
                    dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceErrorOptional ("HrMprConfigInterfaceTransportEnum", hr,
                        (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr));
    return hr;
}

HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceGetHandle (hMprConfig, lpwsInterfaceName,
                                            phRouterInterface);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceErrorOptional ("HrMprConfigInterfaceGetHandle", hr,
                        (HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr));
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportAdd (hMprConfig, hRouterInterface,
                                               dwTransportId, lpwsTransportName,
                                               pInterfaceInfo, dwInterfaceInfoSize,
                                               phRouterIfTransport);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceError ("HrMprConfigInterfaceTransportAdd", hr);
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportRemove(hMprConfig, hRouterInterface,
                                                 hRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceErrorOptional ("HrMprConfigInterfaceTransportRemove", hr, FALSE);
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportGetHandle (hMprConfig,
                                                     hRouterInterface,
                                                     dwTransportId,
                                                     phRouterIfTransport);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceErrorOptional ("HrMprConfigInterfaceTransportAdd", hr,
                        (HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr));
    return hr;
}

HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportCreate (hMprConfig, dwTransportId,
                    lpwsTransportName, pGlobalInfo, dwGlobalInfoSize,
                    pClientInterfaceInfo, dwClientInterfaceInfoSize,
                    lpwsDLLPath, phRouterTransport);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceError ("HrMprConfigTransportCreate", hr);
    return hr;
}

HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportDelete (hMprConfig, hRouterTransport);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceError ("HrMprConfigTransportDelete", hr);
    return hr;
}

HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetHandle (hMprConfig, dwTransportId,
                                            phRouterTransport);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceError ("HrMprConfigTransportGetHandle",
                (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
                ? S_OK : hr);
    return hr;
}

HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT LPWSTR*                 lplpwsDLLPath               OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetInfo (hMprConfig, hRouterTransport,
                                          ppGlobalInfo, lpdwGlobalInfoSize,
                                          ppClientInterfaceInfo,
                                          lpdwClientInterfaceInfoSize,
                                          lplpwsDLLPath);
    if (NO_ERROR != dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceError ("HrMprConfigTransportGetInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\datafmt.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    datafmt.h
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Class declarations for IPX data formatting routines 
// Originally written by VadimE. (this should actually be in the common library)
//=============================================================================

#ifndef _DATAFMT_H_
#define _DATAFMT_H_

class CIPX_NETWORK {
public:
    CIPX_NETWORK(PUCHAR net): m_pNet(net) {};
    operator PUCHAR () {return m_pNet;};
    friend CString& operator << (
        CString&        str,
        CIPX_NETWORK    &net
        );
    friend LPTSTR& operator << (
        LPTSTR&         str,
        CIPX_NETWORK    &net
        );
    friend CString& operator >> (
        CString&        str,
        CIPX_NETWORK    &net
        );
private:
    PUCHAR  m_pNet;
    CIPX_NETWORK();
};

class CIPX_NODE {
public:
    CIPX_NODE(PUCHAR node): m_pNode(node) {};
    operator PUCHAR () {return m_pNode;};
    friend CString& operator << (
        CString&    str,
        CIPX_NODE   &node
        );
    friend LPTSTR& operator << (
        LPTSTR&     str,
        CIPX_NODE   &node
        );
    friend CString& operator >> (
        CString&    str,
        CIPX_NODE   &node
        );
private:
    PUCHAR  m_pNode;
    CIPX_NODE();
};

class CIPX_SOCKET {
public:
    CIPX_SOCKET(PUCHAR sock): m_pSock(sock) {};
    operator PUCHAR () {return m_pSock;};
    friend CString& operator << (
        CString&    str,
        CIPX_SOCKET &sock
        );
    friend LPTSTR& operator << (
        LPTSTR&     str,
        CIPX_SOCKET &sock
        );
    friend CString& operator >> (
        CString&    str,
        CIPX_SOCKET &sock
        );
private:
    PUCHAR  m_pSock;
    CIPX_SOCKET();
};

class CIPX_PACKET_TYPE {
public:
    CIPX_PACKET_TYPE(UCHAR type): m_Type(type), m_pType(&m_Type) {};
    CIPX_PACKET_TYPE(PUCHAR pType): m_pType(pType) {};
    operator USHORT () {return *m_pType;};
    friend CString& operator << (
        CString&            str,
        CIPX_PACKET_TYPE&  type
        );
    friend LPTSTR& operator << (
        LPTSTR&             str,
        CIPX_PACKET_TYPE&  type
        );
    friend CString& operator >> (
        CString&            str,
        CIPX_PACKET_TYPE&  type
        );
private:
    UCHAR  m_Type;
    PUCHAR m_pType;
    CIPX_PACKET_TYPE();
};

class CIPX_ADDRESS {
public:
    CIPX_ADDRESS (
        PUCHAR net, 
		PUCHAR mask,
        PUCHAR node, 
        PUCHAR sock
        ):m_pNet(net), m_pMask(mask), m_pNode(node), m_pSock(sock)
    {};
    friend LPTSTR& operator << (
        LPTSTR&         str,
        CIPX_ADDRESS&   addr
        );
    friend CString& operator << (
        CString&        str,
        CIPX_ADDRESS&   addr
        );
private:
    PUCHAR      m_pNet;
	PUCHAR		m_pMask;
    PUCHAR      m_pNode;
    PUCHAR      m_pSock;
    CIPX_ADDRESS();
};

#endif // _DATAFMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipadd.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipadd.h
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Class declarations for IP filter Add/Edit routines
//============================================================================

#include "ipctrl.h"

/////////////////////////////////////////////////////////////////////////////
// CIpFltrAddEdit dialog

class CIpFltrAddEdit : public CBaseDialog
{
// Construction
public:
	CIpFltrAddEdit(	CWnd* pParent,
					FilterListEntry ** ppFilterEntry,
					DWORD dwFilterType);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CIpFltrAddEdit)
	enum { IDD = IDD_IPFILTER_ADDEDIT };
	CStatic	m_stDstPort;
	CStatic	m_stSrcPort;
	CComboBox	m_cbFoo;
	CEdit	m_cbSrcPort;
	CEdit	m_cbDstPort;
	CComboBox	m_cbProtocol;
	CString	m_sProtocol;
	CString	m_sSrcPort;
	CString	m_sDstPort;
	//}}AFX_DATA

	CEdit	m_ebFoo;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIpFltrAddEdit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CString GetIcmpTypeString( WORD dwPort );
	CString GetIcmpCodeString( WORD dwPort );
	CString GetPortString( DWORD dwProtocol, WORD dwPort );
	WORD GetPortNumber( DWORD dwProtocol, CString& cStr);
	WORD GetIcmpType( CString& cStr);
	WORD GetIcmpCode( CString& cStr);

// Implementation
protected:
	static DWORD		m_dwHelpMap[];

	FilterListEntry**	m_ppFilterEntry;
	IPControl			m_ipSrcAddress;
	IPControl			m_ipSrcMask;
	IPControl			m_ipDstAddress;
	IPControl			m_ipDstMask;
	BOOL				m_bEdit;
	BOOL				m_bSrc;
	BOOL				m_bDst;
	DWORD				m_dwFilterType;

	UINT_PTR QueryCurrentProtocol() { return (m_cbProtocol.GetItemData(m_cbProtocol.GetCurSel()));}

	void SetProtocolSelection( UINT idProto );

	// Generated message map functions
	//{{AFX_MSG(CIpFltrAddEdit)
	afx_msg void OnSelchangeProtocol();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnCbSourceClicked();
	afx_msg void OnCbDestClicked();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\remrras\server\ustringp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ustringp.h
//
//--------------------------------------------------------------------------

#ifndef _USTRINGP_H_
#define _USTRINGP_H_


//nclude <ntdef.h>
//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
#ifndef _USTRINGP_NO_UNICODE_STRING
	
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif

#ifndef _USTRINGP_NO_UNICODE_STRING32

typedef struct _STRING32 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONG  Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;

#endif





#ifdef __cplusplus
extern "C"
{
#endif

void
SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz );
void
SetUnicodeMultiString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          pmsz );

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\datafmt.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    datafmt.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IPX data formatting routines
//============================================================================

// helper routines for data formatting - copied from ..\ipxadmin\datafmt.cpp

#include "stdafx.h"
#include "resource.h"
#include "datafmt.h"

CString&
operator << (
    CString&        str,
    CIPX_NETWORK&   net
    ) {
    str.Format (TEXT ("%.2x%.2x%.2x%.2x"),
                net.m_pNet[0],net.m_pNet[1],net.m_pNet[2],net.m_pNet[3]);
    return str;
}

LPTSTR&
operator << (
    LPTSTR&         str,
    CIPX_NETWORK&   net
    ) {
    _stprintf (str, TEXT ("%.2x%.2x%.2x%.2x"),
                net.m_pNet[0],net.m_pNet[1],net.m_pNet[2],net.m_pNet[3]);
    return str;
}


CString&
operator >> (
    CString&    str,
    CIPX_NETWORK &net
    ) {
    ULONG   val; INT n;
    if ((_stscanf (str, TEXT("%lx%n"), &val, &n)==1) && (n==str.GetLength())) {
        net.m_pNet[0] = (UCHAR)(val>>24);
        net.m_pNet[1] = (UCHAR)(val>>16);
        net.m_pNet[2] = (UCHAR)(val>>8);
        net.m_pNet[3] = (UCHAR)(val);
        return str;
    }
    AfxMessageBox (IDS_INVALID_NETWORK_NUMBER);
//    throw (DWORD)ERROR_INVALID_DATA;
    return str;
}

CString&
operator << (
    CString&    str,
    CIPX_NODE&  node
    ) {
    str.Format (TEXT ("%.2x%.2x%.2x%.2x%.2x%.2x"),
                node.m_pNode[0],node.m_pNode[1],node.m_pNode[2],
                node.m_pNode[3],node.m_pNode[4],node.m_pNode[5]);
    return str;
}

LPTSTR&
operator << (
    LPTSTR&     str,
    CIPX_NODE&  node
    ) {
    _stprintf (str, TEXT ("%.2x%.2x%.2x%.2x%.2x%.2x"),
                node.m_pNode[0],node.m_pNode[1],node.m_pNode[2],
                node.m_pNode[3],node.m_pNode[4],node.m_pNode[5]);
    return str;
}

CString&
operator >> (
    CString&    str,
    CIPX_NODE   &node
    ) {
    ULONGLONG   val; INT n;
    if ((_stscanf (str, TEXT("%I64x%n"), &val, &n)==1)
            && (val<=0xFFFFFFFFFFFFI64)
            && (n==str.GetLength())) {
        node.m_pNode[0] = (UCHAR)(val>>40);
        node.m_pNode[1] = (UCHAR)(val>>32);
        node.m_pNode[2] = (UCHAR)(val>>24);
        node.m_pNode[3] = (UCHAR)(val>>16);
        node.m_pNode[4] = (UCHAR)(val>>8);
        node.m_pNode[5] = (UCHAR)(val);
        return str;
    }
    AfxMessageBox (IDS_INVALID_NODE_NUMBER);
//    throw (DWORD)ERROR_INVALID_DATA;
    return str;
}


CString&
operator << (
    CString&    str,
    CIPX_SOCKET &sock
    ) {
    str.Format (TEXT ("%.2x%.2x"),
                sock.m_pSock[0],sock.m_pSock[1]);
    return str;
}

LPTSTR&
operator << (
    LPTSTR&     str,
    CIPX_SOCKET &sock
    ) {
    _stprintf (str, TEXT ("%.2x%.2x"),
                sock.m_pSock[0],sock.m_pSock[1]);
    return str;
}


CString&
operator >> (
    CString&    str,
    CIPX_SOCKET &sock
    ) {
    USHORT   val; INT n;
    if ((_stscanf (str, TEXT("%hx%n"), &val, &n)==1) && (n==str.GetLength())) {
        sock.m_pSock[0] = (UCHAR)(val>>8);
        sock.m_pSock[1] = (UCHAR)(val);
        return str;
    }
    AfxMessageBox (IDS_INVALID_SOCKET_NUMBER);
//    throw (DWORD)ERROR_INVALID_DATA;
    return str;
}

CString&
operator << (
    CString&            str,
    CIPX_PACKET_TYPE&  type
    ) {
    str.Format (TEXT ("%.1x"), *type.m_pType);
    return str;
 }
LPTSTR&
operator << (
    LPTSTR&             str,
    CIPX_PACKET_TYPE&  type
    ) {
    _stprintf (str, TEXT ("%.1x"), *type.m_pType);
    return str;
 }


CString&
operator >> (
    CString&            str,
    CIPX_PACKET_TYPE&  type
    ) {
    
    INT n;
    CString cStr;

    if ((_stscanf (str, TEXT("%hx%n"), type.m_pType, &n)==1)
            && (n==str.GetLength())) {

        return str;
    }
    
    AfxMessageBox (IDS_INVALID_SERVICE_TYPE);
//    throw (DWORD)ERROR_INVALID_DATA;
    return str;
 }

CString&
operator << (
    CString&        str,
    CIPX_ADDRESS    &addr
    ) {
    str.Format (TEXT ("%.2x%.2x%.2x%.2x.%.2x%.2x%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x.%.2x%.2x"),
                addr.m_pNet[0],addr.m_pNet[1],addr.m_pNet[2],addr.m_pNet[3],
                addr.m_pMask[0],addr.m_pMask[1],addr.m_pMask[2],addr.m_pMask[3],
                addr.m_pNode[0],addr.m_pNode[1],addr.m_pNode[2],
                    addr.m_pNode[3],addr.m_pNode[4],addr.m_pNode[5],
                addr.m_pSock[0],addr.m_pSock[1]);
    return str;
}

LPTSTR&
operator << (
    LPTSTR&         str,
    CIPX_ADDRESS    &addr
    ) {
    _stprintf (str, TEXT ("%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x.%.2x%.2x"),
                addr.m_pNet[0],addr.m_pNet[1],addr.m_pNet[2],addr.m_pNet[3],
                addr.m_pMask[0],addr.m_pMask[1],addr.m_pMask[2],addr.m_pMask[3],
                addr.m_pNode[0],addr.m_pNode[1],addr.m_pNode[2],
                    addr.m_pNode[3],addr.m_pNode[4],addr.m_pNode[5],
                addr.m_pSock[0],addr.m_pSock[1]);
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipadd.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipadd.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IP Filter Add/Edit dialog code
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipfltr.h"
#include "ipadd.h"
extern "C" {
#include <winsock.h>
#include <fltdefs.h>
#include <iprtinfo.h>
}
#include "ipaddr.h"

#include "rtradmin.hm"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static	enum {
	PROTOCOL_TCP = 0,
	PROTOCOL_TCP_ESTABLISHED,
	PROTOCOL_UDP,
	PROTOCOL_ICMP,
	PROTOCOL_ANY,
	PROTOCOL_OTHER,
};

static UINT g_aPROTOCOLS[][2] = {
	{IDS_PROTOCOL_TCP,	PROTOCOL_TCP},
	{IDS_PROTOCOL_TCP_ESTABLISHED, PROTOCOL_TCP_ESTABLISHED},
	{IDS_PROTOCOL_UDP,  PROTOCOL_UDP},
	{IDS_PROTOCOL_ICMP, PROTOCOL_ICMP},
	{IDS_PROTOCOL_ANY,  PROTOCOL_ANY},
	{IDS_PROTOCOL_OTHER, PROTOCOL_OTHER},
};

#define IDS_ICMP_ECHO 1
#define IDS_ICMP_REDIRECT 2

#if 0
// TODO sample ICMP types - need to update with actual list
static UINT g_aICMPTYPE[][2] = {
    {1, IDS_ICMP_ECHO},
    {2, IDS_ICMP_REDIRECT}
}; 
#endif

HRESULT MultiEnableWindow(HWND hWndParent, BOOL fEnable, UINT first, ...)
{
	UINT	nCtrlId = first;
	HWND	hWndCtrl;
	
	va_list	marker;

	va_start(marker, first);

	while (nCtrlId != 0)
	{
		hWndCtrl = ::GetDlgItem(hWndParent, nCtrlId);
		Assert(hWndCtrl);
		if (hWndCtrl)
			::EnableWindow(hWndCtrl, fEnable);

		// get the next item
		nCtrlId = va_arg(marker, UINT);
	}

	
	va_end(marker);

	return hrOK;
}



/////////////////////////////////////////////////////////////////////////////
// CIpFltrAddEdit dialog


CIpFltrAddEdit::CIpFltrAddEdit(CWnd* pParent,
							   FilterListEntry ** ppFilterEntry,
							   DWORD dwFilterType)
	: CBaseDialog(CIpFltrAddEdit::IDD, pParent),
	  m_ppFilterEntry( ppFilterEntry ),
	  m_dwFilterType ( dwFilterType )
{
	//{{AFX_DATA_INIT(CIpFltrAddEdit)
	m_sProtocol = _T("");
	m_sSrcPort = _T("");
	m_sDstPort = _T("");
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CIpFltrAddEdit::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIpFltrAddEdit)
	DDX_Control(pDX, IDC_AEIP_ST_DEST_PORT, m_stDstPort);
	DDX_Control(pDX, IDC_AEIP_ST_SRC_PORT, m_stSrcPort);
	DDX_Control(pDX, IDC_AEIP_CB_SRC_PORT, m_cbSrcPort);
	DDX_Control(pDX, IDC_AEIP_CB_DEST_PORT, m_cbDstPort);
	DDX_Control(pDX, IDC_AEIP_CB_PROTOCOL, m_cbProtocol);
	DDX_CBString(pDX, IDC_AEIP_CB_PROTOCOL, m_sProtocol);
	DDV_MaxChars(pDX, m_sProtocol, 32);
	DDX_CBString(pDX, IDC_AEIP_CB_SRC_PORT, m_sSrcPort);
	DDV_MaxChars(pDX, m_sSrcPort, 16);
	DDX_CBString(pDX, IDC_AEIP_CB_DEST_PORT, m_sDstPort);
	DDV_MaxChars(pDX, m_sDstPort, 16);
    DDX_Check(pDX, IDC_AEIP_CB_SOURCE, m_bSrc);
    DDX_Check(pDX, IDC_AEIP_CB_DEST, m_bDst);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CIpFltrAddEdit, CBaseDialog)
	//{{AFX_MSG_MAP(CIpFltrAddEdit)
	ON_CBN_SELCHANGE(IDC_AEIP_CB_PROTOCOL, OnSelchangeProtocol)
	ON_BN_CLICKED(IDC_AEIP_CB_SOURCE, OnCbSourceClicked)
	ON_BN_CLICKED(IDC_AEIP_CB_DEST, OnCbDestClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CIpFltrAddEdit::m_dwHelpMap[] =
{
//	IDC_AEIP_ST_SOURCE, HIDC_AEIP_ST_SOURCE,
//	IDC_AEIP_CB_SOURCE, HIDC_AEIP_CB_SOURCE,
//	IDC_AEIP_ST_SOURCE_ADDRESS, HIDC_AEIP_ST_SOURCE_ADDRESS,
//	IDC_AEIP_EB_SOURCE_ADDRESS, HIDC_AEIP_EB_SOURCE_ADDRESS,
//	IDC_AEIP_ST_SOURCE_MASK, HIDC_AEIP_ST_SOURCE_MASK,
//	IDC_AEIP_EB_SOURCE_MASK, HIDC_AEIP_EB_SOURCE_MASK,
//	IDC_AEIP_ST_DEST, HIDC_AEIP_ST_DEST,
//	IDC_AEIP_CB_DEST, HIDC_AEIP_CB_DEST,
//	IDC_AEIP_ST_DEST_ADDRESS, HIDC_AEIP_ST_DEST_ADDRESS,
//	IDC_AEIP_EB_DEST_ADDRESS, HIDC_AEIP_EB_DEST_ADDRESS,
//	IDC_AEIP_ST_DEST_MASK, HIDC_AEIP_ST_DEST_MASK,
//	IDC_AEIP_EB_DEST_MASK, HIDC_AEIP_EB_DEST_MASK,
//	IDC_AEIP_ST_PROTOCOL, HIDC_AEIP_ST_PROTOCOL,
//	IDC_AEIP_CB_PROTOCOL, HIDC_AEIP_CB_PROTOCOL,
//	IDC_AEIP_ST_SRC_PORT, HIDC_AEIP_ST_SRC_PORT,
//	IDC_AEIP_CB_SRC_PORT, HIDC_AEIP_CB_SRC_PORT,
//	IDC_AEIP_ST_DEST_PORT, HIDC_AEIP_ST_DEST_PORT,
//	IDC_AEIP_CB_DEST_PORT, HIDC_AEIP_CB_DEST_PORT,
	0,0,
};

/////////////////////////////////////////////////////////////////////////////
// CIpFltrAddEdit message handlers

//-----------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::OnSelchangeProtocol
//
// Handles 'CBN_SELCHANGE' notification from Protocols combo box
//------------------------------------------------------------------------------

void CIpFltrAddEdit::OnSelchangeProtocol() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CWnd * hWnd;
	CString   cStr;

	// if tcp or udp, then enable src/dest port
	// if icmp, rename strings and enable type/code
	// if Other enable src port
	// if Any disable everything

	switch(QueryCurrentProtocol()) {
	case PROTOCOL_TCP:
	case PROTOCOL_TCP_ESTABLISHED:
	case PROTOCOL_UDP:  
		VERIFY(cStr.LoadString(IDS_SRC_PORT));	  
		m_stSrcPort.SetWindowText(cStr);
		VERIFY(cStr.LoadString(IDS_DST_PORT));	  
		m_stDstPort.SetWindowText(cStr);
		m_cbSrcPort.ShowWindow(SW_SHOW);
		m_cbDstPort.ShowWindow(SW_SHOW);
		m_stSrcPort.ShowWindow(SW_SHOW);
		m_stDstPort.ShowWindow(SW_SHOW);
		break;

	case PROTOCOL_ICMP:
		VERIFY(cStr.LoadString(IDS_ICMP_TYPE));	  
		m_stSrcPort.SetWindowText(cStr);
		VERIFY(cStr.LoadString(IDS_ICMP_CODE));	  
		m_stDstPort.SetWindowText(cStr);
		m_cbSrcPort.ShowWindow(SW_SHOW);
		m_cbDstPort.ShowWindow(SW_SHOW);
   		m_stSrcPort.ShowWindow(SW_SHOW);
		m_stDstPort.ShowWindow(SW_SHOW);
		break;

	case PROTOCOL_ANY:
		m_cbSrcPort.ShowWindow(SW_HIDE);
		m_cbDstPort.ShowWindow(SW_HIDE);
		VERIFY(hWnd = GetDlgItem(IDC_AEIP_ST_SRC_PORT));
		hWnd->ShowWindow(SW_HIDE);
		VERIFY(hWnd = GetDlgItem(IDC_AEIP_ST_DEST_PORT));
		hWnd->ShowWindow(SW_HIDE);
		break;

	case PROTOCOL_OTHER:
		VERIFY(cStr.LoadString(IDS_OTHER_PROTOCOL));	  
		m_stSrcPort.SetWindowText(cStr);
		m_cbSrcPort.ShowWindow(SW_SHOW);
   		m_stSrcPort.ShowWindow(SW_SHOW);
		m_cbDstPort.ShowWindow(SW_HIDE);
		VERIFY(hWnd = GetDlgItem(IDC_AEIP_ST_DEST_PORT));
		hWnd->ShowWindow(SW_HIDE);
		break;
	}
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::OnInitDialog
//
// Handles 'WM_INITDIALOG' notification from the dialog
//------------------------------------------------------------------------------

BOOL CIpFltrAddEdit::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString     st;
    
	CBaseDialog::OnInitDialog();

	// determine if a new filter is being added or if an
	// existing filter is being modified.
	m_bEdit = ( *m_ppFilterEntry != NULL );

    st.LoadString(m_bEdit ? IDS_IP_EDIT_FILTER : IDS_IP_ADD_FILTER);
    SetWindowText(st);
    

	// create the IP controls
    m_ipSrcAddress.Create(m_hWnd, IDC_AEIP_EB_SOURCE_ADDRESS);
    m_ipSrcMask.Create(m_hWnd, IDC_AEIP_EB_SOURCE_MASK);
	IpAddr_ForceContiguous((HWND) m_ipSrcMask);
	
    m_ipDstAddress.Create(m_hWnd, IDC_AEIP_EB_DEST_ADDRESS);
    m_ipDstMask.Create(m_hWnd, IDC_AEIP_EB_DEST_MASK);
	IpAddr_ForceContiguous((HWND) m_ipDstMask);

	// disable IP controls by default
	CheckDlgButton(IDC_AEIP_CB_SOURCE, FALSE);
	OnCbSourceClicked();
	CheckDlgButton(IDC_AEIP_CB_DEST, FALSE);
	OnCbDestClicked();

	CString sProtocol;

	// fill up the protocol combo box with list of protocols
    UINT  count = sizeof(g_aPROTOCOLS)/sizeof(g_aPROTOCOLS[0]);
	for ( UINT i = 0; i < count; i++ ) {
		sProtocol.LoadString(g_aPROTOCOLS[i][0]);
		UINT item = m_cbProtocol.AddString(sProtocol);
		m_cbProtocol.SetItemData(item, g_aPROTOCOLS[i][1]);
		if( g_aPROTOCOLS[i][1] == PROTOCOL_ANY ) 
		{
			m_cbProtocol.SetCurSel(item);
		}
	}

	// Fill in the controls if the user is editing a filter

    if(m_bEdit)
    {
	  FilterListEntry * pfle = *m_ppFilterEntry;

	  if( pfle->dwSrcAddr == 0 &&
		  pfle->dwSrcMask == 0 )
	  {
		  m_bSrc = FALSE;
		  CheckDlgButton( IDC_AEIP_CB_SOURCE, 0);
	  }
	  else
	  {
		  m_bSrc = TRUE;
		  CheckDlgButton( IDC_AEIP_CB_SOURCE, 1);
		  m_ipSrcAddress.SetAddress(INET_NTOA(pfle->dwSrcAddr));
		  m_ipSrcMask.SetAddress(INET_NTOA(pfle->dwSrcMask));
		  GetDlgItem(IDC_AEIP_EB_SOURCE_ADDRESS)->EnableWindow(TRUE);  
		  GetDlgItem(IDC_AEIP_EB_SOURCE_MASK)->EnableWindow(TRUE);  
	  }

	  if( pfle->dwDstAddr == 0 &&
		  pfle->dwDstMask == 0 )
	  {
		  m_bDst = FALSE;
		  CheckDlgButton( IDC_AEIP_CB_DEST, 0);
	  }
	  else
	  {
		  m_bDst = TRUE;
		  CheckDlgButton( IDC_AEIP_CB_DEST, 1);
		  m_ipDstAddress.SetAddress(INET_NTOA(pfle->dwDstAddr));
		  m_ipDstMask.SetAddress(INET_NTOA(pfle->dwDstMask));		
		  GetDlgItem(IDC_AEIP_EB_DEST_ADDRESS)->EnableWindow(TRUE);  	
		  GetDlgItem(IDC_AEIP_EB_DEST_MASK)->EnableWindow(TRUE);
	  }

	  if ( pfle->dwProtocol == FILTER_PROTO_ANY )
	  {
		  SetProtocolSelection(IDS_PROTOCOL_ANY);
	  }
	  else if ( pfle->dwProtocol == FILTER_PROTO_ICMP )
	  {
		  SetProtocolSelection(IDS_PROTOCOL_ICMP);
		  m_cbSrcPort.SetWindowText(GetIcmpTypeString( pfle->wSrcPort));
		  m_cbDstPort.SetWindowText(GetIcmpCodeString( pfle->wDstPort));
	  }
	  else if ( pfle->dwProtocol == FILTER_PROTO_TCP )	
	  {
          if(pfle->fLateBound & TCP_ESTABLISHED_FLAG)
          {
              SetProtocolSelection(IDS_PROTOCOL_TCP_ESTABLISHED);
          }
          else
          {
		      SetProtocolSelection(IDS_PROTOCOL_TCP);
          }

		  m_cbSrcPort.SetWindowText(GetPortString( pfle->dwProtocol, pfle->wSrcPort));
		  m_cbDstPort.SetWindowText(GetPortString( pfle->dwProtocol, pfle->wDstPort));
	  }
	  else if ( pfle->dwProtocol == FILTER_PROTO_UDP )
	  {
		  SetProtocolSelection(IDS_PROTOCOL_UDP);
		  m_cbSrcPort.SetWindowText(GetPortString( pfle->dwProtocol, pfle->wSrcPort));
		  m_cbDstPort.SetWindowText(GetPortString( pfle->dwProtocol, pfle->wDstPort));

	  }
	  else
	  {
		  WCHAR buffer[16+1];

		  SetProtocolSelection(IDS_PROTOCOL_OTHER);
		  m_cbSrcPort.SetWindowText(_itow(pfle->dwProtocol, buffer, 10) );
	  }
    }


	// enable/disable controls based on filter type
	if (m_dwFilterType == FILTER_PERUSER_OUT)
	{
		MultiEnableWindow(GetSafeHwnd(), FALSE,
						  IDC_AEIP_CB_SOURCE,
						  IDC_AEIP_ST_SOURCE_ADDRESS,
						  IDC_AEIP_EB_SOURCE_ADDRESS,
						  IDC_AEIP_ST_SOURCE_MASK,
						  IDC_AEIP_EB_SOURCE_MASK,
						  0);
	}
	else if (m_dwFilterType == FILTER_PERUSER_IN)
	{
		MultiEnableWindow(GetSafeHwnd(), FALSE,
						  IDC_AEIP_CB_DEST,
						  IDC_AEIP_ST_DEST_ADDRESS,
						  IDC_AEIP_EB_DEST_ADDRESS,
						  IDC_AEIP_ST_DEST_MASK,
						  IDC_AEIP_EB_DEST_MASK,
						  0);
	}	



	// enable disable controls depending on selection

	OnSelchangeProtocol();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::SetProtocolSelection
//
// Select the proper Protocol in the protocol 
//------------------------------------------------------------------------------

void CIpFltrAddEdit::SetProtocolSelection( UINT idProto )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString cStr;

	if(!cStr.LoadString(idProto))
	{
		AfxMessageBox(_T("Error loading resource"));
	}
	
	m_cbProtocol.GetItemData(m_cbProtocol.GetCurSel());

	UINT item = m_cbProtocol.FindStringExact(-1, cStr);

	if(item != CB_ERR)
		m_cbProtocol.SetCurSel(item);
	else
		m_cbProtocol.SetCurSel(0);
}


//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpTypeString
//
// returns a CString representing ICMP type (if known) or a string version
// of the Type number.
//------------------------------------------------------------------------------

CString CIpFltrAddEdit::GetIcmpTypeString( WORD dwPort )
{
	WCHAR buffer[16];

	CString s = _T("");

    // look through our list of ICMP types and if we know the type, load
    // the corresponding string, else convert the port number to string
    // and return the string.
#if 0
    UINT  count = sizeof(g_aICMPTYPE)/sizeof(g_aICMPTYPE[0]);
    for(UINT i = 0; i < count; i++)
    {
        if(g_aICMPTYPE[i][0] == dwPort)
		{
			VERIFY(s.LoadString(g_aICMPTYPE[i][1]));
            return (s);
		}
    }
#endif
	return (CString((LPWSTR)_itow(dwPort, buffer, 10)));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpCodeString
//
// returns a CString representing ICMP code (if known) or a string version
// of the Code number.
//------------------------------------------------------------------------------

CString CIpFltrAddEdit::GetIcmpCodeString( WORD dwPort )
{
	WCHAR buffer[16];

	return (CString((LPWSTR)_itow(dwPort, buffer, 10)));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetPortString
//
// returns a CString representing port type (eg., FTP, ECHO) (if known) or a string 
// version of the port number
//------------------------------------------------------------------------------

CString CIpFltrAddEdit::GetPortString( DWORD dwProtocol, WORD dwPort )
{
	WCHAR buffer[16];

	return (CString((LPWSTR)_itow(dwPort, buffer, 10)));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetPortNumber
//
// converts the port string name to port number and returns it
//------------------------------------------------------------------------------

WORD CIpFltrAddEdit::GetPortNumber( DWORD dwProtocol, CString& cStr)
{
	return ((WORD)(_wtoi((const wchar_t *)cStr.GetBuffer(10))));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpType
//
// returns a number version of the ICMP type string
//------------------------------------------------------------------------------

WORD CIpFltrAddEdit::GetIcmpType( CString& cStr)
{
	return ((WORD)(_wtoi((const wchar_t *)cStr.GetBuffer(10))));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpCode
//
// returns a number version of the ICMP code string
//------------------------------------------------------------------------------

WORD CIpFltrAddEdit::GetIcmpCode( CString& cStr)
{
	return ((WORD)(_wtoi((const wchar_t *)cStr.GetBuffer(10))));
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::OnOK
//
// handles 'BN_CLICKED' notification from "OK" button
//------------------------------------------------------------------------------

void CIpFltrAddEdit::OnOK() 
{

	FilterListEntry * pfle = new FilterListEntry;


    if ( !pfle )
    {
        AfxMessageBox( IDS_ERROR_NO_MEMORY );
        return;
    }

    ZeroMemory( pfle, sizeof(FilterListEntry) );


    //
    // Error breakout loop.
    //
    
	do {
	
		CString sAddr;


        //
		// if source network filter is specified, verify and
		// save data.
		//
		
		if ( m_bSrc = IsDlgButtonChecked(IDC_AEIP_CB_SOURCE) )
		{
			if(m_ipSrcAddress.GetAddress(sAddr) != 4)
			{
				AfxMessageBox(IDS_ENTER_SRC_ADDRESS);
				::SetFocus((HWND)m_ipSrcAddress);
				break;
			}
			
			pfle->dwSrcAddr = INET_ADDR(sAddr);
			
			if( m_ipSrcMask.GetAddress(sAddr) != 4)
			{
				AfxMessageBox(IDS_ENTER_SRC_MASK);
				::SetFocus((HWND)m_ipSrcMask);
				break;
			}
			
			pfle->dwSrcMask = INET_ADDR(sAddr);
			
            if ((pfle->dwSrcAddr & pfle->dwSrcMask) != pfle->dwSrcAddr)
            {
				AfxMessageBox(IDS_INVALID_SRC_MASK);
				::SetFocus((HWND)m_ipSrcMask);
				break;
            }
		}
		else
		{
			pfle->dwSrcAddr = 0;
			pfle->dwSrcMask = 0;
		}


        //
		// if destination network filter is specified, 
		// verify and save data.
		//
		
		if ( m_bDst = IsDlgButtonChecked(IDC_AEIP_CB_DEST) )
		{
			if(m_ipDstAddress.GetAddress(sAddr) != 4)
			{
				AfxMessageBox(IDS_ENTER_DST_ADDRESS);
				::SetFocus((HWND)m_ipDstAddress);
				break;
			}
			
			pfle->dwDstAddr = INET_ADDR(sAddr);

			
			if(m_ipDstMask.GetAddress(sAddr) != 4)
			{
				AfxMessageBox(IDS_ENTER_DST_MASK);
				::SetFocus((HWND)m_ipDstMask);
				break;
			}
			
			pfle->dwDstMask = INET_ADDR(sAddr);
			
            if ((pfle->dwDstAddr & pfle->dwDstMask) != pfle->dwDstAddr)
            {
				AfxMessageBox(IDS_INVALID_DST_MASK);
				::SetFocus((HWND)m_ipDstMask);
				break;
            }
		}
		else
		{
			pfle->dwDstAddr = 0;
			pfle->dwDstMask = 0;
		}


        //
        // verify and save protocol specific data
        //
        
		CString cStr = _T("");
		CString cStr2 = _T("");

		int index;

		switch(QueryCurrentProtocol()) {
		case PROTOCOL_TCP:
			pfle->dwProtocol = FILTER_PROTO_TCP;
			m_cbSrcPort.GetWindowText(cStr);
			pfle->wSrcPort = GetPortNumber(PROTOCOL_TCP, cStr);
			m_cbDstPort.GetWindowText(cStr);
			pfle->wDstPort = GetPortNumber(PROTOCOL_TCP, cStr);
			break;

		case PROTOCOL_TCP_ESTABLISHED:
			pfle->dwProtocol = FILTER_PROTO_TCP;
            pfle->fLateBound |= TCP_ESTABLISHED_FLAG;
			m_cbSrcPort.GetWindowText(cStr);
			pfle->wSrcPort = GetPortNumber(PROTOCOL_TCP_ESTABLISHED, cStr);
			m_cbDstPort.GetWindowText(cStr);
			pfle->wDstPort = GetPortNumber(PROTOCOL_TCP_ESTABLISHED, cStr);
			break;

		case PROTOCOL_UDP:
			pfle->dwProtocol = FILTER_PROTO_UDP;
			m_cbSrcPort.GetWindowText(cStr);
			pfle->wSrcPort = GetPortNumber(PROTOCOL_UDP, cStr);
			m_cbDstPort.GetWindowText(cStr);
			pfle->wDstPort = GetPortNumber(PROTOCOL_UDP, cStr);
			break;

		case PROTOCOL_ICMP:
			pfle->dwProtocol = FILTER_PROTO_ICMP;
			m_cbSrcPort.GetWindowText(cStr);
			m_cbDstPort.GetWindowText(cStr2);

			// Windows NT bugs: 83110
			// Default is 0xFF if none of the fields have data
			if (cStr.IsEmpty() && cStr2.IsEmpty())
			{
				pfle->wSrcPort = FILTER_ICMP_TYPE_ANY;
				pfle->wDstPort = FILTER_ICMP_CODE_ANY;
			}
			else
			{
				pfle->wSrcPort = GetIcmpType(cStr);
				pfle->wDstPort = GetIcmpCode(cStr2);
			}
			break;

		case PROTOCOL_ANY:
			pfle->dwProtocol = FILTER_PROTO_ANY;
			pfle->wSrcPort = pfle->wDstPort = 0;
			break;

		case PROTOCOL_OTHER:
			m_cbSrcPort.GetWindowText(cStr);
			pfle->dwProtocol = FILTER_PROTO(_wtoi((const wchar_t*)cStr.GetBuffer(16+1)));
			if(pfle->dwProtocol == 0)
			{
				AfxMessageBox(IDS_ENTER_OTHER_PROTOCOL);
				::SetFocus((HWND)m_cbSrcPort);
				delete pfle;
				return;
			}
			pfle->wSrcPort = pfle->wDstPort = 0;
			break;

		default:
		    AfxMessageBox( IDS_ERROR_SETTING_BLOCK );
		    delete pfle;
			return;
		}
		
        //
        // if this is a new filter, add it to m_ppFilterEntry
        //
        
    	if (!*m_ppFilterEntry)
	    {
	        *m_ppFilterEntry = pfle;
	    }

	    else
	    {
	        FilterListEntry *pfleDst = *m_ppFilterEntry;

	        pfleDst-> dwSrcAddr     = pfle-> dwSrcAddr;
	        pfleDst-> dwSrcMask     = pfle-> dwSrcMask;
	        pfleDst-> dwDstAddr     = pfle-> dwDstAddr;
	        pfleDst-> dwDstMask     = pfle-> dwDstMask;
	        pfleDst-> dwProtocol    = pfle-> dwProtocol;
	        pfleDst-> wSrcPort      = pfle-> wSrcPort;
	        pfleDst-> wDstPort      = pfle-> wDstPort;
	        pfleDst-> fLateBound      = pfle-> fLateBound;
	        
	        delete pfle;
	    }
	    
		// end the dialog
		CBaseDialog::OnOK();

		return;
		
	}while(FALSE);


    //
    // error condition
    //
    
	delete pfle;
	
	return;
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::OnCancel
//
// handles 'BN_CLICKED' notification from the Cancel button
//------------------------------------------------------------------------------

void CIpFltrAddEdit::OnCancel() 
{
	CBaseDialog::OnCancel();
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpTypeString
//
// Handles BN_CLICKED notification from "Source network" checkbox
//------------------------------------------------------------------------------

void CIpFltrAddEdit::OnCbSourceClicked() 
{
	m_bSrc = IsDlgButtonChecked(IDC_AEIP_CB_SOURCE);
    GetDlgItem(IDC_AEIP_EB_SOURCE_ADDRESS)->EnableWindow( m_bSrc );
    GetDlgItem(IDC_AEIP_EB_SOURCE_MASK)->EnableWindow( m_bSrc );
}

//------------------------------------------------------------------------------
// Function:	CIpFltrAddEdit::GetIcmpTypeString
//
// Handles BN_CLICKED notification from "Destination network" checkbox
//------------------------------------------------------------------------------


void CIpFltrAddEdit::OnCbDestClicked() 
{
	m_bDst = IsDlgButtonChecked(IDC_AEIP_CB_DEST);
    GetDlgItem(IDC_AEIP_EB_DEST_ADDRESS)->EnableWindow( m_bDst );
    GetDlgItem(IDC_AEIP_EB_DEST_MASK)->EnableWindow( m_bDst );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\fltrhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fltrhelp.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "rtrfiltr.hm"
#include "resource.h"


//
// What follows is the data that gets generated from
//		mkdlg.exe -c rtrfiltr.rc
//




// "File rtrfiltr.rc line 82 : Resource - DIALOG : IDD_IPXFILTER"
static const DWORD rgdw_IDD_IPXFILTER[] = 
{
    IDC_IPX_PERMIT, HIDC_IPX_PERMIT,
    IDC_IPX_DENY, HIDC_IPX_DENY,
    IDC_IPX_FILTER_LIST, HIDC_IPX_FILTER_LIST,
    IDC_IPX_FILTER_ADD, HIDC_IPX_FILTER_ADD,
    IDC_IPX_FILTER_EDIT, HIDC_IPX_FILTER_EDIT,
    IDC_IPX_FILTER_DELETE, HIDC_IPX_FILTER_DELETE,
	0,0 
};


// "File rtrfiltr.rc line 106 : Resource - DIALOG : IDD_IPXFILTER_ADDEDIT"
static const DWORD rgdw_IDD_IPXFILTER_ADDEDIT[] = 
{
    IDC_AI_ST_SRC_NET, HIDC_AI_ST_SRC_NET,
    IDC_AEIPX_EB_SRC_NET, HIDC_AEIPX_EB_SRC_NET,
    IDC_AI_ST_SRC_MASK, HIDC_AI_ST_SRC_MASK,
    IDC_AEIPX_EB_SRC_MASK, HIDC_AEIPX_EB_SRC_MASK,
    IDC_AI_ST_SRC_NODE, HIDC_AI_ST_SRC_NODE,
    IDC_AEIPX_EB_SRC_NODE, HIDC_AEIPX_EB_SRC_NODE,
    IDC_AI_ST_SRC_SOCKET, HIDC_AI_ST_SRC_SOCKET,
    IDC_AEIPX_EB_SRC_SOCKET, HIDC_AEIPX_EB_SRC_SOCKET,
    IDC_AI_ST_DST_NET, HIDC_AI_ST_DST_NET,
    IDC_AEIPX_EB_DST_NET, HIDC_AEIPX_EB_DST_NET,
    IDC_AI_ST_DST_MASK, HIDC_AI_ST_DST_MASK,
    IDC_AEIPX_EB_DST_MASK, HIDC_AEIPX_EB_DST_MASK,
    IDC_AI_ST_DST_NODE, HIDC_AI_ST_DST_NODE,
    IDC_AEIPX_EB_DST_NODE, HIDC_AEIPX_EB_DST_NODE,
    IDC_AI_ST_DST_SOCKET, HIDC_AI_ST_DST_SOCKET,
    IDC_AEIPX_EB_DST_SOCKET, HIDC_AEIPX_EB_DST_SOCKET,
    IDC_AI_ST_PACKET_TYPE, HIDC_AI_ST_PACKET_TYPE,
    IDC_AEIPX_EB_PACKET_TYPE, HIDC_AEIPX_EB_PACKET_TYPE,
	0,0 
};


// "File rtrfiltr.rc line 138 : Resource - DIALOGEX : IDD_IPFILTER"
static const DWORD rgdw_IDD_IPFILTER[] = 
{
    IDC_IP_PERMIT, HIDC_IP_PERMIT,
    IDC_IP_DENY, HIDC_IP_DENY,
    IDC_IP_FILTER_LIST, HIDC_IP_FILTER_LIST,
    IDC_IP_FILTER_ADD, HIDC_IP_FILTER_ADD,
    IDC_IP_FILTER_EDIT, HIDC_IP_FILTER_EDIT,
    IDC_IP_FILTER_DELETE, HIDC_IP_FILTER_DELETE,
	0,0 
};


// "File rtrfiltr.rc line 165 : Resource - DIALOG : IDD_IPFILTER_ADDEDIT"
static const DWORD rgdw_IDD_IPFILTER_ADDEDIT[] = 
{
    IDC_AEIP_CB_SOURCE, HIDC_AEIP_CB_SOURCE,
    IDC_AEIP_ST_SOURCE_ADDRESS, HIDC_AEIP_ST_SOURCE_ADDRESS,
    IDC_AEIP_EB_SOURCE_ADDRESS, HIDC_AEIP_EB_SOURCE_ADDRESS,
    IDC_AEIP_ST_SOURCE_MASK, HIDC_AEIP_ST_SOURCE_MASK,
    IDC_AEIP_EB_SOURCE_MASK, HIDC_AEIP_EB_SOURCE_MASK,
    IDC_AEIP_CB_DEST, HIDC_AEIP_CB_DEST,
    IDC_AEIP_ST_DEST_ADDRESS, HIDC_AEIP_ST_DEST_ADDRESS,
    IDC_AEIP_EB_DEST_ADDRESS, HIDC_AEIP_EB_DEST_ADDRESS,
    IDC_AEIP_ST_DEST_MASK, HIDC_AEIP_ST_DEST_MASK,
    IDC_AEIP_EB_DEST_MASK, HIDC_AEIP_EB_DEST_MASK,
    IDC_AEIP_CB_PROTOCOL, HIDC_AEIP_CB_PROTOCOL,
    IDC_AEIP_ST_SRC_PORT, HIDC_AEIP_ST_SRC_PORT,
    IDC_AEIP_CB_SRC_PORT, HIDC_AEIP_CB_SRC_PORT,
    IDC_AEIP_ST_DEST_PORT, HIDC_AEIP_ST_DEST_PORT,
    IDC_AEIP_CB_DEST_PORT, HIDC_AEIP_CB_DEST_PORT,
	0,0 
};


// "File rtrfiltr.rc line 205 : Resource - DIALOGEX : IDD_IPFILTER_DD"
static const DWORD rgdw_IDD_IPFILTER_DD[] = 
{
    IDC_IP_FILTER_ONLY, HIDC_IP_FILTER_ONLY,
    IDC_IP_FILTER_ALL, HIDC_IP_FILTER_ALL,
    IDC_IP_FILTER_LIST, HIDC_IP_FILTER_LIST,
    IDC_IP_FILTER_ADD, HIDC_IP_FILTER_ADD,
    IDC_IP_FILTER_EDIT, HIDC_IP_FILTER_EDIT,
    IDC_IP_FILTER_DELETE, HIDC_IP_FILTER_DELETE,
	0,0 
};

//
// End of mkdlg.exe output
//



static BOOL				s_fInitHelpMap = FALSE;
static CMapWordToPtr	s_IDDHelpMap;
void InitHelpMap();

DWORD *	RtrfiltrSnapHelpMap(DWORD dwIDD)
{
	LPVOID	pvHelpMap = NULL;
	
	if (!s_fInitHelpMap)
	{
		InitHelpMap();
		s_fInitHelpMap = TRUE;
	}

	// Look in the help map
	s_IDDHelpMap.Lookup((WORD) dwIDD, pvHelpMap);
	return (DWORD *) pvHelpMap;
}

void InitHelpMap()
{
	s_IDDHelpMap.SetAt(IDD_IPXFILTER_INPUT, (LPVOID) rgdw_IDD_IPXFILTER);
	s_IDDHelpMap.SetAt(IDD_IPXFILTER_OUTPUT, (LPVOID) rgdw_IDD_IPXFILTER);
	s_IDDHelpMap.SetAt(IDD_IPXFILTER_ADDEDIT, (LPVOID) rgdw_IDD_IPXFILTER_ADDEDIT);
	s_IDDHelpMap.SetAt(IDD_IPFILTER, (LPVOID) rgdw_IDD_IPFILTER);
	s_IDDHelpMap.SetAt(IDD_IPFILTER_ADDEDIT, (LPVOID) rgdw_IDD_IPFILTER_ADDEDIT);
	s_IDDHelpMap.SetAt(IDD_IPFILTER_DD, (LPVOID) rgdw_IDD_IPFILTER_DD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipcfg.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipcfg.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IP Packet Filters Configuration
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipfltr.h"
#include "format.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//-----------------------------------------------------------------------------
// Function:	IpFilterConfig
//
// Handles connecting to router, getting interface info, creating the IP filter
// configuration dialog and saving the Filters back to the registry.
// Uses CRouterInfo and other classes implemented in ..\common library.
//------------------------------------------------------------------------------

DWORD APIENTRY
IpFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
	IN	LPCWSTR		pwsInterfaceName,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

    DWORD dwErr;
    HANDLE hMprConfig = NULL, hInterface = NULL, hIfTransport = NULL;
    TCHAR* pszMachine;
	SPIRouterInfo	spRouterInfo;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase	spInfoBase;
	HRESULT	hr = hrOK;

    //
    // Convert the machine name from Unicode
    //

    if (!pwsMachineName) { pszMachine = NULL; }
    else {

		pszMachine = (TCHAR *) alloca((StrLenW(pwsMachineName)+3) * sizeof(TCHAR));

		StrCpyTFromW(pszMachine, pwsMachineName);
    }

	// Connect to the server first
    dwErr = ::MprConfigServerConnect((LPWSTR)pwsMachineName, &hMprConfig);

    if (dwErr != NO_ERROR) { return dwErr; }

	// create a CRouterInfo object
	CreateRouterInfo(&spRouterInfo, NULL, pwsMachineName);

    CWaitCursor wait;

	// Now load the RouterInfo data from the registry
	hr = spRouterInfo->Load((LPCTSTR)pszMachine, hMprConfig);
      
	if (!FHrSucceeded(hr)) { return WIN32_FROM_HRESULT(hr); }

	// Get the pointer to the CRmInterfaceInfo object for the specified 
	// protocol and interface
	LookupRtrMgrInterface(spRouterInfo,
						  pwsInterfaceName,
						  PID_IP,
						  &spRmIf);

	if (!spRmIf) { return ERROR_INVALID_DATA ;}

	// Load the data for the specified interface
	hr = spRmIf->Load(pszMachine, hMprConfig, NULL, NULL);

	if (!FHrSucceeded(hr))
		return WIN32_FROM_HRESULT(hr);

	spRmIf->GetInfoBase(hMprConfig, NULL, NULL, &spInfoBase);

	//
    // Display the IP filter configuration dialog
    //
	if (IpFilterConfigInfoBase(pParent->GetSafeHwnd(),
							   spInfoBase,
							   spRmIf,
							   dwFilterType) == hrOK)
	{
		hr = spRmIf->Save(pszMachine,
							 hMprConfig,
							 NULL,
							 NULL,
							 spInfoBase,
							 0);
		if (FHrSucceeded(hr))
			dwErr = ERROR_SUCCESS;
		else
			dwErr = WIN32_FROM_HRESULT(hr);
	}
	
    //
    //
	//
	// do clean up here and return
	//
    
    ::MprConfigServerDisconnect( hMprConfig );

    return dwErr;
}


HRESULT APIENTRY
IpFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

	HRESULT	hr = hrOK;

	if (dwFilterType == FILTER_DEMAND_DIAL)
	{
		//
		// Display the IP filter configuration dialog
		//
		
		CIpFltrDD dlg(CWnd::FromHandle(hwndParent), pInfoBase, dwFilterType );

		if (dlg.DoModal() == IDOK)
			hr = hrOK;
		else
			hr = hrFalse;
	}
	else
	{
		//
		// Display the IP filter configuration dialog
		//
		
		CIpFltr dlg(CWnd::FromHandle(hwndParent), pInfoBase, dwFilterType );

		if (dlg.DoModal() == IDOK)
			hr = hrOK;
		else
			hr = hrFalse;
	}
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipfltr.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipfltr.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IP Filter  dialog code
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipfltr.h"
#include "ipadd.h"
#include <ipinfoid.h>
#include "strmap.h"

extern "C" {
#include <winsock2.h>
#include <fltdefs.h>
#include <iprtinfo.h>
}

#include "ipaddr.h"
#include "listctrl.h"

#include "rtradmin.hm"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static UINT	uStringIdTable[]	= { IDS_COL_SOURCEADDRESS,
									IDS_COL_SOURCEMASK,
									IDS_COL_DESTADDRESS,
									IDS_COL_DESTMASK,
									IDS_COL_PROTOCOL,
									IDS_COL_SOURCEPORT,
									IDS_COL_DESTPORT } ;


CString s_stFilterUDP;
CString s_stFilterTCP;
CString s_stFilterICMP;
CString s_stFilterAny;
CString s_stFilterUnknown;

const CStringMapEntry IPFilterProtocolMap[] =
{
    { FILTER_PROTO_UDP, &s_stFilterUDP, IDS_PROTOCOL_UDP },
    { FILTER_PROTO_TCP, &s_stFilterTCP, IDS_PROTOCOL_TCP },
    { FILTER_PROTO_ICMP, &s_stFilterICMP, IDS_PROTOCOL_ICMP },
    { FILTER_PROTO_ANY, &s_stFilterAny, IDS_PROTOCOL_ANY },
    { -1, &s_stFilterUnknown, IDS_PROTOCOL_UNKNOWN },
};

CString&    ProtocolTypeToCString(DWORD dwType)
{
	return MapDWORDToCString(dwType, IPFilterProtocolMap);
}


/////////////////////////////////////////////////////////////////////////////
// CIpFltr dialog


CIpFltr::CIpFltr(CWnd*			pParent,
				 IInfoBase *	pInfoBase,
				 DWORD			dwFilterType,
				 UINT			idd)
	: CBaseDialog(idd, pParent),
	  m_pParent(pParent),
	  m_dwFilterType(dwFilterType)
{
	m_spInfoBase.Set(pInfoBase);
	//{{AFX_DATA_INIT(CIpFltr)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}

CIpFltr::~CIpFltr()
{
    while (!m_filterList.IsEmpty()) {

        delete (FilterListEntry*)m_filterList.RemoveHead();
    }
}

void CIpFltr::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIpFltr)
	DDX_Control(pDX, IDC_IP_FILTER_LIST, m_listCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIpFltr, CBaseDialog)
	//{{AFX_MSG_MAP(CIpFltr)
	ON_BN_CLICKED(IDC_IP_FILTER_ADD, OnIpFilterAdd)
	ON_BN_CLICKED(IDC_IP_FILTER_DELETE, OnIpFilterDelete)
	ON_BN_CLICKED(IDC_IP_FILTER_EDIT, OnIpFilterEdit)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_IP_FILTER_LIST, OnGetdispinfo)
	ON_NOTIFY(NM_DBLCLK, IDC_IP_FILTER_LIST, OnDblclkIpFilterList)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_IP_FILTER_LIST, OnNotifyListItemChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CIpFltr::m_dwHelpMap[] = 
{
//	IDC_IP_PERMIT, HIDC_IP_PERMIT,
//	IDC_IP_DENY, HIDC_IP_DENY,
//	IDC_IP_FILTER_LIST, HIDC_IP_FILTER_LIST,
//	IDC_IP_FILTER_ADD, HIDC_IP_FILTER_ADD,
//	IDC_IP_FILTER_EDIT, HIDC_IP_FILTER_EDIT,
//	IDC_IP_FILTER_DELETE, HIDC_IP_FILTER_DELETE,
	0,0,
};

/////////////////////////////////////////////////////////////////////////////
// CIpFltr message handlers

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnInitDialog
//
// Handles 'WM_INITDIALOG' notification from the dialog
//------------------------------------------------------------------------------

BOOL CIpFltr::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UINT	i;
	CBaseDialog::OnInitDialog();
	
	CRect	rcDlg, rc;
	CString	sCol;
    CString stTitle;
	HRESULT	hr = hrOK;
	DWORD	dwFilterType;
    UINT    idsTitle = 0;

	Assert( m_dwFilterType == FILTER_INBOUND ||
			m_dwFilterType == FILTER_OUTBOUND ||
			m_dwFilterType == FILTER_DEMAND_DIAL ||
			m_dwFilterType == FILTER_PERUSER_IN ||
		    m_dwFilterType == FILTER_PERUSER_OUT );

	m_stAny.LoadString(IDS_ANY);
	m_stUserMask.LoadString(IDS_USER_MASK);
	m_stUserAddress.LoadString(IDS_USER_ADDRESS);

	switch (m_dwFilterType)
	{
		case FILTER_PERUSER_OUT:	// from RAS server's perspective, it's INBOUND ( but out from user )
		case FILTER_INBOUND:
			dwFilterType = IP_IN_FILTER_INFO;
            idsTitle = IDS_IP_TITLE_INPUT;
			break;
		default:
		case FILTER_PERUSER_IN:		// from RAS server's perspective, it's OUTBOUND ( but out to user )
		case FILTER_OUTBOUND:
			dwFilterType = IP_OUT_FILTER_INFO;
            idsTitle = IDS_IP_TITLE_OUTPUT;
            stTitle.LoadString(IDS_OUTPUT_TEXT);
            SetDlgItemText(IDC_STATIC, stTitle); 
			break;
		case FILTER_DEMAND_DIAL:
			dwFilterType = IP_DEMAND_DIAL_FILTER_INFO;
            idsTitle = IDS_IP_TITLE_DD;
			break;
	}

    stTitle.LoadString(idsTitle);
    SetWindowText(stTitle);
	
	// initialize rectangle for list control display

	GetClientRect(rcDlg);

	// Initialize the mask controls

	// insert columns
	m_listCtrl.GetClientRect(&rc);

	for (i = 0; i < IP_NUM_COLUMNS; i++ )	{
		sCol.LoadString(uStringIdTable[i]);
		m_listCtrl.InsertColumn(i, sCol);
		AdjustColumnWidth(m_listCtrl, i, sCol);
	}
	// set extended attributes
	ListView_SetExtendedListViewStyle( m_listCtrl.m_hWnd, LVS_EX_FULLROWSELECT );

	InfoBlock * pBlock;
    FILTER_DESCRIPTOR  * pIPfDescriptor;
	FILTER_INFO		   * pIPfInfo;
	DWORD				 dwCount;

	hr = m_spInfoBase->GetBlock( dwFilterType, &pBlock, 0);
	
	// The filter was previously defined
	if (FHrSucceeded(hr) && (pBlock->pData != NULL))
	{
		pIPfDescriptor = ( FILTER_DESCRIPTOR * ) pBlock->pData;
		SetFilterActionButtonsAndText(m_dwFilterType, pIPfDescriptor->faDefaultAction);
		dwCount  = pIPfDescriptor->dwNumFilters;

		pIPfInfo = (FILTER_INFO*)pIPfDescriptor->fiFilter;
	
		for ( i = 0; i < dwCount; i++, pIPfInfo++ )	{       
			FilterListEntry* pfle = new FilterListEntry;

            if (!pfle)
			{
				hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				break;
			}

            pfle->dwSrcAddr		=	pIPfInfo->dwSrcAddr;
			pfle->dwSrcMask		=	pIPfInfo->dwSrcMask;
			pfle->dwDstAddr		=	pIPfInfo->dwDstAddr;		
			pfle->dwDstMask		=	pIPfInfo->dwDstMask;			
			pfle->dwProtocol	=	pIPfInfo->dwProtocol;			
            if( pfle->dwProtocol == FILTER_PROTO_TCP ||
                pfle->dwProtocol == FILTER_PROTO_UDP)
            {
                pfle->wSrcPort  =   ntohs(pIPfInfo->wSrcPort);
			    pfle->wDstPort  =	ntohs(pIPfInfo->wDstPort);			
            }
            else
            {
			    pfle->wSrcPort	=	pIPfInfo->wSrcPort;			
			    pfle->wDstPort	=	pIPfInfo->wDstPort;			
            }
			pfle->fLateBound	=	pIPfInfo->fLateBound;			
            pfle->pos			=	m_filterList.AddTail(pfle);
			INT item = m_listCtrl.InsertItem(	LVIF_TEXT|LVIF_PARAM, i, LPSTR_TEXTCALLBACK,
												0,0,0, (LPARAM)pfle);
			if(item != -1) {m_listCtrl.SetItemData( item, (DWORD_PTR)pfle); }
		}
	}
	else	{
		// This should not trigger an error to be reported
		hr = hrOK;
		SetFilterActionButtonsAndText(m_dwFilterType, PF_ACTION_FORWARD);
	}		

	// select the first item in the list if list is not empty, else
	// disable the radio controls and set sate to Allow

	if( m_listCtrl.GetItemCount())
	{
		m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
		m_listCtrl.SetFocus();

		GetDlgItem(IDC_IP_FILTER_DELETE)->EnableWindow(TRUE);
		GetDlgItem(IDC_IP_FILTER_EDIT)->EnableWindow(TRUE);
	}
	else
	{
		SetFilterActionButtonsAndText(m_dwFilterType, PF_ACTION_FORWARD, FALSE);
		GetDlgItem(IDC_IP_FILTER_DELETE)->EnableWindow(FALSE);
		GetDlgItem(IDC_IP_FILTER_EDIT)->EnableWindow(FALSE);
	}

	if (!FHrSucceeded(hr))
	{
		// report construction error and return
        ::AfxMessageBox(IDS_CONSTRUCTION_ERROR);
	}
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnIpFilterAdd
//
// Handles 'BN_CLICKED' notification from the 'Add' button
//------------------------------------------------------------------------------

void CIpFltr::OnIpFilterAdd() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Display the IP filter Add/Edit dialog
    //

	FilterListEntry* pfle = NULL;

	CIpFltrAddEdit dlg( this, (FilterListEntry**)&pfle, m_dwFilterType);
  
    if ( dlg.DoModal() != IDOK )	{ m_listCtrl.SetFocus(); return; }

	// Add the newly configured filter to our list and update list control

	pfle->pos = m_filterList.AddTail( pfle );
	int item = m_listCtrl.InsertItem(	LVIF_TEXT|LVIF_PARAM, 0, LPSTR_TEXTCALLBACK,
										0,0,0, (LPARAM)pfle);
	if(item != -1) {m_listCtrl.SetItemData( item, (DWORD_PTR)pfle); }

	// enable radio controls when the first item is added to list
	if( m_listCtrl.GetItemCount() == 1)
	{
		SetFilterActionButtonsAndText(m_dwFilterType, PF_ACTION_FORWARD);
	}
    m_listCtrl.SetItemState(item, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();
}

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnIpFilterEdit
//
// Handles 'BN_CLICKED' notification from the 'Edit' button
//------------------------------------------------------------------------------

void CIpFltr::OnIpFilterEdit() 
{
	// Get the current list selection
	// get the corresponding itemdata
	// pass it down to the CIpFltrAddEdit dialog

    //
    // Get the selected item
    //

    int i = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    if (i == -1) { 	m_listCtrl.SetFocus(); return ; }

    //
    // Get the interface for the selected item
    //

    FilterListEntry* pfle = (FilterListEntry*)m_listCtrl.GetItemData(i);

	CIpFltrAddEdit dlg( this, (FilterListEntry**)&pfle, m_dwFilterType );
  
    if ( dlg.DoModal() != IDOK )	{ return; }

	m_listCtrl.Update(i);
	m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();
}

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnIpFilterDelete
//
// Handles 'BN_CLICKED' notification from the 'Delete' button
//------------------------------------------------------------------------------

void CIpFltr::OnIpFilterDelete() 
{
	// Get the current list selection
	// delete it from our private list
	// delete the item from the list or just refresh the list view

    //
    // Get the selected item
    //

    int i = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    if (i == -1) { return ; }

    //
    // Get the interface for the selected item
    //

    FilterListEntry* pfle = (FilterListEntry*)m_listCtrl.GetItemData(i);

	//
	// delete it
	m_listCtrl.DeleteItem(i);
	m_filterList.RemoveAt(pfle->pos); 
	delete pfle;

	//
	// select the next available list item
	//

	// disable radio controls if all items in list are deleted
	// they will be reenabled when the first filter is added to list
	if( !m_listCtrl.GetItemCount())
	{
		SetFilterActionButtonsAndText(m_dwFilterType, PF_ACTION_FORWARD, FALSE);
	}
	else if (m_listCtrl.GetItemCount() == i)
		m_listCtrl.SetItemState((i == 0? i: i-1), LVIS_SELECTED, LVIS_SELECTED);
	else
		m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();
}

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnOK
//
// Handles 'BN_CLICKED' notification from the 'OK' button
//------------------------------------------------------------------------------

void CIpFltr::OnOK() 
{
	// If the filters information changed, write this to registry
	// and return
	DWORD	dwSize, dwCount;
	HRESULT	hr = hrOK;
	DWORD	dwFilterType;

	switch (m_dwFilterType)
	{
		case FILTER_PERUSER_OUT:
		case FILTER_INBOUND:
			dwFilterType = IP_IN_FILTER_INFO;
			break;
		default:
		case FILTER_PERUSER_IN:
		case FILTER_OUTBOUND:
			dwFilterType = IP_OUT_FILTER_INFO;
			break;
		case FILTER_DEMAND_DIAL:
			dwFilterType = IP_DEMAND_DIAL_FILTER_INFO;
			break;
	}
	
	dwCount = (DWORD) m_filterList.GetCount();

	if(dwCount)
	{
		InfoBlock * pBlock = new InfoBlock;

		if (!pBlock)	{ // display an error message for no memory 
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		};

		pBlock->dwType = dwFilterType;
		
		// dwCount -1 because FILTER_DESCRIPTOR already has room for one FILTER_INFO structure
		dwSize = pBlock->dwSize = sizeof( FILTER_DESCRIPTOR ) + ( (dwCount - 1) * sizeof (FILTER_INFO) );
		pBlock->dwCount = 1;
		
		pBlock->pData  = new BYTE[dwSize];

		if(!pBlock->pData)	{ // display an error message for no memory
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		}

		FILTER_DESCRIPTOR  * pIPfDescriptor;
		FILTER_INFO		   * pIPfInfo;

		pIPfDescriptor = (FILTER_DESCRIPTOR*) pBlock->pData;
		pIPfDescriptor->dwVersion = IP_FILTER_DRIVER_VERSION;
		pIPfDescriptor->dwNumFilters = dwCount;

		if (dwFilterType == IP_DEMAND_DIAL_FILTER_INFO)
		{
			pIPfDescriptor->faDefaultAction = IsDlgButtonChecked(IDC_IP_FILTER_ONLY) ?
											PF_ACTION_DROP : PF_ACTION_FORWARD;
		}
		else
		{
			pIPfDescriptor->faDefaultAction = IsDlgButtonChecked(IDC_IP_PERMIT) ? 
                                          PF_ACTION_FORWARD : PF_ACTION_DROP;
		}

		pIPfInfo = (FILTER_INFO*)pIPfDescriptor->fiFilter;

		POSITION pos;
		pos = m_filterList.GetHeadPosition();
		while(pos)	{
			FilterListEntry* pfle = (FilterListEntry*)m_filterList.GetNext(pos);
			pIPfInfo->dwSrcAddr		=	pfle->dwSrcAddr;
			pIPfInfo->dwSrcMask		=	pfle->dwSrcMask;
			pIPfInfo->dwDstAddr		=	pfle->dwDstAddr;		
			pIPfInfo->dwDstMask		=	pfle->dwDstMask;			
			pIPfInfo->dwProtocol	=	pfle->dwProtocol;			
            if( pIPfInfo->dwProtocol == FILTER_PROTO_TCP ||
                pIPfInfo->dwProtocol == FILTER_PROTO_UDP)
            {
			    pIPfInfo->wSrcPort	=	htons(pfle->wSrcPort);			
			    pIPfInfo->wDstPort	=	htons(pfle->wDstPort);	
            }
            else if ( pIPfInfo->dwProtocol == FILTER_PROTO_ICMP )
            {
			    pIPfInfo->wSrcPort	=	MAKEWORD(pfle->wSrcPort, 0x00);			
			    pIPfInfo->wDstPort	=	MAKEWORD(pfle->wDstPort, 0x00);	
            } 
            else
            {
			    pIPfInfo->wSrcPort	=	pfle->wSrcPort;			
			    pIPfInfo->wDstPort	=	pfle->wDstPort;	
            }
			pIPfInfo->fLateBound	=	pfle->fLateBound;			
			pIPfInfo++;
		}

		if( FHrOK(m_spInfoBase->BlockExists(dwFilterType)))
		{
			hr = m_spInfoBase->SetBlock(
										dwFilterType,
										pBlock, 0);
		}
		else
		{
			hr = m_spInfoBase->AddBlock(
										dwFilterType,
										dwSize,
										pBlock->pData,
										1, FALSE);
		}
		if (!FHrSucceeded(hr))
		{
			AfxMessageBox(IDS_ERROR_SETTING_BLOCK);
		}
		delete[] pBlock->pData;
		delete pBlock;
	}
	else
	{
		// remove any previously defined filters

		InfoBlock * pBlock = new InfoBlock;

		if (!pBlock)	{ // display an error message for no memory 
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		};
		
		pBlock->dwType = dwFilterType;
		dwSize = pBlock->dwSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]);
		pBlock->dwCount = 1;
		
		pBlock->pData  = new BYTE[dwSize];

		if(!pBlock->pData)	{ // display an error message for no memory
			delete pBlock;
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		}

		FILTER_DESCRIPTOR  * pIPfDescriptor;
		FILTER_INFO		   * pIPfInfo;

		pIPfDescriptor = (FILTER_DESCRIPTOR*) pBlock->pData;

		if (dwFilterType == IP_DEMAND_DIAL_FILTER_INFO)
		{
			pIPfDescriptor->faDefaultAction = IsDlgButtonChecked(
				IDC_IP_FILTER_ONLY) ?
				PF_ACTION_DROP : PF_ACTION_FORWARD;
		}
		else
		{
			pIPfDescriptor->faDefaultAction = IsDlgButtonChecked(IDC_IP_PERMIT) ? 
                                          PF_ACTION_FORWARD : PF_ACTION_DROP;
		}
		pIPfDescriptor->dwVersion = IP_FILTER_DRIVER_VERSION;
		pIPfDescriptor->dwNumFilters = 0;

		if( FHrOK(m_spInfoBase->BlockExists(dwFilterType)))
		{
			hr = m_spInfoBase->SetBlock( dwFilterType,
										 pBlock, 0);
		}
		else
		{
			hr = m_spInfoBase->AddBlock( dwFilterType,
										 dwSize,
										 pBlock->pData,
										 1, FALSE);
		}
		if (!FHrSucceeded(hr))
		{
			AfxMessageBox(IDS_ERROR_SETTING_BLOCK);
		}
		delete[] pBlock->pData;
		delete pBlock;
//		hr = m_spInfoBase->RemoveBlock(m_dwFilterType == FILTER_INBOUND ? IP_IN_FILTER_INFO : IP_OUT_FILTER_INFO);
	}

	CBaseDialog::OnOK();
}

void CIpFltr::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CBaseDialog::OnCancel();
}

enum {
    SRC_ADDRESS=0,
    SRC_MASK,
	DEST_ADDRESS,
	DEST_MASK,
	PROTOCOL,
	SRC_PORT,
	DEST_PORT
};

//------------------------------------------------------------------------------
// Function:	CIpFltr::OnGetdispinfo
//
// Handles 'LVN_GETDISPINFO' notification from the list control
//------------------------------------------------------------------------------

void CIpFltr::OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult) 
{
	static WCHAR s_szDestPortBuffer[32];
	static WCHAR s_szSrcPortBuffer[32];
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	
	FilterListEntry * pfle = (FilterListEntry*)pDispInfo->item.lParam;

	// Setup the default condition
	pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) m_stAny;

	switch( pDispInfo->hdr.code )
	{
	case LVN_GETDISPINFO:
		switch( pDispInfo->item.iSubItem )
		{
		case SRC_ADDRESS:
			if (m_dwFilterType == FILTER_PERUSER_OUT)
				pDispInfo->item.pszText = (LPTSTR)(LPCTSTR) m_stUserAddress;
			else
			{
				if (pfle->dwSrcAddr != 0)
					pDispInfo->item.pszText = INET_NTOA(pfle->dwSrcAddr);
			}
			break;
		case SRC_MASK:
			if (m_dwFilterType == FILTER_PERUSER_OUT)
				pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) m_stUserMask;
			else
			{
				if (pfle->dwSrcMask != 0)
					pDispInfo->item.pszText = INET_NTOA(pfle->dwSrcMask);
			}
			break;
		case DEST_ADDRESS:
			if (m_dwFilterType == FILTER_PERUSER_IN)
				pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) m_stUserAddress;
			else
			{
				if (pfle->dwDstAddr != 0)
					pDispInfo->item.pszText = INET_NTOA(pfle->dwDstAddr);
			}
			break;
		case DEST_MASK:
			if (m_dwFilterType == FILTER_PERUSER_IN)
				pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) m_stUserMask;
			else
			{
				if (pfle->dwDstMask != 0)
					pDispInfo->item.pszText = INET_NTOA(pfle->dwDstMask);
			}
			break;
		case PROTOCOL:
			// known protocol, display string, else number
			m_stTempOther = GetProtocolString(pfle->dwProtocol,pfle->fLateBound);
			pDispInfo->item.pszText = (LPTSTR) (LPCTSTR)m_stTempOther;

			break;
		case SRC_PORT:
			if (pfle->dwProtocol == FILTER_PROTO_ICMP)
			{
				if (pfle->wSrcPort != FILTER_ICMP_TYPE_ANY)
					pDispInfo->item.pszText = (LPTSTR)_itow(pfle->wSrcPort,
						s_szSrcPortBuffer, 10);				
			}
			else
			{
				if (pfle->wSrcPort != 0)
					pDispInfo->item.pszText = (LPTSTR)_itow(pfle->wSrcPort,
						s_szSrcPortBuffer, 10);
			}
			break;
		case DEST_PORT:
			if (pfle->dwProtocol == FILTER_PROTO_ICMP)
			{
				if (pfle->wSrcPort != FILTER_ICMP_CODE_ANY)
					pDispInfo->item.pszText = (LPTSTR)_itow(pfle->wDstPort,
						s_szDestPortBuffer, 10);				
			}
			else
			{
				if (pfle->wDstPort != 0)
					pDispInfo->item.pszText = (LPTSTR)_itow(pfle->wDstPort,
						s_szDestPortBuffer, 10);				
			}
			break;
		default:
			break;
		}
	}
	*pResult = 0;
}

// --------------------------------------------------------------------
// Function:	CIpFltr::GetProtocolString
//
// returns protocol names for known protocols
// --------------------------------------------------------------------

CString CIpFltr::GetProtocolString(DWORD dwProtocol, DWORD fFlags)
{
	WCHAR buffer[32];
    CString st;

    switch (dwProtocol)
    {
        case FILTER_PROTO_TCP:
            st = ProtocolTypeToCString(dwProtocol);
            if(fFlags & TCP_ESTABLISHED_FLAG)
            {
                st.LoadString(IDS_PROTOCOL_TCP_ESTABLISHED);
            }
            break;
        case FILTER_PROTO_UDP:
        case FILTER_PROTO_ICMP:
        case FILTER_PROTO_ANY:
            st = ProtocolTypeToCString(dwProtocol);
            break;
        default:
            st = (LPTSTR) _itow(dwProtocol, buffer, 10);
            break;
    }

    return st;
}

//------------------------------------------------------------------------------
// Function:    CIpFltr::SetFilterActionButtonsAndText                         
//                                                                             
// Called to set the 'Filter Action' radio-buttons and corresponding text   
// Enables/Disables controls based on 'bEnable' value - defaults to enable
//------------------------------------------------------------------------------

VOID
CIpFltr::SetFilterActionButtonsAndText(
	DWORD	dwFilterType,
	DWORD	dwAction,
	BOOL	bEnable
)	
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	if (dwFilterType == FILTER_DEMAND_DIAL)
	{
		CheckDlgButton( IDC_IP_FILTER_ONLY, dwAction == PF_ACTION_DROP );
		CheckDlgButton( IDC_IP_FILTER_ALL,   dwAction == PF_ACTION_FORWARD );
	
		GetDlgItem(IDC_IP_FILTER_ONLY)->EnableWindow(bEnable);
		GetDlgItem(IDC_IP_FILTER_ALL)->EnableWindow(bEnable);
	}
	else if ((dwFilterType == FILTER_PERUSER_IN) ||
			 (dwFilterType == FILTER_PERUSER_OUT))
	{
		CheckDlgButton( IDC_IP_PERMIT, dwAction == PF_ACTION_FORWARD );
		CheckDlgButton( IDC_IP_DENY,   dwAction == PF_ACTION_DROP );
		CString sItem;
	
		GetDlgItem(IDC_IP_PERMIT)->EnableWindow(bEnable);
		GetDlgItem(IDC_IP_DENY)->EnableWindow(bEnable);

		sItem.LoadString(IDS_PERUSER_PERMIT);
		SetDlgItemText( IDC_IP_PERMIT, sItem );

		sItem.LoadString(IDS_PERUSER_DENY);
		SetDlgItemText( IDC_IP_DENY, sItem );
	}
	else
	{
		CheckDlgButton( IDC_IP_PERMIT, dwAction == PF_ACTION_FORWARD );
		CheckDlgButton( IDC_IP_DENY,   dwAction == PF_ACTION_DROP );
		CString sItem;
	
		GetDlgItem(IDC_IP_PERMIT)->EnableWindow(bEnable);
		GetDlgItem(IDC_IP_DENY)->EnableWindow(bEnable);

		sItem.LoadString( dwFilterType == FILTER_INBOUND? IDS_RECEIVE : IDS_TRANSMIT );
		SetDlgItemText( IDC_IP_PERMIT, sItem );
		sItem.LoadString( IDS_DROP );
		SetDlgItemText( IDC_IP_DENY, sItem );
	}
}

//------------------------------------------------------------------------------
// Function:    CIpFltr::OnDoubleclickedIpFilterList                         
//                         `                                                    
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------


void CIpFltr::OnDblclkIpFilterList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnIpFilterEdit();
	
	*pResult = 0;
}

void CIpFltr::OnNotifyListItemChanged(NMHDR *pNmHdr, LRESULT *pResult)
{
	NMLISTVIEW *	pnmlv = reinterpret_cast<NMLISTVIEW *>(pNmHdr);
	BOOL		fSelected;

	fSelected = (m_listCtrl.GetNextItem(-1, LVNI_SELECTED) != -1);
	GetDlgItem(IDC_IP_FILTER_DELETE)->EnableWindow(fSelected);
	GetDlgItem(IDC_IP_FILTER_EDIT)->EnableWindow(fSelected);
}



/////////////////////////////////////////////////////////////////////////////
// CIpFltrDD dialog


CIpFltrDD::CIpFltrDD(CWnd*			pParent,
				 IInfoBase *	pInfoBase,
				 DWORD			dwFilterType)
	: CIpFltr(pParent, pInfoBase, dwFilterType, CIpFltrDD::IDD)
{
	//{{AFX_DATA_INIT(CIpFltrDD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}

CIpFltrDD::~CIpFltrDD()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipfltr.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipfltr.h
//
// History:
//  08/30/96	Ram Cherala		Created
//	01/24/98	Kenn Takara		Modified for new snapins.
//
// Class declarations for IP Filter code.
//============================================================================

#ifndef _IPFLTR_H_
#define _IPFLTR_H_

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

// number of columns in the IP list view control
#define		IP_NUM_COLUMNS	7

struct 	FilterListEntry	{
	DWORD		dwSrcAddr;
	DWORD		dwSrcMask;
	DWORD		dwDstAddr;
	DWORD		dwDstMask;
	DWORD		dwProtocol;
	DWORD		fLateBound;
	WORD		wSrcPort;
	WORD		wDstPort;
    POSITION	pos;
};

typedef CList<FilterListEntry *, FilterListEntry *> FilterList;

/////////////////////////////////////////////////////////////////////////////
// CIpFltr dialog

class CIpFltr : public CBaseDialog {
// Construction
public:
	CIpFltr(CWnd *		pParent,
			IInfoBase * pInfoBase,
			DWORD		dwFilterType,
		    UINT		idDlg = CIpFltr::IDD);

    ~CIpFltr();

	VOID	SetFilterActionButtonsAndText( DWORD dwFilterType,
										   DWORD dwAction,
										   BOOL bEnable = TRUE );
	
    CString GetProtocolString(DWORD dwProtocol, DWORD fFlags);

// Dialog Data
	//{{AFX_DATA(CIpFltr)
	enum { IDD = IDD_IPFILTER };
 	CListCtrl		m_listCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIpFltr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];

	CWnd*			m_pParent;
	SPIInfoBase		m_spInfoBase;
	DWORD			m_dwFilterType;
	FilterList		m_filterList;

	// Stores temp string information for Other Protocol
	CString			m_stTempOther;

	// Store the "Any" string here since it's used so many times
	CString			m_stAny;
	CString			m_stUserMask;
	CString			m_stUserAddress;

	// Generated message map functions
	//{{AFX_MSG(CIpFltr)
	virtual BOOL OnInitDialog();
	afx_msg void OnIpFilterAdd();
	afx_msg void OnIpFilterDelete();
	afx_msg void OnIpFilterEdit();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkIpFilterList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNotifyListItemChanged(NMHDR *, LRESULT *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CIpFltrDD : public CIpFltr
{
public:
	CIpFltrDD(CWnd *	pParent,
			  IInfoBase *pInfoBase,
			  DWORD		dwFilterType);

	~CIpFltrDD();

	enum { IDD = IDD_IPFILTER_DD };
};

#endif // _IPFLTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipxcfg.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipxcfg.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IPX Packet Filters Configuration
//============================================================================

// ipxcfg.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipxfltr.h"
#include "format.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD APIENTRY
IpxFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
	IN	LPCWSTR		pwsInterfaceName,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

    DWORD dwErr;
    HANDLE hMprConfig = NULL, hInterface = NULL, hIfTransport = NULL;
    TCHAR* pszMachine;
	SPIRouterInfo	spRouterInfo;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase	spInfoBase;
	HRESULT		hr = hrOK;

    //
    // Convert the machine name from Unicode
    //

    if (!pwsMachineName) { pszMachine = NULL; }
    else {

		pszMachine = (TCHAR *) alloca((StrLenW(pwsMachineName)+3) * sizeof(TCHAR));
        StrCpyTFromW(pszMachine, pwsMachineName);
    }

	// Connect to the server first
    dwErr = ::MprConfigServerConnect((LPWSTR)pwsMachineName, &hMprConfig);

    if (dwErr != NO_ERROR) { return dwErr; }

	// create a CRouterInfo object
	CreateRouterInfo(&spRouterInfo, NULL, pwsMachineName);
    if (!spRouterInfo) { return ERROR_NOT_ENOUGH_MEMORY; }

    CWaitCursor wait;

	// Now load the RouterInfo data from the registry
	hr = spRouterInfo->Load((LPCTSTR)pszMachine, hMprConfig);
    if (!FHrSucceeded(hr)) { return WIN32_FROM_HRESULT(hr); }

	// Get the pointer to the CRmInterfaceInfo object for the specified 
	// protocol and interface
	LookupRtrMgrInterface(spRouterInfo,
						  pwsInterfaceName,
						  PID_IPX,
						  &spRmIf);

	if (!spRmIf) { return ERROR_INVALID_DATA ;}

	// Load the data for the specified interface
	hr = spRmIf->Load(pszMachine, hMprConfig, NULL, NULL);

    if (!FHrSucceeded(hr)) { return WIN32_FROM_HRESULT(hr); }

	//
    // Display the IPX filter configuration dialog
    //
	spRmIf->GetInfoBase(hMprConfig, NULL, NULL, &spInfoBase);

	if (IpxFilterConfigInfoBase(pParent->GetSafeHwnd(), spInfoBase,
								spRmIf, dwFilterType) == hrOK)
	{
		hr = spRmIf->Save(pszMachine,
							 hMprConfig,
							 NULL,
							 NULL,
							 spInfoBase,
							 0);
		if (FHrSucceeded(hr))
			dwErr = ERROR_SUCCESS;
		else
			dwErr = WIN32_FROM_HRESULT(hr);
	}
	
	//
	// do clean up here and return
	//

    ::MprConfigServerDisconnect( hMprConfig );

    return dwErr;
}


HRESULT APIENTRY
IpxFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

	HRESULT		hr = hrOK;

	CIpxFilter dlg(CWnd::FromHandle(hwndParent), pInfoBase, dwFilterType);
    if( dlg.DoModal() == IDOK ) 
	{
		hr = hrOK;
	}
	else
	{
		hr = hrFalse;
	}
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipxadd.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipxadd.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of IPX Filter Add/Edit dialog code
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipxfltr.h"
#include "datafmt.h"
#include "IpxAdd.h"
extern "C" {
#include <ipxrtdef.h>
#include <ipxtfflt.h>
}

#include "rtradmin.hm"

/////////////////////////////////////////////////////////////////////////////
// CIpxAddEdit dialog


CIpxAddEdit::CIpxAddEdit(CWnd* pParent,
						 FilterListEntry ** ppFilterEntry)
	: CBaseDialog(CIpxAddEdit::IDD, pParent),
	  m_ppFilterEntry( ppFilterEntry ),
	  m_bValidate( TRUE )
{
	//{{AFX_DATA_INIT(CIpxAddEdit)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CIpxAddEdit::DoDataExchange(CDataExchange* pDX)
{
    CString cStr;
    
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIpxAddEdit)
	DDX_Control(pDX, IDC_AEIPX_EB_SRC_SOCKET, m_ebSrcSocket);
	DDX_Control(pDX, IDC_AEIPX_EB_SRC_NODE, m_ebSrcNode);
	DDX_Control(pDX, IDC_AEIPX_EB_SRC_NET, m_ebSrcNet);
	DDX_Control(pDX, IDC_AEIPX_EB_SRC_MASK, m_ebSrcMask);
	DDX_Control(pDX, IDC_AEIPX_EB_PACKET_TYPE, m_ebPacketType);
	DDX_Control(pDX, IDC_AEIPX_EB_DST_SOCKET, m_ebDstSocket);
	DDX_Control(pDX, IDC_AEIPX_EB_DST_NODE, m_ebDstNode);
	DDX_Control(pDX, IDC_AEIPX_EB_DST_NET, m_ebDstNet);
	DDX_Control(pDX, IDC_AEIPX_EB_DST_MASK, m_ebDstMask);
	DDX_Text(pDX, IDC_AEIPX_EB_SRC_SOCKET, cStr);
	DDV_MaxChars(pDX, cStr, 4);
	DDX_Text(pDX, IDC_AEIPX_EB_SRC_NODE, cStr);
	DDV_MaxChars(pDX, cStr, 12);
	DDX_Text(pDX, IDC_AEIPX_EB_SRC_NET, cStr);
	DDV_MaxChars(pDX, cStr, 8);
	DDX_Text(pDX, IDC_AEIPX_EB_SRC_MASK, cStr);
	DDV_MaxChars(pDX, cStr, 8);
	DDX_Text(pDX, IDC_AEIPX_EB_DST_SOCKET, cStr);
	DDV_MaxChars(pDX, cStr, 4);
	DDX_Text(pDX, IDC_AEIPX_EB_DST_NODE, cStr);
	DDV_MaxChars(pDX, cStr, 12);
	DDX_Text(pDX, IDC_AEIPX_EB_DST_NET, cStr);
	DDV_MaxChars(pDX, cStr, 8);
	DDX_Text(pDX, IDC_AEIPX_EB_DST_MASK, cStr);
	DDV_MaxChars(pDX, cStr, 8);
	DDX_Text(pDX, IDC_AEIPX_EB_PACKET_TYPE, cStr);
	DDV_MaxChars(pDX, cStr, 4);
	//}}AFX_DATA_MAP
}

// change not to use KILLFOCUS to do data entry validation:
// 		reason: create dead loop when the one loosing focus and the one getting focus both have invalid entries
//		here we change to do validation with OnOK
BEGIN_MESSAGE_MAP(CIpxAddEdit, CBaseDialog)
	//{{AFX_MSG_MAP(CIpxAddEdit)
/*	
    ON_MESSAGE(WM_EDITLOSTFOCUS, OnEditLostFocus)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_SRC_NET, OnKillFocusSrcNet)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_SRC_MASK, OnKillFocusSrcNetMask)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_SRC_NODE, OnKillFocusSrcNode)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_SRC_SOCKET, OnKillFocusSrcSocket)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_DST_NET, OnKillFocusDstNet)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_DST_MASK, OnKillFocusDstNetMask)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_DST_NODE, OnKillFocusDstNode)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_DST_SOCKET, OnKillFocusDstSocket)
	ON_EN_KILLFOCUS(IDC_AEIPX_EB_PACKET_TYPE, OnKillFocusPacketType)
*/	
    ON_WM_PARENTNOTIFY()
    ON_WM_ACTIVATEAPP()
    ON_WM_QUERYENDSESSION()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CIpxAddEdit::m_dwHelpMap[] =
{
//    IDC_AI_ST_SRC_NET, HIDC_AI_ST_SRC_NET,
//    IDC_AEIPX_EB_SRC_NET, HIDC_AEIPX_EB_SRC_NET,
//    IDC_AI_ST_SRC_MASK, HIDC_AI_ST_SRC_MASK,
//    IDC_AEIPX_EB_SRC_MASK, HIDC_AEIPX_EB_SRC_MASK,
//    IDC_AI_ST_SRC_NODE, HIDC_AI_ST_SRC_NODE,
//    IDC_AEIPX_EB_SRC_NODE, HIDC_AEIPX_EB_SRC_NODE,
//    IDC_AI_ST_SRC_SOCKET, HIDC_AI_ST_SRC_SOCKET,
//    IDC_AEIPX_EB_SRC_SOCKET, HIDC_AEIPX_EB_SRC_SOCKET,
//    IDC_AI_ST_DST_NET, HIDC_AI_ST_DST_NET,
//    IDC_AEIPX_EB_DST_NET, HIDC_AEIPX_EB_DST_NET,
//    IDC_AI_ST_DST_MASK, HIDC_AI_ST_DST_MASK,
//    IDC_AEIPX_EB_DST_MASK, HIDC_AEIPX_EB_DST_MASK,
//    IDC_AI_ST_DST_NODE, HIDC_AI_ST_DST_NODE,
//    IDC_AEIPX_EB_DST_NODE, HIDC_AEIPX_EB_DST_NODE,
//    IDC_AI_ST_DST_SOCKET, HIDC_AI_ST_DST_SOCKET,
//    IDC_AEIPX_EB_DST_SOCKET, HIDC_AEIPX_EB_DST_SOCKET,
//    IDC_AI_ST_PACKET_TYPE, HIDC_AI_ST_PACKET_TYPE,
//    IDC_AEIPX_EB_PACKET_TYPE, HIDC_AEIPX_EB_PACKET_TYPE,
	0,0
};

/////////////////////////////////////////////////////////////////////////////
// CIpxAddEdit message handlers

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnInitDialog
//
// Handles 'WM_INITDIALOG' notification from the dialog
//------------------------------------------------------------------------------

BOOL CIpxAddEdit::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	CString cStr;

    //
	// determine if a new filter is being added or if an
	// existing filter is being modified.
	//
	
	m_bEdit = ( *m_ppFilterEntry != NULL );

    cStr.LoadString(m_bEdit ? IDS_IPX_EDIT_FILTER : IDS_IPX_ADD_FILTER);
    SetWindowText(cStr);
    

    //
    // Remove this style so we get the WM_PARENTNOTIFY when 
    // the user clicks on the Cancel button
    //
    
    GetDlgItem(IDCANCEL)->ModifyStyleEx(WS_EX_NOPARENTNOTIFY,0);


    //
	// fill in the controls if user is editing an existing filter
    //
    
	if(m_bEdit)
	{
		FilterListEntry * pfle = *m_ppFilterEntry;
		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)
		{
			m_ebSrcNet.SetWindowText(cStr << CIPX_NETWORK(pfle->SourceNetwork));
			m_ebSrcMask.SetWindowText(cStr << CIPX_NETWORK(pfle->SourceNetworkMask));
		}


		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
		{
			m_ebSrcNode.SetWindowText(cStr << CIPX_NODE(pfle->SourceNode));
        }
		

		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
		{
			m_ebSrcSocket.SetWindowText(cStr << CIPX_SOCKET(pfle->SourceSocket));
		}


		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)
		{
			m_ebDstNet.SetWindowText(cStr << CIPX_NETWORK(pfle->DestinationNetwork));
			m_ebDstMask.SetWindowText(cStr << CIPX_NETWORK(pfle->DestinationNetworkMask));
		}

		
		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
		{
			m_ebDstNode.SetWindowText(cStr << CIPX_NODE(pfle->DestinationNode));
		}

		
		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
		{
			m_ebDstSocket.SetWindowText(cStr << CIPX_SOCKET(pfle->DestinationSocket));
		}
		
		
		if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
		{
			m_ebPacketType.SetWindowText(cStr << CIPX_PACKET_TYPE(pfle->PacketType));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD IDCsToVerify[] = {
			IDC_AEIPX_EB_SRC_NET, 
			IDC_AEIPX_EB_SRC_MASK, 
			IDC_AEIPX_EB_SRC_NODE, 
			IDC_AEIPX_EB_SRC_SOCKET, 
			IDC_AEIPX_EB_DST_NET,
			IDC_AEIPX_EB_DST_MASK, 
			IDC_AEIPX_EB_DST_NODE, 
			IDC_AEIPX_EB_DST_SOCKET, 
			IDC_AEIPX_EB_PACKET_TYPE, 
			0 };
			
//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnOK
//
// Handles 'BN_CLICKED' notification from the 'OK' button
//------------------------------------------------------------------------------

void CIpxAddEdit::OnOK() 
{
    DWORD   net, mask;
    
	CString cStr, cNet, cMask;
	
	FilterListEntry * pfle;

    INT n = 0;

	// validate the data entries
	while(IDCsToVerify[n] != 0)
	{
		if (TRUE != ValidateAnEntry(IDCsToVerify[n++]))
			return;

	};

	if(!*m_ppFilterEntry)
	{
	    //
		// new filter added, allocate memory and save information
		//
		
		*m_ppFilterEntry = new FilterListEntry;
	}

	VERIFY(*m_ppFilterEntry);

	pfle = *m_ppFilterEntry;


	do {

	    //
	    // init. flags  field.
	    //
	    
        pfle->FilterDefinition = 0;

        
        //
        // Traffic filter source parameters
        //
        
        m_ebSrcNet.GetWindowText(cNet);
        m_ebSrcMask.GetWindowText(cMask);


        //
        // if net number is empty
        //
        
        if ( cNet.GetLength() == 0 )
        {
            CString cEmpty = _T("00000000");

            cEmpty >> CIPX_NETWORK(pfle->SourceNetwork);


            //
            // if net mask is also empty
            //

            if ( cMask.GetLength() == 0 )
            {
			    cEmpty >> CIPX_NETWORK(pfle->SourceNetworkMask);
            }
        
            else
            {
                cMask >> CIPX_NETWORK( pfle-> SourceNetworkMask );
                pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            }
        }


        //
        // if net number is not empty
        //
        
        else
        {
            //
            // if net mask is empty
            //

            if ( cMask.GetLength() == 0 )
            {
				AfxMessageBox(IDS_ENTER_MASK);
				::SetFocus((HWND)m_ebSrcMask);
				
				break;
            }

            //
            // both net and mask specified.  Verify validity
            //
                
    		if ( ( _stscanf (cNet, TEXT("%lx%n"), &net, &n) == 1 )      && 
    			 ( n == cNet.GetLength() )                              &&
	    		 ( _stscanf (cMask, TEXT("%lx%n"), &mask, &n) == 1 )    &&
	    		 ( n == cMask.GetLength() ) ) 
            {
			    if ( ( net & mask ) != net)
				{
				    AfxMessageBox(IDS_ENTER_VALID_MASK);
    				::SetFocus((HWND)m_ebSrcMask);
    					
                    break;
			    }
            }
            
            else
            {
				AfxMessageBox(IDS_ENTER_VALID_MASK);
    			::SetFocus((HWND)m_ebSrcMask);
    					
                break;
            }


            //
            // valid network number and mask combination
            //
            
            cNet >> CIPX_NETWORK( pfle-> SourceNetwork );
            cMask >> CIPX_NETWORK( pfle-> SourceNetworkMask );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            
        }


        //
        // get source node
        //

        m_ebSrcNode.GetWindowText( cStr );

        if ( cStr.GetLength() == 0 )
        {
            CString cEmpty = _T( "000000000000" );
            
			cEmpty >> CIPX_NODE(pfle->SourceNode);
        }

        else
        {
            cStr >> CIPX_NODE( pfle-> SourceNode );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
        }


        //
        // get source socket
        //

        m_ebSrcSocket.GetWindowText( cStr );

        if ( cStr.GetLength() == 0 )
        {
            CString cEmpty = _T( "0000" );
            
			cEmpty >> CIPX_SOCKET( pfle->SourceSocket );
        }

        else
        {
            cStr >> CIPX_SOCKET( pfle-> SourceSocket );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
        }



        //
        // Traffic filter destination parameters
        //
        
        m_ebDstNet.GetWindowText(cNet);
        m_ebDstMask.GetWindowText(cMask);


        //
        // if net number is empty
        //
        
        if ( cNet.GetLength() == 0 )
        {
            CString cEmpty = _T("00000000");

            cEmpty >> CIPX_NETWORK(pfle->DestinationNetwork);


            //
            // if net mask is also empty
            //

            if ( cMask.GetLength() == 0 )
            {
			    cEmpty >> CIPX_NETWORK(pfle->DestinationNetworkMask);
            }
        
            else
            {
                cMask >> CIPX_NETWORK( pfle-> DestinationNetworkMask );
                pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            }
        }


        //
        // if net number is not empty
        //
        
        else
        {
            //
            // if net mask is empty
            //

            if ( cMask.GetLength() == 0 )
            {
				AfxMessageBox(IDS_ENTER_MASK);
				::SetFocus((HWND)m_ebDstMask);
				
				break;
            }

            //
            // both net and mask specified.  Verify validity
            //
                
    		if ( ( _stscanf (cNet, TEXT("%lx%n"), &net, &n) == 1 )      && 
    			 ( n == cNet.GetLength() )                              &&
	    		 ( _stscanf (cMask, TEXT("%lx%n"), &mask, &n) == 1 )    &&
	    		 ( n == cMask.GetLength() ) ) 
            {
			    if ( ( net & mask ) != net)
				{
				    AfxMessageBox(IDS_ENTER_VALID_MASK);
    				::SetFocus((HWND)m_ebDstMask);
    					
                    break;
			    }
            }
            
            else
            {
				AfxMessageBox(IDS_ENTER_VALID_MASK);
    			::SetFocus((HWND)m_ebDstMask);
    					
                break;
            }


            //
            // valid network number and mask combination
            //
            
            cNet >> CIPX_NETWORK( pfle-> DestinationNetwork );
            cMask >> CIPX_NETWORK( pfle-> DestinationNetworkMask );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            
        }


        //
        // get destination node
        //

        m_ebDstNode.GetWindowText( cStr );

        if ( cStr.GetLength() == 0 )
        {
            CString cEmpty = _T( "000000000000" );
            
			cEmpty >> CIPX_NODE(pfle->DestinationNode);
        }

        else
        {
            cStr >> CIPX_NODE( pfle-> DestinationNode );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
        }


        //
        // get destination socket
        //

        m_ebDstSocket.GetWindowText( cStr );

        if ( cStr.GetLength() == 0 )
        {
            CString cEmpty = _T( "0000" );
            
			cEmpty >> CIPX_SOCKET( pfle->DestinationSocket );
        }

        else
        {
            cStr >> CIPX_SOCKET( pfle-> DestinationSocket );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
        }


        //
        // get packet type
        //

        m_ebPacketType.GetWindowText( cStr );

        if ( cStr.GetLength() == 0 )
        {
            CString cEmpty = _T( "0" );

            cEmpty >> CIPX_PACKET_TYPE( pfle-> PacketType );
        }

        else
        {
            cStr >> CIPX_PACKET_TYPE( &pfle-> PacketType );

            pfle-> FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
        }
        
		CBaseDialog::OnOK();
		
	} while (FALSE);
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnCancel
//
// Handles 'BN_CLICKED' notification from the 'Cancel' button
//------------------------------------------------------------------------------

void CIpxAddEdit::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CBaseDialog::OnCancel();
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusSrcNet
//
// Handles 'EN_KILLFOCUS' notification from the 'Source Network number' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusSrcNet()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_SRC_NET, 0 );
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusSrcMask
//
// Handles 'EN_KILLFOCUS' notification from the 'Source Network Mask' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusSrcNetMask()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_SRC_MASK, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusSrcNode
//
// Handles 'EN_KILLFOCUS' notification from the 'Source Network Node' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusSrcNode()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_SRC_NODE, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusSrcSocket
//
// Handles 'EN_KILLFOCUS' notification from the 'Source Network Socket' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusSrcSocket()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_SRC_SOCKET, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusDstNet
//
// Handles 'EN_KILLFOCUS' notification from the 'Destination Network number' 
// editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusDstNet()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_DST_NET, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusDstMask
//
// Handles 'EN_KILLFOCUS' notification from the 'Destination Network mask' 
// editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusDstNetMask()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_DST_MASK, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusDstNode
//
// Handles 'EN_KILLFOCUS' notification from the 'Destination Node' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusDstNode()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_DST_NODE, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusSrcNet
//
// Handles 'EN_KILLFOCUS' notification from the 'Destination socket' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusDstSocket()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_DST_SOCKET, 0 );
}

//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusPacketType
//
// Handles 'EN_KILLFOCUS' notification from the 'Packet Type' editbox
//------------------------------------------------------------------------------

void CIpxAddEdit::OnKillFocusPacketType()
{
    PostMessage( WM_EDITLOSTFOCUS, IDC_AEIPX_EB_PACKET_TYPE, 0 );
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnKillFocusPacketType
//
// Handles 'EN_KILLFOCUS' notification from the 'Packet Type' editbox
//------------------------------------------------------------------------------
afx_msg
LONG CIpxAddEdit::OnEditLostFocus( UINT uId, LONG lParam )
{
	ValidateAnEntry(uId);

	return 0;

};
BOOL CIpxAddEdit::ValidateAnEntry( UINT uId)
{

    BOOL bOK    = FALSE;
    
    CString cStr, cStr1;
    

    if ( m_bValidate )
    {
        if ( !UpdateData( TRUE ) )
        {
            return 0;
        }

    
        switch ( uId )
        {
        case IDC_AEIPX_EB_SRC_NET:

            m_ebSrcNet.GetWindowText( cStr );

            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_NETWORK_NUMBER );
            }
            
            break;
        

        case IDC_AEIPX_EB_SRC_MASK:

            m_ebSrcMask.GetWindowText( cStr );

            m_ebSrcNet.GetWindowText( cStr1 );

            bOK = VerifyEntry( uId, cStr, cStr1 );

            break;


        case IDC_AEIPX_EB_SRC_NODE:

            m_ebSrcNode.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_NODE_NUMBER );
            }
            
            break;


        case IDC_AEIPX_EB_SRC_SOCKET:

            m_ebSrcSocket.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_SOCKET_NUMBER );
            }
            
            break;


        case IDC_AEIPX_EB_DST_NET:

            m_ebDstNet.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_NETWORK_NUMBER );
            }

            break;


        case IDC_AEIPX_EB_DST_MASK:

            m_ebDstMask.GetWindowText( cStr );
        
            m_ebDstNet.GetWindowText( cStr1 );

            bOK = VerifyEntry( uId, cStr, cStr1 );
            
            break;


        case IDC_AEIPX_EB_DST_NODE:

            m_ebDstNode.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_NODE_NUMBER );
            }

            break;


        case IDC_AEIPX_EB_DST_SOCKET:

            m_ebDstSocket.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_SOCKET_NUMBER );
            }

            break;


        case IDC_AEIPX_EB_PACKET_TYPE:

            m_ebPacketType.GetWindowText( cStr );
        
            if ( !( bOK = VerifyEntry( uId, cStr, cStr1 ) ) )
            {
                ::AfxMessageBox( IDS_INVALID_SERVICE_TYPE );
            }
            
            break;
        }

        if ( !bOK )
        {
            GetDlgItem( uId )-> SetFocus();
        }
    }

    m_bValidate = TRUE;
    
    return bOK;
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnParentNotify
//
// Handles 'WM_PARENTNOTIFY' notification caused by a mouse click on the CANCEL
// button
//------------------------------------------------------------------------------

void CIpxAddEdit::OnParentNotify(UINT message, LPARAM lParam)
{

    CBaseDialog::OnParentNotify(message, lParam);

    //
    // Mouse clicked on dialog.
    //
    
    CPoint ptButtonDown(LOWORD(lParam), HIWORD(lParam)); 

    //
    // Did the user click the mouse on the cancel button?
    //
    
    if ( ( message == WM_LBUTTONDOWN ) && 
         ( ChildWindowFromPoint( ptButtonDown ) == GetDlgItem(IDCANCEL) ) )
    {         
        m_bValidate = FALSE;
    }        
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnActivateApp
//
// Handles 'WM_ACTIVATEAPP' notification
//------------------------------------------------------------------------------

void CIpxAddEdit::OnActivateApp(BOOL bActive, HTASK hTask)
{
    CBaseDialog::OnActivateApp(bActive, hTask);

    m_bValidate = bActive;
}


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::OnQuerySession
//
// Handles 'WM_QUERYENDSESSION' notification
//------------------------------------------------------------------------------

BOOL CIpxAddEdit::OnQueryEndSession()
{

    if ( !CBaseDialog::OnQueryEndSession() )
    {
        return FALSE;
    }        
    
    //
    // Before ending this Windows session, 
    // validate the dialog controls.
    // This is basically the code from CDialog::OnOK();
    //
    
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }
    
    EndDialog(IDOK);
    
    return TRUE;
}


#define ValidHexCharSet         TEXT( "1234567890abcdefABCDEF" )


//------------------------------------------------------------------------------
// Function:	CIpxAddEdit::VerifyEntry
//
// Verifies entered data in each edit control
//------------------------------------------------------------------------------

BOOL CIpxAddEdit::VerifyEntry( 
    UINT            uId, 
    const CString&  cStr, 
    const CString&  cNet 
    )
{

    INT         n = 0;
    DWORD       dwNet, dwMask;

    
    //
    // if the value in cStr is not a mask
    //

    if ( uId != IDC_AEIPX_EB_SRC_MASK   &&
         uId != IDC_AEIPX_EB_DST_MASK )
    {
        //
        // if empty string skip it.
        //
        
        if ( cStr.GetLength() == 0 ) 
        {  
            return TRUE;
        }


        //
        // check string has only valid hex characters
        //

        CString cTmp = cStr.SpanIncluding( (LPCTSTR) ValidHexCharSet );

        return ( cTmp.GetLength() == cStr.GetLength() );
    }


    //
    // the value in CStr is a mask.
    //

    //
    // Empty network and mask is a valid combination. 
    //
    
    if ( cNet.GetLength() == 0 &&
         cStr.GetLength() == 0 )
    {
        return TRUE;
    }


    //
    // no network mask specified
    //

    if ( cStr.GetLength() == 0 )
    {

        //
        // check if network number is valid.  If it isn't
        // the network number check will fire, so do not
        // pop a box here.  HACK to circumvent the KILLFOCUS
        // processing
        //
        
        CString cTmp = cNet.SpanIncluding( (LPCTSTR) ValidHexCharSet );

        if ( cNet.GetLength() == cTmp.GetLength() )
        {
            ::AfxMessageBox( IDS_ENTER_MASK );
            return FALSE;
        }

        return TRUE;
    }
    
    
    //
    // verify mask has only hex chars.
    //

    CString cTmp = cStr.SpanIncluding( (LPCTSTR) ValidHexCharSet );

    if ( cTmp.GetLength() != cStr.GetLength() ) 
    { 
        ::AfxMessageBox( IDS_ENTER_VALID_MASK );
        return FALSE; 
    }


    //
    // If net number is empty, return TRUE.
    //

    if ( cNet.GetLength() == 0 )
    {
        return TRUE;
    }
    
    //
    // if net number contains invalid data, return TRUE.
    // Net number validation will take care of this.
    //

    cTmp = cNet.SpanIncluding( (LPCTSTR) ValidHexCharSet );

    if ( cNet.GetLength() != cTmp.GetLength() )
    {
        return TRUE;
    }
    
    //
    // verify net and mask jive
    //

    if ( ( _stscanf (cNet, TEXT("%lx%n"), &dwNet, &n) == 1 )      && 
         ( n == cNet.GetLength() )                              &&
	     ( _stscanf (cStr, TEXT("%lx%n"), &dwMask, &n) == 1 )    &&
         ( n == cStr.GetLength() ) ) 
    {
	    if ( ( dwNet & dwMask ) != dwNet)
		{
		    ::AfxMessageBox( (uId == IDC_AEIPX_EB_SRC_MASK) ?
		                     IDS_INVALID_SRC_MASK :
		                     IDS_INVALID_DST_MASK );
            return FALSE;
		}
    }
            
    else
    {
        ::AfxMessageBox( IDS_ENTER_VALID_MASK );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipxfltr.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:	ipxfltr.cpp
//
// History:
//	08/30/96	Ram Cherala 	Created
//
// Implementation of IPX Filter  dialog code
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "ipxfltr.h"
#include "datafmt.h"
#include "ipxadd.h"
#include <ipxrtdef.h>
#include <ipxtfflt.h>
extern "C" {
#include <winsock.h>
}
#include "rtradmin.hm"
#include "listctrl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if 1
static UINT uStringIdTable[]	= { IDS_COL_SOURCENETWORK,
									IDS_COL_SOURCEMASK,
									IDS_COL_SOURCENODE,
									IDS_COL_SOURCESOCKET,
									IDS_COL_DESTNETWORK,
									IDS_COL_DESTMASK,
									IDS_COL_DESTNODE,
									IDS_COL_DESTSOCKET,
									IDS_COL_PACKETTYPE
									} ;
#else
static UINT uStringIdTable[]	= { IDS_COL_SOURCEADDRESS,
									IDS_COL_DESTADDRESS,
									IDS_COL_PACKETTYPE
									} ;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIpxFilter dialog
CIpxFilter::CIpxFilter(CWnd*		pParent /*=NULL*/,
					   IInfoBase *	pInfoBase,
					   DWORD		dwFilterType)
	: CBaseDialog( (dwFilterType == FILTER_INBOUND ? CIpxFilter::IDD_INBOUND : CIpxFilter::IDD_OUTBOUND), pParent),
	  m_pParent(pParent),
	  m_dwFilterType(dwFilterType)
{
	//{{AFX_DATA_INIT(CIpxFilter)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_spInfoBase.Set(pInfoBase);

//	SetHelpMap(m_dwHelpMap);
}

CIpxFilter::~CIpxFilter()
{
	while (!m_filterList.IsEmpty()) {

		delete (FilterListEntry*)m_filterList.RemoveHead();
	}
}

void CIpxFilter::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIpxFilter)
	DDX_Control(pDX, IDC_IPX_FILTER_LIST, m_listCtrl);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CIpxFilter, CBaseDialog)
	//{{AFX_MSG_MAP(CIpxFilter)
	ON_NOTIFY(NM_DBLCLK, IDC_IPX_FILTER_LIST, OnDblclkIpxFilterList)
	ON_BN_CLICKED(IDC_IPX_FILTER_ADD, OnIpxFilterAdd)
	ON_BN_CLICKED(IDC_IPX_FILTER_EDIT, OnIpxFilterEdit)
	ON_BN_CLICKED(IDC_IPX_FILTER_DELETE, OnIpxFilterDelete)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_IPX_FILTER_LIST, OnGetdispinfoIpxFilterList)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_IPX_FILTER_LIST, OnNotifyListItemChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CIpxFilter::m_dwHelpMap[] =
{
//	IDC_IPX_PERMIT, HIDC_IPX_PERMIT,
//	IDC_IPX_DENY, HIDC_IPX_DENY,
//	IDC_IPX_FILTER_LIST, HIDC_IPX_FILTER_LIST,
//	IDC_IPX_FILTER_ADD, HIDC_IPX_FILTER_ADD,
//	IDC_IPX_FILTER_EDIT, HIDC_IPX_FILTER_EDIT,
//	IDC_IPX_FILTER_DELETE, HIDC_IPX_FILTER_DELETE,
	0,0
};

/////////////////////////////////////////////////////////////////////////////
// CIpxFilter message handlers

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnInitDialog
//
// Handles 'WM_INITDIALOG' notification from the dialog
//------------------------------------------------------------------------------

BOOL CIpxFilter::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	CBaseDialog::OnInitDialog();
	
	ASSERT( m_dwFilterType == FILTER_INBOUND || m_dwFilterType == FILTER_OUTBOUND );

	InfoBlock * pBlock;
	IPX_TRAFFIC_FILTER_GLOBAL_INFO	* pIpxGlobal;
	IPX_TRAFFIC_FILTER_INFO 		* pIpxInfo;

	CRect	rcDlg, rc;
	CString sCol;
	DWORD	dwErr = NO_ERROR;
	HRESULT hr = hrOK;

    m_stAny.LoadString(IDS_ANY);
	
	// initialize rectangle for list control display

	GetClientRect(rcDlg);

	// insert columns
	m_listCtrl.GetClientRect(&rc);

	UINT i;

	for ( i = 0; i < IPX_NUM_COLUMNS; i++ ) {
		sCol.LoadString(uStringIdTable[i]);
		m_listCtrl.InsertColumn(i, sCol);
		AdjustColumnWidth(m_listCtrl, i, sCol);
	}
	// set extended attributes
	ListView_SetExtendedListViewStyle( m_listCtrl.m_hWnd, LVS_EX_FULLROWSELECT );

	hr = m_spInfoBase->GetBlock((m_dwFilterType == FILTER_INBOUND) ? 
                                IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
                                IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
                                &pBlock, 0);
                                    
                          
	// The filter was previously defined
                                    
    // Windows NT Bug : 267091
    // We may get a NULL block (one that has 0 data), so we need
    // to check for that case also.
                                   
	if (FHrSucceeded(hr) && (pBlock->pData != NULL))
	{
		pIpxGlobal = ( IPX_TRAFFIC_FILTER_GLOBAL_INFO * ) pBlock->pData;
		SetFilterActionButtonsAndText(m_dwFilterType, pIpxGlobal->FilterAction);
	}
	else
	{
		SetFilterActionButtonsAndText(m_dwFilterType, IPX_TRAFFIC_FILTER_ACTION_DENY);
	}

	DWORD	dwCount;

	hr = m_spInfoBase->GetBlock( (m_dwFilterType == FILTER_INBOUND) ? 
									IPX_IN_TRAFFIC_FILTER_INFO_TYPE :
									IPX_OUT_TRAFFIC_FILTER_INFO_TYPE, &pBlock,
									0);
	if (FHrSucceeded(hr))
	{
		dwCount  = pBlock->dwCount;

		pIpxInfo = ( PIPX_TRAFFIC_FILTER_INFO ) pBlock->pData;
        
        if (pIpxInfo)
        {
            for ( i = 0; i < dwCount; i++, pIpxInfo++ ) {
                FilterListEntry* pfle = new FilterListEntry;
                
                if (!pfle) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }
                
                CopyMemory(pfle, pIpxInfo, sizeof(IPX_TRAFFIC_FILTER_INFO));
                pfle->pos	=	m_filterList.AddTail(pfle);
                INT item = m_listCtrl.InsertItem(	LVIF_TEXT|LVIF_PARAM, i, LPSTR_TEXTCALLBACK,
                    0,0,0, (LPARAM)pfle);
                if(item != -1) {m_listCtrl.SetItemData( item, (DWORD_PTR)pfle); }
            }
        }
	}

	// select the first item in the list if list is not empty, else
	// disable the radio controls and set sate to Allow

	if( m_listCtrl.GetItemCount())
	{
		m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
		m_listCtrl.SetFocus();
		
		GetDlgItem(IDC_IPX_FILTER_DELETE)->EnableWindow(TRUE);
		GetDlgItem(IDC_IPX_FILTER_EDIT)->EnableWindow(TRUE);
	}
	else
	{
		SetFilterActionButtonsAndText(m_dwFilterType, IPX_TRAFFIC_FILTER_ACTION_DENY, FALSE);
		GetDlgItem(IDC_IPX_FILTER_DELETE)->EnableWindow(FALSE);
		GetDlgItem(IDC_IPX_FILTER_EDIT)->EnableWindow(FALSE);
	}

#if 0
	if ( dwErr != NO_ERROR )	{
		// report construction error and return
		::AfxMessageBox(IDS_CONSTRUCTION_ERROR);
	}
#endif	
	return FALSE;  // return TRUE unless you set the focus to a control
				   // EXCEPTION: OCX Property Pages should return FALSE
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnDblclkIpxFilterList						  
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------


void CIpxFilter::OnDblclkIpxFilterList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnIpxFilterEdit();
	
	*pResult = 0;
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnIpxFilterAdd						   
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------

void CIpxFilter::OnIpxFilterAdd() 
{
	// Display the IP filter Add/Edit dialog
	//

	FilterListEntry* pfle = NULL;

	CIpxAddEdit dlg( this, (FilterListEntry**)&pfle);
  
	if ( dlg.DoModal() != IDOK )	{ return; }

	// Add the newly configured filter to our list and update list control

	pfle->pos = m_filterList.AddTail( pfle );
	int item = m_listCtrl.InsertItem(	LVIF_TEXT|LVIF_PARAM, 0, LPSTR_TEXTCALLBACK,
										0,0,0, (LPARAM)pfle);
	if(item != -1) {m_listCtrl.SetItemData( item, (DWORD_PTR)pfle); }

	// enable radio controls when the first item is added to list
	m_listCtrl.SetItemState(item, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();

}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnIpxFilterEdit 						
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------

void CIpxFilter::OnIpxFilterEdit() 
{
	// Get the current list selection
	// get the corresponding itemdata
	// pass it down to the CIpFltrAddEdit dialog

	//
	// Get the selected item
	//

	int i = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

	if (i == -1) { return ; }

	//
	// Get the interface for the selected item
	//

	FilterListEntry* pfle = (FilterListEntry*)m_listCtrl.GetItemData(i);

	CIpxAddEdit dlg( this, (FilterListEntry**)&pfle  );
  
	if ( dlg.DoModal() != IDOK )	{ return; }

	m_listCtrl.Update(i);
	m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnIpxFilterDelete						  
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------

void CIpxFilter::OnIpxFilterDelete() 
{
	// Get the current list selection
	// delete it from our private list
	// delete the item from the list or just refresh the list view

	//
	// Get the selected item
	//

	int i = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

	if (i == -1) { return ; }

	//
	// Get the interface for the selected item
	//

	FilterListEntry* pfle = (FilterListEntry*)m_listCtrl.GetItemData(i);

	//
	// delete it
	m_listCtrl.DeleteItem(i);
	m_filterList.RemoveAt(pfle->pos); 
	delete pfle;

	//
	// select the next available list item
	//

	// disable radio controls if all items in list are deleted
	// they will be reenabled when the first filter is added to list
	if( !m_listCtrl.GetItemCount())
	{
		SetFilterActionButtonsAndText(m_dwFilterType, IPX_TRAFFIC_FILTER_ACTION_DENY, FALSE);
	}
	else if (m_listCtrl.GetItemCount() == i)
		m_listCtrl.SetItemState((i == 0? i: i-1), LVIS_SELECTED, LVIS_SELECTED);
	else
		m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	m_listCtrl.SetFocus();
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnOK						 
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------

void CIpxFilter::OnOK() 
{
	// If the filters information changed, write this to registry
	// and return
	DWORD	 dwSize, dwCount, dwErr;
	HRESULT 	hr = hrOK;

	dwCount = (DWORD) m_filterList.GetCount();

	if (!dwCount && IsDlgButtonChecked(IDC_IPX_DENY) )
	{
		if (m_dwFilterType == FILTER_INBOUND)
			AfxMessageBox(IDS_RECEIVE_NO_FILTER, MB_OK);
		else
			AfxMessageBox(IDS_TRANSMIT_NO_FILTER, MB_OK);
		return;
	}
	
	
	if(dwCount)
	{
		InfoBlock * pBlock = new InfoBlock;

		// First Set the global information

		if (!pBlock)	{ // display an error message for no memory 
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		};
		dwSize = pBlock->dwSize = sizeof( IPX_TRAFFIC_FILTER_GLOBAL_INFO );

		pBlock->dwType =	(m_dwFilterType == FILTER_INBOUND) ? 
							IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
							IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
		pBlock->dwCount = 1;
		
		pBlock->pData = new BYTE[dwSize];

		if(!pBlock->pData)	{ // display an error message for no memory
			delete pBlock;
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		}
		
		IPX_TRAFFIC_FILTER_GLOBAL_INFO * pIpxGlobal = (IPX_TRAFFIC_FILTER_GLOBAL_INFO*)pBlock->pData;
		pIpxGlobal->FilterAction =	IsDlgButtonChecked(IDC_IPX_PERMIT) ? IPX_TRAFFIC_FILTER_ACTION_DENY : IPX_TRAFFIC_FILTER_ACTION_PERMIT;

		if( FHrOK(m_spInfoBase->BlockExists(
							(m_dwFilterType == FILTER_INBOUND)?
							IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
							IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE )))
		{
			hr = m_spInfoBase->SetBlock( 
							(m_dwFilterType == FILTER_INBOUND)?
							IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
							IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE ,
							pBlock, 0);
		}
		else
		{
			hr = m_spInfoBase->AddBlock( 
						(m_dwFilterType == FILTER_INBOUND)?
						IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
						IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
						dwSize,
						pBlock->pData,
						1, FALSE);
		}

		delete[] pBlock->pData;

		// now set the filter information

		pBlock->dwType = (m_dwFilterType == FILTER_INBOUND) ? IPX_IN_TRAFFIC_FILTER_INFO_TYPE : IPX_OUT_TRAFFIC_FILTER_INFO_TYPE ;
		// dwCount -1 because FILTER_DESCRIPTOR already has room for one FILTER_INFO structure
		pBlock->dwSize = sizeof(IPX_TRAFFIC_FILTER_INFO);
		dwSize = sizeof (IPX_TRAFFIC_FILTER_INFO) * dwCount;
		pBlock->dwCount = dwCount;
		
		pBlock->pData  = new BYTE[dwSize];

		if(!pBlock->pData)	{ // display an error message for no memory
			delete pBlock;
			AfxMessageBox(IDS_ERROR_NO_MEMORY);
			return;
		}

		IPX_TRAFFIC_FILTER_INFO    * pIPXfInfo;

		pIPXfInfo = (IPX_TRAFFIC_FILTER_INFO*)pBlock->pData;

		POSITION pos;

		pos = m_filterList.GetHeadPosition();
		while(pos)	{
			FilterListEntry* pfle = (FilterListEntry*)m_filterList.GetNext(pos);
			CopyMemory(pIPXfInfo, pfle, sizeof(IPX_TRAFFIC_FILTER_INFO));
			pIPXfInfo++;
		}

		if( FHrOK(m_spInfoBase->BlockExists(m_dwFilterType == FILTER_INBOUND?IPX_IN_TRAFFIC_FILTER_INFO_TYPE:IPX_OUT_TRAFFIC_FILTER_INFO_TYPE)))
		{
			hr = m_spInfoBase->SetBlock( 
					(m_dwFilterType == FILTER_INBOUND) ? IPX_IN_TRAFFIC_FILTER_INFO_TYPE : IPX_OUT_TRAFFIC_FILTER_INFO_TYPE,
											pBlock, 0);
		}
		else
		{
			hr = m_spInfoBase->AddBlock( 
						(m_dwFilterType == FILTER_INBOUND) ? IPX_IN_TRAFFIC_FILTER_INFO_TYPE : IPX_OUT_TRAFFIC_FILTER_INFO_TYPE,				
						pBlock->dwSize,
						pBlock->pData,
						pBlock->dwCount,
						FALSE);
		}
		if (!FHrSucceeded(hr))
		{
			AfxMessageBox(IDS_ERROR_SETTING_BLOCK);
		}
		delete[] pBlock->pData;
		delete pBlock;
	}
	else
	{
		// remove any previously defined filters
		hr = m_spInfoBase->AddBlock((m_dwFilterType == FILTER_INBOUND) ?
						IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
						IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
						0, NULL, 0, TRUE);
		hr = m_spInfoBase->AddBlock((m_dwFilterType == FILTER_INBOUND) ?
						IPX_IN_TRAFFIC_FILTER_INFO_TYPE :
						IPX_OUT_TRAFFIC_FILTER_INFO_TYPE,
						0, NULL, 0, TRUE);
	}
	
	CBaseDialog::OnOK();
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnCancel						 
//						   `													
// Handles 'NM_DBLCLK' notification from the Filter list control
//------------------------------------------------------------------------------

void CIpxFilter::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CBaseDialog::OnCancel();
}

//------------------------------------------------------------------------------
// Function:	CIpxFilter::SetFilterActionButtonsAndText						  
//																			   
// Called to set the 'Filter Action' radio-buttons and corresponding text	
// Enables/Disables controls based on 'bEnable' value - defaults to enable
//------------------------------------------------------------------------------

VOID
CIpxFilter::SetFilterActionButtonsAndText(
	DWORD	dwFilterType,
	DWORD	dwAction,
	BOOL	bEnable
)	
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CheckDlgButton( IDC_IPX_PERMIT, dwAction == IPX_TRAFFIC_FILTER_ACTION_DENY );
	CheckDlgButton( IDC_IPX_DENY,	dwAction == IPX_TRAFFIC_FILTER_ACTION_PERMIT );
	
	CString sItem;

//	GetDlgItem(IDC_IPX_PERMIT)->EnableWindow(bEnable);
//	GetDlgItem(IDC_IPX_DENY)->EnableWindow(bEnable);

//	sItem.LoadString( dwFilterType == FILTER_INBOUND? IDS_RECEIVE : IDS_TRANSMIT );
//	SetDlgItemText( IDC_IPX_PERMIT, sItem );
//	sItem.LoadString( IDS_DROP );
//	SetDlgItemText( IDC_IPX_DENY, sItem );
}

#if 1
enum {
	SRC_NETWORK=0,
	SRC_MASK,
	SRC_NODE,
	SRC_SOCKET,
	DEST_NETWORK,
	DEST_MASK,
	DEST_NODE,
	DEST_SOCKET,
	PACKET_TYPE
};
#else

enum {
	SRC_ADDRESS=0,
	DEST_ADDRESS,
	PACKET_TYPE
};

#endif

	
//------------------------------------------------------------------------------
// Function:	CIpxFilter::OnGetdispinfoIpxFilterList
//
// Handles 'LVN_GETDISPINFO' notification from the list control
//------------------------------------------------------------------------------

void CIpxFilter::OnGetdispinfoIpxFilterList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	WCHAR buffer[32];
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	CString cStr;
	BOOL	bFilter;

	FilterListEntry * pfle = (FilterListEntry*)pDispInfo->item.lParam;

    // Setup some default
    pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) m_stAny;

	switch( pDispInfo->hdr.code )
	{
	case LVN_GETDISPINFO:
		switch( pDispInfo->item.iSubItem )
		{
		case SRC_NETWORK:
            if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)
                pfle->stSourceNetwork << CIPX_NETWORK(pfle->SourceNetwork);
            else
                pfle->stSourceNetwork = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stSourceNetwork;
			break;
            
		case SRC_MASK:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)
                pfle->stSourceNetworkMask << CIPX_NETWORK(pfle->SourceNetworkMask);
            else
                pfle->stSourceNetworkMask = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stSourceNetworkMask;
			break;
            
		case SRC_NODE:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
                pfle->stSourceNode << CIPX_NODE(pfle->SourceNode);
            else
                pfle->stSourceNode = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stSourceNode;
			break;
            
		case SRC_SOCKET:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
                pfle->stSourceSocket << CIPX_SOCKET(pfle->SourceSocket);
            else
                pfle->stSourceSocket = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stSourceSocket;
			break;
            
		case DEST_NETWORK:
            if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)
                pfle->stDestinationNetwork << CIPX_NETWORK(pfle->DestinationNetwork);
            else
                pfle->stDestinationNetwork = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stDestinationNetwork;            
			break;
            
		case DEST_MASK:
            if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)
                pfle->stDestinationNetworkMask << CIPX_NETWORK(pfle->DestinationNetworkMask);
            else
                pfle->stDestinationNetworkMask = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stDestinationNetworkMask;            
			break;
            
		case DEST_NODE:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
                pfle->stDestinationNode << CIPX_NODE(pfle->DestinationNode);
            else
                pfle->stDestinationNode = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stDestinationNode;            
			break;
            
		case DEST_SOCKET:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
                pfle->stDestinationSocket << CIPX_SOCKET(pfle->DestinationSocket);
            else
                pfle->stDestinationSocket = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stDestinationSocket;            
			break;
            
		case PACKET_TYPE:
			if (pfle->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
                pfle->stPacketType << CIPX_PACKET_TYPE(pfle->PacketType);
            else
                pfle->stPacketType = m_stAny;
            pDispInfo->item.pszText = (LPTSTR) (LPCTSTR) pfle->stPacketType;            
			break;
		default:
			break;
		}
	}
	*pResult = 0;
}


void CIpxFilter::OnNotifyListItemChanged(NMHDR *pNmHdr, LRESULT *pResult)
{
	BOOL		fSelected;

	fSelected = (m_listCtrl.GetNextItem(-1, LVNI_SELECTED) != -1);
	GetDlgItem(IDC_IPX_FILTER_DELETE)->EnableWindow(fSelected);
	GetDlgItem(IDC_IPX_FILTER_EDIT)->EnableWindow(fSelected);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipxadd.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipxadd.h
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Class declarations for IPX filter Add/Edit routines
//============================================================================

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#define WM_EDITLOSTFOCUS        (WM_USER + 101)

/////////////////////////////////////////////////////////////////////////////
// CIpxAddEdit dialog

class CIpxAddEdit : public CBaseDialog
{
// Construction
public:
	CIpxAddEdit(CWnd* pParent,
				FilterListEntry ** ppFilterEntry);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CIpxAddEdit)
	enum { IDD = IDD_IPXFILTER_ADDEDIT };
	CEdit	m_ebSrcSocket;
	CEdit	m_ebSrcNode;
	CEdit	m_ebSrcNet;
	CEdit	m_ebSrcMask;
	CEdit	m_ebPacketType;
	CEdit	m_ebDstSocket;
	CEdit	m_ebDstNode;
	CEdit	m_ebDstNet;
	CEdit	m_ebDstMask;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIpxAddEdit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD		m_dwHelpMap[];

	FilterListEntry**	m_ppFilterEntry;
	BOOL				m_bEdit;
    BOOL                m_bValidate;
    
    BOOL                VerifyEntry( 
                            UINT uId, 
                            const CString& cStr, 
                            const CString& cNet );

	// call VerifyEntry inside                            
	BOOL ValidateAnEntry( UINT uId);                            
    
	// Generated message map functions
	//{{AFX_MSG(CIpxAddEdit)
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg LONG OnEditLostFocus(UINT, LONG); 
	afx_msg void OnKillFocusSrcNet();
	afx_msg void OnKillFocusSrcNetMask();
	afx_msg void OnKillFocusSrcNode();
	afx_msg void OnKillFocusSrcSocket();
	afx_msg void OnKillFocusDstNet();
	afx_msg void OnKillFocusDstNetMask();
	afx_msg void OnKillFocusDstNode();
	afx_msg void OnKillFocusDstSocket();
	afx_msg void OnKillFocusPacketType();
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg BOOL OnQueryEndSession();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\rtrfiltr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       rtrfiltr.h
//
//--------------------------------------------------------------------------

// rtrfiltr.h : main header file for the RTRFILTR DLL
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "filter.h"

/////////////////////////////////////////////////////////////////////////////
// CRtrfiltrApp
// See rtrfiltr.cpp for the implementation of this class
//

class CRtrfiltrApp : public CWinApp
{
public:
	CRtrfiltrApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRtrfiltrApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CRtrfiltrApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

DWORD APIENTRY
IpxFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
	IN	LPCWSTR		pwsInterfaceName,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    );

DWORD APIENTRY
IpFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
	IN	LPCWSTR		pwsInterfaceName,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    );

HRESULT APIENTRY
IpxFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    );

HRESULT APIENTRY
IpFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    );

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtrfiltr.rc
//
#define IDS_RECEIVE                     1
#define IDS_TRANSMIT                    2
#define IDS_DROP                        3
#define IDS_CONSTRUCTION_ERROR          4
#define IDS_COL_SOURCEADDRESS           5
#define IDS_COL_SOURCEMASK              6
#define IDS_COL_DESTADDRESS             7
#define IDS_COL_DESTMASK                8
#define IDS_COL_PROTOCOL                9
#define IDS_COL_SOURCEPORT              10
#define IDS_COL_DESTPORT                11
#define IDS_PROTOCOL_TCP                12
#define IDS_PROTOCOL_UDP                13
#define IDS_PROTOCOL_ICMP               14
#define IDS_PROTOCOL_ANY                15
#define IDS_PROTOCOL_OTHER              16
#define IDS_ICMP_TYPE                   17
#define IDS_ICMP_CODE                   18
#define IDS_SRC_PORT                    19
#define IDS_DST_PORT                    20
#define IDS_IP_PORT                     21
#define IDS_ENTER_SRC_ADDRESS           22
#define IDS_ENTER_SRC_MASK              23
#define IDS_ENTER_DST_ADDRESS           24
#define IDS_ENTER_DST_MASK              25
#define IDS_ENTER_OTHER_PROTOCOL        26
#define IDS_ERROR_NO_MEMORY             27
#define IDS_ERROR_SETTING_BLOCK         28
#define IDS_COL_SOURCENETWORK           29
#define IDS_COL_SOURCENODE              30
#define IDS_COL_SOURCESOCKET            31
#define IDS_COL_DESTSOCKET              32
#define IDS_COL_DESTNETWORK             33
#define IDS_COL_DESTNODE                34
#define IDS_COL_PACKETTYPE              35
#define IDS_ENTER_NETWORK               36
#define IDS_ENTER_MASK                  37
#define IDS_ENTER_NODE                  38
#define IDS_ENTER_SOCKET                39
#define IDS_ENTER_PACKETTYPE            40
#define IDS_INVALID_NETWORK_NUMBER      41
#define IDS_INVALID_NODE_NUMBER         42
#define IDS_INVALID_SOCKET_NUMBER       43
#define IDS_INVALID_SERVICE_TYPE        44
#define IDS_ENTER_VALID_MASK            45
#define IDS_INVALID_SRC_MASK            46
#define IDS_INVALID_DST_MASK            47
#define IDS_OTHER_PROTOCOL              48
#define IDS_PROTOCOL_TCP_ESTABLISHED    49
#define IDS_ANY                         50
#define IDS_PERUSER_PERMIT              51
#define IDS_PERUSER_DENY                52
#define IDS_USER_MASK                   53
#define IDS_USER_ADDRESS                54
#define IDS_PROTOCOL_UNKNOWN            55
#define IDS_IP_ADD_FILTER               56
#define IDS_IP_EDIT_FILTER              57
#define IDS_IPX_ADD_FILTER              58
#define IDS_IPX_EDIT_FILTER             59
#define IDS_IP_TITLE_INPUT              60
#define IDS_IP_TITLE_OUTPUT             61
#define IDS_IP_TITLE_DD                 62
#define IDS_RECEIVE_NO_FILTER           63
#define IDS_TRANSMIT_NO_FILTER          64
#define IDD_IPXFILTER_OUTPUT            136
#define IDC_IPX_PERMIT                  6000
#define IDC_IPX_DENY                    6001
#define IDC_IPX_FILTER_LIST             6002
#define IDC_IPX_FILTER_ADD              6003
#define IDC_AEIPX_CB_SRC_NET            6004
#define IDC_AEIPX_CB_SRC_NODE           6005
#define IDC_AEIPX_EB_SRC_MASK           6006
#define IDC_AEIPX_EB_SRC_NET            6007
#define IDC_AI_ST_SRC_MASK              6008
#define IDC_AEIPX_EB_SRC_NODE           6009
#define IDC_AEIPX_CB_SRC_SOCKET         6010
#define IDC_AEIPX_EB_SRC_SOCKET         6011
#define IDC_AEIPX_CB_DST_NET            6012
#define IDC_AEIPX_EB_DST_MASK           6013
#define IDC_AEIPX_EB_DST_NET            6014
#define IDC_AI_ST_DST_MASK              6015
#define IDC_AEIPX_CB_DST_NODE           6016
#define IDC_AEIPX_EB_DST_NODE           6017
#define IDC_AEIPX_CB_DST_SOCKET         6018
#define IDC_AEIPX_EB_DST_SOCKET         6019
#define IDC_AEIPX_CB_PACKET_TYPE        6020
#define IDC_AEIPX_EB_PACKET_TYPE        6021
#define IDC_IP_DENY                     6022
#define IDC_IP_FILTER_LIST              6023
#define IDC_IP_FILTER_ADD               6024
#define IDC_IP_FILTER_EDIT              6025
#define IDC_IP_FILTER_DELETE            6026
#define IDC_AEIP_CB_PROTOCOL            6027
#define IDC_AEIP_CB_SRC_PORT            6030
#define IDC_AEIP_CB_DEST_PORT           6031
#define IDC_AEIP_CB_SOURCE              6033
#define IDC_AEIP_ST_SOURCE_MASK         6035
#define IDC_AEIP_CB_DEST                6037
#define IDC_AEIP_ST_PROTOCOL            6038
#define IDC_AEIP_ST_SRC_PORT            6041
#define IDC_AEIP_ST_DEST_PORT           6042
#define IDC_AEIP_EB_SOURCE_ADDRESS      6045
#define IDC_AEIP_EB_SOURCE_MASK         6047
#define IDC_AEIP_EB_DEST_ADDRESS        6048
#define IDC_AEIP_EB_DEST_MASK           6049
#define IDC_IPX_FILTER_CONFIGURE        6052
#define IDC_IPX_FILTER_EDIT             6053
#define IDC_IPX_FILTER_DELETE           6054
#define IDC_AEIP_ST_DEST_MASK           6055
#define IDC_AEIP_ST_SOURCE_ADDRESS      6056
#define IDC_AEIP_ST_DEST_ADDRESS        6057
#define IDC_AI_ST_DST_NET               6058
#define IDC_AI_ST_DST_NODE              6059
#define IDC_IP_PERMIT                   6060
#define IDC_AI_ST_SRC_NET               6061
#define IDC_AI_ST_SRC_NODE              6062
#define IDC_AI_ST_SRC_SOCKET            6063
#define IDC_AI_ST_DST_SOCKET            6064
#define IDC_AI_ST_PACKET_TYPE           6065
#define IDC_IP_FILTER_ONLY              6066
#define IDC_IP_FILTER_ALL               6067
#define IDC_CHECK1                      6068
#define IDC_CHECK2                      6069
#define IDD_IPXFILTER                   14000
#define IDD_IPXFILTER_INPUT             14000
#define IDD_IPXFILTER_ADDEDIT           14001
#define IDD_IPFILTER                    14002
#define IDD_IPFILTER_ADDEDIT            14003
#define IDD_IPFILTER_DD                 14004
#define IDS_OUTPUT_TEXT                 14005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         6070
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\ipxfltr.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    ipxfltr.h
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Class declarations for IPX Filter code.
//============================================================================

#ifndef _IPXFLTR_H_
#define _IPXFLTR_H_

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#define		IPX_NUM_COLUMNS	    9

struct 	FilterListEntry	{
    ULONG		FilterDefinition;
    UCHAR		DestinationNetwork[4];
    UCHAR		DestinationNetworkMask[4];
    UCHAR		DestinationNode[6];
    UCHAR		DestinationSocket[2];
    UCHAR		SourceNetwork[4];
    UCHAR		SourceNetworkMask[4];
    UCHAR		SourceNode[6];
    UCHAR		SourceSocket[2];
    UCHAR		PacketType;

    // These are the string equivalents of the data above.
    // This is used by the getdispinfo
    CString     stFilterDefinition;
    CString     stDestinationNetwork;
    CString     stDestinationNetworkMask;
    CString     stDestinationNode;
    CString     stDestinationSocket;
    CString     stSourceNetwork;
    CString     stSourceNetworkMask;
    CString     stSourceNode;
    CString     stSourceSocket;
    CString     stPacketType;

    POSITION	pos;
};

/////////////////////////////////////////////////////////////////////////////
// CIpxFilter dialog

class CIpxFilter : public CBaseDialog
{
// Construction
public:
	CIpxFilter(CWnd *		pParent,
			   IInfoBase *	pInfoBase,
			   DWORD		dwFilterType );

    ~CIpxFilter();

// Dialog Data
	//{{AFX_DATA(CIpxFilter)
	enum { 
		IDD_INBOUND = IDD_IPXFILTER_INPUT,
		IDD_OUTBOUND = IDD_IPXFILTER_OUTPUT
	};
	CListCtrl	m_listCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIpxFilter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

private:
	VOID	
		SetFilterActionButtonsAndText(	DWORD	dwFilterType,
										DWORD	dwAction,
										BOOL	bEnable = TRUE );

protected:
	static DWORD	m_dwHelpMap[];

	CWnd*			m_pParent;
	SPIInfoBase		m_spInfoBase;
	DWORD			m_dwFilterType;
	CPtrList		m_filterList;
    CString         m_stAny;

	// Generated message map functions
	//{{AFX_MSG(CIpxFilter)
	afx_msg void OnDblclkIpxFilterList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnIpxFilterAdd();
	afx_msg void OnIpxFilterEdit();
	afx_msg void OnIpxFilterDelete();
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnGetdispinfoIpxFilterList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNotifyListItemChanged(NMHDR *, LRESULT *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif // _IPXFLTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	rtrfiltr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include "atlbase.h"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "mprsnap.h"

#include <mmc.h>

extern "C" {
#include <mprapi.h>
#include <dim.h>
}

#include "dbgutil.h"
#include "std.h"
#include "info.h"
#include "infobase.h"
#include "tfschar.h"
#include "errutil.h"

#include "mprfltr.h"

#include "commctrl.h" //kmurthy:For comctr32 version 6

//again for comctrl32 version 6
#define SIDEBYSIDE_COMMONCONTROLS 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrfiltr\rtrfiltr.cpp ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    rtrfiltr.cpp
//
// History:
//  08/30/96	Ram Cherala		Created
//
// Implementation of Router Packet Filters Configuration
// Defines initialization routines for the rtrfiltr.dll
//============================================================================

#include "stdafx.h"
#include "rtrfiltr.h"
#include "mprfltr.h"
#include "ipaddr.h"
#include "dialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRtrfiltrApp

BEGIN_MESSAGE_MAP(CRtrfiltrApp, CWinApp)
	//{{AFX_MSG_MAP(CRtrfiltrApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRtrfiltrApp construction

CRtrfiltrApp::CRtrfiltrApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRtrfiltrApp object

CRtrfiltrApp theApp;

BOOL CRtrfiltrApp::InitInstance() 
{
	BOOL bRet = CWinApp::InitInstance();

	// Setup the proper help file
	free((void *) m_pszHelpFilePath);
	m_pszHelpFilePath = _tcsdup(_T("mprsnap.hlp"));
	
	// Setup the global help function
	extern DWORD * RtrfiltrSnapHelpMap(DWORD dwIDD);
	SetGlobalHelpMapFunction(RtrfiltrSnapHelpMap);
   
	// initialize IP address control once

    if (bRet)
    {
        if (m_pszHelpFilePath != NULL)
            free((void*)m_pszHelpFilePath);
        m_pszHelpFilePath = _tcsdup(_T("mprsnap.hlp"));
//        IpAddrInit(AfxGetInstanceHandle(), 0, 0);
        IPAddrInit(AfxGetInstanceHandle());
//        InitCommonLibrary ();
    }

	return bRet;
}

//----------------------------------------------------------------------------
// Function:    MprUIFilterConfig
//
// Called to configure Filter for the transport interface.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprUIFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
	IN	LPCWSTR		pwsInterfaceName,
	IN  DWORD       dwTransportId,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

    DWORD dwErr = NO_ERROR;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO IPX filter config will pass in NULL for the interface name
	// to configure filters for Client Interface. Ignore this for now
	// and add code to deal with IPX Client interface config.

	if(pwsInterfaceName == NULL)
		return dwErr;

	switch ( dwTransportId )	{
	case PID_IP:
		dwErr = IpFilterConfig( pParent, 
								pwsMachineName,
								pwsInterfaceName,
								dwFilterType );
		break;
	case PID_IPX:
		dwErr = IpxFilterConfig( pParent, 
								 pwsMachineName,
								 pwsInterfaceName,
								 dwFilterType );
		break;
		
	default:
		dwErr = ERROR_INVALID_PARAMETER;
	}

	return dwErr;
}


HRESULT APIENTRY
MprUIFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
	IN  DWORD       dwTransportId,
	IN	DWORD		dwFilterType	// FILTER_INBOUND, FILTER_OUTBOUND
    ) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{

		if (pInfoBase == NULL)
			CORg(E_INVALIDARG);

		// TODO IPX filter config will pass in NULL for the interface name
		// to configure filters for Client Interface. Ignore this for now
		// and add code to deal with IPX Client interface config.
		
		switch ( dwTransportId )
		{
			case PID_IP:
				hr = IpFilterConfigInfoBase( hwndParent,
											 pInfoBase,
											 pRmIf,
											 dwFilterType );
				break;
			case PID_IPX:
				hr = IpxFilterConfigInfoBase( hwndParent,
											  pInfoBase,
											  pRmIf,
											  dwFilterType );
				break;
				
			default:
				hr = E_INVALIDARG;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\add.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    add.h
//
// History:
//  Abolade-Gbadegesin  Mar-15-1996 Created
//
// Contains declarations for the dialogs displayed to select items
// to be added to the router-configuration.
//============================================================================


#ifndef _ADD_H
#define _ADD_H

#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _RTRLIST_H
#include "rtrlist.h"	// for the CList classes
#endif


//----------------------------------------------------------------------------
// Class:       CRmAddInterface
//
// This dialog displays interfaces not yet added to the specified transport,
// allowing the user to select one to add.
//----------------------------------------------------------------------------

class CRmAddInterface : public CBaseDialog {
    
    public:
    
        CRmAddInterface(
            IRouterInfo*            pRouterInfo,
            IRtrMgrInfo*            pRmInfo,
            IRtrMgrInterfaceInfo**  ppRmInterfaceInfo,
			CWnd *					pParent
            ) : CBaseDialog(CRmAddInterface::IDD, pParent)
		{
			m_spRouterInfo.Set(pRouterInfo);
			m_spRtrMgrInfo.Set(pRmInfo);
			m_ppRtrMgrInterfaceInfo = ppRmInterfaceInfo;
//			SetHelpMap(m_dwHelpMap);
		}

        virtual ~CRmAddInterface( );
    
        //{{AFX_DATA(CRmAddInterface)
        enum { IDD = IDD_ADD };
        CListCtrl	                m_listCtrl;
        //}}AFX_DATA
    
    
        //{{AFX_VIRTUAL(CRmAddInterface)
        protected:
        virtual VOID                DoDataExchange(CDataExchange* pDX);
        //}}AFX_VIRTUAL
    
    protected:
		static DWORD				m_dwHelpMap[];
    
        CImageList                  m_imageList;
		SPIRouterInfo				m_spRouterInfo;
		SPIRtrMgrInfo				m_spRtrMgrInfo;

		// This is used to store the list of interfaces
		// that we have pointers to in our list box.  I could
		// keep AddRef'd pointers in the item data, but this
		// seems safer.
		PInterfaceInfoList			m_pIfList;

		// The return value is stored in here
		IRtrMgrInterfaceInfo **		m_ppRtrMgrInterfaceInfo;
    
        //{{AFX_MSG(CRmAddInterface)
        virtual BOOL                OnInitDialog();
        afx_msg VOID                OnDblclkListctrl(NMHDR* , LRESULT* );
        virtual VOID                OnOK();
        //}}AFX_MSG
    
        DECLARE_MESSAGE_MAP()
};






//----------------------------------------------------------------------------
// Class:       CAddRoutingProtocol
//
// This dialog displays routing-protocols for the specified transport,
// allowing the user to select a protocol to be added.
//----------------------------------------------------------------------------

class CAddRoutingProtocol : public CBaseDialog {
    
    public:

        CAddRoutingProtocol(
			IRouterInfo *			pRouter,
            IRtrMgrInfo*            pRmInfo,
            IRtrMgrProtocolInfo**   ppRmProtInfo,
            CWnd*                   pParent         = NULL
            ) : CBaseDialog(CAddRoutingProtocol::IDD, pParent)
			{
				m_spRouter.Set(pRouter);
				m_spRm.Set(pRmInfo);
				m_ppRmProt = ppRmProtInfo;
				// SetHelpMap(m_dwHelpMap);
			}

        virtual
        ~CAddRoutingProtocol( );
    
        //{{AFX_DATA(CAddRoutingProtocol)
        enum { IDD = IDD_ADD };
        CListCtrl	                m_listCtrl;
        //}}AFX_DATA
    

        //{{AFX_VIRTUAL(CAddRoutingProtocol)
        protected:
        virtual VOID                DoDataExchange(CDataExchange* pDX);
        //}}AFX_VIRTUAL
    
    protected:
		static DWORD				m_dwHelpMap[];
    
        CImageList                  m_imageList;
		SPIRouterInfo				m_spRouter;
		SPIRtrMgrInfo				m_spRm;
		IRtrMgrProtocolInfo	**		m_ppRmProt;
//        CPtrList                    m_pcbList;
    
        //{{AFX_MSG(CAddRoutingProtocol)
        afx_msg VOID                OnDblclkListctrl(NMHDR* , LRESULT* );
        virtual VOID                OnOK();
        virtual BOOL                OnInitDialog();
        //}}AFX_MSG

        DECLARE_MESSAGE_MAP()
};



//----------------------------------------------------------------------------
// Class:       CRpAddInterface
//
// This dialog displays interfaces not yet added to the specified protocol,
// allowing the user to select one to add.
//----------------------------------------------------------------------------

class CRpAddInterface : public CBaseDialog {
    
    public:
    
        CRpAddInterface(
            IRouterInfo*            pRouterInfo,
            IRtrMgrProtocolInfo*            pRmProtInfo,
            IRtrMgrProtocolInterfaceInfo**  ppRmProtInterfaceInfo,
            CWnd*                   pParent = NULL);

        virtual
        ~CRpAddInterface( );
    
        //{{AFX_DATA(CRpAddInterface)
        enum { IDD = IDD_ADD };
        CListCtrl	                m_listCtrl;
        //}}AFX_DATA
    
    
        //{{AFX_VIRTUAL(CRpAddInterface)
        protected:
        virtual VOID                DoDataExchange(CDataExchange* pDX);
        //}}AFX_VIRTUAL
    
 