    if ( ! pquestion )
    {
        //  reject empty queries

        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]: pQuestion == NULL\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //  DEVNOTE: alignment faults reading question type and class?

    pMsg->pQuestion = pquestion;
    INLINE_NTOHS( type, pquestion->QuestionType );
    pMsg->wQuestionType = type;
    pMsg->wTypeCurrent = type;
    pMsg->wOffsetCurrent = DNS_OFFSET_TO_QUESTION_NAME;
    pMsg->pCurrent = (PCHAR) (pquestion + 1);

    //
    //  Reject type zero. This type is used internally by the server, so 
    //  the debug server will throw asserts if it tries to process a legitimate
    //  query for type 0.
    //

    if ( !type )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]: query type is zero\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  reject non-internet class queries
    //

    qclass = pquestion->QuestionClass;
    if ( qclass != DNS_RCLASS_INTERNET  &&  qclass != DNS_RCLASS_ALL )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT_IMPLEMENTED]: "
            "Bad QCLASS in query\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  catch non-QUERY opcodes
    //      -> process UPDATE
    //      -> queue NOTIFY to secondary thread
    //      -> reject unsupported opcodes
    //

    STAT_INC( Query2Stats.TotalQueries );

    if ( pMsg->Head.Opcode != DNS_OPCODE_QUERY )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_UPDATE )
        {
            //
            //  Test global AllowUpdate flag.
            //

            if ( !SrvCfg_fAllowUpdate )
            {
                rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
                goto RejectIntact;
            }

            //
            //  Class MUST be class of zone (INET only).
            //

            if ( qclass != DNS_RCLASS_INTERNET )
            {
                DNS_PRINT(( "WARNING:  message at %p, non-INTERNET UPDATE\n" ));
                rejectRcode = DNS_RCODE_FORMAT_ERROR;
                goto RejectIntact;
            }

            //
            //  Conditional breakpoint based on sender IP. Also break if 
            //  the break list starts with 255.255.255.255.
            //

            #if DBG
            if ( SrvCfg_aipUpdateBreakList )
            {
                if ( SrvCfg_aipUpdateBreakList->AddrCount &&
                     ( DnsAddr_IsClear( &SrvCfg_aipUpdateBreakList->AddrArray[ 0 ]  ) ||
                       DnsAddrArray_ContainsAddr( 
                            SrvCfg_aipUpdateBreakList,
                            &pMsg->RemoteAddr,
                            DNSADDR_MATCH_IP ) ) )
                {
                    DNS_PRINT(( "HARD BREAK: " 
                        DNS_REGKEY_BREAK_ON_RECV_FROM
                        " %s\n",
                        DNSADDR_STRING( &pMsg->RemoteAddr ) ));
                    DebugBreak();
                }
            }
            #endif

            //
            //  Process update.
            //

            STAT_INC( Query2Stats.Update );
            Up_ProcessUpdate( pMsg );
            goto Done;
        }

        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            STAT_INC( Query2Stats.Notify );
            Xfr_QueueSoaCheckResponse( pMsg );
            goto Done;
        }

        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT IMPLEMENTED]: bad opcode in query\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  write question name into lookup name
    //

    if ( ! Name_ConvertPacketNameToLookupName(
                pMsg,
                pMsg->MessageBody,
                pMsg->pLooknameQuestion ) )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  Bad name\n",
            pMsg ));

        //  shouldn't get this far as caught when skipping question
        TEST_ASSERT( FALSE );
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    rejectRcode = Answer_ParseAndStripOpt( pMsg );
    if ( rejectRcode != DNS_RCODE_NOERROR )
    {
        rejectFlags = DNS_REJECT_DO_NOT_SUPPRESS;
        goto RejectIntact;
    }

    //
    //  TKEY negotiation.
    //
    //  DEVNOTE-DCR: 453633 - could eliminate secure queue and queuing if no secure zones
    //

    if ( type == DNS_TYPE_TKEY )
    {
        DNS_DEBUG( UPDATE, (
            "Queuing TKEY nego packet %p to SecureNego queue\n",
            pMsg ));
        STAT_INC( Query2Stats.TKeyNego );
        PQ_QueuePacketEx( g_SecureNegoQueue, pMsg, FALSE );
        goto Done;
    }

    STAT_INC( Query2Stats.Standard );
    Stat_IncrementQuery2Stats( type );

    //
    //  Zone transfer.
    //

    if ( type == DNS_TYPE_AXFR || type == DNS_TYPE_IXFR )
    {
        Xfr_TransferZone( pMsg );
        goto Done;
    }

    //
    //  for standard query MUST NOT have any RR sets beyond question
    //  note:  this MUST be after dispatch of IXFR which does
    //      have record in Authority section
    //  EDNS: up to one additional RR is allowed: it must be type OPT
    //

    if ( pMsg->Head.AnswerCount != 0 ||
         pMsg->Head.NameServerCount != 0 ||
         pMsg->Head.AdditionalCount > 1 )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  non-zero answer or\n"
            "    name server RR count or too many additional RRs\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  Is this question from this client already in the recursion queue?
    //  If so, silently drop this query. The has retried the query before
    //  the remote server has responded. If an answer is available the
    //  client will get it when we respond to the original query.
    //

    if ( PQ_IsQuestionAlreadyQueued( g_pRecursionQueue, pMsg, FALSE ) )
    {
        DNS_DEBUG( ANY, (
            "Request %p is a retry while original is in recursion\n",
            pMsg ));
        STAT_INC( RecurseStats.DiscardedDuplicateQueries );
        Packet_Free( pMsg );
        goto Done;
    }

    //
    //  setup response defaults
    //
    //  leave fixed flags to be set in Send_Response()
    //      - IsResponse         = 1
    //      - RecursionAvailable = 1
    //      - Reserved           = 0
    //
    //  may still use this Request buffer in recursive query, so
    //  that much less to reset
    //

    //  need to clear truncation flag
    //      should not be set, BUT if is set will hose us

    pMsg->Head.Truncation      = 0;

    //  secure query or EDNS may start to send other records

    pMsg->Head.AnswerCount     = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;

    //
    //  It would be nice to sanity check the end of question here, but
    //  the Win95 NBT resolver is broken and sends packets that exceed 
    //  the length of the actual DNS message.
    //  MSG_ASSERT( pMsg, pMsg->pCurrent == DNSMSG_END(pMsg) );
    //

    //
    //  set recursion available
    //
    //  fRecuseIfNecessary, indicates need to recurse when non-authoritive
    //      lookup failure occurs;  otherwise referral

    pMsg->Head.RecursionAvailable = (UCHAR) SrvCfg_fRecursionAvailable;
    pMsg->fRecurseIfNecessary = SrvCfg_fRecursionAvailable
                                    && pMsg->Head.RecursionDesired;

    //
    //  set message for query response
    //      - response flag
    //      - set/clear message info lookup flags
    //          (set for additional info lookup)
    //      - init addtional info
    //      - set to write answer records
    //

    pMsg->Head.IsResponse = TRUE;

    SET_MESSAGE_FOR_QUERY_RESPONSE( pMsg );

    INITIALIZE_ADDITIONAL( pMsg );

    SET_TO_WRITE_ANSWER_RECORDS( pMsg );

    pMsg->Opt.wOriginalQueryPayloadSize = pMsg->Opt.wUdpPayloadSize;

    Answer_Question( pMsg );
    goto Done;


RejectIntact:

    Reject_RequestIntact( pMsg, rejectRcode, rejectFlags );

Done:

    return;
}



VOID
FASTCALL
Answer_Question(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Answer the question.

    Note, this is separate from the function above, ONLY to provide an
    entry point for continuing to attempt answer after recursing on
    original query.

Arguments:

    pMsg - query to answer

Return Value:

    None

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pnodeCachePriority;
    PZONE_INFO      pzone;
    WORD            type = pMsg->wTypeCurrent;
    BOOL            attemptedPlugin = FALSE;

    DNS_DEBUG( LOOKUP, (
        "Answer_Question() for packet at %p\n",
        pMsg ));

    #ifdef DNSSRV_PLUGINS
    RetryQuery:
    #endif
    
    //
    //  Find closest node in database. 
    //

    pnode = Lookup_NodeForPacket(
                pMsg,
                pMsg->MessageBody,  // question name follows header
                0 );
    if ( !pMsg->pnodeClosest )
    {
        MSG_ASSERT( pMsg, FALSE );
        Reject_RequestIntact( pMsg, DNS_RCODE_FORMERR, 0 );
        return;
    }

    //
    //  DEVNOTE-DCR: 453667 - should save "closest" zone context
    //      (actual question zone or zone holding delegation)
    //

    pzone = pMsg->pzoneCurrent;

    IF_DEBUG( LOOKUP )
    {
        if ( !pnode )
        {
            DnsDebugLock();
            Dbg_MessageNameEx(
                "Node for ",
                (PCHAR)pMsg->MessageBody,
                pMsg,
                NULL,
                " NOT in database\n"
                );
            Dbg_NodeName(
                "Closest node found",
                pMsg->pnodeClosest,
                "\n" );
            DnsDebugUnlock();
        }
        IF_DEBUG( LOOKUP2 )
        {
            if ( pzone )
            {
                Dbg_Zone(
                    "Lookup name in authoritative zone ",
                    pzone );
            }
            else
            {
                DNS_PRINT(( "Lookup name in non-authoriative zone\n" ));
            }
        }
    }

    pMsg->pNodeQuestion = pnode;
    pMsg->pNodeQuestionClosest = pMsg->pnodeClosest;

    IF_DNSLOG( LOOKUP )
    {
        PCHAR       pszpacket = NULL;
        PCHAR       psznode = NULL;
        PCHAR       pszclosestnode = NULL;
        
        DNSLOG( LOOKUP, (
            "Query name %s\n"
            LOG_INDENT "zone          %s (type %d)\n"
            LOG_INDENT "node          %s (%p)\n"
            LOG_INDENT "closest node  %s (%p)\n",
            pszpacket = Log_FormatPacketName(
                            pMsg,
                            pMsg->MessageBody ),
            pzone ? pzone->pszZoneName : "cache",
            pzone ? pzone->fZoneType : 0,
            psznode = Log_FormatNodeName( pnode ),
            pnode,
            pszclosestnode = Log_FormatNodeName( pnode ),
            pMsg->pnodeClosest ));
       FREE_HEAP( pszpacket );
       FREE_HEAP( psznode );
       FREE_HEAP( pszclosestnode );
    }

    //
    //  Set Authority
    //
    //  If the AnswerCount > 1, the authority bit has already been
    //  set or reset as appropriate for our authority to answer the
    //  original question.
    //
    //  The authority bit refers only to the first answer - which
    //  should be the one that most directly answers the question.
    //

    if ( pMsg->Head.AnswerCount == 0 )
    {
        pMsg->Head.Authoritative =
            pzone && !IS_ZONE_STUB( pzone ) ?
            TRUE : FALSE;
    }

    //
    //  Zone expired or down for update.
    //  Do not attempt answer, MUST wait until can contact master.
    //
    //  DEVNOTE 000109: switching back to REFUSED. (REFUSED caused trouble 
    //      with old queries -- it was returned and query did not continue, 
    //      this is fixed but for a while use SERVER_FAILURE.)
    //      Note:  BIND sends non-auth response and only REFUSES the
    //              AXFR request itself
    //

    if ( pzone )
    {
        if ( IS_ZONE_INACTIVE( pzone ) )
        {
            if ( IS_ZONE_STUB( pzone ) )
            {
                //
                //  Inactive stub zones are treated as if they were not
                //  present locally. 
                //

                DNSLOG( LOOKUP, (
                    "Ignoring inactive stub zone %s\n",
                    pzone->pszZoneName ));
                pzone = pMsg->pzoneCurrent = NULL;
                pnode = pMsg->pNodeQuestion = pMsg->pNodeQuestionClosest = NULL;
                pMsg->pnodeClosest = DATABASE_CACHE_TREE;
            }
            else
            {
                DNSLOG( LOOKUP, (
                    "Zone %s not active - query refused\n",
                    pzone->pszZoneName ));
                DNS_DEBUG_ZONEFLAGS( LOOKUP, pzone, "zone inactive" );
                Reject_Request(
                    pMsg,
                    DNS_RCODE_REFUSED,      //  DNS_RCODE_SERVER_FAILURE,
                    0 );
                return;
            }
        }
    }

    //
    //  Not authoritative for ALL queries unless the node's type ALL
    //  TTL has not yet expired.
    //

    else if ( type == DNS_TYPE_ALL )
    {
        if ( ( !pMsg->pRecurseMsg ||
               !pMsg->fQuestionCompleted ) &&
              ( pnode &&
                ( pnode->dwTypeAllTtl == 0 || 
                  pMsg->dwQueryTime >= pnode->dwTypeAllTtl ) ) )
        {
            pnode = NULL;
        }
    }

    //
    //  found node for query name in database?
    //
    //  save question name compression info
    //
    //  answer from database
    //      - find answer or error and send
    //          - in function recursion to handle any additional lookups
    //          - write referral, if no data, not recursing
    //
    //  or async lookup
    //      - recurse
    //      - WINS lookup
    //      - NBSTAT lookup
    //

    if ( pnode )
    {
        Name_SaveCompressionForLookupName(
            pMsg,
            pMsg->pLooknameQuestion,
            pnode );
        Answer_QuestionFromDatabase(
            pMsg,
            pnode,
            DNS_OFFSET_TO_QUESTION_NAME,
            type );
        return;
    }

    //
    //  Authoritative but node NOT found
    //      - try WINS, NBSTAT, wildcard lookup as appropriate
    //      - everything fails, return NAME_ERROR
    //
    //  For not-auth zones, we are actually not authoritative, so do not
    //  enter this if(). Instead we want to continue on and
    //  Recurse_Question().
    //

    if ( pzone && !IS_ZONE_NOTAUTH( pzone ) )
    {
        //
        //  WINS lookup
        //      - in WINS zone
        //      - A lookup or ALL records lookup
        //

        if ( IS_ZONE_WINS(pzone) &&
                     (type == DNS_TYPE_A ||
                      type == DNS_TYPE_ALL ) )
        {
            ASSERT( pMsg->fQuestionRecursed == FALSE );

            if ( Wins_MakeWinsRequest(
                    pMsg,
                    pzone,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    NULL ) )
            {
                return;
            }
        }

        //
        //  NetBIOS reverse lookup
        //

        else if ( IS_ZONE_NBSTAT(pzone)  &&
                  ( type == DNS_TYPE_PTR ||
                    type == DNS_TYPE_ALL ) )
        {
            if ( Nbstat_MakeRequest( pMsg, pzone ) )
            {
                return;
            }
        }

        //
        //  Wildcard lookup?
        //      - RR not found at node
        //      - in authoritative zone
        //
        //  no longer distinguish types, as always need to check for wildcard to
        //  make name-error\auth-empty determination
        //
        //  if successful, just return, lookup is completed in function
        //

        else if ( Answer_QuestionWithWildcard(
                    pMsg,
                    pMsg->pnodeClosest,
                    type,
                    DNS_OFFSET_TO_QUESTION_NAME ) )
        {
            return;
        }

        //
        //  authoritative and node not found => NAME_ERROR
        //
        //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
        //  based on whether other data may be available for other types from
        //      - WINS\WINSR
        //      - wildcard
        //

        ASSERT( pMsg->pzoneCurrent == pzone );
        Send_NameError( pMsg );
        return;
    }

    //
    //  NOT authoritative -- recursion or referral.
    //
    //  If we were authoritative for the question, we would have
    //  returned from this function by name, and we also must not
    //  have found any answers in our cache.  Therefore, try recursion.
    //

    DNS_DEBUG( LOOKUP, (
        "Encountered non-authoritative node with no matching RRs\n" ));

    pMsg->pnodeCurrent = NULL;
    
    #ifdef DNSSRV_PLUGINS

    //
    //  Consult DNS plugin. If success, retry the query.
    //

    if ( !attemptedPlugin && g_pfnPluginDnsQuery )
    {
        attemptedPlugin = TRUE;
        
        if ( Plugin_DnsQuery(
                pMsg,
                DNSMSG_PTR_FOR_OFFSET(
                    pMsg,
                    DNSMSG_QUESTION_NAME_OFFSET ) ) == ERROR_SUCCESS )
        {
            goto RetryQuery;
        }
    }

    #endif

    //
    //  No data so recurse.
    //
    
    Recurse_Question(
        pMsg,
        pMsg->pnodeClosest );
}



VOID
FASTCALL
Answer_QuestionFromDatabase(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset,
    IN      WORD            wType
    )
/*++

Routine Description:

    Answer the from database information.

Arguments:

    pMsg - query to answer

    pNode - node in database question is for

    wOffsetName - offset in packet to name of node

    wType - question type

    fDone - query has been completed, send packet

Return Value:

    TRUE, if answered question or attempting async lookup of answer.
    FALSE, if NO answer found.

--*/
{
    WORD                cRRWritten;
    PZONE_INFO          pzone = NULL;
    PADDITIONAL_INFO    pAdditional = &pMsg->Additional;
    PCHAR               pcurrent;
    BOOL                attemptedPlugin = FALSE;
#if DBG
    INT                 cCnameLookupFailures = 0;
#endif

    CLIENT_ASSERT( pMsg->wTypeCurrent );

    DNS_DEBUG( LOOKUP, (
        "Answer_QuestionFromDatabase() for query at %p\n"
        "    node label   = %s (%p)\n"
        "    name offset  = 0x%04hx\n"
        "    query type   = 0x%04hx\n",
        pMsg,
        pNode ? pNode->szLabel : NULL,
        pNode,
        wNameOffset,
        wType ));

    //
    //  EDNS: Set the EDNS OPT flag and adjust the buffer end pointer
    //  based on the payload size included in the original query. If there
    //  was no OPT in the original query set the buffer size to the
    //  standard UDP length. For TCP queries, set the buffer size to max.
    //

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );
    if ( pMsg->fTcp )
    {
        pMsg->BufferLength = pMsg->MaxBufferLength;
    }
    else
    {
        pMsg->BufferLength =
            ( pMsg->Opt.wUdpPayloadSize > DNS_RFC_MAX_UDP_PACKET_LENGTH ) ?
            min( SrvCfg_dwMaxUdpPacketSize, pMsg->Opt.wUdpPayloadSize ) :
            DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    pMsg->pBufferEnd = DNSMSG_PTR_FOR_OFFSET( pMsg, pMsg->BufferLength );
    ASSERT( pMsg->pCurrent < pMsg->pBufferEnd );

    //
    //  Loop until all RR written for query
    //

    while ( 1 )
    {
        //
        //  if no node, lookup node
        //

        if ( !pNode )
        {
            if ( wNameOffset )
            {
                pNode = Lookup_NodeForPacket(
                            pMsg,
                            DNSMSG_PTR_FOR_OFFSET( pMsg, wNameOffset ),
                            0 );                    //  lookup flags
            }
            if ( !pNode && IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) )
            {
                goto Additional;
            }
            DNS_DEBUG( ANY, (
                "ERROR:  no pNode and not doing additional lookup!\n" ));
            ASSERT( FALSE );
            goto Done;
        }

        DNS_DEBUG( LOOKUP2, (
            "Answer loop pnode %s (%p)\n"
            "    section %d\n",
            pNode->szLabel, pNode,
            pMsg->Section ));

        //
        //  Name Error cached for node?
        //      - if timed out, clear and continue
        //      - if still valid (not timed out)
        //          -> if answer for question, send NAME_ERROR
        //          -> otherwise, continue with any additional records
        //
        //  Note, we test NOEXIST flag again within lock, before timeout test
        //

        if ( IS_NOEXIST_NODE( pNode ) )
        {
            DNS_STATUS  status;
            
            DNSLOG( LOOKUP, (
                "Found cached name error at node %p\n",
                pNode ));
                
            status = writeCachedNameErrorNodeToPacketAndSend( pMsg, pNode );
            if ( status == ERROR_SUCCESS )
            {
                return;
            }
            else if ( status == DNS_ERROR_RECORD_TIMED_OUT )
            {
                continue;
            }
            else
            {
                ASSERT( DNS_INFO_NO_RECORDS );
                goto FinishedAnswer;
            }
        }

        //
        //  CNAME at question?
        //
        //  If question node is alias, set to write CNAME and set flag
        //  so can do original lookup at CNAME node.
        //

        if ( IS_CNAME_NODE(pNode)  &&
             IS_CNAME_REPLACEABLE_TYPE(wType)  &&
             IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
        {
            //  CNAME loop check
            //  should have caught on loading records

            if ( pMsg->cCnameAnswerCount >= CNAME_CHAIN_LIMIT )
            {
                DNS_PRINT((
                    "ERROR:  Detected CNAME loop answering query at %p\n"
                    "    aborting lookup and sending response\n",
                    pMsg ));
                break;
            }
            pMsg->fReplaceCname = TRUE;
            wType = DNS_TYPE_CNAME;
        }

        //
        //  lookup current question
        //      - A records special case
        //      - for non-A allow for additional section processsing
        //
        //  If this zone has any DNSSEC records, we cannot use the A
        //  record special case, since we may have to include SIG and
        //  KEY RRs in the response.
        //
        //  If the name offset is beyond standard DNS compression,
        //  do not use the A record function. Instead call the general
        //  record writing function.
        //

        pcurrent = pMsg->pCurrent;

        if ( wType == DNS_TYPE_A &&
             wNameOffset < DNSSRV_MAX_COMPRESSION_OFFSET &&
             ( !pNode->pZone ||
               !IS_ZONE_DNSSEC( ( PZONE_INFO ) pNode->pZone ) ) )
        {
            IF_DNSLOG( LOOKUP )
            {
                PCHAR       psznode = NULL;

                DNSLOG( LOOKUP, (
                    "Writing A records for node %s (%p)\n"
                    LOG_INDENT "to %s section of packet %p\n",
                    psznode = Log_FormatNodeName( pNode ),
                    pNode,
                    Log_CurrentSection( pMsg ),
                    pMsg ));
                FREE_HEAP( psznode );
            }

            cRRWritten = Wire_WriteAddressRecords(
                                pMsg,
                                pNode,
                                wNameOffset );
        }
        else
        {
            IF_DNSLOG( LOOKUP )
            {
                PCHAR       psznode = NULL;

                DNSLOG( LOOKUP, (
                    "Writing %s records for node %s (%p)\n"
                    LOG_INDENT "to %s section of packet %p\n",
                    Dns_RecordStringForType( wType ),
                    psznode = Log_FormatNodeName( pNode ),
                    pNode,
                    Log_CurrentSection( pMsg ),
                    pMsg ));
                FREE_HEAP( psznode );
            }

            cRRWritten = Wire_WriteRecordsAtNodeToMessage(
                                pMsg,
                                pNode,
                                wType,
                                wNameOffset,
                                DNSSEC_ALLOW_INCLUDE_ALL );

            //
            //  CNAME lookup
            //      - reset question type to original
            //      - if successful, restart query at new node
            //      - update zone info current;  will need to determine
            //          need for WINS lookup or recursion
            //      - clear previous recursion flag, to indicate
            //          any further recursion is for new name
            //
            //  it is possible to fail CNAME lookup at CNAME node,
            //  if CNAME timed out between node test and write attempt
            //  simply retry -- if working properly can not loop;
            //  debug code to verify we don't have hole here
            //

            if ( pMsg->fReplaceCname )
            {
                pMsg->cCnameAnswerCount++;
                wType = pMsg->wQuestionType;

                if ( ! cRRWritten )
                {
#if DBG
                    cCnameLookupFailures++;
                    DNS_DEBUG( LOOKUP, (
                        "Cname lookup failure %d on query at %p\n",
                        cCnameLookupFailures,
                        pMsg ));
                    ASSERT( cCnameLookupFailures == 1 );
#endif
                    pMsg->fReplaceCname = FALSE;
                    continue;
                }

                //  if allow multiple CNAMEs, then these ASSERTs are invalid
                //ASSERT( cRRWritten == 1 );
                //ASSERT( pAdditional->cCount == 1 );
                ASSERT( pAdditional->iIndex == 0 );

                //  recover node from additional data
                //  note:  message will be set for additional data and A lookup
                //      must reset to question section and question type

                DNS_ADDITIONAL_SET_ONLY_WANT_A( pAdditional );
                pNode = getNextAdditionalNode( pMsg );

                pAdditional->cCount = 0;
                pAdditional->iIndex = 0;
                pMsg->fReplaceCname = FALSE;
                SET_TO_WRITE_ANSWER_RECORDS(pMsg);

                if ( pNode )
                {
                    wNameOffset = pMsg->wOffsetCurrent;
                    pMsg->wTypeCurrent = wType;
                    continue;
                }

                ASSERT( !pMsg->pnodeCache &&
                        !pMsg->pnodeCacheClosest &&
                        pMsg->pzoneCurrent );
                DNS_DEBUG( LOOKUP, (
                    "WARNING:  CNAME leads to non-existant name in auth zone!\n" ));
                break;
            }
        }

        //
        //  end of packet -- truncation set during RR write
        //

        if ( pMsg->Head.Truncation )
        {
            DNS_DEBUG( LOOKUP, (
                "Truncation writing Answer for packet at %p\n"
                "    %d records written\n",
                pMsg,
                pMsg->Head.AnswerCount ));

            //
            //  UDP
            //      - if writing answer or referral send
            //      - if writing additional records AND have already written
            //          SOME additional records, then rollback to last write
            //          clear truncation and send
            //
            //      Example:
            //          Answer
            //              MX 10 foo.com
            //          Additional
            //              foo.com A => 30 A records
            //          In this case we leave in the write, as if we take it
            //          out a client has NO additional data and MUST retry;
            //          it's likely even direct requery would cause truncation
            //          also, bringing up TCP in server\server case
            //
            //      Example
            //          Answer
            //              MX 10 foo.com
            //              MX 10 bar.com
            //          Additional
            //              foo.com A  1.1.1.1
            //              bar.com A => 30 A records
            //          In this case we kill the write and truncation bit;
            //          this saves a TCP session in the server-server case
            //          and costs little as the client already has an additional
            //          record set to use;
            //
            //      DEVONE: need better truncation handling
            //
            //      Note, it may be reasonable to kill this in the future.
            //      Currently our server ALWAYS starts a TCP session on truncated
            //      packet for simplicity in avoiding caching incomplete response.
            //      This should be fixed, so it caches what's available, AND if
            //      that is sufficient to answer client query.  (As in example #2)
            //      there's no reason to recurse.  Furthermore, if packet can
            //      just be cleanly forwarded, there's no reason to recurse period.
            //

            if ( !pMsg->fTcp )
            {
                if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) &&
                    CURRENT_RR_SECTION_COUNT( pMsg ) > cRRWritten )
                {
                    pMsg->pCurrent = pcurrent;
                    CURRENT_RR_SECTION_COUNT( pMsg ) -= cRRWritten;
                    pMsg->Head.Truncation = FALSE;
                }
                break;
            }

            //
            //  TCP
            //      - rollback last RR set write, reallocate and continue
            //
            //  DEVNOTE-DCR: 453783 - realloc currently a mess -- just SEND
            //      maybe should roll back -- again based on
            //      where we are in packet (as above) -- then send
            //

            else
            {
                DNS_PRINT((
                    "WARNING:  truncating in TCP packet (%p)!\n"
                    "    sending packet\n",
                    pMsg ));

                goto Done;
#if 0
                pMsg->Head.Truncation = FALSE;
                CURRENT_RR_SECTION_COUNT( pMsg ) -= cRRWritten;
                pMsg = Tcp_ReallocateMessage(
                            pMsg,
                            ( WORD ) DNS_TCP_REALLOC_PACKET_LENGTH );
                if ( !pMsg )
                {
                    //  reallocator sends SERVER_FAILURE message
                    return;
                }
                continue;
#endif
            }
        }

        //
        //  handy to have zone for this node
        //

        pzone = NULL;
        if ( IS_AUTH_NODE( pNode ) )
        {
            pzone = pNode->pZone;
        }

        //
        //  WINS lookup ?
        //
        //      - asked for A record or ALL records
        //      - didn't find A record
        //      - in authoritive zone configured for WINS
        //
        //  need this lookup here so can
        //      - ALL records query (where node may exist and other records
        //          may be successfully written)
        //      - additional records through WINS
        //
        //  note, WINS request function saves async parameters
        //

        if ( pMsg->fWins  &&  pzone  &&  IS_ZONE_WINS(pzone) )
        {
            ASSERT( wType == DNS_TYPE_A || wType == DNS_TYPE_ALL );
            ASSERT( pzone->pWinsRR );
            ASSERT( pMsg->fQuestionRecursed == FALSE );

            if ( Wins_MakeWinsRequest(
                    pMsg,
                    ( PZONE_INFO ) pzone,
                    wNameOffset,
                    pNode ) )
            {
                return;
            }
        }

        //
        //  no records written
        //      - recurse?
        //      - referral?
        //      - nbstat?
        //      - wildcard?
        //
        //  if all fail, just drop down for authoritative empty response
        //

        if ( !cRRWritten )
        {
            #ifdef DNSSRV_PLUGINS

            //
            //  Consult DNS plugin. If success, retry the query.
            //

            if ( !attemptedPlugin && g_pfnPluginDnsQuery )
            {
                attemptedPlugin = TRUE;
                
                if ( Plugin_DnsQuery(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET(
                            pMsg,
                            DNSMSG_QUESTION_NAME_OFFSET ) ) == ERROR_SUCCESS )
                {
                    continue;
                }
            }

            #endif

            //
            //  recursion or referral -- if NOT AUTHORITATIVE
            //

            if ( !pzone )
            {
                //
                //  recursion
                //
                //  do NOT recurse when
                //      -> already recursed this question and received
                //      authoritative (or forwarders) answer
                //      -> are writing additional records AND
                //          - have already written additional records
                //          (client made not need any more info)
                //          - have not yet checked all additional records in cache
                //
                //  just drop through to continue doing any additional work
                //      necessary
                //

                if ( pMsg->fRecurseIfNecessary )
                {
                    ASSERT( !IS_SET_TO_WRITE_AUTHORITY_RECORDS( pMsg ) );

                    if ( ( !pMsg->fQuestionRecursed
                            || !pMsg->fQuestionCompleted ) &&
                         ( !IS_SET_TO_WRITE_ADDITIONAL_RECORDS( pMsg )
                            || pMsg->Additional.iRecurseIndex > 0
                            || pMsg->Head.AdditionalCount == 0 ) &&
                         !IS_NODE_FORCE_AUTH( pNode ) )
                    {
                        pMsg->pnodeCurrent = pNode;
                        pMsg->wOffsetCurrent = wNameOffset;
                        pMsg->wTypeCurrent = wType;

                        Recurse_Question(
                            pMsg,
                            pNode );
                        return;
                    }
                }

                //
                //  referral
                //
                //  only referral for question answer
                //  don't issue referrals on referrals
                //      - can't find NS or A
                //      - can't find additional data
                //      - can't find CNAME chain element
                //

                else if ( IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) &&
                          pMsg->Head.AnswerCount == 0 )
                {
                    Recurse_WriteReferral(
                        pMsg,
                        pNode );
                    return;
                }

            }   //  end non-authoritative

            //
            //  authoritative
            //      - nbstat lookup
            //      - wildcard lookup
            //      - fail to authoritative empty response
            //

            else
            {
                //
                //  nbstat lookup
                //

                if ( IS_ZONE_NBSTAT( pzone ) &&
                     ( wType == DNS_TYPE_PTR ||
                       wType == DNS_TYPE_ALL ) )
                {
                    if ( Nbstat_MakeRequest( pMsg, pzone ) )
                    {
                        return;
                    }
                }

                //
                //  wildcard lookup
                //      - RR not found at node
                //      - in authoritative zone
                //
                //  do NOT bother with distinguishing types, as need to
                //  do wildcard lookup before we can send NAME_ERROR \ EMPTY
                //
                //  some folks are wildcarding A records, so might as well
                //  always do quick check
                //
                //  if successful, just return, lookup is completed in function
                //
                //  pNode == pMsg->pnodeCurrent indicates wildcard lookup
                //      failed on existing node
                //

                pMsg->pnodeCurrent = pNode;

                if ( Answer_QuestionWithWildcard(
                        pMsg,
                        pNode,
                        wType,
                        wNameOffset ) )
                {
                    return;
                }

            }   //  end authoritative

        }   //  end no records written


FinishedAnswer:

        //
        //  authority records to write?
        //

        if ( pzone && IS_SET_TO_WRITE_ANSWER_RECORDS( pMsg ) )
        {
            //
            //  if no data, send NAME_ERROR or AUTH_EMPTY response
            //
            //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
            //  based on whether other data may be available for other types from
            //      - WINS\WINSR
            //      - wildcard
            //

            if ( pMsg->Head.AnswerCount == 0 )
            {
                ASSERT( pMsg->pzoneCurrent == pzone );
                Send_NameError( pMsg );
                return;
            }

            //
            //  for BIND compat can put NS in all responses
            //  note we turn Additional processing back on as may have been
            //      suppressed during type ALL query
            //

            if ( SrvCfg_fWriteAuthority )
            {
                SET_TO_WRITE_AUTHORITY_RECORDS(pMsg);
                pNode = pzone->pZoneRoot;
                wType = DNS_TYPE_NS;
                wNameOffset = 0;
                pMsg->fDoAdditional = TRUE;

                DNS_DEBUG( WRITE2, (
                    "Writing authority records to msg at %p\n",
                    pMsg ));
                continue;
            }
        }
        else if ( pNode &&
                  IS_NODE_FORCE_AUTH( pNode ) &&
                  pMsg->Head.AnswerCount == 0 )
        {
            //
            //  This node is FORCE_AUTH so we want an empty auth response.
            //
            
            SET_TO_WRITE_AUTHORITY_RECORDS( pMsg );
            pNode = pzone ? pzone->pZoneRoot : g_pRootHintsZone->pZoneRoot;
            wType = DNS_TYPE_SOA;
            wNameOffset = 0;
            pMsg->fRecurseIfNecessary = FALSE;
            continue;
        }

Additional:

        //
        //  additional records to write?
        //
        //      - also clear previous recursion flag, to indicate
        //          any further recursion is for new question
        //

        pNode = getNextAdditionalNode( pMsg );
        if ( pNode )
        {
            wNameOffset = pMsg->wOffsetCurrent;
            wType = pMsg->wTypeCurrent;
            continue;
        }

        //
        //  no more records -- send result
        //

        break;
    }

Done:

    //
    //  Send response
    //

    Send_QueryResponse( pMsg );
}



PDB_NODE
getNextAdditionalNode(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Find next additional data node.

Arguments:

    pMsg -- ptr to query

    dwFlags -- flags modifying "getnext" behavior

Return Value:

    Ptr to node, if successful.
    NULL otherwise.

--*/
{
    PADDITIONAL_INFO    padditional;
    PDB_NODE            pnode;
    DWORD               i;
    WORD                offset;
    DWORD               lookupFlags = LOOKUP_WINS_ZONE_CREATE;
    BOOL                frecurseAdditional = FALSE;
    BOOL                attemptedPlugin = FALSE;

    DNS_DEBUG( LOOKUP, (
        "getNextAdditionalNode() for query at %p, flags %08X\n",
        pMsg,
        pMsg->Additional.dwStateFlags ));
    DNS_DEBUG( LOOKUP2, (
        "getNextAdditionalNode() for query at %p\n",
        "    additional count     %d\n"
        "    additional index     %d\n"
        "    add recurse index    %d\n",
        pMsg,
        pMsg->Additional.cCount,
        pMsg->Additional.iIndex,
        pMsg->Additional.iRecurseIndex ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  additional records to write?
    //
   
    padditional = &pMsg->Additional;
    i = padditional->iIndex;

    //
    //  cache node creation?
    //      - never force creation in authoritative zones
    //      - but do force in cache when would recurse for the name
    //          if it wasn't there
    //      => CNAME chasing for answer
    //      => additional after exhausted all direct lookup
    //      (see comment below)
    //
    //  DEVNOTE:  can remove this when Answer_QuestionFromDatabase loop
    //      runs cleanly (drops through to recursion) with no pNode
    //
    //  If we are replacing a CNAME, we must add the WINS flag so that if
    //  there is currently no data for this node we will force the node's
    //  creation. This will only have an effect if the node is in a zone
    //  that is WINS-enabled.
    //

    if ( pMsg->fReplaceCname )
    {
        lookupFlags |= LOOKUP_CACHE_CREATE;
    }
    else if ( padditional->iRecurseIndex > 0 )
    {
        frecurseAdditional = TRUE;
        i = padditional->iRecurseIndex;
        lookupFlags |= LOOKUP_CACHE_CREATE;
    }

    //
    //  If we have already looped through all additional requests AND
    //  have written out at least one additional record but have NOT
    //  written out any additional A records, when restart the additional
    //  loop, this time looking only for A records. This is for DNSSEC,
    //  when we may have found local a KEY record to put in the ADD
    //  section, but we will want to include at least one A record
    //  (recursing if necessary).
    //

    if ( padditional->cCount == i &&
        pMsg->Head.AdditionalCount &&
        !DNS_ADDITIONAL_WROTE_A( padditional ) )
    {
        DNS_ADDITIONAL_SET_ONLY_WANT_A( padditional );
        i = 0;
        padditional->iIndex = ( WORD ) i;
        lookupFlags = LOOKUP_WINS_ZONE_CREATE | LOOKUP_CACHE_CREATE;
        frecurseAdditional = TRUE;

        DNS_DEBUG( LOOKUP, (
            "found some additional data to write in database for pMsg=%p\n"
            "    but no A records so re-checking for A RRs with recursive lookup\n",
            pMsg ));
    }

    //
    //  loop through until find next additional node that exists
    //      and hence potentially has some data
    //
    //  DEVNOTE:  if forcing some additional data write, then on complete
    //      failure, will need to restart forcing node CREATE
    //

    while ( padditional->cCount > i )
    {
        //
        //  Are we set to only get A records?
        //

        if ( DNS_ADDITIONAL_ONLY_WANT_A( padditional ) &&
            padditional->wTypeArray[ i ] != DNS_TYPE_A )
        {
            ++i;
            continue;
        }

        pMsg->wTypeCurrent = padditional->wTypeArray[ i ];
        offset = padditional->wOffsetArray[ i++ ];

        DNS_DEBUG( LOOKUP2, (
            "Chasing additional data for pMsg=%p at offset %d for type %d\n",
            pMsg,
            offset,
            pMsg->wTypeCurrent ));

        ASSERT( offset > 0 && offset < DNSMSG_CURRENT_OFFSET(pMsg) );

        if ( !( padditional->dwStateFlags & DNS_ADDSTATE_NOT_ADDITIONAL ) )
        {
            SET_TO_WRITE_ADDITIONAL_RECORDS( pMsg );
        }
        
        RetryQuery:

        pnode = Lookup_NodeForPacket(
                    pMsg,
                    DNSMSG_PTR_FOR_OFFSET( pMsg, offset ),
                    lookupFlags );
        if ( pnode )
        {
            pMsg->wOffsetCurrent = offset;

            if ( frecurseAdditional )
            {
                padditional->iRecurseIndex = i;
            }
            else
            {
                padditional->iIndex = i;
            }
            pMsg->fQuestionRecursed = FALSE;
            pMsg->fQuestionCompleted = FALSE;

            if ( pMsg->wTypeCurrent == DNS_TYPE_A )
            {
                DNS_ADDITIONAL_SET_WROTE_A( padditional );
            }
            return pnode;
        }
        else
        {
            #ifdef DNSSRV_PLUGINS

            //
            //  Consult DNS plugin. If success, retry the query.
            //

            if ( !attemptedPlugin && g_pfnPluginDnsQuery )
            {
                attemptedPlugin = TRUE;
                
                if ( Plugin_DnsQuery(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET( pMsg, offset ) ) == ERROR_SUCCESS )
                {
                    goto RetryQuery;
                }
            }

            #endif
        }

        DNS_DEBUG( LOOKUP2, (
            "Additional data name for pMsg=%p offset=%d, not found\n",
            pMsg,
            offset ));

        //
        //  if recursion is desired, then try to get at least ONE
        //      additional A record
        //
        //  so if we've:
        //      - exhausted additional list
        //      - in additional pass, not CNAME
        //      - haven't written ANY additional records
        //      - haven't already retried all additional names
        //      - and are set to recurse
        //  => then retry additional names allowing recursion
        //
        //  We do not want any non-A additional records after this point,
        //  recursion is only allowed for A additional records.
        //

        if ( padditional->cCount == i &&
             ! pMsg->fReplaceCname &&
             pMsg->Head.AdditionalCount == 0 &&
             ! frecurseAdditional &&
             pMsg->fRecurseIfNecessary )
        {
            DNS_ADDITIONAL_SET_ONLY_WANT_A( padditional );
            i = 0;
            padditional->iIndex = (WORD) i;
            lookupFlags = LOOKUP_WINS_ZONE_CREATE | LOOKUP_CACHE_CREATE;
            frecurseAdditional = TRUE;

            DNS_DEBUG( LOOKUP, (
                "Found NO additional data to write in database for pMsg=%p\n"
                "    re-checking additional for recursive lookup\n",
                pMsg ));
        }
        continue;
    }

    padditional->iIndex = (WORD) i;

    DNS_DEBUG( LOOKUP, (
        "No more additional data for query at %p\n"
        "    final index = %d\n",
        pMsg,
        i ));

    return( NULL );
}



VOID
Answer_ContinueNextLookupForQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Continue with next lookup to answer query.

    Use this to move on to NEXT lookup to complete query.
        - after get NAME_ERROR or other failure to write current lookup
        - after successful direct write of current lookup to packet
            (as currently used in WINS)

Arguments:

    pMsg -- ptr to query timed out

Return Value:

    None.

--*/
{
    PDB_NODE    pnode;

    DNS_DEBUG( LOOKUP, (
        "Answer_ContinueWithNextLookup() for query at %p\n",
        pMsg ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  additional records to write?
    //

    pnode = getNextAdditionalNode( pMsg );
    if ( pnode )
    {
        Answer_QuestionFromDatabase(
            pMsg,
            pnode,
            pMsg->wOffsetCurrent,
            pMsg->wTypeCurrent );
        return;
    }

    //
    //  otherwise do final send
    //

    Send_QueryResponse( pMsg );
}



VOID
Answer_ContinueCurrentLookupForQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Continue with current lookup to answer query.

    Use this to write result after recursing query or doing WINS lookup.

Arguments:

    pMsg -- ptr to query timed out

Return Value:

    None.

--*/
{
    DNS_DEBUG( LOOKUP, (
        "Answer_ContinueCurrentLookup() for query at %p\n",
        pMsg ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    STAT_INC( RecurseStats.ContinueCurrentLookup );

    //
    //  If the current node is in a forwarder zone, clear the current 
    //  node in case data has arrived in the cache that could satisfy
    //  the query. This triggers another cache search. 
    //

    if ( pMsg->pnodeCurrent )
    {
        PZONE_INFO  pzone = pMsg->pnodeCurrent->pZone;

        if ( pzone && ( IS_ZONE_FORWARDER( pzone ) || IS_ZONE_STUB( pzone ) ) )
        {
            pMsg->pnodeCurrent = NULL;
        }
    }

    //
    //  if node for query, restart attempt to write records for query
    //      - if previous response completed query (answer or authoritative empty)
    //      then answer question
    //      - if question not completed, then have delegation, restart recursion
    //      at current question node
    //

    if ( pMsg->pnodeCurrent )
    {
        ASSERT( pMsg->wOffsetCurrent );
        ASSERT( pMsg->wTypeCurrent );

        if ( !pMsg->fQuestionCompleted )
        {
            STAT_INC( RecurseStats.ContinueCurrentRecursion );

            Recurse_Question(
                pMsg,
                pMsg->pnodeCurrent );
            return;
        }

        Answer_QuestionFromDatabase(
                pMsg,
                pMsg->pnodeCurrent,
                pMsg->wOffsetCurrent,
                pMsg->wTypeCurrent );
    }

    //  original question name NOT found, in database, restart at lookup

    else
    {
        Answer_Question( pMsg );
    }
}



BOOL
Answer_QuestionWithWildcard(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wOffset
    )
/*++

Routine Description:

    Write response using wildcard name\records.

Arguments:

    pMsg - Info for message to write to.

    pNode - node for which lookup desired

    wType - type of lookup

    wNameOffset - offset to name being written

Return Value:

    TRUE if wildcard's found, written -- terminate current lookup loop.
    FALSE, othewise -- continue lookup.

--*/
{
    PDB_RECORD  prr;
    PDB_NODE    pnodeWild;
    PDB_NODE    pzoneRoot;
    BOOL        fcheckAndMoveToParent;

    DNS_DEBUG( LOOKUP, (
        "Wildcard lookup for query at %p\n",
        pMsg ));

    //
    //  if NOT authoritative, wildcard meaningless
    //  verify wildcard lookup type
    //

    ASSERT( IS_AUTH_NODE( pNode ) );

    //
    //  find stopping point -- zone root
    //

    pzoneRoot = ( ( PZONE_INFO ) pNode->pZone )->pZoneRoot;

    //
    //  if found node, MUST check that it does not terminate
    //  wildcard processing before moving to parent for wildcard check
    //
    //  if did NOT find name, pNode is closest node and can be
    //  checked immediately for wildcard parent
    //

    if ( pMsg->pnodeCurrent == pNode )
    {
        fcheckAndMoveToParent = TRUE;
    }
    else
    {
        fcheckAndMoveToParent = FALSE;
    }

    //  init wildcard flag for "not found"
    //      - reset it when wildcard is found

    pMsg->fQuestionWildcard = WILDCARD_NOT_AVAILABLE;

    //
    //  proceed up tree checking for wildcard parent
    //  until encounter stop condition
    //
    //  note:  don't require node lock -- RR lookup always from NULL
    //          start (not existing RR), and don't write any node info
    //

    while ( 1 )
    {
        //
        //  move to parent?
        //      - stop at zone root
        //      - loose wildcarding, stop if node has records of desired type
        //      - strict wildcarding, stop if node has any records
        //
        //  skip first time through when query didn't find node;  in that
        //  case pNode is closest node and we check it for wildcard parent
        //

        if ( fcheckAndMoveToParent )
        {
            if ( pNode == pzoneRoot )
            {
                DNS_DEBUG( LOOKUP2, ( "End wildcard loop -- hit zone root\n" ));
                break;
            }
            else if ( SrvCfg_fLooseWildcarding )
            {
                if ( RR_FindNextRecord(
                        pNode,
                        wType,
                        NULL,
                        0 ) )
                {
                    DNS_DEBUG( LOOKUP2, (
                        "End wildcard loop -- hit node with type\n" ));
                    break;
                }
            }
            else if ( pNode->pRRList )
            {
                DNS_DEBUG( LOOKUP2, (
                    "End wildcard loop -- hit node with records\n" ));
                break;
            }
            pNode = pNode->pParent;
        }
        else
        {
            fcheckAndMoveToParent = TRUE;
        }

        //
        //  if wildcard child of node, check if wildcard for desired type
        //      => if so, do lookup on it
        //

        ASSERT( !IS_NOEXIST_NODE( pNode ) );

        if ( IS_WILDCARD_PARENT( pNode ) )
        {
            Dbase_LockDatabase();
            pnodeWild = NTree_FindOrCreateChildNode(
                            pNode,
                            "*",
                            1,
                            FALSE,      //  find, no create
                            0,          //  memtag
                            NULL );     //  ptr for following node
            Dbase_UnlockDatabase();

            if ( pnodeWild )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_NodeName(
                        "Wildcard node found ",
                        pnodeWild,
                        "\n" );
                }

                //
                //  quick check on wildcard existence
                //  if just checking wildcard this is all we need
                //
                //  note, no problem setting flag on non-question, as if have
                //  reached non-question node write, then use of the flag for
                //  NAME_ERROR response is superfluous
                //
                //  note, if wildcard RR has been deleted (but node still hanging
                //  around for timeout) then just ignore as if node doesn't exist
                //  (note, we can't delete WILDCARD_PARENT in case new RR added
                //  back on to node before delete)
                //

                if ( !pnodeWild->pRRList )
                {
                    continue;
                }
                pMsg->fQuestionWildcard = WILDCARD_EXISTS;

                //  just checking for any wildcard before NXDOMAIN send

                if ( wOffset == WILDCARD_CHECK_OFFSET )
                {
                    DNS_DEBUG( LOOKUP2, (
                        "Wildcardable question check successful\n" ));
                    return TRUE;
                }

                //
                //  Find wildcard and write wildcard answer to message.
                //

                if ( RR_FindNextRecord(
                        pnodeWild,
                        wType,
                        NULL,
                        0 ) )
                {
                    //  wildcard with wType found

                    if ( Wire_WriteRecordsAtNodeToMessage(
                            pMsg,
                            pnodeWild,
                            wType,
                            wOffset,
                            DNSSEC_ALLOW_INCLUDE_ALL ) )
                    {
                        DNS_DEBUG( LOOKUP, ( "Successful wildcard lookup\n" ));
                        Answer_ContinueNextLookupForQuery( pMsg );
                        return TRUE;
                    }
                    ELSE_IF_DEBUG( ANY )
                    {
                        Dbg_DbaseNode(
                            "ERROR:  Wildcard node lookup unsucessful ",
                            pnodeWild );
                        DNS_PRINT((
                            "Only Admin delete of record during lookup,"
                            "should create this\n" ));
                    }
                }
                ELSE_IF_DEBUG( LOOKUP2 )
                {
                    DNS_PRINT((
                        "Wildcard node, no records for type %d\n",
                        wType ));
                }

                //
                //  See if there is a CNAME wildcard. If so, write it
                //  out to the packet.
                //

                if ( RR_FindNextRecord(
                        pnodeWild,
                        DNS_TYPE_CNAME,
                        NULL,
                        0 ) )
                {
                    DNS_DEBUG( LOOKUP, ( "Successful wildcard CNAME lookup\n" ));

                    if ( Wire_WriteRecordsAtNodeToMessage(
                            pMsg,
                            pnodeWild,
                            DNS_TYPE_CNAME,
                            wOffset,
                            DNSSEC_ALLOW_INCLUDE_ALL ) )
                    {
                        //
                        //  Retrieve address records for CNAME. If the query 
                        //  type requires it, the address records should go 
                        //  in the answer section, otherwise put them in
                        //  the additional section.
                        //

                        if ( IS_GLUE_ADDRESS_TYPE( wType ) )
                        {
                            pMsg->Additional.dwStateFlags |= DNS_ADDSTATE_NOT_ADDITIONAL;
                        }

                        DNS_ADDITIONAL_SET_ONLY_WANT_A( &pMsg->Additional );
                        Answer_ContinueNextLookupForQuery( pMsg );
                        return TRUE;
                    }
                }
            }
            ELSE_IF_DEBUG( ANY )
            {
                Dbg_NodeName(
                    "ERROR:  Wildcard node NOT found as expected as child of ",
                    pNode,
                    "\n" );
            }
        }
        ELSE_IF_DEBUG( LOOKUP2 )
        {
            Dbg_NodeName(
                "Node not wildcard parent -- moving up ",
                pNode,
                "\n" );
        }
    }

    return FALSE;
}



DNS_STATUS
FASTCALL
writeCachedNameErrorNodeToPacketAndSend(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Write cached NAME_ERROR node, and if appropriate send NXDOMAIN.

Arguments:

    pMsg -- ptr to query being processed

    pNode -- ptr to node with cached name error.

Return Value:

    ERROR_SUCCESS if NXDOMAIN written to packet and sent.
    DNS_INFO_NO_RECORDS if valid cached name error, but not question answer.
    DNS_ERROR_RECORD_TIMED_OUT     if no name error cached at node.

--*/
{
    DNS_STATUS  status;
    PDB_RECORD  prr;
    PDB_NODE    pnodeZone;

    DNS_DEBUG( WRITE, (
        "writeCachedNameErrorNodeToPacketAndSend()\n"
        "    packet = %p, node = %p\n",
        pMsg, pNode ));

    //
    //  get cached name error, if timed out return
    //

    if ( !RR_CheckNameErrorTimeout( pNode, FALSE, NULL, NULL ) )
    {
        status = DNS_ERROR_RECORD_TIMED_OUT;
        goto Done;
    }

    //
    //  if NOT name error on ORIGINAL question, then nothing to write
    //

    if ( pMsg->Head.AnswerCount ||
        !IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
    {
        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }

    //
    //  send name error
    //

    pMsg->pnodeCurrent = pNode;
    Send_NameError( pMsg );
    status = ERROR_SUCCESS;

Done:

    return status;
}



VOID
FASTCALL
answerIQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Execute TKEY request.

Arguments:

    pMsg -- request for TKEY

Return Value:

    None.

--*/
{
    PCHAR           pch;
    WORD            lenQuestion;
    WORD            lenAnswer;
    WORD            responseCode = DNS_RCODE_FORMERR;
    DNS_PARSED_RR   tempRR;
    CHAR            szbuf[ IP_ADDRESS_STRING_LENGTH+3 ];

    DNS_DEBUG( LOOKUP, ( "Enter answerIQuery( %p )\n", pMsg ));

    if ( !SrvCfg_dwEnableFakeIQuery )
    {
        responseCode = DNS_RCODE_NOT_IMPLEMENTED;
        goto Failed;
    }

    //
    //  should have NO questions and ONE answer
    //

    if ( pMsg->Head.QuestionCount != 0 && pMsg->Head.AnswerCount != 1 )
    {
        goto Failed;
    }

    //
    //  pull out answer (IQUERY question)
    //

    pch = Wire_SkipPacketName( pMsg, pMsg->MessageBody );
    if ( ! pch )
    {
        goto Failed;
    }

    pch = Dns_ReadRecordStructureFromPacket(
            pch,
            DNSMSG_END( pMsg ),
            & tempRR );
    if ( ! pch )
    {
        goto Failed;
    }
    if ( tempRR.Type != DNS_TYPE_A ||
        tempRR.Class != DNS_CLASS_INTERNET ||
        tempRR.DataLength != sizeof(IP_ADDRESS) )
    {
        goto Failed;
    }
    lenAnswer = (WORD) (pch - pMsg->MessageBody);

    //
    //  convert requested address into a DNS name
    //

    pch = IP_STRING( * ( UNALIGNED IP_ADDRESS * ) tempRR.pchData );
    lenQuestion = ( WORD ) strlen( pch );

    szbuf[0] = '[';

    RtlCopyMemory(
        szbuf + 1,
        pch,
        lenQuestion );

    lenQuestion++;
    szbuf[ lenQuestion ] = ']';
    lenQuestion++;
    szbuf[ lenQuestion ] = 0;

    DNS_DEBUG( LOOKUP, ( "Responding to IQUERY with name %s\n", szbuf ));

    //
    //  move IQUERY answer
    //      - must leave space for packet name and DNS_QUESTION
    //      - packet name is strlen(name)+2 for leading label length and trailing 0
    //

    lenQuestion += sizeof(DNS_QUESTION) + 2;
    memmove(
        pMsg->MessageBody + lenQuestion,
        pMsg->MessageBody,
        lenAnswer );

    //
    //  write question
    //

    pch = Dns_WriteDottedNameToPacket(
                pMsg->MessageBody,
                pMsg->pBufferEnd,
                szbuf,
                NULL,   // no domain name
                0,      // no offset
                0 );    // not unicode
    if ( !pch )
    {
        goto Failed;
    }
    
    //
    //  Note: not checking to see if packet has enough room but it's
    //  reasonable to assume there will always be room for the entire
    //  faked IQUERY response in a UDP (or TCP) packet.
    //

    * ( UNALIGNED WORD * ) pch = DNS_RTYPE_A;
    pch += sizeof( WORD );
    * ( UNALIGNED WORD * ) pch = ( WORD ) DNS_RCLASS_INTERNET;
    pch += sizeof( WORD );

    DNS_DEBUG( LOOKUP2, (
        "phead          = %p\n"
        "pbody          = %p\n"
        "pch after q    = %p\n"
        "len answer     = %x\n"
        "len question   = %x\n",
        & pMsg->Head,
        pMsg->MessageBody,
        pch,
        lenAnswer,
        lenQuestion ));

    ASSERT( pch == pMsg->MessageBody + lenQuestion );

    pMsg->pCurrent = pch + lenAnswer;
    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.QuestionCount = 1;
    pMsg->fDelete = TRUE;

    Send_Msg( pMsg, 0 );
    return;

Failed:

    Reject_RequestIntact(
        pMsg,
        responseCode,
        0 );
    return;
}



WORD
Answer_ParseAndStripOpt(
    IN OUT  PDNS_MSGINFO    pMsg )
/*++

Routine Description:

    The message's pCurrent pointer should be pointing to the OPT
    RR, which is in the additional section. This parses and saves the
    OPT values in pMsg->Opt and strips the OPT out of the message.

    DEVNOTE: Currently this routine assumes the OPT RR is the last
    RR in the packet. This is not always going to be true!

Arguments:

    pMsg - message to process

Return Value:

    Returns DNS_RCODE_XXX constant. If NOERROR, then either there was
    no OPT or it was parsed successfully. Otherwise the rcode should
    be used to reject the request.

--*/
{
    WORD    rcode = DNS_RCODE_NOERROR;

    RtlZeroMemory( &pMsg->Opt, sizeof( pMsg->Opt ) );

    if ( pMsg->Head.AdditionalCount )
    {
        PDNS_WIRE_RECORD    pOptRR;
        BOOL                nameEmpty;

        nameEmpty = *pMsg->pCurrent == 0;

        //
        //  Skip over the packet name.
        //

        pOptRR = ( PDNS_WIRE_RECORD ) Wire_SkipPacketName(
            pMsg,
            ( PCHAR ) pMsg->pCurrent );
        if ( !pOptRR )
        {
            ASSERT( pOptRR );
            DNS_DEBUG( EDNS, (
                "add==1 but no OPT for msg=%p msg->curr=%p\n",
                pMsg,
                pMsg->pCurrent ));
            goto Done;
        }

        //
        //  Check if this is actually an OPT. Return NOERROR if not.
        //

        if ( InlineFlipUnalignedWord( &pOptRR->RecordType ) != DNS_TYPE_OPT )
        {
            goto Done;
        }

        //
        //  Verify format of OPT.
        //

        if ( !nameEmpty )
        {
            DNS_DEBUG( EDNS, (
                "OPT domain name is not empty msg=%p msg->curr=%p\n",
                pMsg,
                pMsg->pCurrent ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        if ( pOptRR->DataLength != 0 )
        {
            DNS_DEBUG( EDNS, (
                "OPT RData is not empty msg=%p msg->curr=%p (%d bytes)\n",
                pMsg,
                pMsg->pCurrent,
                pOptRR->DataLength ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        if ( !SrvCfg_dwEnableEDnsReception )
        {
            DNS_DEBUG( ANY, (
                "EDNS disabled so rejecting %p [FORMERR]\n",
                pMsg ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        pMsg->Opt.fFoundOptInIncomingMsg = TRUE;
        SET_SEND_OPT( pMsg );

        pMsg->Opt.cExtendedRCodeBits = ( UCHAR ) ( pOptRR->TimeToLive & 0xFF );
        pMsg->Opt.cVersion = ( UCHAR ) ( ( pOptRR->TimeToLive >> 8 ) & 0xFF );
        pMsg->Opt.wUdpPayloadSize =
            InlineFlipUnalignedWord( &pOptRR->RecordClass );

        DNS_DEBUG( LOOKUP, (
            "OPT in %p at %p\n"
            "    version=%d extended=0x%02X zero=0x%04X\n",
            pMsg,
            pOptRR,
            ( int ) pMsg->Opt.cVersion,
            ( int ) pMsg->Opt.cExtendedRCodeBits,
            ( int ) ( ( pOptRR->TimeToLive >> 16 ) & 0xFFFF ) ));

        //
        //  The OPT has been parsed. It should now be removed from the
        //  message. We do not ever want to forward or cache the OPT RR.
        //  NOTE: we are assuming there are no RRs after the OPT!
        //

        --pMsg->Head.AdditionalCount;
        pMsg->MessageLength = ( WORD ) DNSMSG_OFFSET( pMsg, pMsg->pCurrent );

        //
        //  Test for unsupported EDNS version.
        //

        if ( pMsg->Opt.cVersion != 0 )
        {
            DNS_DEBUG( ANY, (
                "rejecting request %p [BADVERS] bad EDNS version %d\n",
                pMsg,
                pMsg->Opt.cVersion ));

            rcode = DNS_RCODE_BADVERS;
            goto Done;
        }
    } // if

    Done:

    return rcode;
} // Answer_ParseAndStripOpt



VOID
Answer_TkeyQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Execute TKEY request.

Arguments:

    pMsg -- request for TKEY

Return Value:

    None.

--*/
{
    DNS_STATUS      status;

    DNS_DEBUG( LOOKUP, ( "Enter answerTkeyQuery( %p )\n", pMsg ));

    //STAT_INC( Query2Stats.TkeyRecieved );

#if DBG
    if ( pMsg->Head.RecursionDesired )
    {
        DNS_PRINT(( "CLIENT ERROR:  TKEY with RecursionDesired set!\n" ));
        // ASSERT( FALSE );
    }
#endif

    //
    //  DEVNOTE-DCR: 453800 - need cleanup for this on server restart
    //
    //  Ram stuck this init in main loop, either stick with switch to here
    //  or encapsulate with function.  In either case must have protection
    //  against MT simultaneous init -- currently just using database lock.
    //

    if ( !g_fSecurityPackageInitialized )
    {
        Dbase_LockDatabase()
        status = Dns_StartServerSecurity();
        Dbase_UnlockDatabase()
        if ( status != ERROR_SUCCESS )
        {
            //  DEVNOTE-LOG: log event for security init failure
            DNS_PRINT(( "ERROR:  Failed to initialize security package!!!\n" ));
            status = DNS_RCODE_SERVER_FAILURE;
            goto Failed;
        }
    }

    //
    //  negotiate TKEY
    //
    //  DEVNOTE: if this fails it would be nifty to increment stats based
    //  on the extended error code rather than the DNS rcode.
    //

    status = Dns_ServerNegotiateTkey(
                &pMsg->RemoteAddr,
                DNS_HEADER_PTR( pMsg ),
                DNSMSG_END( pMsg ),
                pMsg->pBufferEnd,
                    #if DBG
                    SrvCfg_dwBreakOnAscFailure,
                    #else
                    FALSE,
                    #endif
                &pMsg->pCurrent );
    if ( status == ERROR_SUCCESS )
    {
        pMsg->Head.IsResponse = TRUE;
        Send_Msg( pMsg, 0 );
        return;
    }

Failed:

    ASSERT( status < DNS_RCODE_MAX );
    //STAT_INC( PrivateStats.TkeyRefused );
    Reject_RequestIntact(
        pMsg,
        (UCHAR) status,
        0 );
}

//
//  End of answer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\boot.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    boot.c

Abstract:

    Domain Name System (DNS) Server

    DNS boot from registry routines.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Private protos
//


DNS_STATUS
setupZoneFromRegistry(
    IN OUT  HKEY            hkeyZone,
    IN      LPWSTR          pwsZoneName,
    IN      BOOL *          pfRegZoneDeleted    OPTIONAL
    );

DNS_STATUS
loadRegistryZoneExtensions(
    IN      HKEY            hkeyZone,
    IN      PZONE_INFO      pZone
    );



DNS_STATUS
Boot_FromRegistry(
    VOID
    )
/*++

Routine Description:

    Boot from registry values.  (Taking the place of boot file.)

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DWORD   status;
    HKEY    hkeyzones = NULL;
    DWORD   zoneIndex = 0;
    HKEY    hkeycurrentZone;
    DWORD   nameLength;
    WCHAR   wsnameZone[ DNS_MAX_NAME_LENGTH ];
    BOOL    fregZoneDeleted = FALSE;

    DNS_DEBUG( INIT, ( "Boot_FromRegistry()\n" ));

    //
    //  lock out admin access
    //  disable write back to registry from creation functions,
    //      since any values we create are from registry
    //

    Config_UpdateLock();
    Zone_UpdateLock( NULL );

    g_bRegistryWriteBack = FALSE;

    //
    //  walk zones in registry and recreate each one
    //

    while( 1 )
    {
        //
        //  Keep SCM happy.
        //

        Service_LoadCheckpoint();

        //
        //  Get the next zone.
        //

        status = Reg_EnumZones(
                    &hkeyzones,
                    zoneIndex,
                    &hkeycurrentZone,
                    wsnameZone );

        //  advance index for next zone;  do here to easily handle failure cases
        zoneIndex++;

        if ( status != ERROR_SUCCESS )
        {
            //  check for no more zones

            if ( status == ERROR_NO_MORE_ITEMS )
            {
                break;
            }

            //  DEVNOTE-LOG:  corrupted registry zone name EVENT here

            DNS_PRINT(( "ERROR:  Reading zones from registry failed\n" ));
            continue;
        }

        //
        //  if registry zone name is dot terminated (and not cache zone)
        //  then create zone will create non-dot-terminated name;
        //  (create zone does this to insure DS has unique name for a given
        //  zone)
        //  fix by treating zone as if non-boot, so all data is read from
        //  current zone key, but is rewritten to registry under correct name
        //

        nameLength = wcslen( wsnameZone );
        if ( nameLength > 1 && wsnameZone[nameLength-1] == L'.' )
        {
            g_bRegistryWriteBack = TRUE;
        }

        //
        //  zone found, read zone info
        //      - if old registry cache zone found and deleted then drop enum index
        //

        status = setupZoneFromRegistry(
                    hkeycurrentZone,
                    wsnameZone,
                    &fregZoneDeleted );
        if ( fregZoneDeleted )
        {
            zoneIndex--;
        }
        if ( status != ERROR_SUCCESS )
        {
            //  DEVNOTE-LOG: corrupted registry zone name EVENT here
            g_bRegistryWriteBack = FALSE;
            continue;
        }

        //
        //  if name was dot terminated
        //      - delete previous zone key
        //      - reset write back global, it serves as flag
        //

        if ( g_bRegistryWriteBack )
        {
            status = RegDeleteKeyW(
                        hkeyzones,
                        wsnameZone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT(( "Unable to delete dot-terminated zone key\n" ));
                ASSERT( FALSE );
            }
            g_bRegistryWriteBack = FALSE;
        }
    }

    if ( status == ERROR_NO_MORE_ITEMS )
    {
        status = ERROR_SUCCESS;
    }

    //
    //  unlock for admin access
    //  enable write back to registry from creation functions,
    //

    Config_UpdateUnlock();
    Zone_UpdateUnlock( NULL );
    g_bRegistryWriteBack = TRUE;

    if ( hkeyzones )
    {
        RegCloseKey( hkeyzones );
    }

    return status;
}



DNS_STATUS
setupZoneFromRegistry(
    IN OUT  HKEY            hkeyZone,
    IN      LPWSTR          pwsZoneName,
    IN      BOOL *          pfRegZoneDeleted    OPTIONAL
    )
/*++

Routine Description:

    Setup the zone from zone's registry data.

Arguments:

    hkeyZone -- registry key for zone;  key is closed on exit

    pwsZoneName -- name of zone

    pfRegZoneDeleted -- set to TRUE if the zone was deleted
        from the registry - this allows the caller to adjust
        the current zone index to read the next zone from the
        registry correctly

Return Value:

    ERROR_SUCCESS -- if successful
    DNSSRV_STATUS_REGISTRY_CACHE_ZONE -- on cache "zone" delete
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;
    DWORD           zoneType;
    DWORD           fdsIntegrated = FALSE;
    PWSTR           pwszoneFile = NULL;
    PDNS_ADDR_ARRAY arrayMasterIp = NULL;
    BOOL            fregZoneDeleted = FALSE;
    PDNS_DP_INFO    pdp = NULL;
    PSTR            pszdpFqdn = NULL;

    DNS_DEBUG( INIT, (
        "Reading boot info for zone %S from registry\n"
        "    zone key = %p\n",
        pwsZoneName,
        hkeyZone ));

    //
    //  read zone type
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pwsZoneName,
                DNS_REGKEY_ZONE_TYPE,
                FALSE,          // not BOOLEAN
                &zoneType );

    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_ZONE_TYPE,
            1,
            &pwsZoneName,
            NULL,
            status );
        goto InvalidData;
    }

    //
    //  get zone database info
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pwsZoneName,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                TRUE,               // byte BOOLEAN value
                &fdsIntegrated );

    //
    //  if DS zone, then MUST be on DC
    //      - if DC has been demoted, error out zone load
    //
    //  note:  not deleting registry zone, specifically to handle case
    //      where booting safe build;  do not want to trash registry info
    //
    //  DEVNOTE: 453826 - cleanup of old DS-integrated registry entries
    //      how does admin get this problem cleaned up without
    //      whacking registry by hand?
    //
    //      can be fixed a number of ways:
    //          - boot count since DS load
    //          - flag\count on zone
    //          - separate DS zones enumeration (easy to skip and delete)
    //
    //  for DS load, either
    //      - all DS zones have already been read from directory
    //          => so this zone old and may be deleted
    //      - or failed to open DS
    //          => just ignore this data and continue
    //

    if ( fdsIntegrated )
    {
        //
        //  Read the directory partition FQDN for the zone.
        //
        
        pszdpFqdn = ( PSTR ) Reg_GetValueAllocate(
                                    hkeyZone,
                                    NULL,
                                    ( PSTR ) WIDE_TEXT( DNS_REGKEY_ZONE_DIRECTORY_PARTITION ),
                                    DNS_REG_UTF8,
                                    NULL );
        if ( pszdpFqdn )
        {
            pdp = Dp_FindByFqdn( pszdpFqdn );
            if ( !pdp )
            {
                BYTE    argTypeArray[] =
                {
                    EVENTARG_UNICODE,
                    EVENTARG_UTF8
                };
                PVOID   argArray[] =
                {
                    pwsZoneName,
                    pszdpFqdn
                };

                status = ERROR_INVALID_DATA;

                DNS_LOG_EVENT(
                    DNS_EVENT_DS_REGISTRY_DP_INVALID,
                    2,
                    argArray,
                    argTypeArray,
                    status );
                goto Done;
            }
        }
        
        if ( !SrvCfg_fDsAvailable )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_OPEN_FAILED,
                1,
                &pwsZoneName,
                NULL,
                status );
            goto Done;
        }

        else if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY )
        {
            //  we've tried open before this call, so if fDsAvailable
            //  is TRUE we MUST have opened;
            //
            //  DEVOTE: srvcfg.h should be new SrvCfg_fDsOpen flag
            //  to explicitly let us test open condition

            if ( SrvCfg_fDsAvailable )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  deleted DS-integrated zone %S, from registry\n"
                    "    Booted from DS and zone not found in DS\n",
                    pwsZoneName ));
                Reg_DeleteZone( 0, pwsZoneName );
                fregZoneDeleted = TRUE;
            }
            status = DNS_EVENT_INVALID_REGISTRY_ZONE;
            goto Done;
        }
    }

    //
    //  not DS integrated, get zone file
    //      - must have for primary
    //      - default if not given for root-hints
    //      - optional for secondary

    else if ( !fdsIntegrated )
    {
        pwszoneFile = (PWSTR) Reg_GetValueAllocate(
                                    hkeyZone,
                                    NULL,
                                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                                    DNS_REG_WSZ,
                                    NULL );

        if ( !pwszoneFile && zoneType == DNS_ZONE_TYPE_PRIMARY )
        {
            DNS_DEBUG( INIT, (
                "No zone file found in registry for primary zone %S\n",
                pwsZoneName ));

            DNS_LOG_EVENT(
                DNS_EVENT_NO_ZONE_FILE,
                1,
                &pwsZoneName,
                NULL,
                0 );
            goto InvalidData;
        }
    }

    //
    //  old "cache" zone -- delete it
    //

    if ( zoneType == DNS_ZONE_TYPE_CACHE )
    {
        status = Zone_DatabaseSetup_W(
                    g_pCacheZone,
                    fdsIntegrated,
                    pwszoneFile,
                    0,              //  flags
                    NULL,           //  DP pointer
                    0,              //  DP flags
                    NULL );         //  DP FQDN
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
        }
        DNS_PRINT((
            "WARNING:  Deleting old cache zone key!\n" ));
        Reg_DeleteZone( 0, pwsZoneName );
        status = DNSSRV_STATUS_REGISTRY_CACHE_ZONE;
        fregZoneDeleted = TRUE;
        goto Done;
    }

    //
    //  secondary, stub, and forwarder zones MUST have master IP list
    //

    if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
            zoneType == DNS_ZONE_TYPE_STUB ||
            zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        arrayMasterIp = Reg_GetAddrArray(
                            hkeyZone,
                            NULL,
                            DNS_REGKEY_ZONE_MASTERS );
        if ( arrayMasterIp )
        {
            IF_DEBUG( INIT )
            {
                DnsDbg_DnsAddrArray(
                    "Master IPs for zone from registry:  ",
                    NULL,
                    arrayMasterIp );
            }
        }
        else
        {
            DNS_DEBUG( INIT, (
                "No masters found in in registry for zone type %d\n"
                "    zone %S\n",
                zoneType,
                pwsZoneName ));

            DNS_LOG_EVENT(
                DNS_EVENT_SECONDARY_REQUIRES_MASTERS,
                1,
                &pwsZoneName,
                NULL,
                0 );
            goto InvalidData;
        }
    }

    //
    //  create the zone
    //

    status = Zone_Create_W(
                &pzone,
                zoneType,
                pwsZoneName,
                arrayMasterIp,
                fdsIntegrated,
                pwszoneFile );
    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REG_ZONE_CREATION_FAILED,
            1,
            &pwsZoneName,
            NULL,
            status );

        DNS_PRINT(( "ERROR:  Registry zone creation failed\n" ));
        goto Done;
    }
    
    //
    //  For DS integrated zones, set the zone DP. This must be done
    //  even for zones that are located in the legacy partition.
    //
    
    if ( fdsIntegrated )
    {
        status = Ds_SetZoneDp( pzone, pdp, FALSE );
        if ( status != ERROR_SUCCESS )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_REG_ZONE_CREATION_FAILED,
                1,
                &pwsZoneName,
                NULL,
                status );

            DNS_PRINT(( "ERROR:  Could not set directory partition for registry zone\n" ));
            goto Done;
        }
    }

#if 0
    //
    //  for cache file -- done
    //

    if ( zoneType == DNS_ZONE_TYPE_CACHE )
    {
        goto Done;
    }
#endif

    //
    //  read extensions
    //

    status = loadRegistryZoneExtensions(
                hkeyZone,
                pzone );

    DNS_DEBUG( INIT, ( "Successfully loaded zone info from registry\n\n" ));
    goto Done;


InvalidData:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_INVALID_DATA;
    }
    DNS_PRINT((
        "ERROR:  In registry data for zone %S\n"
        "    Zone load terminated, status = %d %p\n",
        pwsZoneName,
        status,
        status ));

    DNS_LOG_EVENT(
        DNS_EVENT_INVALID_REGISTRY_ZONE,
        1,
        &pwsZoneName,
        NULL,
        status );

Done:

    //  free allocated data

    FREE_HEAP( pwszoneFile );
    FREE_HEAP( arrayMasterIp );
    FREE_HEAP( pszdpFqdn );

    //  close zone's registry key

    RegCloseKey( hkeyZone );

    if ( pfRegZoneDeleted )
    {
        DNS_DEBUG( INIT2, (
            "Returning zone %S deleted from registry\n", pwsZoneName ));
        *pfRegZoneDeleted = fregZoneDeleted;
    }

    return status;
}



DNS_STATUS
Boot_FromRegistryNoZones(
    VOID
    )
/*++

Routine Description:

    Boot from registry with no zones.
    Setup default cache file for load.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( INIT, ( "Boot_FromRegistryNoZones()\n" ));

    //
    //  DEVNOTE: check that we're defaulting cache info properly?
    //

    return ERROR_SUCCESS;
}



DNS_STATUS
loadRegistryZoneExtensions(
    IN      HKEY            hkeyZone,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Read MS zone extensions (not part of boot file).

    This called both from standard registry boot, and to load just
    extensions when booting from boot file.

Arguments:

    hkeyZone -- registry key for zone

    pZone -- ptr to zone if zone already exists;  otherwise NULL

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_ADDR_ARRAY     arrayIp;

    ASSERT( pZone );
    ASSERT( pZone->aipSecondaries == NULL );
    ASSERT( pZone->aipNotify == NULL );

    DNS_DEBUG( INIT, (
        "Loading registry zone extensions for zone %S\n"
        "    zone key = %p\n",
        pZone->pwsZoneName,
        hkeyZone ));

    //
    //  get secondary list
    //

    arrayIp = Reg_GetAddrArray(
                    hkeyZone,
                    NULL,
                    DNS_REGKEY_ZONE_SECONDARIES );
    IF_DEBUG( INIT )
    {
        if ( arrayIp )
        {
            DnsDbg_DnsAddrArray(
                "Secondary list for zone from registry:  ",
                NULL,
                arrayIp );
        }
        else
        {
            DNS_PRINT((
                "No secondaries found in in registry for zone %S\n",
                pZone->pwsZoneName ));
        }
    }
    pZone->aipSecondaries = arrayIp;

    //
    //  get secure secondaries flag
    //      - note this may exist even though NO secondaries specified
    //
    //      - however, because this regkey was not explicitly written in NT4
    //      if the key is NOT read, we'll default to open
    //      - since key was binary in NT4
    //      if have secondary list, assume secondary LIST_ONLY
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pZone->pwsZoneName,
                DNS_REGKEY_ZONE_SECURE_SECONDARIES,
                TRUE,                               //  byte value
                &pZone->fSecureSecondaries );
    if ( status == ERROR_SUCCESS )
    {
        if ( pZone->fSecureSecondaries && pZone->aipSecondaries )
        {
            pZone->fSecureSecondaries = ZONE_SECSECURE_LIST_ONLY;
        }
    }
    else
    {
        pZone->fSecureSecondaries =
            IS_ZONE_DSINTEGRATED( pZone ) ?
                ZONE_SECSECURE_NO_XFR :
                ZONE_SECSECURE_NS_ONLY;
    }

    //
    //  get notify list
    //

    arrayIp = Reg_GetAddrArray(
                    hkeyZone,
                    NULL,
                    DNS_REGKEY_ZONE_NOTIFY_LIST );
    IF_DEBUG( INIT )
    {
        if ( arrayIp )
        {
            DnsDbg_DnsAddrArray(
                "Notify IPs for zone from registry:  ",
                NULL,
                arrayIp );
        }
        else
        {
            DNS_PRINT((
                "No notify IPs found in in registry for zone %S\n",
                pZone->pwsZoneName ));
        }
    }
    pZone->aipNotify = arrayIp;

    //
    //  notify level
    //  defaults
    //      - ALL NS for regular primary
    //      - list only for DS primary
    //      - list only for secondary
    //
    //  this key didn't exist in NT4, but defaults written in Zone_Create()
    //  will properly handled upgrade case
    //  will notify aipSecondaries if given and also any NS list for standard
    //  primary -- exactly NT4 behavior
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_NOTIFY_LEVEL,
        TRUE,                           //  byte value
        &pZone->fNotifyLevel );

    //
    //  get local master list for stub zones
    //

    if ( IS_ZONE_STUB( pZone ) )
    {    
        arrayIp = Reg_GetAddrArray(
                        hkeyZone,
                        NULL,
                        DNS_REGKEY_ZONE_LOCAL_MASTERS );
        IF_DEBUG( INIT )
        {
            if ( arrayIp )
            {
                DnsDbg_DnsAddrArray(
                    "Local Masters for stub zone: ",
                    NULL,
                    arrayIp );
            }
            else
            {
                DNS_PRINT((
                    "No local masters found in in registry for stub zone %S\n",
                    pZone->pwsZoneName ));
            }
        }
        pZone->aipLocalMasters = arrayIp;
        DnsAddrArray_SetPort( pZone->aipLocalMasters, DNS_PORT_NET_ORDER );
    }

    //
    //  updateable zone?
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_ALLOW_UPDATE,
        FALSE,      // DWORD value
        &pZone->fAllowUpdate );

    //
    //  update logging?
    //      - default is off for DS integrated
    //      - on in datafile case
    //

    if ( pZone->fAllowUpdate )
    {
        status = Reg_ReadDwordValue(
                    hkeyZone,
                    pZone->pwsZoneName,
                    DNS_REGKEY_ZONE_LOG_UPDATES,
                    TRUE,       // byte value
                    &pZone->fLogUpdates );
        if ( status != ERROR_SUCCESS )
        {
            pZone->fLogUpdates = !pZone->fDsIntegrated;
        }
    }

    //
    //  scavenging info
    //      - for DS zone, this is read from DS zone properties
    //      - only write if property found -- otherwise server default
    //          already set in Zone_Create()
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_AGING,
            FALSE,                          //  full BOOL value
            &pZone->bAging );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_NOREFRESH_INTERVAL,
            FALSE,                          //  full DWORD value
            &pZone->dwNoRefreshInterval );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_REFRESH_INTERVAL,
            FALSE,                          //  full DWORD value
            &pZone->dwRefreshInterval );

        //  zero refresh\no-refresh intervals are illegal

        if ( pZone->dwRefreshInterval == 0 )
        {
            pZone->dwRefreshInterval = SrvCfg_dwDefaultRefreshInterval;
        }
        if ( pZone->dwNoRefreshInterval == 0 )
        {
            pZone->dwNoRefreshInterval = SrvCfg_dwDefaultNoRefreshInterval;
        }
    }

    //
    //  Parameters for conditional domain forwarder zones.
    //

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_FWD_TIMEOUT,
            FALSE,                          // full DWORD value
            &pZone->dwForwarderTimeout );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_FWD_SLAVE,
            TRUE,                           // byte value
            &pZone->fForwarderSlave );
    }

    //
    //  DC Promo transitional
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_DCPROMO_CONVERT,
        FALSE,                              //  DWORD value
        &pZone->dwDcPromoConvert );

    DNS_DEBUG( INIT, ( "Loaded zone extensions from registry\n" ));

    return ERROR_SUCCESS;
}



DNS_STATUS
Boot_ProcessRegistryAfterAlternativeLoad(
    IN      BOOL            fBootFile,
    IN      BOOL            fLoadRegZones
    )
/*++

Routine Description:

    Registry action after non-registry (BootFile or DS) load:
        =>  Load zone extensions for existing zones
        =>  Load registry zones configured in registry
                OR
            Delete them.

    SrvCfgInitialize sets basic server properties.
    We do NOT want to pay attention to those which can be set be boot file:

        - Slave
        - NoRecursion

    Futhermore we want to overwrite any registry info for parameters read from
    boot file, even if not read by SrvCfgInitialize():

        - Forwarders

Arguments:

    fBootFile -- boot file load

    fLoadRegZones -- load additional registry zones

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       status;
    INT         fstrcmpZone;
    PZONE_INFO  pzone;
    HKEY        hkeyzones = NULL;
    DWORD       zoneIndex = 0;
    HKEY        hkeycurrentZone = NULL;
    WCHAR       wsnameZone[ DNS_MAX_NAME_LENGTH ];

    DNS_DEBUG( INIT, (
        "Boot_ProcessRegistryAfterAlternativeLoad()\n" ));

    //
    //  lock out admin access
    //  disable write back to registry during functions,
    //      since any values we create are from registry
    //

    Zone_UpdateLock( NULL );

    //
    //  check all zones in registry
    //      - either load zone or extensions
    //      - or delete registry zone
    //

    while ( 1 )
    {
        //
        //  Find next zone in registry.
        //

        status = Reg_EnumZones(
                    &hkeyzones,
                    zoneIndex,
                    &hkeycurrentZone,
                    wsnameZone );

        DNS_DEBUG( INIT, (
            "found registry zone index %d \"%S\"\n", zoneIndex, wsnameZone ));

        if ( status != ERROR_SUCCESS )
        {
            ASSERT( status == ERROR_NO_MORE_ITEMS );
            break;
        }
        zoneIndex++;

        //
        //  Find the zone in the zone list that matches the registry zone name.
        //

        fstrcmpZone = 1;    //  In case there are no zones.

        pzone = Zone_ListGetNextZone( NULL );
        while ( pzone )
        {
            if ( !IS_ZONE_CACHE( pzone ) )
            {
                DNS_DEBUG( INIT2, (
                    "compare zone list for match \"%S\"\n", pzone->pwsZoneName ));

                //
                //  Compare registry name to current zone list name. Terminate
                //  if the names match or if we've gone past the registry name 
                //  in the zone list.
                //

                fstrcmpZone = wcsicmp_ThatWorks( wsnameZone, pzone->pwsZoneName );
                if ( fstrcmpZone <= 0 )
                {
                    break;
                }
            }
            pzone = Zone_ListGetNextZone( pzone );
        }

        //
        //  fstrcmpZone == 0 --> pzone is zone in zone list matching reg zone
        //  fstrcmpZone != 0 --> registry zone was not found in zone list
        //

        DNS_DEBUG( INIT, (
            "loading extensions for reg zone name %S, %s match\n",
            wsnameZone,
            fstrcmpZone == 0 ? "found" : "no" ));

        if ( fstrcmpZone == 0 )
        {
            status = loadRegistryZoneExtensions(
                        hkeycurrentZone,
                        pzone );

            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
            }
            RegCloseKey( hkeycurrentZone );
        }

        //
        //  unmatched registry zone
        //      - for DS load -- attempt to load zone extensions
        //      - for boot file -- delete registry zone
        //

        else if ( fLoadRegZones )
        {
            BOOL    fregZoneDeleted = FALSE;

            ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY ||
                    SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED );

            status = setupZoneFromRegistry(
                        hkeycurrentZone,
                        wsnameZone,
                        &fregZoneDeleted );

            //  move on to next registry zone
            //      - if bogus cache zone deleted, don't inc index
            //      - setupZoneFromRegistry() closes zone handle
            //
            //  note zone is loaded to in memory zone list, immediately
            //  AHEAD of current pzone ptr;  no action to alter zone list
            //  should be necessary

            if ( fregZoneDeleted )
            {
                zoneIndex--;
            }
        }
        else
        {
            DWORD       rc;

            ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_FILE ||
                    SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED );

            DNS_DEBUG( INIT, (
                "Deleting unused registry zone \"%S\" key\n",
                wsnameZone ));

            RegCloseKey( hkeycurrentZone );

            //
            //  It's critical that we delete the key even if it has children.
            //  If the delete fails we will be stuck in an infinite loop!
            //

            rc = SHDeleteKeyW( hkeyzones, wsnameZone );
            ASSERT( rc == ERROR_SUCCESS );

            zoneIndex--;
        }
    }

    if ( hkeyzones )
    {
        RegCloseKey( hkeyzones );
    }

    if ( status == ERROR_NO_MORE_ITEMS )
    {
        status = ERROR_SUCCESS;
    }

    //
    //  write back server configuration changes to registry
    //

    g_bRegistryWriteBack = TRUE;

    //
    //  reset server configuration read from bootfile
    //

    if ( fBootFile )
    {
        //  set forwarders info

        status = Config_SetupForwarders(
                        BootInfo.aipForwarders,
                        0,
                        BootInfo.fSlave );

        //  write changed value of no-recursion
        //  this is read by SrvCfgInitialize() only need to write it
        //  back if different

        if ( BootInfo.fNoRecursion && SrvCfg_fRecursionAvailable ||
             !BootInfo.fNoRecursion && !SrvCfg_fRecursionAvailable )
        {
            DNS_PROPERTY_VALUE prop = { REG_DWORD, BootInfo.fNoRecursion };
            status = Config_ResetProperty(
                        0,
                        DNS_REGKEY_NO_RECURSION,
                        &prop );
        }
    }

    //
    //  unlock zone for admin access
    //

    Zone_UpdateUnlock( NULL );
    return status;
}



DNS_STATUS
loadZonesIntoDbase(
    VOID
    )
/*++

Routine Description:

    Read zone files into database.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    INT         countZonesOpened = 0;

    //
    //  loop loading all zones in list
    //      - load file if given
    //      - load from DS
    //

    pzone = NULL;

    while ( pzone = Zone_ListGetNextZone(pzone) )
    {
        if ( IS_ZONE_CACHE( pzone ) )
        {
            continue;
        }

        //
        //  Load the zone. Secondary zones with no database file 
        //  will fail with ERROR_FILE_NOT_FOUND. Zone_Load will 
        //  leave the zone locked so unlock it afterwards.
        //

        status = Zone_Load( pzone );

        Zone_UnlockAfterAdminUpdate( pzone );

        if ( status == ERROR_SUCCESS ||
            IS_ZONE_SECONDARY( pzone ) && status == ERROR_FILE_NOT_FOUND )
        {
            countZonesOpened++;
            continue;
        }

        ASSERT( IS_ZONE_SHUTDOWN( pzone ) );
        DNS_PRINT((
            "ERROR: failed zone %S load!!!\n",
            pzone->pwsZoneName ));
    }

    if ( countZonesOpened <= 0 )
    {
        DNS_DEBUG( ANY, (
            "INFO:  Caching server only\n" ));

        DNS_LOG_EVENT(
            DNS_EVENT_CACHING_SERVER_ONLY,
            0,
            NULL,
            NULL,
            0 );
    }
    return ERROR_SUCCESS;
}



//
//  Main load database at boot routine
//

DNS_STATUS
Boot_LoadDatabase(
    VOID
    )
/*++

Routine Description:

    Load the database:
        - initialize the database
        - build the zone list from boot file
        - read in database files to build database

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    LPSTR       pszBootFilename;
    DNS_STATUS  status;
    PZONE_INFO  pzone;

    //
    //  Create cache "zone"
    //

    g_bRegistryWriteBack = FALSE;
    status = Zone_Create(
                &pzone,
                DNS_ZONE_TYPE_CACHE,
                ".",
                0,
                0,          //  flags
                NULL,       //  no masters
                FALSE,      //  file not database
                NULL,       //  naming context
                NULL,       //  default file name
                0,
                NULL,
                NULL );     //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }
    ASSERT( g_pCacheZone && pzone == g_pCacheZone );
    g_bRegistryWriteBack = TRUE;

    //
    //  load zone information from registry or boot file
    //

    //  boot file state
    //  must find boot file or error

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
    {
        status = File_ReadBootFile( TRUE );
        if ( status == ERROR_SUCCESS )
        {
            goto ReadFiles;
        }
        return status;
    }

    //
    //  fresh install
    //      - try to find boot file
    //      - if boot file found => explicit boot file state
    //      - if boot file NOT found, try no-zone boot
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        DNS_PROPERTY_VALUE prop = { REG_DWORD, 0 };
        status = File_ReadBootFile( FALSE );
        if ( status == ERROR_SUCCESS )
        {
            prop.dwValue = BOOT_METHOD_FILE;
            Config_ResetProperty(
                0,
                DNS_REGKEY_BOOT_METHOD,
                &prop );
            goto ReadFiles;
        }

        if ( status == ERROR_FILE_NOT_FOUND )
        {
            //  do NOT require open -- suppresses open failure event logging
            status = Ds_BootFromDs( 0 );
            if ( status == ERROR_SUCCESS )
            {
                prop.dwValue = BOOT_METHOD_DIRECTORY;
                Config_ResetProperty(
                    0,
                    DNS_REGKEY_BOOT_METHOD,
                    &prop );
                goto ReadFiles;
            }
        }

        if ( status == DNS_ERROR_DS_UNAVAILABLE )
        {
            status = Boot_FromRegistryNoZones();
            if ( status == ERROR_SUCCESS )
            {
                goto ReadFiles;
            }
        }
        return status;
    }

    //
    //  boot from directory
    //
    //  note:  boot from directory is actually directory PLUS
    //      any non-DS stuff in the registry AND any additional
    //      registry zone config for DS zones
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY )
    {
        status = Ds_BootFromDs( DNSDS_WAIT_FOR_DS );
        if ( status == ERROR_SUCCESS )
        {
            goto ReadFiles;
        }
        return status;
    }

    //
    //  registry boot state
    //

    else
    {
        ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_REGISTRY );

        status = Boot_FromRegistry();
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
    }

ReadFiles:

    //
    //  Force create of "cache zone"
    //  Read root hints -- if any available
    //
    //  Doing this before load, so g_pCacheZone available;  If later do delayed loads
    //      for DS zones, this may be requirement;
    //
    //  DEVNOTE-LOG: should we log an error on root hints load failure?
    //

    status = Zone_LoadRootHints();
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Root hints load failure = %d (%p)\n"
            "    Must be accompanied by event log,\n"
            "    but will continue to load\n",
            status, status ));

        SrvInfo_fWarnAdmin = TRUE;
    }

    //
    //  Read in zone files\directory
    //

    IF_DEBUG( INIT2 )
    {
        Dbg_ZoneList( "Zone list before file load:\n" );
    }
    status = loadZonesIntoDbase();
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  Auto load default reverse lookup zones
    //

    Zone_CreateAutomaticReverseZones();

    //
    //  Check database -- catch consistency errors
    //

    if ( ! Dbase_StartupCheck( DATABASE_FOR_CLASS(DNS_RCLASS_INTERNET) ) )
    {
        return( ERROR_INVALID_DATA );
    }

    IF_DEBUG( INIT2 )
    {
        Dbg_ZoneList( "Zone list after file load:\n" );
    }
    IF_DEBUG( INIT2 )
    {
        Dbg_DnsTree(
            "ZONETREE after load:\n",
            DATABASE_ROOT_NODE );
    }

    //
    //  post-load reconfiguration
    //

    Config_PostLoadReconfiguration();

    return status;
}

//
//  End boot.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\samples\pluginsample\dnspluginsample.c ===
/*++

Copyright (c) 1997-2002 Microsoft Corporation

Module Name:

    DnsPluginSample.c

Abstract:

    Domain Name System (DNS) Sample Plugin DLL

Author:

    Jeff Westhead   jwesth   January 2002

Revision History:

--*/


//  -------------------------------------------------------------------------
//      Documentation
//  -------------------------------------------------------------------------

/*

 Installing the plugin DLL
---------------------------

- copy plugin to any directory, for example c:\bin

- configure DNS server to load plugin by running this command:
    dnscmd /Config /ServerLevelPluginDll c:\bin\dnssampleplugin.dll

- restart the DNS service
    net stop dns & net start dns


 Uninstalling the plugin DLL
-----------------------------

- configure DNS server to stop loading the plugin by running this command:
    dnscmd /Config /ServerLevelPluginDll

- restart the DNS service
    net stop dns & net start dns

 Querying current plugin DLL
-----------------------------

- run this command to see the current plugin DLL name
    dnscmd /Info /ServerLevelPluginDll

*/


//  -------------------------------------------------------------------------
//      Include directives
//  -------------------------------------------------------------------------


#include "DnsPluginSample.h"


//  -------------------------------------------------------------------------
//      Macros
//  -------------------------------------------------------------------------


#define SIZEOF_DB_NAME( pDbName ) ( ( pDbName )->Length + sizeof( UCHAR ) * 2 )


//  -------------------------------------------------------------------------
//      Global variables
//  -------------------------------------------------------------------------


PLUGIN_ALLOCATOR_FUNCTION       g_pDnsAllocate = NULL;
PLUGIN_FREE_FUNCTION            g_pDnsFree = NULL;


//  -------------------------------------------------------------------------
//      Functions
//  -------------------------------------------------------------------------


/*++

Routine Description:

    DllMain

Arguments:

Return Value:

--*/
BOOL WINAPI 
DllMain( 
    HANDLE      hModule, 
    DWORD       dwReason, 
    LPVOID      lpReserved
    )
{
    return TRUE;
}   //  DllMain


/*++

Routine Description:

    DnsPluginInitialize is called by the DNS server to initialize
    the plugin.

Arguments:

    pDnsAllocator -- allocator function for future allocation of DNS records
    
Return Value:

    Return ERROR_SUCCESS or error code if initialization failed.

--*/
DWORD
DnsPluginInitialize(
    PLUGIN_ALLOCATOR_FUNCTION       pDnsAllocateFunction,
    PLUGIN_FREE_FUNCTION            pDnsFreeFunction
    )
{
    WSADATA     wsaData;

    g_pDnsAllocate = pDnsAllocateFunction;
    g_pDnsFree = pDnsFreeFunction;

    WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    
    return ERROR_SUCCESS;
}   //  DnsPluginInitialize


/*++

Routine Description:

    DnsPluginCleanup is called by the DNS server to terminate hooked lookups.
    The plugin must close all connections and free all resources.

Arguments:

    None.
    
Return Value:

    Return ERROR_SUCCESS or error code if cleanup failed.

--*/
DWORD
DnsPluginCleanup(
    VOID
    )
{
    g_pDnsAllocate = NULL;
    g_pDnsFree = NULL;
    
    WSACleanup();

    return ERROR_SUCCESS;
}   //  DnsPluginCleanup


/*++

Routine Description:

    This function returns a DNS name in dotted string format as a DB_NAME.

Arguments:

    pszDottedName -- DNS name to be converted into DB_NAME format
    
    pDbName -- pointer to structure where DB_NAME value will be written
    
Return Value:

    Return ERROR_SUCCESS or error code on failure.

--*/
DWORD
convertDottedNameToDbName(
    PSTR            pszDottedName,
    DB_NAME *       pDbName )
{
    DWORD           status = ERROR_SUCCESS;
    PSTR            psz;
    PSTR            pszCharDest = &pDbName->RawName[ 1 ];
    PUCHAR          puchLabelLength = &pDbName->RawName[ 0 ];
    
    memset( pDbName, 0, sizeof( *pDbName ) );

    if ( !pszDottedName )
    {
        goto Done;
    }
    
    //
    //  Account for first length byte in the name.
    //

    pDbName->Length = 1;

    //
    //  Loop through characters of the dotted name, converting to DB_NAME.
    //
    
    for ( psz = pszDottedName; *psz; ++psz )
    {
        if ( *psz == '.' )
        {
            if ( *( psz + 1 ) == '\0' )
            {
                break;      //  Terminating dot - ignore.
            }
            puchLabelLength = pszCharDest++;
            ++pDbName->Length;
            ++pDbName->LabelCount;
        }
        else
        {
            ++pDbName->Length;
            ++*puchLabelLength;
            *pszCharDest++ = *psz;
        }
    }
    
    //
    //  Account for terminating zero character.
    //
    
    ++pDbName->LabelCount;
    ++pDbName->Length;
    
    Done:
    
    return status;
}   //  convertDottedNameToDbName


/*++

Routine Description:

    DnsPluginQuery is called by the DNS server to retrieve a list of
    DNS records for a DNS name. The plugin must fabricate a linked list of
    DNS records if the name is valid.

Arguments:

    pszQueryName -- DNS name that is being queried for, note this will always
        be a fully-qualified domain name and will always end in a period
    
    wQueryType -- record type desired by the DNS server
    
    pszRecordOwnerName -- static buffer in the DNS server where the plugin
        may write the owner name of the record list if it does not match the
        query name -- currently this should only be used when returning a
        single SOA record for NAME_ERROR and NO_RECORDS responses
    
    ppDnsRecordListHead -- pointer to first element of linked list of DNS
        records; this list is fabricated by the plugin and returned on output
    
Return Value:

    Return ERROR_SUCCESS or error code if cleanup failed.

--*/
DWORD
DnsPluginQuery(
    PSTR                pszQueryName,
    WORD                wQueryType,
    PSTR                pszRecordOwnerName,
    PDB_RECORD *        ppDnsRecordListHead
    )
{
    DWORD               status = DNS_PLUGIN_SUCCESS;
    PDB_RECORD          prr;
    PDB_RECORD          prrlast = NULL;
    
    ASSERT( ppDnsRecordListHead != NULL );
    *ppDnsRecordListHead = NULL;

    //
    //  This macro performs allocation error checking and automates the
    //  linking of new DNS resource records as they are allocated.
    //
    
    #define CheckNewRRPointer( pNewRR )                                         \
        if ( pNewRR == NULL ) { status = DNS_PLUGIN_OUT_OF_MEMORY; goto Done; } \
        if ( *ppDnsRecordListHead == NULL ) { *ppDnsRecordListHead = pNewRR; }  \
        if ( prrlast ) { prrlast->pRRNext = pNewRR; }                           \
        prrlast = pNewRR
    
    //
    //  This plugin sythesizes a DNS zone called "dnssample.com". If the
    //  query is for a name outside that zone the plugin will return name error.
    //

    #define PLUGIN_ZONE_NAME    "dnssample.com."
        
    if ( strlen( pszQueryName ) < strlen( PLUGIN_ZONE_NAME ) ||
         _stricmp(
            pszQueryName + strlen( pszQueryName ) - strlen( PLUGIN_ZONE_NAME ),
            PLUGIN_ZONE_NAME ) != 0 )
    {
        status = DNS_PLUGIN_NAME_OUT_OF_SCOPE;
        goto Done;
    }
    
    //
    //  Parse the query name to determine what records should be returned.
    //
    
    if ( strlen( pszQueryName ) == strlen( PLUGIN_ZONE_NAME ) )
    {
        switch ( wQueryType )
        {
            case DNS_TYPE_SOA:
            {
                //  At the zone root return 2 arbitrary NS records.
                
                DB_NAME     dbnamePrimaryServer;
                DB_NAME     dbnameZoneAdmin;

                status = convertDottedNameToDbName(
                                "ns1." PLUGIN_ZONE_NAME,
                                &dbnamePrimaryServer ) ;
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                status = convertDottedNameToDbName(
                                "admin." PLUGIN_ZONE_NAME,
                                &dbnameZoneAdmin ) ;
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }

                prr = g_pDnsAllocate(
                            sizeof( DWORD ) * 5 +
                            SIZEOF_DB_NAME( &dbnamePrimaryServer ) +
                            SIZEOF_DB_NAME( &dbnameZoneAdmin ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_SOA;
                prr->Data.SOA.dwSerialNo = htonl( 1000 );
                prr->Data.SOA.dwRefresh = htonl( 3600 );
                prr->Data.SOA.dwRetry = htonl( 600 );
                prr->Data.SOA.dwExpire = htonl( 1800 );
                prr->Data.SOA.dwMinimumTtl = htonl( 60 );
                memcpy(
                    &prr->Data.SOA.namePrimaryServer,
                    &dbnamePrimaryServer,
                    SIZEOF_DB_NAME( &dbnamePrimaryServer ) );
                memcpy(
                    ( PBYTE ) &prr->Data.SOA.namePrimaryServer +
                        SIZEOF_DB_NAME( &dbnamePrimaryServer ),
                    &dbnameZoneAdmin,
                    SIZEOF_DB_NAME( &dbnameZoneAdmin ) );
                break;
            }

            case DNS_TYPE_NS:
            {
                //  At the zone root return 2 arbitrary NS records.
                
                DB_NAME     dbname;

                status = convertDottedNameToDbName(
                                "ns1." PLUGIN_ZONE_NAME,
                                &dbname );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                prr = g_pDnsAllocate( SIZEOF_DB_NAME( &dbname ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_NS;
                memcpy(
                    &prr->Data.PTR.nameTarget,
                    &dbname,
                    SIZEOF_DB_NAME( &dbname ) );

                status = convertDottedNameToDbName(
                                "ns2." PLUGIN_ZONE_NAME,
                                &dbname ) ;
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                prr = g_pDnsAllocate( SIZEOF_DB_NAME( &dbname ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_NS;
                memcpy(
                    &prr->Data.PTR.nameTarget,
                    &dbname,
                    SIZEOF_DB_NAME( &dbname ) );
                break;
            }
            
            case DNS_TYPE_MX:
            {
                //  At the zone root return 2 arbitrary MX records.

                DB_NAME     dbname;

                status = convertDottedNameToDbName(
                                "mail1." PLUGIN_ZONE_NAME,
                                &dbname ) ;
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                prr = g_pDnsAllocate(
                            sizeof( WORD ) + SIZEOF_DB_NAME( &dbname ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_MX;
                prr->Data.MX.wPreference = htons( 10 );
                memcpy(
                    &prr->Data.MX.nameExchange,
                    &dbname,
                    SIZEOF_DB_NAME( &dbname ) );

                status = convertDottedNameToDbName(
                                "mail2." PLUGIN_ZONE_NAME,
                                &dbname ) ;
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                prr = g_pDnsAllocate(
                            sizeof( WORD ) + SIZEOF_DB_NAME( &dbname ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_MX;
                prr->Data.MX.wPreference = htons( 20 );
                memcpy(
                    &prr->Data.MX.nameExchange,
                    &dbname,
                    SIZEOF_DB_NAME( &dbname ) );
                break;
            }

            case DNS_TYPE_A:

                //  At the zone root return 3 arbitrary A records.
                
                prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_A;
                prr->Data.A.ipAddress = inet_addr( "1.1.1.1" );

                prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_A;
                prr->Data.A.ipAddress = inet_addr( "2.2.2.2" );

                prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
                CheckNewRRPointer( prr );
                prr->wType = DNS_TYPE_A;
                prr->Data.A.ipAddress = inet_addr( "3.3.3.3" );
                break;

            default:
                status = DNS_PLUGIN_NO_RECORDS;
                break;
        }
    }
    else if ( _stricmp( pszQueryName, "www." PLUGIN_ZONE_NAME ) == 0 ||
                    _stricmp( pszQueryName, "mail1." PLUGIN_ZONE_NAME ) == 0 ||
                    _stricmp( pszQueryName, "mail2." PLUGIN_ZONE_NAME ) == 0 )
    {
        if ( wQueryType == DNS_TYPE_A )
        {
            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.1" );

            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.2" );

            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.3" );

            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.4" );
        }
        else
        {
            status = DNS_PLUGIN_NO_RECORDS;
        }
    }
    else if ( _stricmp( pszQueryName, "ns1." PLUGIN_ZONE_NAME ) == 0 )
    {
        if ( wQueryType == DNS_TYPE_A )
        {
            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.50" );
        }
        else
        {
            status = DNS_PLUGIN_NO_RECORDS;
        }
    }
    else if ( _stricmp( pszQueryName, "ns2." PLUGIN_ZONE_NAME ) == 0 )
    {
        if ( wQueryType == DNS_TYPE_A )
        {
            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "100.100.100.51" );
        }
        else
        {
            status = DNS_PLUGIN_NO_RECORDS;
        }
    }
    else if ( strstr( pszQueryName, "aaa" ) )
    {
        //
        //  For any other queried name in the zone that contains "aaa", 
        //  return an arbitrary A record. Note: using strstr here is
        //  a bad idea. All string comparisons should be case insensitive.
        //
        
        if ( wQueryType == DNS_TYPE_A )
        {
            prr = g_pDnsAllocate( sizeof( IP4_ADDRESS ) );
            CheckNewRRPointer( prr );
            prr->wType = DNS_TYPE_A;
            prr->Data.A.ipAddress = inet_addr( "1.2.3.4" );
            prr->dwTtlSeconds = 1200;
        }
        else
        {
            status = DNS_PLUGIN_NO_RECORDS;
        }
    }
    else
    {
        status = DNS_PLUGIN_NAME_ERROR;
    }
    
    Done:

    if ( status == DNS_PLUGIN_NO_RECORDS || status == DNS_PLUGIN_NAME_ERROR )
    {
        //
        //  Return the zone SOA.
        //

        DB_NAME     dbnamePrimaryServer;
        DB_NAME     dbnameZoneAdmin;

        if ( convertDottedNameToDbName(
                "ns1." PLUGIN_ZONE_NAME,
                &dbnamePrimaryServer ) != ERROR_SUCCESS )
        {
            goto Return;
        }
        if ( convertDottedNameToDbName(
                "admin." PLUGIN_ZONE_NAME,
                &dbnameZoneAdmin ) != ERROR_SUCCESS )
        {
            goto Return;
        }

        prr = g_pDnsAllocate(
                    sizeof( DWORD ) * 5 +
                    SIZEOF_DB_NAME( &dbnamePrimaryServer ) +
                    SIZEOF_DB_NAME( &dbnameZoneAdmin ) );
        CheckNewRRPointer( prr );
        prr->wType = DNS_TYPE_SOA;
        prr->Data.SOA.dwSerialNo = htonl( 1000 );
        prr->Data.SOA.dwRefresh = htonl( 3600 );
        prr->Data.SOA.dwRetry = htonl( 600 );
        prr->Data.SOA.dwExpire = htonl( 1800 );
        prr->Data.SOA.dwMinimumTtl = htonl( 60 );
        memcpy(
            &prr->Data.SOA.namePrimaryServer,
            &dbnamePrimaryServer,
            SIZEOF_DB_NAME( &dbnamePrimaryServer ) );
        memcpy(
            ( PBYTE ) &prr->Data.SOA.namePrimaryServer +
                SIZEOF_DB_NAME( &dbnamePrimaryServer ),
            &dbnameZoneAdmin,
            SIZEOF_DB_NAME( &dbnameZoneAdmin ) );
        
        //
        //  Set owner name for the SOA.
        //
        
        if ( pszRecordOwnerName )
        {
            strcpy( pszRecordOwnerName, PLUGIN_ZONE_NAME );
        }
    }    
    else if ( status != ERROR_SUCCESS )
    {
        PDB_RECORD      prrnext;
        
        //
        //  On failure free any records allocated.
        //

        for ( prr = *ppDnsRecordListHead; prr; prr = prrnext )
        {
            prrnext = prr->pRRNext;
            g_pDnsFree( prr );
        }
        *ppDnsRecordListHead = NULL;
    }

    Return:
        
    return status;
}   //  DnsPluginQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\client.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    client.c

Abstract:

    Domain Name System (DNS) Server

    Routines for DNS server acting as client to another DNS.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

--*/


#include "dnssrv.h"



PDNS_MSGINFO
Msg_CreateSendMessage(
    IN      DWORD   dwBufferLength
    )
/*++

Routine Description:

    Create DNS message.

    Message is setup with cleared header fields, and packet
    ptr set to byte immediately following header.

    Caller is reponsible for setting non-zero header fields and
    writing actual question.

Arguments:

    dwBufferLength -- length of message buffer; pass zero to
        allocate a standard UDP message or non-zero to allocate
        a TCP message with specified buffer length

Return Value:

    Ptr to message structure if successful.
    NULL on allocation error.

--*/
{
    PDNS_MSGINFO    pMsg;

    //
    //  allocate message info structure with desired message buffer size
    //

    if ( dwBufferLength == 0 )
    {
        pMsg = Packet_AllocateUdpMessage();
    }
    else
    {
        ASSERT( dwBufferLength > DNSSRV_UDP_PACKET_BUFFER_LENGTH );
        pMsg = Packet_AllocateTcpMessage( dwBufferLength );
    }

    IF_NOMEM( !pMsg )
    {
        DNS_PRINT(( "ERROR:  unable to allocate memory for query\n" ));
        return NULL;
    }
    ASSERT( pMsg->BufferLength >= DNSSRV_UDP_PACKET_BUFFER_LENGTH );

    //
    //  clear message header
    //

    RtlZeroMemory(
        ( PCHAR ) DNS_HEADER_PTR( pMsg ),
        sizeof ( DNS_HEADER ) );

    //
    //  init message buffer fields
    //      - set to write immediately after header
    //      - set for NO delete on send
    //

    pMsg->pCurrent = pMsg->MessageBody;
    pMsg->fDelete = FALSE;

    //
    //  initialize message socket
    //      - caller MUST choose remote IP address
    //

    pMsg->Socket = g_UdpSendSocket;
    DnsAddr_Reset( &pMsg->RemoteAddr );
    pMsg->RemoteAddr.SockaddrIn6.sin6_family = AF_INET;
    pMsg->RemoteAddr.SockaddrIn6.sin6_port = DNS_PORT_NET_ORDER;
    
    return pMsg;
}   //  Msg_CreateMessage




BOOL
FASTCALL
Msg_WriteQuestion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Write question to packet.

    Note:  Routine DOES NOT clear message info or message header.
    This is optimized for use immediately following Msg_CreateMessage().

Arguments:

    pMsg - message info

    pNode - node in database of domain name to write

    wType - question type

Return Value:

    TRUE if successful
    FALSE if lookup or packet space error

--*/
{
    PCHAR   pch;
    WORD    netType;

    ASSERT( pMsg );
    ASSERT( pNode );

    //  restart write at message header

    pch = pMsg->MessageBody;

    //
    //  write question
    //      - node name
    //      - question structure

    pch = Name_PlaceFullNodeNameInPacket(
            pch,
            pMsg->pBufferEnd,
            pNode );

    if ( !pch  ||  pMsg->pBufferEnd - pch < sizeof( DNS_QUESTION) )
    {
        DNS_PRINT((
            "ERROR:  unable to write question to msg at %p\n"
            "    for domain node at %p\n"
            "    buffer length = %d\n",
            pMsg,
            pNode,
            pMsg->BufferLength ));

        Dbg_DbaseNode(
            "ERROR:  unable to write question for node",
            pNode );
        Dbg_DnsMessage(
            "Failed writing question to message:",
            pMsg );

        ASSERT( FALSE );
        return FALSE;
    }

    pMsg->pQuestion = (PDNS_QUESTION) pch;
    pMsg->wQuestionType = wType;

    INLINE_HTONS( netType, wType )
    *(UNALIGNED WORD *) pch = netType;
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = (WORD) DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    pMsg->Head.QuestionCount = 1;

    //
    //  set message length info
    //      - setting MessageLength itself for case of root NS query, where
    //        this message is copied, rather than directly sent
    //

    pMsg->pCurrent = pch;
    pMsg->MessageLength = DNSMSG_OFFSET( pMsg, pch );

    return TRUE;
}



BOOL
Msg_MakeTcpConnection(
    IN      PDNS_MSGINFO    pMsg,
    IN      PDNS_ADDR       ipServer,
    IN      PDNS_ADDR       ipBind,         OPTIONAL
    IN      DWORD           Flags           OPTIONAL
    )
/*++

Routine Description:

    Connect TCP socket to desired server.

    Note, returned message info structure is setup with CLEAR DNS
    except:
        - XID set
        - set to query
    And message length info set to write after header.

    Caller is reponsible for setting non-zero header fields and
    writing actual question.

Arguments:

    pMsg -- message info to set with connection socket

    ipServer -- IP of DNS server to connect to

    ipBind -- IP to bind to, may be NULL

    Flags -- flags to Sock_CreateSocket()
        interesting ones are
            - DNSSOCK_BLOCKING if want blocking
            - DNSSOCK_NO_ENLIST for socket to reside in connections list rather
                    than main socket list

Return Value:

    TRUE if successful.
    FALSE on connect error.

--*/
{
    SOCKET      s;
    INT         err;
    DNS_ADDR    inaddrAny;

    ASSERT( ipServer );
    
    if ( ipBind == NULL )
    {
        DnsAddr_Reset( &inaddrAny );
        DnsAddr_Family( &inaddrAny ) = DnsAddr_Family( ipServer );
        ipBind = &inaddrAny;
    }
    
    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //

    ASSERT( DnsAddr_Family( ipServer ) == DnsAddr_Family( ipBind ) );
    
    DnsAddr_SetPort( ipBind, 0 );
    
    s = Sock_CreateSocket(
            SOCK_STREAM,
            ipBind,
            Flags );
    if ( s == DNS_INVALID_SOCKET )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  unable to create TCP socket to create TCP"
            "    connection to %s\n",
            DNSADDR_STRING( ipServer ) ));
        pMsg->Socket = 0;
        return FALSE;
    }

    //
    //  set TCP params
    //      - do before connect(), so can directly use sockaddr buffer
    //

    pMsg->fTcp = TRUE;
    DnsAddr_Copy( &pMsg->RemoteAddr, ipServer );

    //
    //  connect
    //

    err = connect(
            s,
            &pMsg->RemoteAddr.Sockaddr,
            pMsg->RemoteAddr.SockaddrLength );
    if ( err )
    {
        PCHAR   pchIpString;

        err = GetLastError();

        if ( err != WSAEWOULDBLOCK )
        {
            CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

            DnsAddr_WriteIpString_A( szaddr, &pMsg->RemoteAddr );

            pchIpString = szaddr;

            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_CONNECT_TO_SERVER,
                1,
                &pchIpString,
                EVENTARG_ALL_UTF8,
                err );

            DNS_DEBUG( TCP, (
                "Unable to establish TCP connection to %s\n",
                pchIpString ));

            Sock_CloseSocket( s );
            pMsg->Socket = 0;
            return FALSE;
        }
    }

    pMsg->Socket = s;
    return TRUE;
}   // Msg_MakeTcpConnection



BOOL
Msg_ValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    )
/*++

Routine Description:

    Validate response received from another DNS.

    Sets up information about response in message info:
        pQuestion       -- points at question
        wQuestionType   -- set
        pCurrent        -- points at first answer RR

    Note, RCODE check is left to the caller.

Arguments:

    pResponse - info for response received from DNS

    pQuery - info for query sent to DNS

    wType - question known, may set type;  MUST indicate type if doing
            zone transfer, as BIND feels free to ignore setting XID and
            Response flag in zone transfers

Return Value:

    TRUE if response is valid.
    FALSE if error.

--*/
{
    PCHAR           pch;
    PDNS_QUESTION   presponseQuestion;
    PDNS_QUESTION   pqueryQuestion = NULL;

    ASSERT( pResponse != NULL );

    DNS_DEBUG( RECV, (
        "Msg_ValidateResponse() for packet at %p\n"
        "%s",
        pResponse,
        pQuery
            ?   ""
            :   "    validating without original query specified!\n" ));

    //
    //  validating with original question
    //      - save type, need single place to check for zone transfer
    //      - match XID (though AXFR packets may have zero XID)
    //

    if ( pQuery )
    {
        wType = pQuery->wQuestionType;

        if ( pQuery->Head.Xid != pResponse->Head.Xid
                &&
             (  ( pResponse->Head.Xid != 0 ) ||
                ( wType != DNS_TYPE_AXFR && wType != DNS_TYPE_IXFR ) ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Response XID does not match query\n"
                "    query xid    = %hd\n"
                "    response xid = %hd\n",
                pQuery->Head.Xid,
                pResponse->Head.Xid ));
            goto Fail;
        }
    }

    //
    //  check opcode
    //

    if ( OpCode && (DWORD)pResponse->Head.Opcode != OpCode )
    {
        DNS_DEBUG( ANY, ( "ERROR:  Bad opcode in response from server\n" ));
        goto Fail;
    }

    //
    //  check response
    //      - may not be set on zone transfer
    //

    if ( !pResponse->Head.IsResponse  &&  wType != DNS_TYPE_AXFR )
    {
        DNS_DEBUG( ANY, ( "ERROR:  Response flag not set in response from server\n" ));
        goto Fail;
    }

    //
    //  if question repeated, verify
    //

    if ( pResponse->Head.QuestionCount > 0 )
    {
        if ( pResponse->Head.QuestionCount != 1 )
        {
            DNS_DEBUG( ANY, ( "Multiple questions in response\n" ));
            goto Fail;
        }

        //
        //  break out internal pointers
        //      - do it once here, then use FASTCALL to pass down
        //
        //  save off question, in case request is requeued
        //

        pch = pResponse->MessageBody;

        presponseQuestion = (PDNS_QUESTION) Wire_SkipPacketName(
                                                pResponse,
                                                (PCHAR)pch );
        if ( !presponseQuestion )
        {
            goto Fail;
        }
        pResponse->pQuestion = presponseQuestion;

        pResponse->wQuestionType = FlipUnalignedWord( &presponseQuestion->QuestionType );
        pResponse->pCurrent = (PCHAR) (presponseQuestion + 1);

        //
        //  compare response's question to expected
        //      - from query's question
        //      - from expected type
        //

        if ( wType && pResponse->wQuestionType != wType )
        {
            DNS_DEBUG( ANY, ( "ERROR:  Response question does NOT expected type\n" ));
            goto Fail;
        }
    }

    //
    //  no question is valid
    //

    else
    {
        pResponse->pCurrent = pResponse->MessageBody;
        pResponse->pQuestion = NULL;
        pResponse->wQuestionType = 0;
    }

    DNS_DEBUG( RECV, (
        "Msg_ValidateResponse() succeeds for packet at %p\n",
        pResponse ));

    return TRUE;

Fail:

    //
    //  DEVNOTE-LOG: could log bad response packets
    //

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Bad response packet:",
            pResponse );
    }
    return FALSE;
}



BOOL
Msg_NewValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    )
/*++

Routine Description:

    Validate response received from a remote DNS server by verifying
    that the question in the response matches the original.
    
    Does not modify any fields in response or query messages. Does
    not check RCODE in response.

    Jeff W: I copied and cleaned up the original copy of this funciton
    above. The original isn't 100% useful because it has side effects
    that other parts of the code relies up. This is spaghetti code.

Arguments:

    pResponse - response received from remote server

    pQuery - query sent to remote server

    wType - expected question type in response - this argument is
            ignored if pQuery is not NULL

    OpCode - expected opcode in response - this argument is
             ignored if pQuery is not NULL

Return Value:

    TRUE if response is valid, else FALSE.

--*/
{
    ASSERT( pResponse != NULL );

    DNS_DEBUG( RECV, (
        "Msg_NewValidateResponse(): type=%d opcode=%d\n"
        "    resp=%p query=%p\n",
        ( int ) wType,
        ( int ) OpCode,
        pResponse,
        pQuery ));

        wType = pQuery->wQuestionType;

    //
    //  Check XID. XID is allowed not to match for XFR responses.
    //

    if ( pQuery )
    {
        if ( pQuery->Head.Xid != pResponse->Head.Xid &&
             ( ( pResponse->Head.Xid != 0 ) ||
               ( wType != DNS_TYPE_AXFR && wType != DNS_TYPE_IXFR ) ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR: response XID %hd does not match query XID %hd\n",
                pResponse->Head.Xid,
                pQuery->Head.Xid ));
            goto Fail;
        }
    }

    //
    //  Check opcode.
    //

    if ( pQuery )
    {
        OpCode = ( DWORD ) pQuery->Head.Opcode;
    }
    if ( OpCode && ( DWORD ) pResponse->Head.Opcode != OpCode )
    {
        DNS_DEBUG( ANY, (
            "ERROR: bad opcode %d in response\n",
            ( DWORD ) pResponse->Head.Opcode ));
        goto Fail;
    }

    //
    //  Check response bit. Optional if query is AXFR.
    //

    if ( !pResponse->Head.IsResponse && wType != DNS_TYPE_AXFR )
    {
        DNS_DEBUG( ANY, ( "ERROR: response bit not set in response\n" ));
        goto Fail;
    }

    //
    //  Match question if we have one.
    //

    if ( pQuery &&
        pResponse->Head.QuestionCount > 0 &&
        pQuery->Head.QuestionCount == pResponse->Head.QuestionCount )
    {
        PCHAR           pchresp = pResponse->MessageBody;
        PCHAR           pchquery = pQuery->MessageBody;
        LOOKUP_NAME     queryLookupName;
        LOOKUP_NAME     respLookupName;
        PDNS_QUESTION   prespQuestion;
        PDNS_QUESTION   pqueryQuestion;

        if ( pResponse->Head.QuestionCount != 1 )
        {
            DNS_DEBUG( ANY, ( "Multiple questions in response\n" ));
            goto Fail;
        }

        //
        //  Compare question names.
        //

        if ( !Name_ConvertRawNameToLookupName(
                pchresp,
                &respLookupName ) ||
             !Name_ConvertRawNameToLookupName(
                pchquery,
                &queryLookupName ) )
        {
            DNS_DEBUG( ANY, (
                "Found invalid question name (unable to convert)\n" ));
            goto Fail;
        }
        if ( !Name_CompareLookupNames(
                &respLookupName,
                &queryLookupName ) )
        {
            DNS_DEBUG( ANY, (
                "Lookup names don't match\n" ));
            goto Fail;
        }

        //
        //  Compare types.
        //

        prespQuestion = ( PDNS_QUESTION ) Wire_SkipPacketName(
                                                pResponse,
                                                ( PCHAR ) pchresp );
        pqueryQuestion = ( PDNS_QUESTION ) Wire_SkipPacketName(
                                                pQuery,
                                                ( PCHAR ) pchquery );
        if ( !prespQuestion || !pqueryQuestion )
        {
            DNS_DEBUG( ANY, (
                "Unable to skip question name\n" ));
            goto Fail;
        }
        if ( wType &&
             wType != FlipUnalignedWord( &prespQuestion->QuestionType ) )
        {
            DNS_DEBUG( ANY, (
                "Response question type %d does not match expected type %d\n",
                FlipUnalignedWord( &prespQuestion->QuestionType ),
                wType ));
            goto Fail;
        }
    }

    return TRUE;

    Fail:

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Msg_NewValidateResponse found bad response packet:",
            pResponse );
    }
    return FALSE;
}


//
//  End of client.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dbase.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dbase.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database routines.

Author:

    Jim Gilroy (jamesg)     March 10, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Database -- only IN (Internet class supported)
//

DNS_DATABASE    g_Database;

//
//  Cache "zone"
//
//  Cache "zone" will always exist.
//  However, only have root-hints when not root authoritative.
//
//  Local node, marks no-forwarding domain.  Queries for "xxx.local" are
//  not forwarded (unless actually authoritative for higher domain and
//  doing referral).
//

PZONE_INFO  g_pCacheZone;

PDB_NODE    g_pCacheLocalNode;


//
//  Non-deletable nodes reference count
//

#define NO_DELETE_REF_COUNT (0x7fff)



//
//  Database locking
//
//  Lock database with one critical section
//
//  Need locking for:
//      - sibling list in tree
//      - resource record list
//      - writing data (flags) at nodes
//
//  Ideally have locking for all access to node to handle all three,
//  but this expensive -- if use resource or CS per node -- or difficult
//  to do efficiently -- must hold CS to lock and unlock node and have
//  something to wait on (event).  Even then must hold multiple locks
//  as walk down tree.
//
//  Could try separate locking for three cases above.  But then must acquire
//  two locks to do basic operations which entail tree list and access flag,
//  or RR list and access flag.
//
//  Simple solution is ONE database lock.  Causes a few more thread context
//  switches, but simple and effective.
//


CRITICAL_SECTION    DbaseLockCs;
DWORD               DbaseLockCount;
DWORD               DbaseLockThread;

LPSTR               DbaseLockFile;
DWORD               DbaseLockLine;
PDB_NODE            DbaseLockNode;
PVOID               pDbaseLockHistory;



VOID
Dbg_DbaseLock(
    VOID
    )
/*++

Routine Description:

    Debug print database locking info.

Arguments:

    None

Return Value:

    None

--*/
{
    PDB_NODE    pnode = DbaseLockNode;

    DnsPrintf(
        "Database locking info:\n"
        "\tthread   = %d\n"
        "\tcount    = %d\n"
        "\tfile     = %s\n"
        "\tline     = %d\n"
        "\tnode     = %p (%s)\n",
        DbaseLockThread,
        DbaseLockCount,
        DbaseLockFile,
        DbaseLockLine,
        pnode,
        ( pnode ? pnode->szLabel : "none" )
        );
}



VOID
Dbase_LockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Database locking function.

Arguments:

    pNode -- ptr to node to add resource record to

    pszFile -- source file holding lock

    dwLine -- line number holding lock

Return Value:

    None

--*/
{
    EnterCriticalSection( &DbaseLockCs );
    DbaseLockCount++;

    if ( DbaseLockCount == 1 )
    {
        DbaseLockFile = pszFile;
        DbaseLockLine = dwLine;
        DbaseLockNode = pNode;

        //IF_DEBUG( ANY )
        //{
            DbaseLockThread = GetCurrentThreadId();
        //}
    }

    DNS_DEBUG( LOCK2, (
        "Database LOCK (%d) (thread=%d) (n=%p) %s, line %d\n",
        DbaseLockCount,
        DbaseLockThread,
        pNode,
        pszFile,
        dwLine ));
}



VOID
Dbase_UnlockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Database locking function.

Arguments:

    pNode -- ptr to node to add resource record to

    pszFile -- source file holding lock

    dwLine -- line number holding lock

Return Value:

    None

--*/
{
    DNS_DEBUG( LOCK2, (
        "Database UNLOCK (%d) (thread=%d) (n=%p) %s, line %d\n",
        DbaseLockCount-1,
        DbaseLockThread,
        pNode,
        pszFile,
        dwLine ));

    if ( (LONG)DbaseLockCount <= 0 )
    {
        ASSERT( FALSE );
        return;
    }
    else if ( DbaseLockThread != GetCurrentThreadId() )
    {
        ASSERT( FALSE );
        return;
    }

    DbaseLockCount--;

    LeaveCriticalSection( &DbaseLockCs );
}



BOOL
Dbase_IsLockedByThread(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Check if database is locked by current thread.

Arguments:

    pNode -- ptr to node to check if locked

Return Value:

    None

--*/
{
    DWORD   threadId = GetCurrentThreadId();

    if ( threadId != DbaseLockThread )
    {
        DNS_DEBUG( DATABASE, (
            "ERROR:  Database NOT locked by calling thread (%d)!!!\n",
            threadId ));
        IF_DEBUG( DATABASE )
        {
            Dbg_DbaseLock();
        }
        return FALSE;
    }

    return TRUE;
}



//
//  Basic database utilities
//

BOOL
Dbase_Initialize(
    IN OUT      PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Initialize a DNS database.

Arguments:

    pDbase -- ptr to database struct

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //
    //  cache zone
    //

    g_pCacheZone = NULL;
    g_pCacheLocalNode = NULL;

    //
    //  init global database lock
    //

    DbaseLockCount     = 0;
    DbaseLockFile      = NULL;
    DbaseLockLine      = 0;
    DbaseLockThread    = 0;
    DbaseLockNode      = NULL;
    pDbaseLockHistory  = NULL;

    if ( DnsInitializeCriticalSection( &DbaseLockCs ) != ERROR_SUCCESS )
    {
        goto fail;
    }

    //
    //  create zone tree root for database
    //

    pDbase->pRootNode = NTree_Initialize();
    if ( ! pDbase->pRootNode )
    {
        goto fail;
    }
    SET_ZONE_ROOT( pDbase->pRootNode );

    //
    //  create reverse lookup domain
    //
    //  handle to keep node around, so have easy access to it,
    //      and know it is there to test if nodes are within it
    //

    pDbase->pReverseNode    = Lookup_CreateZoneTreeNode( "in-addr.arpa" );
    pDbase->pIP6Node        = Lookup_CreateZoneTreeNode( "ip6.arpa" );

    if ( ! pDbase->pReverseNode ||
         ! pDbase->pIP6Node )
    {
        goto fail;
    }
    pDbase->pIntNode    = pDbase->pIP6Node->pParent;
    pDbase->pArpaNode   = pDbase->pReverseNode->pParent;

    //
    //  set database nodes to NO DELETE
    //

    SET_NODE_NO_DELETE( pDbase->pRootNode );
    SET_NODE_NO_DELETE( pDbase->pReverseNode );
    SET_NODE_NO_DELETE( pDbase->pIP6Node );

    DNS_DEBUG( DATABASE, (
        "Created database.\n"
        "\tpnodeRoot = %p\n"
        "\tRoot node label = %s\n"
        "\tRoot node label length = %d\n"
        "\tpnodeReverse = %p\n"
        "\tReverse node label = %s\n"
        "\tReverse node label length = %d\n",
        pDbase->pRootNode,
        pDbase->pRootNode->szLabel,
        pDbase->pRootNode->cchLabelLength,
        pDbase->pReverseNode,
        pDbase->pReverseNode->szLabel,
        pDbase->pReverseNode->cchLabelLength
        ));

    return TRUE;

fail:

    DNS_PRINT(( "ERROR:  FAILED to create database.\n" ));
    return FALSE;
}



VOID
Dbase_Delete(
    IN OUT  PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Delete the database, freeing all nodes and resource records.

    Note, that the walk is done UNLOCKED!

    For AXFR temp databases, this is not an issue, as single thread
    is owner.

    For permanent database:
        - shutdown only with single thread active
        - other deletes must lock out timeout thread, and
        NTree_RemoveNode grabs lock

Arguments:

    pDbase -- ptr to database

Return Value:

    None

--*/
{
    NTSTATUS status;

    //
    //  verify database initialized
    //

    if ( ! pDbase->pRootNode )
    {
        return;
    }

    //
    //  delete DNS tree
    //

    IF_DEBUG( DATABASE2 )
    {
        Dbg_DnsTree(
            "Database before delete:\n",
            pDbase->pRootNode );
    }

    NTree_DeleteSubtree( pDbase->pRootNode );

    //
    //  note:  don't delete database structure, currently it
    //          is on the stack in the zone receive thread
    //
}



//
//  Database load utilities
//

BOOL
traverseAndCheckDatabaseAfterLoad(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Check database for startup.

Arguments:

    pTreeNode -- ptr to root node

    pvDummy -- unused

    pvdwMinimumTtl -- min TTL for current zone in net byte order

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    //
    //  check zone roots
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        PZONE_INFO  pzone = pNode->pZone;

        //
        //  authoritative zones root
        //
        //  if active must have
        //      - valid zone root
        //      - SOA record at root
        //

        if ( pzone  &&  ! IS_ZONE_SHUTDOWN(pzone) )
        {
            PDB_NODE    pnodeZoneRoot;

            pnodeZoneRoot = pzone->pZoneRoot;
            if ( !pnodeZoneRoot )
            {
                ASSERT( FALSE );
                return FALSE;
            }
            ASSERT( pnodeZoneRoot->pZone == pzone );
            ASSERT( IS_AUTH_ZONE_ROOT(pnodeZoneRoot) );
            ASSERT( IS_ZONE_ROOT(pnodeZoneRoot) );

            if ( ! RR_FindNextRecord(
                        pnodeZoneRoot,
                        DNS_TYPE_SOA,
                        NULL,
                        0 ) )
            {
#if 0
                DNS_LOG_EVENT(
                    DNS_EVENT_AUTHORITATIVE_ZONE_WITHOUT_SOA,
                    1,
                    & pzone->pwsZoneName,
                    NULL,
                    0 );
#endif
                IF_DEBUG( ANY )
                {
                    Dbg_DbaseNode(
                        "Node with missing SOA: ",
                        pNode );
                    Dbg_Zone(
                        "Zone with missing SOA: ",
                        pzone );
                    Dbg_DnsTree(
                        "Database with missing SOA:\n",
                        DATABASE_ROOT_NODE );
                }
                ASSERT( FALSE );
                return FALSE;
            }
        }
    }

    //
    //  recurse to check children
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild;

        pchild = NTree_FirstChild( pNode );
        ASSERT( pchild );

        while ( pchild )
        {
            if ( ! traverseAndCheckDatabaseAfterLoad( pchild ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return TRUE;
}



BOOL
Dbase_StartupCheck(
    IN OUT  PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Check database tree for validity, and set flags (Authority)
    and TTL values in all nodes.

    The reason we do NOT do this during parsing, is the difficulty
    of identifying sub-zone (glue) records before knowing zone boundaries.

Arguments:

    pRootNode -- ptr to root node

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PDB_NODE    pnodeRoot;

    //
    //  verify either
    //      - root authoritative
    //      - forwarding
    //      - have root-hints NS at root
    //

    if ( IS_ROOT_AUTHORITATIVE() )
    {
        return TRUE;
    }

    if ( SrvCfg_aipForwarders )
    {
        return TRUE;
    }

    if ( ! RR_FindNextRecord(
                ROOT_HINTS_TREE_ROOT(),
                DNS_TYPE_NS,
                NULL,
                0 ) )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_NO_ROOT_NAME_SERVER,
            0,
            NULL,
            NULL,
            0 );
    }
    return TRUE;
}

//
//  End of dbase.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dbase.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dbase.h

Abstract:

    Domain Name System (DNS) Server

    DNS Database definitions and declarations.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

--*/


#ifndef _DBASE_INCLUDED_
#define _DBASE_INCLUDED_


//
//  Database type
//

typedef struct
{
    PDB_NODE    pRootNode;
    PDB_NODE    pReverseNode;
    PDB_NODE    pArpaNode;
    PDB_NODE    pIP6Node;
    PDB_NODE    pIntNode;
}
DNS_DATABASE, *PDNS_DATABASE;


//
//  DNS Database global.
//
//  Since only IN (Internet) class is supported, will code critical
//  path routines with fixed access to database global.
//

extern  DNS_DATABASE    g_Database;

#define DATABASE_FOR_CLASS(_class_)     (&g_Database)

#define DATABASE_ROOT_NODE              (g_Database.pRootNode)
#define DATABASE_ZONE_TREE              (g_Database.pRootNode)

#define DATABASE_ARPA_NODE              (g_Database.pArpaNode)
#define DATABASE_REVERSE_NODE           (g_Database.pReverseNode)
#define DATABASE_INT_NODE               (g_Database.pIntNode)
#define DATABASE_IP6_NODE               (g_Database.pIP6Node)

#define IS_ROOT_AUTHORITATIVE()         (DATABASE_ROOT_NODE->pZone)

//
//  Cache "zone"
//
//  Cache "zone" should always exist.  It holds cache tree pointers
//  and file name \ database info and simplifies load\clear\reload
//  operations.
//
//  However, only have root-hints when not root authoritative.
//  Currently root-hints are saved directly into cache tree.   This
//  has some benefit as we can use RR rank to determine which remote
//  servers to chase.
//  The disadvantages:
//      - must clear cache on root hint reload (or accept mess)
//      - can't write back non-root root hints (i.e. can't tree traverse)
//      - requires special RANK check in RR lists, which otherwise would
//          not exists (all data at given RR set would necessarily be same rank)
//

extern  PZONE_INFO  g_pCacheZone;

extern  PDB_NODE    g_pCacheLocalNode;

#define DATABASE_CACHE_TREE             (g_pCacheZone->pTreeRoot)


//
//  Root hints
//
//  Currently root hints just reside in cache.
//  This is probably less than optimal for management purposes,
//  so will distinguish so code hit is minimal if we change later.
//

#define g_pRootHintsZone    (g_pCacheZone)

#define MARK_ROOT_HINTS_DIRTY() \
        if ( g_pRootHintsZone ) \
        {                       \
            g_pRootHintsZone->fDirty = TRUE;    \
            g_pRootHintsZone->bNsDirty = TRUE;  \
        }

#define ROOT_HINTS_TREE_ROOT()      (g_pRootHintsZone->pTreeRoot)

#define IS_ZONE_ROOTHINTS(pZone)    ((pZone) == g_pRootHintsZone)


//
//  DNS Database type routines (dbase.c)
//

BOOL
Dbase_Initialize(
    OUT     PDNS_DATABASE   pDbase
    );

BOOL
Dbase_StartupCheck(
    IN OUT  PDNS_DATABASE   pDbase
    );

VOID
Dbase_Delete(
    IN OUT  PDNS_DATABASE   pDbase
    );

BOOL
Dbase_TraverseAndFree(
    IN OUT  PDB_NODE        pNode,
    IN      PVOID           fShutdown,
    IN      PVOID           pvDummy
    );



//
//  Database lookup (dblook.c)
//

#define LOOKUP_FIND                 0x00000001
#define LOOKUP_CREATE               0x00000002
#define LOOKUP_REFERENECE           0x00000004
#define LOOKUP_CACHE_CREATE         0x00000008

#define LOOKUP_NAME_FQDN            0x00000010
#define LOOKUP_NAME_RELATIVE        0x00000020
#define LOOKUP_FQDN                 LOOKUP_NAME_FQDN
#define LOOKUP_RELATIVE             LOOKUP_NAME_RELATIVE

#define LOOKUP_RAW                  0x00000040
#define LOOKUP_DBASE_NAME           0x00000080

#define LOOKUP_LOAD                 0x00000100
#define LOOKUP_WITHIN_ZONE          0x00000200
#define LOOKUP_ORIGIN               0x00000400

//
//  Create node if zone is WINS enabled
//
#define LOOKUP_WINS_ZONE_CREATE     0x00000800  

#define LOOKUP_BEST_RANK            0x00001000

//
//  Lookup_CreateParentZoneDelegation: if this flag is set only create
//  the delegation in the parent zone if there is no existing delegation.
//
#define LOOKUP_CREATE_DEL_ONLY_IF_NONE   0x00002000

//  NS\Additional lookup options
#define LOOKUP_OUTSIDE_GLUE         0x00010000
#define LOOKUP_NO_CACHE_DATA        0x00020000
#define LOOKUP_CACHE_PRIORITY       0x00040000  // give priority to cache data

//  Zone tree lookup
#define LOOKUP_FIND_ZONE            0x01000000
#define LOOKUP_MATCH_ZONE           0x02000000
#define LOOKUP_CREATE_ZONE          0x04000000
#define LOOKUP_IGNORE_FORWARDER     0x08000000  // do not match forwarder zones

#define LOOKUP_MATCH_ZONE_ROOT      (LOOKUP_FIND_ZONE | LOOKUP_MATCH_ZONE)

#define LOOKUP_FILE_LOAD_RELATIVE   (LOOKUP_LOAD | LOOKUP_RELATIVE | LOOKUP_ORIGIN)

#define LOOKUP_LOCKED               0x10000000


//  phony "find closest node" pointers
//      - FIND when closest node not wanted

#define DNS_FIND_LOOKUP_PTR         ((PVOID)(-1))
#define LOOKUP_FIND_PTR             (DNS_FIND_LOOKUP_PTR)


//
//  Zone lookup
//

PDB_NODE
Lookup_ZoneNode(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,            OPTIONAL
    IN      PDNS_MSGINFO    pMsg,               OPTIONAL
    IN      PLOOKUP_NAME    pLookupName,        OPTIONAL
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppNodeClosest,      OPTIONAL
    OUT     PDB_NODE *      ppNodePrevious      OPTIONAL
    );

//  Zone lookup with dotted name parameters

PDB_NODE
Lookup_ZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag,         OPTIONAL
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDNS_STATUS     pStatus         OPTIONAL
    );

PDB_NODE
Lookup_FindZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PCHAR           pszName,
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDWORD          pStatus         OPTIONAL
    );


//  Specialized zone lookup

PDB_NODE
Lookup_FindNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    );

PDB_NODE
Lookup_FindGlueNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    );

PDB_NODE
Lookup_CreateNodeForDbaseNameIfInZone(
    IN      PZONE_INFO      pZone,
    IN      PDB_NAME        pName
    );

PDB_NODE
Lookup_CreateCacheNodeFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PCHAR *         ppchName
    );

PDB_NODE
Lookup_CreateParentZoneDelegation(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppParentZone
    );


//
//  Zone tree lookup
//

PDB_NODE
Lookup_ZoneTreeNode(
    IN      PLOOKUP_NAME    pLookupName,
    IN      DWORD           dwFlag
    );

PZONE_INFO
Lookup_ZoneForPacketName(
    IN      PCHAR           pchPacketName,
    IN      PDNS_MSGINFO    pMsg                OPTIONAL
    );

//
//  Dotted lookup in zone tree
//      - zone find\create
//      - standard database nodes
//

PDB_NODE
Lookup_ZoneTreeNodeFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag
    );

#define Lookup_CreateZoneTreeNode(pszName) \
        Lookup_ZoneTreeNodeFromDottedName( \
                (pszName),  \
                0,          \
                LOOKUP_CREATE_ZONE )



//
//  General lookup (not in specific zone)
//
//  This structure defines the results of the general lookup.
//  It fully describes the state of the name in the database
//  zone, delegation and cache.
//

typedef struct
{
    PDB_NODE    pNode;
    PDB_NODE    pNodeClosest;
    PZONE_INFO  pZone;
    PDB_NODE    pNodeDelegation;
    PDB_NODE    pNodeGlue;
    PDB_NODE    pNodeCache;
    PDB_NODE    pNodeCacheClosest;
}
LOOKUP_RESULT, *PLOOKUP_RESULT;


PDB_NODE
Lookup_Node(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,
    IN      WORD            wType,      OPTIONAL
    OUT     PLOOKUP_RESULT  pResult
    );


//
//  Query lookup
//      - writes info to message buffer

PDB_NODE
Lookup_NodeForPacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag
    );


//  Lookup database name

PDB_NODE
Lookup_NsHostNode(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    IN      PZONE_INFO      pZone,
    OUT     PDB_NODE *      ppDelegation
    );

PDB_NODE
Lookup_DbaseName(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppDelegationNode
    );

#if 0
#define Lookup_FindDbaseName(pName) \
        Lookup_DbaseName( (pName), 0, NULL );

#define Lookup_FindNsHost(pName)   \
        Lookup_FindDbaseName(pName)
#endif


PDB_NODE
Lookup_FindNodeForIpAddress(
    IN      PDNS_ADDR       pDnsAddr,
    IN      DWORD           dwFlag,
    IN      PDB_NODE *      ppNodeFind
    );


//
//  Database node utilities (dblook.c)
//

BOOL
Dbase_IsNodeInSubtree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    );

BOOL
Dbase_IsNodeInSubtreeByLabelCompare(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    );
      
#define Dbase_IsNodeInReverseIP4LookupDomain( pNode, pDbase ) \
            Dbase_IsNodeInSubtree( (pNode), (pDbase)->pReverseNode )

#define Dbase_IsNodeInReverseIP6LookupDomain( pNode, pDbase ) \
            Dbase_IsNodeInSubtree( (pNode), (pDbase)->pIP6Node )

#define Dbase_IsReverseLookupNode( pNode ) \
            Dbase_IsNodeInSubtree(    \
                (pNode),            \
                DATABASE_REVERSE_NODE  )

PZONE_INFO
Dbase_FindAuthoritativeZone(
    IN      PDB_NODE     pNode
    );

PDB_NODE
Dbase_FindSubZoneRoot(
    IN      PDB_NODE     pNode
    );



//
//  Lock database with one critical section
//
//  Need locking for:
//      - sibling list in tree
//      - resource record list
//      - writing data (flags) at nodes
//
//  Ideally have locking for all access to node to handle all three,
//  but this expensive -- if use resource or CS per node -- or difficult
//  to do efficiently -- must hold CS to lock and unlock node and have
//  something to wait on (event).  Even then must hold multiple locks
//  as walk down tree.
//
//  Could try separate locking for three cases above.  But then must acquire
//  two locks to do basic operations which entail tree list and access flag,
//  or RR list and access flag.
//
//  Simple solution is ONE database lock.  Causes a few more thread context
//  switches, but simple and effective.
//

#define Dbase_LockDatabase()  \
        Dbase_LockEx( NULL, __FILE__, __LINE__ );

#define Dbase_UnlockDatabase() \
        Dbase_UnlockEx( NULL, __FILE__, __LINE__ );

VOID
Dbase_LockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dbase_UnlockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

//
//  Node locking
//
//  Macroize node locking.  This hides the fact that currently node locking
//  is global.  If later want to roll out individual node locking to improve
//  MP performance, then the change is relatively easy.
//

#define LOCK_NODE(pNode)        Dbase_LockEx( pNode, __FILE__, __LINE__ );
#define UNLOCK_NODE(pNode)      Dbase_UnlockEx( pNode, __FILE__, __LINE__ );

//
//  Zone database locking
//
//  Macroize zone database locking.
//
//  DEVNOTE: should make zone locks atomic
//      JJW: crit sec is used in underlying function - it is atomic already?
//

#define LOCK_ZONE_DATABASE( pZone )     Dbase_LockDatabase()
#define UNLOCK_ZONE_DATABASE( pZone )   Dbase_UnlockDatabase()

//
//  RR List locking
//
//  Currently locking entire database, but setup to handle as
//  separate operation.
//

#define LOCK_RR_LIST(pNode)             Dbase_LockEx( pNode, __FILE__, __LINE__ );
#define UNLOCK_RR_LIST(pNode)           Dbase_UnlockEx( pNode, __FILE__, __LINE__ );

#define LOCK_READ_RR_LIST(pNode)        LOCK_RR_LIST(pNode)
#define UNLOCK_READ_RR_LIST(pNode)      UNLOCK_RR_LIST(pNode)

#define LOCK_WRITE_RR_LIST(pNode)       LOCK_RR_LIST(pNode)
#define UNLOCK_WRITE_RR_LIST(pNode)     UNLOCK_RR_LIST(pNode)

#define DUMMY_LOCK_RR_LIST(pNode)       DNS_DEBUG( LOCK, ( "DummyRR_LOCK(%p)\n", pNode ));
#define DUMMY_UNLOCK_RR_LIST(pNode)     DNS_DEBUG( LOCK, ( "DummyRR_UNLOCK(%p)\n", pNode ));

//
//  Lock verification
//
//  ASSERT macros provide easy way to macro-out unnecessary lock\unlock calls
//  while providing check that in fact lock is already held.
//  Functions can be coded with these ASSERT_LOCK \ ASSERT_UNLOCK macros
//  in the correct lock\unlock positions to improve code maintenance.
//  The actual check (node is locked) is the same for lock or unlock.
//

BOOL
Dbase_IsLockedByThread(
    IN OUT  PDB_NODE        pNode
    );

#define IS_LOCKED_NODE(pNode)           Dbase_IsLockedByThread( pNode )

#define ASSERT_LOCK_NODE(pnode)         ASSERT( IS_LOCKED_NODE(pnode) )
#define ASSERT_UNLOCK_NODE(pnode)       ASSERT( !IS_LOCKED_NODE(pnode) )

#define IS_LOCKED_RR_LIST(pNode)        IS_LOCKED_NODE( pNode )

#define ASSERT_LOCK_RR_LIST(pnode)      ASSERT( IS_LOCKED_RR_LIST(pnode) )
#define ASSERT_UNLOCK_RR_LIST(pnode)    ASSERT( !IS_LOCKED_RR_LIST(pnode) )


VOID
Dbg_DbaseLock(
    VOID
    );


#if 0
PDB_NODE
Name_GetNodeForIpAddressString(
    IN      LPSTR       pszIp
    );

PDB_NODE
Name_GetNodeForIpAddress(
    IN      LPSTR           pszIp,
    IN      DNS_ADDR        ipAddress,
    IN      PDB_NODE *      ppNodeFind
    );
#endif


#endif  //  _DBASE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dblook.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dblook.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database lookup routine.

Author:

    Jim Gilroy (jamesg)     May 1998

Revision History:

--*/


#include "dnssrv.h"



//
//  Direct to zone lookup routines
//

PDB_NODE
Lookup_ZoneNode(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,            OPTIONAL
    IN      PDNS_MSGINFO    pMsg,               OPTIONAL
    IN      PLOOKUP_NAME    pLookupName,        OPTIONAL
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppNodeClosest,      OPTIONAL
    OUT     PDB_NODE *      ppNodePrevious      OPTIONAL
    )
/*++

Routine Description:

    Finds node in zone.

Arguments:

    pZone - zone to lookup node in

    pchName - name to lookup given in packet format

    pMsg - ptr to message if using packet name

    pLookupName - lookup name

    NOTE: specify only ONE of pLookupName or pchName

    dwFlag - flags describing query type

    ppNodeClosest - addr to receive ptr to closest node found
                - valid ptr us in "Find Mode"
                - NULL puts us in "Create Mode" causing creation of all
                    necessary nodes to add name to database

    ppNodePrevious - ptr to receive node that precedes the lookup name
        in the zone tree - used to create NXT records in response (DNSSEC)

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    ULONG           cchlabel;
    PCHAR           pchlabel = NULL;        // need to init for wildcard test
    PDB_NODE        pnodeParent = NULL;     // PPC compiler happiness
    INT             labelCount;
    BOOL            fcreateInsideZone;
    BOOL            fcreate;
    LOOKUP_NAME     lookname;               // in case lookup name not given
    UCHAR           authority;
    DWORD           dwNodeMemtag = 0;       // zero results in generic tag

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneNode()\n"
        "    zone     = %s\n"
        "    pchName  = %p\n"
        "    pMsg     = %p\n"
        "    pLookup  = %p\n"
        "    flag     = %p\n"
        "    ppClose  = %p\n",
        pZone ? pZone->pszZoneName : "NULL -- cache zone",
        pchName,
        pMsg,
        pLookupName,
        dwFlag,
        ppNodeClosest ));

    //
    //  Set lookup flags
    //      - default to standard "create" node case
    //
    //  Check "find" closest ptr
    //  Special cases:
    //      fake FIND ptr => find but don't bother returning closest
    //
    //  DEVNOTE: eliminate bogus PTR, just use find flag
    //

    if ( ppNodeClosest )
    {
        fcreate = dwFlag & ( LOOKUP_CREATE |
            ( ( pZone && IS_ZONE_WINS( pZone ) ) ? LOOKUP_WINS_ZONE_CREATE : 0 ) );

        fcreateInsideZone = fcreate;

        if ( ppNodeClosest == DNS_FIND_LOOKUP_PTR )
        {
            ppNodeClosest = NULL;
        }
    }
    else
    {
        fcreate = !(dwFlag & LOOKUP_FIND);
        fcreateInsideZone = fcreate;
    }

    //
    //  if raw name, build lookup name
    //
    //  if message, first check if name is offset that we have already parsed
    //

    if ( pchName )
    {
        IF_DEBUG( LOOKUP )
        {
            Dbg_MessageName(
                "Lookup_ZoneNode() name to lookup:  ",
                pchName,
                pMsg );
        }
        ASSERT( pLookupName == NULL );

        pLookupName = &lookname;

        if ( pMsg )
        {
            pnode = Name_CheckCompressionForPacketName(
                        pMsg,
                        pchName );
            if ( pnode )
            {
                goto DoneFast;
            }
            if ( !Name_ConvertPacketNameToLookupName(
                        pMsg,
                        pchName,
                        pLookupName ) )
            {
                pnode = NULL;
                goto DoneFast;
            }
            //  packet names are always FQDN
            dwFlag |= LOOKUP_FQDN;
        }

        //
        //  raw name, not from packet
        //

        else
        {
            if ( ! Name_ConvertRawNameToLookupName(
                        pchName,
                        pLookupName ) )
            {
                pnode = NULL;
                goto DoneFast;
            }
        }
    }
    ASSERT( pLookupName );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Lookup_ZoneNode() to %s domain name",
             ppNodeClosest ? "find" : "add" ));
        Dbg_LookupName(
            "",
            pLookupName );
    }

    //
    //  Get starting node
    //      - if FQDN we start at top
    //      - relative name we start at zone root
    //      - if loading start in load database, otherwise in current
    //

    if ( !pZone )
    {
        if ( !(dwFlag & LOOKUP_LOAD) )
        {
            pnode = DATABASE_CACHE_TREE;
            dwNodeMemtag = MEMTAG_NODE_CACHE;
        }
        else
        {
            pnode = g_pCacheZone->pLoadTreeRoot;
        }
        ASSERT( pnode );
    }
    else if ( dwFlag & LOOKUP_NAME_FQDN )
    {
        if ( dwFlag & LOOKUP_LOAD )
        {
            pnode = pZone->pLoadTreeRoot;
        }
        else
        {
            pnode = pZone->pTreeRoot;
            if ( !pnode )
            {
                DNS_PRINT((
                    "ERROR:  lookup to zone %s with no tree root!\n"
                    "    Substituting pLoadTreeRoot %p\n",
                    pZone->pszZoneName,
                    pZone->pLoadTreeRoot ));

                pnode = pZone->pLoadTreeRoot;
            }
        }

        //  create new node ONLY inside zone itself?
        //      - start with create flag off;  it will be
        //      turned on when cross zone boundary
        //      - note, root zone requires special case
        //      as you are ALREADY at zone root

        if ( dwFlag & LOOKUP_WITHIN_ZONE  &&  !IS_ROOT_ZONE(pZone) )
        {
            fcreate = FALSE;
        }
    }
    else
    {
        ASSERT( dwFlag & LOOKUP_NAME_RELATIVE );

        if ( dwFlag & LOOKUP_LOAD )
        {
            if ( dwFlag & LOOKUP_ORIGIN )
            {
                pnode = pZone->pLoadOrigin;
            }
            else
            {
                pnode = pZone->pLoadZoneRoot;
            }
        }
        else
        {
            pnode = pZone->pZoneRoot;
            if ( !pnode )
            {
                DNS_PRINT((
                    "ERROR:  lookup to zone %s with no zone root!\n"
                    "    Substituting pLoadZoneRoot %p\n",
                    pZone->pszZoneName,
                    pZone->pLoadZoneRoot ));

                pnode = pZone->pLoadZoneRoot;
            }
        }
    }

    if ( !pnode )
    {
        DNS_DEBUG( LOOKUP, (
            "WARNING:  Zone %s lookup with no zone trees!\n",
            pZone->pszZoneName ));
        goto DoneFast;
    }

    //
    //  clear cache "zone" ptr to avoid ptr drag down (see below)
    //
    //  DEVNOTE: alternatives are to either
    //      - get comfy with pZone in cache tree
    //      - don't drag zone ptr (which is nice for splices and joins)
    //      - ASSERT() here and find where we call with cache "zone"
    //

    if ( pZone && IS_ZONE_CACHE(pZone) )
    {
        pZone = NULL;
    }

    //  starting authority corresponds to node

    authority = pnode->uchAuthority;

    DNS_DEBUG( LOOKUP2, (
        "Lookup start node %p (%s) in zone %p\n",
        pnode, pnode->szLabel,
        pZone ));

    //
    //  Walk down database.
    //
    //  In "find mode", return NULL if node not found.
    //
    //  In "create node", build nodes as necessary.
    //
    //  In either case, if reach node, return it.
    //
    //  Lookup name is packet name with labels in root-to-node order.
    //  but still terminated with 0.
    //

    labelCount = pLookupName->cLabelCount;

    if ( !(dwFlag & LOOKUP_LOCKED) )
    {
        Dbase_LockDatabase();
    }

    while( labelCount-- )
    {
        //
        //  get next label and its length
        //

        pchlabel  = pLookupName->pchLabelArray[labelCount];
        cchlabel  = pLookupName->cchLabelArray[labelCount];

        DNS_DEBUG( LOOKUP2, (
            "Lookup length %d, label %.*s\n",
            cchlabel,
            cchlabel,
            pchlabel ));

        ASSERT( cchlabel <= DNS_MAX_LABEL_LENGTH );
        ASSERT( cchlabel > 0 );

        //
        //  find or create node
        //

        pnodeParent = pnode;
        pnode = NTree_FindOrCreateChildNode(
                        pnodeParent,
                        pchlabel,
                        cchlabel,
                        fcreate,
                        dwNodeMemtag,           //  memtag
                        ppNodePrevious );

        //
        //  node found
        //

        if ( pnode )
        {
            ASSERT( pnode->cLabelCount == pnodeParent->cLabelCount+1 );

            DNS_DEBUG( DATABASE2, (
                "Found (or created) node %s\n",
                pnode->szLabel ));

            //
            //  drag\reset authority
            //      this allows changes (delegations, delegation removals, splices)
            //      to propagate down through the tree on lookup
            //
            //      note:  this doesn't elminate transients completely, but when a
            //      node is looked up, it will have correct authority

            if ( pZone )
            {
                if ( IS_ZONE_ROOT(pnode) )
                {
                    if ( IS_AUTH_ZONE_ROOT(pnode) )     // crossing into the zone
                    {
                        ASSERT( pZone->pZoneRoot == pnode || pZone->pLoadZoneRoot == pnode );
                        fcreate = fcreateInsideZone;
                        authority = AUTH_ZONE;
                        pnode->uchAuthority = authority;
                    }
                    else if ( authority == AUTH_ZONE )  // crossing into delegation
                    {
                        pnode->uchAuthority = AUTH_DELEGATION;
                        authority = AUTH_GLUE;
                    }
                }
                else
                {
                    pnode->uchAuthority = authority;
                }
            }

            //  DEVNOTE: drag zone down for zone splice
            //      otherwise skip it
            //      already inherit zone from parent on create
            //
            //  DEVNOTE: this currently is dragging cache "zone"
            //      down into cache tree

            pnode->pZone = pZone;

            IF_DEBUG( DATABASE2 )
            {
                Dbg_DbaseNode(
                    "Found (or created) domain node:\n",
                    pnode );
            }
            continue;
        }

        //  name does not exist

        DNS_DEBUG( DATABASE2, (
            "Node %.*s does not exist\n",
            cchlabel,
            pchlabel ));
        break;

    }   //  end main loop through labels

    //
    //  node found
    //      - mark as accessed -- so can't be deleted
    //
    //  for "create and reference mode" lookup
    //      - bump up reference count to indicate new reference
    //

    if ( pnode )
    {
        SET_NODE_ACCESSED( pnode );

        //  "find mode", set closest as node itself

        if ( ppNodeClosest )
        {
            *ppNodeClosest = pnode;
        }

        //  "create mode", mark parent of wildcard nodes
        //
        //  note:  don't care about screening out cached nodes, the
        //      wildcard lookup won't take place unless authoritative
        //      and not checking allows

        else if ( pchlabel && *pchlabel == '*' && cchlabel == 1 )
        {
            SET_WILDCARD_PARENT(pnodeParent);
        }
    }

    //
    //  node not found - return closest ancestor
    //
    //  note:  still need to test here, as may fail in "create mode"
    //          to actually create node if out of memory
    //

    else if ( ppNodeClosest )
    {
        SET_NODE_ACCESSED(pnodeParent);
        *ppNodeClosest = pnodeParent;
    }

    //
    //  Set previous node accessed so it will persist for a while.
    //

    if ( ppNodePrevious && *ppNodePrevious )
    {
        SET_NODE_ACCESSED( *ppNodePrevious );
    }

    //
    //  unlock and return node for name
    //

    if ( !(dwFlag & LOOKUP_LOCKED) )
    {
        Dbase_UnlockDatabase();
    }

    //  if packet lookup, save compression to node
    //
    //  DEVNOTE: double saved compression
    //      answer.c explicitly calls SaveCompressionForLookupName()
    //      so need to be intelligent about this
    //
    //  best to have compression-node mapping saved for XFR, but only
    //  real interesting case is to save to PreviousName, which is
    //  used repeatedly
    //

    if ( pMsg && pnode )
    {
        Name_SaveCompressionWithNode(
            pMsg,
            pchName,
            pnode );
    }

    return pnode;

    DoneFast:

    //  either node found without lookup (packet compression)
    //  or error and node is NULL

    if ( pnode )
    {
        SET_NODE_ACCESSED( pnode );
    }
    if ( ppNodeClosest )
    {   
        *ppNodeClosest = pnode;
    }

    return pnode;
}



PDB_NODE
Lookup_ZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag,         OPTIONAL
    OUT     PDB_NODE *      ppnodeClosest,  OPTIONAL
    OUT     PDNS_STATUS     pStatus         OPTIONAL
    )
/*++

Routine Description:

    Creates node in database giving name and zone.

    Essentially wraps creation of lookup name with call to actual
    find/create node.

Arguments:

    pZone           -- zone

    pchName         -- ptr to name

    cchNameLength   -- name length

    dwFlag          -- lookup flags; most importantly
        - LOOKUP_LOAD on load
        - LOOKUP_FQDN to force names to be considered as FQDN

    ppnodeClosest   -- address to recieve node's closest ancestor;
                        if specified then lookup is a "FIND",
                        if not specified, then lookup is a "CREATE"

    pStatus         -- addr to receive status

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DWORD           statusName;
    LOOKUP_NAME     lookName;

    if ( !pchName )
    {
        goto NameError;
    }

    //
    //  name length for string
    //

    if ( cchNameLength == 0 )
    {
        cchNameLength = strlen( pchName );
    }

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneNodeFromDotted()\n"
        "    zone     = %s\n"
        "    pchName  = %.*s\n"
        "    flag     = %p\n",
        pZone ? pZone->pszZoneName : NULL,
        cchNameLength,
        pchName,
        dwFlag ));

    //
    //  determine type of name
    //      - FQDN
    //      - dotted but not FQDN
    //      - single part
    //

    statusName = Dns_ValidateAndCategorizeDnsName( pchName, cchNameLength );

    //  most common case -- FQDN or dotted name with no append
    //      => no-op

    if ( statusName == DNS_STATUS_FQDN )
    {
        dwFlag |= LOOKUP_FQDN;
    }

    //  kick out on errors

    else if ( statusName == DNS_ERROR_INVALID_NAME )
    {
        goto NameError;
    }

    //  on dotted name or single part name
    //      - might be FQDN, if not set relative name flag

    else
    {
        ASSERT( statusName == DNS_STATUS_DOTTED_NAME ||
                statusName == DNS_STATUS_SINGLE_PART_NAME );

        if ( !(dwFlag & LOOKUP_FQDN) )
        {
            dwFlag |= LOOKUP_RELATIVE;
        }

        //
        //  origin "@" notation
        //      - return current origin (start node or zone root)
        //

        if ( *pchName == '@' )
        {
            if ( cchNameLength != 1 )
            {
                goto NameError;
            }
            ASSERT( statusName == DNS_STATUS_SINGLE_PART_NAME );

            if ( pStatus )
            {
                *pStatus = ERROR_SUCCESS;
            }
            if ( !pZone )
            {
                pnode = g_pCacheZone->pTreeRoot;
            }
            else if ( dwFlag & LOOKUP_LOAD )
            {
                if ( pZone->pLoadOrigin )
                {
                    pnode = pZone->pLoadOrigin;
                }
                else
                {
                    pnode = pZone->pLoadZoneRoot;
                }
            }
            else
            {
                pnode = pZone->pZoneRoot;
            }

            //  set closest node and return current origin
            //
            //  DEVNOTE:  eliminate bogus PTR, just use find flag

            if ( ppnodeClosest && ppnodeClosest != DNS_FIND_LOOKUP_PTR )
            {
                *ppnodeClosest = pnode;
            }
            return pnode;
        }
    }

    //
    //  regular name -- convert to lookup name
    //

    if ( ! Name_ConvertDottedNameToLookupName(
                (PCHAR) pchName,
                cchNameLength,
                &lookName ) )
    {
        goto NameError;
    }

    //
    //  valid lookup name -- do lookup
    //

    pnode = Lookup_ZoneNode(
                pZone,
                NULL,       //  sending lookup name
                NULL,       //  no message
                &lookName,
                dwFlag,
                ppnodeClosest,
                NULL );     //  previous node ptr
    if ( pStatus )
    {
        if ( pnode )
        {
            *pStatus = ERROR_SUCCESS;
        }
        else if ( ppnodeClosest )       // find case
        {
            *pStatus = DNS_ERROR_NAME_DOES_NOT_EXIST;
        }
        else                            // create case
        {
            *pStatus = DNS_ERROR_NODE_CREATION_FAILED;
        }
    }
    return pnode;

NameError:

    DNS_DEBUG( DATABASE2, (
        "ERROR: failed invalid name %.*s lookup.\n",
        cchNameLength,
        pchName ));
    if ( pStatus )
    {
        *pStatus = DNS_ERROR_INVALID_NAME;
    }
    return NULL;
}



PDB_NODE
Lookup_FindZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PCHAR           pszName,
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDWORD          pStatus         OPTIONAL
    )
/*++

Routine Description:

    Find zone node.

    This handles attempt to find zone node, with assuming FQDN name,
    then assuming relative name.

Arguments:

    pZone -- zone for lookup;  NULL for cache

    pszName -- name FQDN or single part name

    ppNodeClosest -- closest node ptr for find

    pStatus -- addr to receive status return

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;

    DNS_DEBUG( LOOKUP, (
        "Lookup_FindZoneNodeFromDotted()\n"
        "    zone     = %s\n"
        "    pszName  = %s\n",
        pZone ? pZone->pszZoneName : NULL,
        pszName ));

    //
    //  try first with zone context, NO appending to name
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                pszName,
                0,
                LOOKUP_FQDN,
                ppNodeClosest,      // find
                pStatus );

    //
    //  if find zone node => done
    //
    //  DEVNOTE: later may want to limit return of node's IN a zone,
    //      when no zone given
    //  DEVNOTE: flags should determine if want delegation info\ outside info
    //

    if ( pnode && ( !pZone || !IS_OUTSIDE_ZONE_NODE( pnode ) ) )
    {
        return pnode;
    }

    //
    //  otherwise try again with zone context and append
    //

    return Lookup_ZoneNodeFromDotted(
                pZone,
                pszName,
                0,
                LOOKUP_RELATIVE,
                ppNodeClosest,      // find
                pStatus );
}



PDB_NODE
Lookup_FindGlueNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Finds desired GLUE node in database.
    If node is IN zone, then it is NOT returned.

    This function exists to simplify writing GLUE for XFR, DS or file write.
    It writes glue ONLY from specified zone.

Arguments:

    pZone   - zone to look in;  if not given assume cache

    pName   - dbase name to find glue node for

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;


    DNS_DEBUG( LOOKUP, (
        "Lookup_FindGlueNodeForDbaseName()\n"
        "    zone     = %s\n"
        "    pName    = %p\n",
        pZone ? pZone->pszZoneName : NULL,
        pName ));

    //
    //  lookup node in zone
    //

    pnode = Lookup_ZoneNode(
                pZone,
                pName->RawName,
                NULL,                   //  no message
                NULL,                   //  no lookup name
                LOOKUP_NAME_FQDN,       //  flag
                DNS_FIND_LOOKUP_PTR,
                NULL );                 //  previous node ptr
    if ( !pnode )
    {
        return NULL;
    }

    //  if cache zone (anything ok)

    if ( !pZone || IS_ZONE_CACHE(pZone) )
    {
        return pnode;
    }

    IF_DEBUG( LOOKUP )
    {
        Dbg_DbaseNode(
            "Glue node found:",
            pnode );
    }

    //
    //  verify that node is NOT in zone
    //  zone nodes aren't needed as they are written directly by
    //      - AXFR
    //      - file write
    //      - DS write
    //  outside zone glue isn't need
    //  so subzone nodes are only required nodes
    //

    if ( IS_AUTH_NODE(pnode) )
    {
        ASSERT( pnode->pZone == pZone );
        return NULL;
    }

    //
    //  subzone glue should be return
    //
    //  outside zone glue returned, if flag not set
    //  outside zone glue can help with FAZ cases at zone roots
    //      generally allow its use
    //

    //
    //  DEVNOTE: check other zone's on SERVER?
    //      subzone glue AND especially OUTSIDE glue, might have
    //      authoritative data on server;  sure be nice to use
    //      it (and even copy it over) if it exists
    //

    if ( IS_SUBZONE_NODE(pnode) || !SrvCfg_fDeleteOutsideGlue )
    {
        return pnode;
    }

    //  outside zone glue, being screened out

    ASSERT( IS_OUTSIDE_ZONE_NODE(pnode) );

    return NULL;
}



PDB_NODE
Lookup_FindNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Finds node for desired DB_NAME in database.

Arguments:

    pZone   - zone to look in;  if not given assume cache

    pName   - dbase name to find glue node for

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;

    DNS_DEBUG( LOOKUP, (
        "Lookup_FindNodeForDbaseName()\n"
        "    zone     = %s\n"
        "    pName    = %p\n",
        pZone ? pZone->pszZoneName : NULL,
        pName ));

    pnode = Lookup_ZoneNode(
                pZone,
                pName->RawName,
                NULL,                   //  no message
                NULL,                   //  no lookup name
                LOOKUP_NAME_FQDN,       //  flag
                DNS_FIND_LOOKUP_PTR,
                NULL );                 //  previous node ptr

    return pnode;
}



PDB_NODE
Lookup_CreateNodeForDbaseNameIfInZone(
    IN      PZONE_INFO      pZone,
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Create node for DBASE name, only if name owned by given zone.

Arguments:

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;

    //
    //  lookup in zone
    //      - create mode but only WITHIN zone
    //

    pnode = Lookup_ZoneNode(
                pZone,
                pName->RawName,
                NULL,           //  no message
                NULL,           //  no lookup name
                LOOKUP_FQDN | LOOKUP_CREATE | LOOKUP_WITHIN_ZONE,
                NULL,           //  create mode
                NULL );         //  previous node ptr

    return pnode;
}



PDB_NODE
Lookup_CreateCacheNodeFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PCHAR *         ppchName
    )
/*++

Routine Description:

    Create cache node from packet name.

Arguments:

    pMsg        - message to point to

    ppchName    - addr with ptr to packet name, and which receives packet
                    ptr to next byte after name

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PCHAR       pch = *ppchName;
    PDB_NODE    pnode;

    //
    //  ensure name within packet
    //

    if ( pch >= pchMsgEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet, bad name in packet!!!\n"
            "    at end of packet processing name with more records to process\n"
            "    packet length = %ld\n"
            "    current offset = %ld\n",
            pMsg->MessageLength,
            DNSMSG_OFFSET( pMsg, pch ) ));
        CLIENT_ASSERT( FALSE );
        return NULL;
    }


    //
    //  lookup node in zone
    //

    pnode = Lookup_ZoneNode(
                NULL,               //  cache zone
                pch,
                pMsg,
                NULL,               //  no lookup name
                0,                  //  flag
                NULL,               //  create
                NULL );             //  previous node ptr
    if ( !pnode )
    {
        DNS_DEBUG( ANY, (
            "Bad packet name at %p in message at %p\n"
            "    from %s\n",
            pch,
            pMsg,
            pMsg ? MSG_IP_STRING( pMsg ) : NULL ));
        return NULL;
    }

    //  skip name to return ptr to next byte

    pch = Wire_SkipPacketName( pMsg, pch );
    if ( ! pch )
    {
        DNS_PRINT(( "ERROR:  skipping packet name!!!\n" ));
        MSG_ASSERT( pMsg, FALSE );
        return NULL;
    }

    *ppchName = pch;

    return pnode;
}



PDB_NODE
Lookup_CreateParentZoneDelegation(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppParentZone
    )
/*++

Routine Description:

    Find delegation of given zone in parent zone.

    Note:  delegation is created\returned:

        - AUTH node if not yet delegated
        - delegation node if exists
        - NULL if below another delegation

    This routine respects the value of SrvCfg_dwAutoCreateDelegations.

Arguments:

    pZone -- zone to find parent delegation for

    dwFlag -- respected flags:
                LOOKUP_CREATE_DEL_ONLY_IF_NONE

    ppParentZone -- addr to receive parent zone

Return Value:

    Delegation node in parent zone (if any)
    NULL if no parent or not direct parent and flag was set.

--*/
{
    PZONE_INFO  parentZone = NULL;
    PDB_NODE    pzoneTreeNode;
    PDB_NODE    pnodeDelegation = NULL;
    DWORD       flag;

    //
    //  protection
    //

    if ( IS_ZONE_CACHE(pZone) ||
         ! pZone->pCountName ||
         ! pZone->pZoneTreeLink )
    {
        // return NULL;
        pnodeDelegation = NULL;
        goto Done;
    }

    //
    //  find parent zone in zone tree
    //

    pzoneTreeNode = pZone->pZoneTreeLink;

    while ( pzoneTreeNode = pzoneTreeNode->pParent )
    {
        parentZone = pzoneTreeNode->pZone;
        if ( parentZone )
        {
            ASSERT( parentZone != pZone );
            break;
        }
    }

    //
    //  find\create delegation node
    //      - for primary CREATE
    //      - for secondary FIND
    //
    //  accept:
    //      - existing delegation
    //      - auth node (child zone is new creation)
    //  but ignore subdelegation
    //
    //  JENHANCE:  don't create if below delegation
    //

    if ( parentZone )
    {
        int     retry = 0;

        flag = LOOKUP_FQDN | LOOKUP_WITHIN_ZONE;
        if ( IS_ZONE_SECONDARY( parentZone ) ||
            dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE )
        {
            flag |= LOOKUP_FIND;
        }

        while ( retry++ < 2 )
        {
            pnodeDelegation = Lookup_ZoneNode(
                                parentZone,
                                pZone->pCountName->RawName,
                                NULL,                   // no message
                                NULL,                   // no lookup name
                                flag,
                                NULL,                   // default to create
                                NULL );                 // previous node ptr

            DNS_DEBUG( LOOKUP, (
                "Lookup_CreateParentZoneDelegation() try %d flag 0x%08X node %p\n",
                retry,
                flag,
                pnodeDelegation ));

            if ( pnodeDelegation )
            {
                ASSERT( IS_AUTH_NODE( pnodeDelegation ) ||
                        IS_DELEGATION_NODE( pnodeDelegation ) ||
                        IS_GLUE_NODE( pnodeDelegation ) );

                if ( IS_GLUE_NODE( pnodeDelegation ) )
                {
                    pnodeDelegation = NULL;
                }
                break;
            }

            if ( dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE )
            {
                //
                //  No existing delegation was found so now we must call
                //  the lookup routine again to create the delegation.
                //

                flag &= ~LOOKUP_FIND;
                continue;
            }
            break;
        }
        ASSERT(
            pnodeDelegation ||
            flag & LOOKUP_FIND ||
            dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE );
    }

Done:

    if ( ppParentZone )
    {
        *ppParentZone = parentZone;
    }

    return pnodeDelegation;
}



//
//  Node + Zone location utils
//

BOOL
Dbase_IsNodeInSubtree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    )
/*++

Routine Description:

    Is node in a given subtree.

Arguments:

    pNode -- node

    pSubtree -- subtree root node

Return Value:

    TRUE if pNode is child of pSubtree
    FALSE otherwise

--*/
{
    while ( pNode != NULL )
    {
        if ( pNode == pSubtree )
        {
            return TRUE;
        }
        pNode = pNode->pParent;
    }
    return FALSE;
}


BOOL
Dbase_IsNodeInSubtreeByLabelCompare(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    )
/*++

Routine Description:

    Is the FQDN represented by a node at or under the FQDN of a subtree?

    This function is useful to determine subtree membership when the 
    node pointer is in a different zone than the subtree pointer.

Arguments:

    pNode -- node

    pSubtree -- subtree root node

Return Value:

    TRUE if pNode is child by name of pSubtree
    FALSE otherwise

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    psubtreenode;
    UCHAR       subtreeLabelCount;

    //
    //  Verify node pointers.
    //

    if ( !pNode || !pSubtree )
    {
        return FALSE;
    }

    //
    //  Shortcut: if the subtree is deeper than the node then the node
    //  cannot be inside the subtree.
    //

    subtreeLabelCount = pSubtree->cLabelCount;

    if ( subtreeLabelCount > pNode->cLabelCount )
    {
        return FALSE;
    }

    //
    //  If the node and subtree belong to the same zone use the
    //  faster node pointer comparison function.
    //

    if ( NODE_ZONE( pNode ) == NODE_ZONE( pSubtree ) )
    {
        return Dbase_IsNodeInSubtree( pNode, pSubtree );
    }

    //
    //  Walk up the node tree to the name depth level of the subtree.
    //

    for ( pnode = pNode;
          pnode && pnode->cLabelCount > subtreeLabelCount;
          pnode = pnode->pParent );

    if ( !pnode )
    {
        ASSERT( pnode );
        return FALSE;
    }

    //
    //  Compare all labels at and above the current node with the
    //  corresponding labels in the subtree.
    //

    for ( psubtreenode = pSubtree;
          pnode && psubtreenode;
          pnode = pnode->pParent, psubtreenode = psubtreenode->pParent )
    {
        UCHAR   labelLength = pnode->cchLabelLength;

        if ( psubtreenode->cchLabelLength != labelLength ||
             !RtlEqualMemory( NTree_GetDowncasedLabel( pnode ),
                              NTree_GetDowncasedLabel( psubtreenode ),
                              labelLength ) )
        {
            return FALSE;
        }
    }

    ASSERT( pnode == NULL && psubtreenode == NULL );    //  tree sizes equal?

    return TRUE;
}   // Dbase_IsNodeInSubtreeByLabelCompare



PZONE_INFO
Dbase_FindAuthoritativeZone(
    IN      PDB_NODE     pNode
    )
/*++

Routine Description:

    Get zone for node, if authoritative.

Arguments:

    pNode -- node to find zone info

Return Value:

    Zone info of authoritative zone.
    NULL if non-authoritative node.

--*/
{
    if ( IS_AUTH_NODE(pNode) )
    {
        return pNode->pZone;
    }
    return NULL;
}



PDB_NODE
Dbase_FindSubZoneRoot(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get sub-zone root (delegation node) of this node.

    This function is used to check for whether glue records for a
    particular sub-zone are required.  They are required when host
    node is IN the subzone.

Arguments:

    pNode -- node to find if in sub-zone

Return Value:

    Sub-zone root node is in if found.
    NULL if node NOT in sub-zone of pZoneRoot.

--*/
{
    ASSERT( pNode );

    //
    //  if in zone proper -- bail
    //

    if ( IS_AUTH_NODE(pNode) )
    {
        return NULL;
    }

    while ( pNode != NULL )
    {
        ASSERT( IS_SUBZONE_NODE(pNode) );

        //  if find sub-zone root -- done
        //  otherwise move to parent

        if ( IS_ZONE_ROOT(pNode) )
        {
            ASSERT( IS_DELEGATION_NODE(pNode) );
            return pNode;
        }
        pNode = pNode->pParent;
    }

    //
    //  node not within zone at all
    //

    return NULL;
}



//
//  Zone tree
//
//  The zone tree is standard NTree, containing no data, but simply nodes for zone roots
//  of authoritative zones on server.  These nodes contain link to ZONE_INFO structure
//  which in turn has links to the individual zone trees and data for the zone.
//
//  When doing a general lookup -- not confined to specific zone -- closest zone is found
//  in zone tree, then lookup proceeds in that zone's tree.
//

#define LOCK_ZONETREE()         Dbase_LockDatabase()
#define UNLOCK_ZONETREE()       Dbase_UnlockDatabase()


PDB_NODE
Lookup_ZoneTreeNode(
    IN      PLOOKUP_NAME    pLookupName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Lookup node in zone tree.

Arguments:

    pLookupName - name to lookup

    dwFlag      - lookup flags

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    ULONG           cchlabel;
    PCHAR           pchlabel = NULL;        // need to init for wildcard test
    PDB_NODE        pzoneRootNode = NULL;
    BOOL            fcreateZone;
    INT             labelCount;

    //
    //  build lookup name
    //

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneTreeNode()\n"
        "    flag     = %p\n",
        dwFlag ));

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Lookup_ZoneTreeNode() lookup name",
            pLookupName );
    }

    //  set create flag only if creating new zone

    fcreateZone = ( dwFlag & LOOKUP_CREATE_ZONE );

    //  start lookup at main zone database root
    //      - if root-auth it may also be closest zone root

    pnode = DATABASE_ROOT_NODE;
    if ( pnode->pZone )
    {
        pzoneRootNode = pnode;
    }

    //
    //  Walk down database to find closest authoritative zone
    //

    labelCount = pLookupName->cLabelCount;

    LOCK_ZONETREE();

    while ( labelCount-- )
    {
        pchlabel = pLookupName->pchLabelArray[labelCount];
        cchlabel = pLookupName->cchLabelArray[labelCount];

        DNS_DEBUG( LOOKUP2, (
            "Lookup length %d, label %.*s\n",
            cchlabel,
            cchlabel,
            pchlabel ));

        ASSERT( cchlabel <= DNS_MAX_LABEL_LENGTH );
        ASSERT( cchlabel > 0 );

        //  find node for next label
        //      - only doing create for new zone creation

        pnode = NTree_FindOrCreateChildNode(
                        pnode,
                        pchlabel,
                        cchlabel,
                        fcreateZone,
                        0,              //  memtag
                        NULL );         //  ptr for previous node
        if ( !pnode )
        {
            DNS_DEBUG( DATABASE2, (
                "Node %.*s does not exist in zone tree.\n",
                cchlabel,
                pchlabel ));
            break;
        }

        //
        //  node found, if zone root, save zone info
        //
        //  do NOT allow drag down of zone ptr
        //  our paradigm is to have pZone ONLY at root, for easy delete\pause etc
        //      - currently NTree create inherits parent's pZone
        //

        if ( pnode->pZone )
        {
            if ( dwFlag & LOOKUP_IGNORE_FORWARDER &&
                IS_ZONE_FORWARDER( ( PZONE_INFO ) ( pnode->pZone ) ) )
            {
                continue;       //  Ignore forwarder zones if flag set.
            }

            if ( fcreateZone && pnode->pParent && pnode->pParent->pZone == pnode->pZone )
            {
                pnode->pZone = NULL;
                continue;
            }
            pzoneRootNode = pnode;

            DNS_DEBUG( DATABASE2, (
                "Found zone root %.*s in zone tree\n"
                "    pZone = %p\n"
                "    remaining label count = %d\n",
                cchlabel,
                pchlabel,
                pzoneRootNode->pZone,
                labelCount ));
        }
        ELSE_IF_DEBUG( DATABASE2 )
        {
            DNS_PRINT((
                "Found (or created) zone tree node %.*s\n",
                cchlabel,
                pchlabel ));
        }

    }   //  end main loop through labels


    //
    //  standard query sets no flag
    //      - simply FIND closest zone
    //

    if ( dwFlag )
    {
        //
        //  creating new zone, just return new node
        //      - caller must check for duplicates, etc.
        //

        if ( fcreateZone )
        {
            pzoneRootNode = pnode;
            if ( pzoneRootNode )
            {
                SET_ZONETREE_NODE( pzoneRootNode );
            }
        }

        //
        //  exact zone match
        //      - must have found matching node in tree, and it is zone node

        else if ( dwFlag & LOOKUP_MATCH_ZONE )
        {
            if ( !pnode || !pnode->pZone )
            {
                ASSERT( !pnode || pnode != pzoneRootNode );
                pzoneRootNode = NULL;
            }
        }
    }
#if 0
    else if ( pnode == DATABASE_REVERSE_ROOT )
    {
        pzoneRootNode = pnode;
    }
#endif

    //  return zonetree node for zone

    UNLOCK_ZONETREE();

    return pzoneRootNode;
}



PDB_NODE
Lookup_ZoneTreeNodeFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Finds or creates node in zone tree.

    Use for
        - new zone create
        - creating standard dbase nodes (reverse lookup nodes)
        - for finding zone

Arguments:

    pchName         -- ptr to name

    cchNameLength   -- name length

    dwFlag          -- lookup flags; most importantly
        0                   -- find closest zone
        LOOKUP_CREATE_ZONE  -- create node
        LOOKUP_MATCH_ZONE   -- exact match to existing zone node or fail

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countName;
    LOOKUP_NAME     lookupName;

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneTreeNodeFromDotted()\n"
        "    name     = %p\n"
        "    flag     = %p\n",
        pchName,
        dwFlag ));

    //
    //  three lookups
    //      - create (then no find flag)
    //      - find zone
    //      - find and match zone
    //

    //
    //  convert to lookup name
    //

    status = Name_ConvertFileNameToCountName(
                &countName,
                pchName,
                cchNameLength );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        return NULL;
    }

    if ( ! Name_ConvertRawNameToLookupName(
                countName.RawName,
                &lookupName ) )
    {
        ASSERT( FALSE );
        return NULL;
    }

    //
    //  find zone tree node
    //

    return Lookup_ZoneTreeNode(
                &lookupName,
                dwFlag );
}



PZONE_INFO
Lookup_ZoneForPacketName(
    IN      PCHAR           pchPacketName,
    IN      PDNS_MSGINFO    pMsg                OPTIONAL
    )
/*++

Routine Description:

    Find zone for packet name.

Arguments:

    pchPacketName   - name to lookup given in packet format.

    pMsg            - ptr to message, if using packet name.
                    note, no message ptrs are set;

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    LOOKUP_NAME     lookupName;

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneForPacketName()\n"
        "    pMsg     = %p\n"
        "    name     = %p\n",
        pMsg,
        pchPacketName ));

    //
    //  convert to lookup name
    //

    if ( ! Name_ConvertPacketNameToLookupName(
                pMsg,
                pchPacketName,
                &lookupName ) )
    {
        return NULL;
    }

    //
    //  find zone tree node
    //

    pnode = Lookup_ZoneTreeNode(
                &lookupName,
                LOOKUP_MATCH_ZONE );
    if ( pnode )
    {
        return ( PZONE_INFO ) pnode->pZone;
    }
    return NULL;
}



PDB_NODE
lookupNodeForPacketInCache(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,
    IN      PDB_NODE        pnodeGlue,
    IN      PLOOKUP_NAME    pLookupName,
    IN OUT  PDB_NODE *      ppnodeClosest,
    IN OUT  PDB_NODE *      ppnodeCache,
    IN OUT  PDB_NODE *      ppnodeCacheClosest,
    IN OUT  PDB_NODE *      ppnodeDelegation
    )
/*++

Routine Description:

    This is an internal function used by Lookup_NodeForPacket.

Arguments:

    See Lookup_NodeForPacket for usage.

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DWORD           flag;

    ASSERT( pLookupName );
    ASSERT( ppnodeClosest );
    ASSERT( ppnodeCache );
    ASSERT( ppnodeCacheClosest );
    ASSERT( ppnodeDelegation );
    ASSERT( ppnodeClosest );

    //
    //  cache lookup
    //
    //  DEVNOTE: again, even in cache should closest be last NS
    //
    //  "CACHE_CREATE" lookup flag, causes create in cache but not
    //  in ordinary zone;  this is useful for additional or CNAME
    //  chasing where want zone data -- if available -- but don't
    //  need node if it's empty;  however for cache nodes, want to
    //  create node so that can recurse for it
    //
    //  DEVNOTE: better is to skip this and have recursion work
    //      properly merely from closest node and offset;  however
    //      would still need to maintain zone\cache info in order
    //      to make decision about which nodes could recurse
    //

    flag = dwFlag | LOOKUP_NAME_FQDN;
    if ( flag & LOOKUP_CACHE_CREATE )
    {
        flag |= LOOKUP_CREATE;
    }

    pnode = Lookup_ZoneNode(
                NULL,
                NULL,
                NULL,
                pLookupName,
                flag,
                ppnodeClosest,
                NULL                // previous node ptr
                );

    *ppnodeCache = pnode;
    *ppnodeCacheClosest = *ppnodeClosest;

    ASSERT( !pnode || pnode->cLabelCount == pLookupName->cLabelCount );

    //
    //  detect if have delegation\glue with better data then cache
    //      if so, return it
    //  however always ANSWER non-auth questions from cache
    //      EXCEPT question asking NS query directly at delegation;
    //      the idea is that the delegation really is purpose of
    //      NS query, other queries should get auth-data
    //
    //  DEVOTE:  for additional, it's perhaps better to link cached
    //      answer\auth RR, to cache additional RR, and ditto for
    //      delegation info
    //
    //  note type==0 condition indicates dummy packet sent for by
    //  covering Lookup_Node() function;  in this case just go with
    //  best data
    //

    if ( pnodeGlue )
    {
        WORD    type = pMsg->wTypeCurrent;

        ASSERT( type );

        if ( dwFlag & LOOKUP_BEST_RANK ||
            !IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) ||
            (type == DNS_TYPE_NS  &&  IS_DELEGATION_NODE(pnodeGlue)) )
        {
            DWORD   rankGlue;
            DWORD   rankCache;

            if ( *ppnodeCache )
            {
                rankGlue = RR_FindRank( pnodeGlue, type );
                rankCache = RR_FindRank( *ppnodeCache, type );
            }
            if ( !*ppnodeCache || rankGlue > rankCache )
            {
                DNS_DEBUG( LOOKUP, (
                    "Returning glue node %p, with higher rank data than cache node %p\n",
                    pnodeGlue,
                    *ppnodeCache ));
                pnode = pnodeGlue;
                *ppnodeClosest = *ppnodeDelegation;
            }
        }
    }
    
    return pnode;
} // lookupNodeForPacketInCache




//
//  General -- non-zone specific -- lookup routines
//

PDB_NODE
Lookup_NodeForPacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

    Finds node required.
    Fills in packet "current node" data.

Arguments:

    pMsg        - ptr to message, if using packet name;
                  message's current lookup ptrs:
                        pMsg->pnodeCurrent
                        pMsg->pnodeClosest
                        pMsg->pzoneCurrent
                        pMsg->pnodeDelegation
                        pMsg->pnodeGlue
                        pMsg->pnodeCache
                        pMsg->pnodeCacheClosest
                        pMsg->pnodeNxt
                  are set in message buffer

    pchName     - name to lookup, either raw or in packet.

    dwFlag      - lookup flags

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnodeZoneRoot;
    PDB_NODE        pnodeClosest = NULL;
    PDB_NODE        pnodeDelegation = NULL;
    PDB_NODE        pnodeGlue = NULL;
    PDB_NODE        pnodeCache = NULL;
    PDB_NODE        pnodeCacheClosest = NULL;
    PDB_NODE        pnodeNxt = NULL;
    DWORD           flag;
    BOOL            fpacketName;
    WORD            savedLabelCount;
    LOOKUP_NAME     lookupName;             // in case lookup name not given
    WORD            lookupType = pMsg->wTypeCurrent;

    //
    //  build lookup name
    //

    DNS_DEBUG( LOOKUP, (
        "Lookup_NodeForPacket()\n"
        "    pMsg     = %p\n"
        "    pchName  = %p\n"
        "    flag     = %p\n"
        "    wType    = %d\n",
        pMsg,
        pchName,
        dwFlag,
        lookupType ));

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_MessageName(
            "Incoming name:  ",
            pchName,
            pMsg );
    }

    //  verify valid flag
    //  flag needed to transmit find\create distinction when this routine
    //      called by non-packet-lookup covering calls;  since ORing dwFlag
    //      in calls below, must be clear of RELATIVE or FQDN

    ASSERT( !(dwFlag & (LOOKUP_RELATIVE | LOOKUP_FQDN) ) );

    //
    //  if message, first check if name is offset that we have already parsed
    //      - note RAW flag indicates not a packet name even though have pMsg context
    //
    //  DEVNOTE: need some invalid name return?
    //

    fpacketName = !(dwFlag & LOOKUP_RAW);

    if ( fpacketName )
    {
        if ( ! Name_ConvertPacketNameToLookupName(
                    pMsg,
                    pchName,
                    &lookupName ) )
        {
            pnode = NULL;
            goto LookupComplete;
        }
    }

    //
    //  raw name lookup
    //

    else
    {
        if ( ! Name_ConvertRawNameToLookupName(
                    pchName,
                    &lookupName ) )
        {
            pnode = NULL;
            goto LookupComplete;
        }
    }

    //  Lookup name is packet name with labels in root-to-node order.
    //  but still terminated with 0.

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Lookup_NodeForPacket() lookup name",
            &lookupName );
    }

    //
    //  If the cache has priority for this lookup, check it before doing
    //  a zone lookup.
    //

    if ( ( dwFlag & LOOKUP_CACHE_PRIORITY ) &&
        !( dwFlag & LOOKUP_NO_CACHE_DATA ) )
    {
        pnode = lookupNodeForPacketInCache(
            pMsg,
            pchName,
            dwFlag,
            pnodeGlue,
            &lookupName,
            &pnodeClosest,
            &pnodeCache,
            &pnodeCacheClosest,
            &pnodeDelegation );
        
        if ( pnode )
        {
            goto LookupComplete;
        }
    }

    //
    //  Lookup in zone tree. Most flags are not passed through.
    //

    pnodeZoneRoot = Lookup_ZoneTreeNode(
                        &lookupName,
                        dwFlag & LOOKUP_IGNORE_FORWARDER );

    //
    //  Found zone.
    //      - query in closest zone
    //      - save lookup name count, send lookup name just with count for labels
    //          below zone root
    //
    //  DEVNOTE: should have a flag to indicate that we're just interested
    //      in referral -- i.e. we'll return delegation and be done with it
    //

    if ( pnodeZoneRoot )
    {
        pzone = ( PZONE_INFO ) pnodeZoneRoot->pZone;

        ASSERT( pzone );
        ASSERT( pzone->cZoneNameLabelCount == pnodeZoneRoot->cLabelCount );

        //
        //  If this is a stub zone we want to return the closest
        //  node in the cache. But note that the current zone returned
        //  will be the stub zone. Be careful of this fact: the
        //  node or closest node may not be in the current zone!
        //

        if ( IS_ZONE_NOTAUTH( pzone ) )
        {
            UCHAR   czoneLabelCount;
               
            SET_NODE_ACCESSED( pnodeZoneRoot );

            //
            //  If the query is for the SOA or NS of a stub zone root
            //  then return the zone root as the answer node.
            //

            if ( IS_ZONE_STUB( pzone ) &&
                ( lookupType == DNS_TYPE_SOA || lookupType == DNS_TYPE_NS ) &&
                pzone->pZoneRoot && 
                lookupName.cLabelCount == pnodeZoneRoot->cLabelCount )
            {
                pnode = pnodeClosest = pzone->pZoneRoot;
                SET_NODE_ACCESSED( pnode );
                goto LookupComplete;
            }

            //
            //  Search the cache.
            //

            pnode = lookupNodeForPacketInCache(
                pMsg,
                pchName,
                dwFlag,
                pnodeGlue,
                &lookupName,
                &pnodeClosest,
                &pnodeCache,
                &pnodeCacheClosest,
                &pnodeDelegation );

            DNS_DEBUG( LOOKUP, (
                "notauth zone: searched cached node=%s closest=%s\n",
                pnode ? pnode->szLabel : "NULL",
                pnodeClosest ? pnodeClosest->szLabel : "NULL" ));

            if ( pnodeClosest )
            {
                SET_NODE_ACCESSED( pnodeClosest );
            }

            //
            //  If the not-auth zone is not active, do not use it.
            //  Return whatever nodes we found in cache.
            //

            if ( IS_ZONE_INACTIVE( pzone ) )
            {
                pzone = NULL;
                goto LookupComplete;
            }

            //
            //  For stub zones, if the answer node is a cache node at 
            //  the zone root and the query type is NS or SOA move the answer
            //  node to be the notauth zone root itself.
            //
            //  Otherwise, the cache node or closest node is acceptable
            //  if it is at or underneath the not-auth zone root. Compare label
            //  counts to determine if this is true.
            //

            czoneLabelCount = pzone->cZoneNameLabelCount;
            if ( pnode )
            {
                if ( pnode->cLabelCount == czoneLabelCount &&
                    IS_ZONE_STUB( pzone ) &&
                    ( lookupType == DNS_TYPE_SOA ||
                        lookupType == DNS_TYPE_NS ) )
                {
                    DNS_DEBUG( LOOKUP, (
                        "Using stub node as answer node type %d in zone %s\n",
                        lookupType,
                        pzone->pszZoneName  ));
                    pnode = pnodeClosest = pzone->pZoneRoot;
                    SET_NODE_ACCESSED( pnode );
                    goto LookupComplete;
                }
                if ( pnode->cLabelCount >= czoneLabelCount )
                {
                    goto LookupComplete;
                }
            }
            if ( pnodeClosest && pnodeClosest->cLabelCount >= czoneLabelCount )
            {
                goto LookupComplete;
            }

            //
            //  There is nothing helpful in the cache, so return the
            //  notauth zone root as the closest node.
            //

            pnodeClosest = pzone->pZoneRoot;
            SET_NODE_ACCESSED( pnodeClosest );
            pnode = NULL;
            goto LookupComplete;
        }

        savedLabelCount = lookupName.cLabelCount;
        lookupName.cLabelCount -= (WORD) pnodeZoneRoot->cLabelCount;

        DNS_DEBUG( LOOKUP2, (
            "Do lookup in closest zone %s, with %d labels remaining.\n",
            pzone->pszZoneName,
            lookupName.cLabelCount ));

        pnode = Lookup_ZoneNode(
                    pzone,
                    NULL,
                    NULL,
                    &lookupName,
                    dwFlag | LOOKUP_RELATIVE,
                    &pnodeClosest,
                    &pnodeNxt );

        //  reset lookupname to use full FQDN

        lookupName.cLabelCount = savedLabelCount;

        ASSERT( !pnode || pnode->cLabelCount == savedLabelCount );

        //
        //  If the node is within a zone we're done.
        //

        if ( pnodeClosest && IS_AUTH_NODE(pnodeClosest) )
        {
            DNS_DEBUG( LOOKUP2, (
                "Lookup within zone %s ... lookup done.\n",
                pzone->pszZoneName ));
            goto LookupComplete;
        }

        //
        //  in delegation
        //      - save delegation info
        //      - then fall through to visit cache with lookup
        //

        //
        //  DEVNOTE: should save delegation label count for comparison with
        //      cached label count?
        //  our just function to compare (traverse up tree)
        //

        //
        //  DEVNOTE:  delegation should get delegation -- NOT just closest?
        //

        pnodeDelegation = pnodeClosest;
        pnodeGlue = pnode;
        pzone = NULL;
    }

    //
    //  If zone lookup failed and we haven't already tried the cache do
    //  a lookup in cache. LOOKUP_NO_CACHE_DATA is a special case for
    //  the UI - pick up glue and delegation nodes if they exist.
    //

    if ( !( dwFlag & LOOKUP_CACHE_PRIORITY ) )
    {
        if ( dwFlag & LOOKUP_NO_CACHE_DATA )
        {
            pnode = pnodeGlue;
            pnodeClosest = pnodeDelegation;
            goto LookupComplete;
        }

        pnode = lookupNodeForPacketInCache(
            pMsg,
            pchName,
            dwFlag,
            pnodeGlue,
            &lookupName,
            &pnodeClosest,
            &pnodeCache,
            &pnodeCacheClosest,
            &pnodeDelegation );
    } // if

LookupComplete:

    //  fill message fields
    //  advantage of doing this all at once here, is we force reset of
    //      of variables from any previous query

    pMsg->pnodeCurrent      = pnode;
    pMsg->pnodeClosest      = pnodeClosest;
    pMsg->pzoneCurrent      = pzone;
    pMsg->pnodeDelegation   = pnodeDelegation;
    pMsg->pnodeGlue         = pnodeGlue;
    pMsg->pnodeCache        = pnodeCache;
    pMsg->pnodeCacheClosest = pnodeCacheClosest;
    pMsg->pnodeNxt          = pnodeNxt;

    ASSERT( !pnode ||
            pzone == ( PZONE_INFO ) pnode->pZone ||
            !pzone && pnode == pnodeGlue ||
            pzone && !pnode->pZone && IS_ZONE_NOTAUTH( pzone ) );
    ASSERT( !pnodeClosest ||
            !pzone && pnode == pnodeGlue ||
            pzone == ( PZONE_INFO ) pnodeClosest->pZone ||
            pzone && IS_ZONE_NOTAUTH( pzone ) );

    DNS_DEBUG( LOOKUP, (
        "Leave Lookup_NodeForPacket()\n"
        "    pMsg     = %p\n"
        "    pchName  = %p\n"
        "    flag     = %p\n"
        "    type     = %d\n"
        "    results:\n"
        "    pnode            = %p\n"
        "    pnodeClosest     = %p\n"
        "    pzone            = %p\n"
        "    pnodeDelegation  = %p\n"
        "    pnodeGlue        = %p\n"
        "    pnodeCache       = %p\n"
        "    pnodeCacheClosest= %p\n",
        pMsg,
        pchName,
        dwFlag,
        lookupType,
        pnode,
        pnodeClosest,
        pzone,
        pnodeDelegation,
        pnodeGlue,
        pnodeCache,
        pnodeCacheClosest ));

    //  save compression to node

    if ( fpacketName && pnode )
    {
        Name_SaveCompressionWithNode(
            pMsg,
            pchName,
            pnode );
    }

    ASSERT( !pnode || IS_NODE_RECENTLY_ACCESSED(pnode) );

    return pnode;
}



PDB_NODE
Lookup_NodeOld(
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,             OPTIONAL
    OUT     PDB_NODE *      ppNodeDelegation,   OPTIONAL
    OUT     PDB_NODE *      ppNodeClosest       OPTIONAL
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

Arguments:

    pchName     - Name to lookup given in packet format.

    dwFlag      - lookup flags

    ppNodeDelegation - addr to receive ptr to node in delegation, if found

    ppNodeClosest - addr to receive ptr to closest node found
                    - valid ptr us in "Find Mode"
                    - NULL puts us in "Create Mode" causing creation of all
                        necessary nodes to add name to database

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DNS_MSGINFO     msgBuffer;
    PDNS_MSGINFO    pmsg;

    //
    //  if no input message, send one down to use to receive
    //      desired OUT param nodes
    //      - LOOKUP_RAW insures that name is NOT treated as being
    //          within packet;  this is AV protection only as
    //          name should not contain any compression offsets
    //      - set type=A and LOOKUP_BEST_RANK in case of cache\delegation
    //          data duplication;  assume that generally this happens
    //          only for glue chasing so setup to pick best type A
    //          data available
    //

    pmsg = &msgBuffer;
    pmsg->wTypeCurrent = DNS_TYPE_A;
    dwFlag |= (LOOKUP_RAW | LOOKUP_BEST_RANK);

    //
    //  In case the lookup routine needs to check TTLs initialize
    //  the message query time to the current time less a few seconds
    //  as a fudge factor to approximate a realistic (but safe)
    //  query time.
    //

    pmsg->dwQueryTime = DNS_TIME() - 60;

    pnode = Lookup_NodeForPacket(
                pmsg,
                pchName,
                dwFlag );

    //
    //  write OUT params from out results in packet buf
    //

    if ( ppNodeDelegation )
    {
        *ppNodeDelegation = pmsg->pnodeDelegation;
    }

    if ( ppNodeClosest && ppNodeClosest != DNS_FIND_LOOKUP_PTR )
    {
        *ppNodeClosest = pnode ? pnode : pmsg->pnodeClosest;
    }

    return pnode;
}



PDB_NODE
Lookup_DbaseName(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppDelegationNode
    )
/*++

Routine Description:

    Find node for dbase name.

Arguments:

    pMsg        - message to point to

    dwFlag      - flag to pass in

    ppchName    - addr with ptr to packet name, and which receives packet
                    ptr to next byte after name

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pclosestNode;

    //
    //  JJCONVERT:  big issues here about handling delegation
    //
    //  generic routine should probably have *ppnodeClosest and take FIND_PTR
    //  for NS, should deal explicitly with given delegation priority when available
    //      or when zone matches
    //
    //  for packet lookup should have routine that writes standard packet variables
    //

    pnode = Lookup_NodeOld(
                pName->RawName,
                dwFlag,                 //  flags
                ppDelegationNode,
                &pclosestNode );        //  find
    return pnode;
}



PDB_NODE
Lookup_NsHostNode(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    IN      PZONE_INFO      pZone,
    OUT     PDB_NODE *      ppDelegation
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

    Finds node required.
    Fills in packet "current node" data.

Arguments:

    pchName - name to lookup in raw format

    dwFlag - lookup flags
                ONLY interesting flag is LOOKUP_CREATE to force node
                creation in cache zone (this is used to get node to
                chase for missing glue)

    pZone - ptr to zone context that is "interesting" to lookup;
            outside zone glue data can be used from this zone

    ppDelegation - addr to receive delegation node ptr (if any)

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pnodeFirstLookup;

    DNS_DEBUG( LOOKUP, (
        "Lookup_NsHostNode()\n"
        "    pName    = %p\n"
        "    pZone    = %p\n"
        "    flag     = %p\n",
        pName,
        pZone,
        dwFlag ));

    //
    //  lookup node
    //

    pnode = Lookup_NodeOld(
                pName->RawName,
                dwFlag,
                ppDelegation,   //  need delegation (if any)
                NULL );         //  no out closest

    //
    //  check if screening out cache data
    //

    if ( pnode &&
         (dwFlag & LOOKUP_NO_CACHE_DATA) &&
         IS_CACHE_TREE_NODE(pnode) )
    {
        pnode = NULL;       // toss cache node
    }

    //
    //  outside zone glue?
    //      - using existence of pZone to mean it's ok to use
    //
    //  check if already found data of desired type
    //      - if found or in our zone => done
    //
    //  lookup in specified zone
    //      => accept result of ANY whatever result is, we'll take it
    //

    if ( pZone )
    {
        pnodeFirstLookup = pnode;

        if ( pnode  &&
             (pnode->pZone == pZone || RR_FindRank( pnode, DNS_TYPE_A )) )
        {
            goto Done;
        }

        pnode = Lookup_ZoneNode(
                    pZone,
                    pName->RawName,
                    NULL,                   //  no message
                    NULL,                   //  no lookup name
                    LOOKUP_NAME_FQDN,       //  flag
                    DNS_FIND_LOOKUP_PTR,
                    NULL );                 //  previous node ptr

        //  should have found any AUTH node above

        DNS_DEBUG( LOOKUP, (
            "Found node %p on direct zone lookup.\n",
            pnode ));

        if ( !pnode )
        {
            pnode = pnodeFirstLookup;
        }
    }

Done:

    DNS_DEBUG( LOOKUP2, (
        "Lookup_NsHostNode() returns %p (l=%s)\n",
        pnode,
        pnode ? pnode->szLabel : NULL ));

    return pnode;
}



PDB_NODE
Lookup_FindNodeForIpAddress(
    IN      PDNS_ADDR       pDnsAddr,
    IN      DWORD           dwFlag,
    IN      PDB_NODE *      ppNodeFind
    )
/*++

Routine Description:

    Get reverse lookup node corresponding to IP address.

Arguments:

    pDnsAddr -- IP to find node for

    ppNodeClosest   -- address to recieve node's closest ancestor;
                        if specified then lookup is a "FIND",
                        if not specified, then lookup is a "CREATE"

Return Value:

    Ptr to domain node if found.
    NULL if not found.

--*/
{
    PCHAR       pch;
    PCHAR       pchnew;
    CHAR        ch;
    DWORD       dotCount;
    LONG        length;
    LONG        lengthArpa;
    PCHAR       apstart[ 5 ];
    CHAR        reversedIpString[ DNS_ADDR_IP_STRING_BUFFER_LENGTH + 40 ];
    DNS_STATUS  status;
    DB_NAME     nameReverse;
    ULONG       ipAddress;
    int         i;
    PCHAR       pszip;

    DNS_DEBUG( LOOKUP, (
        "Lookup_FindNodeForIpAddress() for %s\n",
        DNSADDR_STRING( pDnsAddr ) ));

    //
    //  Construct reverse IP string.
    //  FIXIP6: only supporting IPv4 at this time.
    //

    ASSERT( DnsAddr_Family( pDnsAddr ) == AF_INET );
    if ( DnsAddr_Family( pDnsAddr ) != AF_INET )
    {
        goto ErrorReturn;
    }
    ipAddress = ntohl( pDnsAddr->SockaddrIn.sin_addr.s_addr );
    pszip = IP_STRING( ipAddress );

    //
    //  convert to count name
    //

    status = Name_ConvertDottedNameToDbaseName(
                &nameReverse,
                pszip,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }
    status = Name_AppendDottedNameToDbaseName(
                &nameReverse,
                "in-addr.arpa.",
                0 );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }

    IF_DEBUG( LOOKUP )
    {
        Dbg_CountName(
            "Count name for IP address",
            & nameReverse,
            NULL );
    }

    //
    //  lookup
    //

    return Lookup_NodeOld(
                nameReverse.RawName,
                dwFlag,             // flags
                NULL,               // delegation out
                ppNodeFind );

ErrorReturn:

    if ( ppNodeFind && ppNodeFind != DNS_FIND_LOOKUP_PTR )
    {
        *ppNodeFind = NULL;
    }
    return NULL;
}


//
//  End of lookup.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\csd.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    csd.h

Abstract:

    Header file for security classes

Environment:

    User mode

Revision History:

    04/06/97 -srinivac-
        Created it from ATL sources
    08/07/98 -eyals-
        Stole from \nt\private\dirsync\dsserver\server, modified & renamed

--*/

#ifndef _CSD_H_
#define _CSD_H_




// defines //

#define SECINFO_ALL         ( OWNER_SECURITY_INFORMATION |  \
                              GROUP_SECURITY_INFORMATION |  \
                              SACL_SECURITY_INFORMATION  |  \
                              DACL_SECURITY_INFORMATION )

#define SECINFO_NODACL      ( SECINFO_ALL & ~DACL_SECURITY_INFORMATION )
#define SECINFO_NOSACL      ( SECINFO_ALL & ~SACL_SECURITY_INFORMATION )
#define SECINFO_OWNERGROUP  ( OWNER_SECURITY_INFORMATION |  \
                              GROUP_SECURITY_INFORMATION )



class CSecurityDescriptor
{
public:
        CSecurityDescriptor();
        ~CSecurityDescriptor();

public:
        HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD,
                       BYTE AclRevision = ACL_REVISION_DS,
                       BOOL bAllowInheritance = FALSE );
        HRESULT Attach(LPCTSTR pszSdString); // added T
        HRESULT AttachObject(HANDLE hObject);
        HRESULT Initialize();
        HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
        HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
        HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
        HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
        HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(LPCTSTR pszPrincipal);
        HRESULT Allow(PSID pPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        HRESULT Deny(PSID pPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(PSID pPrincipal);

        // utility functions
        // Any PSID you get from these functions should be delete'd
        static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
        static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
        static HRESULT IsSidInTokenGroups(HANDLE hToken, PSID pSid, PBOOL pbMember);
        static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
        static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = TRUE);
        static HRESULT CopyACL(PACL pDest, PACL pSrc);
        static HRESULT GetCurrentUserSID(PSID *ppSid, BOOL bThread=FALSE);
        static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);

        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, PSID principalSID, DWORD dwAccessMask, DWORD AceFlags = 0);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, PSID principalSID, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, PSID principalSID);

        BOOL
        CSecurityDescriptor::DoesPrincipleHaveAce(
            PSID        principalSID
            );

        BOOL
        CSecurityDescriptor::DoesPrincipleHaveAce(
            LPCTSTR     pszPrincipal
            );

        operator PSECURITY_DESCRIPTOR()
        {
                return m_pSD;
        }

        PSID ExtractAceSid( ACCESS_ALLOWED_ACE* pACE );

        //
        // SD string interface
        //
        LPTSTR GenerateSDString(PSECURITY_DESCRIPTOR OPTIONAL pSd = NULL,
                                DWORD OPTIONAL fSecInfo = SECINFO_NOSACL);

public:
        PSECURITY_DESCRIPTOR m_pSD;
        PSID m_pOwner;
        PSID m_pGroup;
        PACL m_pDACL;
        PACL m_pSACL;
};

#endif  // ifndef _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\csd.cxx ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    csd.cxx

Abstract:

    This is from the ATL sources. This provides a simple interface
    for managing ACLs and SDs

Environment:

    User mode

Revision History:

    04/06/97 -srinivac-
        Created it from ATL sources
    08/07/98 -eyals-
        Stole from \nt\private\dirsync\dsserver\server, modified & renamed

--*/

//
// These routines are all non-unicode
//
// #ifdef UNICODE
// Jeff W: Making these routines unicode again!!
// #undef UNICODE
// #endif


#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <ntseapi.h>
#include <sddl.h>


#if 0
#include <stdio.h>


#define DBGOUT(x)    (OutputDebugString(x))

#define DBGOUT_SID(psid, cbsid)              \
{                            \
   CHAR buf[1024];                       \
   DWORD j = (cbsid) / sizeof(DWORD);            \
   sprintf(buf, "sid<%lu> [", j);            \
   DBGOUT(buf);                      \
   for (DWORD i=0; i<j;i++)                  \
   {                             \
      sprintf(buf, "%X%c", *((PDWORD)(psid)+i),      \
          j == i+1 ? ']' : '.');             \
      DBGOUT(buf);                       \
   }                             \
}
#else
#define DBGOUT(x)
#define DBGOUT_SID(x, cbsid);
#endif

#include "csd.h"

CSecurityDescriptor::CSecurityDescriptor()
{
    m_pSD = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;
    m_pDACL = NULL;
    m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
    if ( m_pSD )
        delete [] m_pSD;
    if ( m_pOwner )
        delete [] m_pOwner, m_pOwner = NULL;
    if ( m_pGroup )
        delete [] m_pGroup, m_pGroup = NULL;
    if ( m_pDACL )
        delete [] m_pDACL, m_pDACL = NULL;
    if ( m_pSACL )
        delete [] m_pSACL, m_pSACL = NULL;
}

HRESULT CSecurityDescriptor::Initialize()
{
    if ( m_pSD )
    {
        delete [] m_pSD;
        m_pSD = NULL;
    }
    if (m_pOwner)
    {
        delete [] m_pOwner;
        m_pOwner = NULL;
    }
    if (m_pGroup)
    {
        delete [] m_pGroup;
        m_pGroup = NULL;
    }
    if (m_pDACL)
    {
        delete [] m_pDACL;
        m_pDACL = NULL;
    }
    if (m_pSACL)
    {
        delete [] m_pSACL;
        m_pSACL = NULL;
    }

    m_pSD = new BYTE[ sizeof( SECURITY_DESCRIPTOR ) ];
    if (!m_pSD)
        return E_OUTOFMEMORY;
    if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] m_pSD;
        m_pSD = NULL;
        return hr;
    }
    // DEVNOTE: commented out. You wanna prevent all from touching this by default
    // Set the DACL to allow EVERYONE
    //    SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);

    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr=S_OK;

    Initialize();
    hr = GetProcessSids(&pUserSid, &pGroupSid);
    if ( FAILED( hr ) )
       goto cleanup;
    hr = SetOwner(pUserSid, bDefaulted);
    if ( FAILED( hr ) )
       goto cleanup;
    hr = SetGroup(pGroupSid, bDefaulted);
    if ( FAILED( hr ) )
       goto cleanup;
cleanup:
    if ( pUserSid )
        delete [] pUserSid;
    if ( pGroupSid )
        delete [] pGroupSid;
    return hr;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr=S_OK;

    Initialize();
    hr = GetThreadSids(&pUserSid, &pGroupSid);
    if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
        hr = GetProcessSids(&pUserSid, &pGroupSid);
    if ( FAILED( hr ) )
       goto cleanup;
    hr = SetOwner(pUserSid, bDefaulted);
    if ( FAILED( hr ) )
       goto cleanup;
    hr = SetGroup(pGroupSid, bDefaulted);
    if ( FAILED( hr ) )
       goto cleanup;
cleanup:
    if ( pUserSid )
        delete [] pUserSid;
    if ( pGroupSid )
        delete [] pGroupSid;
    return hr;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
    // Mark the SD as having no owner
    if ( !SetSecurityDescriptorOwner( m_pSD, NULL, bDefaulted ) )
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    if ( m_pOwner )
    {
        delete [] m_pOwner;
        m_pOwner = NULL;
    }

    // If they asked for no owner don't do the copy
    if ( pOwnerSid == NULL )
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pOwnerSid);

    m_pOwner = ( PSID ) new BYTE[ dwSize ];
    if (!m_pOwner)
    {
        // Insufficient memory to allocate Sid
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pOwner, pOwnerSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] m_pOwner;
        m_pOwner = NULL;
        return hr;
    }

    if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] m_pOwner;
        m_pOwner = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
    // Mark the SD as having no Group
    if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    if (m_pGroup)
    {
        delete [] m_pGroup;
        m_pGroup = NULL;
    }

    // If they asked for no Group don't do the copy
    if (pGroupSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pGroupSid);

    m_pGroup = ( PSID ) new BYTE[ dwSize ];
    if (!m_pGroup)
    {
        // Insufficient memory to allocate Sid
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pGroup, pGroupSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] m_pGroup;
        m_pGroup = NULL;
        return hr;
    }

    if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] m_pGroup;
        m_pGroup = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::Allow( LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags )
{
    HRESULT hr = AddAccessAllowedACEToACL( &m_pDACL, pszPrincipal, dwAccessMask, AceFlags );
    if ( SUCCEEDED( hr ) )
        SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
    return hr;
}

HRESULT CSecurityDescriptor::Deny( LPCTSTR pszPrincipal, DWORD dwAccessMask )
{
    HRESULT hr = AddAccessDeniedACEToACL( &m_pDACL, pszPrincipal, dwAccessMask );
    if ( SUCCEEDED( hr ) )
        SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
    return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
    HRESULT     hr = S_OK;
    int         retries = 250;

    //
    //  There can be duplicate ACLs with the same principle. Keep whacking
    //  ACEs until they're all gone or we hit a hard retry limit.
    //
        
    while ( hr == S_OK && --retries > 0 )
    {
        hr = RemovePrincipalFromACL( m_pDACL, pszPrincipal );
        if ( SUCCEEDED( hr ) )
        {
            SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE );
        }
    }
    return hr;
}




HRESULT CSecurityDescriptor::Allow(PSID pPrincipal, DWORD dwAccessMask, DWORD AceFlags)
{
   HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pPrincipal, dwAccessMask, AceFlags);
   if ( SUCCEEDED( hr ) )
       SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
   return hr;

}


HRESULT CSecurityDescriptor::Deny(PSID pPrincipal, DWORD dwAccessMask)
{
   HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pPrincipal, dwAccessMask);
   if ( SUCCEEDED( hr ) )
       SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
   return hr;

}


HRESULT CSecurityDescriptor::Revoke(PSID pPrincipal)
{
    HRESULT     hr = S_OK;
    int         retries = 250;

    //
    //  There can be duplicate ACLs with the same principle. Keep whacking
    //  ACEs until they're all gone or we hit a hard retry limit.
    //

    while ( hr == S_OK && --retries > 0 )
    {
        hr = RemovePrincipalFromACL( m_pDACL, pPrincipal );
        if ( SUCCEEDED( hr ) )
        {
            SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE );
        }
    }
    return hr;
}


HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (!bRes)
    {
        // Couldn't open process token
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    //
    // clean all memory temp. allocations
    //
    if(hToken)
        CloseHandle(hToken);
    return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
    if (!bRes)
    {
        // Couldn't open thread token
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    //
    // clean all memory temp. allocations
    //
    if(hToken)
        CloseHandle(hToken);
    return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
    DWORD dwSize;
    HRESULT hr;
    PTOKEN_USER ptkUser = NULL;
    PTOKEN_PRIMARY_GROUP ptkGroup = NULL;
    PSID pSid = NULL;

    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;

    if (ppUserSid)
    {
        // Get length required for TokenUser by specifying buffer length of 0
        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkUser = ( TOKEN_USER * ) new BYTE[ dwSize ];
        if (!ptkUser)
        {
            // Insufficient memory to allocate TOKEN_USER
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkUser->User.Sid);

        pSid = ( PSID ) new BYTE[ dwSize ];
        if ( !pSid ) 
        {
            // Insufficient memory to allocate Sid
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        *ppUserSid = pSid;
        pSid = NULL;
        delete [] ptkUser;
        ptkUser = NULL;
    }
    if (ppGroupSid)
    {
        // Get length required for TokenPrimaryGroup by specifying buffer length of 0
        GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkGroup = ( TOKEN_PRIMARY_GROUP * ) new BYTE[ dwSize ];
        if (!ptkGroup)
        {
            // Insufficient memory to allocate TOKEN_USER
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

        pSid = ( PSID ) new BYTE[ dwSize ];
        if ( !pSid )
        {
            // Insufficient memory to allocate Sid
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        *ppGroupSid = pSid;
        pSid = NULL;
        delete [] ptkGroup;
    }

    return S_OK;

failed:
    if ( ptkUser )
        delete [] ptkUser;
    if ( ptkGroup )
        delete [] ptkGroup;
    if ( pSid )
        delete [] pSid;
    return hr;
}



HRESULT CSecurityDescriptor::IsSidInTokenGroups(HANDLE hToken, PSID pSid, PBOOL pbMember)
{
    DWORD dwSize;
    HRESULT hr = S_OK;
    PTOKEN_GROUPS ptkGroups = NULL;
    ULONG i;
    BOOL bMember = FALSE;

    if (!pbMember)
    {
       return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Get length required for TokenUser by specifying buffer length of 0
    GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwSize);
    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
    {
       // Expected ERROR_INSUFFICIENT_BUFFER
       hr = HRESULT_FROM_WIN32(hr);
       goto failed;
    }
    hr = ERROR_SUCCESS;

    ptkGroups = ( TOKEN_GROUPS * ) new BYTE[ dwSize ];
    if (!ptkGroups)
    {
       // Insufficient memory to allocate TOKEN_USER
       hr = E_OUTOFMEMORY;
       goto failed;
    }
       // Get Sid of process token.
    if (!GetTokenInformation(hToken, TokenGroups, ptkGroups, dwSize, &dwSize))
    {
       // Couldn't get groups info
       hr = HRESULT_FROM_WIN32( GetLastError() );
       goto failed;
    }

#if 0
    //
    // print user sid
    //
    {
       PSID pUSid=NULL;
       if (ERROR_SUCCESS ==
           GetCurrentUserSID(&pUSid, TRUE))
       {
          DBGOUT("User Sid:");
          DBGOUT_SID(pUSid, GetLengthSid(pSid));
          DBGOUT("\n");
          delete [] pUSid;
       }
    }
#endif

    DBGOUT("searching for ");
    DBGOUT_SID(pSid, GetLengthSid(pSid));
    DBGOUT(" ...\n");
    for (i=0; i<ptkGroups->GroupCount; i++)
    {
       DBGOUT(" >");
       DBGOUT_SID(ptkGroups->Groups[i].Sid,
              GetLengthSid(ptkGroups->Groups[i].Sid));
       DBGOUT(" ?\n");
       if (TRUE == (bMember = RtlEqualSid(pSid, ptkGroups->Groups[i].Sid)))
       {
          DBGOUT(" >> EqualSid\n");
          break;
       }
    }
    *pbMember = bMember;

failed:
    if ( ptkGroups )
       delete [] ptkGroups;

    return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid, BOOL bThread)
{
    HANDLE tkHandle = NULL;
    BOOL bstatus=FALSE;

    if ( bThread )
    {
       bstatus = OpenThreadToken(GetCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &tkHandle);
    }
    else
    {
       bstatus = OpenProcessToken(GetCurrentProcess(),
                      TOKEN_QUERY,
                      &tkHandle);
    }
    if ( bstatus )
    {
        TOKEN_USER *tkUser;
        DWORD tkSize = 0;
        DWORD sidLength;

        // Call to get size information for alloc
        GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
        tkUser = ( TOKEN_USER * ) new BYTE[ tkSize ];
        if (!tkUser)
        {
            SetLastError( E_OUTOFMEMORY );
            goto Failed;
        }

        // Now make the real call
        if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
        {
            sidLength = GetLengthSid(tkUser->User.Sid);
            *ppSid = ( PSID ) new BYTE[ sidLength ];
            if ( !*ppSid )
            {
                //  DEVNOTE: this isn't consistent with HRESULT either
                //      better to just have a single failure return
                CloseHandle(tkHandle);
                return E_OUTOFMEMORY;
            }

            memcpy(*ppSid, tkUser->User.Sid, sidLength);
            CloseHandle(tkHandle);

            delete [] tkUser;
            return S_OK;
        }
        else
        {
            CloseHandle(tkHandle);
            delete [] tkUser;
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

Failed:
    //
    // clean all memory temp. allocations
    //
    if( tkHandle )
        CloseHandle( tkHandle );

    return HRESULT_FROM_WIN32( GetLastError() );
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
    HRESULT hr;
    LPTSTR pszRefDomain = NULL;
    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE snu;

    // Call to get size info for alloc
    LookupAccountName(
            NULL,
            pszPrincipal,
            *ppSid,
            &dwSidSize,
            pszRefDomain,
            &dwDomainSize,
            &snu );

    hr = GetLastError();
    if ( hr != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32( hr );
    }

    pszRefDomain = new TCHAR[ dwDomainSize ];
    if ( pszRefDomain == NULL )
    {
        return E_OUTOFMEMORY;
    }

    *ppSid = ( PSID ) new BYTE[ dwSidSize ];
    if (*ppSid != NULL)
    {
        if ( !LookupAccountName(
                    NULL,
                    pszPrincipal,
                    *ppSid,
                    &dwSidSize,
                    pszRefDomain,
                    &dwDomainSize,
                    &snu ))
        {
            delete [] *ppSid;
            *ppSid = NULL;
            delete [] pszRefDomain;
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        delete [] pszRefDomain;
        return S_OK;
    }
    delete [] pszRefDomain;
    return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(
    PSECURITY_DESCRIPTOR    pSelfRelativeSD,
    BYTE                    AclRevision,
    BOOL                    bAllowInheritance )
{
    PACL    pDACL = NULL;
    PACL    pSACL = NULL;
    BOOL    bDACLPresent, bSACLPresent;
    BOOL    bDefaulted;
    BOOL    bStatus = FALSE;
    ACCESS_ALLOWED_ACE* pACE;
    HRESULT hr;
    PSID    pUserSid;
    PSID    pGroupSid;

    SetLastError( ERROR_SUCCESS );
    
    if ( !pSelfRelativeSD )
    {
       return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // get the existing DACL.
    if ( !GetSecurityDescriptorDacl(
                pSelfRelativeSD,
                &bDACLPresent,
                &pDACL,
                &bDefaulted ) ||
         !pDACL)
    {
        goto failed;
    }

    if ( bDACLPresent )
    {
        AclRevision = pDACL->AclRevision;
        if (pDACL)
        {
            m_pDACL = ( PACL ) new BYTE[ pDACL->AclSize ];
            if (!m_pDACL)
                goto failed;

            // initialize the DACL
            if (!InitializeAcl(m_pDACL, pDACL->AclSize, AclRevision))
                goto failed;

            // copy the ACES
            for ( int i = 0; i < pDACL->AceCount; i++ )
            {
                if ( !GetAce(pDACL, i, (void **)&pACE) )
                {
                    goto failed;
                }

                pUserSid = ExtractAceSid( pACE );
                if ( pUserSid )
                {
                    if ( AclRevision < ACL_REVISION_DS )
                    {
                        if ( pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
                        {
                            bStatus = AddAccessAllowedAce(
                                            m_pDACL,
                                            AclRevision,
                                            pACE->Mask,
                                            pUserSid );
                        }
                        else if ( pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE )
                        {
                            bStatus = AddAccessDeniedAce(
                                            m_pDACL,
                                            AclRevision,
                                            pACE->Mask,
                                            pUserSid );
                        }
                        else
                        {
                            bStatus = TRUE;
                        }
                    }
                    else
                    {
                        if ( bAllowInheritance ||
                            !(pACE->Header.AceFlags & INHERITED_ACE) )
                        {
                            //
                            // For DS ACEs we need to optionaly skip inheritable ones
                            //

                            if ( pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
                            {
                                bStatus = AddAccessAllowedAce(
                                                m_pDACL,
                                                AclRevision,
                                                pACE->Mask,
                                                pUserSid );
                            }
                            else if ( pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE )
                            {
                                bStatus = AddAccessDeniedAce(
                                                m_pDACL,
                                                AclRevision,
                                                pACE->Mask,
                                                pUserSid );
                            }
                            else
                            {
                                bStatus = TRUE;
                            }
                        }
                        else
                        {
                            // don't fail
                            bStatus = TRUE;
                        }
                    }
                    if ( !bStatus )
                    {
                        goto failed;
                    }
                }
                else
                {
                    //
                    // unknown ace
                    //
                    SetLastError( ERROR_INVALID_ACL );
                    goto failed;
                }
            }

            if ( !IsValidAcl( m_pDACL ) )
            {
                goto failed;
            }
        }

        // set the DACL
        if ( !SetSecurityDescriptorDacl(
                    m_pSD,
                    m_pDACL ? TRUE : FALSE,
                    m_pDACL,
                    bDefaulted ) )
        {
            goto failed;
        }
    }

    // get the existing SACL.
    if ( !GetSecurityDescriptorSacl( pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted ) )
    {
        goto failed;
    }

    if ( bSACLPresent )
    {
        ASSERT( !"DNS SERVER SHOULD NOT DEAL WITH SACLS!!!" );
        goto failed;

        #if 0
        
        AclRevision = pSACL->AclRevision;
        if ( pSACL )
        {
            m_pSACL = ( PACL ) new BYTE[ pSACL->AclSize ];
            if ( !m_pSACL )
            {
                goto failed;
            }

            if ( !InitializeAcl( m_pSACL, pSACL->AclSize, ACL_REVISION ) )
            {
                goto failed;
            }
            
            if ( !CopyACL( m_pSACL, pSACL ) )
            {
                goto failed;
            }

            if ( !IsValidAcl( m_pSACL ) )
            {
                goto failed;
            }
        }

        // set the SACL
        if ( !SetSecurityDescriptorSacl(
                    m_pSD,
                    m_pSACL ? TRUE : FALSE,
                    m_pSACL,
                    bDefaulted ) )
        {
            goto failed;
        }
        
        #endif
    }

    if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
        goto failed;

    if (FAILED(SetOwner(pUserSid, bDefaulted)))
        goto failed;

    if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
        goto failed;

    if (FAILED(SetGroup(pGroupSid, bDefaulted)))
        goto failed;

    if (!IsValidSecurityDescriptor(m_pSD))
        goto failed;

    return hr;

failed:

    if ( m_pDACL )
        delete [] m_pDACL, m_pDACL = NULL;
    if ( m_pSD )
        delete [] m_pSD, m_pSD = NULL;

    hr = HRESULT_FROM_WIN32( GetLastError() );
    return FAILED( hr ) ? hr : E_UNEXPECTED;
}


HRESULT CSecurityDescriptor::Attach(LPCTSTR pszSdString)
{

   BOOL bStatus = TRUE;
   HRESULT hrStatus = NOERROR;
   PSECURITY_DESCRIPTOR pSd=NULL;

   //
   // Get SD in self-relative form
   //
   bStatus = ConvertStringSecurityDescriptorToSecurityDescriptor(pszSdString,
                                 SDDL_REVISION,
                                 &pSd,
                                 NULL );

   hrStatus = bStatus ? Attach(pSd) : HRESULT_FROM_WIN32( GetLastError() );

   if( pSd )
      LocalFree( pSd );

   return hrStatus;
}



#if 0

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
    HRESULT hr;
    DWORD dwSize = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[ dwSize ];

    if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        delete [] pSD;
        return hr;
    }

    hr = Attach(pSD);
    delete [] pSD;
    return hr;
}

#endif


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    LPVOID pAce;
    ACE_HEADER *aceHeader;

    if (pSrc == NULL)
        return S_OK;

    if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        return HRESULT_FROM_WIN32( GetLastError() );

    // Copy all of the ACEs to the new ACL
    for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pSrc, i, &pAce))
            return HRESULT_FROM_WIN32( GetLastError() );

        aceHeader = (ACE_HEADER *) pAce;

        if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    DWORD returnValue;
    PSID principalSID = NULL;

    // PREFIX BUG: Reworked this so we have one return path and not leaking SID.
    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if ( !FAILED( returnValue ) )
    {
        returnValue = AddAccessDeniedACEToACL( ppAcl, principalSID, dwAccessMask );
    }

    delete [] principalSID;
    return FAILED( returnValue )? returnValue : S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PACL oldACL;
    PACL newACL = NULL;
    HRESULT status = S_OK;

    oldACL = *ppAcl;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
    {
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);
    }

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = ( PACL ) new BYTE[ aclSize ];
    if ( !newACL )
    {
        status = E_OUTOFMEMORY;
        goto Failed;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        status = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        status = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    status = CopyACL( newACL, oldACL );
    if ( FAILED( status ) )
    {
        goto Failed;
    }

    *ppAcl = newACL;
    newACL = NULL;
    delete [] oldACL;

    return S_OK;

    Failed:

    delete [] newACL;
    return status;
}

HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags)
{
    DWORD returnValue;
    PSID principalSID = NULL;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID );
    if ( FAILED( returnValue ) )
    {
        return returnValue;
    }

    returnValue = AddAccessAllowedACEToACL(ppAcl, principalSID, dwAccessMask, AceFlags);
    delete [] principalSID;

    return FAILED( returnValue ) ? returnValue : S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask, DWORD AceFlags)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PACL oldACL;
    PACL newACL = NULL;
    HRESULT hres = 0;

    if ( !principalSID )
    {
        hres = E_INVALIDARG;
        goto Failed;
    }
    
    oldACL = *ppAcl;

    aclSizeInfo.AclBytesInUse = 0;
    if ( *ppAcl != NULL )
    {
        GetAclInformation(
        oldACL,
        (LPVOID) &aclSizeInfo,
        (DWORD) sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation);
    }

    aclSize =
        aclSizeInfo.AclBytesInUse +
        sizeof(ACL) +
        sizeof(ACCESS_ALLOWED_ACE) +
        GetLengthSid(principalSID) -
        sizeof(DWORD);

    newACL = (PACL) new BYTE[ aclSize ];
    if ( !newACL )
    {
        hres = E_OUTOFMEMORY;
        goto Failed;
    }

    if ( !InitializeAcl( newACL, aclSize, ACL_REVISION ) )
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    returnValue = CopyACL( newACL, oldACL );
    if ( FAILED( returnValue ) )
    {
        hres = returnValue;
        goto Failed;
    }

    if ( !AddAccessAllowedAceEx(
            newACL,
            ACL_REVISION,
            AceFlags,
            dwAccessMask,
            principalSID ) )
    {
        hres = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    *ppAcl = newACL;
    if ( oldACL )
    {
        delete [] oldACL;
    }
    return S_OK;

    Failed:

    //  The new ACL will not be returned so free it!
    delete [] newACL;
    return hres;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
   PSID principalSID = NULL;
   DWORD returnValue;

   returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
   if (FAILED(returnValue))
       return returnValue;

   returnValue = RemovePrincipalFromACL(pAcl, principalSID);

   delete [] principalSID;
   return FAILED(returnValue)?returnValue:S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, PSID principalSID)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    ULONG i;
    LPVOID ace;
    ACCESS_ALLOWED_ACE *accessAllowedAce;
    ACCESS_DENIED_ACE *accessDeniedAce;
    SYSTEM_AUDIT_ACE *systemAuditAce;
    DWORD returnValue;
    ACE_HEADER *aceHeader;

    GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &ace))
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce(pAcl, i);
                return S_OK;
            }
        }
    }
    return S_OK;
}


BOOL
CSecurityDescriptor::DoesPrincipleHaveAce(
    LPCTSTR     pszPrincipal
    )
{
    PSID    principalSID = NULL;

    if ( FAILED( GetPrincipalSID( pszPrincipal, &principalSID ) ) )
    {
        return FALSE;
    }

    return DoesPrincipleHaveAce( principalSID );
}   //  CSecurityDescriptor::DoesPrincipleHaveAce


BOOL
CSecurityDescriptor::DoesPrincipleHaveAce(
    PSID    principalSID
    )
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    ULONG i;
    LPVOID ace;
    ACCESS_ALLOWED_ACE *accessAllowedAce;
    ACCESS_DENIED_ACE *accessDeniedAce;
    SYSTEM_AUDIT_ACE *systemAuditAce;
    DWORD returnValue;
    ACE_HEADER *aceHeader;

    GetAclInformation(
    m_pDACL,
    ( LPVOID ) &aclSizeInfo,
    ( DWORD ) sizeof( ACL_SIZE_INFORMATION ),
    AclSizeInformation );

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
    if ( !GetAce( m_pDACL, i, &ace ) )
    {
        return FALSE;
    }

    aceHeader = ( ACE_HEADER * ) ace;

    if ( aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE )
    {
        accessAllowedAce = ( ACCESS_ALLOWED_ACE * ) ace;

        if ( EqualSid( principalSID, ( PSID ) &accessAllowedAce->SidStart ) )
        {
        return TRUE;
        }
    }
    else if ( aceHeader->AceType == ACCESS_DENIED_ACE_TYPE )
    {
        accessDeniedAce = ( ACCESS_DENIED_ACE * ) ace;

        if ( EqualSid( principalSID, ( PSID ) &accessDeniedAce->SidStart ) )
        {
        return TRUE;
        }
    } else if ( aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE )
    {
        systemAuditAce = ( SYSTEM_AUDIT_ACE * ) ace;

        if ( EqualSid( principalSID, ( PSID ) &systemAuditAce->SidStart ) )
        {
        return TRUE;
        }
    }
    }
    return FALSE;
}   //  CSecurityDescriptor::DoesPrincipleHaveAce


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
    HRESULT hr=S_OK;
    TOKEN_PRIVILEGES tpPrevious;
    TOKEN_PRIVILEGES tp;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID luid;
    BOOL bOwnToken=FALSE;

    // if no token specified open process token
    if (hToken == 0)
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto cleanup;
        }
        bOwnToken = TRUE;
    }

    if (!LookupPrivilegeValue(NULL, privilege, &luid ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto cleanup;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto cleanup;
    }

    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (bEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto cleanup;
    }

cleanup:

    if (bOwnToken && hToken)
    {
       CloseHandle(hToken);
    }


    return hr;
}


LPTSTR CSecurityDescriptor::GenerateSDString(PSECURITY_DESCRIPTOR OPTIONAL pSd,
                         DWORD OPTIONAL fSecInfo)
{
/*+++
Function   : GenerateSDString
Description: Uses SDDL to generate a SD string
Parameters : pSd: Optional SD to convert
         fSecInfo: Optional requested security information flag
Return     : a pointer to LocalAlloc'eted string representation of SD
         NULL on error.
Remarks    : Must free returned string w/ LocalFree.
         Use GetLastError if you get back a NULL
---*/

   PSECURITY_DESCRIPTOR pTmpSd = pSd ? pSd : m_pSD;
   LPTSTR pwsSd = NULL;

   if (!pTmpSd)
   {
      return NULL;
   }

   ConvertSecurityDescriptorToStringSecurityDescriptor(pTmpSd,
                               SDDL_REVISION,
                               fSecInfo,
                               &pwsSd,
                               NULL);
   return pwsSd;
}




PSID CSecurityDescriptor::ExtractAceSid( ACCESS_ALLOWED_ACE* pACE )
/*++

Routine Description (ExtractAceSid):

    Extract a Sid from an ace based on the ace's type

Arguments:

    ACE in old format (ACCESS_ALLOWED_ACE)


Return Value:

    ptr to a sid;




Remarks:
    None.


--*/
{

    PBYTE ptr = NULL;

    ASSERT ( pACE );

    if ( pACE->Header.AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {

    //
    // Simple case ACE
    //
    ptr = (PBYTE)&(pACE->SidStart);
    }
    else if ( pACE->Header.AceType <= ACCESS_MAX_MS_V3_ACE_TYPE )
    {
    //
    // Compound ACE case
    //
    // PCOMPOUND_ACCESS_ALLOWED_ACE pObjAce = (PCOMPOUND_ACCESS_ALLOWED_ACE)pACE;
    // I think this case in term of typecasting is equivalent
    // to the previous one. Left for clarity, later can collapse down.

    ptr = (PBYTE)&(pACE->SidStart);

    }
    else if ( pACE->Header.AceType <= ACCESS_MAX_MS_V4_ACE_TYPE )
    {
    //
    // Object ACEs
    //
    ACCESS_ALLOWED_OBJECT_ACE *pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*)pACE;
    ptr = (PBYTE)&(pObjAce->ObjectType);

    if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
    {
        ptr += sizeof(GUID);
    }

    if (pObjAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
    {
        ptr += sizeof(GUID);
    }

    }

    return (PSID)ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\debug.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Domain Name System (DNS) Server

    Debug routines for server datatypes.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

--*/


#include "dnssrv.h"


#if DBG

//
//  Debug flag globals
//

DWORD   DnsSrvDebugFlag = 0;
DWORD   DnsLibDebugFlag = 0;

//
//  Note, debug globals (flag, file handle) and basic debug printing
//  routines are now in dnslib.lib and\or dnsapi.dll
//

//
//  empty string
//

CHAR    szEmpty = 0;
PCHAR   pszEmpty = &szEmpty;


//
//  Private debug utilities
//

BOOL
dumpTreePrivate(
    IN      PDB_NODE    pNode,
    IN      INT         Indent
    );



//
//  Dbg_TimeString
//
//  This is grossly inefficient, but quick-n-dirty for logging time:
//      DNS_DEBUG( ZONEXFR, ( "FOO at %s\n", Dbg_TimeString() ));
//

PCHAR
Dbg_TimeString(
    VOID
    )
{
    #define DBG_TIME_STRING_COUNT   20      //  larger is safer

    DNS_STATUS      status;
    static PCHAR    pszBuff;
    static CHAR     szStaticBuffers[ DBG_TIME_STRING_COUNT ][ 20 ];
    static LONG     idx = 0;
    int             myIdx;
    SYSTEMTIME      st;

    myIdx = InterlockedIncrement( &idx );
    if ( myIdx >= DBG_TIME_STRING_COUNT )
    {
        myIdx = idx = 0;    //  a bit unsafe
    }
    pszBuff = szStaticBuffers[ myIdx ];  

    GetLocalTime( &st );

    status = StringCchPrintfA(
                    pszBuff,
                    20,
                    "%02d:%02d:%02d.%03d",
                    st.wHour,
                    st.wMinute,
                    st.wSecond,
                    st.wMilliseconds );
    if ( FAILED( status ) )
    {
        *pszBuff = '\0';
    }

    return pszBuff;
}   //  Dbg_TimeString



//
//  General debug utils
//

VOID
Dbg_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
{
    DnsPrintf(
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );

    DnsDebugFlush();

    //
    //  unfortunately many folks have debug flags set to jump into the kernel
    //      debugger;  to prevent us from doing this, we'll only call DebugBreak()
    //      when at least some debug flags are set
    //
    //  DEVNOTE: it would be cool to check if a user mode debugger has attached
    //          itself -- but i'd imagine that we can't tell the difference between
    //          this and the typical "ntsd -d" pipe to kd
    //

    IF_DEBUG( ASSERTS )
    {
        DebugBreak();
    }
}



VOID
Dbg_TestAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
/*++

Routine Description:

    Test ASSERT().  May fire under abnormal conditions, but we always
    want to know about it.

Arguments:

Return Value:

    None.

--*/
{
    DnsPrintf(
        "ERROR:  TEST-ASSERT( %s ) failed!!!\n"
        "    in %s line %d\n",
        pszExpr,
        pszFile,
        LineNo );
    DnsDebugFlush();

    IF_DEBUG( ASSERTS )
    {
        DebugBreak();
    }
}



//
//  Debug print routines for DNS types and structures
//

INT
Dbg_MessageNameEx(
    IN      LPSTR           pszHeader,  OPTIONAL
    IN      PBYTE           pName,
    IN      PDNS_MSGINFO    pMsg,       OPTIONAL
    IN      PBYTE           pEnd,       OPTIONAL
    IN      LPSTR           pszTrailer  OPTIONAL
    )
/*++

Routine Description:

    Print DNS name in a message.

Arguments:

    pszHeader - header to print

    pName - ptr to name in packet to print

    pMsg - ptr to message;  if not given name can not contain offsets,
            and there is no protection against bad names

    pEnd - ptr to byte after end of allowable memory;
            OPTIONAL, if given name restricted to below this ptr
            if not given and pMsg given, name restricted to message;
            this allows tighter restriction then message when known
            name length or known to be in packet RR

    pszTrailer - trailer;  OPTIONAL, if not given print newline

Return Value:

    Count of bytes printed.

--*/
{
    INT     byteCount;


    //
    //  if not given end and have message, use message end
    //

    if ( !pEnd && pMsg )
    {
        pEnd = DNSMSG_END(pMsg);
    }

    //
    //  if not given header, use "Name:  "
    //  if not given trailer, use newline
    //

    if ( !pszHeader )
    {
        pszHeader = "Name:  ";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "\n";
    }

    byteCount = DnsDbg_PacketName(
                    pszHeader,
                    pName,
                    DNS_HEADER_PTR(pMsg),
                    pEnd,
                    pszTrailer );
    return byteCount;
}



VOID
Dbg_DnsMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    )
{
    PCHAR       pch;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        messageLength;
    WORD        offset;
    WORD        xid;
    WORD        questionCount;
    WORD        answerCount;
    WORD        authorityCount;
    WORD        additionalCount;
    WORD        countSectionRR;
    BOOL        bflipped = FALSE;

    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( "%s\n", pszHeader );
    }

    messageLength = pMsg->MessageLength;

    DnsPrintf(
        "%s %s info at %p\n"
        "  Socket = %u\n"
        "  Remote addr %s, port %u\n"
        "  Time Query=%u, Queued=%u, Expire=%u\n"
        "  Max buf length = 0x%04x (%d)\n"
        "  Buf length = 0x%04x (%d)\n"
        "  Msg length = 0x%04x (%d)\n"
        "  Message:\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pMsg->Head.IsResponse
            ? "response"
            : "question"),
        pMsg,
        pMsg->Socket,
        DNSADDR_STRING( &pMsg->RemoteAddr ),
        ntohs( pMsg->RemoteAddr.SockaddrIn6.sin6_port ),
        pMsg->dwQueryTime,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        pMsg->MaxBufferLength, pMsg->MaxBufferLength,
        pMsg->BufferLength, pMsg->BufferLength,
        messageLength, messageLength );

    DnsPrintf(
        "    XID       0x%04hx\n"
        "    Flags     0x%04hx\n"
        "        QR        %x (%s)\n"
        "        OPCODE    %x (%s)\n"
        "        AA        %x\n"
        "        TC        %x\n"
        "        RD        %x\n"
        "        RA        %x\n"
        "        Z         %x\n"
        "        RCODE     %x (%s)\n"
        "    QCOUNT    0x%hx\n"
        "    ACOUNT    0x%hx\n"
        "    NSCOUNT   0x%hx\n"
        "    ARCOUNT   0x%hx\n",

        pMsg->Head.Xid,
        ntohs( DNSMSG_FLAGS(pMsg) ),
        pMsg->Head.IsResponse,
        (pMsg->Head.IsResponse ? "response" : "question"),
        pMsg->Head.Opcode,
        Dns_OpcodeString( pMsg->Head.Opcode ),
        pMsg->Head.Authoritative,
        pMsg->Head.Truncation,
        pMsg->Head.RecursionDesired,
        pMsg->Head.RecursionAvailable,
        pMsg->Head.Reserved,
        pMsg->Head.ResponseCode,
        Dns_ResponseCodeString( pMsg->Head.ResponseCode ),

        pMsg->Head.QuestionCount,
        pMsg->Head.AnswerCount,
        pMsg->Head.NameServerCount,
        pMsg->Head.AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    xid                = pMsg->Head.Xid;
    questionCount      = pMsg->Head.QuestionCount;
    answerCount        = pMsg->Head.AnswerCount;
    authorityCount     = pMsg->Head.NameServerCount;
    additionalCount    = pMsg->Head.AdditionalCount;

    if ( questionCount )
    {
        bflipped = questionCount & 0xff00;
    }
    else if ( authorityCount )
    {
        bflipped = authorityCount & 0xff00;
    }
    if ( bflipped )
    {
        xid                = ntohs( xid );
        questionCount      = ntohs( questionCount );
        answerCount        = ntohs( answerCount );
        authorityCount     = ntohs( authorityCount );
        additionalCount    = ntohs( additionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //
    //  if def this out to allow bad packet testing

    if ( (questionCount & 0xff00) ||
        (authorityCount & 0xff00) ||
        (additionalCount & 0xff00) )
    {
        DnsPrintf(
            "WARNING:  Invalid RR set counts -- possible bad packet\n"
            "    terminating packet print.\n" );
        //  A bad packet is not worthy of assert.
        //  TEST_ASSERT( FALSE );
        goto Unlock;
    }

    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsg->Head.IsResponse &&
            IS_WINS_XID(xid) &&
            ntohs( pMsg->RemoteAddr.SockaddrIn6.sin6_port ) == WINS_REQUEST_PORT )
    {
        DnsPrintf( "  WINS Response packet.\n\n" );
        goto Unlock;
    }

    //
    //  print questions and resource records
    //

    pch = pMsg->MessageBody;

    for ( isection=0; isection<4; isection++)
    {
        if ( isection==0 )
        {
            countSectionRR = questionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = answerCount;
            DnsPrintf( "    ANSWER SECTION:\n" );
        }
        else if ( isection==2 )
        {
            countSectionRR = authorityCount;
            DnsPrintf( "    AUTHORITY SECTION:\n" );
        }
        else if ( isection==3 )
        {
            countSectionRR = additionalCount;
            DnsPrintf( "    ADDITIONAL SECTION:\n" );
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            offset = DNSMSG_OFFSET( pMsg, pch );
            if ( offset >= messageLength  &&  pch >= pMsg->pCurrent )
            {
                DnsPrintf(
                    "ERROR:  BOGUS PACKET:\n"
                    "    Following RR (offset %hu) past packet length (%d).\n"
                    "    pch = %p, pCurrent = %p, %d bytes\n",
                    offset,
                    messageLength,
                    pch,
                    pMsg->pCurrent,
                    pMsg->pCurrent - pch );
                //  A bad packet is not worthy of assert.
                //  TEST_ASSERT( FALSE );
                goto Unlock;
            }
            if ( pch >= pMsg->pBufferEnd )
            {
                DnsPrintf(
                    "ERROR:  next record name at %p is beyond end of message buffer at %p!\n\n",
                    pch,
                    pMsg->pBufferEnd );
                //  A bad packet is not worthy of assert.
                //  TEST_ASSERT( FALSE );
                break;
            }

            //
            //  print RR name
            //

            DnsPrintf(
                "    Offset = 0x%04x, RR count = %d\n",
                offset,
                i );

            cchName = DnsDbg_PacketName(
                            "    Name      \"",
                            pch,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END( pMsg ),
                            "\"\n" );
            if ( ! cchName )
            {
                DnsPrintf( "ERROR:  Invalid name length, stop packet print\n" );
                //  A bad packet is not worthy of assert.
                //  TEST_ASSERT( FALSE );
                break;
            }
            pch += cchName;
            if ( pch >= pMsg->pBufferEnd )
            {
                DnsPrintf(
                    "ERROR:  next record data at %p is beyond end of message buffer at %p!\n\n",
                    pch,
                    pMsg->pBufferEnd );
                //  A bad packet is not worthy of assert.
                //  TEST_ASSERT( FALSE );
                break;
            }

            //  print question or resource record

            if ( isection == 0 )
            {
                WORD    type = FlipUnalignedWord( pch );

                DnsPrintf(
                    "      QTYPE   %s (%u)\n"
                    "      QCLASS  %u\n",
                    DnsRecordStringForType( type ),
                    type,
                    FlipUnalignedWord( pch + sizeof(WORD) ) );
                pch += sizeof( DNS_QUESTION );
            }
            else
            {
#if 0
                pch += Dbg_MessageRecord(
                            NULL,
                            (PDNS_WIRE_RECORD) pch,
                            pMsg );
#endif
                pch += DnsDbg_PacketRecord(
                            NULL,
                            (PDNS_WIRE_RECORD) pch,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END(pMsg) );
            }
        }
    }

    //  check that at proper end of packet
    //  note:  don't check against pCurrent as when print after recv,
    //      it is unitialized
    //  if MS fast transfer tag, just print it

    offset = DNSMSG_OFFSET( pMsg, pch );
    if ( offset < messageLength )
    {
        if ( offset+2 == messageLength )
        {
            DnsPrintf( "    TAG: %c%c\n", *pch, *(pch+1) );
        }
        else
        {
            DnsPrintf(
                "WARNING:  message continues beyond these records\n"
                "    pch = %p, pCurrent = %p, %d bytes\n"
                "    offset = %hu, msg length = %hu, %d bytes\n",
                pch,
                pMsg->pCurrent,
                pMsg->pCurrent - pch,
                offset,
                messageLength,
                messageLength - offset );
        }
    }
    DnsPrintf( "\n" );

Unlock:
    DnsDebugUnlock();
}   //  Dbg_DnsMessage




VOID
Dbg_Zone(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Print zone information

Arguments:

    pszHeader - name/message before zone print

    pZone - zone information to print

Return Value:

    None.

--*/
{
    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( pszHeader );
    }
    if ( pZone == NULL )
    {
        DnsPrintf( "(NULL Zone ptr)\n" );
        goto Done;
    }

    //
    //  cache zone -- nothing much of interest
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DnsPrintf(
            "Cache \"zone\"\n"
            "  ptr      = %p\n"
            "  file     = %s\n",
            pZone,
            pZone->pszDataFile );
        goto Done;
    }

    //
    //  primary or secondary, verify link to zone root node
    //

    ASSERT( !pZone->pZoneRoot || pZone->pZoneRoot->pZone == pZone );
    ASSERT( !pZone->pLoadZoneRoot || pZone->pLoadZoneRoot->pZone == pZone );

    DnsPrintf(
        "%s zone %S\n"
        "  Zone ptr         = %p\n"
        "  Name UTF8        = %s\n"
        "  File             = %S\n"
        "  DS Integrated    = %d\n"
        "  AllowUpdate      = %d\n",
        IS_ZONE_PRIMARY(pZone) ? "Primary" : "Secondary",
        pZone->pwsZoneName,
        pZone,
        pZone->pszZoneName,
        pZone->pwsDataFile,
        pZone->fDsIntegrated,
        pZone->fAllowUpdate );

    DnsPrintf(
        "  pZoneTreeLink    = %p\n"
        "  pZoneRoot        = %p\n"
        "  pTreeRoot        = %p\n"
        "  pLoadZoneRoot    = %p\n"
        "  pLoadTreeRoot    = %p\n"
        "  pLoadOrigin      = %p\n",
        pZone->pZoneTreeLink,
        pZone->pZoneRoot,
        pZone->pTreeRoot,
        pZone->pLoadZoneRoot,
        pZone->pLoadTreeRoot,
        pZone->pLoadOrigin );

    DnsPrintf(
        "  Version          = %lu\n"
        "  Loaded Version   = %lu\n"
        "  Last Xfr Version = %lu\n"
        "  SOA RR           = %p\n"
        "  WINS RR          = %p\n"
        "  Local WINS RR    = %p\n",
        pZone->dwSerialNo,
        pZone->dwLoadSerialNo,
        pZone->dwLastXfrSerialNo,
        pZone->pSoaRR,
        pZone->pWinsRR,
        pZone->pLocalWinsRR );

    DnsPrintf(
        "  Flags:\n"
        "    fZoneType      = %d\n"
        "    label count    = %d\n"
        "    fReverse       = %d\n"
        "    fDsIntegrated  = %d\n"
        "    fAutoCreated   = %d\n"
        "    fSecureSeconds = %d\n"
        "\n"
        "  State:\n"
        "    fDirty         = %d\n"
        "    fRootDirty     = %d\n"
        "    fLocalWins     = %d\n"
        "    fPaused        = %d\n"
        "    fShutdown      = %d\n"
        "    fInDsWrite     = %d\n"
        "\n"
        "  Locking:\n"
        "    fLocked        = %d\n"
        "    ThreadId       = %d\n"
        "    fUpdateLock    = %d\n"
        "    fXfrRecv       = %d\n"
        "    fFileWrite     = %d\n"
        "\n",
        pZone->fZoneType,
        pZone->cZoneNameLabelCount,
        pZone->fReverse,
        pZone->fDsIntegrated,
        pZone->fAutoCreated,
        pZone->fSecureSecondaries,

        pZone->fDirty,
        pZone->fRootDirty,
        pZone->fLocalWins,
        pZone->fPaused,
        pZone->fShutdown,
        pZone->fInDsWrite,

        pZone->fLocked,
        pZone->dwLockingThreadId,
        pZone->fUpdateLock,
        pZone->fXfrRecvLock,
        pZone->fFileWriteLock );

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        DnsPrintf(
            "  Primary Info:\n"
            "    last transfer  = %u\n"
            "    next transfer  = %u\n"
            "    next DS poll   = %u\n"
            "    szLastUsn      = %s\n"
            "    hUpdateLog     = %d\n"
            "    update log cnt = %d\n"
            "    RR count       = %d\n"
            "\n",
            LAST_SEND_TIME( pZone ),
            pZone->dwNextTransferTime,
            ZONE_NEXT_DS_POLL_TIME(pZone),
            pZone->szLastUsn,
            pZone->hfileUpdateLog,
            pZone->iUpdateLogCount,
            pZone->iRRCount );
    }
    else if ( IS_ZONE_SECONDARY(pZone) )
    {
        DnsPrintf(
            "  Secondary Info:\n"
            "    last check     = %lu\n"
            "    next check     = %lu\n"
            "    expiration     = %lu\n"
            "    fNotified      = %d\n"
            "    fStale         = %d\n"
            "    fEmpty         = %d\n"
            "    fNeedAxfr      = %d\n"
            "    fSkipIxfr      = %d\n"
            "    fSlowRetry     = %d\n"
            "    cIxfrAttempts  = %d\n"
            "\n"
            "    recv starttime = %lu\n"
            "    bad master cnt = %d\n"
            "    ipPrimary      = %s\n"
            "    ipLastAxfr     = %s\n"
            "    ipXfrBind      = %s\n"
            "    ipNotifier     = %s\n"
            "    ipFreshMaster  = %s\n"
            "\n",
            pZone->dwLastSoaCheckTime,
            pZone->dwNextSoaCheckTime,
            pZone->dwExpireTime,
            pZone->fNotified,
            pZone->fStale,
            pZone->fEmpty,
            pZone->fNeedAxfr,
            pZone->fSkipIxfr,
            pZone->fSlowRetry,
            pZone->cIxfrAttempts,

            pZone->dwZoneRecvStartTime,
            pZone->dwBadMasterCount,
            DNSADDR_STRING( &pZone->ipPrimary ),
            DNSADDR_STRING( &pZone->ipLastAxfrMaster ),
            DNSADDR_STRING( &pZone->ipXfrBind ),
            DNSADDR_STRING( &pZone->ipNotifier ),
            DNSADDR_STRING( &pZone->ipFreshMaster ) );

        DnsDbg_DnsAddrArray(
            "  Master list: ",
            "    master",
            pZone->aipMasters );
    }
    else
    {
        DnsPrintf( "ERROR:  Invalid zone type!\n" );
    }

    DnsDbg_DnsAddrArray(
        "  Secondary list: ",
        "    \tsecondary",
        pZone->aipSecondaries );

    DnsPrintf(
        "  Count name       = %p\n"
        "  LogFile          = %S\n"
        "  DS Name          = %S\n"
        "\n"
        "  New serial       = %u\n"
        "  Default TTL      = %d\n"
        "  IP reverse       = %S\n"
        "  IP reverse mask  = %d (bits)\n"
        "\n\n",
        pZone->pCountName,
        pZone->pwsLogFile,
        pZone->pwszZoneDN,

        pZone->dwNewSerialNo,
        pZone->dwDefaultTtlHostOrder,
        DNSADDR_STRING( &pZone->ipReverse ),
        pZone->ipReverse.SubnetLength );
Done:

    DnsDebugUnlock();
}





VOID
Dbg_ZoneList(
    IN      LPSTR           pszHeader
    )
/*++

Routine Description:

    Print all zones in zone list.

Arguments:

    pszHeader - name/message before zone list print

Return Value:

    None.

--*/
{
    PZONE_INFO  pZone = NULL;

    if ( !pszHeader )
    {
        pszHeader = "\nZone list:\n";
    }
    DnsDebugLock();

    DnsPrintf( pszHeader );

    //
    //  walk zone list printing zones
    //

    while ( pZone = Zone_ListGetNextZone(pZone) )
    {
        Dbg_Zone( NULL, pZone );
    }

    DnsPrintf( "*** End of Zone List ***\n\n" );

    DnsDebugUnlock();
}



INT
Dbg_NodeName(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Print node name corresponding to node in database.

Arguments:

    pszHeader - name/message before node print

    pnode - node to print name for

    pszTrailer - string to follow node print

Return Value:

    None.

--*/
{
    CHAR    szname[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PCHAR   pch;
    BOOLEAN fPrintedAtLeastOneLabel = FALSE;

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pszTrailer )
    {
        pszTrailer = pszEmpty;
    }
    DnsDebugLock();

    if ( pNode == NULL )
    {
        DnsPrintf( "%s (NULL node ptr) %s", pszHeader, pszTrailer );
        goto Done;
    }

    //
    //  cut node -- then can't proceed up tree (tree isn't there)
    //

    if ( IS_CUT_NODE(pNode) )
    {
        DnsPrintf(
            "%s cut-node label=\"%s\"%s",
            pszHeader,
            pNode->szLabel,
            pszTrailer );
        goto Done;
    }

    //
    //
    //  get node name
    //

    pch = Name_PlaceFullNodeNameInBuffer(
                szname,
                szname + DNS_MAX_NAME_BUFFER_LENGTH,
                pNode );
    DnsPrintf(
        "%s \"%s\"%s",
        pszHeader,
        pch ? szname : "ERROR: bad node name!!!",
        pszTrailer );

Done:

    DnsDebugUnlock();
    return( 0 );
}



VOID
Dbg_DbaseNodeEx(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwIndent    OPTIONAL
    )
/*++

Routine Description:

    Print node in database.

Arguments:

    pchHeader - header to print

    pNode - root node of tree/subtree to print

    dwIndent - indentation count, useful for database tree printing;
        if 0, then no indentation formatting is done

Return Value:

    None.

--*/
{
    DWORD       iIndent;
    PDB_RECORD  pRR;

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    DnsDebugLock();

    //
    //  indent node for dbase listing
    //      - indent two characters each time
    //      - prefix node with leader of desired indent length
    //

    if ( dwIndent )
    {
        DnsPrintf(
            "%.*s",
            (dwIndent << 1),
            "+-----------------------------------------------------------------" );
    }

    if ( pNode == NULL )
    {
        DnsPrintf( "%s NULL domain node ptr.\n", pszHeader );
        goto Unlock;
    }

    if ( IS_SELECT_NODE(pNode) )
    {
        DnsPrintf( "%s select node -- skipping.\n", pszHeader );
        goto Unlock;
    }

    Dbg_NodeName(
        pszHeader,
        pNode,
        NULL );

    //
    //  print node flags, version info
    //  print child and reference counts
    //      - if not indenting bring down new line
    //

    DnsPrintf(
        "%s %p %s(%08lx %s%s%s%s)(z=%p)(b=%d) ",
        dwIndent ? " " : "\n    => ",
        pNode,
        IS_NOEXIST_NODE(pNode) ? "(NXDOM) " : pszEmpty,
        pNode->dwNodeFlags,
        IS_AUTH_ZONE_ROOT(pNode)    ? "A" : pszEmpty,
        IS_ZONE_ROOT(pNode)         ? "Z" : pszEmpty,
        IS_CNAME_NODE(pNode)        ? "C" : pszEmpty,
        IS_WILDCARD_PARENT(pNode)   ? "W" : pszEmpty,
        pNode->pZone,
        pNode->uchAccessBin );

    DnsPrintf(
        " (cc=%d) (par=%p) (lc=%d)\n",
        pNode->cChildren,
        pNode->pParent,
        pNode->cLabelCount );

    //
    //  zone root, check link to zone
    //

    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        PZONE_INFO pZone = (PZONE_INFO) pNode->pZone;
        if ( pZone )
        {
            if ( pZone->pZoneRoot != pNode  &&
                 pZone->pLoadZoneRoot != pNode  &&
                 pZone->pZoneTreeLink != pNode )
            {
                DnsPrintf(
                    "ERROR:  Auth zone root node (%p) with bogus zone ptr.\n"
                    "    pzone = %p (%s)\n"
                    "    zone root        = %p\n"
                    "    load zone root   = %p\n"
                    "    zone tree link   = %p\n",
                    pNode,
                    pZone,
                    pZone->pszZoneName,
                    pZone->pZoneRoot,
                    pZone->pLoadZoneRoot,
                    pZone->pZoneTreeLink );
            }
        }
        else if ( !IS_SELECT_NODE(pNode) )
        {
            DnsPrintf(
                "ERROR:  Auth zone root node with bogus zone ptr.\n"
                "    node = %p, label %s -- NULL zone root ptr.\n",
                pNode, pNode->szLabel );
            ASSERT( FALSE );
        }
    }

    //
    //  print all RR in node
    //      - if indenting, indent all RRs by two characters
    //

    pRR = FIRST_RR( pNode );

    while ( pRR != NULL )
    {
        if ( dwIndent )
        {
            DnsPrintf(
                "%.*s",
                (dwIndent << 1),
                "|                                                          " );
        }
        Dbg_DbaseRecord( "   ", pRR );
        pRR = pRR->pRRNext;
    }

Unlock:
    DnsDebugUnlock();
}



INT
Dbg_DnsTree(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Print entire tree or subtree from a given node of the database.

Arguments:

    pszHeader - print header

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    INT rv;

    //
    //  need to hold database lock during entire print
    //  reason is there are plenty of places in the code that
    //  debug print while holding database lock, hence to avoid
    //  deadlock, must hold database lock while holding print lock
    //

    if ( !pszHeader )
    {
        pszHeader = "Database subtree";
    }

    Dbase_LockDatabase();
    DnsDebugLock();

    DnsPrintf( "%s:\n", pszHeader );
    rv = dumpTreePrivate(
            pNode,
            1 );
    DnsPrintf( "\n" );

    DnsDebugUnlock();
    Dbase_UnlockDatabase();

    return rv;
}



VOID
Dbg_CountName(
    IN      LPSTR           pszHeader,
    IN      PDB_NAME        pName,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)

--*/
{
    PUCHAR  pch;
    DWORD   labelLength;
    PUCHAR  pchstop;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pName )
    {
        DnsPrintf( "%s NULL name to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    DnsPrintf(
        "%s [%d][%d] ",
        pszHeader,
        pName->Length,
        pName->LabelCount );


    //
    //  print each label
    //

    pch = pName->RawName;
    pchstop = pch + pName->Length;

    while ( labelLength = *pch++ )
    {
        if ( labelLength > DNS_MAX_LABEL_LENGTH )
        {
            DnsPrintf( "[ERROR:  bad label count = %d]", labelLength );
            break;
        }
        DnsPrintf(
            "(%d)%.*s",
            labelLength,
            labelLength,
            pch );

        pch += labelLength;

        if ( pch >= pchstop )
        {
            DnsPrintf( "[ERROR:  bad count name, printing past length!]" );
            break;
        }
    }

    if ( !pszTrailer )
    {
        pszTrailer = "\n";
    }
    DnsPrintf( "%s", pszTrailer );

    DnsDebugUnlock();
}



VOID
Dbg_LookupName(
    IN      LPSTR           pszHeader,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Debug print lookup name.

Arguments:

    pszHeader - header to print with lookup name

    pLookupName - lookup name

Return Value:

    None.

--*/
{
    INT     cLabel;
    PCHAR   pch;

    DnsDebugLock();

    DnsPrintf(
        "%s:\n"
        "    LabelCount = %d\n"
        "    NameLength = %d\n",
        pszHeader ? pszHeader : "Lookup Name",
        pLookupName->cLabelCount,
        pLookupName->cchNameLength );

    for (cLabel=0; cLabel < pLookupName->cLabelCount; cLabel++ )
    {
        pch = pLookupName->pchLabelArray[cLabel];

        DnsPrintf(
            "    ptr = 0x%p;  count = %d;  label = %.*s\n",
            pch,
            pLookupName->cchLabelArray[cLabel],
            pLookupName->cchLabelArray[cLabel],
            pch );
    }
    DnsDebugUnlock();
}



VOID
Dbg_DbaseRecord(
    IN      LPSTR           pszHeader,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Print RR in packet format.

Arguments:

    pszHeader - Header message/name for RR.

    pdnsRR - resource record to print

    pszTrailer - Trailer to print after RR.

Return Value:

    None.

--*/
{
    PCHAR       prrString;
    PDB_NAME    pname;
    PCHAR       pch;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pRR )
    {
        DnsPrintf( "%s NULL RR to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    //
    //  print RR fixed fields
    //

    prrString = Dns_RecordStringForType( pRR->wType );

    DnsPrintf(
        "%s %s (R=%02x) (%s%s%s%s) (TTL: %lu %lu) (ATS=%d) ",
        pszHeader,
        prrString,
        RR_RANK(pRR),
        IS_CACHE_RR(pRR)        ? "C" : pszEmpty,
        IS_ZERO_TTL_RR(pRR)     ? "0t" : pszEmpty,
        IS_FIXED_TTL_RR(pRR)    ? "Ft" : pszEmpty,
        IS_ZONE_TTL_RR(pRR)     ? "Zt" : pszEmpty,
        pRR->dwTtlSeconds,
        IS_CACHE_RR(pRR) ? (pRR->dwTtlSeconds-DNS_TIME()) : ntohl(pRR->dwTtlSeconds),
        pRR->dwTimeStamp );

    if ( RR_RANK(pRR) == 0  &&  !IS_WINS_TYPE(pRR->wType) )
    {
        DnsPrintf( "[UN-RANKED] " );
    }

    //
    //  empty auth?
    //

    if ( IS_EMPTY_AUTH_RR( pRR ) )
    {
        DnsPrintf(
            "empty record set\n" );
        goto Done;
    }

    //
    //  print RR data
    //

    switch ( pRR->wType )
    {

    case DNS_TYPE_A:

        DnsPrintf(
            "%d.%d.%d.%d\n",
            * ( (PUCHAR) &(pRR->Data.A) + 0 ),
            * ( (PUCHAR) &(pRR->Data.A) + 1 ),
            * ( (PUCHAR) &(pRR->Data.A) + 2 ),
            * ( (PUCHAR) &(pRR->Data.A) + 3 ) );
        break;

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_NOEXIST:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single indirection
        //

        Dbg_DbaseName(
            NULL,
            & pRR->Data.NS.nameTarget,
            NULL );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        DnsPrintf(
            "%d ",
            ntohs( pRR->Data.MX.wPreference ) );
        Dbg_DbaseName(
            NULL,
            & pRR->Data.MX.nameExchange,
            NULL );
        break;

    case DNS_TYPE_SOA:

        pname = & pRR->Data.SOA.namePrimaryServer;

        Dbg_DbaseName(
            "\n\tPrimaryServer: ",
            pname,
            NULL );
        pname = Name_SkipDbaseName( pname );

        Dbg_DbaseName(
            "    ZoneAdministrator: ",
            pname,
            NULL );

        DnsPrintf(
            "    SerialNo     = %lu\n"
            "    Refresh      = %lu\n"
            "    Retry        = %lu\n"
            "    Expire       = %lu\n"
            "    MinimumTTL   = %lu\n",
            ntohl( pRR->Data.SOA.dwSerialNo ),
            ntohl( pRR->Data.SOA.dwRefresh ),
            ntohl( pRR->Data.SOA.dwRetry ),
            ntohl( pRR->Data.SOA.dwExpire ),
            ntohl( pRR->Data.SOA.dwMinimumTtl ) );
        break;

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        pname = & pRR->Data.MINFO.nameMailbox;

        Dbg_DbaseName(
            NULL,
            pname,
            "" );
        pname = Name_SkipDbaseName( pname );

        Dbg_DbaseName(
            "  ",
            pname,
            NULL );
        break;

    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    case DNS_TYPE_TEXT:
    {
        //
        //  all these are simply text string(s)
        //

        PCHAR   pchrover = pRR->Data.TXT.chData;
        PCHAR   pchstop = pchrover + pRR->wDataLength;
        UCHAR   cch;

        while ( pchrover < pchstop )
        {
            cch = (UCHAR) *pchrover++;
            DnsPrintf( "    %.*s\n", cch, pchrover );
            pchrover += cch;
        }
        ASSERT( pchrover == pchstop );
        break;
    }

    case DNS_TYPE_WKS:
    {
        INT i;

        DnsPrintf(
            "WKS: Address %d.%d.%d.%d\n"
            "    Protocol %d\n"
            "    Bitmask\n",
            * ( (PUCHAR) &(pRR->Data.WKS) + 0 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 1 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 2 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 3 ),
            pRR->Data.WKS.chProtocol );

        for ( i = 0;
                i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                    i++ )
        {
            DnsPrintf(
                "    \tbyte[%d] = 0x%02x\n",
                i,
                (UCHAR) pRR->Data.WKS.bBitMask[i] );
        }
        break;
    }

    case DNS_TYPE_NULL:
    {
        INT i;

        for ( i = 0; i < pRR->wDataLength; i++ )
        {
            //  print one DWORD per line

            if ( !(i%16) )
            {
                DnsPrintf( "\n\t" );
            }
            DnsPrintf(
                "%02x ",
                (UCHAR) pRR->Data.Null.chData[i] );
        }
        DnsPrintf( "\n" );
        break;
    }

    case DNS_TYPE_SRV:

        //  SRV <priority> <weight> <port>

        DnsPrintf(
            "%d %d %d ",
            ntohs( pRR->Data.SRV.wPriority ),
            ntohs( pRR->Data.SRV.wWeight ),
            ntohs( pRR->Data.SRV.wPort )
            );

        Dbg_DbaseName(
            NULL,
            & pRR->Data.SRV.nameTarget,
            NULL );
        break;

    case DNS_TYPE_WINS:
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - lookup and cache timeouts
        //      - WINS server list
        //

        Dns_WinsRecordFlagString(
            pRR->Data.WINS.dwMappingFlag,
            achFlag );

        DnsPrintf(
            "\n    flags           = %s (0x%p)\n"
            "    lookup timeout   = %d\n"
            "    cache timeout    = %d\n",
            achFlag,
            pRR->Data.WINS.dwMappingFlag,
            pRR->Data.WINS.dwLookupTimeout,
            pRR->Data.WINS.dwCacheTimeout );

        //
        // DEVNOTE: AV on trashed wins record
        //

#if 0
        DnsDbg_IpAddressArray(
            NULL,
            "    WINS Servers",
            pRR->Data.WINS.cWinsServerCount,
            pRR->Data.WINS.aipWinsServers );
#endif
        break;
    }

    case DNS_TYPE_WINSR:
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - lookup and cache timeouts
        //      - result domain
        //

        Dns_WinsRecordFlagString(
            pRR->Data.WINSR.dwMappingFlag,
            achFlag );

        DnsPrintf(
            "\nflags            = %s (0x%p)\n"
            "    lookup timeout   = %d\n"
            "    cache timeout    = %d\n",
            achFlag,
            pRR->Data.WINS.dwMappingFlag,
            pRR->Data.WINS.dwLookupTimeout,
            pRR->Data.WINS.dwCacheTimeout );

        Dbg_DbaseName(
            "    result domain    = ",
            & pRR->Data.WINSR.nameResultDomain,
            NULL );

        DnsPrintf( "\n" );
        break;
    }

    default:
        DnsPrintf(
            "Unknown resource record type %d at %p.\n",
            pRR->wType,
            pRR );
        break;
    }

    Done:

    DnsDebugUnlock();
}



VOID
Dbg_DsRecord(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD      pRR
    )
/*++

Routine Description:

    Print DS record.

Arguments:

    pszHeader - Header message/name for RR.

    pRR - DS record to print

    pszTrailer - Trailer to print after RR.

Return Value:

    None.

--*/
{
    PCHAR   prrString;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pRR )
    {
        DnsPrintf( "%s NULL RR to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    //
    //  print RR fixed fields
    //

    prrString = Dns_RecordStringForType( pRR->wType );

    DnsPrintf(
        "%s %s (%d) (len=%d) (rv=%d,rr=%d) (ver=%d) (TTL: %lu) (rt=%d)\n",
        pszHeader,
        prrString,
        pRR->wType,
        pRR->wDataLength,
        pRR->Version,
        pRR->Rank,
        pRR->dwSerial,
        pRR->dwTtlSeconds,
        pRR->dwTimeStamp );

    DnsDebugUnlock();
}



VOID
Dbg_DsRecordArray(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD *    ppDsRecord,
    IN      DWORD           dwCount
    )
{
    DWORD   i;

    DnsDebugLock();
    DnsPrintf( (pszHeader ? pszHeader : "") );

    if ( !ppDsRecord )
    {
        DnsPrintf( "NULL record buffer ptr.\n" );
        DnsDebugUnlock();
        return;
    }
    else
    {
        DnsPrintf(
            "Record array of length %d at %p:\n",
            dwCount,
            ppDsRecord );
    }

    //
    //  loop printing DS records
    //

    for( i=0; i<dwCount; i++ )
    {
        Dbg_DsRecord(
            "    DS record",
            ppDsRecord[i] );
    }
    DnsDebugUnlock();
}



//
//  Private debug utilities
//

BOOL
dumpTreePrivate(
    IN      PDB_NODE    pNode,
    IN      INT         Indent
    )
/*++

Routine Description:

    Print node in database, and walk subtree printing subnodes in database.

    NOTE:   This function should NOT BE CALLED DIRECTLY!
            This function calls itself recursively and hence to avoid
            unnecessary overhead, prints in this function are not protected.
            Use Dbg_DnsTree() to print tree/subtree in database.

Arguments:

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    //
    //  print the node
    //

    Dbg_DbaseNodeEx(
        NULL,
        pNode,
        (DWORD) Indent );

    //
    //  recurse, walking through child list printing all their subtrees
    //
    //  note:  no locking required as Dbg_DumpTree() holds database
    //          lock during entire call
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild;

        Indent++;
        pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            dumpTreePrivate(
                pchild,
                Indent );

            pchild = NTree_NextSibling( pchild );
        }
    }
    return( TRUE );
}



#include <Accctrl.h>
#include <Aclapi.h>
#include <tchar.h>


PWCHAR Dbg_DumpSid(
    PSID                    pSid
    )
{
    static WCHAR        szOutput[ 512 ];

    WCHAR               name[ 512 ] = L"";
    DWORD               namelen = sizeofarray( name );
    WCHAR               domain[ 512 ] = L"";
    DWORD               domainlen = sizeofarray( domain );
    SID_NAME_USE        sidNameUse = 0;
    DNS_STATUS          status;

    *szOutput = L'\0';
    
    if ( LookupAccountSidW(
            NULL,
            pSid,
            name,
            &namelen,
            domain,
            &domainlen,
            &sidNameUse ) )
    {
        if ( !*domain && !*name )
        {
            status = StringCchCopyW(
                            szOutput,
                            sizeofarray( szOutput ),
                            L"UNKNOWN" );
            if ( FAILED( status ) )
            {
                return szOutput;
            }
        }
        else
        {
            status = StringCchPrintfW(
                            szOutput,
                            sizeofarray( szOutput ),
                            L"%s%s%s",
                            domain, *domain ? L"\\" : L"", name );
            if ( FAILED( status ) )
            {
                return szOutput;
            }
        }
    }
    else
    {
        status = StringCchPrintfW(
                        szOutput,
                        sizeofarray( szOutput ),
                        L"failed=%d",
                        GetLastError() );
        if ( FAILED( status ) )
        {
            return szOutput;
        }
    }

    return szOutput;
}   //  Dbg_DumpSid


VOID Dbg_DumpAcl(
    PACL                    pAcl
    )
{
    ULONG                           i = 0;

    for ( i = 0; i < pAcl->AceCount; ++i )
    {
        ACCESS_ALLOWED_ACE *            paaAce = NULL;
        ACCESS_ALLOWED_OBJECT_ACE *     paaoAce = NULL;
        ACE_HEADER *                    pAce = NULL;
        PWCHAR                          pwsName;
		DWORD							dwMask;

        if ( !GetAce( pAcl, i, ( LPVOID * ) &pAce ) )
        {
            goto DoneDebug;
        }
        
        if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
        {
            paaAce = ( ACCESS_ALLOWED_ACE * ) pAce;
			dwMask = paaAce->Mask;
            pwsName = Dbg_DumpSid( ( PSID ) ( &paaAce->SidStart ) );
        }
        else
        {
            #if 0
            //  This sometimes AVs in LookupAccountSidW for some reason.
            paaoAce = ( ACCESS_ALLOWED_OBJECT_ACE * ) pAce;
			dwMask = paaoAce->Mask;
            pwsName = Dbg_DumpSid( ( PSID ) ( &paaoAce->SidStart ) );
            #endif
            DNS_DEBUG( ANY, ( "OBJECT ACE " ));
        }

        DNS_DEBUG( ANY, (
            "Ace=%-2d type=%d mask=%08X bytes=%-2d flags=%04X %S\n",
            i,
            pAce->AceType,
			dwMask,
            pAce->AceSize,
            pAce->AceFlags,
            pwsName ));
    }

    DoneDebug:
    return;
}   //  Dbg_DumpAcl


VOID Dbg_DumpSD(
    const char *            pszContext,
    PSECURITY_DESCRIPTOR    pSD
    )
{
    PACL                    pAcl = NULL;
    BOOL                    aclPresent = FALSE;
    BOOL                    aclDefaulted = FALSE;

    if ( !pSD )
    {
        return;
    }
    
    if ( !GetSecurityDescriptorDacl(
                pSD,
                &aclPresent,
                &pAcl,
                &aclDefaulted ) )
    {
        goto DoneDebug;
    }

    DNS_DEBUG( ANY, (
        "%s: DACL in SD %p present=%d defaulted=%d ACEs=%d\n",
        pszContext,
        pSD,
        ( int ) aclPresent,
        ( int ) aclDefaulted,
        aclPresent ? pAcl->AceCount : 0 ));

    if ( aclPresent )
    {
        Dbg_DumpAcl( pAcl );
    }

    if ( !GetSecurityDescriptorSacl(
                pSD,
                &aclPresent,
                &pAcl,
                &aclDefaulted ) )
    {
        goto DoneDebug;
    }

    DNS_DEBUG( ANY, (
        "%s: SACL in SD %p present=%d defaulted=%d ACEs=%d\n",
        pszContext,
        pSD,
        ( int ) aclPresent,
        ( int ) aclDefaulted,
        aclPresent ? pAcl->AceCount : 0 ));

    if ( aclPresent )
    {
        Dbg_DumpAcl( pAcl );
    }

    DoneDebug:
    return;
}   //  Dbg_DumpSD


//
//  Stole this straight routine from MSDN.
//
BOOL Dbg_GetUserSidForToken(
    HANDLE hToken,
    PSID *ppsid
    ) 
{
   BOOL bSuccess = FALSE;
   DWORD dwIndex;
   DWORD dwLength = 0;
   PTOKEN_USER p = NULL;

// Get required buffer size and allocate the TOKEN_GROUPS buffer.

   if (!GetTokenInformation(
         hToken,         // handle to the access token
         TokenUser,    // get information about the token's groups 
         (LPVOID) p,   // pointer to TOKEN_GROUPS buffer
         0,              // size of buffer
         &dwLength       // receives required buffer size
      )) 
   {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
         goto Cleanup;

      p = (PTOKEN_USER)HeapAlloc(GetProcessHeap(),
         HEAP_ZERO_MEMORY, dwLength);

      if (p == NULL)
         goto Cleanup;
   }

// Get the token group information from the access token.

   if (!GetTokenInformation(
         hToken,         // handle to the access token
         TokenUser,    // get information about the token's groups 
         (LPVOID) p,   // pointer to TOKEN_GROUPS buffer
         dwLength,       // size of buffer
         &dwLength       // receives required buffer size
         )) 
   {
      goto Cleanup;
   }

     dwLength = GetLengthSid(p->User.Sid);
     *ppsid = (PSID) HeapAlloc(GetProcessHeap(),
                 HEAP_ZERO_MEMORY, dwLength);
     if (*ppsid == NULL)
         goto Cleanup;
     if (!CopySid(dwLength, *ppsid, p->User.Sid)) 
     {
         HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
         goto Cleanup;
     }

   bSuccess = TRUE;

Cleanup: 

// Free the buffer for the token groups.

   if (p != NULL)
      HeapFree( GetProcessHeap(), 0, ( LPVOID )p );

   return bSuccess;
}


VOID Dbg_FreeUserSid (
    PSID *ppsid
    ) 
{
    HeapFree( GetProcessHeap(), 0, (LPVOID)*ppsid );
}


//
//  This function writse a log showing the current user (from
//  the thread token) to the debug log.
//
VOID Dbg_CurrentUser(
    PCHAR   pszContext
    )
{
    DBG_FN( "Dbg_CurrentUser" )

    BOOL    bstatus;
    HANDLE  htoken = NULL;
    PSID    pSid = NULL;

    if ( !pszContext ) 
    {
        pszContext = ( PCHAR ) fn;
    }

    bstatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &htoken );
    if ( !bstatus )
    {
        DNS_DEBUG( ANY, (
            "%s (%s): failed to open thread token error=%d\n", fn,
             pszContext, GetLastError() ));
        return;
    }

    if ( Dbg_GetUserSidForToken( htoken, &pSid ) )
    {
        DNS_DEBUG( ANY, (
            "%s: current user is %S\n", 
            pszContext, Dbg_DumpSid( pSid ) ));
        Dbg_FreeUserSid( &pSid );
    }
    else
    {
        DNS_DEBUG( ANY, (
            "%s: Dbg_GetUserSidForToken failed\n", fn ));
        ASSERT( FALSE );
    }
    CloseHandle( htoken );
}

#endif      // end DBG only routines



VOID
Dbg_HardAssert(
    IN      LPSTR   pszFile,
    IN      INT     LineNo,
    IN      LPSTR   pszExpr
    )
{
    //
    //  if debug log, write immediately
    //

    DNS_DEBUG( ANY, (
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo ));

    //
    //  bring up debugger
    //

    DebugBreak();

    //
    //  then print ASSERT to debugger
    //      (covers retail or no debug file case)

    DnsDbg_PrintfToDebugger(
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );
}



//
//  Debug print routines for DNS types and structures
//
//  We have a separate one from the one in dnslib, because
//  our message structure is different.
//  Note, since this is used in dns.log logging, we use the
//  \r\n return because of notepad.
//

VOID
Print_DnsMessage(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    )
{
    PCHAR       pchRecord;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wLength;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;
    BOOL        fUpdate = pMsg->Head.Opcode == DNS_OPCODE_UPDATE;

    Dns_PrintLock();

    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\r\n", pszHeader );
    }

    wLength = pMsg->MessageLength;

    PrintRoutine(
        pPrintContext,
        "%s %s info at %p\r\n"
        "  Socket = %u\r\n"
        "  Remote addr %s, port %u\r\n"
        "  Time Query=%u, Queued=%u, Expire=%u\r\n"
        "  Buf length = 0x%04x (%d)\r\n"
        "  Msg length = 0x%04x (%d)\r\n"
        "  Message:\r\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pMsg->Head.IsResponse
            ? "response"
            : "question"),
        pMsg,
        pMsg->Socket,
        DNSADDR_STRING( &pMsg->RemoteAddr ),
        ntohs( pMsg->RemoteAddr.SockaddrIn6.sin6_port ),
        pMsg->dwQueryTime,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        pMsg->BufferLength, pMsg->BufferLength,
        wLength, wLength );

    PrintRoutine(
        pPrintContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "      QR        %x (%s)\r\n"
        "      OPCODE    %x (%s)\r\n"
        "      AA        %x\r\n"
        "      TC        %x\r\n"
        "      RD        %x\r\n"
        "      RA        %x\r\n"
        "      Z         %x\r\n"
        "      RCODE     %x (%s)\r\n"
        "    %cCOUNT    %d\r\n"
        "    %s  %d\r\n"
        "    %sCOUNT   %d\r\n"
        "    ARCOUNT   %d\r\n",

        pMsg->Head.Xid,
        ntohs( DNSMSG_FLAGS(pMsg) ),
        pMsg->Head.IsResponse,
        pMsg->Head.IsResponse ? "RESPONSE" : "QUESTION",
        pMsg->Head.Opcode,
        Dns_OpcodeString( pMsg->Head.Opcode ),
        pMsg->Head.Authoritative,
        pMsg->Head.Truncation,
        pMsg->Head.RecursionDesired,
        pMsg->Head.RecursionAvailable,
        pMsg->Head.Reserved,
        pMsg->Head.ResponseCode,
        Dns_ResponseCodeString( pMsg->Head.ResponseCode ),
        fUpdate ? 'Z' : 'Q',
        pMsg->Head.QuestionCount,
        fUpdate ? "PRECOUNT" : "ACOUNT  ",
        pMsg->Head.AnswerCount,
        fUpdate ? "UP" : "NS",
        pMsg->Head.NameServerCount,
        pMsg->Head.AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pMsg->Head.Xid;
    wQuestionCount      = pMsg->Head.QuestionCount;
    wAnswerCount        = pMsg->Head.AnswerCount;
    wNameServerCount    = pMsg->Head.NameServerCount;
    wAdditionalCount    = pMsg->Head.AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //
    //  if def this out to allow bad packet testing

    if ( (wQuestionCount & 0xff00) ||
        (wNameServerCount & 0xff00) ||
        (wAdditionalCount & 0xff00) )
    {
        PrintRoutine(
            pPrintContext,
            "WARNING:  Invalid RR set counts -- possible bad packet\r\n"
            "    terminating packet print.\r\n" );
        TEST_ASSERT( FALSE );
        goto Unlock;
    }

    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsg->Head.IsResponse &&
            IS_WINS_XID(wXid) &&
            ntohs( pMsg->RemoteAddr.SockaddrIn6.sin6_port ) == WINS_REQUEST_PORT )
    {
        PrintRoutine(
            pPrintContext,
            "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }

    //
    //  print questions and resource records
    //

    pchRecord = pMsg->MessageBody;

    for ( isection=0; isection<4; isection++)
    {

#define DNS_SECTIONEMPTYSTRING \
    ( countSectionRR == 0 ? "      empty\r\n" : "" )

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
            PrintRoutine(
                pPrintContext,
                "    %s SECTION:\r\n%s",
                fUpdate ? "ZONE" : "QUESTION",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
            PrintRoutine(
                pPrintContext,
                "    %s SECTION:\r\n%s",
                fUpdate ? "PREREQUISITE" : "ANSWER",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
            PrintRoutine(
                pPrintContext, "    %s SECTION:\r\n%s",
                fUpdate ? "UPDATE" : "AUTHORITY",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
            PrintRoutine(
                pPrintContext,
                "    ADDITIONAL SECTION:\r\n%s",
                DNS_SECTIONEMPTYSTRING );
        }

#undef DNS_SECTIONEMPTYSTRING

        for ( i = 0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = DNSMSG_OFFSET( pMsg, pchRecord );
            if ( wOffset >= wLength  &&  pchRecord >= pMsg->pCurrent )
            {
                PrintRoutine(
                    pPrintContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "    Following RR (offset %hu) past packet length (%d).\r\n"
                    "    pchRecord = %p, pCurrent = %p, %d bytes\r\n",
                    wOffset,
                    wLength,
                    pchRecord,
                    pMsg->pCurrent,
                    pMsg->pCurrent - pchRecord );
                TEST_ASSERT( FALSE );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pPrintContext,
                "    Offset = 0x%04x, RR count = %d\r\n",
                wOffset,
                i );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pPrintContext,
                            "    Name      \"",
                            pchRecord,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END( pMsg ),
                            "\"\r\n" );
            if ( ! cchName )
            {
                PrintRoutine(
                    pPrintContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                TEST_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                WORD    type = FlipUnalignedWord( pchRecord );

                PrintRoutine(
                    pPrintContext,
                    "      %cTYPE   %s (%u)\r\n"
                    "      %cCLASS  %u\r\n",
                    fUpdate ? 'Z' : 'Q',
                    DnsRecordStringForType( type ),
                    type,
                    fUpdate ? 'Z' : 'Q',
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pPrintContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                DNS_HEADER_PTR(pMsg),
                                DNSMSG_END( pMsg )
                                );
            }
        }
    }

    //  check that at proper end of packet
    //  note:  don't check against pCurrent as when print after recv,
    //      it is unitialized
    //  if MS fast transfer tag, just print it

    wOffset = DNSMSG_OFFSET( pMsg, pchRecord );
    if ( wOffset < wLength )
    {
        if ( wOffset+2 == wLength )
        {
            PrintRoutine(
                pPrintContext,
                "    TAG: %c%c\r\n",
                *pchRecord,
                *(pchRecord+1) );
        }
        else
        {
            PrintRoutine(
                pPrintContext,
                "WARNING:  message continues beyond these records\r\n"
                "    pch = %p, pCurrent = %p, %d bytes\r\n"
                "    offset = %hu, msg length = %hu, %d bytes\r\n",
                pchRecord,
                pMsg->pCurrent,
                pMsg->pCurrent - pchRecord,
                wOffset,
                wLength,
                wLength - wOffset );
        }
    }
    PrintRoutine(
        pPrintContext,
        "\r\n" );

Unlock:

    DnsPrint_Unlock();
} // Print_DnsMessage


//
//  End of debug.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dfile.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dfile.h

Abstract:

    Domain Name System (DNS) Server

    Database file definitions and declarations.

Author:

    Jim Gilroy (jamesg)     November 1996

Revision History:

--*/


#ifndef _DNS_DFILE_INCLUDED_
#define _DNS_DFILE_INCLUDED_

//
//  Default database file locations
//

#define DNS_DATABASE_DIRECTORY              TEXT("dns")
#define DNS_DATABASE_BACKUP_DIRECTORY       TEXT("dns\\backup")
#define DNS_DATABASE_BACKUP_SUBDIR          TEXT("\\backup")

#define DNS_DEFAULT_CACHE_FILE_NAME         TEXT("cache.dns")
#define DNS_DEFAULT_CACHE_FILE_NAME_UTF8    ("cache.dns")

//
//  File directory globals
//
//  Init these once at the beginning to avoid rebuilding on each write.
//

extern  PWSTR   g_pFileDirectoryAppend;
extern  DWORD   g_FileDirectoryAppendLength;

extern  PWSTR   g_pFileBackupDirectoryAppend;
extern  DWORD   g_FileBackupDirectoryAppendLength;


//
//  File names will generally be manipulated in unicode
//  allowing direct use of Move\Copy system calls.
//

#define DNS_BOOT_FILE_NAME              TEXT("boot")
#define DNS_BOOT_FILE_PATH              TEXT("dns\\boot")
#define DNS_BOOT_FILE_BACKUP_NAME       TEXT("boot.bak")
#define DNS_BOOT_FILE_FIRST_BACKUP      TEXT("dns\\backup\\boot.first")
#define DNS_BOOT_FILE_LAST_BACKUP       TEXT("dns\\backup\\boot")

//  Doc mentions "boot.dns", so we also try this if regular fails

#define DNS_BOOTDNS_FILE_PATH           TEXT("dns\\boot.dns")

//  Message when move boot file

#define DNS_BOOT_FILE_MESSAGE_PATH      TEXT("dns\\boot.txt")

//  Message when encounter write error

#define DNS_BOOT_FILE_WRITE_ERROR       TEXT("dns\\boot.write.error")


//
//  Buffer our zone file writes for performance
//
//  Define max size any record write will require.  Record write will
//  note proceed unless this amount of buffer is available.
//
//  Buffer size itself must be larger.
//

#define MAX_RECORD_FILE_WRITE   (0x11000)   // 64k max record length + change
#define ZONE_FILE_BUFFER_SIZE   (0x80000)   // 512K buffer


//
//  Boot file info
//

typedef struct _DnsBootInfo
{
    PDNS_ADDR_ARRAY     aipForwarders;
    DWORD               fSlave;
    DWORD               fNoRecursion;
}
DNS_BOOT_FILE_INFO;

extern DNS_BOOT_FILE_INFO   BootInfo;

//
//  Name column for writing back to file
//

#define NAME_COLUMN_WIDTH   (24)
#define BLANK_NAME_COLUMN   ("                        ")


//
//  Special parsing characters
//

#define NEWLINE_CHAR                ('\n')
#define COMMENT_CHAR                (';')
#define DOT_CHAR                    ('.')
#define QUOTE_CHAR                  ('"')
#define SLASH_CHAR                  ('\\')
#define DIRECTIVE_CHAR              ('$')
#define LINE_EXTENSION_START_CHAR   ('(')
#define LINE_EXTENSION_END_CHAR     (')')


//
//  Token structure
//

typedef struct _Token
{
    PCHAR   pchToken;
    DWORD   cchLength;
}
TOKEN, *PTOKEN;

//  create token macro

#define MAKE_TOKEN( ptoken, pch, cch ) \
            ((ptoken)->pchToken = (pch), (ptoken)->cchLength = (cch) )

//  token walking macro

#define NEXT_TOKEN( argc, argv )  ((argc)--, (argv)++)


//
//  Database file parsing info
//

#define MAX_TOKEN_LENGTH    (255)
#define MAX_TOKENS          (2048)

typedef struct _ParseInfo
{
    //  zone info

    PZONE_INFO          pZone;
    DWORD               dwAppendFlag;
    DWORD               dwDefaultTtl;
    DWORD               dwTtlDirective;     //  from $TTL - RFC 2308

    //  file info

    PWSTR               pwsFileName;
    DWORD               cLineNumber;
    PDB_NODE            pOriginNode;
    BUFFER              Buffer;

    //  error info

    DNS_STATUS          fErrorCode;
    DWORD               ArgcAtError;
    BOOLEAN             fTerminalError;
    BOOLEAN             fErrorEventLogged;
    BOOLEAN             fParsedSoa;

    //  line parsing info

    UCHAR               uchDwordStopChar;

    //  RR info
    //      - save line owner for defaulting next line

    PDB_NODE            pnodeOwner;
    PDB_RECORD          pRR;
    WORD                wType;
    BOOLEAN             fLeadingWhitespace;

    //  tokenization of line

    DWORD               Argc;
    TOKEN               Argv[ MAX_TOKENS ];

    //  origin as count name

    COUNT_NAME          OriginCountName;
}
PARSE_INFO, *PPARSE_INFO;


//
//  Aging time stamp (MS extension)
//
//  [AGE:<time stamp>] is format
//

#define AGING_TOKEN_HEADER          ("[AGE:")

#define AGING_TOKEN_HEADER_LENGTH   (5)


//
//  Database initialization (dbase.c)
//

DNS_STATUS
File_ReadCacheFile(
    VOID
    );

//
//  Datafile load (dfread.c)
//

DNS_STATUS
File_LoadDatabaseFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsFileName,
    IN      PPARSE_INFO     pParentParseInfo,
    IN      PDB_NODE        pOriginNode
    );


//
//  File parsing utilities (dfread.c)
//

DNS_STATUS
File_GetNextLine(
    IN OUT  PPARSE_INFO     pParseInfo
    );

VOID
File_InitBuffer(
    OUT     PBUFFER         pBuffer,
    IN      PCHAR           pchStart,
    IN      DWORD           dwLength
    );

BOOLEAN
File_LogFileParsingError(
    IN      DWORD           dwEvent,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    );

BOOLEAN
File_MakeTokenString(
    OUT     LPSTR           pszString,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo
    );

BOOLEAN
File_ParseIpAddress(
    OUT     PDNS_ADDR       pIpAddress,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    );

BOOLEAN
File_ParseDwordToken(
    OUT     PDWORD          pdwOutput,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    );

PCHAR
File_CopyFileTextData(
    OUT     PCHAR           pchBuffer,
    IN      DWORD           cchBufferLength,
    IN      PCHAR           pchText,
    IN      DWORD           cchLength,          OPTIONAL
    IN      BOOL            fWriteLengthChar
    );

DNS_STATUS
File_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    );

PDB_NODE
File_CreateNodeFromToken(
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken,
    IN      BOOLEAN         fReference
    );

#define File_ReferenceNameToken( token, info )   \
        File_CreateNodeFromToken( info, token, TRUE )

DNS_STATUS
File_ReadCountNameFromToken(
    OUT     PCOUNT_NAME     pCountName,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    );


//
//  Write back utils (in nameutil.c to share character table)
//

PCHAR
FASTCALL
File_PlaceStringInBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      BOOL            fQuoted,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
FASTCALL
File_PlaceNodeNameInBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

PCHAR
FASTCALL
File_WriteRawNameToBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    );

//
//  Boot file (bootfile.c)
//

DNS_STATUS
File_ReadBootFile(
    IN      BOOL            fMustFindBootFile
    );

BOOL
File_WriteBootFile(
    VOID
    );

//
//  File path utilities (file.c)
//

BOOL
File_CreateDatabaseFilePath(
    IN OUT  PWCHAR          pwFileBuffer,
    IN OUT  PWCHAR          pwBackupBuffer,     OPTIONAL
    IN      PWSTR           pwsFileName
    );

BOOL
File_CheckDatabaseFilePath(
    IN      PWCHAR          pwFileName,
    IN      DWORD           cFileNameLength     OPTIONAL
    );

BOOL
File_MoveToBackupDirectory(
    IN      PWSTR           pwsFileName
    );


#endif  // _DNS_DFILE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\debug.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Domain Name System (DNS) Server

    Debug definitions and declarations.

Author:

    Jim Gilroy (jamesg) February 1995

Revision History:

--*/


#ifndef _DEBUG_INCLUDED_
#define _DEBUG_INCLUDED_

//
//  Test App
//

extern  BOOLEAN fServiceStartedFromConsole;

//
//  Server debug stuff
//

#define DNS_DEBUG_FILENAME      ("dns\\dnsdebug.log")

#define DNS_DEBUG_FLAG_FILENAME ("dns\\dnsdebug")
#define DNS_DEBUG_FLAG_REGKEY   ("DebugFlag")



#if DBG

//
//  Enable debug print tests
//

extern  DWORD DnsSrvDebugFlag;

#define IF_DEBUG(a)         if ( DnsSrvDebugFlag & DNS_DEBUG_ ## a )
#define IF_NOT_DEBUG(a)     if ( ( DnsSrvDebugFlag & DNS_DEBUG_ ## a ) == 0 )
#define ELSE_IF_DEBUG(a)    else if ( DnsSrvDebugFlag & DNS_DEBUG_ ## a )

#define DNS_DEBUG( _flag_, _print_ )            \
        IF_DEBUG( _flag_ )                      \
        {                                       \
            (DnsPrintf _print_ );               \
        }

//
//  Enable ASSERTs
//

#ifdef ASSERT
#undef  ASSERT
#endif

#define ASSERT(expr) \
{                           \
        if ( !(expr) )      \
        {                   \
            Dbg_Assert( __FILE__, __LINE__, # expr ); \
        }                   \
}

#ifdef  TEST_ASSERT
#undef  TEST_ASSERT
#define TEST_ASSERT(expr) \
{                           \
        if ( !(expr) )      \
        {                   \
            Dbg_TestAssert( __FILE__, __LINE__, # expr ); \
        }                   \
}
#endif
#define CLIENT_ASSERT(expr)     TEST_ASSERT(expr)

#define MSG_ASSERT( pMsg, expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dbg_DnsMessage( "FAILED MESSAGE:", (pMsg) ); \
        Dbg_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}

#define ASSERT_IF_HUGE_ARRAY( ipArray )                 \
{                                                       \
    if ( (ipArray) && (ipArray)->AddrCount > 1000 )     \
    {                                                   \
        DnsPrintf(                                      \
            "IP array at %p has huge count %d\n",       \
            (ipArray),                                  \
            (ipArray)->AddrCount );                     \
        ASSERT( (ipArray)->AddrCount > 1000 );          \
    }                                                   \
}

#define ASSERT_VALID_HANDLE( h )                                        \
{                                                                       \
    DWORD   flags = 0;                                                  \
    BOOL    isValidHandle;                                              \
                                                                        \
    isValidHandle = GetHandleInformation( ( HANDLE ) h, &flags );       \
    if ( !isValidHandle )                                               \
    {                                                                   \
        DWORD   error = GetLastError();                                 \
                                                                        \
        DnsPrintf(                                                      \
            "ERROR: Bogus handle 0x%X error %d\n", h, error );          \
        /* ASSERT( isValidHandle ); */                                  \
    }                                                                   \
}
    

//
//  Debugging flags
//

#define DNS_DEBUG_BREAKPOINTS   0x00000001
#define DNS_DEBUG_DEBUGGER      0x00000002
#define DNS_DEBUG_FILE          0x00000004
#define DNS_DEBUG_EVENTLOG      0x00000008
#define DNS_DEBUG_EXCEPT        0x00000008

#define DNS_DEBUG_INIT          0x00000010
#define DNS_DEBUG_SOCKET        0x00000010
#define DNS_DEBUG_PNP           0x00000010
#define DNS_DEBUG_SHUTDOWN      0x00000010
#define DNS_DEBUG_DATABASE      0x00000020
#define DNS_DEBUG_TIMEOUT       0x00000020
#define DNS_DEBUG_LOOKUP        0x00000040
#define DNS_DEBUG_WRITE         0x00000080
#define DNS_DEBUG_READ          0x00000080

#define DNS_DEBUG_RPC           0x00000100
#define DNS_DEBUG_AGING         0x00000100
#define DNS_DEBUG_SCAVENGE      0x00000100
#define DNS_DEBUG_TOMBSTONE     0x00000100
#define DNS_DEBUG_RECV          0x00000200
#define DNS_DEBUG_EDNS          0x00000200
#define DNS_DEBUG_SEND          0x00000400
#define DNS_DEBUG_TCP           0x00000800
#define DNS_DEBUG_DS            0x00000800
#define DNS_DEBUG_SD            0x00000800
#define DNS_DEBUG_DP            0x00000800      //  directory partition
#define DNS_DEBUG_EVTCTRL       0x00000800      //  event control

#define DNS_DEBUG_RECURSE       0x00001000
#define DNS_DEBUG_REMOTE        0x00001000
#define DNS_DEBUG_STUFF         0x00001000
#define DNS_DEBUG_ZONEXFR       0x00002000
#define DNS_DEBUG_AXFR          0x00002000
#define DNS_DEBUG_XFR           0x00002000
#define DNS_DEBUG_UPDATE        0x00004000
#define DNS_DEBUG_WINS          0x00008000
#define DNS_DEBUG_NBSTAT        0x00008000

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_FREE_LIST     0x00040000
#define DNS_DEBUG_REGISTRY      0x00080000
#define DNS_DEBUG_SCM           0x00080000
#define DNS_DEBUG_LOCK          0x00080000

//
//  High output detail debugging
//

#define DNS_DEBUG_RECURSE2      0x00100000
#define DNS_DEBUG_REMOTE2       0x00100000
#define DNS_DEBUG_DS2           0x00100000
#define DNS_DEBUG_DP2           0x00100000      //  directory partition
#define DNS_DEBUG_UPDATE2       0x00200000
#define DNS_DEBUG_ASYNC         0x00200000
#define DNS_DEBUG_WINS2         0x00400000
#define DNS_DEBUG_NBSTAT2       0x00400000
#define DNS_DEBUG_ZONEXFR2      0x00800000
#define DNS_DEBUG_AXFR2         0x00800000
#define DNS_DEBUG_XFR2          0x00800000

#define DNS_DEBUG_RPC2          0x01000000
#define DNS_DEBUG_INIT2         0x01000000
#define DNS_DEBUG_LOOKUP2       0x02000000
#define DNS_DEBUG_WRITE2        0x04000000
#define DNS_DEBUG_READ2         0x04000000
#define DNS_DEBUG_RECV2         0x04000000
#define DNS_DEBUG_BTREE         0x08000000

#define DNS_DEBUG_LOCK2         0x10000000
#define DNS_DEBUG_PARSE2        0x10000000
#define DNS_DEBUG_DATABASE2     0x10000000
#define DNS_DEBUG_TIMEOUT2      0x10000000
#define DNS_DEBUG_ANNOY2        0x20000000
#define DNS_DEBUG_MSGTIMEOUT    0x20000000
#define DNS_DEBUG_HEAP2         0x20000000
#define DNS_DEBUG_BTREE2        0x20000000

#define DNS_DEBUG_ASSERTS       0x40000000
#define DNS_DEBUG_CONSOLE       0x80000000
#define DNS_DEBUG_START_BREAK   0x80000000

#define DNS_DEBUG_ALL           0xffffffff
#define DNS_DEBUG_ANY           0xffffffff
#define DNS_DEBUG_OFF           (0)


//
//  Renaming of dnslib debug routines
//

#define DnsDebugFlush()     DnsDbg_Flush()
#define DnsPrintf           DnsDbg_Printf
#define DnsDebugLock()      DnsDbg_Lock()
#define DnsDebugUnlock()    DnsDbg_Unlock()
#define Dbg_Lock()          DnsDbg_Lock()
#define Dbg_Unlock()        DnsDbg_Unlock()

//
//  General debug routines
//

VOID
Dbg_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );

VOID
Dbg_TestAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );


//
//  Debug print routines for DNS types and structures
//

INT
Dbg_MessageNameEx(
    IN      LPSTR           pszHeader,  OPTIONAL
    IN      PBYTE           pName,
    IN      PDNS_MSGINFO    pMsg,       OPTIONAL
    IN      PBYTE           pEnd,       OPTIONAL
    IN      LPSTR           pszTrailer  OPTIONAL
    );

#define Dbg_MessageName( h, n, m ) \
        Dbg_MessageNameEx( h, n, m, NULL, NULL )

VOID
Dbg_DnsMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Dbg_ByteFlippedMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Dbg_Compression(
    IN      LPSTR           pszHeader,
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Dbg_DbaseRecord(
    IN      LPSTR           pszHeader,
    IN      PDB_RECORD      pRR
    );

#ifdef  NEWDNS
VOID
Dbg_DsRecord(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD      pRR
    );
#else
#define Dbg_DsRecord(a,b)   DnsDbg_RpcRecord(a,(PDNS_RPC_RECORD)b)
#endif

VOID
Dbg_DsRecordArray(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD *    ppDsRecord,
    IN      DWORD           dwCount
    );

VOID
Dbg_CountName(
    IN      LPSTR           pszHeader,
    IN      PDB_NAME        pName,
    IN      LPSTR           pszTrailer
    );

#define Dbg_DbaseName(a,b,c)    Dbg_CountName(a,b,c)

VOID
Dbg_PacketQueue(
    IN      LPSTR           pszHeader,
    IN OUT  PPACKET_QUEUE   pQueue
    );

INT
Dbg_DnsTree(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pDomainTree
    );

VOID
Dbg_DbaseNodeEx(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwIndent
    );

#define Dbg_DbaseNode( h, n )   Dbg_DbaseNodeEx( h, n, 0 )

INT
Dbg_NodeName(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszTrailer
    );

VOID
Dbg_LookupName(
    IN      LPSTR           pszHeader,
    IN      PLOOKUP_NAME    pLookupName
    );

#define Dbg_RawName(a,b,c)      DnsDbg_PacketName(a, b, NULL, NULL, c)

VOID
Dbg_Zone(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    );

VOID
Dbg_ZoneList(
    IN      LPSTR           pszHeader
    );

VOID
Dbg_Statistics(
    VOID
    );

VOID
Dbg_ThreadHandleArray(
    VOID
    );

VOID
Dbg_ThreadDescrpitionMatchingId(
    IN      DWORD           ThreadId
    );

VOID
Dbg_SocketContext(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pContext
    );

VOID
Dbg_SocketList(
    IN      LPSTR           pszHeader
    );

VOID
Dbg_NsList(
    IN      LPSTR           pszHeader,
    IN      PNS_VISIT_LIST  pNsList
    );

PWCHAR
Dbg_DumpSid(
    PSID                    pSid
    );

VOID
Dbg_DumpAcl(
    PACL                    pAcl
    );

VOID
Dbg_DumpSD(
    const char *            pszContext,
    PSECURITY_DESCRIPTOR    pSD
    );

BOOL
Dbg_GetUserSidForToken(
    HANDLE hToken,
    PSID *ppsid
    );

VOID
Dbg_FreeUserSid (
    PSID *ppsid
    );

VOID Dbg_CurrentUser(
    PCHAR   pszContext
    );

PCHAR
Dbg_TimeString(
    VOID
    );

//
//  Debug packet tracking
//

VOID
Packet_InitPacketTrack(
    VOID
    );

VOID
Packet_AllocPacketTrack(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Packet_FreePacketTrack(
    IN      PDNS_MSGINFO    pMsg
    );

//
//  Event logging
//

#define DNS_LOG_EVENT( Id, ArgCount, ArgArray, TypeArray, ErrorCode ) \
            Eventlog_LogEvent(  \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_FLAGS( Id, ArgCount, ArgArray, TypeArray, Flags, ErrorCode ) \
            Eventlog_LogEvent(  \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                Id,             \
                Flags,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_DESCRIPTION( Descript, Id, ArgCount, ArgArray, ErrorCode ) \
            Eventlog_LogEvent(  \
                __FILE__,       \
                __LINE__,       \
                Descript,       \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                NULL,           \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_RAW_DATA( Id, ArgCount, ArgArray, TypeArray, RawSize, Raw ) \
            Eventlog_LogEvent(  \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                0,              \
                RawSize,        \
                Raw )

#define DNS_LOG_EVENT_BAD_PACKET( Id, Msg ) \
            EventLog_BadPacket( \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                Id,             \
                Msg )

#else

//
//  Non-Debug
//

#define IF_DEBUG(a)                 if (0)
#define ELSE_IF_DEBUG(a)            else if (0)
#define DNS_DEBUG( flag, print )
#define MSG_ASSERT( pMsg, expr )
#define CLIENT_ASSERT(expr)
#define ASSERT_IF_HUGE_ARRAY( ipArray )
#define ASSERT_VALID_HANDLE( h )

//
//  DEVNOTE:    Should not have to define away these functions, they
//              should only be used inside debug blocks anyway.  Compiler
//              ought to optimize out all "if (0)" block code.
//

//
//  Renaming of dnslib debug routines
//

#define DnsDebugFlush()
#define DnsPrintf     
#define DnsDebugLock()
#define DnsDebugUnlock()
#define Dbg_Lock()
#define Dbg_Unlock()

//
//  Renaming server debug routines
//

#define Dbg_MessageNameEx(a,b,c,d,e)
#define Dbg_MessageName(a,b,c)
#define Dbg_DnsMessage(a,b)
#define Dbg_ByteFlippedMessage(a,b)
#define Dbg_Compression(a,b)
#define Dbg_ResourceRecordDatabase(a)
#define Dbg_DumpTree(a)
#define Dbg_DnsTree(a,b)
#define Dbg_DbaseNodeEx(a,b,c)
#define Dbg_DbaseNode(a,b)
#define Dbg_DbaseRecord(a,b)
#define Dbg_DsRecord(a,b)
#define Dbg_DsRecordArray(a,b,c)
#define Dbg_CountName(a,b,c)
#define Dbg_DbaseName(a,b,c)
#define Dbg_NodeName(a,b,c)
#define Dbg_LookupName(a,b)
#define Dbg_RawName(a,b,c)
#define Dbg_Zone(a,b)
#define Dbg_ZoneList(a)
#define Dbg_ThreadHandleArray()
#define Dbg_ThreadDescrpitionMatchingId(a)
#define Dbg_Statistics()
#define Dbg_NsList(a,b)
#define Dbg_HourTimeAsSystemTime(a,b)

#if 0
#define Dbg_RpcServerInfoNt4(a,b)
#define Dbg_RpcServerInfo(a,b)
#define Dbg_RpcZoneInfo(a,b)
#define Dbg_RpcName(a,b,c)
#define Dbg_RpcNode(a,b)
#define Dbg_RpcRecord(a,b)
#define Dbg_RpcRecordsInBuffer(a,b,c)
#endif
#define Dbg_PacketQueue(a,b)
#define Dbg_FdSet(a,b)
#define Dbg_SocketList(p)
#define Dbg_SocketContext(p,s)
#define Dbg_SocketContext(p,s)

//  no-op packet tracking

#define Packet_InitPacketTrack()
#define Packet_AllocPacketTrack(pMsg)
#define Packet_FreePacketTrack(pMsg)


//
//  Retail event logging
//

#define DNS_LOG_EVENT( Id, ArgCount, ArgArray, TypeArray, ErrorCode ) \
            Eventlog_LogEvent(  \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_FLAGS( Id, ArgCount, ArgArray, TypeArray, Flags, ErrorCode ) \
            Eventlog_LogEvent(  \
                Id,             \
                Flags,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_DESCRIPTION( Descript, Id, ArgCount, ArgArray, ErrorCode ) \
            Eventlog_LogEvent(  \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                NULL,           \
                ErrorCode,      \
                0,              \
                NULL )

#define DNS_LOG_EVENT_RAW_DATA( Id, ArgCount, ArgArray, TypeArray, RawSize, Raw ) \
            Eventlog_LogEvent(  \
                Id,             \
                0,              \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                0,              \
                RawSize,        \
                Raw )

#define DNS_LOG_EVENT_BAD_PACKET( Id, Msg ) \
            EventLog_BadPacket( \
                Id,             \
                Msg )

#endif  //  non-DBG


//
//  "Hard Assert"
//
//  Used for retail also when need to catch failure early rather than at crash.
//

VOID
Dbg_HardAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );

#define HARD_ASSERT( expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dbg_HardAssert( \
            __FILE__,   \
            __LINE__,   \
            # expr );   \
    }                   \
}

//  Hard assert on first run through - good for one time startup bp.
#if DBG
#define FIRST_TIME_HARD_ASSERT( expr )                          \
{                                                               \
    static int hitCount = 0;                                    \
    if ( hitCount++ == 0 ) { HARD_ASSERT( expr ); }     \
}
#else
#define FIRST_TIME_HARD_ASSERT( expr )
#endif

//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif

//
//  Print routine -- used in non-debug logging code
//

VOID
Print_DnsMessage(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );


#endif // _DEBUG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dfwrite.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dfwrite.c

Abstract:

    Domain Name System (DNS) Server

    Database file _write back routines.

Author:

    Jim Gilroy (jamesg)     August 14, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Private prototypes
//

BOOL
writeCacheFile(
    IN      PBUFFER         pBuffer,
    IN OUT  PZONE_INFO      pZone
    );

BOOL
zoneTraverseAndWriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    );

BOOL
writeZoneRoot(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pZoneRoot
    );

BOOL
writeDelegation(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pSubNode
    );

BOOL
writeNodeRecordsToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    );



BOOL
File_DeleteZoneFileW(
    IN      PCWSTR          pwszZoneFileName
    )
/*++

Routine Description:

    Deletes a zone file by file name. The file name must not contain
    any path information.

Arguments:

    pwsZoneFileName -- zone file to delete

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    WCHAR   wszfilePath[ MAX_PATH ];

    if ( !pwszZoneFileName || !*pwszZoneFileName )
    {
        return TRUE;
    }

    if ( !File_CreateDatabaseFilePath(
                wszfilePath,
                NULL,                       // backup path
                ( PWSTR ) pwszZoneFileName ) )
    {
        ASSERT( FALSE );
        return FALSE;
    }
    return DeleteFile( wszfilePath );
}   //  File_DeleteZoneFileW



BOOL
File_DeleteZoneFileA(
    IN      PCSTR           pszZoneFileName
    )
/*++

Routine Description:

    Deletes a zone file by file name. The file name must not contain
    any path information.

Arguments:

    pwsZoneFileName -- zone file to delete

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PWSTR       pwszZoneFileName;
    BOOL        rc;

    if ( !pszZoneFileName || !*pszZoneFileName )
    {
        return TRUE;
    }

    pwszZoneFileName = Dns_StringCopyAllocate(
                            ( PSTR ) pszZoneFileName,
                            0,
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );
    if ( !pwszZoneFileName )
    {
        return FALSE;
    }

    rc = File_DeleteZoneFileW( pwszZoneFileName );

    FREE_HEAP( pwszZoneFileName );

    return rc;
}   //  File_DeleteZoneFileA



BOOL
File_WriteZoneToFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsZoneFile,    OPTIONAL
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Write zone to back to database file.

Arguments:

    pZone -- zone to write

    pwsZoneFile -- file to write to, if NULL use zone's file
    
    dwFlags -- operational flags

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    BOOL            retval = FALSE;
    HANDLE          hfile = NULL;
    BUFFER          buffer;
    PCHAR           pdata = NULL;
    WCHAR           wstempFileName[ MAX_PATH ];
    WCHAR           wstempFilePath[ MAX_PATH ];
    WCHAR           wsfilePath[ MAX_PATH ];
    WCHAR           wsbackupPath[ MAX_PATH ];
    PWCHAR          pwsTargetFile;
    DNS_STATUS      status;
    BOOL            blocked = FALSE;

    //
    //  assuming that zone locked to protect integrity during write back
    //  locked either by secondary transfer or by zone write back RPC function
    //
    //  note file handle serves as flag that write is outstanding
    //

    ASSERT( pZone );

    pwsTargetFile = pwsZoneFile ? pwsZoneFile : pZone->pwsDataFile;

    DNS_DEBUG( DATABASE, (
        "File_WriteZoneToFile( zone=%s ) to file %S\n",
        pZone->pszZoneName,
        pwsTargetFile ? pwsTargetFile : L"NULL" ));

    //
    //  File operations must be performed in the DNS server context.
    //
    
    if ( dwFlags & DNS_FILE_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            dwFlags &= ~ZONE_CREATE_IMPERSONATING;
            retval = FALSE;
            goto Cleanup;
        }
    }

    //
    //  for cache verify that it is writable
    //      - doing cache updates
    //      - cache has necessary info
    //
    //  skipping case here where writing from deleted root zone
    //      - only writing when have no cache file so writing is always better
    //      - some validations may fail
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( pZone==g_pCacheZone && ! Zone_VerifyRootHintsBeforeWrite(pZone) )
        {
            goto Cleanup;
        }
    }

    //
    //  Forwarder zones need no processing.
    //

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        retval = TRUE;
        goto Cleanup;
    }

    //
    //  DEVNOTE: What is the proper course of action here if the zone is
    //  DS integrated? A BxGBxG indicated that a DS integrated cache zone may
    //  get in here. (Used to have a check if fDsIntegrated, ouput debug msg
    //  and return FALSE, but that was #if 0.)
    //

    //
    //  if no file zone -- no action
    //      can happen on no file secondary
    //      or switching from DS, without properly specifying file
    //

    if ( !pwsTargetFile )
    {
        retval = FALSE;
        goto Cleanup;
    }

    //
    //  create temp file path
    //

    #define DNS_TEMP_FILE_SUFFIX        L".temp"
    #define DNS_TEMP_FILE_SUFFIX_LEN    ( 5 )

    if ( wcslen( wstempFileName ) + DNS_TEMP_FILE_SUFFIX_LEN > MAX_PATH - 1 )
    {
        retval = FALSE;
        goto Cleanup;
    }

    wcscpy( wstempFileName, pwsTargetFile );
    wcscat( wstempFileName, L".temp" );

    if ( !File_CreateDatabaseFilePath(
                wstempFilePath,
                NULL,
                wstempFileName ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        retval = FALSE;
        goto Cleanup;
    }

    //
    //  lock out updates while write this version
    //

    if ( !Zone_LockForFileWrite(pZone) )
    {
        DNS_DEBUG( WRITE, (
            "WARNING:  Failure to lock zone %s for file write back\n",
            pZone->pszDataFile ));
        retval = FALSE;
        goto Cleanup;
    }
    blocked = TRUE;

    //
    //  no SOA -- no action
    //      can happen when attempting to write secondary that has
    //      never loaded any data
    //

    if ( !pZone->pZoneRoot  ||
         (!pZone->pSoaRR  &&  !IS_ZONE_CACHE(pZone)) )
    {
        DNS_DEBUG( WRITE, (
            "Zone has no SOA, quiting zone write!\n" ));
        goto Cleanup;
    }

    //
    //  allocate a file buffer
    //

    pdata = (PCHAR) ALLOC_TAGHEAP( ZONE_FILE_BUFFER_SIZE, MEMTAG_FILEBUF );
    IF_NOMEM( !pdata )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  open database file
    //

    hfile = OpenWriteFileExW(
                wstempFilePath,
                FALSE );        //  overwrite
    if ( !hfile )
    {
        //  DEVNOTE-LOG: another event failed to open file for zone write?
        //              - beyond file open problem?

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to open temp file for zone file %s\n",
            pZone->pszDataFile ));
        goto Cleanup;
    }

    //
    //  initialize file buffer
    //

    InitializeFileBuffer(
        & buffer,
        pdata,
        ZONE_FILE_BUFFER_SIZE,
        hfile );

    //
    //  cache file write back?
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        retval = writeCacheFile( &buffer, pZone );
        goto Done;
    }

    //
    //  write zone to file
    //

    FormattedWriteToFileBuffer(
        & buffer,
        ";\r\n"
        ";  Database file %s for %s zone.\r\n"
        ";      Zone version:  %lu\r\n"
        ";\r\n\r\n",
        pZone->pszDataFile,
        pZone->pszZoneName,
        pZone->dwSerialNo );

    retval = zoneTraverseAndWriteToFile(
                &buffer,
                pZone,
                pZone->pZoneRoot );
    if ( !retval )
    {
        //
        //  DEVNOTE-LOG: event for zone write failure
        //

        DNS_DEBUG( ANY, (
            "ERROR:  Failure writing zone to %s\n",
            pZone->pszDataFile ));
        goto Cleanup;
    }

    //
    //  push remainder of buffer to file
    //

    WriteBufferToFile( &buffer );

    //
    //  log zone write
    //

    {
        PVOID   argArray[3];
        BYTE    typeArray[3];

        typeArray[0] = EVENTARG_DWORD;
        typeArray[1] = EVENTARG_UNICODE;
        typeArray[2] = EVENTARG_UNICODE;

        argArray[0] = (PVOID) (DWORD_PTR) pZone->dwSerialNo;
        argArray[1] = (PVOID) pZone->pwsZoneName;
        argArray[2] = (PVOID) pwsTargetFile;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_WRITE_COMPLETED,
            3,
            argArray,
            typeArray,
            0 );
    }

    DNS_DEBUG( DATABASE, (
        "Zone %s, version %d written to file %s\n",
        pZone->pszZoneName,
        pZone->dwSerialNo,
        pZone->pszDataFile ));

    //
    //  on successful write -- reset dirty bit
    //

    pZone->fDirty = FALSE;

    Done:

    //  close up file
    //      - doing before unlock so effectively new file write can not
    //          occur until this write wrapped up

    CloseHandle( hfile );
    hfile = NULL;

    //
    //  copy new file, to datafile
    //      - backup old if appropriate
    //

    if ( !File_CreateDatabaseFilePath(
                wsfilePath,
                wsbackupPath,
                pwsTargetFile ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  backup file, if no existing backup
    //
    //  by not overwriting existing, we insure that we preserve a copy
    //  of a file corresponding to a manual edit (if any);  and if the
    //  admin clears the backup on manual edit, we'll always have copy
    //  of last manual edit
    //

    if ( wsbackupPath[ 0 ] != L'\0' )
    {
        DNS_DEBUG( WRITE, (
            "Copy file %S to backup file %S\n",
            wsfilePath,
            wsbackupPath ));
        CopyFile(
            wsfilePath,
            wsbackupPath,
            TRUE );             //  do NOT overwrite existing
    }

    //  copy new file

    DNS_DEBUG( WRITE, (
        "Copy temp file %S to datafile %s\n",
        wstempFilePath,
        wsfilePath ));
    MoveFileEx(
        wstempFilePath,
        wsfilePath,
        MOVEFILE_REPLACE_EXISTING );

    //
    //  close update log
    //
    //  DEVNOTE-DCR: 453999 - What do to with the update log. Back it up? Where
    //      to? Save a set of backups? Or leave the file open and write a
    //      WRITE_BACK entry into it?
    //

    if ( pZone->hfileUpdateLog )
    {
        hfile = pZone->hfileUpdateLog;
        pZone->hfileUpdateLog = NULL;
        CloseHandle( hfile );
        hfile = NULL;

        DNS_DEBUG( WRITE, (
            "Closed update log file %s for zone %s\n",
            pZone->pwsLogFile,
            pZone->pszZoneName ));
    }

    Cleanup:

    if ( hfile )
    {
        CloseHandle( hfile );
    }

    if ( blocked )
    {
        Zone_UnlockAfterFileWrite( pZone );
    }

    if ( dwFlags & DNS_FILE_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
        retval = ( status == ERROR_SUCCESS );
    }

    //  free data buffer

    FREE_TAGHEAP( pdata, ZONE_FILE_BUFFER_SIZE, MEMTAG_FILEBUF );

    return retval;
}



BOOL
zoneTraverseAndWriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Walk through new zone writing RR into database.

Arguments:

    pNode -- new node to write;  root of new zone on initial call

    pZone -- ptr to zone

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    ASSERT( pNode && pZone && pBuffer );
    ASSERT( pZone->pZoneRoot );
    ASSERT( pZone->pSoaRR );

    //
    //  stop on select node
    //

    if ( IS_SELECT_NODE(pNode) )
    {
        return TRUE;
    }

    //
    //  zone root
    //      - write SOA and NS first for zone root
    //      - write NS and possibly glue records for subzones,
    //          then terminate recursioon
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        if ( IS_AUTH_ZONE_ROOT(pNode) )
        {
            if ( !writeZoneRoot(
                        pBuffer,
                        pZone,
                        pNode ) )
            {
                return FALSE;
            }
            //  continue recursion with root's child nodes
        }
        else
        {
            ASSERT( IS_DELEGATION_NODE(pNode) );

            return writeDelegation(
                        pBuffer,
                        pZone,
                        pNode );
        }
    }

    //
    //  node in zone -- write all RR in node
    //

    else if ( !writeNodeRecordsToFile(
                    pBuffer,
                    pZone,
                    pNode ) )
    {
        //
        //  DEVNOTE-LOG: log general event about failure to write RR and suggest
        //       action to take
        //          - remove file when restart secondary
        //       or could set flag and rename file at end?
        //
    }

    //
    //  write children
    //
    //  test first optimization, since most nodes leaf nodes
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( !zoneTraverseAndWriteToFile(
                        pBuffer,
                        pZone,
                        pchild ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return TRUE;
}



//
//  File writing utilities
//

PCHAR
writeNodeNameToBuffer(
    IN      PBUFFER         pBuffer,
    IN      PDB_NODE        pNode,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Write node's name.  Default zone root, if given.

Arguments:

    pBuffer -- handle for file to write to

    pNode -- node to write

    pZoneRoot -- node of zone root, to stop name expansion at

    pszTrailer -- trailing string to attach

Return Value:

    None.

--*/
{
    PCHAR   pch;
    DWORD   countWritten;

    ASSERT( pBuffer );
    ASSERT( pNode );

    //  write node name directly into buffer

    pch = File_PlaceNodeNameInFileBuffer(
                pBuffer->pchCurrent,
                pBuffer->pchEnd,
                pNode,
                pZone ? pZone->pZoneRoot : NULL );
    if ( !pch )
    {
        ASSERT( FALSE );
        return NULL;
    }

    countWritten = (DWORD) (pch - pBuffer->pchCurrent);
    pBuffer->pchCurrent = pch;

    //
    //  write trailer
    //      - if trailer given, write it
    //      - if no trailer, assume writing record name and pad to
    //          column width

    if ( pszTrailer )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "%s",
            pszTrailer );
    }
    else
    {
        //  convert count written to count of spaces we need to write
        //  at a minimum we write one

        countWritten = NAME_COLUMN_WIDTH - countWritten;

        FormattedWriteToFileBuffer(
            pBuffer,
            "%.*s",
            (( (INT)countWritten > 0 ) ? countWritten : 1),
            BLANK_NAME_COLUMN );
    }

    return pBuffer->pchCurrent;
}



BOOL
writeDelegation(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write delegation to file.
    Includes writing cache file root hints.

Arguments:

    pBuffer -- handle for file to write to

    pNode -- node delegation is at

    pZoneRoot -- roote node of zone being written;  NULL for cache file write

    dwDefaultTtl -- default TTL for zone;  zero for cache file write

Return Value:

    None.

--*/
{
    PDB_RECORD          prrNs;          // NS resource record
    PDB_NODE            pnodeNs;        // name server node
    PDB_RECORD          prrA;           // name server A record
    UCHAR               rankNs;
    UCHAR               writtenRankNs;
    UCHAR               rankA;
    UCHAR               writtenRankA;
    BOOL                fzoneRoot = FALSE;
    BOOL                fcacheFile = FALSE;

    ASSERT( pBuffer );
    ASSERT( pNode );
    ASSERT( pZone );

    DNS_DEBUG( WRITE2, ( "writeDelegation()\n" ));

    //
    //  note:  used to pass pZone = NULL for cache file write
    //      can not use that method for case where writing
    //      back cache file from deleted root zone, because
    //      Lookup_FindGlueNodeForDbaseName() will not look in
    //      proper tree for records
    //

    //
    //  comment
    //      - writeCacheFile handles it's comment
    //      - zone NS comment
    //      - delegation comment
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        fcacheFile = TRUE;
    }
    else if ( pZone->pZoneRoot == pNode )
    {
        fzoneRoot = TRUE;

        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  Zone NS records\r\n"
            ";\r\n\r\n" );
    }
    else
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  Delegated sub-zone:  " );

        writeNodeNameToBuffer(
            pBuffer,
            pNode,
            NULL,
            "\r\n;\r\n" );
    }

    //
    //  write NS info
    //      - find \ write each NS at delegation
    //      - for each NS host write A records
    //          - do NOT include records INSIDE the zone, they
    //          are written separately
    //          - write OUTSIDE zone records only if not deleting
    //          - for zone NS-hosts, subzone glue treated as outside
    //              records
    //

    Dbase_LockDatabase();
    //LOCK_RR_LIST(pNode);
    writtenRankNs = 0;

    prrNs = START_RR_TRAVERSE( pNode );

    while( prrNs = NEXT_RR(prrNs) )
    {
        if ( IS_EMPTY_AUTH_RR( prrNs ) )
        {
            continue;
        }

        if ( prrNs->wType != DNS_TYPE_NS )
        {
            if ( prrNs->wType > DNS_TYPE_NS )
            {
                break;
            }
            continue;
        }

        //  use highest ranking non-cache data available
        //  unless doing cache auto write back, then use highest rank
        //      data including cache data if available

        if ( fcacheFile )
        {
            rankNs = RR_RANK(prrNs);
            if ( rankNs < writtenRankNs )
            {
                break;
            }
            if ( IS_CACHE_RANK(rankNs) && !SrvCfg_fAutoCacheUpdate )
            {
                continue;
            }
        }

        if ( !RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prrNs,
                    pNode ) )
        {
            DNS_PRINT(( "Delegation NS RR write failed!!!\n" ));
            ASSERT( FALSE );
            continue;
            //goto WriteFailed;
        }
        writtenRankNs = rankNs;

        //
        //  if writing zone NS, no host write if suppressing OUTSIDE data
        //

        if ( fzoneRoot && SrvCfg_fDeleteOutsideGlue )
        {
            continue;
        }

        //
        //  write "glue" A records ONLY when necessary
        //
        //  We need these records, when they are within a subzone of
        //  the zone we are writing:
        //
        //  example:
        //      zone:       ms.com.
        //      sub-zones:  nt.ms.com.  psg.ms.com.
        //
        //      If NS for nt.ms.com:
        //
        //      1) foo.nt.ms.com
        //          In this case glue for foo.nt.ms.com MUST be added
        //          as ms.com server has no way to lookup foo.nt.ms.com
        //          without knowning server for nt.ms.com to refer query
        //          to.
        //
        //      2) foo.psg.ms.com
        //          Again SHOULD be added unless we already know how to
        //          get to psg.ms.com server.  This is too complicated
        //          sort out, so just include it.
        //
        //      2) bar.ms.com or bar.b26.ms.com
        //          Do not need to write glue record as it is in ms.com.
        //          zone and will be written anyway. (However might want
        //          to verify that it is there and alert admin to lame
        //          delegation if it is not.)
        //
        //      3) bar.com
        //          Outside ms.com.  Don't need to include, as it can
        //          be looked up in its domain.
        //          Not desirable to include it as we don't own it, so
        //          it may change without our knowledge.
        //          However, may want to include if specifically loaded
        //          included in zone.
        //
        //  Note, for reverse lookup domains, name servers are never IN
        //  the domain, and hence no glue is ever needed.
        //
        //  Note, for "cache" zone (writing root hints), name servers are
        //  always needed (always in "subzone") and we can skip test.
        //

        pnodeNs = Lookup_FindGlueNodeForDbaseName(
                        pZone,
                        & prrNs->Data.NS.nameTarget );
        if ( !pnodeNs )
        {
            continue;
        }

        prrA = NULL;
        writtenRankA = 0;
        //LOCK_RR_LIST(pNodeNs);

        prrA = START_RR_TRAVERSE( pnodeNs );

        while( prrA = NEXT_RR(prrA) )
        {
            if ( prrA->wType > DNS_TYPE_A )
            {
                break;
            }

            if ( IS_EMPTY_AUTH_RR( prrNs ) )
            {
                continue;
            }

            //  use highest ranking non-cache data available
            //  unless doing cache auto write back, then use highest rank
            //      data including cache data if available

            if ( fcacheFile )
            {
                rankA = RR_RANK(prrA);
                if ( rankA < writtenRankA )
                {
                    break;
                }
                if ( IS_CACHE_RANK(rankA) && !SrvCfg_fAutoCacheUpdate )
                {
                    continue;
                }
            }

            if ( !RR_WriteToFile(
                        pBuffer,
                        pZone,
                        prrA,
                        pnodeNs ) )
            {
                DNS_PRINT(( "Delegation A RR write failed!!!\n" ));
                ASSERT( FALSE );
                //continue;
                goto WriteFailed;
            }
            writtenRankA = rankA;
        }
        //UNLOCK_RR_LIST(pNodeNs);
    }

    //UNLOCK_RR_LIST(pNode);
    Dbase_UnlockDatabase();

    if ( !fzoneRoot && !fcacheFile )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            ";  End delegation\r\n\r\n" );
    }
    return TRUE;

WriteFailed:

    Dbase_UnlockDatabase();
    IF_DEBUG( ANY )
    {
        Dbg_DbaseNode(
            "ERROR:  Failure writing delegation to file\n",
            pNode );
    }
    return FALSE;
}



BOOL
writeZoneRoot(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    Write zone root node to file.

Arguments:

    pBuffer -- handle for file to write to

    pZone -- zone whose root is being written

    pZoneRoot -- zone's root node

Return Value:

    None.

--*/
{
    PDB_RECORD      prr;

    ASSERT( pBuffer && pZone && pZoneRoot );

    //
    //  write SOA record
    //

    LOCK_RR_LIST(pZoneRoot);

    prr = RR_FindNextRecord(
            pZoneRoot,
            DNS_TYPE_SOA,
            NULL,
            0 );
    if ( !prr )
    {
        DNS_PRINT(( "ERROR:  File write failure, no SOA record found for zone!!!\n" ));
        ASSERT( FALSE );
        goto WriteFailed;
    }
    if ( !RR_WriteToFile(
                pBuffer,
                pZone,
                prr,
                pZoneRoot ) )
    {
        goto WriteFailed;
    }

    //
    //  write zone NS records
    //      - write ONLY zone NS records, not delegation records
    //

    if ( !writeDelegation(
                pBuffer,
                pZone,
                pZoneRoot ) )
    {
        goto WriteFailed;
    }

#if 0
    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Zone NS records\r\n"
        ";\r\n\r\n" );

    prr = NULL;

    while ( prr = RR_FindNextRecord(
                    pZoneRoot,
                    DNS_TYPE_NS,
                    prr,
                    0 ) )
    {
        if ( !IS_ZONE_RR(prr) )
        {
            continue;
        }
        if ( !RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    pZoneRoot ) )
        {
            goto WriteFailed;
        }
    }
#endif

    //
    //  write WINS\WINS-R RR back to file
    //
    //  special case write back of WINS/NBSTAT RR, as may
    //  be LOCAL record and MUST only have one RR to reboot
    //

    if ( pZone && pZone->pWinsRR )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  %s lookup record\r\n"
            ";\r\n\r\n",
            pZone->fReverse ? "WINSR (NBSTAT)" : "WINS" );

        RR_WriteToFile(
            pBuffer,
            pZone,
            pZone->pWinsRR,
            pZoneRoot );
    }

    //
    //  rest of zone root records
    //      - skip previously written SOA and NS records
    //

    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Zone records\r\n"
        ";\r\n\r\n" );

    prr = NULL;

    while( prr = RR_FindNextRecord(
                    pZoneRoot,
                    DNS_TYPE_ALL,
                    prr,
                    0 ) )
    {
        //  if op out WINS record
        // if ( prr->wType == DNS_TYPE_SOA || prr->wType == DNS_TYPE_NS )

        if ( prr->wType == DNS_TYPE_SOA
                ||
             prr->wType == DNS_TYPE_NS
                ||
             prr->wType == DNS_TYPE_WINS
                ||
             prr->wType == DNS_TYPE_WINSR )
        {
            continue;
        }
        if ( !RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    pZoneRoot ) )
        {
            //
            //  DEVNOTE-LOG: general RR write error logging (suggest action)
            //      or set flag and rename file
            //
        }
    }

    UNLOCK_RR_LIST(pZoneRoot);
    //FormattedWriteToFileBuffer( pBuffer, "\r\n\r\n" );
    return TRUE;

WriteFailed:

    UNLOCK_RR_LIST(pZoneRoot);

    IF_DEBUG( ANY )
    {
        Dbg_DbaseNode(
            "ERROR:  Failure writing zone root node to file.\r\n",
            pZoneRoot );
    }
    ASSERT( FALSE );
    return FALSE;
}



BOOL
writeCacheFile(
    IN      PBUFFER         pBuffer,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write's root NS info back to cache file.

Arguments:

    pZone -- ptr to cache zone;  MUST have open handle to cache file.

Return Value:

    None.

--*/
{
    BOOL    retBool;

    ASSERT( IS_ZONE_CACHE(pZone) );
    ASSERT( pBuffer );

    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Root Name Server Hints File:\r\n"
        ";\r\n"
        ";\tThese entries enable the DNS server to locate the root name servers\r\n"
        ";\t(the DNS servers authoritative for the root zone).\r\n"
        ";\tFor historical reasons this is known often referred to as the\r\n"
        ";\t\"Cache File\"\r\n"
        ";\r\n\r\n" );

    //
    //  cache hints are just root delegation
    //

    retBool = writeDelegation(
                    pBuffer,
                    pZone,
                    pZone->pTreeRoot
                    );
    if ( retBool )
    {
        pZone->fDirty = FALSE;
    }
    ELSE
    {
        DNS_DEBUG( ANY, ( "ERROR:  Writing back cache file\n" ));
    }

    //  push remainder of data to disk
    //
    //  DEVNOTE-DCR: 454004 - What to do on write failure? How about write to
    //      temp file and MoveFile() the result to avoid tromping what we've
    //      got there now?
    //

    WriteBufferToFile( pBuffer );

    return( retBool );
}



//
//  Write records to file functions
//

PCHAR
AFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write A record.
    Assumes adequate buffer space.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch += sprintf(
                pch,
                "%d.%d.%d.%d\r\n",
                * ( (PUCHAR) &(pRR->Data.A) + 0 ),
                * ( (PUCHAR) &(pRR->Data.A) + 1 ),
                * ( (PUCHAR) &(pRR->Data.A) + 2 ),
                * ( (PUCHAR) &(pRR->Data.A) + 3 ) );
    return pch;
}



PCHAR
PtrFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  PTR type RR are single indirection RR

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.NS.nameTarget,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }

    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
MxFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    pch += sprintf(
                pch,
                "%d\t",
                ntohs( pRR->Data.MX.wPreference ) );
    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                & pRR->Data.MX.nameExchange,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }

    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
SoaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write SOA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PDB_NAME    pname;

    //  NOTE: not possible to open with ( because of BIND bug)
    //  must have both primary and admin on line for BIND to load

    //  primary name server

    pch += sprintf( pch, " " );

    pname = &pRR->Data.SOA.namePrimaryServer;

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }
    pch += sprintf( pch, "  " );

    //  admin

    pname = Name_SkipDbaseName( pname );

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                pname,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }

    //  fixed fields

    pch += sprintf(
                pch,
                " (\r\n"
                "%s\t%-10u   ; serial number\r\n"
                "%s\t%-10u   ; refresh\r\n"
                "%s\t%-10u   ; retry\r\n"
                "%s\t%-10u   ; expire\r\n"
                "%s\t%-10u ) ; default TTL\r\n",
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwSerialNo ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwRefresh ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwRetry ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwExpire ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwMinimumTtl ) );
    return pch;
}



PCHAR
MinfoFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write MINFO record.
    Includes MINFO and RP record types.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PDB_NAME    pname;

    //  these type's record data is two domain names

    pname = & pRR->Data.MINFO.nameMailbox;

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }
    pch += sprintf( pch, "\t" );

    pname = Name_SkipDbaseName( pname );

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }

    pch += sprintf( pch, "\r\n" );

    return pch;
}



PCHAR
TxtFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write text record types.
    Includes TXT, HINFO, X25, ISDN types.

Arguments:

    pRR - ptr to database record

    pchBuf - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PCHAR       pchtext = pRR->Data.TXT.chData;
    PCHAR       pchtextStop = pchtext + pRR->wDataLength;
    PCHAR       pchbufStart = pchBuf;
    UCHAR       cch;
    BOOL        fopenedBrace = FALSE;


    //  catch empty case
    //  do this here as loop terminator below is in the middle of the loop

    if ( pchtext >= pchtextStop )
    {
        goto NewLine;
    }

    //  open multi-line for TXT record, may have lots of strings

    if ( pRR->wType == DNS_TYPE_TEXT )
    {
        *pchBuf++ = '(';
        *pchBuf++ = ' ';
        fopenedBrace = TRUE;
    }

    //
    //  all these are simply text string(s)
    //
    //  check for blanks in string, to be sure we can reparse
    //  when reload file
    //
    //  DEVNOTE-DCR: 454006 - Better quoting and multiple-line handling.
    //

    while( 1 )
    {
        cch = (UCHAR) *pchtext++;

        pchBuf = File_PlaceStringInFileBuffer(
                    pchBuf,
                    pchBufEnd,
                    FILE_WRITE_QUOTED_STRING,
                    pchtext,
                    cch );
        if ( !pchBuf )
        {
            ASSERT( FALSE );
#if 1
            pchBuf += sprintf(
                        pchbufStart,
                        "ERROR\r\n"
                        ";ERROR: Previous record contained unprintable text data,\r\n"
                        ";       which has been replaced by string \"ERROR\".\r\n"
                        ";       Please review and correct text data.\r\n"  );
#endif
            break;
        }

        //  point to next text string
        //  stop if at end

        pchtext += cch;
        if ( pchtext >= pchtextStop )
        {
            break;
        }

        //  if multi-line, write newline
        //  otherwise separate with space

        if ( fopenedBrace )
        {
            pchBuf += sprintf(
                        pchBuf,
                        "\r\n%s\t",
                        BLANK_NAME_COLUMN );
        }
        else
        {
            *pchBuf++ = ' ';
        }
    }

    //  done, drop to new line, closing multi-line if opened

    if ( fopenedBrace )
    {
        *pchBuf++ = ' ';
        *pchBuf++ = ')';
    }

NewLine:

    *pchBuf++ = '\r';
    *pchBuf++ = '\n';

    ASSERT( pchtext == pchtextStop );

    return( pchBuf );
}



PCHAR
RawRecordFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write record as raw octect string.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DWORD   count;
    PCHAR   pchdata;

    count = pRR->wDataLength;
    pchdata = (PCHAR) &pRR->Data;

    while ( count-- )
    {
        pch += sprintf( pch, "%02x ", *pchdata++ );
    }

    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
WksFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write WKS record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    struct protoent *   pProtoent;
    struct servent *    pServent;
    INT     i;
    USHORT  port;
    INT     bitmask;

    //
    //  WKS address
    //

    pch += sprintf(
                pch,
                "%d.%d.%d.%d\t",
                * ( (PUCHAR) &(pRR->Data.WKS) + 0 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 1 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 2 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 3 ) );

    //
    //  protocol
    //

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );

    if ( pProtoent )
    {
        pch += sprintf(
                    pch,
                    "%s (",                 // services will follow one per line
                    pProtoent->p_name );
    }
    else    // unknown protocol -- write protocol number
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UNKNOWN_PROTOCOL_NUMBER,
            0,
            NULL,
            NULL,
            (INT) pRR->Data.WKS.chProtocol );

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to find protocol %d, writing WKS record\n",
            (INT) pRR->Data.WKS.chProtocol ));

        pch += sprintf(
                    pch,
                    "%u (\t; ERROR:  unknown protocol %u\r\n",
                    (UINT) pRR->Data.WKS.chProtocol,
                    (UINT) pRR->Data.WKS.chProtocol );

        pServent = NULL;
    }


    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];
        port = i * 8;

        //
        //  get service for each bit set in byte
        //      - get out as soon byte is empty of ports
        //

        while ( bitmask )
        {
            if ( bitmask & 0x80 )
            {
                if ( pProtoent )
                {
                    pServent = getservbyport(
                                    (INT) htons(port),
                                    pProtoent->p_name );
                }

                if ( pServent )
                {
                    pch += sprintf(
                            pch,
                            "\r\n%s\t\t%s",
                            BLANK_NAME_COLUMN,
                            pServent->s_name );
                }
                else
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_UNKNOWN_SERVICE_PORT,
                        0,
                        NULL,
                        NULL,
                        (INT) port );

                    DNS_DEBUG( ANY, (
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record\n",
                        port
                        ));

                    pch += sprintf( pch,
                            "\r\n%s\t\t%u\t; ERROR:  unknown service for port %u\r\n",
                            BLANK_NAME_COLUMN,
                            port,
                            port );
                }
            }

            port++;           // next service port
            bitmask <<= 1;     // shift mask up to read next port
        }
    }

    pch += sprintf( pch, " )\r\n" );   // close up service list
    return pch;
}



PCHAR
AaaaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write AAAA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch = Dns_Ip6AddressToString_A(
            pch,
            &pRR->Data.AAAA.Ip6Addr );

    ASSERT( pch );

    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
SrvFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write SRV record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  fixed fields

    pch += sprintf(
                pch,
                "%d %d %d\t",
                ntohs( pRR->Data.SRV.wPriority ),
                ntohs( pRR->Data.SRV.wWeight ),
                ntohs( pRR->Data.SRV.wPort ) );

    //  target host

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                & pRR->Data.SRV.nameTarget,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return pch;
    }

    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
AtmaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write ATMA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch = Dns_AtmaAddressToString(
                pch,
                pRR->Data.ATMA.chFormat,
                pRR->Data.ATMA.bAddress,
                pRR->wDataLength - 1 );         //  length of address, (ie. excluding format)

    if ( !pch )
    {
        return pch;
    }
    pch += sprintf( pch, "\r\n" );
    return pch;
}



PCHAR
WinsFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write WINS or WINSR record.

    Combining these in one function because of duplicate code for
    mapping and timeouts.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DWORD i;

    //
    //  WINS
    //      - scope/domain mapping flag
    //      - WINS server list
    //

    if ( pRR->Data.WINS.dwMappingFlag )
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        Dns_WinsRecordFlagString(
            pRR->Data.WINS.dwMappingFlag,
            achFlag );

        pch += sprintf(
                    pch,
                    "%s ",
                    achFlag );
    }

    pch += sprintf(
                pch,
                "L%d C%d (",
                pRR->Data.WINS.dwLookupTimeout,
                pRR->Data.WINS.dwCacheTimeout );

    //
    //  WINS -- server IPs one per line
    //

    if ( pRR->wType == DNS_TYPE_WINS )
    {
        for( i=0; i<pRR->Data.WINS.cWinsServerCount; i++ )
        {
            pch += sprintf(
                        pch,
                        "\r\n%s\t%d.%d.%d.%d",
                        BLANK_NAME_COLUMN,
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 0 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 1 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 2 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 3 ) );
        }

        pch += sprintf( pch, " )\r\n" );
    }

    //
    //  WINSR -- result domain
    //

    else
    {
        ASSERT( pRR->wType == DNS_TYPE_WINSR );

        pch = File_WriteDbaseNameToFileBuffer(
                    pch,
                    pchBufEnd,
                    & pRR->Data.WINSR.nameResultDomain,
                    pZone );
        if ( !pch )
        {
            ASSERT( FALSE );
            return pch;
        }
        pch += sprintf( pch, " )\r\n" );
    }

    return pch;
}



PCHAR
KeyFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    int     keyLength;

    keyLength = pRR->wDataLength - SIZEOF_KEY_FIXED_DATA;
    if ( pchBufEnd - pch < keyLength * 2 )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Write flags, protocol, and algorithm.
    //

    pch += sprintf(
                pch,
                "0x%04X %d %d ",
                ( int ) ntohs( pRR->Data.KEY.wFlags ),
                ( int ) pRR->Data.KEY.chProtocol,
                ( int ) pRR->Data.KEY.chAlgorithm );

    //
    //  Write key as a base64 string.
    //

    pch = Dns_SecurityKeyToBase64String(
                pRR->Data.KEY.Key,
                keyLength,
                pch );

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
} // KeyFileWrite



PCHAR
SigFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DBG_FN( "SigFileWrite" )

    PCHAR       pszType;
    CHAR        szSigExp[ 30 ];
    CHAR        szSigInc[ 30 ];

    pszType = Dns_RecordStringForType( ntohs( pRR->Data.SIG.wTypeCovered ) );
    if ( !pszType )
    {
        DNS_DEBUG( DATABASE, (
            "%s: null type string for RR type %d in zone %s\n",
            fn,
            ( int ) ntohs( pRR->Data.SIG.wTypeCovered ),
            pZone->pszZoneName ));
        pch = NULL;
        goto Cleanup;
    }

    pch += sprintf(
                pch,
                "%s %d %d %d %s %s %d ",
                pszType,
                ( int ) pRR->Data.SIG.chAlgorithm,
                ( int ) pRR->Data.SIG.chLabelCount,
                ( int ) ntohl( pRR->Data.SIG.dwOriginalTtl ),
                Dns_SigTimeString(
                    ntohl( pRR->Data.SIG.dwSigExpiration ),
                    szSigExp ),
                Dns_SigTimeString(
                    ntohl( pRR->Data.SIG.dwSigInception ),
                    szSigInc ),
                ( int ) ntohs( pRR->Data.SIG.wKeyTag ) );

    //
    //  Write signer's name.
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                &pRR->Data.SIG.nameSigner,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }
    pch += sprintf( pch, " " );

    //
    //  Write signature as a base64 string.
    //

    pch = Dns_SecurityKeyToBase64String(
                ( PBYTE ) &pRR->Data.SIG.nameSigner +
                    DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
                pRR->wDataLength -
                    SIZEOF_SIG_FIXED_DATA - 
                    DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
                pch );

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
}   //  SigFileWrite



PCHAR
NxtFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    int byteIdx, bitIdx;

    //
    //  Write next name.
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                &pRR->Data.NXT.nameNext,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Write list of types from the type bitmap. Never write a value
    //  for bit zero.
    //

    for ( byteIdx = 0; byteIdx < DNS_MAX_TYPE_BITMAP_LENGTH; ++byteIdx )
    {
        for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
        {
            PCHAR   pszType;

            if ( !( pRR->Data.NXT.bTypeBitMap[ byteIdx ] &
                    ( 1 << bitIdx ) ) )
            {
                continue;   // Bit value is zero - do not write string.
            }
            pszType = Dns_RecordStringForType( byteIdx * 8 + bitIdx );
            if ( !pszType )
            {
                ASSERT( FALSE );
                continue;   // This type has no string - do not write.
            }
            pch += sprintf( pch, " %s", pszType );
        } 
    }

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
}   //  NxtFileWrite



//
//  Write RR to file dispatch table
//

RR_FILE_WRITE_FUNCTION   RRFileWriteTable[] =
{
    RawRecordFileWrite, //  ZERO -- default for unknown types

    AFileWrite,         //  A
    PtrFileWrite,       //  NS
    PtrFileWrite,       //  MD
    PtrFileWrite,       //  MF
    PtrFileWrite,       //  CNAME
    SoaFileWrite,       //  SOA
    PtrFileWrite,       //  MB
    PtrFileWrite,       //  MG
    PtrFileWrite,       //  MR
    RawRecordFileWrite, //  NULL
    WksFileWrite,       //  WKS
    PtrFileWrite,       //  PTR
    TxtFileWrite,       //  HINFO
    MinfoFileWrite,     //  MINFO
    MxFileWrite,        //  MX
    TxtFileWrite,       //  TXT
    MinfoFileWrite,     //  RP
    MxFileWrite,        //  AFSDB
    TxtFileWrite,       //  X25
    TxtFileWrite,       //  ISDN
    MxFileWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFileWrite,       //  SIG
    KeyFileWrite,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFileWrite,      //  AAAA
    NULL,               //  LOC
    NxtFileWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFileWrite,       //  SRV
    AtmaFileWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFileWrite,      //  WINS
    WinsFileWrite       //  WINS-R
};




BOOL
writeNodeRecordsToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write node's RRs to file.

Arguments:


Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  prr;
    UCHAR       previousRank = 0;       // satisfy compiler
    UCHAR       rank;
    WORD        previousType = 0;
    WORD        type;
    BOOL        fwrittenRR = FALSE;
    BOOL        ret = TRUE;

    //
    //  walk RR list, writing each record
    //

    LOCK_RR_LIST(pNode);

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  skip cached records

        if ( IS_CACHE_RR( prr ) )
        {
            continue;
        }

        //  avoid writing duplicate records from different ranks

        type = prr->wType;
        rank = RR_RANK(prr);
        if ( type == previousType && rank != previousRank )
        {
            continue;
        }
        previousRank = rank;
        previousType = type;

        //  write RR
        //      - first RR written with node name, following defaulted
        //      - continue on unwritable record

        ret = RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    fwrittenRR ? NULL : pNode );
        if ( !ret )
        {
            continue;
        }
        fwrittenRR = TRUE;
    }

    UNLOCK_RR_LIST(pNode);
    return ret;
}



BOOL
RR_WriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Print RR in packet format.

    Assumes pNode is locked for read.

Arguments:

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch;
    PCHAR   pchout;
    PCHAR   pchend;
    PCHAR   pszTypeName;
    WORD    type = pRR->wType;
    RR_FILE_WRITE_FUNCTION  pwriteFunction;

    //
    //  Skip empty auth RRs. Return TRUE - nothing was written but no error.
    //

    if ( IS_EMPTY_AUTH_RR( pRR ) )
    {
        ASSERT( !IS_EMPTY_AUTH_RR( pRR ) );
        return TRUE;
    }

    //
    //  verify adequate buffer space
    //      (includes node name, max record and overhead)
    //  if not available push buffer to disk and reset
    //

    pch = pBuffer->pchCurrent;
    pchend = pBuffer->pchEnd;

    if ( pch + MAX_RECORD_FILE_WRITE > pchend )
    {
        if ( !WriteBufferToFile( pBuffer ) )
        {
            ASSERT( FALSE );
        }
        ASSERT( IS_EMPTY_BUFFER(pBuffer) );
        pch = pBuffer->pchCurrent;
    }

    //
    //  get type name \ verify writable record type
    //

    pszTypeName = DnsRecordStringForWritableType( type );
    if ( !pszTypeName )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UNWRITABLE_RECORD_TYPE,
            0,
            NULL,
            NULL,
            (WORD) type );

        pch += sprintf(
                pch,
                ";ERROR:  record of unknown type %d\r\n"
                ";DNS server should be upgraded to version that supports this type\n",
                type );
    }

    //
    //  write domain name -- if necessary
    //      - extra tabs if defaulting domain name
    //

    if ( pNode )
    {
        pch = writeNodeNameToBuffer(
                pBuffer,
                pNode,
                pZone,
                NULL );         //  no trailer, causes pad to end of name column
        if ( !pch )
        {
            ASSERT( FALSE );
            return FALSE;
        }
    }
    else
    {
        pch += sprintf( pch, "%s", BLANK_NAME_COLUMN );
    }

    //
    //  if aging zone -- write age
    //

    if ( pRR->dwTimeStamp && pZone && pZone->bAging )
    {
        pch += sprintf( pch, "[AGE:%u]\t", pRR->dwTimeStamp );
    }

    //
    //  write non-default TTL
    //
    //  write NO TTLs to cache file
    //
    //  note:  the RFCs indicate that the SOA value is a minimum TTL,
    //          but in order to allow small values to indicate the
    //          impending expiration of a particular record it is more
    //          useful to consider this the "default" TTL;  we'll
    //          stick to this convention, and save values smaller
    //          than the minimum
    //

    if ( pZone
            && IS_ZONE_AUTHORITATIVE( pZone )
            && pZone->dwDefaultTtl != pRR->dwTtlSeconds
            && !IS_ZONE_TTL_RR( pRR ) )
    {
        pch += sprintf( pch, "%u\t", ntohl( pRR->dwTtlSeconds ) );
    }

    //
    //  write class and type
    //      - SOA must write class to identify zone class
    //

    if ( type == DNS_TYPE_SOA )
    {
        pch += sprintf( pch, "IN  SOA" );
    }
    else if ( pszTypeName )
    {
        pch += sprintf( pch, "%s\t", pszTypeName );
    }
    else
    {
        pch += sprintf( pch, "#%d\t", type );
    }

    //
    //  write RR data
    //

    pwriteFunction = (RR_FILE_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFileWriteTable,
                            type );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    pchout = pwriteFunction(
                pRR,
                pch,
                pchend,
                pZone );
    if ( pchout )
    {
        //  successful
        //  reset buffer for data written

        pBuffer->pchCurrent = pchout;
        return TRUE;
    }

    //
    //  write failed
    //      - if data in buffer, than possible buffer space problem,
    //          empty buffer and retry
    //      - note empty buffer on retry prevents infinite recursion
    //

    if ( !IS_EMPTY_BUFFER( pBuffer ) )
    {
        if ( !WriteBufferToFile(pBuffer) )
        {
            ASSERT( FALSE );
        }
        ASSERT( IS_EMPTY_BUFFER(pBuffer) );

        pchout = pwriteFunction(
                    pRR,
                    pch,
                    pchend,
                    pZone );
        if ( pchout )
        {
            //  successful
            //  reset buffer for data written

            pBuffer->pchCurrent = pchout;
            return TRUE;
        }
    }

    //
    //  record write failed on empty buffer
    //

    DnsDbg_Lock();
    DNS_PRINT((
        "WARNING:  RRFileWrite routine failure for record type %d,\n"
        "\tassuming out of buffer space\n",
        type ));

    Dbg_DbaseRecord(
        "Record that failed file write:",
        pRR );

    Dbg_DbaseNode(
        "ERROR:  Failure writing to RR at node\n",
        pNode );
    DnsDbg_Unlock();

    return FALSE;
}

//
//  End of dfwrite.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dns.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dns.c

Abstract:

    Domain Name System (DNS) Server

    This is the main routine for the NT Domain Name Service.

Author:

    Jim Gilroy (jamesg)     March 1996

Revision History:

--*/


#include "dnssrv.h"


//
//  Service control globals
//

SERVICE_STATUS          DnsServiceStatus;
SERVICE_STATUS_HANDLE   DnsServiceStatusHandle;

#if DBG

//
//  This is DBG only because it exposes security holes. By keeping the global DBG
//  only we ensure that the code that uses it will also be DBG only, so we won't
//  mistakenly ship retail code with security holes.
//

BOOL                    g_RunAsService = TRUE;

//
//  Test thread for playing around in debug
//

DNS_STATUS Test_Thread( PVOID );

#endif

//
//  Service control code to announce DNS server start to other services
//      (defined in dnsapi.h)
//  Netlogon service needs to be alerted when DNS server starts, to allow
//  it to start registering.
//

//#define SERVICE_CONTROL_DNS_SERVER_START      (0x00000200)

#define NETLOGON_SERVICE_NAME               (L"netlogon")

LPWSTR  g_wszNetlogonServiceName = NETLOGON_SERVICE_NAME;


extern DWORD g_ServerState = DNS_STATE_LOADING;


//
//  Static globals
//      - system processors
//

DWORD   g_ProcessorCount;


//
//  Service control globals
//

HANDLE  hDnsContinueEvent = NULL;
HANDLE  hDnsShutdownEvent = NULL;
HANDLE  hDnsCacheLimitEvent = NULL;

//
//  Alert threads to service change
//
//  This provides low cost, in-line test for threads, to determine
//  whether they need to even call Thread_ServiceCheck() which
//  checks pause\shutdown state and waits if appropriate.
//

BOOL    fDnsThreadAlert = TRUE;

//
//  Service exit flag
//

BOOL    fDnsServiceExit = FALSE;

//
//  Restart globals
//

DWORD   g_LoadCount = 0;
BOOL    g_bDoReload = FALSE;
BOOL    g_bHitException = FALSE;

//
//  Startup announcement globals
//

BOOL    g_fAnnouncedStartup = FALSE;
DWORD   g_StartupTime = 0;

#define FORCE_STARTUP_ANNOUNCE_TIMEOUT  (60)    // one minute


//
//  General server CS
//

CRITICAL_SECTION    g_GeneralServerCS;


//
//  Misc globals
//

DWORD       g_dwEnableAdvancedDatabaseLocking = 0;


//
//  Service dispatch table.
//      - Run DNS as standalone service
//

VOID
startDnsServer(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    );

SERVICE_TABLE_ENTRY steDispatchTable[] =
{
    { DNS_SERVICE_NAME,  startDnsServer },
    { NULL,              NULL           }
};


//
//  Private protos
//

DNS_STATUS
loadDatabaseAndRunDns(
    VOID
    );

VOID
indicateShutdown(
    IN      BOOL            fShutdownRpc
    );



//
//  Main entry point
//

VOID
__cdecl
main(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    )
/*++

Routine Description:

    DNS main routine.

    Initializes service controller to dispatch DNS service.

--*/
{
    #if DBG

    DWORD i;

    for ( i = 1; i < argc; ++i )
    {
        char * pszcommand = ( PCHAR ) argv[ i ];

        //  Strip off optional command char.

        if ( *pszcommand == '/' || *pszcommand == '-' )
        {
            ++pszcommand;
        }

        //  Test arguments.

        if ( _stricmp( ( PCHAR ) argv[ i ], "/notservice" ) == 0 )
        {
            g_RunAsService = FALSE;
        }
    }

    if ( g_RunAsService )
    {
        StartServiceCtrlDispatcher( steDispatchTable );
    }
    else
    {
        startDnsServer( argc, argv );
    }

    #else

    StartServiceCtrlDispatcher( steDispatchTable );

    #endif

    ExitProcess( 0 );
}



//
//  Service control routines
//

VOID
announceServiceStatus(
    VOID
    )
/*++

Routine Description:

    Announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/
{
    #if DBG
    if ( !g_RunAsService )
    {
        goto Done;
    }
    #endif

    //
    //  Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //

    if ( DnsServiceStatusHandle == 0 )
    {
        DNS_DEBUG( ANY, (
            "announceServiceStatus:  Cannot call SetServiceStatus, "
            "no status handle\n" ));
        DnsDebugFlush();
        return;
    }

    //  call SetServiceStatus, ignoring any errors.

    SetServiceStatus( DnsServiceStatusHandle, &DnsServiceStatus );

    #if DBG
    Done:       //  free builds error on unused labels!
    #endif

    DNS_DEBUG( INIT, (
        "Announced DNS service status %p, (%d) at time %d\n",
        DnsServiceStatus.dwCurrentState,
        GetCurrentTimeInSeconds() ));
}



DNS_STATUS
Service_SendControlCode(
    IN      LPWSTR          pwszServiceName,
    IN      DWORD           dwControlCode
    )
/*++

Routine Description:

    Send control code to given service.

    Note, this routine is generic, it could be moved to library.
    
    Security note: the permissions now requested from the SCM are
    only sufficient to send user-defined controls to services. If
    this routine is used for any other purpose the requested
    permissions may need to be changed.

Arguments:

    pwszServiceName -- service name (unicode)

    dwControlCode -- control code to send

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    SC_HANDLE       hmanager = NULL;
    SC_HANDLE       hservice = NULL;
    SERVICE_STATUS  serviceStatus;
    DNS_STATUS      status;

    hmanager = OpenSCManagerW(
                    NULL,
                    NULL,
                    GENERIC_WRITE );
    if ( !hmanager )
    {
        goto Failed;
    }

    hservice = OpenServiceW(
                    hmanager,
                    pwszServiceName,
                    SERVICE_USER_DEFINED_CONTROL );
    if ( !hservice )
    {
        goto Failed;
    }

    if ( ControlService(
            hservice,
            dwControlCode,
            &serviceStatus ) )
    {
        status = ERROR_SUCCESS;
        goto Cleanup;
    }

Failed:

    status = GetLastError();
    DNS_DEBUG( ANY, (
        "Service_SendControlCode() failed!\n"
        "    service  = %S\n"
        "    code     = %p\n"
        "    error    = %p (%lu)\n",
        pwszServiceName,
        dwControlCode,
        status, status ));

Cleanup:

    if ( hmanager )
    {
        CloseServiceHandle( hmanager );
    }
    if ( hservice )
    {
        CloseServiceHandle( hservice );
    }

    return status;
}



VOID
Service_LoadCheckpoint(
    VOID
    )
/*++

Routine Description:

    Inform service controller of passage another load checkpoint.

Arguments:

    None.

Return Value:

    None.

--*/
{
    #define DNS_SECONDS_BETWEEN_SCM_UPDATES     10

    static DWORD    dwLastScmAnnounce = 0x7FFFFF0;      //  Forces initial announce.

    #if DBG
    if ( !g_RunAsService )
    {
        return;
    }
    #endif

    //
    //  if already announced starup, checkpoint is pointless
    //

    if ( g_fAnnouncedStartup )
    {
        return;
    }

    UPDATE_DNS_TIME();

    //
    //  announce start if long load
    //
    //  service controller has long delay and will eventually give up
    //  the "dot-stream" if we don't announce startup in a couple minutes.
    //  so if load still progressing, BUT is now over a minute since
    //  start, simply announce that we're starting
    //

    if ( g_StartupTime + FORCE_STARTUP_ANNOUNCE_TIMEOUT > DNS_TIME() )
    {
        Service_ServiceControlAnnounceStart();
        goto Done;
    }

    //
    //  Don't notify SCM too frequently.
    //

    if ( dwLastScmAnnounce + DNS_SECONDS_BETWEEN_SCM_UPDATES < DNS_TIME() )
    {
        goto Done;
    }

    //  should never reach check point, without successful call to
    //  RegisterServiceCtrlHandler()

    ASSERT( DnsServiceStatusHandle != 0 );

    //
    //  bump check point, inform service controller
    //

    DnsServiceStatus.dwCheckPoint++;
    announceServiceStatus();

    DNS_DEBUG( INIT, (
        "Startup checkpoint %d at time %d\n",
        DnsServiceStatus.dwCheckPoint,
        GetCurrentTimeInSeconds() ));

    dwLastScmAnnounce = DNS_TIME();

    Done:

    return;
}



VOID
Service_ServiceControlAnnounceStart(
    VOID
    )
/*++

Routine Description:

    Inform service controller of that we've started.
    Note, that we may not necessarily mean we've started.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  if already announced startup -- skip
    //

    if ( g_fAnnouncedStartup )
    {
        return;
    }

    #if DBG
    if ( !g_RunAsService )
    {
        return;
    }
    #endif

    //  should never reach start without successful call to
    //  RegisterServiceCtrlHandler()

    ASSERT( DnsServiceStatusHandle != 0 );

    DnsServiceStatus.dwCurrentState = SERVICE_RUNNING;
    DnsServiceStatus.dwControlsAccepted =
                                SERVICE_ACCEPT_STOP |
                                SERVICE_ACCEPT_PAUSE_CONTINUE |
                                SERVICE_ACCEPT_SHUTDOWN |
                                SERVICE_ACCEPT_PARAMCHANGE |
                                SERVICE_ACCEPT_NETBINDCHANGE;

    DnsServiceStatus.dwCheckPoint = 0;
    DnsServiceStatus.dwWaitHint = 0;

    announceServiceStatus();

    g_fAnnouncedStartup = TRUE;

    DNS_DEBUG( INIT, (
        "Announced DNS server startup at time %d\n",
        GetCurrentTimeInSeconds() ));

    //
    //  tell netlogon DNS server has started
    //

    Service_SendControlCode(
        g_wszNetlogonServiceName,
        SERVICE_CONTROL_DNS_SERVER_START );
}



VOID
respondToServiceControlMessage(
    IN      DWORD   opCode
    )
/*++

Routine Description:

    Handle service control messages.

Arguments:

    opCode - service control opcode

Return Value:

    None.

--*/
{
    BOOL    announce = TRUE;
    INT     err;

    IF_DEBUG( ANY )
    {
        DNS_PRINT((
            "\nrespondToServiceControlMessage( %d )\n",
            opCode ));
        DnsDebugFlush();
    }

    //
    //  process given service action
    //
    //  change the service status to reflect new statustlist
    //

    switch( opCode )
    {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        DNSLOG( INIT, ( "Received service control stop\n" ));

        DnsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        announceServiceStatus();

        //
        //  Alert threads of shutdown
        //  Sets shutdown event and closes sockets, to wake threads.
        //

        indicateShutdown( TRUE );

        //
        //  Main thread should announce shutdown when completed.
        //

        announce = FALSE;
        break;

    case SERVICE_CONTROL_PAUSE:

        DnsServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
        announceServiceStatus( );

        //
        //  Pause threads on their next test
        //

        err = ResetEvent( hDnsContinueEvent );
        ASSERT( err );

        DnsServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        DnsServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
        announceServiceStatus();

        //
        //  Release paused threads
        //

        err = SetEvent( hDnsContinueEvent );
        ASSERT( err );

        DnsServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_INTERROGATE:

        //
        //  Just announce our status
        //

        break;

    case SERVICE_CONTROL_PARAMCHANGE :
    case SERVICE_CONTROL_NETBINDADD :
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:

        //
        //  In .NET the server listens for IP address changes directly.
        //  We no longer pick up IP changes in response to these service
        //  control messages.
        //
        
#if 0
        //
        //  PnP notification
        //  Caching resolver will give us a PnP notification if IP interfaces change
        //

        if ( g_ServerState == DNS_STATE_RUNNING )
        {
            Sock_ChangeServerIpBindings();
        }
        ELSE_IF_DEBUG( ANY )
        {
            DNS_PRINT((
                "Ignoring PARAMCHANGE because server state is %d\n",
                g_ServerState ));
        }
#endif

        break;

    default:

        break;
    }

    if ( announce )
    {
        announceServiceStatus( );
    }

}   // respondToServiceControlMessage



VOID
Service_IndicateException(
    VOID
    )
/*++

Routine Description:

    Indicate exception and force shutdown or possible restart

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  if NOT already shutting down
    //
    //      - set exception flag
    //      - indicate shutdown to wake other threads
    //
    //  exception flag will mean that exception is cause of the shutdown;
    //  exception while doing normal shutdown should be ignored
    //

    if ( !fDnsServiceExit )
    {
        g_bHitException = TRUE;
        try
        {
            indicateShutdown( FALSE );
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
        }
    }
}



VOID
Service_IndicateRestart(
    VOID
    )
/*++

Routine Description:

    Indicate exception and force shutdown or possible restart

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_bDoReload = TRUE;

    try
    {
        indicateShutdown( FALSE );
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
    }
}



//
//  Main startup\run\shutdown routines
//

VOID
indicateShutdown(
    IN      BOOL            fShutdownRpc
    )
/*++

Routine Description:

    Indicates service shutdown to all threads.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT err;

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT((
            "indicateShutdown()\n"
            "    fDnsServiceExit = %d\n",
            fDnsServiceExit ));
        DnsDebugFlush();
    }

    //
    //  set global shutdown flag
    //

    if ( fDnsServiceExit )
    {
        return;
    }
    fDnsServiceExit = TRUE;

    //
    //  alert threads to make the check
    //

    fDnsThreadAlert = TRUE;

    //
    //  set termination event to wake up waiting threads
    //

    if ( hDnsShutdownEvent != NULL )
    {
        SetEvent( hDnsShutdownEvent );
    }

    //
    //  release any paused threads
    //

    if ( hDnsContinueEvent != NULL )
    {
        SetEvent( hDnsContinueEvent );
    }

    //
    //  close all sockets
    //
    //  wakes up any threads waiting in recvfrom() or select()
    //

    Sock_CloseAllSockets();

    //  close UDP completion port

    Udp_ShutdownListenThreads();

    //
    //  wake timeout thread
    //

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Waking timeout thread\n" ));
        DnsDebugFlush();
    }
    Timeout_LockOut();

    //
    //  shutdown RPC
    //
    //  do NOT do this when intentionally shutting down on RPC
    //  thread;  (dnscmd /Restart) as since you're in an RPC thread
    //  the RPC shutdown can hang
    //

    if ( fShutdownRpc )
    {
        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT(( "Shutting down RPC\n" ));
            DnsDebugFlush();
        }
        Rpc_Shutdown();
    }

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Finished indicateShutdown()\n" ));
        DnsDebugFlush();
    }
}



VOID
startDnsServer(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    )
/*++

Routine Description:

    DNS service entry point.

    Called by service controller when DNS service asked to start.

Arguments:

Return Value:

    None.

--*/
{
    DBG_FN( "startDnsServer" )

    DNS_STATUS  status;
    SYSTEM_INFO systemInfo;

    //  CredHandle DefaultCredHandle;

    DNS_DEBUG( INIT, ( "%s: starting\n" ) );

    //
    //  Initialize all the status fields so that subsequent calls to
    //  SetServiceStatus() need to only update fields that changed.
    //

    DnsServiceStatus.dwServiceType = SERVICE_WIN32;
    DnsServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    DnsServiceStatus.dwControlsAccepted = 0;
    DnsServiceStatus.dwCheckPoint = 1;
    DnsServiceStatus.dwWaitHint = DNSSRV_STARTUP_WAIT_HINT;
    DnsServiceStatus.dwWin32ExitCode = NO_ERROR;
    DnsServiceStatus.dwServiceSpecificExitCode = NO_ERROR;

    //  Save processor count
    //      - useful for determining number of threads to create

    GetSystemInfo( &systemInfo );
    g_ProcessorCount = systemInfo.dwNumberOfProcessors;

    //
    //  General server CS
    //
    
    if ( DnsInitializeCriticalSection( &g_GeneralServerCS ) != ERROR_SUCCESS )
    {
        return;
    }

    //
    //  Initialize heap - do this before eventlog init because UTF8 registry
    //      routines used in eventlog init require heap.
    //
    //  Set dnslib \ dnsapi.dll to use server's heap routines
    //

    if ( !Mem_HeapInit() )
    {
        return;
    }

    Dns_LibHeapReset(
        Mem_DnslibAlloc,
        Mem_DnslibRealloc,
        Mem_DnslibFree );

    #if 0
    //
    //  .NET: There is a race condition in DNSAPI where some stuff can get
    //  allocated before this call, then passed back to the DNS server later
    //  and freed with the wrong free. To eliminate this we are going to let
    //  DNSAPI do it's own memory management. 
    //
    
    DnsApiHeapReset(
        Mem_DnslibAlloc,
        Mem_DnslibRealloc,
        Mem_DnslibFree );
    #endif

    DNS_DEBUG( INIT, ( "%s: mem init complete\n" ) );

    //
    //  Initialize debugging. The flag found in the file is the dnslib
    //  debug flag and is also used as the starting value for the server
    //  debug flag. The server debug flag value may be over-written by
    //  the DebugLevel parameter from the registry.
    //
    //  For server-only debug logging, do not use the file. Instead use
    //  the regkey.
    //

#if DBG
    Dns_StartDebug(
        0,
        DNS_DEBUG_FLAG_FILENAME,
        NULL,
        DNS_DEBUG_FILENAME,
        DNS_SERVER_DEBUG_LOG_WRAP );

    if ( pDnsDebugFlag )
    {
        DnsSrvDebugFlag = *pDnsDebugFlag;
    }

    IF_DEBUG( START_BREAK )
    {
        DnsDebugBreak();
    }

    //  Verify static data

    Name_VerifyValidFileCharPropertyTable();
#endif

    //
    //  Initialize our handles to the event log.  We do this early so that
    //  we can log events if any other initializations fail.
    //

    status = Eventlog_Initialize();
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  Initialize server to receive service requests by registering the
    //  control handler.
    //

    #if DBG
    if ( !g_RunAsService )
    {
        goto DoneServiceRegistration;
    }
    #endif

    DnsServiceStatusHandle = RegisterServiceCtrlHandler(
                                    DNS_SERVICE_NAME,
                                    respondToServiceControlMessage );
    if ( DnsServiceStatusHandle == 0 )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR:  RegisterServiceCtrlHandler() failed\n"
            "    error = %d %p\n",
            status, status ));
        goto Exit;
    }
    announceServiceStatus( );

    #if DBG
    DoneServiceRegistration: // free builds error on unused labels!
    #endif

    //
    //  Initialize seconds timer
    //      - there's a CS that protects timer wrap
    //      - save off startup time
    //

    Dns_InitializeSecondsTimer();

    g_StartupTime = GetCurrentTimeInSeconds();

    DNS_DEBUG( INIT, (
        "Server start at time %d\n",
        g_StartupTime ));

#if 0
    //
    //  disable B-node on resolver
    //

    DnsDisableBNodeResolverThread();
    Sleep( 3000 );
#endif

    //
    //  load and run DNS, this thread becomes TCP receive thread
    //
    //  we will continue to do this if g_bDoReload flag indicates
    //      that reload is appropriate
    //

    do
    {
        g_bDoReload = FALSE;
        g_bHitException = FALSE;

        fDnsThreadAlert = TRUE;
        fDnsServiceExit = FALSE;

        DNS_DEBUG( INIT, ( "%s: loading database\n", fn ) );

        status = loadDatabaseAndRunDns();

        g_LoadCount++;
    }
    while( g_bDoReload );


Exit:

    //
    //  Place nice with ICS. This must be done before event logging and
    //  debug logging have been shut down.
    //

    ICS_Notify( FALSE );

    //  Log shutdown

    DNS_LOG_EVENT(
        DNS_EVENT_SHUTDOWN,
        0,
        NULL,
        NULL,
        0 );

    //
    //  Announce that we're down.
    //

    DnsServiceStatus.dwCurrentState = SERVICE_STOPPED;
    DnsServiceStatus.dwControlsAccepted = 0;
    DnsServiceStatus.dwCheckPoint = 0;
    DnsServiceStatus.dwWaitHint = 0;
    DnsServiceStatus.dwWin32ExitCode = status;
    DnsServiceStatus.dwServiceSpecificExitCode = status;
    announceServiceStatus();

    //  Close event log.
    //  Close log file.
    //  Close debug file.
    Eventlog_Terminate();
    Dns_EndDebug();
}



//
//  Global initialization
//
//  To allow restart, the various initialization routines are
//  initializing some globals that ordinarily would be done by
//  compiler generated load code.
//
//  However, a few require initialization before the init routines
//  even run, as they serve as flags.  Others are in modules that
//  do not have an init routine.
//

extern  BOOL    g_fUsingSecondary;

extern  DWORD   g_ThreadCount;

extern  BOOL    g_bRpcInitialized;

extern  BOOL    mg_TcpConnectionListInitialized;


VOID
initStartUpGlobals(
    VOID
    )
/*++

Routine Description:

    Init globals that must be initialized before we get to normal
    initialization.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS

--*/
{
    //  DS globals (ds.c)

    Ds_StartupInit();

    //  thread array count (thread.c)

    g_ThreadCount = 0;

    //  clear NBSTAT globals (nbstat.c)

    Nbstat_StartupInitialize();

    //  RPC init (rpc.c)

    g_bRpcInitialized = FALSE;

    //  TCP connection list

    mg_TcpConnectionListInitialized = FALSE;

    //  secondary module init flag (zonesec.c)

    g_fUsingSecondary = FALSE;

    //  WINS init (wins.c)

    g_pWinsQueue = NULL;
}



VOID
normalShutdown(
    IN      DNS_STATUS      TerminationError
    )
/*++

Routine Description:

    Normal shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT         err;
    DWORD       i;

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

    indicateShutdown( TRUE );

    //
    //  Announce that we're going down.
    //

    if ( !g_bDoReload )
    {
        DnsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        DnsServiceStatus.dwCheckPoint = 1;
        DnsServiceStatus.dwWaitHint = DNSSRV_SHUTDOWN_WAIT_HINT;
        DnsServiceStatus.dwWin32ExitCode = TerminationError;
        DnsServiceStatus.dwServiceSpecificExitCode = TerminationError;

        announceServiceStatus();
    }

    //
    //  wait on all outstanding worker threads to wrap up
    //

    Thread_ShutdownWait();

    //
    //  dump statistics for this run.
    //
    //  DEVNOTE: 454016 - need some reload stats and reload context in dump
    //

    IF_DEBUG( ANY )
    {
        if ( SrvCfg_fStarted )
        {
            DNS_PRINT(( "Final DNS statistics:\n" ));
            Dbg_Statistics();
        }
    }

    //
    //  Write back dirty zones and optionally boot file
    //

    if ( SrvCfg_fStarted )
    {
        try
        {
            Zone_WriteBackDirtyZones( TRUE );

            if ( !SrvCfg_fBootMethod && SrvCfg_fBootFileDirty )
            {
                File_WriteBootFile();
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            //  DEVNOTE: need to log or do something intelligent here!
        }
    }

    //
    //  DEVNOTE-DCR: 454018 - stop here on restart (see RAID for full B*GB*G text)
    //

    //
    //  Close event handles
    //

    if ( hDnsContinueEvent != NULL )
    {
        err = CloseHandle( hDnsContinueEvent );
        ASSERT( err == TRUE );
        hDnsContinueEvent = NULL;
    }

    if ( hDnsShutdownEvent != NULL )
    {
        err = CloseHandle( hDnsShutdownEvent );
        ASSERT( err == TRUE );
        hDnsShutdownEvent = NULL;
    }

    if ( hDnsCacheLimitEvent != NULL )
    {
        err = CloseHandle( hDnsCacheLimitEvent );
        ASSERT( err == TRUE );
        hDnsCacheLimitEvent = NULL;
    }

    //
    //  Cleanup security package
    //

    if ( g_fSecurityPackageInitialized )
    {
        Dns_TerminateSecurityPackage();
    }

    //
    //  Close Winsock
    //

    WSACleanup( );

#if 0
    //
    //  DEVNOTE-DCR: 454109 Memory cleanup is currently disabled but it 
    //  would be nice for leak detection!!
    //
    //  Cleanup memory
    //      - database
    //      - recursion queue
    //      - secondary control queue
    //      - WINS queue
    //      - zone list
    //      - TCP connection list
    //

    Recurse_CleanupRecursion();
    Wins_Cleanup();
    Nbstat_Shutdown();

    Tcp_ConnectionListDelete();
#endif

    //
    //  Closing NBT handles
    //
    //  Shouldn't be necessary now that get process termination, BUT
    //  I think this may be the cause of the MM bugcheck we see.
    //

    Nbstat_Shutdown();

    Dp_Cleanup();

    Log_Shutdown();
}



VOID
reloadShutdown(
    VOID
    )
/*++

Routine Description:

    Reload shutdown.

    Like regular shutdown except:
        - wrap shutdown code with exception handlers
        - attempt closing handles that we'll reinit,
            again wrapped with exception handling
        - delete heap

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT         err;
    DWORD       terminationError = ERROR_SUCCESS;
    DWORD       i;
    DNS_STATUS  status;

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

#if 0
    //  loop approach -- saves taking lots of handlers in typical case
    //
    //  do shutdown work within exception handler
    //  loop until at least TRY each item once
    //

    bcontinue = TRUE;

    while ( bcontinue )
    {
        bcontinue = FALSE;

        try
        {
            if ( !btriedIndicateShutdown )
            {
                indicateShutdown();
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            bcontinue = TRUE;
        }
    }
#endif

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

    try
    {
        indicateShutdown( TRUE );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  wait on all outstanding worker threads to wrap up
    //

    try
    {
        Thread_ShutdownWait();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  dump statistics for this run.
    //
    //  DEVNOTE-DCR: 454016 - need some reload stats and context in dump
    //

    try
    {
        IF_DEBUG( ANY )
        {
            if ( SrvCfg_fStarted )
            {
                DNS_PRINT(( "Final DNS statistics:\n" ));
                Dbg_Statistics();
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Write back dirty zones and optionally boot file
    //

    try
    {
        if ( SrvCfg_fStarted )
        {
            Zone_WriteBackDirtyZones( TRUE );

            if ( !SrvCfg_fBootMethod && SrvCfg_fBootFileDirty )
            {
                File_WriteBootFile();
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  DEVNOTE-DCR: 454018 - stop here on restart (see RAID for full B*GB*G text)
    //

#if 0
    //  DEVNOTE-DCR: 454109 Memory cleanup is currently disabled but it 
    //  would be nice for leak detection!!

    //  Cleanup memory
    //      - database
    //      - recursion queue
    //      - secondary control queue
    //      - WINS queue
    //      - zone list
    //      - TCP connection list
    //

    ZoneList_Shutdown();
    Recurse_CleanupRecursion();
    Wins_Cleanup();
    Nbstat_Shutdown();
    Tcp_ConnectionListDelete();
    Update_Shutdown();
    Secondary_Shutdown();
#endif

    #ifdef DNSSRV_PLUGINS
    Plugin_Cleanup();
    #endif

    //
    //  cleanup TCP connection list
    //      - sockets
    //      - queue CS
    //      - event
    //
    //  note:  closing these sockets shouldn't be required
    //      to wake all threads

    try
    {
        Tcp_ConnectionListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //  close winsock itself

    try
    {
        WSACleanup( );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Close event handles
    //  JENHANCE -- these could just be reset instead?
    //

    try
    {
        CloseHandle( hDnsContinueEvent );
        CloseHandle( hDnsShutdownEvent );
        CloseHandle( hDnsCacheLimitEvent );
        hDnsContinueEvent = hDnsShutdownEvent = hDnsCacheLimitEvent = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //  Cleanup security package

    if ( g_fSecurityPackageInitialized )
    {
        try
        {
            Dns_TerminateSecurityPackage();
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {}
    }

    //  cleanup WINS queue


    //  Close Winsock

    try
    {
        WSACleanup( );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Closing NBT handles and queues
    //

    try
    {
        Nbstat_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  delete various CS and packet queues
    //      - with queues includes closing of queuing event
    //

    try
    {
        Packet_ListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Zone_ListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Wins_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Xfr_CleanupSecondaryZoneControl();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Up_UpdateShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Recurse_CleanupRecursion();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Ds_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Security_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Log_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}


    //
    //  Delete heap -- the big one
    //

    try
    {
        Mem_HeapDelete();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
}



DNS_STATUS
loadDatabaseAndRunDns(
    VOID
    )
/*++

Routine Description:

    This is main load \ TCP service thread.

    Moved from startDnsServer() so that to simplify calling it in a loop
    when DNS encounters AV or out of memory condition.

Arguments:

Return Value:

    None.

--*/
{
    DBG_FN( "loadDatabaseAndRunDns" )

    INT         err;
    DWORD       terminationError = ERROR_SUCCESS;
    DWORD       i;
    DNS_STATUS  status;
    
    DNS_DEBUG( INIT, ( "%s: starting at %d\n", fn, GetCurrentTimeInSeconds() ));
    
    g_ServerState = DNS_STATE_LOADING;

    //
    //  init globals
    //

    initStartUpGlobals();

    //
    //  create heap
    //  heap is initialized in main routine on first pass
    //

    if ( g_LoadCount != 0 )
    {
        if ( !Mem_HeapInit() )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto StartFailed;
        }
    }

    //
    //  Initialize registry module.
    //
    
    Reg_Init();

    //
    //  init security
    //      - security applied to perfmon stuff initialized
    //      in stats, so go before stats

    Security_Initialize();

    //
    //  statistics
    //      - must come before server config init, or
    //      some of the memory stats get boggled up

    Stats_Initialize();

    //
    //  Init server configuration. This will read the "true" debug level out
    //  of the registry so don't bother logging much before this point unless
    //  you plan to be using the dnsdebug log flag file.
    //

    if ( !Config_Initialize() )
    {
        status = ERROR_INVALID_DATA;
        goto StartFailed;
    }

    //
    //  Update log level. Force event logging to the log file always.
    //

    SrvCfg_dwOperationsLogLevel_LowDword |= ( DWORD ) DNSLOG_EVENT;
    DNSLOG_UPDATE_LEVEL();
    
    //
    //  Make privates copies of configuration items that are not allowed
    //  to be changed and take effect during a session.
    //
    
    g_dwEnableAdvancedDatabaseLocking =
        SrvCfg_dwEnableAdvancedDatabaseLocking;

    //
    //  Boot-time debug logs.
    //

    DNS_DEBUG( INIT, (
        "DNS time: %d -> %d CRT system boot -> %s",
        DNS_TIME(),
        SrvInfo_crtSystemBootTime,
        ctime( &SrvInfo_crtSystemBootTime ) ));

    //
    //  If after reading the debug level from the registry a start break
    //  is required, execute it.
    //

    IF_DEBUG( START_BREAK )
    {
        DnsDebugBreak();
    }

    //
    //  service control -- pause and shutdown -- events
    //
    //  start service with continue event unsignalled -- paused;
    //  this allows us to spawn threads as we create sockets and
    //  load database, yet have them wait until everything is initialized
    //
    //  also create other events here
    //

    hDnsContinueEvent = CreateEvent(
                            NULL,           //  Security Attributes
                            TRUE,           //  create Manual-Reset event
                            FALSE,          //  start unsignalled -- paused
                            NULL );         //  event name
    hDnsShutdownEvent = CreateEvent(
                            NULL,           //  Security Attributes
                            TRUE,           //  create Manual-Reset event
                            FALSE,          //  start unsignalled
                            NULL );         //  event name
    hDnsCacheLimitEvent = CreateEvent(
                            NULL,           //  Security Attributes
                            FALSE,          //  not manual reset
                            FALSE,          //  start unsignalled
                            NULL );         //  event name
    if ( !hDnsShutdownEvent || !hDnsContinueEvent || !hDnsCacheLimitEvent )
    {
        status = GetLastError();
        DNS_PRINT(( "ERROR: CreateEvent failed status=%d\n", status ));
        goto StartFailed;
    }

    //
    //  initialize logging
    //      - failure not terminal to startup
    //

    Log_InitializeLogging(
        FALSE );    // fAlreadyLocked

    DNSLOG( INIT, ( "Server settings have been successfully loaded\n" ));

    //
    //  init packet list
    //      must be done before socket create \ UDP receive start

    if ( !Packet_ListInitialize() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto StartFailed;
    }

    //
    //  init timeout thread info
    //  do this here, so that we don't encounter problems on timeout frees
    //  before timeout thread starts
    //

    if ( !Timeout_Initialize() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto StartFailed;
    }

    //
    //  initialize recursion
    //      - init queue
    //      - init remote list
    //      - init recursion thread
    //

    if ( !Recurse_InitializeRecursion() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto StartFailed;
    }

    //
    //  initialize update queue
    //

    status = Up_InitializeUpdateProcessing();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }

    //
    //  init packet tracking
    //

    Packet_InitPacketTrack();

    //
    //  init bad sender suppression
    //

    Send_InitBadSenderSuppression();

    //
    //  Place nice with ICS. This can be done any time after event logging 
    //  and debug logging have been initialized.
    //

    ICS_Notify( TRUE );

    //
    //  Open, bind, and listen on sockets on the UDP and TCP DNS ports.
    //

    status = Sock_ReadAndOpenListeningSockets();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }
    DNS_DEBUG( INIT, ( "%s: sockets are open\n", fn ) );

    //
    //  Initialize zone list and zone locking.
    //

    if ( !Zone_ListInitialize() )
    {
        goto StartFailed;
    }

    Zone_LockInitialize();

    //
    //  Initialize the permanent database
    //

    if ( !Dbase_Initialize( DATABASE_FOR_CLASS(DNS_RCLASS_INTERNET) ) )
    {
        return ERROR_INVALID_DATA;
    }

    //
    //  Directory partition initialization
    //

    Dp_Initialize();

    //
    //  Load the DNS database of resource records.
    //
    //  Note:  this may cause creation of other threads, sockets, events, etc.
    //      - secondary thread
    //      - WINS recv thread
    //

    status = Boot_LoadDatabase();
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Boot_LoadDatabase() failed %p (%d)\n",
            status, status ));

        //  return recognizable status code to service controller
        //      if NOT in DNS space bring it in

        if ( ( DWORD ) status > ( DWORD ) DNSSRV_STATUS )
        {
            status = DNS_ERROR_ZONE_CREATION_FAILED;
            DNS_DEBUG( ANY, (
                "Remap Boot_LoadDatabase() failed error to %p (%d)\n",
                status, status ));
        }
        goto StartFailed;
    }

    //
    //  Start timeout thread
    //      - doing this after database load to make sure it's impossible
    //        for thread to get to partially loaded database -- no matter
    //        how long load takes
    //

    if ( !Thread_Create(
                "Timeout_Thread",
                Timeout_Thread,
                NULL,
                0 ) )
    {
        status = GetLastError();
        goto StartFailed;
    }
    
    //
    //  Plugin initialization
    //
    
    #ifdef DNSSRV_PLUGINS
    Plugin_Initialize();
    #endif

    //
    //  Setup RPC -- only once everything started and we're ready to go
    //

    status = Rpc_Initialize();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Rpc_Initialize() returned %p (%d)\n",
            status, status ));

        DNS_LOG_EVENT(
            DNS_EVENT_RPC_SERVER_INIT_FAILED,
            0,
            NULL,
            NULL,
            status );
#if 0
        goto StartFailed;
#endif
    }

    //
    //  Announce startup. This must be done before we try to do socket
    //  receive operations, or else they will hang. (Because they will
    //  think that the server is paused and so will wait for it to
    //  become unpaused.)
    //

    if ( g_LoadCount == 0 )
    {
        Service_ServiceControlAnnounceStart();
    }

    //
    //  create UDP receive threads
    //

    status = Udp_CreateReceiveThreads();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }

    //
    //  start DS polling thread
    //  currently do this even if no DS, so we can switch it on
    //      whenever desired;
    //
    // DEVNOTE-DCR: 454035 - Start DS polling thread when DS is opened?
    //

    if ( !Thread_Create(
                "DsPoll",
                Ds_PollingThread,
                NULL,
                0 ) )
    {
        status = GetLastError();
        goto StartFailed;
    }

    //
    //  Initialize scavenging
    //

    status = Scavenge_Initialize();
    if ( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( INIT, (
           "Error <%lu>: Failed to initialize scavenging\n",
           status ));
    }

    //
    //  Debug only stuff
    //
    
    #if 0
    Thread_Create( "TestThread", Test_Thread, NULL, 0 );
    #endif
    
    //
    //  Perform the first poll for directory partitions and migrate
    //  any dcpromo zones. If this fails start the service anyways.
    //
    
    Dp_Poll( NULL, UPDATE_DNS_TIME(), TRUE );

    //
    //  Start IP notification change thread.
    //

    if ( Thread_Create(
            "IpNotify_Thread",
            IpNotify_Thread,
            NULL,
            0 ) )
    
    //
    //  We are now officially started - all data is loaded and
    //  all worker threads have been created.
    //

    SrvCfg_fStarted = TRUE;
    if ( g_LoadCount == 0 )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_STARTUP_OK,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  Change state to RUNNING.
    //

    g_ServerState = DNS_STATE_RUNNING;

    //
    //  Release any waiting threads
    //
    //  note, test for shutdown during startup and reset fDnsThreadAlert
    //  so that threads are properly woken;  (we do this after normal
    //  clearing fDnsThreadAlert to avoid timing window with indicate
    //  shutdown)
    //

    IF_DEBUG( INIT )
    {
        Dbg_ThreadHandleArray();
    }
    fDnsThreadAlert = FALSE;
    if ( fDnsServiceExit )
    {
        fDnsThreadAlert = TRUE;
    }
    err = SetEvent( hDnsContinueEvent );

    ASSERT( err );

    //
    //  Use this thread to receive incoming TCP DNS requests.
    //

    DNS_DEBUG( INIT, (
        "Loaded and running TCP receiver on pass %d\n",
        g_LoadCount ));

    try
    {
        Tcp_Receiver();
    }
    except( TOP_LEVEL_EXCEPTION_TEST() )
    {
        DNS_DEBUG( ANY, (
            "EXCEPTION: %p (%d) on TCP server thread\n",
            GetExceptionCode(),
            GetExceptionCode() ));

        //TOP_LEVEL_EXCEPTION_BODY();
        Service_IndicateException();
    }

    g_ServerState = DNS_STATE_TERMINATING;

    //
    //  determine if we'll reload
    //      - started
    //      - hit exception (not regular shutdown)
    //      - set to reload
    //
    //  started is covered by being here
    //  g_bHitException should only be set when we hit exception
    //  -- not on regular shutdown, or exception during regular shutdown
    //  and when want to reload
    //

    if ( g_bHitException )
    {
        ASSERT( SrvCfg_fStarted );
        ASSERT( SrvCfg_bReloadException );

        if ( SrvCfg_fStarted && SrvCfg_bReloadException )
        {
            g_bDoReload = TRUE;
        }
    }
    if ( g_bDoReload )
    {
        reloadShutdown();
        return( ERROR_SUCCESS );
    }

    //
    //  Shut down (though may reload).
    //
    //  Fall here when receiver thread exits or if error on startup.
    //

StartFailed:

    g_ServerState = DNS_STATE_TERMINATING;

    DNS_DEBUG( SHUTDOWN, (
        "DNS service error upon exiting: %p (%d)\n",
        status, status ));

    normalShutdown( status );

    return status;
}


//
//  End dns.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dnsplugininterface.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    plugin.h

Abstract:

    Domain Name System (DNS) Server

    DNS plugins

Author:

    Jeff Westhead, November 2001

Revision History:

--*/


#ifndef _DNSPLUGININTERFACE_H_INCLUDED
#define _DNSPLUGININTERFACE_H_INCLUDED


#ifndef DNS_SERVER

#define DNS_MAX_TYPE_BITMAP_LENGTH      16

#pragma pack( push, 1 )

typedef struct _DbName
{
    UCHAR   Length;
    UCHAR   LabelCount;
    CHAR    RawName[ DNS_MAX_NAME_LENGTH + 1 ];
}
DB_NAME;

typedef struct _Dbase_Record
{
    struct _Dbase_Record *    pRRNext;      //  plugin must set this field

    DWORD           Reserved1;
    WORD            wType;                  //  plugin must set this field
    WORD            Reserved2;
    DWORD           dwTtlSeconds;           //  plugin must set this field
    DWORD           Reserved3;

    //
    //  Data for specific types - the plugin must fill out all fields
    //

    union
    {
        struct
        {
            IP_ADDRESS      ipAddress;
        }
        A;

        struct
        {
            IP6_ADDRESS     Ip6Addr;
        }
        AAAA;

        struct
        {
            DWORD           dwSerialNo;
            DWORD           dwRefresh;
            DWORD           dwRetry;
            DWORD           dwExpire;
            DWORD           dwMinimumTtl;
            DB_NAME         namePrimaryServer;

            //  ZoneAdmin name immediately follows
            //  DB_NAME         nameZoneAdmin;
        }
        SOA;

        struct
        {
            DB_NAME         nameTarget;
        }
        PTR,
        NS,
        CNAME,
        MB,
        MD,
        MF,
        MG,
        MR;

        struct
        {
            DB_NAME         nameMailbox;

            //  ErrorsMailbox immediately follows
            // DB_NAME         nameErrorsMailbox;
        }
        MINFO,
        RP;

        struct
        {
            WORD            wPreference;
            DB_NAME         nameExchange;
        }
        MX,
        AFSDB,
        RT;

        struct
        {
            BYTE            chData[1];
        }
        HINFO,
        ISDN,
        TXT,
        X25,
        Null;

        struct
        {
            IP_ADDRESS      ipAddress;
            UCHAR           chProtocol;
            BYTE            bBitMask[1];
        }
        WKS;

        struct
        {
            WORD            wTypeCovered;
            BYTE            chAlgorithm;
            BYTE            chLabelCount;
            DWORD           dwOriginalTtl;
            DWORD           dwSigExpiration;
            DWORD           dwSigInception;
            WORD            wKeyTag;
            DB_NAME         nameSigner;
            //  signature data follows signer's name
        }
        SIG;

        struct
        {
            WORD            wFlags;
            BYTE            chProtocol;
            BYTE            chAlgorithm;
            BYTE            Key[1];
        }
        KEY;

        struct
        {
            WORD            wVersion;
            WORD            wSize;
            WORD            wHorPrec;
            WORD            wVerPrec;
            DWORD           dwLatitude;
            DWORD           dwLongitude;
            DWORD           dwAltitude;
        }
        LOC;

        struct
        {
            BYTE            bTypeBitMap[ DNS_MAX_TYPE_BITMAP_LENGTH ];
            DB_NAME         nameNext;
        }
        NXT;

        struct
        {
            WORD            wPriority;
            WORD            wWeight;
            WORD            wPort;
            DB_NAME         nameTarget;
        }
        SRV;

        struct
        {
            UCHAR           chFormat;
            BYTE            bAddress[1];
        }
        ATMA;

        struct
        {
            DWORD           dwTimeSigned;
            DWORD           dwTimeExpire;
            WORD            wSigLength;
            BYTE            bSignature;
            DB_NAME         nameAlgorithm;

            //  Maybe followed in packet by other data
            //  If need to process then move fixed fields ahead of
            //      bSignature

            //  WORD    wError;
            //  WORD    wOtherLen;
            //  BYTE    bOtherData;
        }
        TSIG;

        struct
        {
            WORD            wKeyLength;
            BYTE            bKey[1];
        }
        TKEY;

        struct
        {
            UCHAR           chPrefixBits;
            // AddressSuffix should be SIZEOF_A6_ADDRESS_SUFFIX_LENGTH
            // bytes but that constant is not available in dnsexts
            BYTE            AddressSuffix[ 16 ];
            DB_NAME         namePrefix;
        }
        A6;

    } Data;
}
DB_RECORD, *PDB_RECORD;

#pragma pack( pop )

#endif


//
//  Prototypes for DNS server functions exported by pointer to the plugin.
//

typedef PVOID ( __stdcall * PLUGIN_ALLOCATOR_FUNCTION )(
    size_t                      sizeAllocation
    );

typedef VOID ( __stdcall * PLUGIN_FREE_FUNCTION )(
    PVOID                       pFree
    );


//
//  Interface function names. The plugin DLL must export functions with
//  these names. All 3 functions must be exported by the plugin.
//

#define     PLUGIN_FNAME_INIT       "DnsPluginInitialize"
#define     PLUGIN_FNAME_CLEANUP    "DnsPluginCleanup"
#define     PLUGIN_FNAME_DNSQUERY   "DnsPluginQuery"


//
//  Interface prototypes. The plugin DLL must export functions matching 
//  these prototypes. All 3 functions must be exported by the plugin.
//

typedef DWORD ( *PLUGIN_INIT_FUNCTION )(
    PLUGIN_ALLOCATOR_FUNCTION   dnsAllocateFunction,
    PLUGIN_FREE_FUNCTION        dnsFreeFunction
    );

typedef DWORD ( *PLUGIN_CLEANUP_FUNCTION )(
    VOID
    );

typedef DWORD ( *PLUGIN_DNSQUERY_FUNCTION )(
    PSTR                        pszQueryName,
    WORD                        wQueryType,
    PSTR                        pszRecordOwnerName,
    PDB_RECORD *                ppDnsRecordListHead
    );

//
//  PLUGIN_FNAME_DNSQUERY return codes. The plugin must return one of
//  these values and may never return a value not listed below.
//

#define DNS_PLUGIN_SUCCESS              ERROR_SUCCESS
#define DNS_PLUGIN_NO_RECORDS           -1
#define DNS_PLUGIN_NAME_ERROR           -2
#define DNS_PLUGIN_NAME_OUT_OF_SCOPE    -3
#define DNS_PLUGIN_OUT_OF_MEMORY        DNS_ERROR_NO_MEMORY
#define DNS_PLUGIN_GENERIC_FAILURE      DNS_ERROR_RCODE_SERVER_FAILURE

/*

DNS_PLUGIN_SUCCESS -> The plugin has allocated a linked list of DNS 
    recource records. All resource records in the list MUST have the
    same DNS type value as the query type.
    
DNS_PLUGIN_NO_RECORDS -> The name exists but there are no records of
    the queried type at this name. The plugin should return a single
    SOA record as the record list.
    
DNS_PLUGIN_NAME_ERROR -> The DNS name queried for does not exist. The
    plugin may optionally return a single SOA record as the record list.

DNS_PLUGIN_NAME_OUT_OF_SCOPE -> The DNS name queried for is outside the
    authority of the plugin. The plugin must not return any resource
    records. The DNS server will continue name resolution by forwarding
    or recursing as configured.

DNS_PLUGIN_OUT_OF_MEMORY -> Memory error. The plugin must not return
    any resource records.

DNS_PLUGIN_GENERIC_FAILURE -> Other internal error. The plugin must not 
    return any resource records.

Note: if the plugin returns an SOA (see NO_RECORDS or NAME_ERROR, above)
then the plugin should also write the DNS name of the owner of the SOA
record to the pszRecordOwnerName parameter. The DNS server will always
pass a pointer to a static buffer that will be DNS_MAX_NAME_LENGTH+1
characters long.

*/


#endif  //  _DNSPLUGININTERFACE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dnsrpc_s_stub.c ===
#include "dnssrv.h"

#include "dnsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dfread.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dfread.c

Abstract:

    Domain Name System (DNS) Server

    File read routines.
    => general file read\tokenize\parse routines shared with bootfile.c
        and RR parse functions
    => build zone from database file function

Author:

    Jim Gilroy (jamesg)     November 1996

Revision History:

--*/


#include "dnssrv.h"

#include <malloc.h>

//
//  UTF8 files
//
//  notepad.exe has option to save files as UTF8
//  for a UTF8 file the first three bytes are (EF BB BF) which
//  is the UTF8 conversion of the unicode file byte marker (FEFF)
//

BYTE Utf8FileId[] = { 0xEF, 0xBB, 0xBF };

#define UTF8_FILE_ID            (Utf8FileId)

#define UTF8_FILE_ID_LENGTH     (3)




//
//  File read utils
//

const CHAR *
readNextToken(
    IN OUT  PBUFFER         pBuffer,
    OUT     PULONG          pcchTokenLength,
    OUT     PBOOL           pfLeadingWhitespace
    )
/*++

Routine Description:

    Read next token in buffer.

Arguments:

    pBuffer - buffer of file data

    pcchTokenLength - ptr to DWORD to receive token length

    pfLeadingWhitespace - ptr to indicate if whitespace before token;  this indicates
        use of same name as previous, when reading record name token;

Return Value:

    Ptr to first byte in next token if successful.
    NULL if out of tokens.

--*/
{
    register PCHAR  pch;
    UCHAR           ch = 0;
    WORD            charType = 0;
    WORD            stopMask = B_READ_TOKEN_STOP;
    PCHAR           pchend;
    PCHAR           ptokenStart;
    BOOL            fquoted = FALSE;

    pch = pBuffer->pchCurrent;
    pchend = pBuffer->pchEnd;

    ASSERT( pcchTokenLength != NULL );
    ASSERT( pfLeadingWhitespace != NULL );
    *pfLeadingWhitespace = FALSE;

    //
    //  Implementation note:
    //      pch -- always points at NEXT unread char in buffer;
    //          when finish it is at or is rolled back to point at next token
    //      bufLength -- always indicates remaining bytes in buffer relative
    //          to pch;  i.e. they stay in ssync
    //
    //  It is NOT safe to dereference pch, without verifying bufLength, as on
    //  the last token of memory mapped file, this would blow up.
    //

    //
    //  skip leading whitespace -- find next token start
    //

    while ( pch < pchend )
    {
        ch = (UCHAR) *pch++;
        charType = DnsFileCharPropertyTable[ ch ];

        if ( charType & B_READ_WHITESPACE )
        {
            continue;
        }
        break;
    }

    //  exhausted file, without finding new token, kick out

    if ( pch >= pchend )
    {
        ASSERT( pch == pBuffer->pchEnd );
        goto EndOfBuffer;
    }

    //  save token start
    //  check if found leading whitespace

    ptokenStart = pch - 1;
    if ( ptokenStart > pBuffer->pchCurrent )
    {
        *pfLeadingWhitespace = TRUE;
    }

    DNS_DEBUG( OFF, (
        "After white space cleansing:\n"
        "    pch = %p, ptokenStart = %p\n"
        "    ch = %c (%d)\n"
        "    charType = %04x\n",
        pch,
        ptokenStart,
        ch, ch,
        charType ));

    //
    //  special processing characters
    //

    if ( charType & B_READ_TOKEN_STOP )
    {
        //  comment?
        //      -- dump rest of comment, return newline token

        if ( ch == COMMENT_CHAR )
        {
            while ( pch < pchend  &&  (*pch++ != NEWLINE_CHAR) )
            {
                continue;
            }
            if ( pch >= pchend )
            {
                ASSERT( pch == pBuffer->pchEnd );
                goto EndOfBuffer;
            }

            //  point token start at newline

            ptokenStart = pch - 1;
            ASSERT( *ptokenStart == NEWLINE_CHAR );
            goto TokenParsed;
        }

        //
        //  single character tokens
        //  need to check here as these are also stop characters
        //

        if ( ch == NEWLINE_CHAR ||
            ch == LINE_EXTENSION_START_CHAR ||
            ch == LINE_EXTENSION_END_CHAR )
        {
            ASSERT( ptokenStart == pch - 1);
            goto TokenParsed;
        }

        //  only other stop tokens are comment (previously processed)
        //  or whitespace (can't be here)

        DNS_DEBUG( ALL, (
            "ERROR:  Bogus char = %u, charType = %x\n"
            "    pch = %p\n"
            "    ptokenStart = %p\n",
            ch,
            charType,
            pch,
            ptokenStart ));

        ASSERT( FALSE );
    }

    //
    //  at beginning of token
    //      - check for quoted string
    //      - token start is next character
    //

    if ( ch == QUOTE_CHAR )
    {
        stopMask = B_READ_STRING_STOP;
        ptokenStart = pch;
        if ( pch >= pchend )
        {
            ASSERT( pch == pBuffer->pchEnd );
            goto EndOfBuffer;
        }
    }
    ELSE_ASSERT( ptokenStart == pch - 1);

    //
    //  find token length, and remainder of buffer
    //      - find token stop
    //      - calculate length
    //

    DNS_DEBUG( OFF, (
        "start token parse:\n"
        "    pchToken = %p, token = %c\n"
        "    bytes left = %d\n",
        ptokenStart,
        *ptokenStart,
        pchend - pch ));

    ASSERT( ch != COMMENT_CHAR && ch != NEWLINE_CHAR &&
            ch != LINE_EXTENSION_START_CHAR && ch != LINE_EXTENSION_END_CHAR );

    while ( pch < pchend )
    {
        ch = (UCHAR) *pch++;
        charType = DnsFileCharPropertyTable[ ch ];

        DNS_DEBUG( PARSE2, (
            "    ch = %c (%d), charType = %04x\n",
            ch, ch,
            charType ));

        //  handle the 99% case first
        //  hopefully minimizing instructions

        if ( !(charType & B_READ_MASK) )
        {
            fquoted = FALSE;
            continue;
        }

        //  if quoted character (ex \") then always accept it
        //      it may quote more octal chars, but none of those characters will
        //      need any special processing so we can now turn off quote

        //
        //  DEVNOTE: quoted char should be printable -- need to enforce?
        //      don't want to allow say quoted line feed and miss line feed
        //

        if ( fquoted )
        {
            fquoted = FALSE;
            continue;
        }

        //
        //  special stop characters
        //      whitespace      -- ends any string
        //      special chars   -- ends non-quoted string only
        //      quote char      -- ends quoted string only
        //
        //  if hit stop token, back up to point at stop token, it begins next token
        //

        if ( charType & stopMask )
        {
            --pch;
            break;
        }

        //  quote char (\) quotes next character

        if ( ch == SLASH_CHAR )
        {
            fquoted = TRUE;
            continue;
        }

        //  any non-standard character which is not stop character for
        //  token type

        fquoted = FALSE;
        continue;
    }

TokenParsed:

    //
    //  set token length and next token ptr
    //

    *pcchTokenLength = (DWORD)(pch - ptokenStart);

    //  if quoted string token, move next token ptr past terminating quote

    if ( stopMask == B_READ_STRING_STOP && ch == QUOTE_CHAR )
    {
        pch++;
    }

    //
    //  reset for remainder of buffer
    //

    ASSERT( pch <= pchend );
    pBuffer->pchCurrent = (PCHAR) pch;
    pBuffer->cchBytesLeft = (DWORD)(pchend - pch);

    DNS_DEBUG( PARSE2, (
        "After token parse:\n"
        "    pchToken = %p, length = %d, token = %.*s\n"
        "    pchNext  = %p, bytes left = %d\n",
        ptokenStart,
        *pcchTokenLength,
        *pcchTokenLength,
        ptokenStart,
        pch,
        pBuffer->cchBytesLeft ));

    return ptokenStart;


EndOfBuffer:

    ASSERT( pch == pBuffer->pchEnd );

    *pcchTokenLength = 0;
    pBuffer->cchBytesLeft = 0;
    return NULL;
}



DNS_STATUS
File_GetNextLine(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Return next token in a buffer.

Arguments:

    pParseInfo - parsing info for file

Return Value:

    ERROR_SUCCESS on normal line termination.
    ErrorCode on error.

--*/
{
    const CHAR *    pchtoken;
    DWORD           tokenLength;
    DWORD           tokenCount = 0;
    BOOL            fparens = FALSE;
    DWORD           parensTokenCount = 0;
    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fleadingWhitespace;

    //
    //  end of buffer?
    //  if ran out of space, but returned valid tokens processing last record
    //      then, may enter this function with no bytes in buffer
    //

    if ( pParseInfo->Buffer.cchBytesLeft == 0 )
    {
        return ERROR_NO_TOKEN;
    }

    //
    //  get tokens until get parsing for next entire useable line
    //      - ignore comment lines and empty lines
    //      - get all tokens in extended line
    //      - inc line count now, so correct for events during tokenizing
    //

    pParseInfo->cLineNumber++;

    while( 1 )
    {
        #define DNS_MAX_TOKENS_IN_LINE      100
        
        pchtoken = readNextToken(
                        & pParseInfo->Buffer,
                        & tokenLength,
                        & fleadingWhitespace );

        //
        //  Overflow check: if we are looking for the close parenthesis
        //  only allow a fixed maximum number of tokens. If we exceed
        //  the limit, assume the zone file is bad and abort.
        //
        
        if ( fparens )
        {
            if ( ++parensTokenCount > DNS_MAX_TOKENS_IN_LINE )
            {
                status = DNS_ERROR_DATAFILE_PARSING;
                break;
            }
        }
        
        //
        //  end of file?
        //

        if ( !pchtoken )
        {
            if ( pParseInfo->Buffer.cchBytesLeft != 0 )
            {
                File_LogFileParsingError(
                    DNS_EVENT_UNEXPECTED_END_OF_TOKENS,
                    pParseInfo,
                    NULL );
                return( DNS_ERROR_DATAFILE_PARSING );
            }
            if ( tokenCount == 0 )
            {
                status = ERROR_NO_TOKEN;
            }
            break;
        }
        ASSERT( pchtoken != NULL );

        //
        //  newlines and line extension
        //      - need test for length as quoted string may start with
        //      "(..."
        //

        if ( tokenLength == 1 )
        {
            //
            //  newline
            //      - ignore newline and continue if no valid line so far
            //      - continue parsing if doing line extension
            //      - stop if end of valid line

            if ( *pchtoken == NEWLINE_CHAR )
            {
                if ( tokenCount == 0 || fparens )
                {
                    pParseInfo->cLineNumber++;
                    continue;
                }
                break;
            }

            //
            //  line extension -- set flag but ignore token
            //

            if ( *pchtoken == LINE_EXTENSION_START_CHAR )
            {
                fparens = TRUE;
                parensTokenCount = 0;
                continue;
            }
            else if ( *pchtoken == LINE_EXTENSION_END_CHAR )
            {
                fparens = FALSE;
                continue;
            }
        }

        //
        //  useful token
        //      - save leading whitespace indication on first token
        //      - save token, token lengths
        //

        if ( tokenCount == 0 )
        {
            pParseInfo->fLeadingWhitespace = (BOOLEAN)fleadingWhitespace;
        }
        pParseInfo->Argv[ tokenCount ].pchToken = (PCHAR) pchtoken;
        pParseInfo->Argv[ tokenCount ].cchLength = tokenLength;
        tokenCount++;
    }

    //  set returned token count

    pParseInfo->Argc = tokenCount;

#if DBG
    IF_DEBUG( INIT2 )
    {
        DWORD i;

        DnsPrintf(
            "Tokenized line %d -- %d tokens:\n",
            pParseInfo->cLineNumber,
            tokenCount );

        for( i=0; i<tokenCount; i++ )
        {
            DnsPrintf(
                "    token[%d] = %.*s (len=%d)\n",
                i,
                pParseInfo->Argv[i].cchLength,
                pParseInfo->Argv[i].pchToken,
                pParseInfo->Argv[i].cchLength );
        }
    }
#endif

    return status;
}




//
//  Database file parsing utilities
//

VOID
File_InitBuffer(
    OUT     PBUFFER         pBuffer,
    IN      PCHAR           pchStart,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Initialize buffer structure.

Arguments:

Return Value:

    None

--*/
{
    pBuffer->cchLength     = dwLength;
    pBuffer->pchStart      = pchStart;
    pBuffer->pchEnd        = pchStart + dwLength;
    pBuffer->pchCurrent    = pchStart;
    pBuffer->cchBytesLeft  = dwLength;
}



BOOLEAN
File_LogFileParsingError(
    IN      DWORD           dwEvent,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    )
/*++

Routine Description:

    Log database parsing problem.

Arguments:

    dwEvent - particular event to log

    pParseInfo - database context for parsing error

    pToken - current token being parsed

Return Value:

    FALSE to provide return for token routines.

--*/
{
    PVOID   argArray[3];
    BYTE    typeArray[3];
    WORD    argCount = 0;
    CHAR    szToken[ MAX_TOKEN_LENGTH+1 ];
    CHAR    szLineNumber[ 8 ];
    DWORD   errData;

    DNS_DEBUG( INIT, (
        "LogFileParsingError()\n"
        "    event %p\n"
        "    parse info %p\n"
        "    token %p %.*s\n",
        dwEvent,
        pParseInfo,
        pToken,
        pToken ? pToken->cchLength : 0,
        pToken ? pToken->pchToken : NULL ));

    //
    //  quit if no parse info -- this check allows reuse of code
    //  by RPC record reading, without having to special case
    //

    if ( !pParseInfo )
    {
        DNS_DEBUG( EVENTLOG, (
           "LogFileParsingError() with no pParseInfo -- no logging\n" ));
        return FALSE;
    }

    //
    //  set error data to error status, if any
    //

    errData = pParseInfo->fErrorCode;

    //
    //  prepare token string
    //

    if ( pToken )
    {
        File_MakeTokenString(
            szToken,
            pToken,
            NULL );     //  don't specify pParseInfo to avoid circular error loop
        argArray[argCount] = (PCHAR) szToken;
        typeArray[argCount] = EVENTARG_UTF8;
        argCount++;
    }

    //
    //  prepare file and line number
    //      - default is just these two strings
    //

    argArray[argCount] = pParseInfo->pwsFileName;
    typeArray[argCount] = EVENTARG_UNICODE;
    argCount++;
    argArray[argCount] = (PCHAR) (DWORD_PTR) pParseInfo->cLineNumber;
    typeArray[argCount] = EVENTARG_DWORD;
    argCount++;

    //
    //  special event processing?
    //      - events that need strings in non-default order
    //

    //
    //  log event
    //

    DNS_LOG_EVENT(
        dwEvent,
        argCount,
        argArray,
        typeArray,
        errData );

    //
    //  if terminal error, set indication
    //

    pParseInfo->fTerminalError = NT_ERROR(dwEvent);
    DNS_DEBUG( INIT, (
        "Parser logging event = 0x%p, %sterminal error\n",
        dwEvent,
        pParseInfo->fTerminalError
            ? ""
            : "non-" ));
    return FALSE;
}



BOOLEAN
File_MakeTokenString(
    OUT     LPSTR           pszString,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Make token into string.

Arguments:

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch = pToken->pchToken;
    DWORD   cch = pToken->cchLength;

    if ( cch > DNS_MAX_NAME_LENGTH )
    {
        if ( pParseInfo )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_TOKEN,
                pParseInfo,
                pToken );
        }
        return FALSE;
    }

    //  copy token and NULL terminate

    RtlCopyMemory(
        pszString,
        pch,
        cch );
    pszString[ cch ] = 0;

    return TRUE;
}



BOOLEAN
File_ParseIpAddress(
    OUT     PDNS_ADDR       pDnsAddr,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Parse IP address string into standard DNS_ADDR respresentation.

Arguments:

    pDnsAddr - ptr to storage for IP address

    pToken - current token being parsed

    pParseInfo - parse context, OPTIONAL;  if given then token MUST parse
        to DWORD, if does not log error

Return Value:

    TRUE - if successful
    FALSE - if invalid IP address string

--*/
{
    CHAR        szIpAddress[ DNS_ADDR_IP_STRING_BUFFER_LENGTH + 1 ] = "";

    //
    //  convert IP string to IP address
    //

    if ( pToken->cchLength >
         ( sizeof( szIpAddress ) - 1 ) / sizeof( szIpAddress[ 0 ] ) )
    {
        goto BadIpAddress;
    }
    File_MakeTokenString( szIpAddress, pToken, pParseInfo );

    if ( !Dns_StringToDnsAddr_A( pDnsAddr, szIpAddress ) )
    {
        goto BadIpAddress;
    }
    
    //
    //  Assume we will need this address set to port 53.
    //
    
    DnsAddr_SetPort( pDnsAddr, DNS_PORT_NET_ORDER );

    //
    //  test for conversion error
    //
    //  unfortunately, the error code INADDR_NONE also corresponds
    //      to a valid IP address (255.255.255.255), so must test
    //      that that address was not the input to inet_addr()
    //

    if ( DnsAddr_IsClear( pDnsAddr ) &&
         strcmp( szIpAddress, "255.255.255.255" ) != 0 )
    {
        goto BadIpAddress;
    }

    //
    //  valid conversion
    //

    return TRUE;

BadIpAddress:

    if ( pParseInfo )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_IP_ADDRESS_STRING,
            pParseInfo,
            pToken );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
    }
    return FALSE;
}



BOOLEAN
File_ParseDwordToken(
    OUT     PDWORD          pdwOutput,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Get DWORD for token.

Arguments:

    pToken - ptr to token

    pdwOutput - addr to place DWORD result

    pParseInfo - parse context, OPTIONAL;  if given then token MUST parse
        to DWORD, if does not log error

Return Value:

    TRUE -- if successfully parse token into DWORD
    FALSE -- on error

--*/
{
    PCHAR   pch;
    UCHAR   ch;
    DWORD   result = 0;
    PCHAR   pstop;
    int     base = 10;
    int     multiplier = 1;

    ASSERT( pdwOutput != NULL );
    ASSERT( pToken != NULL );

    DNS_DEBUG( READ, (
        "Parse DWORD token %.*s\n",
        pToken->cchLength,
        pToken->pchToken ));

    pch = pToken->pchToken;
    pstop = pToken->pchToken + pToken->cchLength;

    //
    //  If the string starts with "0x", we are working in hex.
    //

    if ( pToken->cchLength > 2 && *pch == '0' && *( pch + 1 ) == 'x' )
    {
        base = 16;
        pch += 2;
    }

    while ( pch < pstop )
    {
        //  turn from char into interger
        //  by using UCHAR, we can use single compare for validity

        if ( base == 10 )
        {
            CHAR    thischar = *pch++;
            
            ch = (UCHAR) ( thischar - '0' );

            if ( thischar == '-' && result == 0 )
            {
                multiplier *= -1;
                continue;
            }
            else if ( ch <= 9 )
            {
                result = result * 10 + ch;
                continue;
            }
        }
        else
        {
            //  Must be hex if base not 10.
            ch = (UCHAR) tolower( *pch++ );

            if ( ch >= 'a' && ch <= 'f' )
            {
                ch = ( ch - 'a' ) + 10;
            }
            else
            {
                ch -= '0';
            }

            if ( ch <= 15 )
            {
                result = result * 16 + ch;
                continue;
            }
        } 

        //  non-integer encountered
        //      - if it is stop char, break for success

        if ( pParseInfo )
        {
            if ( pParseInfo->uchDwordStopChar == ch + '0' )
            {
                break;
            }
            File_LogFileParsingError(
                DNS_EVENT_INVALID_DWORD_TOKEN,
                pParseInfo,
                pToken );
        }
        return FALSE;
    }

    result *= multiplier;
    *pdwOutput = result;
    return TRUE;
}



WORD
parseClassToken(
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Parse class token.

Arguments:

    pToken - ptr to token

    pParseInfo - parse context, OPTIONAL;  if given then log event
        if token parses to unsupported class

Return Value:

    Class (net order) of token if successfully parse token
    0 if unable to recognize token as class token.

--*/
{
    PCHAR   pch = pToken->pchToken;

    if ( !pch || pToken->cchLength != 2 )
    {
        return 0;
    }

    //
    //  parse all known classes, although only accepting Internet
    //

    if ( _strnicmp( pch, "IN", 2 ) == 0 )
    {
        return DNS_RCLASS_INTERNET;
    }

    if ( _strnicmp( pch, "CH", 2 ) == 0 ||
         _strnicmp( pch, "HS", 2 ) == 0 ||
         _strnicmp( pch, "CS", 2 ) == 0 )
    {
        if ( pParseInfo )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_DWORD_TOKEN,
                pParseInfo,
                pToken );
        }
        return 0xffff;
    }

    //  not a class token

    return 0;
}



//
//  File name read utils
//

PDB_NODE
File_CreateNodeFromToken(
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken,
    IN      BOOLEAN         fReference
    )
/*++

Routine Description:

    Expand token for domain name, to full domain name.

Arguments:

    pParseInfo - line information for parsing this file;  beyond domain
        name written to pszBuffer, this may be altered on error

    pToken - ptr to token

    fReference - reference node as create

Return Value:

    Ptr to node if successful.
    NULL on error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countName;
    PDB_NODE        pnode;
    DWORD           lookupFlag;

    //
    //  origin "@" notation, return current origin
    //

    if ( *pToken->pchToken == '@' )
    {
        if ( pToken->cchLength != 1 )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_ORIGIN_TOKEN,
                pParseInfo,
                pToken );
            goto NameErrorExit;
        }
        if ( fReference )
        {
            NTree_ReferenceNode( pParseInfo->pOriginNode );
        }
        return pParseInfo->pOriginNode;
    }

    //
    //  regular name
    //      - convert to lookup name
    //

    status = Name_ConvertFileNameToCountName(
                &countName,
                pToken->pchToken,
                pToken->cchLength );

    if ( status == DNS_STATUS_DOTTED_NAME )
    {
        //pnodeStart = pParseInfo->pOriginNode;
        lookupFlag = LOOKUP_LOAD | LOOKUP_RELATIVE | LOOKUP_ORIGIN;
    }
    else if ( status == DNS_STATUS_FQDN )
    {
        //pnodeStart = NULL;
        lookupFlag = LOOKUP_LOAD | LOOKUP_FQDN;
    }
    else
    {
        goto NameError;
    }

    //
    //  create or reference node
    //

    pnode = Lookup_ZoneNode(
                pParseInfo->pZone,
                countName.RawName,
                NULL,       //  no message
                NULL,       //  no lookup name
                lookupFlag,
                NULL,       //  create
                NULL );     //  following node ptr
    if ( pnode )
    {
        return pnode;
    }
    //  if name create failed, assume invalid name

NameError:

    //
    //  log invalid domain name
    //
    //  the lookup name function, should log the specific type of name error
    //

    File_LogFileParsingError(
        DNS_EVENT_PARSED_INVALID_DOMAIN_NAME,
        pParseInfo,
        pToken );

NameErrorExit:

    pParseInfo->fErrorCode = DNS_ERROR_INVALID_NAME;
    pParseInfo->fErrorEventLogged = TRUE;
    return NULL;
}



DNS_STATUS
File_ReadCountNameFromToken(
    OUT     PCOUNT_NAME     pCountName,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    )
/*++

Routine Description:

    Copies datafile name into counted raw name format.

Arguments:

    pCountName  - result buffer

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_INVALID_NAME on failure.

--*/
{
    DNS_STATUS      status;
    PCOUNT_NAME     poriginCountName;

    DNS_DEBUG( LOOKUP2, (
        "Building count name from file name \"%.*s\"\n",
        pToken->cchLength,
        pToken->pchToken ));

    //
    //  if given zone get it's raw name
    //

    poriginCountName = &pParseInfo->OriginCountName;

    //
    //  origin "@" notation, return current origin
    //

    if ( *pToken->pchToken == '@' )
    {
        if ( pToken->cchLength != 1 )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_ORIGIN_TOKEN,
                pParseInfo,
                pToken );
            goto NameErrorExit;
        }
        if ( poriginCountName )
        {
            Name_CopyCountName(
                pCountName,
                poriginCountName );
        }
        else
        {
            pCountName->Length = 1;
            pCountName->LabelCount = 0;
            pCountName->RawName[0] = 0;
        }
        return ERROR_SUCCESS;
    }

    //
    //  regular name
    //      - must return FQDN or dotted name (meaning non-FQDN)
    //

    status = Name_ConvertFileNameToCountName(
                pCountName,
                pToken->pchToken,
                pToken->cchLength );

    if ( status == DNS_STATUS_DOTTED_NAME )
    {
        //  append raw zone name

        if ( poriginCountName )
        {
            status = Name_AppendCountName(
                        pCountName,
                        poriginCountName );
            if ( status != ERROR_SUCCESS )
            {
                goto NameError;
            }
        }
        return ERROR_SUCCESS;
    }
    else if ( status == DNS_STATUS_FQDN )
    {
        return ERROR_SUCCESS;
    }

    //  if name create failed, assume invalid name

NameError:

    //
    //  log invalid domain name
    //
    //  the lookup name function, should log the specific type of name error
    //

    File_LogFileParsingError(
        DNS_EVENT_PARSED_INVALID_DOMAIN_NAME,
        pParseInfo,
        pToken );

NameErrorExit:

    pParseInfo->fErrorCode = DNS_ERROR_INVALID_NAME;
    pParseInfo->fErrorEventLogged = TRUE;
    return DNS_ERROR_INVALID_NAME;
}



//
//  Directive processing routines
//

DNS_STATUS
processIncludeDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process INCLUDE directive

Arguments:

    pParseInfo - ptr to parsing info for INCLUDE line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       argc;
    PTOKEN      argv;
    DWORD       fileNameLength;
    CHAR        szfilename[ MAX_PATH ];
    WCHAR       wideFileName[ MAX_PATH ];
    PDB_NODE    pnodeOrigin;

    //
    //  $INCLUDE [orgin] <file>
    //

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    if ( argc < 2 || argc > 3 )
    {
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( argc, argv );

    //
    //  determine origin for included file
    //      - if none given use current origin

    if ( argc == 2 )
    {
        pnodeOrigin = File_CreateNodeFromToken(
                        pParseInfo,
                        argv,
                        FALSE );
        if ( !pnodeOrigin )
        {
            return DNSSRV_PARSING_ERROR;
        }
        NEXT_TOKEN( argc, argv );
    }
    else
    {
        pnodeOrigin = pParseInfo->pOriginNode;
    }

    //
    //  read include filename
    //      - convert to unicode
    //

    ASSERT( MAX_PATH >= MAX_TOKEN_LENGTH );

    if ( !File_MakeTokenString(
            szfilename,
            argv,
            pParseInfo ) )
    {
        return DNSSRV_PARSING_ERROR;
    }
    DNS_DEBUG( INIT2 ,(
        "Reading $INCLUDE filename %s\n",
        szfilename ));

    fileNameLength = MAX_PATH;

    if ( ! Dns_StringCopy(
                (PCHAR) wideFileName,
                & fileNameLength,
                szfilename,
                0,
                DnsCharSetAnsi,
                DnsCharSetUnicode ) )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //
    //  process included file
    //
    //  DEVNOTE: INCLUDE error handling might need some work
    //

    status = File_LoadDatabaseFile(
                pParseInfo->pZone,
                wideFileName,
                pParseInfo,
                pnodeOrigin );

    //
    //  restore zone origin
    //      - although origin ptr is in parseinfo block, effective ptr during lookup is
    //          the one in the zone info struct
    //      - effective origin count name is the one in parse info block which
    //          is stack data of caller and unaffected by call
    //

    pParseInfo->pZone->pLoadOrigin = pParseInfo->pOriginNode;

    return status;
}



DNS_STATUS
processOriginDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process ORIGIN directive

Arguments:

    pParseInfo - ptr to parsing info for ORIGIN line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NODE    pnodeOrigin;

    //
    //  $ORIGIN <new orgin>
    //

    DNS_DEBUG( INIT2, ( "processOriginDirective()\n" ));

    if ( pParseInfo->Argc != 2 )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //  determine new origin
    //  new origin written to stack as need previous origin during create

    pnodeOrigin = File_CreateNodeFromToken(
                    pParseInfo,
                    & pParseInfo->Argv[1],
                    FALSE );                //  no reference
    if ( !pnodeOrigin )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //  save origin to parseinfo
    //  "active" origin used in lookup is in zone block

    pParseInfo->pOriginNode = pnodeOrigin;
    pParseInfo->pZone->pLoadOrigin = pnodeOrigin;

    //  make origin counted name for RR data fields

    Name_NodeToCountName(
        & pParseInfo->OriginCountName,
        pnodeOrigin );

    IF_DEBUG( INIT2 )
    {
        DNS_PRINT((
            "Loaded new $ORIGIN %.*s\n",
            pParseInfo->Argv[1].cchLength,
            pParseInfo->Argv[1].pchToken ));
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
processTtlDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process TTL directive (see RFC 2308 section 4)

Arguments:

    pParseInfo - ptr to parsing info for ORIGIN line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DBG_FN( "processTtlDirective" )

    INT     ttl = -1;
    CHAR    sz[ 20 ];

    //
    //  $TTL <ttl> - if no TTL revert to default
    //

    DNS_DEBUG( INIT2, ( "%s()\n", fn ));

    if ( pParseInfo->Argc == 1 )
    {
        pParseInfo->dwTtlDirective = pParseInfo->dwDefaultTtl;
        DNS_DEBUG( INIT2, (
            "%s: reverting to original default TTL = %d", fn,
            ntohl( pParseInfo->dwTtlDirective ) ));
        return ERROR_SUCCESS;
    }

    if ( pParseInfo->Argc != 2 )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //  determine new default TTL

    if ( pParseInfo->Argv[ 1 ].pchToken &&
        pParseInfo->Argv[ 1 ].cchLength &&
        pParseInfo->Argv[ 1 ].cchLength < sizeof( sz ) )
    {
        strncpy(
            sz,
            pParseInfo->Argv[ 1 ].pchToken,
            pParseInfo->Argv[ 1 ].cchLength );
        sz[ pParseInfo->Argv[ 1 ].cchLength ] = '\0';
        ttl = atoi( sz );
    }

    if ( ttl <= 0 )
    {
        return DNSSRV_PARSING_ERROR;
    }

    pParseInfo->dwTtlDirective = htonl( ttl );

    DNS_DEBUG( INIT2, (
        "%s: new default TTL = %d", fn, pParseInfo->dwTtlDirective ));
    return ERROR_SUCCESS;
}



//
//  Main zone file load routines
//

DNS_STATUS
processFileLine(
    IN OUT  PPARSE_INFO  pParseInfo
    )
/*++

Routine Description:

    Add info from database file line, to database.

Arguments:

    pParseInfo - ptr to database line

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/
{
    DWORD           argc;
    PTOKEN          argv;
    PDB_RECORD      prr = NULL;
    WORD            type = 0;
    WORD            parsedClass;
    DWORD           ttl;
    DWORD           timeStamp = 0;
    PCHAR           pch;
    CHAR            ch;
    BOOL            fparsedTtl;
    BOOL            fatalError = FALSE;
    PDB_NODE        pnodeOwner;
    PZONE_INFO      pzone = pParseInfo->pZone;
    DNS_STATUS      status = ERROR_SUCCESS;
    RR_FILE_READ_FUNCTION   preadFunction;


    //  get register arg variables

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    ASSERT( argc > 0 );

    //  clear parse info RR ptr, to simplify failure cleanup
    //      - this allows cleanup of RRs allocated in dispatch functions
    //      without having to take care of failures in every function

    pParseInfo->pRR = NULL;

    //
    //  check for directive line
    //

    pch = argv->pchToken;

    if ( !pParseInfo->fLeadingWhitespace &&
        *pch == DIRECTIVE_CHAR )
    {
        DWORD   cch = argv->cchLength;

        if ( cch == 7  &&
             _strnicmp( pch, "$ORIGIN", 7 ) == 0 )
        {
            return processOriginDirective( pParseInfo );
        }
        else if ( cch == 8  &&
             _strnicmp( pch, "$INCLUDE", 8 ) == 0 )
        {
            return processIncludeDirective( pParseInfo );
        }
        else if ( cch = 4 &&
             _strnicmp( pch, "$TTL", 4 ) == 0 )
        {
            return processTtlDirective( pParseInfo );
        }
        else
        {
            File_LogFileParsingError(
                DNS_EVENT_UNKNOWN_DIRECTIVE,
                pParseInfo,
                argv );
            goto ErrorReturn;
        }
    }

    //
    //  get RR owner name
    //
    //  - if same as previous name, jsut grab pointer
    //  - mark all nodes NEW to verify zone to id nodes in zone,
    //      for validity check after load
    //

    if ( pParseInfo->fLeadingWhitespace )
    {
        pnodeOwner = pParseInfo->pnodeOwner;
        if ( !pnodeOwner )
        {
            //  possible if first record has leading white space, just
            //  use origin and continue

            pnodeOwner = pParseInfo->pOriginNode;
            pParseInfo->pnodeOwner = pnodeOwner;
            ASSERT( pnodeOwner );
        }
    }
    else
    {
        pnodeOwner = File_CreateNodeFromToken(
                        pParseInfo,
                        argv,
                        FALSE );        //  no reference
        if ( pnodeOwner == NULL )
        {
            status = DNS_ERROR_INVALID_NAME;
            goto ErrorReturn;
        }
        pParseInfo->pnodeOwner = pnodeOwner;
        NEXT_TOKEN( argc, argv );
    }
    if ( argc == 0 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto LogLineError;
    }
    ASSERT( argv && argv->pchToken );

    //
    //  aging time stamp?
    //      [AGE:<time stamp>] is format
    //

    ch = argv->pchToken[0];

    if ( ch == '['  &&
        argv->cchLength > AGING_TOKEN_HEADER_LENGTH  &&
        strncmp( AGING_TOKEN_HEADER, argv->pchToken, AGING_TOKEN_HEADER_LENGTH ) == 0 )
    {
        //  parse aging timestamp as DWORD
        //      - "fix" token to point at aging timestamp
        //      - set DWORD parsing stop char

        argv->cchLength -= AGING_TOKEN_HEADER_LENGTH;
        argv->pchToken += AGING_TOKEN_HEADER_LENGTH;

        pParseInfo->uchDwordStopChar = ']';

        if ( ! File_ParseDwordToken(
                    & timeStamp,
                    argv,
                    pParseInfo ) )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  error reading aging timestamp!\n" ));
            goto LogLineError;
        }
        pParseInfo->uchDwordStopChar = 0;

        NEXT_TOKEN( argc, argv );
    }

    //
    //  TTL / class
    //  the RFC allows TTL and class to be presented in either order
    //  therefore we loop twice to make sure we read them in either order
    //

    fparsedTtl = FALSE;
    parsedClass = 0;

    while ( argc )
    {
        ch = argv->pchToken[0];

        //  first character digit means reading TTL

        if ( !fparsedTtl && ( isdigit( ch ) || ch == '-' ) )
        {
            if ( !File_ParseDwordToken(
                        &ttl,
                        argv,
                        pParseInfo ) )
            {
                goto LogLineError;
            }
            fparsedTtl = TRUE;
            NEXT_TOKEN( argc, argv );
            continue;
        }
        else if ( !parsedClass )
        {
            parsedClass = parseClassToken(
                                argv,
                                pParseInfo );
            if ( !parsedClass )
            {
                break;
            }
            if ( parsedClass != DNS_RCLASS_INTERNET )
            {
                goto LogLineError;
            }
            NEXT_TOKEN( argc, argv );
            continue;
        }
        break;          //  if NOT TTL or class move on
    }
    if ( argc == 0 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto LogLineError;
    }

    //
    //  get RR type and datalength
    //      - save to parse info blob, as within some dispatch functions
    //      type may need to be discriminated
    //

    type = DnsRecordTypeForName(
                argv->pchToken,
                argv->cchLength );

    pParseInfo->wType = type;

    DNS_DEBUG( INIT2, (
        "Creating RR type %d for string %.*s\n",
        type,
        argv->cchLength,
        argv->pchToken ));

    NEXT_TOKEN( argc, argv );

    //
    //  type validity
    //      - zone must start with SOA

    if ( !pParseInfo->fParsedSoa
        && type != DNS_TYPE_SOA
        && !IS_ZONE_CACHE(pzone) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_SOA_RECORD,
            pParseInfo,
            NULL );
        fatalError = TRUE;
        status = DNSSRV_PARSING_ERROR;
        goto ErrorReturn;
    }

    //
    //  check valid zone name
    //
    //  only two types of RR valid outside of zone:
    //
    //  1) NS records delegating a sub-zone
    //      these MUST be immediate child of zone node
    //
    //  2) GLUE records -- A records for valid NS host
    //      we'll assume these MUST FOLLOW NS record, so that
    //      host is marked
    //
    //  note:  RANK reset in RR_AddToNode() function
    //
    //  note rank setting here isn't good enough anyway because do not
    //  know final status of node;  example adding delegation NS takes
    //  place INSIDE the zone when we first do it;  only on ADD does
    //  the node become desired delegation node
    //
    //  only sure way of catching all outside zone data is to do a check
    //  post-load;  then we can catch ALL records outside the zone and verify
    //  that they correspond to NS hosts in the zone and are of the proper type;
    //  this is tedious and unnecessary as random outside the zone data has
    //  no effect and will not be written on file write back
    //

    if ( !IS_AUTH_NODE(pnodeOwner) && !IS_ZONE_CACHE(pzone) )
    {
        IF_DEBUG( INIT2 )
        {
            DNS_PRINT((
                "Encountered node outside zone %s (%p)\n"
                "    zone root        = %p\n"
                "    RR type          = %d\n"
                "    node ptr         = %p\n"
                "    node zone ptr    = %p\n",
                pzone->pszZoneName,
                pzone,
                pzone->pZoneRoot,
                type,
                pnodeOwner,
                pnodeOwner->pZone ));
        }

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_DELEGATION_NODE(pnodeOwner) )
            {
                File_LogFileParsingError(
                    DNS_EVENT_FILE_INVALID_NS_NODE,
                    pParseInfo,
                    NULL );
                status = DNS_ERROR_INVALID_NAME;
                goto ErrorReturn;
            }
        }
        else if ( IS_SUBZONE_TYPE(type) )
        {
#if 0
            //  DEVNOTE: loading outside zone glue
            //      allow outside zone glue to load,
            //          this will not be used EXCEPT to chase delegations
            //
            //  open question:
            //      should limit to chasing => set RANK as ROOT_HINT
            //          OR
            //      allow to use to write referral also => rank stays as GLUE
            //
            //  if choose to discriminate, then need to distinguish OUTSIDE
            //  data from DELEGATION data
            //

            //  verify records in subzone

            if ( IS_OUTSIDE_ZONE_NODE(pnodeOwner) )
            {
                File_LogFileParsingError(
                    DNS_EVENT_FILE_INVALID_A_NODE,
                    pParseInfo,
                    NULL );
                status = DNS_ERROR_INVALID_NAME;
                goto ErrorReturn;
            }
            ASSERT( IS_SUBZONE_NODE(pnodeOwner) );
#endif
        }
        else if ( SrvCfg_fDeleteOutsideGlue )
        {
            File_LogFileParsingError(
                DNS_EVENT_FILE_NODE_OUTSIDE_ZONE,
                pParseInfo,
                NULL );
            status = DNS_ERROR_INVALID_NAME;
            goto ErrorReturn;
        }
    }

    //
    //  dispatching parsing function for desired type
    //
    //      - save type for potential use by type's routine
    //      - save ptr to RR, so can restore from this location
    //      regardless of whether created here or in routine
    //

    preadFunction = ( RR_FILE_READ_FUNCTION )
                        RR_DispatchFunctionForType(
                            RRFileReadTable,
                            type );
    if ( !preadFunction )
    {
        DNS_PRINT((
            "ERROR:  Unsupported RR %d in database file\n",
            type ));
        File_LogFileParsingError(
            DNS_EVENT_UNKNOWN_RESOURCE_RECORD_TYPE,
            pParseInfo,
            --argv );
        status = DNSSRV_ERROR_INVALID_TOKEN;
        goto ErrorReturn;
    }

    status = preadFunction(
                prr,
                argc,
                argv,
                pParseInfo );
    if ( status != ERROR_SUCCESS )
    {
        //  catch LOCAL WINS\WINS-R condition
        //  not an error, error code simply prevents record from being
        //  added to database;  set ZONE_TTL so write back suppresses TTL

        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            return ERROR_SUCCESS;
        }

        DNS_PRINT((
            "ERROR:  DnsFileRead routine failed for type %d.\n\n\n",
            type ));
        goto LogLineError;
    }

    //
    //  recover ptr to type -- may have been created inside type routine
    //  set type
    //

    prr = pParseInfo->pRR;
    prr->wType = type;

    Mem_ResetTag( prr, MEMTAG_RECORD_FILE );

    //
    //  authoritative zones
    //  - set zone version on node
    //  - set TTL
    //      - to explicit value, if given
    //      - otherwise to default value for zone
    //
    //  note, doing these AFTER RR type setup, so SOA record gets
    //      default TTL that it contains
    //
    //  rank is set in RR_AddToNode()
    //  root hint TTL is zeroed in RR_AddToNode()
    //

    if ( IS_ZONE_AUTHORITATIVE(pzone) )
    {
        //pnodeOwner->dwWrittenVersion = pzone->dwSerialNo;
        if ( fparsedTtl )
        {
            prr->dwTtlSeconds = htonl( ttl );
            if ( prr->dwTtlSeconds == ( DWORD ) -1 )
            {
                if ( pParseInfo->dwTtlDirective == pParseInfo->dwDefaultTtl )
                {
                    SET_ZONE_TTL_RR( prr );
                }
                prr->dwTtlSeconds = pParseInfo->dwTtlDirective;
            }
            else
            {
                SET_FIXED_TTL_RR( prr );
            }
        }
        else
        {
            prr->dwTtlSeconds = pParseInfo->dwTtlDirective;
            if ( pParseInfo->dwTtlDirective == pParseInfo->dwDefaultTtl )
            {
                SET_ZONE_TTL_RR( prr );
            }
        }
    }

    //
    //  set aging timestamp
    //      - will be zero unless parsed above
    //

    prr->dwTimeStamp = timeStamp;

    //
    //  add resource record to node's RR list
    //

    status = RR_AddToNode(
                pzone,
                pnodeOwner,
                prr );
    if ( status != ERROR_SUCCESS )
    {
        switch ( status )
        {
            //
            //  DEVNOTE-DCR: 453961 - handling duplicate RRs
            //      - want to load if dup in zone file (switch TTL)
            //      - don't want to load dupes because of glue + zone record
            //
            //  Also should get smart about TTL on glue -- zone TTL should be
            //      used.
            //

            case DNS_ERROR_RECORD_ALREADY_EXISTS:
                RR_Free( prr );
                return ERROR_SUCCESS;

            //
            //  CNAMEs can NOT have other RR data or loops
            //

            case DNS_ERROR_NODE_IS_CNAME:
                File_LogFileParsingError(
                    DNS_EVENT_PARSED_ADD_RR_AT_CNAME,
                    pParseInfo,
                    NULL );
                goto ErrorReturn;

            case DNS_ERROR_CNAME_COLLISION:
                File_LogFileParsingError(
                    DNS_EVENT_PARSED_CNAME_NOT_ALONE,
                    pParseInfo,
                    NULL );
                goto ErrorReturn;

            case DNS_ERROR_CNAME_LOOP:
                File_LogFileParsingError(
                    DNS_EVENT_PARSED_CNAME_LOOP,
                    pParseInfo,
                    NULL );
                goto ErrorReturn;

            default:

                // WINS\WINSR postioning failures may drop here
                DNS_PRINT((
                    "ERROR:  UNKNOWN status %p from RR_Add\n",
                    status ));
                //ASSERT( FALSE );
                goto LogLineError;
        }
    }

    //  track size of zone

    pzone->iRRCount++;
    return ERROR_SUCCESS;


LogLineError:

    //  if no specific error, return general parsing error

    if ( status == ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
    }

    DNS_PRINT((
        "ERROR parsing line, type = %d, status = %p.\n\n\n",
        type,
        status ));

    switch ( status )
    {
        case DNSSRV_ERROR_EXCESS_TOKEN:

            argc = pParseInfo->Argc - 1;
            File_LogFileParsingError(
                DNS_EVENT_UNEXPECTED_TOKEN,
                pParseInfo,
                & pParseInfo->Argv[argc] );
            break;

        case DNSSRV_ERROR_MISSING_TOKEN:

            File_LogFileParsingError(
                DNS_EVENT_UNEXPECTED_END_OF_TOKENS,
                pParseInfo,
                NULL );
            break;

        default:

            if ( type == DNS_TYPE_WINS )
            {
                File_LogFileParsingError(
                    DNS_EVENT_INVALID_WINS_RECORD,
                    pParseInfo,
                    NULL );
            }
            else if ( type == DNS_TYPE_WINSR )
            {
                File_LogFileParsingError(
                    DNS_EVENT_INVALID_NBSTAT_RECORD,
                    pParseInfo,
                    NULL );
            }
            else
            {
                File_LogFileParsingError(
                    DNS_EVENT_PARSING_ERROR_LINE,
                    pParseInfo,
                    NULL );
            }
            break;
    }

ErrorReturn:

    //
    //  if strict load, then quit with error
    //  otherwise log error noting location of ignored record
    //

    ASSERT( status != ERROR_SUCCESS );

    if ( pParseInfo->pRR )
    {
        RR_Free( pParseInfo->pRR );
    }

    if ( !fatalError  &&  !SrvCfg_fStrictFileParsing )
    {
        File_LogFileParsingError(
            DNS_EVENT_IGNORING_FILE_RECORD,
            pParseInfo,
            NULL );
        status = ERROR_SUCCESS;
    }
    return status;
}



DNS_STATUS
File_LoadDatabaseFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsFileName,
    IN      PPARSE_INFO     pParentParseInfo,
    IN      PDB_NODE        pOriginNode
    )
/*++

Routine Description:

    Read database file into database.

Arguments:

    pZone - info on database file and domain

    pwsFileName - file to open

    pParentParseInfo - parent parsing context, if loading included file;  NULL
        for base zone file load

    pOriginNode - origin other than zone root;  NULL for base zone file load,
        MUST be set to origin of $INCLUDE when include file load

Return Value:

    ERROR_SUCCESS if successful
    Error code on error.

--*/
{
    DWORD           status;
    BOOL            bmustFind;
    MAPPED_FILE     mfDatabaseFile;
    PARSE_INFO      ParseInfo;
    WCHAR           wsfileName[ MAX_PATH+1 ];
    WCHAR           wspassedFileName[ MAX_PATH+1 ];


    DNS_DEBUG( INIT, (
        "\n\nFile_LoadDatabaseFile %S\n",
        pwsFileName ));

    //
    //  service starting checkpoint
    //  indicate checkpoint for each file we load;  this protects against
    //  failure if attempting to load a large number of files
    //

    Service_LoadCheckpoint();

    //
    //  init parsing info
    //  file name
    //      - default to zone's if none specified
    //      - save filename for logging problems
    //

    RtlZeroMemory( &ParseInfo, sizeof(PARSE_INFO) );

    if ( !pwsFileName )
    {
        pwsFileName = pZone->pwsDataFile;
    }
    ParseInfo.pwsFileName = pwsFileName;

    //
    //  origin
    //      - if given => included file
    //      for included file, set SOA-parsed flag from parent context
    //      - otherwise use zone root
    //

    if ( pOriginNode )
    {
        ParseInfo.pOriginNode = pOriginNode;
        ParseInfo.fParsedSoa  = pParentParseInfo->fParsedSoa;
    }
    else
    {
        ParseInfo.pOriginNode = pZone->pLoadZoneRoot;
    }

    //
    //  "active" origin is pLoadOrigin in zone block
    //   created count name version for appending to non-FQDN RR data
    //

    pZone->pLoadOrigin = ParseInfo.pOriginNode;

    Name_NodeToCountName(
        & ParseInfo.OriginCountName,
        ParseInfo.pOriginNode );


    //
    //  create file path
    //      - combine directory and file name

    if ( ! File_CreateDatabaseFilePath(
                wsfileName,
                NULL,
                pwsFileName ) )
    {
        ASSERT( FALSE );        // should have been caught in parsing
        return( DNS_ERROR_INVALID_DATAFILE_NAME );
    }
    DNS_DEBUG( INIT, (
        "Reading database file %S:\n",
        wsfileName ));

    //
    //  Open database file
    //
    //  file MUST be present if
    //      - included
    //      - loading non-secondary at startup
    //      secondary loading at startup, just stays shutdown until XFR
    //      primary created from admin creates default records if no file found
    //

    bmustFind = pOriginNode || (!SrvCfg_fStarted && !IS_ZONE_SECONDARY(pZone));

    status = OpenAndMapFileForReadW(
                wsfileName,
                & mfDatabaseFile,
                bmustFind );
    if ( status != ERROR_SUCCESS )
    {
        PVOID   parg = wsfileName;

        DNS_DEBUG( INIT, (
            "Could not open data file %S\n",
            wsfileName ));

        if ( status == ERROR_FILE_NOT_FOUND && !bmustFind )
        {
            ASSERT( IS_ZONE_CACHE(pZone) || IS_ZONE_SHUTDOWN(pZone) );

            if ( IS_ZONE_SECONDARY(pZone) )
            {
                DNS_DEBUG( INIT, (
                    "Zone %S datafile %S not found\n"
                    "    Secondary starts shutdown until transfer\n",
                    pZone->pwsZoneName,
                    wsfileName ));
                return ERROR_SUCCESS;
            }
            else    // new zone from admin
            {
                DNS_DEBUG( INIT, (
                    "Zone %S datafile %S not found\n"
                    "    Loading new zone from admin\n",
                    pZone->pwsZoneName,
                    wsfileName ));
                return status;
            }
        }
        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_OPEN_DATABASE,
            1,
            & parg,
            NULL,
            GetLastError() );
        return status;
    }

    //
    //  setup parsing info
    //

    ParseInfo.cLineNumber    = 0;
    ParseInfo.pZone          = pZone;
    ParseInfo.fTerminalError = FALSE;

    File_InitBuffer(
        &ParseInfo.Buffer,
        (PCHAR) mfDatabaseFile.pvFileData,
        mfDatabaseFile.cbFileBytes );

    //
    //  check for UTF8 file byte id at beginning of file
    //

    if ( RtlEqualMemory(
            mfDatabaseFile.pvFileData,
            UTF8_FILE_ID,
            UTF8_FILE_ID_LENGTH ) )
    {
        DNS_DEBUG( INIT, (
            "Loading UTF8 file for zone %S\n"
            "    skipping UTF8 file id bytes\n",
            pZone->pwsZoneName ));

        File_InitBuffer(
            &ParseInfo.Buffer,
            (PCHAR) mfDatabaseFile.pvFileData + UTF8_FILE_ID_LENGTH,
            mfDatabaseFile.cbFileBytes - UTF8_FILE_ID_LENGTH );
    }

    //
    //  loop until all tokens in file are exhausted
    //

    while ( 1 )
    {
        DNS_DEBUG( INIT2, ( "\nLine %d: ", ParseInfo.cLineNumber ));

        //  get next tokenized line

        status = File_GetNextLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_NO_TOKEN )
            {
                break;
            }
            goto fail_return;
        }

        //  do service starting checkpoint, every 1K lines
        //  this protects against service startup failure, attempting
        //  to load a really big database

        if ( ! (ParseInfo.cLineNumber & 0x3ff) )
        {
            Service_LoadCheckpoint();
        }

        //
        //  process file line
        //

        status = processFileLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto fail_return;
        }

    }   //  loop until file read

    DNS_DEBUG( INIT, (
        "Closing database file %S.\n\n",
        pwsFileName ));

    CloseMappedFile( & mfDatabaseFile );
    return ERROR_SUCCESS;

fail_return:

    DNS_DEBUG( INIT, (
        "Closing database file %S on failure.\n\n",
        pwsFileName ));

    CloseMappedFile( &mfDatabaseFile );
    {
        PVOID   apszArgs[2];

        apszArgs[0] = pwsFileName;
        apszArgs[1] = pZone->pwsZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_PARSE_DATABASE,
            2,
            apszArgs,
            NULL,
            0 );
    }
    return status;
}

//
//  End dfread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dnsprocs.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    dnsprocs.h

Abstract:

    Domain Name System (DNS) Server

    Procedure protypes for DNS service.

Author:

    Jim Gilroy      June 1995

Revision History:

--*/


#ifndef _DNSPROC_INCLUDED_
#define _DNSPROC_INCLUDED_



//
//  Milliseconds time
//

#define GetCurrentTimeInMilliSeconds()  GetCurrentTime()


//
//  Aging \ Timestamps (aging.c)
//

LONGLONG
GetSystemTimeInSeconds64(
    VOID
    );

DWORD
GetSystemTimeHours(
    VOID
    );

DWORD
Aging_UpdateAgingTime(
    VOID
    );

VOID
Aging_TimeStampRRSet(
    IN OUT  PDB_RECORD      pRRSet,
    IN      DWORD           dwFlag
    );

DWORD
Aging_InitZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
Scavenge_Initialize(
    VOID
    );

VOID
Scavenge_Cleanup(
    VOID
    );

DNS_STATUS
Scavenge_CheckForAndStart(
    IN      BOOL            fForce
    );

DNS_STATUS
Scavenge_TimeReset(
    VOID
    );

DNS_STATUS
Tombstone_Initialize(
    VOID
    );

VOID
Tombstone_Cleanup(
    VOID
    );

DNS_STATUS
Tombstone_Trigger(
    VOID
    );

DNS_STATUS
Aging_ForceAgingOnNodeOrSubtree(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fAgeSubtree
    );

//
//  Answering (answer.c)
//

VOID
FASTCALL
Answer_ProcessMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
FASTCALL
Answer_Question(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
FASTCALL
Answer_QuestionFromDatabase(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset,
    IN      WORD            wQueryType
    );

BOOL
Answer_QuestionWithWildcard(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wOffset
    );

VOID
Answer_ContinueCurrentLookupForQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Answer_ContinueNextLookupForQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
FASTCALL
Answer_SaveAdditionalRecordsInfo(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Answer_TkeyQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    );

WORD
Answer_ParseAndStripOpt(
    IN OUT  PDNS_MSGINFO    pMsg );


//
//  Booting (boot.c)
//

DNS_STATUS
Boot_LoadDatabase(
    VOID
    );

DNS_STATUS
Boot_FromRegistry(
    VOID
    );

DNS_STATUS
Boot_FromRegistryNoZones(
    VOID
    );

DNS_STATUS
Boot_ProcessRegistryAfterAlternativeLoad(
    IN      BOOL            fBootFile,
    IN      BOOL            fLoadRegZones
    );


//
//  Client routines (client.c)
//

PDNS_MSGINFO
Msg_CreateSendMessage(
    IN      DWORD           dwBufferLength
    );

BOOL
FASTCALL
Msg_WriteQuestion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

BOOL
Msg_MakeTcpConnection(
    IN      PDNS_MSGINFO    pMsg,
    IN      PDNS_ADDR       ipServer,
    IN      PDNS_ADDR       ipBind,
    IN      DWORD           Flags
    );

BOOL
Msg_ValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    );

BOOL
Msg_NewValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    );


//
//  DS (ds.c)
//

//  DS Open flags

#define DNSDS_MUST_OPEN         (0x00001000)
#define DNSDS_WAIT_FOR_DS       (0x00002000)
#define DNSDS_REQUIRE_OPEN      (0x00003000)

//  Flag indicating operation on node write

#define DNSDS_ADD               (0x00000001)
#define DNSDS_REPLACE           (0x00000002)
#define DNSDS_TOMBSTONE         (0x00000004)

//  Record format versioning

#define DS_NT5_BETA2_RECORD_VERSION     (1)
#define DS_NT5_RECORD_VERSION           (5)

//  Property IDs (note: these are IDs, not bitmasks)

#define DSPROPERTY_ZONE_TYPE                    0x00000001
#define DSPROPERTY_ZONE_ALLOW_UPDATE            0x00000002
#define DSPROPERTY_ZONE_SECONDARIES             0x00000004
#define DSPROPERTY_ZONE_SECURE_TIME             0x00000008
#define DSPROPERTY_ZONE_NOREFRESH_INTERVAL      0x00000010
#define DSPROPERTY_ZONE_REFRESH_INTERVAL        0x00000020
#define DSPROPERTY_ZONE_AGING_STATE             0x00000040
#define DSPROPERTY_ZONE_SCAVENGING_SERVERS      0x00000011
#define DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME   0x00000080
#define DSPROPERTY_ZONE_MASTER_SERVERS          0x00000081
#define DSPROPERTY_ZONE_AUTO_NS_SERVERS         0x00000082
#define DSPROPERTY_ZONE_DCPROMO_CONVERT         0x00000083

// Flags used to write node properties

#define DSPROPERTY_NODE_DBFLAGS         0x00000100

VOID
Ds_StartupInit(
    VOID
    );

#define DNS_DS_OPT_FORCE_KERBEROS       0x0001
#define DNS_DS_OPT_ALLOW_DELEGATION     0x0002

PLDAP
Ds_Connect(
    IN      LPCWSTR         pszServer,
    IN      DWORD           dwFlags,
    OUT     DNS_STATUS *    pStatus
    );

DNS_STATUS
Ds_OpenServer(
    IN      DWORD           dwFlag
    );

VOID
Ds_Shutdown(
    VOID
    );

DNS_STATUS
Ds_OpenServerForSecureUpdate(
    OUT     PLDAP *         ppLdap
    );

DNS_STATUS
Ds_CloseServerAfterSecureUpdate(
    IN OUT  PLDAP *          ppLdap
    );

DNS_STATUS
Ds_BootFromDs(
    IN      DWORD           dwFlag
    );

DNS_STATUS
Ds_OpenZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_CloseZone(
    IN OUT  PZONE_INFO      pZone
    );

#define DNS_ADDZONE_WRITESD     0x00000001

DNS_STATUS
Ds_AddZone(
    IN      PLDAP           pLdap,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlags
    );

#define DNS_DS_DEL_IMPERSONATING    ZONE_CREATE_IMPERSONATING

DNS_STATUS
Ds_DeleteZone(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlags
    );

DNS_STATUS
Ds_TombstoneZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_LoadZoneFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    );

DNS_STATUS
Ds_ReadNodeRecords(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN OUT  PDB_RECORD *    ppRecords,
    IN      PVOID           pSearchBlob
    );

DNS_STATUS
Ds_WriteZoneToDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    );

VOID
Ds_CheckForAndForceSerialWrite(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwCause,
    IN      BOOL            fForce
    );

DNS_STATUS
Ds_WriteNodeToDs(
    IN      PLDAP           pLdapHandle,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwOperation,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    );

DNS_STATUS
Ds_WriteNodeSecurityToDs(
    IN      PZONE_INFO              pZone,
    IN      PDB_NODE                pNode,
    IN      PSECURITY_DESCRIPTOR    pSD
    );

DNS_STATUS
Ds_WriteNodeProperties(
    IN      PDB_NODE      pNode,
    IN      DWORD         dwPropertyFlag
    );


DNS_STATUS
Ds_WriteUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_WriteNonSecureUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_ZonePollAndUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fForce
    );

DNS_STATUS
Ds_UpdateNodeListFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pTempNodeList
    );

DNS_STATUS
Ds_WriteZoneProperties(
    IN      PLDAP           pLdap,
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Ds_UpdateZoneProperties(
    IN      PZONE_INFO      pZone,
    IN      BOOL            bWrite
    );

DNS_STATUS
Ds_RegisterSpnDnsServer(
    IN      PLDAP           ld
    );

BOOL
Ds_IsDsServer(
    VOID
    );


DNS_STATUS
Ds_WriteDnSecurity(
    IN   PLDAP                   ld,
    IN   LPWSTR                  dn,
    IN   PSECURITY_DESCRIPTOR    pSD,
    IN   BOOL                    fRewriteOwner
    );

DNS_STATUS
Ds_AddPrincipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwsDN,
    IN      PSID            pSid,        OPTIONAL
    IN      LPTSTR          pwszName,    OPTIONAL
    IN      DWORD           AccessMask,
    IN      DWORD           AceFlags,    OPTIONAL
    IN      BOOL            bWhackExistingAce,
    IN      BOOL            bTakeOwnership
    );

DNS_STATUS
Ds_RemovePrincipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDN,
    IN      PWSTR           pwszName,   OPTIONAL
    IN      PSID            pSid        OPTIONAL
    );

DNS_STATUS
Ds_CommitAsyncRequest (
    IN      PLDAP           pLdap,
    IN      ULONG           opType,
    IN      ULONG           id,
    IN      PLDAP_TIMEVAL   pTimeout    OPTIONAL
    );

DNS_STATUS
Ds_DeleteDn(
    IN      PLDAP       pldap,
    IN      LPWSTR      wdn,
    IN      BOOL        bSubtree
    );

DNS_STATUS
Ds_ListenAndAddNewZones(
    VOID
    );

#define DNS_DS_NO_EVENTS        0x0001

DNS_STATUS
Ds_ErrorHandler(
    IN      DWORD       LdapStatus,
    IN      LPWSTR      pwszNameArg,    OPTIONAL
    IN      PLDAP       pLdap,          OPTIONAL
    IN      DWORD       dwFlags         OPTIONAL
    );

DNS_STATUS
Ds_WaitForStartup(
    IN      DWORD           dwMilliSeconds
    );

DNS_STATUS
Ds_TestAndReconnect(
    VOID
    );

DNS_STATUS
Ds_PollingThread(
    IN      LPVOID          pvDummy
    );

PSECURITY_DESCRIPTOR *
Ds_ReadSD(
    PLDAP                   LdapSession,
    PLDAPMessage            pLdapMsg
    );


//
//  DS Record read (rrds.c)
//

PDB_RECORD
Ds_CreateRecordFromDsRecord(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN      PDS_RECORD      pDsRecord
    );


//
//  Eventlog (eventlog.c)
//

#define EVENTARG_FORMATTED      (0)
#define EVENTARG_UNICODE        (1)
#define EVENTARG_ANSI           (2)
#define EVENTARG_UTF8           (3)
#define EVENTARG_DWORD          (4)
#define EVENTARG_IP_ADDRESS     (5)
#define EVENTARG_LOOKUP_NAME    (6)

#define EVENTARG_ALL_UNICODE        ((PVOID) EVENTARG_UNICODE)
#define EVENTARG_ALL_UTF8           ((PVOID) EVENTARG_UTF8)
#define EVENTARG_ALL_ANSI           ((PVOID) EVENTARG_ANSI)
#define EVENTARG_ALL_DWORD          ((PVOID) EVENTARG_DWORD)
#define EVENTARG_ALL_IP_ADDRESS     ((PVOID) EVENTARG_IP_ADDRESS)

#define DNS_EVENT_MAX_RAW_DATA  (128)


BOOL
Eventlog_CheckPreviousInitialize(
    VOID
    );

INT
Eventlog_Initialize(
    VOID
    );

VOID
Eventlog_Terminate(
    VOID
    );

#define DNSEVENTLOG_DONT_SUPPRESS       0x0001
#define DNSEVENTLOG_FORCE_LOG_ALWAYS    0x0002      //  ignore all config and suppression

BOOL
Eventlog_LogEvent(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      DWORD           EventId,
    IN      DWORD           dwFlags,            //  DNSEVENTLOG_XXX flags
    IN      WORD            ArgCount,
    IN      PVOID           ArgArray[],
    IN      BYTE            ArgTypeArray[],     OPTIONAL
    IN      DWORD           ErrorCode,          OPTIONAL
    IN      DWORD           RawDataSize,        OPTIONAL
    IN      PVOID           pRawData            OPTIONAL
    );

VOID
EventLog_BadPacket(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      DWORD           EventId,
    IN      PDNS_MSGINFO    pMsg
    );


//
//  Exception handling (except.c)
//

VOID
Ex_RaiseException(
    IN      DWORD             dwCode,
    IN      DWORD             dwFlags,
    IN      DWORD             Argc,
    IN      CONST ULONG_PTR * Argv,
    IN      LPSTR             pszFile,
    IN      INT               iLineNo
    );

#define RAISE_EXCEPTION(a,b,c,d) \
            Ex_RaiseException( (a), (b), (c), (d), __FILE__, __LINE__ );


VOID
Ex_RaiseFormerrException(
    IN      PDNS_MSGINFO    pMsg,
    IN      LPSTR           pszFile,
    IN      INT             iLineNo
    );

#define RAISE_FORMERR( pMsg ) \
            Ex_RaiseFormerrException( (pMsg), __FILE__, __LINE__ );


//
//  Lock debug routines (lock.c)
//

PVOID
Lock_CreateLockTable(
    IN      LPSTR           pszName,
    IN      DWORD           Size,
    IN      DWORD           MaxLockTime
    );

VOID
Lock_SetLockHistory(
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    );

VOID
Lock_SetOffenderLock(
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    );

VOID
Lock_FailedLockCheck(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line
    );

VOID
Dbg_LockTable(
    IN      PVOID           pLockTable,
    IN      BOOL            fPrintHistory
    );


//
//  Service control (dns.c)
//

VOID
Service_LoadCheckpoint(
    VOID
    );

VOID
Service_ServiceControlAnnounceStart(
    VOID
    );

DNS_STATUS
Service_SendControlCode(
    IN      LPWSTR          pwszServiceName,
    IN      DWORD           dwControlCode
    );

VOID
Service_IndicateException(
    VOID
    );

VOID
Service_IndicateRestart(
    VOID
    );


//
// Service Control Manager (using the scm api's)
//
DWORD
scm_Initialize(
    VOID
    );

DWORD
scm_AdjustSecurity(
    IN      PSECURITY_DESCRIPTOR    pNewSd
    );


//
//  Packet allocation (packet.c)
//

BOOL
Packet_ListInitialize(
    VOID
    );

VOID
Packet_ListShutdown(
    VOID
    );

VOID
FASTCALL
Packet_Initialize(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwUsableBufferLength,
    IN      DWORD           dwMaxBufferLength
    );

VOID
Packet_Free(
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
Packet_AllocateUdpMessage(
    VOID
    );

VOID
Packet_FreeUdpMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Packet_WriteDerivedStats(
    VOID
    );


PDNS_MSGINFO
Packet_AllocateTcpMessage(
    IN      DWORD   dwMinBufferLength
    );

#if 0
PDNS_MSGINFO
Packet_ReallocateTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwMinBufferLength
    );
#endif

VOID
Packet_FreeTcpMessage(
    IN      PDNS_MSGINFO    pMsg
    );



//
//  RPC control (rpc.c)
//

DNS_STATUS
Rpc_Initialize(
    VOID
    );

VOID
Rpc_Shutdown(
    VOID
    );

#define DNS_IP_ALLOW_LOOPBACK       0x0001
#define DNS_IP_ALLOW_SELF           0x0002

DNS_STATUS
RpcUtil_ScreenIps(
    IN      PDNS_ADDR_ARRAY     pIpAddrs,
    IN      DWORD               dwFlags,
    OUT     DWORD *             pdwErrorIp      OPTIONAL
    );

BOOL
RpcUtil_CopyStringToRpcBuffer(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString
    );

BOOL
RpcUtil_CopyStringToRpcBufferEx(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString,
    IN      BOOL            fUnicodeIn,
    IN      BOOL            fUnicodeOut
    );

BOOL
RpcUtil_CopyIpArrayToRpcBuffer(
    IN OUT  PIP_ARRAY *         paipRpcIpArray,
    IN      PDNS_ADDR_ARRAY     aipLocalIpArray
    );

DNS_STATUS
RpcUtil_CreateSecurityObjects(
    VOID
    );

DNS_STATUS
RpcUtil_ApiAccessCheck(
    IN      ACCESS_MASK     DesiredAccess
    );

#define PRIVILEGE_PROPERTY                  (0x00000011)
#define PRIVILEGE_ZONE_CREATE               (0x00000012)
#define PRIVILEGE_DELEGATE                  (0x00000013)
#define PRIVILEGE_WRITE                     (0x00000013)
#define PRIVILEGE_READ                      (0x00000014)
#define PRIVILEGE_WRITE_IF_FILE_READ_IF_DS  (0x08000000)

#define PRIVILEGE_RECORD_ADD                (0x00001001)
#define PRIVILEGE_RECORD_DELETE             (0x00001002)
#define PRIVILEGE_RECORD_READ               (0x00001003)

DNS_STATUS
RpcUtil_CheckAdminPrivilege(
    IN      PZONE_INFO      pZone,
    IN      PDNS_DP_INFO    pDpInfo,
    IN      DWORD           dwPrivilege
    );

DNS_STATUS
RpcUtil_FindZone(
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppZone
    );

#define RPC_INIT_FIND_ALL_ZONES         0x00000001
#define RPC_INIT_FORCE_DS_OPERATION     0x00000002

DNS_STATUS
RpcUtil_SessionSecurityInit(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwPrivilege,
    IN      DWORD           dwFlag,
    OUT     PBOOL           pfImpersonating
    );

DNS_STATUS
RpcUtil_SessionComplete(
    VOID
    );

PVOID
MIDL_user_allocate_zero(
    IN      size_t  cBytes
    );


//
//  Wrapper around RPC impersonation
//

#define RPC_SWITCH_TO_SERVER_CONTEXT    FALSE
#define RPC_SWITCH_TO_CLIENT_CONTEXT    TRUE

DNS_STATUS
RpcUtil_SwitchSecurityContext(
    IN  BOOL    bSwitchToClientContext
    );


//
//  Resource record list operations (rrlist.c)
//

#define DNS_RRCOMP_CHECK_TTL            0x0001
#define DNS_RRCOMP_CHECK_TIMESTAMP      0x0002
#define DNS_RRCOMP_IGNORE_SOA_SERIAL    0x0004

#ifdef DNSNT4
BOOL
RR_FindNext(
    IN      PDB_NODE        pNode,
    IN      WORD            wFindType,
    IN OUT  PDB_RECORD *    ppRecord
    );
#endif

PDB_RECORD
RR_FindNextRecord(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      PDB_RECORD      pRecord,
    IN      DWORD           dwQueryTime
    );

DWORD
RR_ListCountRecords(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      BOOL            fLocked
    );

DWORD
RR_FindRank(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

DNS_STATUS
RR_AddToNode(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    );

DNS_STATUS
RR_ListReplace(
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pNewList,
    OUT     PDB_RECORD *    ppDelete
    );

BOOL
RR_CacheSetAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pFirstRR,
    IN OUT  PDB_RECORD      pLastRR,
    IN      DWORD           dwTtl,
    IN      DWORD           dwQueryTime
    );

BOOL
RR_CacheAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN      BOOL            fFirst
    );

DNS_STATUS
RR_DeleteMatchingRecordFromNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    );

VOID
RR_ListTimeout(
    IN OUT  PDB_NODE        pNode
    );

VOID
RR_ListDelete(
    IN OUT  PDB_NODE        pNode
    );

VOID
RR_ListDeleteType(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wType
    );

BOOL
RR_ListIsMatchingType(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

BOOL
RR_ListIsMatchingSet(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRSet,
    IN      BOOL            bForceRefresh
    );

BOOL
RR_ListIsMatchingList(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwFlags
    );

DNS_STATUS
RR_ListDeleteMatchingRecordHandle(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

PDB_RECORD
RR_UpdateDeleteMatchingRecord(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR
    );

PDB_RECORD
RR_UpdateDeleteType(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwFlag
    );

PDB_RECORD
RR_UpdateScavenge(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );

DWORD
RR_UpdateForceAging(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );

PDB_RECORD
RR_ReplaceSet(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    );

DNS_STATUS
RR_UpdateAdd(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate,
    IN      DWORD           dwFlag
    );

VOID
RR_CacheNameError(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wQuestionType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    );

VOID
RR_CacheEmptyAuth(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wQuestionType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    );

BOOL
RR_CheckNameErrorTimeout(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fForceRemove,
    OUT     PDWORD          pdwTtl,         OPTIONAL
    OUT     PDB_NODE *      ppSoaNode       OPTIONAL
    );

#define RR_RemoveCachedNameError(pNode) \
        RR_CheckNameErrorTimeout( (pNode), TRUE, NULL, NULL )

#if DBG
BOOL
RR_ListVerify(
    IN      PDB_NODE        pNode
    );

BOOL
RR_ListVerifyDetached(
    IN      PDB_RECORD      pRR,
    IN      WORD            wType,
    IN      DWORD           dwSource
    );

#else

#define RR_ListVerify(pNode)            (TRUE)
#define RR_ListVerifyDetached(a,b,c)    (TRUE)

#endif


//
//  Record list, unattached functions
//

PDB_RECORD
RR_ListInsertInOrder(
    IN OUT  PDB_RECORD      pFirstRR,
    IN      PDB_RECORD      pNewRR
    );

#define RRCOPY_EXCLUDE_CACHED_DATA  0x00000001

PDB_RECORD
RR_ListForNodeCopy(
    IN      PDB_NODE        pNode,
    IN      DWORD           Flag
    );

PDB_RECORD
RR_ListCopy(
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    );

BOOL
FASTCALL
RR_Compare(
    IN      PDB_RECORD      pRR1,
    IN      PDB_RECORD      pRR2,
    IN      DWORD           dwFlags
    );

DWORD
FASTCALL
RR_PacketTtlForCachedRecord(
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwQueryTime
    );

//
//  RR list comparison
//

#define RRLIST_MATCH            (0)
#define RRLIST_AGING_REFRESH    (0x12)
#define RRLIST_AGING_ON         (0x22)
#define RRLIST_AGING_OFF        (0x42)
#define RRLIST_NO_MATCH         (0xff)

DWORD
RR_ListCompare(
    IN      PDB_RECORD      pNodeRRList,
    IN      PDB_RECORD      pCheckRRList,
    IN      DWORD           dwFlags,
    IN      DWORD           dwRefreshTime           OPTIONAL
    );

BOOL
FASTCALL
RR_IsRecordInRRList(
    IN      PDB_RECORD      pRRList,
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwFlags
    );

PDB_RECORD
RR_RemoveRecordFromRRList(
    IN OUT  PDB_RECORD *    ppRRList,
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwFlags
    );

DWORD
RR_ListCheckIfNodeNeedsRefresh(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwRefreshTime
    );


DWORD
RR_ListFree(
    IN OUT  PDB_RECORD      pRRList
    );

BOOL
RR_ListExtractInfo(
    IN      PDB_RECORD      pNewList,
    IN      BOOL            fZoneRoot,
    OUT     PBOOL           pfNs,
    OUT     PBOOL           pfCname,
    OUT     PBOOL           pfSoa
    );

//
//  Resource record caching (rrcache.c)
//

DNS_STATUS
Recurse_CacheMessageResourceRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PDNS_MSGINFO    pQuery,
    OUT     PBOOL           pfCnameAnswer   OPTIONAL
    );

DNS_STATUS
Xfr_ReadXfrMesssageToDatabase(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
Xfr_ParseIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE_LIST    pPassUpdateList
    );

PCHAR
Wire_ParseWireRecord(
    IN      PCHAR           pchWireRR,
    IN      PCHAR           pchStop,
    IN      BOOL            fClassIn,
    OUT     PPARSE_RECORD   pRR
    );

PDB_RECORD
Wire_CreateRecordFromWire(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PPARSE_RECORD   pParsedRR,
    IN      PCHAR           pchData,
    IN      DWORD           MemTag
    );

//
//  Records to\from flat format (rrflat.c)
//

PDB_RECORD
Flat_ReadRecordFromDsRecord(
    IN      PZONE_INFO          pZone,
    IN      PDB_NODE            pNodeOwner,
    IN      PDNS_FLAT_RECORD    pDsRecord
    );

DNS_STATUS
Dnssrv_Flat_RecordRead(     //  Note: renamed to avoid collision with dnslib
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pRecord,
    OUT     PDB_RECORD *        ppResultRR
    );

DNS_STATUS
Flat_BuildRecordFromFlatBufferAndEnlist(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pnodeOwner,
    IN      PDNS_RPC_RECORD pRecord,
    OUT     PDB_RECORD *    ppResultRR  OPTIONAL
    );

DNS_STATUS
Flat_CreatePtrRecordFromDottedName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszDottedName,
    IN      WORD            wType,
    OUT     PDB_RECORD *    ppResultRR      OPTIONAL
    );

DNS_STATUS
Flat_WriteRecordToBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );


//
//  Resource record packet writing (rrpacket.c)
//

#define DNSSEC_ALLOW_INCLUDE_SIG    (0x00000001)
#define DNSSEC_ALLOW_INCLUDE_NXT    (0x00000002)
#define DNSSEC_ALLOW_INCLUDE_KEY    (0x00000004)
#define DNSSEC_ALLOW_INCLUDE_ALL    (0x00000007)
#define DNSSEC_INCLUDE_KEY          (0x00000040)

BOOL
Wire_AddResourceRecordToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,          OPTIONAL
    IN      WORD            wNameOffset,    OPTIONAL
    IN      PDB_RECORD      pRR,
    IN      DWORD           flags
    );

WORD
Wire_WriteRecordsAtNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wNameOffset,    OPTIONAL
    IN      DWORD           flags
    );

#ifdef NEWDNS
VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NAME        pName,
    IN      WORD            wType
    );
#else
VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      PCHAR           pchPacketName,
    IN      WORD            wType
    );
#endif

WORD
Wire_WriteAddressRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset
    );



//
//  Resource records utils for RPC buffers (rrrpc.c)
//

DNS_STATUS
RutilNt4_WriteRecordToBufferNt4(
    IN OUT  PCHAR *         ppCurrent,
    IN      PCHAR           pchBufEnd,
    IN      PDNS_RPC_NODE   pdnsNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    );

BOOL
RpcUtil_DeleteNodeOrSubtreeForAdmin(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PZONE_INFO      pZone,          OPTIONAL
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN      BOOL            fSubtreeDelete
    );

//
//  Security utils (security.c)
//

DNS_STATUS
Security_Initialize(
    VOID
    );

DNS_STATUS
Security_CreateStandardSids(
    VOID
    );

DNS_STATUS
Security_Shutdown(
    VOID
    );

//
//  Send packet (send.c)
//

#define         DNS_SENDMSG_TCP_ENLISTED        0x0001 

DNS_STATUS
Send_Msg(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwFlags
    );

#define Send_Response( pMsg, dwFlags )                          \
            {                                                   \
                ASSERT( pMsg->Head.IsResponse == TRUE );        \
                Send_Msg( pMsg, dwFlags );                      \
            }

#define Send_Query( pMsg, dwFlags )                             \
            {                                                   \
                ASSERT( pMsg->Head.IsResponse == FALSE );       \
                Send_Msg( pMsg, dwFlags );                      \
            }

DNS_STATUS
Send_ResponseAndReset(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwSendFlags
    );

VOID
Send_Multiple(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      PDNS_ADDR_ARRAY     aipSendAddrs,
    IN OUT  PDWORD              pdwStatCount    OPTIONAL
    );

#define DNS_REJECT_DO_NOT_SUPPRESS      0x00000001

VOID
Reject_UnflippedRequest (
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Reject_Request(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Reject_RequestIntact(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Send_NameError(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
Send_RecursiveResponseToClient(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
Send_QueryResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Send_ForwardResponseAsReply(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery
    );

VOID
Send_InitBadSenderSuppression(
    VOID
    );

//
//  Sockets (socket.c)
//

DNS_STATUS
Sock_ChangeServerIpBindings(
    VOID
    );

DNS_STATUS
Sock_ReadAndOpenListeningSockets(
    VOID
    );

//  Flags to CreateSocket

#define DNSSOCK_LISTEN              (0x00000001)
#define DNSSOCK_REUSEADDR           (0x00000002)
#define DNSSOCK_BLOCKING            (0x00000004)
#define DNSSOCK_NO_ENLIST           (0x00000010)
#define DNSSOCK_NO_EXCLUSIVE        (0x00000020)
//  #define DNSSOCK_DNS_LISTEN_PORT     (0x00000040)
#define DNSSOCK_NO_EVENT_LOGS       (0x00000080)

SOCKET
Sock_CreateSocket(
    IN      INT             SockType,
    IN      PDNS_ADDR       pDestAddr,
    IN      DWORD           Flags
    );

VOID
Sock_EnlistSocket(
    IN      SOCKET      Socket,
    IN      INT         SockType,
    IN      PDNS_ADDR   pDnsAddr,
    IN      BOOL        fListen
    );

BOOL
Sock_SetSocketForTcpConnection(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallback,  OPTIONAL
    IN OUT  PDNS_MSGINFO        pMsg        OPTIONAL
    );

VOID
Sock_CloseSocket(
    IN      SOCKET          Socket
    );

BOOL
Sock_GetAssociatedIpAddr(
    IN      SOCKET          Socket,
    OUT     PDNS_ADDR       pDnsAddr
    );

DNS_STATUS
Sock_StartReceiveOnUdpSockets(
    VOID
    );

VOID
Sock_IndicateUdpRecvFailure(
    IN OUT  PDNS_SOCKET     pContext,
    IN      DNS_STATUS      Status
    );

VOID
Sock_CloseAllSockets(
    VOID
    );

BOOL
Sock_ValidateTcpConnectionSocket(
    IN      SOCKET          Socket
    );

VOID
Sock_CleanupDeadSocketMessage(
    IN OUT  PDNS_SOCKET     pContext
    );

//
//  TCP packet reception (tcpsrv.c)
//

BOOL
Tcp_Receiver(
    VOID
    );

PDNS_MSGINFO
Tcp_ReceiveMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );


//
//  Thread management (thread.c)
//

HANDLE
Thread_Create(
    IN      LPSTR                   pszThreadTitle,
    IN      LPTHREAD_START_ROUTINE  lpStartAddr,
    IN      LPVOID                  lpThreadParam,
    IN      DWORD                   dwFailureEvent  OPTIONAL
    );

VOID
Thread_Close(
    IN      BOOL            fXfrRecv
    );

VOID
Thread_ShutdownWait(
    VOID
    );

LPSTR
Thread_DescrpitionMatchingId(
    IN      DWORD           ThreadId
    );

//
//  Thread service control (thread.c)
//

BOOL
Thread_ServiceCheck(
    VOID
    );

//
//  Thread utils (thread.c)
//

BOOL
Thread_TestFlagAndSet(
    IN OUT  PBOOL           pFlag
    );

VOID
Thread_ClearFlag(
    IN OUT  PBOOL           pFlag
    );


//
//  Timeout thread (timeout.c)
//

#define Timeout_LockOut()
#define Timeout_ClearLockOut()

#define TIMEOUT_NODE_LOCKED     (0x80000000)
#define TIMEOUT_REFERENCE       (0x00000001)
#define TIMEOUT_PARENT          (0x00000002)

VOID
Timeout_SetTimeoutOnNodeEx(
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwTimeout,
    IN      DWORD           dwFlag
    );

#define Timeout_SetTimeoutOnNode(pNode) \
        Timeout_SetTimeoutOnNodeEx( pNode, 0, 0 );

BOOL
Timeout_ClearNodeTimeout(
    IN OUT  PDB_NODE        pNode
    );

BOOL
Timeout_Initialize(
    VOID
    );

VOID
Timeout_Shutdown(
    VOID
    );

VOID
Timeout_FreeWithFunctionEx(
    IN      PVOID           pItem,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define Timeout_FreeWithFunction( ptr, func )                               \
        Timeout_FreeWithFunctionEx( (ptr), (func), __FILE__, __LINE__ )

#define Timeout_Free( pv )                                                  \
        Timeout_FreeWithFunction( (pv), NULL )

#define Timeout_FreeDnsAddrArray( parray )                                  \
        Timeout_FreeWithFunction( ( parray ), DnsAddrArray_Free )

VOID
Timeout_FreeAndReplaceZoneDataEx(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PVOID *         ppZoneData,
    IN      PVOID           pNewData,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define Timeout_FreeAndReplaceZoneData( pzone, ppdata, pnew ) \
    Timeout_FreeAndReplaceZoneDataEx( (pzone), (ppdata), (pnew), NULL, __FILE__, __LINE__ )

#define Timeout_FreeAndReplaceZoneIPArray( pzone, ppdata, pnew ) \
    Timeout_FreeAndReplaceZoneDataEx( (pzone), (ppdata), (pnew), DnsAddrArray_Free, __FILE__, __LINE__ )


DWORD
Timeout_Thread(
    IN      LPVOID          Dummy
    );

VOID
Timeout_CleanupDelayedFreeList(
    VOID
    );


//
//  UDP Packet reception (udp.c)
//

DNS_STATUS
Udp_CreateReceiveThreads(
    VOID
    );

VOID
Udp_DropReceive(
    IN OUT  PDNS_SOCKET     pContext,
    IN      UINT            Index
    );

BOOL
Udp_ReceiveThread(
    IN      LPVOID          pvSocket
    );

VOID
Udp_RecvCheck(
    VOID
    );

VOID
Udp_ShutdownListenThreads(
    VOID
    );


//
//  Update processing (update.c)
//

BOOL
Up_InitializeUpdateProcessing(
    VOID
    );

VOID
Up_UpdateShutdown(
    VOID
    );

BOOL
Up_SetUpdateListSerial(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE         pUpdate
    );

DNS_STATUS
Up_ApplyUpdatesToDatabase(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           Flag
    );

DNS_STATUS
Up_ExecuteUpdateEx(
    IN      PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList,
    IN      DWORD           Flag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLineNo
    );

#define Up_ExecuteUpdate( pZone, pUpdateList, Flag ) \
        Up_ExecuteUpdateEx( (pZone), (pUpdateList), (Flag), __FILE__, __LINE__ )

DNS_STATUS
Up_LogZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList
    );

VOID
Up_ForwardUpdateToPrimary(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Up_ForwardUpdateResponseToClient(
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
Up_ProcessUpdate(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Up_CompleteZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwFlags
    );

VOID
Up_WriteDerivedUpdateStats(
    VOID
    );


VOID
Up_RetryQueuedUpdatesForZone(
    IN      PZONE_INFO      pZone
    );

//
//  Write back of zone files (dfwrite.c)
//

#define DNS_FILE_IMPERSONATING      ZONE_CREATE_IMPERSONATING

BOOL
File_WriteZoneToFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsZoneFile,    OPTIONAL
    IN      DWORD           dwFlags
    );

BOOL
File_DeleteZoneFileW(
    IN      PCWSTR          pwszZoneFileName
    );

BOOL
File_DeleteZoneFileA(
    IN      PCSTR           pszZoneFileName
    );

BOOL
RR_WriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    );


//
//  Zone transfer from primary (zonepri.c)
//

VOID
Xfr_SendNotify(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_TransferZone(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Xfr_ProcessNotifyResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );


//
//  Secondary zone control (zonesec.c)
//

PDNS_MSGINFO
Xfr_BuildXfrRequest(
    IN OUT  PZONE_INFO      pZone,
    IN      WORD            wType,
    IN      BOOL            fTcp
    );

BOOL
Xfr_InitializeSecondaryZoneControl(
    VOID
    );

VOID
Xfr_CleanupSecondaryZoneControl(
    VOID
    );

DNS_STATUS
Xfr_ZoneControlThread(
    IN      LPVOID  pvDummy
    );

VOID
Xfr_InitializeSecondaryZoneTimeouts(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_QueueSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Xfr_CleanupSecondary(
    VOID
    );

VOID
Xfr_SendSoaQuery(
    IN OUT  PZONE_INFO      pZone
    );

BOOL
Xfr_RefreshZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_RetryZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_ForceZoneExpiration(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_ForceZoneRefresh(
    IN OUT  PZONE_INFO      pZone
    );


//
//  Zone transfer reception thread (zonerecv.c)
//

DWORD
Xfr_ReceiveThread(
    IN      LPVOID          pvZone
    );


//
//  Functions from ics.c
//

VOID
ICS_Notify(
    IN      BOOL        fDnsIsStarting
    );

//
//  Functions from autoconfigure.c
//

DNS_STATUS
Dnssrv_AutoConfigure(
    IN      DWORD       dwFlags
    );

//
//  Functions from IpNotify.c
//

DNS_STATUS
IpNotify_Thread(
    IN      PVOID           pvDummy
    );


#endif  //  _DNSPROC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dpart.h ===
/*++

Copyright(c) 1995-2000 Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to directory partition 
    implementation.

Author:

    Jeff Westhead, June 2000

Revision History:

--*/


#ifndef _DNS_DP_H_INCLUDED
#define _DNS_DP_H_INCLUDED


//
//  Max USN string length
//  (ULONGLONG string 20 byte string)
//

#define MAX_USN_LENGTH  (24)


#define DNS_ATTR_OBJECT_CLASS       L"objectClass"
#define DNS_ATTR_OBJECT_CATEGORY    L"objectCategory"


//
//  Constants
//

#define DNS_DP_DISTATTR             L"DC"   //  DP default dist attribute
#define DNS_DP_DISTATTR_CHARS       2       //  length in characters
#define DNS_DP_DISTATTR_BYTES       4       //  length in bytes
#define DNS_DP_DISTATTR_EQ          L"DC="  //  DP default dist attr with "="
#define DNS_DP_DISTATTR_EQ_CHARS    3       //  length in characters
#define DNS_DP_DISTATTR_EQ_BYTES    6       //  length in bytes

#define DNS_DP_OBJECT_CLASS         L"domainDNS"
#define DNS_DP_ATTR_INSTANCE_TYPE   L"instanceType"
#define DNS_DP_ATTR_REFDOM          L"msDS-SDReferenceDomain"
#define DNS_DP_ATTR_SYSTEM_FLAGS    L"systemFlags"
#define DNS_DP_ATTR_REPLICAS        L"msDS-NC-Replica-Locations"
#define DNS_DP_ATTR_NC_NAME         L"nCName"
#define DNS_DP_ATTR_SD              L"ntSecurityDescriptor"
#define DNS_DP_ATTR_REPLUPTODATE    L"replUpToDateVector"
#define DNS_DP_DNS_ROOT             L"dnsRoot"
#define DNS_ATTR_OBJECT_GUID        L"objectGUID"
#define DNS_ATTR_DNS_HOST_NAME      L"dNSHostName"
#define DNS_ATTR_FSMO_SERVER        L"fSMORoleOwner"
#define DNS_ATTR_DC                 L"DC"
#define DNS_ATTR_DNSZONE            L"dnsZone"
#define DNS_ATTR_DESCRIPTION        L"description"
 
#define DNS_DP_DNS_FOLDER_RDN       L"cn=MicrosoftDNS"
#define DNS_DP_DNS_FOLDER_OC        L"container"

#define DNS_DP_SCHEMA_DP_STR        L"CN=Enterprise Schema,"
#define DNS_DP_SCHEMA_DP_STR_LEN    21

#define DNS_DP_CONFIG_DP_STR        L"CN=Enterprise Configuration,"
#define DNS_DP_CONFIG_DP_STR_LEN    28


//
//  Module init functions
//

DNS_STATUS
Dp_Initialize(
    VOID
    );

VOID
Dp_Cleanup(
    VOID
    );

extern LONG g_liDpInitialized;

#define IS_DP_INITIALIZED()     ( g_liDpInitialized > 0 )


//
//  Directory partition structure - see dnsrpc.h for public flags.
//

typedef struct
{
    LIST_ENTRY      ListEntry;

    DWORD           State;              //  DNS_DP_STATE_XXX constant
    PSTR            pszDpFqdn;          //  UTF8 FQDN of the DP
    PWSTR           pwszDpFqdn;         //  Unicode FQDN of the DP
    PWSTR           pwszDpDn;           //  DN of the DP head object
    PWSTR           pwszCrDn;           //  DN of the crossref object
    PWSTR           pwszDnsFolderDn;    //  DN of the MicrosoftDNS object
    PWSTR           pwszGUID;           //  object GUID
    PWSTR           pwszLastUsn;        //  last USN read from DS
    PWSTR *         ppwszRepLocDns;     //  DNs of replication locations
    DWORD           dwSystemFlagsAttr;  //  systemFlags attribute value
    DWORD           dwLastVisitTime;    //  used to track if visited
    DWORD           dwDeleteDetectedCount;  //  # of times DP missing from DS
    DWORD           dwFlags;            //  use DNS_DP_XX flag consts
    LONG            liZoneCount;        //  # of zones in memory from this DP

    PSECURITY_DESCRIPTOR    pMsDnsSd;   //  SD from the MicrosoftDNS object
    PSECURITY_DESCRIPTOR    pCrSd;      //  SD from the crossRef object
}
DNS_DP_INFO, * PDNS_DP_INFO;

#define DNS_DP_DELETE_ALLOWED( pDpInfo )        \
    ( ( ( pDpInfo )->dwFlags &                  \
        ( DNS_DP_AUTOCREATED |                  \
            DNS_DP_LEGACY |                     \
            DNS_DP_DOMAIN_DEFAULT |             \
            DNS_DP_FOREST_DEFAULT ) ) == 0 )

#define IS_DP_LEGACY( _pDpInfo )                \
    ( !( _pDpInfo ) || ( ( _pDpInfo )->dwFlags & DNS_DP_LEGACY ) )

#define IS_DP_FOREST_DEFAULT( pDpInfo )         \
    ( ( pDpInfo ) && ( ( pDpInfo )->dwFlags & DNS_DP_FOREST_DEFAULT ) )

#define IS_DP_DOMAIN_DEFAULT( pDpInfo )         \
    ( ( pDpInfo ) && ( ( pDpInfo )->dwFlags & DNS_DP_DOMAIN_DEFAULT ) )

#define IS_DP_ENLISTED( pDpInfo )               \
    ( ( pDpInfo ) && ( ( pDpInfo )->dwFlags & DNS_DP_ENLISTED ) )

#define IS_DP_DELETED( pDpInfo )                \
    ( ( pDpInfo ) && ( ( pDpInfo )->dwFlags & DNS_DP_DELETED ) )

#define IS_DP_ALLOWED_TO_HAVE_ROOTHINTS( pDpInfo )      \
    ( !( pDpInfo ) ||                                   \
        IS_DP_LEGACY( ( pDpInfo ) ) ||                  \
        IS_DP_DOMAIN_DEFAULT( ( pDpInfo ) ) )

#define ZONE_DP( pZone )        ( ( PDNS_DP_INFO )( ( pZone )->pDpInfo ) )

#define IS_DP_AVAILABLE( pDp )  ( ( pDp )->State == DNS_DP_STATE_OKAY )

#define DP_HAS_MORE_THAN_ONE_REPLICA( pDp )     \
    ( ( pDp )->ppwszRepLocDns &&                \
      ( pDp )->ppwszRepLocDns[ 0 ] &&           \
      ( pDp )->ppwszRepLocDns[ 1 ] )


//
//  Debug functions
//

#ifdef DBG

VOID
Dbg_DumpDpEx(
    IN      LPCSTR          pszContext,
    IN      PDNS_DP_INFO    pDp
    );

VOID
Dbg_DumpDpListEx(
    IN      LPCSTR      pszContext
    );

#define Dbg_DumpDp( pszContext, pDp ) Dbg_DumpDpEx( pszContext, pDp )
#define Dbg_DumpDpList( pszContext ) Dbg_DumpDpListEx( pszContext )

#else

#define Dbg_DumpDp( pszContext, pDp )
#define Dbg_DumpDpList( pszContext )

#endif


//
//  Directory partition functions
//

typedef enum
{
    dnsDpSecurityDefault,   //  DP should have default ACL - no modifications
    dnsDpSecurityDomain,    //  DP should be enlistable by all DCs in domain
    dnsDpSecurityForest     //  DP should be enlistable by all DCs in forest
}   DNS_DP_SECURITY;

DNS_STATUS
Dp_CreateByFqdn(
    IN      PSTR                pszDpFqdn,
    IN      DNS_DP_SECURITY     dnsDpSecurity,
    IN      BOOL                fLogErrors
    );

PDNS_DP_INFO
Dp_GetNext(
    IN      PDNS_DP_INFO    pDpInfo
    );

PDNS_DP_INFO
Dp_FindByFqdn(
    IN      LPSTR   pszFqdn
    );

DNS_STATUS
Dp_AddToList(
    IN      PDNS_DP_INFO    pDpInfo
    );

#define DNS_DP_POLL_FORCE           0x0001      //  do not suppress if just ran poll
#define DNS_DP_POLL_NOTIFYSCM       0x0002      //  notify scm of progress during poll
#define DNS_DP_POLL_NOAUTOENLIST    0x0004      //  skip autoenlist of built-in NDNCs

DNS_STATUS
Dp_PollForPartitions(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollFlags
    );

DNS_STATUS
Dp_BuildZoneList(
    IN      PLDAP           LdapSession
    );

DNS_STATUS
Dp_ModifyLocalDsEnlistment(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fEnlist
    );

DNS_STATUS
Dp_DeleteFromDs(
    IN      PDNS_DP_INFO    pDpInfo
    );

VOID
Dp_FreeDpInfo(
    IN      PDNS_DP_INFO *      ppDpInfo
    );

DNS_STATUS
Dp_Lock(
    VOID
    );

DNS_STATUS
Dp_Unlock(
    VOID
    );

DNS_STATUS
Dp_Poll(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollTime,
    IN      BOOL            fForcePoll
    );

DNS_STATUS
Ds_CheckZoneForDeletion(
    PVOID       pZone
    );

DNS_STATUS
Dp_AutoCreateBuiltinPartition(
    DWORD       dwFlag
    );

DNS_STATUS
Dp_CreateAllDomainBuiltinDps(
    OUT     LPSTR *     ppszErrorDp         OPTIONAL
    );

VOID
Dp_MigrateDcpromoZones(
    IN      BOOL            fForce
    );

DNS_STATUS
Dp_ChangeZonePartition(
    IN      PVOID           pZone,
    IN      PDNS_DP_INFO    pNewDp
    );

VOID
Dp_TimeoutThreadTasks(
    VOID
    );

DNS_STATUS
Dp_FindPartitionForZone(
    IN      DWORD               dwDpFlags,
    IN      LPSTR               pszDpFqdn,
    IN      BOOL                fAutoCreateAllowed,
    OUT     PDNS_DP_INFO *      ppDpInfo
    );

DNS_STATUS
Dp_AlterPartitionSecurity(
    IN      PWSTR               pwszNewPartitionDn,
    IN      DNS_DP_SECURITY     dnsDpSecurity
    );

DNS_STATUS
Dp_LoadOrCreateMicrosoftDnsObject(
    IN      PLDAP           LdapSession,
    IN OUT  PDNS_DP_INFO    pDp,
    IN      BOOL            fCreate
    );


//
//  Utility functions
//


PWSTR
Ds_ConvertFqdnToDn(
    IN      PSTR        pszFqdn
    );

DNS_STATUS
Ds_ConvertDnToFqdn(
    IN      PWSTR       pwszDn,
    OUT     PSTR        pszFqdn
    );

PLDAPMessage
DS_LoadOrCreateDSObject(
    IN      PLDAP           LdapSession,
    IN      PWSTR           pwszDN,
    IN      PWSTR           pwszObjectClass,
    IN      BOOL            fCreate,
    OUT     BOOL *          pfCreated,          OPTIONAL
    OUT     DNS_STATUS *    pStatus             OPTIONAL
    );


//
//  Global variables - call Dp_Lock/Unlock around access!
//

extern PDNS_DP_INFO        g_pLegacyDp;
extern PDNS_DP_INFO        g_pDomainDp;
extern PDNS_DP_INFO        g_pForestDp;


//
//  Unprotected global variables
//

extern LPSTR    g_pszDomainDefaultDpFqdn;
extern LPSTR    g_pszForestDefaultDpFqdn;

extern BOOL     g_fDcPromoZonesPresent;

#endif  // _DNS_DP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dpart.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    dpart.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle Directory Partitions

Author:

    Jeff Westhead (jwesth)  June, 2000

Revision History:

    jwesth      07/2000     initial implementation

--*/


/****************************************************************************

Default directory partitions
----------------------------

There are 2 default directory partitions: the Forest partition and the Domain
partition. It is expected that these partitions will account for all standard
customer needs. Custom paritions may also be used by customers to create a
partition tailored to their particular needs.

The name of the default DPs are not hard-coded. When DNS starts, it must 
discover the name of these two DPs. Right now this is reg-key only but 
eventually we should do this somewhere in the directory.

****************************************************************************/


//
//  Includes
//


#include "dnssrv.h"



//
//  Definitions
//


//  # of times a zone must be missing from a DP before it is deleted
#define DNS_DP_ZONE_DELETE_RETRY    2

#define DP_MAX_PARTITION_POLL_FREQ  30      //  seconds
#define DP_MAX_POLL_FREQ            30      //  seconds

#define sizeofarray( _Array ) ( sizeof( _Array ) / sizeof( ( _Array ) [ 0 ] ) )


//
//  DS Server Objects - structures and functions use to read objects
//  of class "server" from the Sites container in the directory.
//

typedef struct
{
    PWSTR       pwszDn;                 //  DN of server object
    PWSTR       pwszDnsHostName;        //  DNS host name of server
}
DNS_DS_SERVER_OBJECT, * PDNS_DS_SERVER_OBJECT;


//
//  Globals
//
//  g_DpCS is used to serial access to global directory partition list and pointers.
//

LONG                g_liDpInitialized = 0;  //  greater than zero -> initialized
CRITICAL_SECTION    g_DpCS;                 //  critsec for list access

LIST_ENTRY          g_DpList = { 0 };
LONG                g_DpListEntryCount = 0; //  entries in g_DpList
PDNS_DP_INFO        g_pLegacyDp = NULL;     //  ptr to element in g_DpList
PDNS_DP_INFO        g_pDomainDp = NULL;     //  ptr to element in g_DpList
PDNS_DP_INFO        g_pForestDp = NULL;     //  ptr to element in g_DpList

PDNS_DS_SERVER_OBJECT   g_pFsmo = NULL;     //  domain naming FSMO server info

LPSTR               g_pszDomainDefaultDpFqdn    = NULL;
LPSTR               g_pszForestDefaultDpFqdn    = NULL;

#define IS_DP_INITIALIZED()     ( g_liDpInitialized > 0 )

BOOL                g_fDcPromoZonesPresent = TRUE;

ULONG               g_DpTimeoutFastThreadCalls = 0;
DWORD               g_dwLastDpAutoEnlistTime = 0;

#define             DNS_DP_FAST_AUTOCREATE_ATTEMPTS     10

DWORD               g_dwLastPartitionPollTime = 0;
DWORD               g_dwLastDpPollTime = 0;
DWORD               g_dwLastDcpromoZoneMigrateCheck = 0;

//
//  Global controls
//


LONG            g_ChaseReferralsFlag = LDAP_CHASE_EXTERNAL_REFERRALS;

LDAPControlW    g_ChaseReferralsControlFalse =
    {
        LDAP_CONTROL_REFERRALS_W,
        {
            4,
            ( PCHAR ) &g_ChaseReferralsFlag
        },
        FALSE
    };

LDAPControlW    g_ChaseReferralsControlTrue =
    {
        LDAP_CONTROL_REFERRALS_W,
        {
            4,
            ( PCHAR ) &g_ChaseReferralsFlag
        },
        TRUE
    };

LDAPControlW *   g_pDpClientControlsNoRefs[] =
    {
        &g_ChaseReferralsControlFalse,
        NULL
    };

LDAPControlW *   g_pDpClientControlsRefs[] =
    {
        &g_ChaseReferralsControlTrue,
        NULL
    };

LDAPControlW *   g_pDpServerControls[] =
    {
        NULL
    };


//
//  Search filters, etc.
//

WCHAR    g_szCrossRefFilter[] = LDAP_TEXT("(objectCategory=crossRef)");

PWSTR    g_CrossRefDesiredAttrs[] =
{
    LDAP_TEXT( "CN" ),
    DNS_DP_ATTR_SD,
    DNS_DP_ATTR_INSTANCE_TYPE,
    DNS_DP_ATTR_REFDOM,
    DNS_DP_ATTR_SYSTEM_FLAGS,
    DNS_DP_ATTR_REPLICAS,
    DNS_DP_ATTR_NC_NAME,
    DNS_DP_DNS_ROOT,
    DNS_ATTR_OBJECT_GUID,
    LDAP_TEXT( "whenCreated" ),
    LDAP_TEXT( "whenChanged" ),
    LDAP_TEXT( "usnCreated" ),
    LDAP_TEXT( "usnChanged" ),
    DSATTR_ENABLED,
    DNS_ATTR_OBJECT_CLASS,
    NULL
};

PWSTR    g_genericDesiredAttrs[] =
{
    LDAP_TEXT( "CN" ),
    DNS_DP_ATTR_SD,
    DNS_ATTR_OBJECT_GUID,
    LDAP_TEXT( "whenCreated" ),
    LDAP_TEXT( "whenChanged" ),
    LDAP_TEXT( "usnCreated" ),
    LDAP_TEXT( "usnChanged" ),
    DNS_DP_ATTR_REPLUPTODATE,
    DNS_ATTR_OBJECT_CLASS,
    NULL
};


//
//  Local functions
//



PWSTR
microsoftDnsFolderDn(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Allocates Unicode DN for the DP's MicrosoftDNS container.

Arguments:

    Info -- DP to return display name of

Return Value:

    Unicode string. The caller must use FREE_HEAP to free it.

--*/
{
    PWSTR       pwszfolderDn;
    PWSTR       pwzdpDn = pDp->pwszDpDn;
    
    pwszfolderDn = ALLOC_TAGHEAP(
                    ( wcslen( g_pszRelativeDnsFolderPath ) +
                        wcslen( pwzdpDn ) + 5 ) *
                        sizeof( WCHAR ),
                    MEMTAG_DS_DN );

    if ( pwszfolderDn )
    {
        wcscpy( pwszfolderDn, g_pszRelativeDnsFolderPath );
        wcscat( pwszfolderDn, pwzdpDn );
    }

    return pwszfolderDn;
}   //  microsoftDnsFolderDn



PWCHAR
displayNameForDp(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Return the Unicode display name of the DP. This string
    is suitable for event logging or debug logging.

Arguments:

    pDpInfo -- DP to return display name of

Return Value:

    Unicode display string. The caller must not free it. If the
    string is to be held for long-term use the call should make a copy.
    Guaranteed not to be NULL.

--*/
{
    if ( !pDpInfo )
    {
        return L"MicrosoftDNS";
    }

    return pDpInfo->pwszDpFqdn ? pDpInfo->pwszDpFqdn : L"";
}   //  displayNameForDp



PWCHAR
displayNameForZoneDp(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Return the Unicode name of the DP a zone belongs to. This string
    is suitable for event logging or debug logging.
Arguments:

    pZone -- zone to return DP display name of

Return Value:

    Unicode display string. The caller must not free it. If the
    string is to be held for long-term use the call should make a copy.
    Guaranteed not to be NULL.

--*/
{
    if ( !pZone )
    {
        return L"";
    }

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        return L"FILE";
    }

    return displayNameForDp( pZone->pDpInfo );
}   //  displayNameForZoneDp



PLDAP
ldapSessionHandle(
    IN      PLDAP           LdapSession
    )
/*++

Routine Description:

    Given NULL or an LdapSession return the actual LdapSession to use.

    This function is handy when you're using the NULL LdapSession
    (meaning the server global session) so you don't have to have a
    ternary in every call that uses the session handle.

    Do not call this function before the global LDAP handle is opened.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

Return Value:

    Proper LdapSession value to use.

--*/
{
    return LdapSession ? LdapSession : pServerLdap;
}   //  ldapSessionHandle



VOID
freeServerObject(
    IN      PDNS_DS_SERVER_OBJECT   p
    )
/*++

Routine Description:

    Free server object structure allocated by readServerObjectFromDs().
    This function may be used in a call to Timeout_FreeWithFunction,
    example:

        Timeout_FreeWithFunction( pServerObj, freeServerObject );

Arguments:

    p -- ptr to server object to free

Return Value:

    None.

--*/
{
    if ( p )
    {
        FREE_HEAP( p->pwszDn );
        FREE_HEAP( p->pwszDnsHostName );
        FREE_HEAP( p );
    }
}   //  freeServerObject



PDNS_DS_SERVER_OBJECT
readServerObjectFromDs(
    IN      PLDAP           LdapSession,
    IN      PWSTR           pwszServerObjDn,
    OUT     DNS_STATUS *    pStatus             OPTIONAL
    )
/*++

Routine Description:

    Given the DN of a "server" object in the Sites container, allocate
    a server object structure filled in with key values.

Arguments:

    LdapSession -- server session or NULL for global session

    pwszServerObjDn -- DN of object of "server" objectClass, or the DN
        of the DS settings child object under the server object (this
        feature is provided for convenience)

    pStatus -- extended error code (optional)

Return Value:

    Pointer to allocated server struct. Use freeServerObject() to free.

--*/
{
    DBG_FN( "readServerObjectFromDs" )

    PDNS_DS_SERVER_OBJECT   pServer = NULL;
    DNS_STATUS              status = ERROR_SUCCESS;
    PLDAPMessage            pResult = NULL;
    PWSTR *                 ppwszAttrValues = NULL;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl_DGO,
        NULL
    };

    if ( !pwszServerObjDn )
    {
        status =  ERROR_INVALID_PARAMETER;
        goto Done;
    }
    
    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  If we've been given the DN of the server's Settings object, we
    //  need to adjust the DN to the Server object.
    //

    #define DNS_RDN_SERVER_SETTINGS         ( L"CN=NTDS Settings," )
    #define DNS_RDN_SERVER_SETTINGS_LEN     17

    if ( wcsncmp(
            pwszServerObjDn,
            DNS_RDN_SERVER_SETTINGS,
            DNS_RDN_SERVER_SETTINGS_LEN ) == 0 )
    {
        pwszServerObjDn += DNS_RDN_SERVER_SETTINGS_LEN;
    }

    //
    //  Get object from DS.
    //

    status = ldap_search_ext_s(
                LdapSession,
                pwszServerObjDn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                NULL,                   //  attrs
                FALSE,                  //  attrsonly
                ctrls,                  //  server controls
                NULL,                   //  client controls
                &g_LdapTimeout,
                0,                      //  sizelimit
                &pResult );
    if ( status != LDAP_SUCCESS || !pResult )
    {
        status = Ds_ErrorHandler( status, pwszServerObjDn, LdapSession, 0 );
        goto Done;
    }

    //
    //  Allocate server object.
    //

    pServer = ALLOC_TAGHEAP_ZERO(
                    sizeof( DNS_DS_SERVER_OBJECT ),
                    MEMTAG_DS_OTHER );
    if ( pServer )
    {
        pServer->pwszDn = Dns_StringCopyAllocate_W( pwszServerObjDn, 0 );
    }
    if ( !pServer || !pServer->pwszDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Read host name attribute.
    //

    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pResult, 
                        DNS_ATTR_DNS_HOST_NAME );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing from server object\n    %S\n", fn,
            LdapGetLastError(),
            DNS_ATTR_DNS_HOST_NAME,
            pwszServerObjDn ));
        goto Done;
    }
    pServer->pwszDnsHostName = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    if ( !pServer->pwszDnsHostName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:
                       
    ldap_value_free( ppwszAttrValues );
    ldap_msgfree( pResult );

    if ( pStatus )
    {
        *pStatus = status;
    }

    if ( status != ERROR_SUCCESS && pServer )
    {
        freeServerObject( pServer );
        pServer = NULL;
    }

    return pServer;
}   //  readServerObjectFromDs



DNS_STATUS
manageBuiltinDpEnlistment(
    IN      PDNS_DP_INFO        pDp,
    IN      DNS_DP_SECURITY     dnsDpSecurity,
    IN      PSTR                pszDpFqdn,
    IN      BOOL                fLogEvents,
    OUT     BOOL *              pfChangeWritten     OPTIONAL
    )
/*++

Routine Description:

    Create or enlist in a built-in DP as necessary. The DP should
    be either the forest or the domain built-in DP.

Arguments:

    pDp -- DP info or NULL if the DP does not exist in the directory

    dnsDpSecurity -- type of security required on the DP's crossRef

    pszDpFqdn -- FQDN of the DP (used to create if pDp is NULL)

    fLogEvents -- log optional events on errors
        -> failure to enlist is always logged but failure to create
           is only logged if this is TRUE

    pfChangeWritten -- set to TRUE if a change was written to the DS

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "manageBuiltinDpEnlistment" )

    DNS_STATUS  status = DNS_ERROR_INVALID_DATA;
    BOOL        fchangeWritten = FALSE;

    //
    //  If the partition pointer is NULL or if the partition is already 
    //  enlisted, no action is required.
    //

    if ( pDp && IS_DP_ENLISTED( pDp ) && !IS_DP_DELETED( pDp ) )
    {
        status = ERROR_SUCCESS;
        goto Done;
    }

    ASSERT( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal );
    ASSERT( DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal );

    ASSERT( !pDp ||
            IS_DP_FOREST_DEFAULT( pDp ) ||
            IS_DP_DOMAIN_DEFAULT( pDp ) );

    if ( pDp && !IS_DP_DELETED( pDp ) )
    {
        //  The DP exists so add the local DS to the replication scope.

        status = Dp_ModifyLocalDsEnlistment( pDp, TRUE );
        if ( status == ERROR_SUCCESS )
        {
            fchangeWritten = TRUE;
        }
        else
        {
            CHAR    szfqdn[ DNS_MAX_NAME_LENGTH + 1 ];

            PVOID   argArray[] =
            {
                pDp->pszDpFqdn,
                szfqdn,
                ( PVOID ) ( DWORD_PTR ) status
            };

            BYTE    typeArray[] =
            {
                EVENTARG_UTF8,
                EVENTARG_UTF8,
                EVENTARG_DWORD
            };

            Ds_ConvertDnToFqdn( 
                IS_DP_FOREST_DEFAULT( pDp ) ?
                    DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal :
                    DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal,
                szfqdn );

            Ec_LogEvent(
                g_pServerEventControl,
                IS_DP_FOREST_DEFAULT( pDp ) ?
                    DNS_EVENT_DP_CANT_JOIN_FOREST_BUILTIN :
                    DNS_EVENT_DP_CANT_JOIN_DOMAIN_BUILTIN,
                NULL,
                sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                argArray,
                typeArray,
                status );
        }
    }
    else if ( pszDpFqdn )
    {
        //  The DP does not exist so try to create it.

        status = Dp_CreateByFqdn( pszDpFqdn, dnsDpSecurity, FALSE );
        if ( status == ERROR_SUCCESS )
        {
            fchangeWritten = TRUE;
        }
        else if ( fLogEvents )
        {
            PVOID   argArray[] =
            {
                pszDpFqdn,
                ( PVOID ) ( DWORD_PTR ) status
            };

            BYTE    typeArray[] =
            {
                EVENTARG_UTF8,
                EVENTARG_DWORD
            };

            Ec_LogEvent(
                g_pServerEventControl,
                DNS_EVENT_DP_CANT_CREATE_BUILTIN,
                NULL,
                sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                argArray,
                typeArray,
                status );
        }
    }

    Done:

    if ( pfChangeWritten )
    {
        *pfChangeWritten = fchangeWritten;
    }

    DNS_DEBUG( DP, (
        "%s: returning %d for DP %p\n"
        "    FQDN =     %s\n"
        "    change =   %s\n", fn,
        status, 
        pDp,
        pszDpFqdn,
        fchangeWritten ? "TRUE" : "FALSE" ));
    return status;
}   //  manageBuiltinDpEnlistment



PWSTR
Ds_ConvertFqdnToDn(
    IN      PSTR        pszFqdn
    )
/*++

Routine Description:

    Fabricate a DN string from a FQDN string. Assumes all name components
    in the FQDN string map one-to-one to "DC=" components in the DN string.
    The return value is the allocated string (free with FREE_HEAP or
    Timeout_Free) or NULL on allocation error.

Arguments:

    pszFqdn -- input: UTF8 FQDN string

    pwszDn -- output: DN string fabricated from pwszFqdn

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "Ds_ConvertFqdnToDn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwBuffLength;
    PSTR            psz;
    PSTR            pszRover = pszFqdn;
    PWSTR           pwszOutput;
    PWSTR           pwszOutputCurr;
    int             nameComponentIdx = 0;

    ASSERT( pszFqdn );

    //
    //  Estimate the length of the string and allocate. 
    //

    dwBuffLength = 5;                       //  A little bit of padding
    for ( psz = pszFqdn; psz; psz = strchr( psz + 1, '.' ) )
    {
        ++dwBuffLength;                     //  Count "." characters in input FQDN.
    }
    dwBuffLength *= 4;                      //  Space for "DC=" strings.
    dwBuffLength += strlen( pszFqdn );
    dwBuffLength *= 2;                      //  Convert size in WCHARs to BYTES.
    pwszOutput = ( PWSTR ) ALLOC_TAGHEAP_ZERO( dwBuffLength, MEMTAG_DS_DN );

    IF_NOMEM( !pwszOutput )
    {
        goto Done;
    }

    pwszOutputCurr = pwszOutput;

    //
    //  Loop through the name components in the FQDN, writing each
    //  as a RDN to the DN output string.
    //

    do
    {
        INT         iCompLength;
        DWORD       dwBytesCopied;
        DWORD       dwBufLen;

        //
        //  Find the next dot and copy name component to output buffer.
        //  If this is the first name component, append a comma to output 
        //  buffer first.
        //

        psz = strchr( pszRover, '.' );
        if ( nameComponentIdx++ != 0 )
        {
            *pwszOutputCurr++ = L',';
        }
        memcpy(
            pwszOutputCurr,
            DNS_DP_DISTATTR_EQ,
            DNS_DP_DISTATTR_EQ_BYTES );
        pwszOutputCurr += DNS_DP_DISTATTR_EQ_CHARS;

        iCompLength = psz ?
                        ( int ) ( psz - pszRover ) :
                        strlen( pszRover );

        dwBufLen = dwBuffLength;
        dwBytesCopied = Dns_StringCopy(
                                ( PCHAR ) pwszOutputCurr,
                                &dwBufLen,
                                pszRover,
                                iCompLength,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode );

        dwBuffLength -= dwBytesCopied;
        pwszOutputCurr += ( dwBytesCopied / 2 ) - 1;

        //
        //  Advance pointer to start of next name component.
        //

        if ( psz )
        {
            pszRover = psz + 1;
        }
    } while ( psz );

    //
    //  Cleanup and return.
    //

    Done:
    
    DNS_DEBUG( DP, (
        "%s: returning %S\n"
        "    for FQDN %s\n", fn,
        pwszOutput,
        pszFqdn ));
    return pwszOutput;
}   //  Ds_ConvertFqdnToDn



DNS_STATUS
Ds_ConvertDnToFqdn(
    IN      PWSTR       pwszDn,
    OUT     PSTR        pszFqdn
    )
/*++

Routine Description:

    Fabricate a FQDN string from a DN string. Assumes all name components
    in the FQDN string map one-to-one to "DC=" components in the DN string.
    The FQDN ptr must be a buffer at least DNS_MAX_NAME_LENGTH chars long.

Arguments:

    pwszDn -- wide DN string

    pszFqdn -- FQDN string fabricated from pwszDn

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "Ds_ConvertDnToFqdn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwcharsLeft = DNS_MAX_NAME_LENGTH;
    PWSTR           pwszcompStart = pwszDn;
    PWSTR           pwszcompEnd;
    PSTR            pszoutput = pszFqdn;
    int             nameComponentIdx = 0;

    ASSERT( pwszDn );
    ASSERT( pszFqdn );

    if ( !pwszDn || !pszFqdn )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    *pszFqdn = '\0';

    //
    //  Loop through the name components in the DN, writing each RDN as a
    //  dot-separated name component in the output FQDN string.
    //
    //  DEVNOTE: could test dwcharsLeft as we go
    //

    while ( ( pwszcompStart = wcschr( pwszcompStart, L'=' ) ) != NULL )
    {
        DWORD       dwCompLength;
        DWORD       dwCharsCopied;
        DWORD       dwBuffLength;

        ++pwszcompStart;    //  Advance over '='
        pwszcompEnd = wcschr( pwszcompStart, L',' );
        if ( pwszcompEnd == NULL )
        {
            pwszcompEnd = wcschr( pwszcompStart, L'\0' );
        }

        if ( nameComponentIdx++ != 0 )
        {
            *pszoutput++ = '.';
            --dwcharsLeft;
        }

        dwCompLength = ( DWORD ) ( pwszcompEnd - pwszcompStart );

        dwBuffLength = dwcharsLeft;  //  don't want value to be stomped on!

        dwCharsCopied = Dns_StringCopy(
                                pszoutput,
                                &dwBuffLength,
                                ( PCHAR ) pwszcompStart,
                                dwCompLength,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );

        if ( dwCharsCopied == 0 )
        {
            ASSERT( dwCharsCopied != 0 );
            status = DNS_ERROR_INVALID_DATA;
            goto Done;
        }

        --dwCharsCopied;    //  The NULL was copied by Dns_StringCopy.

        pszoutput += dwCharsCopied;
        *pszoutput = '\0';
        dwcharsLeft -= dwCharsCopied;

        pwszcompStart = pwszcompEnd;
    }

    //
    //  Cleanup and return.
    //

    Done:

    DNS_DEBUG( DP, (
        "%s: returning %d\n"
        "    DN:   %S\n"
        "    FQDN: %s\n", fn,
        status, 
        pwszDn,
        pszFqdn ));
    return status;
}   //  Ds_ConvertDnToFqdn



PWSTR *
copyStringArray(
    IN      PWSTR *     ppVals
    )
/*++

Routine Description:

    Copy an LDAP string array from ldap_get_values(). The copied array
    will be NULL-terminated, just like the inbound array.

Arguments:

    ppVals -- array to copy

Return Value:

    Returns ptr to allocated array or NULL on error or if
        inbound array was NULL.

--*/
{
    PWSTR *     ppCopyVals = NULL;
    BOOL        fError = FALSE;
    INT         iCount = 0;
    INT         i;

    if ( ppVals && *ppVals )
    {
        //
        //  Count values.
        //

        for ( ; ppVals[ iCount ]; ++iCount );

        //
        //  Allocate array.
        //

        ppCopyVals = ( PWSTR * ) ALLOC_TAGHEAP_ZERO(
                                    ( iCount + 1 ) * sizeof( PWSTR ),
                                    MEMTAG_DS_OTHER );
        if ( !ppCopyVals )
        {
            fError = TRUE;
            goto Cleanup;
        }

        //
        //  Copy individual strings.
        //

        for ( i = 0; i < iCount; ++i )
        {
            ppCopyVals[ i ] = Dns_StringCopyAllocate_W( ppVals[ i ], 0 );
            if ( !ppCopyVals[ i ] )
            {
                fError = TRUE;
                goto Cleanup;
            }
        }
    }

    Cleanup:

    if ( fError && ppCopyVals )
    {
        for ( i = 0; i < iCount && ppCopyVals[ i ]; ++i )
        {
            FREE_HEAP( ppCopyVals[ i ] );
        }
        FREE_HEAP( ppCopyVals );
        ppCopyVals = NULL;
    }

    return ppCopyVals;
}   //  copyStringArray



VOID
freeStringArray(
    IN      PWSTR *     ppVals
    )
/*++

Routine Description:

    Frees a string array from allocated by copyStringArray.

Arguments:

    ppVals -- array to free

Return Value:

    None.

--*/
{
    if ( ppVals )
    {
        INT     i;

        for ( i = 0; ppVals[ i ]; ++i )
        {
            FREE_HEAP( ppVals[ i ] );
        }
        FREE_HEAP( ppVals );
    }
}   //  freeStringArray



PLDAPMessage
DS_LoadOrCreateDSObject(
    IN      PLDAP           LdapSession,
    IN      PWSTR           pwszDN,
    IN      PWSTR           pwszObjectClass,
    IN      BOOL            fCreate,
    OUT     BOOL *          pfCreated,          OPTIONAL
    OUT     DNS_STATUS *    pStatus             OPTIONAL
    )
/*++

Routine Description:

    Loads a DS object, creating an empty one if it is missing.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pwszDN -- DN of object to load

    pwszObjectClass -- object class (only used during creation)

    fCreate -- if object missing, will be created if TRUE

    pfCreated -- set to TRUE if the object was created by this function

    pStatus -- status of the operation

Return Value:

    Ptr to LDAP result containing object. Caller must free. Returns
    NULL on failure - check *pStatus for error code.

--*/
{
    DBG_FN( "DS_LoadOrCreateDSObject" )
    
    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fCreated = FALSE;
    PLDAPMessage    pResult = NULL;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl_DGO,
        NULL
    };

    ASSERT( pwszDN );
    ASSERT( !fCreate || fCreate && pwszObjectClass );

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );

    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Load/create loop.
    //

    do
    {
        status = ldap_search_ext_s(
                    LdapSession,
                    pwszDN,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    g_genericDesiredAttrs,  //  attrs
                    FALSE,                  //  attrsonly
                    ctrls,                  //  server controls
                    NULL,                   //  client controls
                    &g_LdapTimeout,
                    0,                      //  sizelimit
                    &pResult );
        if ( status == LDAP_NO_SUCH_OBJECT && fCreate )
        {
            //
            //  The object is missing - add it then reload.
            //

            ULONG           msgId = 0;
            INT             idx = 0;
            LDAPModW *      pModArray[ 10 ];

            PWCHAR          objectClassVals[ 2 ] =
                {
                pwszObjectClass,
                NULL
                };
            LDAPModW        objectClassMod = 
                {
                LDAP_MOD_ADD,
                DNS_ATTR_OBJECT_CLASS,
                objectClassVals
                };

            //
            //  Prepare mod array and submit add request.
            //

            pModArray[ idx++ ] = &objectClassMod;
            pModArray[ idx++ ] = NULL;

            status = ldap_add_ext(
                        LdapSession,
                        pwszDN,
                        pModArray,
                        NULL,           //  server controls
                        NULL,           //  client controls
                        &msgId );
            if ( status != ERROR_SUCCESS )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DP, (
                    "%s: error %lu cannot ldap_add_ext( %S )\n", fn,
                    status, 
                    pwszDN ));
                status = Ds_ErrorHandler( status, pwszDN, LdapSession, 0 );
                goto Done;
            }

            //
            //  Wait for the add request to be completed.
            //

            status = Ds_CommitAsyncRequest(
                        LdapSession,
                        LDAP_RES_ADD,
                        msgId,
                        NULL );
            if ( status != ERROR_SUCCESS )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DP, (
                    "%s: error %lu from add request for\n    %S\n", fn,
                    status, 
                    pwszDN ));
                status = Ds_ErrorHandler( status, pwszDN, LdapSession, 0 );
                goto Done;
            }
            fCreated = TRUE;
            continue;       //  Attempt to reload the object.
        }

        //
        //  If the return code is unknown, run it through the error handler.
        //
        
        if ( status != ERROR_SUCCESS &&
             status != LDAP_NO_SUCH_OBJECT )
        {
            status = Ds_ErrorHandler( status, pwszDN, LdapSession, 0 );
        }

        //  Load/add/reload is complete - status is the "real" error code.
        break;
    } while ( 1 );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pfCreated )
    {
        *pfCreated = ( status == ERROR_SUCCESS && fCreated );
    }

    if ( pStatus )
    {
        *pStatus = status;
    }

    if ( status == LDAP_NO_SUCH_OBJECT && pResult )
    {
        ldap_msgfree( pResult );
        pResult = NULL;
    }

    return pResult;
}   //  DS_LoadOrCreateDSObject


//
//  External functions
//



#ifdef DBG
VOID
Dbg_DumpDpEx(
    IN      LPCSTR          pszContext,
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Debug routine - print single DP to log.

Arguments:

    pszContext - comment

Return Value:

    None.

--*/
{
    DBG_FN( "Dbg_DumpDp" )

    DNS_DEBUG( DP, (
        "NC at %p\n"
        "    flags      %08X\n"
        "    fqdn       %s\n"
        "    DN         %S\n"
        "    folder DN  %S\n",
        pDp,
        pDp->dwFlags,
        pDp->pszDpFqdn,
        pDp->pwszDpDn,
        pDp->pwszDnsFolderDn ));
}   //  Dbg_DumpDpEx
#endif



#ifdef DBG
VOID
Dbg_DumpDpListEx(
    IN      LPCSTR      pszContext
    )
/*++

Routine Description:

    Debug routine - print DP list to log.

Arguments:

    pszContext - comment

Return Value:

    None.

--*/
{
    DBG_FN( "Dbg_DumpDpList" )

    PDNS_DP_INFO    pDp = NULL;
    
    DNS_DEBUG( DP, (
        "%s: %s\n", fn,
        pszContext ));

    while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
    {
        Dbg_DumpDpEx( pszContext, pDp );
    }
}   //  Dbg_DumpDpListEx
#endif



DNS_STATUS
getPartitionsContainerDn(
    IN      PWSTR           pwszDn,         IN OUT
    IN      DWORD           buffSize        IN
    )
/*++

Routine Description:

    Writes the partition container DN to the buffer at the argument.

Arguments:

    pwszPartitionsDn -- buffer
    buffSize -- length of pwszPartitionsDn buffer (in characters)

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "getPartitionsContainerDn" )
    
    #define PARTITIONS_CONTAINER_FMT    L"CN=Partitions,%s"

    if ( !pwszDn ||
        !DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ||
        wcslen( PARTITIONS_CONTAINER_FMT ) +
            wcslen( DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ) + 1 > buffSize )
    {
        if ( pwszDn && buffSize > 0 )
        {
            *pwszDn = '\0';
        }
        ASSERT( FALSE );
        return DNS_ERROR_INVALID_DATA;
    }
    else
    {
        wsprintf(
            pwszDn,
            L"CN=Partitions,%s",
            DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal );
        return ERROR_SUCCESS;
    }
}   //  getPartitionsContainerDn



DNS_STATUS
bindToFsmo(
    OUT     PLDAP *     ppLdapSession
    )
/*++

Routine Description:

    Connects to the domain naming master FSMO DC and binds an LDAP session.

Arguments:

    ppLdapSession -- set to new LDAP session handle

Return Value:

    ERROR_SUCCESS if connect and bind successful

--*/
{
    DBG_FN( "bindToFsmo" )

    DNS_STATUS              status = ERROR_SUCCESS;
    PWSTR                   pwszfsmo = NULL;
    PDNS_DS_SERVER_OBJECT   pfsmo = g_pFsmo;

    if ( !pfsmo || ( pwszfsmo = pfsmo->pwszDnsHostName ) == NULL )
    {
        //
        //  This path may occur on the first reboot following DC promotion if
        //  the DS has not finished initializing. In this case, DNS server 
        //  will pick up the FSMO on the next polling cycle.
        //
        
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        DNS_DEBUG( DP, (
            "%s: the DNS server has yet not been able to find the FSMO server\n", fn ));
        goto Done;
    }

    *ppLdapSession = Ds_Connect(
                        pwszfsmo,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to %S status=%d\n", fn,
            pwszfsmo,
            status ));
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        goto Done;
    }

    Done:

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound LDAP session %p to FSMO %S\n", fn,
            *ppLdapSession,
            pwszfsmo ));
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: error %d binding to FSMO %S\n", fn,
            status,
            pwszfsmo ));
    }

    return status;
}   //  bindToFsmo



DNS_STATUS
Dp_AlterPartitionSecurity(
    IN      PWSTR               pwszNewPartitionDn,
    IN      DNS_DP_SECURITY     dnsDpSecurity
    )
/*++

Routine Description:

    Add an ACE for the enterprse DC group to the crossRef object on the
    FSMO so that other DNS servers can remotely add themselves to the
    replication scope of the directory partition.

Arguments:

    pwszNewPartitionDn -- DN of the NC head object of the new partition 

    dnsDpSecurity -- type of crossRef ACL modification desired

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "Dp_AlterPartitionSecurity" )

    DNS_STATUS      status = DNS_ERROR_INVALID_DATA;
    PLDAP           ldapFsmo = NULL;
    PWSTR           pwszcrossrefDn = NULL;
    WCHAR           wszpartitionsContainerDn[ MAX_DN_PATH + 1 ];
    WCHAR           wszfilter[ MAX_DN_PATH + 20 ];
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl_DGO,
        NULL
    };

    //
    //  Bind to the FSMO.
    //

    status = bindToFsmo( &ldapFsmo );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  Search the partitions container for the crossRef matching
    //  the directory partition we just added.
    //

    getPartitionsContainerDn(
        wszpartitionsContainerDn,
        sizeofarray( wszpartitionsContainerDn ) );
    if ( !*wszpartitionsContainerDn )
    {
        DNS_DEBUG( DP, (
            "%s: unable to find partitions container\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    wsprintf( wszfilter, L"(nCName=%s)", pwszNewPartitionDn );

    status = ldap_search_ext_s(
                ldapFsmo,
                wszpartitionsContainerDn,
                LDAP_SCOPE_ONELEVEL,
                wszfilter,
                NULL,                   //  attrs
                FALSE,                  //  attrsonly
                ctrls,                  //  server controls
                NULL,                   //  client controls
                &g_LdapTimeout,         //  time limit
                0,                      //  size limit
                &presult );
    if ( status != LDAP_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: LDAP error 0x%X during partition search\n"
            "    filter  %S\n"
            "    base    %S\n", fn,
            status,
            wszfilter,
            wszpartitionsContainerDn ));
        status = Ds_ErrorHandler( status, wszpartitionsContainerDn, ldapFsmo, 0 );
        goto Done;
    }

    //
    //  Retrieve the DN of the crossRef.
    //

    pentry = ldap_first_entry( ldapFsmo, presult );
    if ( !pentry )
    {
        DNS_DEBUG( DP, (
            "%s: no entry in partition search result\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    pwszcrossrefDn = ldap_get_dn( ldapFsmo, pentry );
    if ( !pwszcrossrefDn )
    {
        DNS_DEBUG( DP, (
            "%s: NULL DN on crossref object\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Modify security on the crossRef.
    //

    if ( dnsDpSecurity != dnsDpSecurityDefault )
    {
        status = Ds_AddPrincipalAccess(
                        ldapFsmo,
                        pwszcrossrefDn,
                        dnsDpSecurity == dnsDpSecurityForest ?
                            g_pEnterpriseDomainControllersSid :
                            g_pDomainControllersSid,
                        NULL,           //  principal name
                        GENERIC_ALL,    //  maybe DNS_DS_GENERIC_WRITE?
                        0,
                        TRUE,			//	whack existing ACE
                        FALSE );		//	take ownership

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DP, (
                "%s: error %d adding access to\n    %S\n", fn,
                status,
                pwszcrossrefDn ));
            status = ERROR_SUCCESS;
        }

        #if 0

        //
        //  This interferes with the DS propogation of ACLs somehow.
        //
        
        if ( dnsDpSecurity == dnsDpSecurityForest )
        {
            //
            //  Remove "Domain Admins" from the ACL on the NC head object.
            //  The forest partition is open to modifications from
            //  Enterprise Admins only. Note: we cannot do this on the
            //  FSMO because the NC head only exists on the local DS
            //  at this time. This will be true until the FSMO is enlisted
            //  in the partition, which could be never if DNS is not running
            //  there.
            //

            status = Ds_RemovePrincipalAccess(
                        ldapSessionHandle( NULL ),
                        pwszNewPartitionDn,
                        NULL,                           //  principal name
                        g_pDomainAdminsSid );

            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: error %d removing ACE for Domain Admins from \n    %S\n", fn,
                    status,
                    pwszNewPartitionDn ));
                status = ERROR_SUCCESS;
            }
        }
        #endif

    }

    Done:

    ldap_memfree( pwszcrossrefDn );
    ldap_msgfree( presult );

    Ds_LdapUnbind( &ldapFsmo );

    return status;
}   //  Dp_AlterPartitionSecurity



DNS_STATUS
Dp_CreateByFqdn(
    IN      PSTR                pszDpFqdn,
    IN      DNS_DP_SECURITY     dnsDpSecurity,
    IN      BOOL                fLogErrors
    )
/*++

Routine Description:

    Create a new NDNC in the DS. The DP is not loaded, just created in the DS.

Arguments:

    pszDpFqdn -- FQDN of the NC

    dnsDpSecurity -- type of ACL modification required on the DP's crossRef
    
    fLogErrors -- if FALSE, no events will be generated on error

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "Dp_CreateByFqdn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    INT             iLength;
    INT             idx;
    PWSTR           pwszdn = NULL;
    ULONG           msgId = 0;
    PLDAP           ldapSession;
    BOOL            fcloseLdapSession = FALSE;
    BOOL            baddedNewNdnc = FALSE;

    WCHAR           instanceTypeBuffer[ 15 ];
    PWCHAR          instanceTypeVals[ 2 ] =
        {
        instanceTypeBuffer,
        NULL
        };
    LDAPModW        instanceTypeMod = 
        {
        LDAP_MOD_ADD,
        DNS_DP_ATTR_INSTANCE_TYPE,
        instanceTypeVals
        };

    PWCHAR          objectClassVals[] =
        {
        DNS_DP_OBJECT_CLASS,
        NULL
        };
    LDAPModW        objectClassMod = 
        {
        LDAP_MOD_ADD,
        DNS_ATTR_OBJECT_CLASS,
        objectClassVals
        };

    PWCHAR          descriptionVals[] =
        {
        L"Microsoft DNS Directory",
        NULL
        };
    LDAPModW        descriptionMod = 
        {
        LDAP_MOD_ADD,
        DNS_ATTR_DESCRIPTION,
        descriptionVals
        };

    LDAPModW *      modArray[] =
        {
        &instanceTypeMod,
        &objectClassMod,
        &descriptionMod,
        NULL
        };

    DNS_DEBUG( DP, (
        "%s: %s\n", fn, pszDpFqdn ));

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( pszDpFqdn );
    if ( !pszDpFqdn )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    //  Get an LDAP handle to the local server. This thread
    //  needs to be impersonating the administrator so that his
    //  credentials will be used. The DNS Server will have rights
    //  if the FSMO is not the local DC.
    //

    ldapSession = Ds_Connect(
                        LOCAL_SERVER_W,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound to local server\n", fn ));
        fcloseLdapSession = TRUE;
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to local server status=%d\n", fn,
            status ));
        goto Done;
    }

    //
    //  Format the root DN of the new NDNC.
    //

    pwszdn = Ds_ConvertFqdnToDn( pszDpFqdn );
    if ( !pwszdn )
    {
        DNS_DEBUG( DP, (
            "%s: error formulating DN from FQDN %s\n", fn, pszDpFqdn ));
        goto Done;
    }

    DNS_DEBUG( DP, (
        "%s: DN will be\n    %S\n", fn,
        pwszdn ));

    //
    //  Fill in parts of the LDAP mods not handled in init.
    //

    _itow(
        DS_INSTANCETYPE_IS_NC_HEAD | DS_INSTANCETYPE_NC_IS_WRITEABLE,
        instanceTypeBuffer,
        10 );

    //
    //  Submit request to add domainDNS object to the directory.
    //

    status = ldap_add_ext(
                ldapSession,
                pwszdn,
                modArray,
                g_pDpServerControls,
                g_pDpClientControlsNoRefs,
                &msgId );

    if ( status != LDAP_SUCCESS )
    {
        status = LdapGetLastError();
        DNS_DEBUG( DP, (
            "%s: error %lu cannot ldap_add_ext( %S )\n", fn,
            status, 
            pwszdn ));
        status = Ds_ErrorHandler(
                        status,
                        pwszdn,
                        ldapSession,
                        fLogErrors ? 0 : DNS_DS_NO_EVENTS );
        goto Done;
    }

    //
    //  Wait for the DS to complete the request. Note: this will involve
    //  binding to the forest FSMO, creating the CrossRef object, replicating
    //  the Partitions container back to the local DS, and adding the local
    //  DC to the replication scope for the new NDNC.
    //
    //  NOTE: if the object already exists, return that code directly. It
    //  is normal to try and create the object to test for it's existence.
    //

    status = Ds_CommitAsyncRequest(
                ldapSession,
                LDAP_RES_ADD,
                msgId,
                NULL );
    if ( status == LDAP_ALREADY_EXISTS )
    {
        DNS_DEBUG( DP, ( "%s: DP already exists\n", fn ));
        status = ERROR_SUCCESS;
        goto Done;
    }
    if ( status != ERROR_SUCCESS )
    {
        status = LdapGetLastError();
        DNS_DEBUG( DP, (
            "%s: error %lu from add request for %S\n", fn,
            status, 
            pwszdn ));
        status = Ds_ErrorHandler(
                        status,
                        pwszdn,
                        ldapSession,
                        fLogErrors ? 0 : DNS_DS_NO_EVENTS );

        //
        //  Replace the generic status from Ds_ErrorHandler with a
        //  status code that will evoke a somewhat helpful message
        //  from winerror.h.
        //
        
        status = DNS_ERROR_DP_FSMO_ERROR;
        goto Done;
    }

    baddedNewNdnc = TRUE;

    //
    //  Alter security on ncHead as required. This is only required 
    //  for built-in partitions. Custom partitions require admin 
    //  credentials for all operations so we don't modify the ACL.
    //

    if ( dnsDpSecurity != dnsDpSecurityDefault )
    {
        status = Dp_AlterPartitionSecurity( pwszdn, dnsDpSecurity );
    }

    //
    //  Remove built-in administrators from the ACL on the NDNC ncHead.
    //
        
#if 0
    Ds_RemovePrincipalAccess(
        ldapSession,
        pwszdn,
        NULL,                           //  principal name
        g_pBuiltInAdminsSid );
#endif

    //
    //  Cleanup and return
    //

    Done:

    if ( fcloseLdapSession )
    {
        Ds_LdapUnbind( &ldapSession );
    }

    if ( status == ERROR_SUCCESS && baddedNewNdnc )
    {
        PVOID   pargs[] = 
            {
                pszDpFqdn,
                pwszdn
            };
        BYTE    argTypeArray[] =
            {
            EVENTARG_UTF8,
            EVENTARG_UNICODE
            };

        ASSERT( pwszdn );

        DNS_LOG_EVENT(
            DNS_EVENT_DP_CREATED,
            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
            pargs,
            argTypeArray,
            status );
    }

    FREE_HEAP( pwszdn );

    DNS_DEBUG( DP, (
        "%s: returning %lu\n", fn,
        status ));
    return status;
}   //  Dp_CreateByFqdn



PDNS_DP_INFO
Dp_GetNext(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Use this function to iterate through the DP list. Pass NULL to begin
    at start of list. 

Arguments:

    pDpInfo - ptr to current list element

Return Value:

    Ptr to next element or NULL if end of list reached.

--*/
{
    if ( !SrvCfg_dwEnableDp )
    {
        return NULL;
    }

    Dp_Lock();
    
    if ( pDpInfo == NULL )
    {
        pDpInfo = ( PDNS_DP_INFO ) &g_DpList;     //  Start at list head
    }

    pDpInfo = ( PDNS_DP_INFO ) pDpInfo->ListEntry.Flink;

    if ( pDpInfo == ( PDNS_DP_INFO ) &g_DpList )
    {
        pDpInfo = NULL;     //  Hit end of list so return NULL.
    }

    Dp_Unlock();
    
    return pDpInfo;
}   //  Dp_GetNext



PDNS_DP_INFO
Dp_FindByFqdn(
    IN      LPSTR   pszFqdn
    )
/*++

Routine Description:

    Search DP list for DP with matching UTF8 FQDN.

Arguments:

    pszFqdn -- fully qualifed domain name of DP to find

Return Value:

    Pointer to matching DP or NULL.

--*/
{
    DBG_FN( "Dp_FindByFqdn" )

    PDNS_DP_INFO pDp = NULL;

    if ( pszFqdn )
    {
        //
        //  Is the name specifying a built-in partition?
        //

        if ( *pszFqdn == '\0' )
        {
            pDp = g_pLegacyDp;
            goto Done;
        }
        if ( _strnicmp( pszFqdn, "..For", 5 ) == 0 )
        {
            pDp = g_pForestDp;
            goto Done;
        }
        if ( _strnicmp( pszFqdn, "..Dom", 5 ) == 0 )
        {
            pDp = g_pDomainDp;
            goto Done;
        }
        if ( _strnicmp( pszFqdn, "..Leg", 5 ) == 0 )
        {
            pDp = g_pLegacyDp;
            goto Done;
        }

        //
        //  Search the DP list.
        //

        while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
        {
            if ( pDp->pszDpFqdn && _stricmp( pszFqdn, pDp->pszDpFqdn ) == 0 )
            {
                break;
            }
        }
    }
    else
    {
        pDp = g_pLegacyDp;
    }

    Done:

    DNS_DEBUG( DP, (
        "%s: returning %p for FQDN %s\n", fn,
        pDp,
        pszFqdn ));
    return pDp;
}   //  Dp_FindByFqdn



DNS_STATUS
Dp_AddToList(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Insert a DP info structure into the global list. Maintain the list in
    sorted order by DN.

Arguments:

    pDpInfo - ptr to element to add to list

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_AddToList" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pDpRover = NULL;
    
    Dp_Lock();

    while ( 1 )
    {
        pDpRover = Dp_GetNext( pDpRover );

        if ( pDpRover == NULL )
        {
            //  End of list, set pointer to list head.
            pDpRover = ( PDNS_DP_INFO ) &g_DpList;
            break;
        }

        ASSERT( pDpInfo->pszDpFqdn );
        ASSERT( pDpRover->pszDpFqdn );

        if ( _wcsicmp( pDpInfo->pwszDpDn, pDpRover->pwszDpDn ) < 0 )
        {
            break;
        }
    }

    ASSERT( pDpRover );

    InsertTailList(
        ( PLIST_ENTRY ) pDpRover,
        ( PLIST_ENTRY ) pDpInfo );
    InterlockedIncrement( &g_DpListEntryCount );

    Dp_Unlock();

    return status;
}   //  Dp_AddToList



DNS_STATUS
Dp_RemoveFromList(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Remove a DP from the global list. The DP is not deleted.

Arguments:

    pDpInfo - ptr to element to remove from list

    fAlreadyLocked - true if the caller already holds the DP lock

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_RemoveFromList" )

    DNS_STATUS      status = ERROR_NOT_FOUND;
    PDNS_DP_INFO    pdpRover = NULL;

    if ( !fAlreadyLocked )
    {
        Dp_Lock();
    }

    //
    //  Walk the list to ensure the DP is actually in the list.
    //

    while ( pdpRover = Dp_GetNext( pdpRover ) )
    {
        if ( pdpRover == pDpInfo )
        {
            LONG    newCount;

            RemoveEntryList( ( PLIST_ENTRY ) pdpRover );
            newCount = InterlockedDecrement( &g_DpListEntryCount );
            ASSERT( ( int ) newCount >= 0 );
            break;
        }
    }

    //
    //  If the DP was not found in the list, error.
    //

    if ( pdpRover != pDpInfo )
    {
        ASSERT( pdpRover == pDpInfo );
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Cleanup;
    }

    //
    //  NULL out global pointers if required.
    //

    if ( pDpInfo == g_pForestDp )
    {
        g_pForestDp = NULL;
    }
    else if ( pDpInfo == g_pDomainDp )
    {
        g_pDomainDp = NULL;
    }

    Cleanup:

    if ( !fAlreadyLocked )
    {
        Dp_Unlock();
    }

    return status;
}   //  Dp_RemoveFromList



VOID
freeDpInfo(
    IN      PDNS_DP_INFO        pDpInfo
    )
/*++

Routine Description:

    Frees all allocated members of the DP info structure, then frees
    the structure itself. Do not reference the DP info pointer after
    calling this function!

Arguments:

    pDpInfo -- DP info structure that will be freed.

Return Value:

    None.

--*/
{
    if ( pDpInfo == NULL )
    {
        return;
    }

    FREE_HEAP( pDpInfo->pszDpFqdn );
    FREE_HEAP( pDpInfo->pwszDpFqdn );
    FREE_HEAP( pDpInfo->pwszDpDn );
    FREE_HEAP( pDpInfo->pwszCrDn );
    FREE_HEAP( pDpInfo->pwszDnsFolderDn );
    FREE_HEAP( pDpInfo->pwszGUID );
    FREE_HEAP( pDpInfo->pwszLastUsn );
    freeStringArray( pDpInfo->ppwszRepLocDns );

    FREE_HEAP( pDpInfo );
}   //  freeDpInfo



VOID
Dp_FreeDpInfo(
    IN      PDNS_DP_INFO *      ppDpInfo
    )
/*++

Routine Description:

    Enters DP info into timeout free queue.

Arguments:

    ppDpInfo -- DP info structure that will be freed.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_FreeDpInfo" )

    if ( ppDpInfo && *ppDpInfo )
    {
        DNS_DEBUG( DP, (
            "%s: freeing %p\n"
            "    FQDN: %s\n"
            "    DN:   %S\n", fn,
            *ppDpInfo,
            ( *ppDpInfo )->pszDpFqdn,
            ( *ppDpInfo )->pwszDpDn ));

        Timeout_FreeWithFunction( *ppDpInfo, freeDpInfo );
        *ppDpInfo = NULL;
    }
}   //  Dp_FreeDpInfo



DNS_STATUS
Dp_Lock(
    VOID
    )
/*++

Routine Description:

    Lock the directory partition manager. Required to access the global list
    of directory partitions.

Arguments:

    None.

Return Value:

    None.

--*/
{
    EnterCriticalSection( &g_DpCS );
    return ERROR_SUCCESS;
}   //  Dp_Lock



DNS_STATUS
Dp_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock the directory partition manager. 

Arguments:

    None.

Return Value:

    None.

--*/
{
    LeaveCriticalSection( &g_DpCS );
    return ERROR_SUCCESS;
}   //  Dp_Unlock



PDNS_DP_INFO
Dp_LoadFromCrossRef(
    IN      PLDAP           LdapSession,
    IN      PLDAPMessage    pLdapMsg,
    IN OUT  PDNS_DP_INFO    pExistingDp,
    OUT     DNS_STATUS *    pStatus         OPTIONAL
    )
/*++

Routine Description:

    This function allocates and initializes a memory DP object
    given a search result pointing to a DP crossref object.

    If the pExistingDp is not NULL, then instead of allocating a new
    object the values for the DP are reloaded and the original DP is
    returned.

    The DP will not be loaded if it is improper system flags or
    if it is a system NC. In this case NULL will be returned but
    the error code will be ERROR_SUCCESS.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pLdapMsg -- LDAP search result pointing to DP crossref object

    pExistingDp -- DP to reload values into or NULL to allocate new NC

    pStatus -- option ptr to status code

Return Value:

    Pointer to new DP object.

--*/
{
    DBG_FN( "Dp_LoadFromCrossRef" )

    DNS_STATUS              status = DNS_ERROR_INVALID_DATA;
    PDNS_DP_INFO            pDp = NULL;
    PWSTR *                 ppwszAttrValues = NULL;
    PWSTR                   pwszCrDn = NULL;                    //  crossRef DN
    BOOL                    fIgnoreNc = TRUE;
    PWSTR                   pwszServiceName;
    BOOL                    fisEnlisted;
    PSECURITY_DESCRIPTOR    pSd;
    BOOL                    flocked = TRUE;
    PLDAPMessage            pncHeadResult = NULL;

    Dp_Lock();

    //
    //  Allocate an DP object or reuse existing DP object.
    //

    if ( pExistingDp )
    {
        pDp = pExistingDp;
    }
    else
    {
        pDp = ( PDNS_DP_INFO ) ALLOC_TAGHEAP_ZERO(
                                    sizeof( DNS_DP_INFO ),
                                    MEMTAG_DS_OTHER );
        if ( pDp == NULL )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }
    pDp->dwDeleteDetectedCount = 0;

    //
    //  Retrieve DN of the crossref object.
    //

    pwszCrDn = ldap_get_dn( LdapSession, pLdapMsg );
    ASSERT( pwszCrDn );
    if ( !pwszCrDn )
    {
        DNS_DEBUG( ANY, (
            "%s: missing DN for search entry %p\n", fn,
            pLdapMsg ));
        goto Done;
    }

    Timeout_Free( pDp->pwszCrDn );
    pDp->pwszCrDn = Dns_StringCopyAllocate_W( pwszCrDn, 0 );
    if ( !pDp->pwszCrDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    
    DNS_DEBUG( DP, (
        "%s: loading DP from crossref with DN\n    %S\n", fn,
        pwszCrDn ));

    //
    //  Retrieve the "Enabled" attribute value. If this attribute's
    //  value is "FALSE" this crossRef is in the process of being
    //  constructed and should be ignored.
    //

    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DSATTR_ENABLED );
    if ( ppwszAttrValues && *ppwszAttrValues &&
        _wcsicmp( *ppwszAttrValues, L"FALSE" ) == 0 )
    {
        DNS_DEBUG( DP, (
            "%s: ignoring DP not fully created\n    %S", fn,
            pwszCrDn ));
        goto Done;
    }
    
    //
    //  Retrieve the USN of the crossref object.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DSATTR_USNCHANGED );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing on crossref\n    %S\n", fn,
            LdapGetLastError(),
            DSATTR_USNCHANGED,
            pwszCrDn ));
        goto Done;
    }

    Timeout_Free( pDp->pwszLastUsn );
    pDp->pwszLastUsn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    if ( !pDp->pwszLastUsn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Screen out crossrefs with system flags that do not interest us.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_ATTR_SYSTEM_FLAGS );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n    %S\n", fn,
            LdapGetLastError(),
            DNS_DP_ATTR_SYSTEM_FLAGS,
            pwszCrDn ));
        goto Done;
    }

    pDp->dwSystemFlagsAttr = _wtoi( *ppwszAttrValues );
    if ( !( pDp->dwSystemFlagsAttr & FLAG_CR_NTDS_NC ) ||
        ( pDp->dwSystemFlagsAttr & FLAG_CR_NTDS_DOMAIN ) )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring crossref with %S=0x%X with DN\n    %S\n", fn,
            DNS_DP_ATTR_SYSTEM_FLAGS,
            pDp->dwSystemFlagsAttr,
            pwszCrDn ));
        goto Done;
    }

    //
    //  Screen out the Schema and Configuration NCs.
    //

    if ( wcsncmp(
            pwszCrDn,
            DNS_DP_SCHEMA_DP_STR,
            DNS_DP_SCHEMA_DP_STR_LEN ) == 0 ||
         wcsncmp(
            pwszCrDn,
            DNS_DP_CONFIG_DP_STR,
            DNS_DP_CONFIG_DP_STR_LEN ) == 0 )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring system crossref with DN\n    %S\n", fn,
            pwszCrDn ));
        goto Done;
    }

    //
    //  Retrieve the crossRef security descriptor.
    //

    pSd = Ds_ReadSD( LdapSession, pLdapMsg );
    Timeout_Free( pDp->pCrSd );
    pDp->pCrSd = pSd;

    //
    //  Retrieve the root DN of the DP data.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_ATTR_NC_NAME );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n    %S\n", fn,
            LdapGetLastError(),
            DNS_DP_ATTR_NC_NAME,
            pwszCrDn ));
        goto Done;
    }
    Timeout_Free( pDp->pwszDpDn );
    pDp->pwszDpDn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    IF_NOMEM( !pDp->pwszDpDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    fIgnoreNc = FALSE;

#if 0
    //
    //  Retrieve the GUID of the NC.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_ATTR_OBJECT_GUID );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n    %S\n", fn,
            LdapGetLastError(),
            DNS_ATTR_OBJECT_GUID,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    pDp->pwszGUID = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    IF_NOMEM( !pDp->pwszGUID )
    {
        status = DNS_ERROR_NO_MEMORY
        goto Done;
    }
#endif

    //
    //  Retrieve the DNS root (FQDN) of the NC.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_DNS_ROOT );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n    %S\n", fn,
            LdapGetLastError(),
            DNS_DP_DNS_ROOT,
            pwszCrDn ));
        goto Done;
    }

    Timeout_Free( pDp->pwszDpFqdn );
    pDp->pwszDpFqdn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    IF_NOMEM( !pDp->pwszDpFqdn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    Timeout_Free( pDp->pszDpFqdn );
    pDp->pszDpFqdn = Dns_StringCopyAllocate(
                            ( PCHAR ) *ppwszAttrValues,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );
    IF_NOMEM( !pDp->pszDpFqdn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Retrieve the replication locations of this NC. Each value is the
    //  DN of the NTDS Settings object under the server object in the 
    //  Sites container.
    //
    //  NOTE: it is possible for this attribute to have no values if all
    //  replicas have been removed. Load the DP anyways so that it can
    //  be re-enlisted.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = Ds_GetRangedAttributeValues(
                            LdapSession,
                            pLdapMsg,
                            pwszCrDn,
                            DNS_DP_ATTR_REPLICAS,
                            NULL,
                            NULL,
                            &status );
    if ( status != ERROR_SUCCESS && status != LDAP_NO_SUCH_ATTRIBUTE )
    {
        DNS_DEBUG( ANY, (
            "%s: error reading replica values (error=%d)\n    %S\n", fn,
            status,
            pwszCrDn ));
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Done;
    }
    Timeout_FreeWithFunction( pDp->ppwszRepLocDns, freeStringArray );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: this crossref has no replicas (error=%d)\n    %S\n", fn,
            status,
            pwszCrDn ));
        pDp->ppwszRepLocDns = NULL;
    }
    else
    {
        pDp->ppwszRepLocDns = ppwszAttrValues;
        ppwszAttrValues = NULL;

        IF_DEBUG( DP )
        {
            int i;

            DNS_DEBUG( DP, (
                "Replicas for: %s\n",
                pDp->pszDpFqdn ) );
            
            for ( i = 0; pDp->ppwszRepLocDns[ i ]; ++i )
            {
                DNS_DEBUG( DP, (
                    "    replica %04d %S\n",
                    i,
                    pDp->ppwszRepLocDns[ i ] ) );
            }
        }
    }

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = NULL;

    //
    //  See if the local DS has a replica of this NC.
    //

    fisEnlisted = FALSE;
    ASSERT( DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal );
    pwszServiceName = DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal;
    if ( pwszServiceName && pDp->ppwszRepLocDns )
    {
        PWSTR *         pwszValue;

        for ( pwszValue = pDp->ppwszRepLocDns; *pwszValue; ++pwszValue )
        {
            if ( wcscmp( *pwszValue, pwszServiceName ) == 0 )
            {
                fisEnlisted = TRUE;
                pDp->dwFlags |= DNS_DP_ENLISTED;
                break;
            }
        }
    }

    DNS_DEBUG( DP, (
        "%s: enlisted=%d for DP %s\n", fn,
        fisEnlisted,
        pDp->pszDpFqdn ) );

    if ( !fisEnlisted )
    {
        pDp->dwFlags &= ~DNS_DP_ENLISTED;
    }

    //
    //  DP has been successfully loaded from crossRef.
    //

    pDp->dwFlags &= ~DNS_DP_DELETED;
    fIgnoreNc = FALSE;
    status = ERROR_SUCCESS;
    pDp->State = DNS_DP_STATE_OKAY;

    if ( IS_DP_ENLISTED( pDp ) )
    {
        struct berval **    ppberval = NULL;
        
        //
        //  Load attributes from the partition's NC head object.
        //

        pncHeadResult = DS_LoadOrCreateDSObject(
                                LdapSession,
                                pDp->pwszDpDn,              //  DN
                                NULL,                       //  object class
                                FALSE,                      //  create
                                NULL,                       //  created flag
                                &status );
        if ( !pncHeadResult )
        {
            //  Couldn't find NC head! Very bad - mark DP unavailable.

            pDp->State = DNS_DP_STATE_UNKNOWN;
            status = DNS_ERROR_DP_NOT_AVAILABLE;
            ASSERT( pncHeadResult );
            goto Done;
        }

#if 0
        //
        //  December 2002: According to Will and Brett this is no 
        //  longer required. The DS_INSTANCETYPE_NC_COMING bit will remain
        //  set until the first sync. The repluptodate vector does not
        //  tell us the information we need to know.
        //
        
        //
        //  See if this partition has completed a full sync. If the partition
        //  has not completed a full sync we must ignore it for the time being.
        //  This prevents us from loading zones from the NDNC that are incomplete
        //  when the NDNC is first added to this DC.
        //
        
        if ( DP_HAS_MORE_THAN_ONE_REPLICA( pDp ) )
        {
            ppberval = ldap_get_values_len(
                                LdapSession,
                                pncHeadResult, 
                                DNS_DP_ATTR_REPLUPTODATE );
            if ( !ppberval )
            {
                DWORD   err = LdapGetLastError();
                DNS_DEBUG( DP, (
                    "%s: ignoring DP not in sync\n    %S\n", fn,
                    pwszCrDn ));
                status = DNS_ERROR_DP_NOT_AVAILABLE;
                goto Done;
            }
            ldap_value_free_len( ppberval );
        }
#endif
        
        //
        //  Read instanceType. If no values, assume okay.
        //

        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                            LdapSession,
                            pLdapMsg, 
                            DNS_DP_ATTR_INSTANCE_TYPE );
        if ( ppwszAttrValues && *ppwszAttrValues )
        {
            UINT    instanceType = wcstol( *ppwszAttrValues, NULL, 10 );
            
            if ( instanceType & DS_INSTANCETYPE_NC_COMING )
            {
                pDp->State = DNS_DP_STATE_REPL_INCOMING;
            }
            else if ( instanceType & DS_INSTANCETYPE_NC_GOING )
            {
                pDp->State = DNS_DP_STATE_REPL_OUTGOING;
            }
        }
    }

    //
    //  If the DP has been marked not available it should be ignored.
    //
    
    if ( !IS_DP_AVAILABLE( pDp ) )
    {
        status = DNS_ERROR_DP_NOT_AVAILABLE;
        goto Done;
    }
    
    //
    //  Examine the values loaded and set appropriate flags and globals.
    //

    ASSERT( pDp->pszDpFqdn );

    if ( g_pszDomainDefaultDpFqdn &&
         _stricmp( g_pszDomainDefaultDpFqdn, pDp->pszDpFqdn ) == 0 )
    {
        g_pDomainDp = pDp;
        pDp->dwFlags |= DNS_DP_DOMAIN_DEFAULT | DNS_DP_AUTOCREATED;
        DNS_DEBUG( DP, (
            "%s: found domain partition %s %p\n", fn,
            g_pszDomainDefaultDpFqdn,
            g_pDomainDp ));
    }
    else if ( g_pszForestDefaultDpFqdn &&
              _stricmp( g_pszForestDefaultDpFqdn, pDp->pszDpFqdn ) == 0 )
    {
        g_pForestDp = pDp;
        pDp->dwFlags |= DNS_DP_FOREST_DEFAULT | DNS_DP_AUTOCREATED;
        DNS_DEBUG( DP, (
            "%s: found forest partition %s %p\n", fn,
            g_pszForestDefaultDpFqdn,
            g_pForestDp ));
    }
    else
    {
        //  Make sure built-in DP flags are turned off.

        pDp->dwFlags &= ~( DNS_DP_FOREST_DEFAULT |
                           DNS_DP_DOMAIN_DEFAULT |
                           DNS_DP_AUTOCREATED );
    }
    
    status = ERROR_SUCCESS;
    
    //
    //  If this is a built-in partition, modify the security descriptor
    //  if it is missing appropriate ACEs.
    //

    if ( IS_DP_FOREST_DEFAULT( pDp ) || IS_DP_DOMAIN_DEFAULT( pDp ) )
    {
        if ( !SD_DoesPrincipalHasAce(
                    NULL,
                    IS_DP_FOREST_DEFAULT( pDp )
                        ? g_pEnterpriseDomainControllersSid
                        : g_pDomainControllersSid,
                    pDp->pCrSd ) )
        {
            Dp_AlterPartitionSecurity(
                pDp->pwszDpDn,
                IS_DP_FOREST_DEFAULT( pDp )
                    ? dnsDpSecurityForest
                    : dnsDpSecurityDomain );
        }
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    ldap_msgfree( pncHeadResult );

    if ( pDp && !pExistingDp && ( status != ERROR_SUCCESS || fIgnoreNc ) )
    {
        Dp_FreeDpInfo( &pDp );
    }

    if ( fIgnoreNc )
    {
        status = ERROR_SUCCESS;
    }

    #if DBG
    if ( pDp )
    {
        Dbg_DumpDp( NULL, pDp );
    }
    #endif
    
    if ( flocked )
    {
        Dp_Unlock();
    }

    DNS_DEBUG( DP, (
        "%s: returning %p status %d for crossref object with DN:\n    %S\n", fn,
        pDp,
        status,
        pwszCrDn ));

    ldap_memfree( pwszCrDn );
    ldap_value_free( ppwszAttrValues );

    if ( pStatus )
    {
        *pStatus = status;
    }

    return pDp;
}   //  Dp_LoadFromCrossRef



DNS_STATUS
Dp_LoadOrCreateMicrosoftDnsObject(
    IN      PLDAP           LdapSession,
    IN OUT  PDNS_DP_INFO    pDp,
    IN      BOOL            fCreate
    )
/*++

Routine Description:

    This function reads and optionally creates the MicrosoftDNS
    container in the directory partition.
    
    If fCreate is TRUE, the partition will be created if missing.
    
    If the container is created or already exists the DN and SD
    fields of the DP will be filled in.
    
    If the MicrosoftDNS container is missing and not created both
    the DN and SD fields in the DP will be NULL.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session
    
    pDp -- directory partition to operate on
    
    fCreate -- create if missing

Return Value:

    Error code.

--*/
{
    DBG_FN( "Dp_LoadOrCreateMicrosoftDnsObject" )

    DNS_STATUS              status = ERROR_SUCCESS;
    PLDAPMessage            presult = NULL;
    PSECURITY_DESCRIPTOR    psd;

    ASSERT( pDp );
    
    if ( !pDp )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    
    if ( !IS_DP_ENLISTED( pDp ) )
    {
        status = DNS_ERROR_DP_NOT_ENLISTED;
        goto Done;
    }

    if ( !IS_DP_AVAILABLE( pDp ) )
    {
        status = DNS_ERROR_DP_NOT_AVAILABLE;
        goto Done;
    }

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    pDp->pwszDnsFolderDn = microsoftDnsFolderDn( pDp );                
    IF_NOMEM( !pDp->pwszDnsFolderDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    
    presult = DS_LoadOrCreateDSObject(
                    LdapSession,
                    pDp->pwszDnsFolderDn,       //  DN
                    DNS_DP_DNS_FOLDER_OC,       //  object class
                    fCreate,                    //  create
                    NULL,                       //  created flag
                    &status );
    if ( status != ERROR_SUCCESS )
    {
        //
        //  Can't find container. This is okay in the no-create case.
        //

        DNS_DEBUG( DP, (
            "%s: error %lu creating DNS folder\n"
            "    DN: %S\n", fn,
            status,
            pDp->pwszDnsFolderDn ));
        FREE_HEAP( pDp->pwszDnsFolderDn );
        pDp->pwszDnsFolderDn = NULL;
        if ( !fCreate )
        {
            status = ERROR_SUCCESS;
        }
    }
    else
    {
        ASSERT( presult );
        
        if ( !presult )
        {
            status = ERROR_INVALID_DATA;
            goto Done;
        }
        
        #if 0

        //
        //  This interferes with the DS propogation of ACLs somehow.
        //
        
        //
        //  Found or created the MicrosoftDNS folder. Make sure it has
        //  appropriate permissions.
        //  

        if ( IS_DP_FOREST_DEFAULT( pDp ) )
        {
            //
            //  Forest partition - remove domain admins from ACL and
            //  add Enterprise Domain Adminds to ACL.
            //

            status = Ds_RemovePrincipalAccess(
                        LdapSession,
                        pDp->pwszDnsFolderDn,
                        DNS_GROUP_DOMAIN_ADMINS );  //  NOTE: MUST USE SID NOT NAME
            DNS_DEBUG( DP, (
                "%s: error %d removing ACE for %S from\n    %S\n", fn,
                status,
                DNS_GROUP_DOMAIN_ADMINS,
                pDp->pwszDnsFolderDn ));
            ASSERT( status == ERROR_SUCCESS );
            status = ERROR_SUCCESS;

            status = Ds_AddPrincipalAccess(
                            LdapSession,
                            pDp->pwszDnsFolderDn,
                            g_pEnterpriseAdminsSid,
                            NULL,           //  principal name
                            GENERIC_ALL,
                            CONTAINER_INHERIT_ACE,
                            TRUE,			//	whack existing ACE
                            FALSE );		//	take ownership
            DNS_DEBUG( DP, (
                "%s: error %d adding ACE for Enterprise Admins from\n    %S\n", fn,
                status,
                pDp->pwszDnsFolderDn ));
            ASSERT( status == ERROR_SUCCESS );
            status = ERROR_SUCCESS;
        }
        else
        {
            //
            //  Domain or custom partition: add DnsAdmins to ACL.
            //

            //  JJW: We are doing this too frequently!

            status = Ds_AddPrincipalAccess(
                            LdapSession,
                            pDp->pwszDnsFolderDn,
                            NULL,           //  SID
                            SZ_DNS_ADMIN_GROUP_W,
                            GENERIC_ALL,
                            CONTAINER_INHERIT_ACE,
                            TRUE,			//	whack existing ACE
                            FALSE );		//	take ownership
            DNS_DEBUG( DP, (
                "%s: error %d adding ACE for %S to\n    %S\n", fn,
                status,
                SZ_DNS_ADMIN_GROUP_W,
                pDp->pwszDnsFolderDn ));
            ASSERT( status == ERROR_SUCCESS );
            status = ERROR_SUCCESS;
        }
        #endif

        //
        //  We don't want authenticated users having any permissions by 
        //  default on the MicrosoftDNS container. 
        //
        
        Ds_RemovePrincipalAccess(
            LdapSession,
            pDp->pwszDnsFolderDn,
            NULL,                           //  principal name
            g_pAuthenticatedUserSid );

        //
        //  Load the security descriptor from the MicrosoftDNS folder
        //  of the DP. This will be used to control zone creation (and
        //  perhaps other operations in the future.
        //

        psd = Ds_ReadSD( LdapSession, presult );
        if ( psd )
        {
            Timeout_Free( pDp->pMsDnsSd );
            pDp->pMsDnsSd = psd;
        }
    }

    Done:
    
    ldap_msgfree( presult );

    DNS_DEBUG( DP, (
        "%s: returning %d for DP %s\n", fn,
        status,
        pDp ? pDp->pszDpFqdn : NULL ));
    return status;
}   //  Dp_LoadOrCreateMicrosoftDnsObject



DNS_STATUS
Dp_PollForPartitions(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollFlags
    )
/*++

Routine Description:

    This function scans the DS for cross-ref objects and modifies
    the current memory DP list to match.

    New DPs are added to the list. DPs that have been delete are
    marked deleted. The zones in these DPs must be unloaded before
    the DP can be removed from the list.
    
    DPs which are replicated on the local DS are marked ENLISTED.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session
    
    dwPollFlags -- flags that modify polling operation

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_PollForPartitions" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DS_SEARCH       searchBlob;
    PWSTR           pwszServiceName ;
    PLDAPSearch     psearch;
    DWORD           dwsearchTime;
    WCHAR           wszPartitionsDn[ MAX_DN_PATH + 1 ];
    PWSTR           pwszCrDn = NULL;        //  crossRef DN
    PDNS_DP_INFO    pDp;
    PWSTR *         ppwszAttrValues = NULL;
    PWSTR *         pwszValue;
    PWSTR           pwsz;
    DWORD           dwCurrentVisitTime;
    PLDAP_BERVAL *  ppbvals = NULL;
    static LONG     functionLock = 0;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl_DGO,
        NULL
    };

    if ( InterlockedIncrement( &functionLock ) != 1 )
    {
        DNS_DEBUG( DP, (
            "%s: another thread is already polling\n", fn ));
        goto Done;
    }

    if ( !SrvCfg_dwEnableDp ||
         !Ds_IsDsServer() ||
         ( SrvCfg_fBootMethod != BOOT_METHOD_DIRECTORY &&
           SrvCfg_fBootMethod != BOOT_METHOD_REGISTRY ) )
    {
        goto Done;
    }

    DNS_DEBUG( DP, (
        "%s: polling flags = %04X\n", fn, dwPollFlags ));

    if ( !( dwPollFlags & DNS_DP_POLL_FORCE ) &&
         DNS_TIME() < g_dwLastPartitionPollTime + DP_MAX_PARTITION_POLL_FREQ )
    {
        DNS_DEBUG( DP, (
            "%s: polled too recently\n"
            "    last poll =            %d\n"
            "    current time =         %d\n"
            "    allowed frequency =    %d seconds\n", fn,
            g_dwLastPartitionPollTime,
            DNS_TIME(),
            DP_MAX_PARTITION_POLL_FREQ ));
        goto Done;
    }

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    Ds_InitializeSearchBlob( &searchBlob );

    dwCurrentVisitTime = g_dwLastPartitionPollTime = UPDATE_DNS_TIME();

    //
    //  Service name is a DN value identifying the local DS. We will
    //  use this value to determine if the local DS is in the replication
    //  scope of an DP later.
    //

    ASSERT( DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal );
    pwszServiceName = DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal;

    //
    //  Reload the FSMO location global variable in case it has changed.
    //  If we can't get the FSMO information, leave the globals NULL - this
    //  is not fatal at this point.
    //

    getPartitionsContainerDn(
        wszPartitionsDn,
        sizeofarray( wszPartitionsDn ) );

    if ( *wszPartitionsDn );
    {
        PLDAPMessage            presult = NULL;
        PLDAPMessage            pentry;
        PDNS_DS_SERVER_OBJECT   pnewFsmoServer;

        //
        //  Get entry for Partitions container.
        //

        status = ldap_search_ext_s(
                    LdapSession,
                    wszPartitionsDn,
                    LDAP_SCOPE_BASE,
                    NULL,                   //  filter
                    NULL,                   //  attrs
                    FALSE,                  //  attrsonly
                    ctrls,                  //  server controls
                    NULL,                   //  client controls
                    &g_LdapTimeout,         //  time limit
                    0,                      //  size limit
                    &presult );
        if ( status != LDAP_SUCCESS )
        {
            goto DoneFsmo;
        }

        pentry = ldap_first_entry( LdapSession, presult );
        if ( !pentry )
        {
            goto DoneFsmo;
        }

        //
        //  Reload the forest behavior version.
        //

        ppwszAttrValues = ldap_get_values(
                                LdapSession,
                                pentry, 
                                DSATTR_BEHAVIORVERSION );
        if ( ppwszAttrValues && *ppwszAttrValues )
        {
            SetDsBehaviorVersion( Forest, ( DWORD ) _wtoi( *ppwszAttrValues ) );
            DNS_DEBUG( DS, (
                "%s: forest %S = %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_ulDsForestVersion ));
        }

        //
        //  Get value of FSMO attribute.
        //
        
        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                                LdapSession,
                                pentry, 
                                DNS_ATTR_FSMO_SERVER );
        if ( !ppwszAttrValues || !*ppwszAttrValues )
        {
            DNS_DEBUG( ANY, (
                "%s: error %lu %S value missing from server object\n    %S\n", fn,
                LdapGetLastError(),
                DNS_ATTR_FSMO_SERVER,
                wszPartitionsDn ));
            ASSERT( ppwszAttrValues && *ppwszAttrValues );
            goto DoneFsmo;
        }

        //
        //  Create a new server FSMO server object.
        //

        pnewFsmoServer = readServerObjectFromDs(
                                LdapSession,
                                *ppwszAttrValues,
                                &status );
        if ( status != ERROR_SUCCESS )
        {
            goto DoneFsmo;
        }
        ASSERT( pnewFsmoServer );

        Dp_Lock();
        Timeout_FreeWithFunction( g_pFsmo, freeServerObject );
        g_pFsmo = pnewFsmoServer;
        Dp_Unlock();

        //
        //  Cleanup FSMO load attempt.
        //
                
        DoneFsmo:

        ldap_value_free( ppwszAttrValues );
		ppwszAttrValues = NULL;

        ldap_msgfree( presult );

        DNS_DEBUG( DP, (
            "%s: FSMO %S status=%d\n", fn,
            g_pFsmo ? g_pFsmo->pwszDnsHostName : L"UNKNOWN", 
            status ));
        status = ERROR_SUCCESS;     //  Don't care if we failed FSMO lookup.
    }

    //
    //  Open a search for cross-ref objects.
    //

    DS_SEARCH_START( dwsearchTime );

    psearch = ldap_search_init_page(
                    LdapSession,
                    wszPartitionsDn,
                    LDAP_SCOPE_ONELEVEL,
                    g_szCrossRefFilter,
                    g_CrossRefDesiredAttrs,
                    FALSE,                      //  attrs only flag
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  sort keys

    DS_SEARCH_STOP( dwsearchTime );

    if ( !psearch )
    {
        DWORD       dwldaperr = LdapGetLastError();

        DNS_DEBUG( ANY, (
            "%s: search open error %d\n", fn,
            dwldaperr ));
        status = Ds_ErrorHandler( dwldaperr, wszPartitionsDn, LdapSession, 0 );
        goto Cleanup;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate through crossref search results.
    //

    while ( 1 )
    {
        PLDAPMessage    pldapmsg;
        PDNS_DP_INFO    pExistingDp = NULL;
        BOOL            fEnlisted = FALSE;

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( ANY, (
                "%s: search error %d\n", fn,
                status ));
            goto Cleanup;
        }

        if ( dwPollFlags & DNS_DP_POLL_NOTIFYSCM )
        {
            Service_LoadCheckpoint();
        }

        pldapmsg = searchBlob.pNodeMessage;

        //
        //  Retrieve DN of the crossref object.
        //

        ldap_memfree( pwszCrDn );
        pwszCrDn = ldap_get_dn( LdapSession, pldapmsg );
        ASSERT( pwszCrDn );
        if ( !pwszCrDn )
        {
            DNS_DEBUG( ANY, (
                "%s: missing DN for search entry %p\n", fn,
                pldapmsg ));
            continue;
        }

        //
        //  Search the DP list for matching DN.
        //
        //  DEVNOTE: could optimize list insertion by adding optional 
        //  insertion point argument to Dp_AddToList().
        //

        while ( ( pExistingDp = Dp_GetNext( pExistingDp ) ) != NULL )
        {
            if ( wcscmp( pwszCrDn, pExistingDp->pwszCrDn ) == 0 )
            {
                DNS_DEBUG( DP, (
                    "%s: found existing match for crossref\n    %S\n", fn,
                    pwszCrDn ));
                break;
            }
        }

        if ( pExistingDp )
        {
            //
            //  This DP is already in the list. Adjust it's status.
            //

            if ( IS_DP_DELETED( pExistingDp ) )
            {
                DNS_DEBUG( DP, (
                    "%s: reactivating deleted DP\n"
                    "    crossRef = %S\n", fn,
                    pwszCrDn ));
            }
            Dp_LoadFromCrossRef(
                        LdapSession,
                        pldapmsg,
                        pExistingDp,
                        &status );
            pExistingDp->dwLastVisitTime = dwCurrentVisitTime;
            pExistingDp->dwDeleteDetectedCount = 0;
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: error %lu reloading existing NC\n"
                    "    %S\n", fn,
                    status,
                    pwszCrDn ));
                continue;
            }
        }
        else
        {
            //
            //  This is a brand new DP. Add it to the list.
            //

            DNS_DEBUG( DP, (
                "%s: no match for crossref, loading from DS\n    %S\n", fn,
                pwszCrDn ));

            pDp = Dp_LoadFromCrossRef(
                        LdapSession,
                        pldapmsg,
                        NULL,
                        &status );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: error %lu loading new NC\n"
                    "\n  DN: %S\n", fn,
                    status,
                    pwszCrDn ));
                continue;
            }
            if ( !pDp )
            {
                continue;   //  DP is not loadable (probably a system NC).
            }

            if ( IS_DP_ENLISTED( pDp ) )
            {
                //
                //  Load the SD on the MicrosoftDNS container. If the 
                //  container is missing ignore that for now. The container 
                //  will be missing on non-DNS NDNCs and can also be missing 
                //  if the admin deleted it manually. In that case we will
                //  recreate it on zone creation.
                //
                
                Dp_LoadOrCreateMicrosoftDnsObject(
                    LdapSession,
                    pDp,
                    FALSE );                //  create flag
            }
            else
            {
                //
                //  This is a partition we haven't seen before and 
                //  currently the local DS is  not enlisted in the 
                //  replication scope for the partition. If this is
                //  a built-in DP, we need to add ourselves.
                //

                if ( ( IS_DP_FOREST_DEFAULT( pDp ) ||
                       IS_DP_DOMAIN_DEFAULT( pDp ) ) &&
                     !( dwPollFlags & DNS_DP_POLL_NOAUTOENLIST ) )
                {
                    Dp_ModifyLocalDsEnlistment( pDp, TRUE );
                }
            }

            //
            //  Mark DP visited and add it to the list.
            //

            pDp->dwLastVisitTime = dwCurrentVisitTime;
            pDp->dwDeleteDetectedCount = 0;
            Dp_AddToList( pDp );
            pExistingDp = pDp;
            pDp = NULL;
        }
    }

    //
    //  Mark any DPs we didn't find as deleted.
    //

    pDp = NULL;
    while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
    {
        if ( pDp->dwLastVisitTime != dwCurrentVisitTime )
        {
            DNS_DEBUG( DP, (
                "%s: found deleted DP with DN\n    %S\n", fn,
                pDp->pwszDpDn ));
            pDp->dwFlags |= DNS_DP_DELETED;
        }
    }
    
    Dp_MigrateDcpromoZones( dwPollFlags & DNS_DP_POLL_FORCE );

    //
    //  Cleanup and exit.
    //

    Cleanup:

    ldap_memfree( pwszCrDn );
    ldap_value_free( ppwszAttrValues );

    Ds_CleanupSearchBlob( &searchBlob );
    
    Done:
    
    InterlockedDecrement( &functionLock );

    DNS_DEBUG( DP, (
        "%s: returning %lu=0x%X\n", fn,
        status, status ));
    return status;
}   //  Dp_PollForPartitions



DNS_STATUS
Dp_ScanDpForZones(
    IN      PLDAP           LdapSession,
    IN      PDNS_DP_INFO    pDp,
    IN      BOOL            fNotifyScm,
    IN      BOOL            fLoadZonesImmediately,
    IN      DWORD           dwVisitStamp
    )
/*++

Routine Description:

    This routine scans a single directory partition for zones. 

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pDp -- directory parition to search for zones

    fNotifyScm -- if TRUE ping SCM before loading each zone

    fLoadZonesImmediately -- if TRUE load zone when found, if FALSE, 
                             caller must load zone later

    dwVisitStamp -- each zone visited will be stamped with this time

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_ScanDpForZones" )

    PLDAPSearch     psearch;
    DS_SEARCH       searchBlob;
    DWORD           searchTime;
    DNS_STATUS      status = ERROR_SUCCESS;

    PLDAPControl    ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        &NoDsSvrReferralControl,
        NULL
    };
    
    if ( !SrvCfg_dwEnableDp ||
         !Ds_IsDsServer() ||
         SrvCfg_fBootMethod != BOOT_METHOD_DIRECTORY )
    {
        return ERROR_SUCCESS;
    }

    Ds_InitializeSearchBlob( &searchBlob );

    DNS_DEBUG( DP, (
        "%s( %s )\n", fn,
        pDp ? pDp->pszDpFqdn : "NULL" ));

    //
    //  If we have no DP or it is not available, do nothing.
    //
    
    if ( !pDp || !IS_DP_AVAILABLE( pDp ) )
    {
        goto Cleanup;
    }

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Cleanup;
    }

    //
    //  Open LDAP search.
    //

    DS_SEARCH_START( searchTime );
    psearch = ldap_search_init_page(
                    pServerLdap,
                    pDp->pwszDpDn,
                    LDAP_SCOPE_SUBTREE,
                    g_szDnsZoneFilter,
                    DsTypeAttributeTable,
                    FALSE,                      //  attrs only
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  no sort
    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler(
                        LdapGetLastError(),
                        g_pwszDnsContainerDN,
                        pServerLdap,
                        0 );
        goto Cleanup;
    }
    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate the search results.
    //

    while ( 1 )
    {
        PZONE_INFO      pZone = NULL;
        PZONE_INFO      pExistingZone = NULL;

        if ( fNotifyScm )
        {
            Service_LoadCheckpoint();
        }

        //
        //  Process the next zone.
        //

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
            }
            else
            {
                DNS_DEBUG( ANY, (
                    "%s: Ds_GetNextMessageInSearch for zones failed\n", fn ));
            }
            break;
        }

        //
        //  Attempt to create the zone. If the zone already exists, set
        //  the zone's visit timestamp.
        //

        status = Ds_CreateZoneFromDs(
                    searchBlob.pNodeMessage,
                    pDp,
                    &pZone,
                    &pExistingZone );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNS_ERROR_ZONE_ALREADY_EXISTS )
            {
                //
                //  The zone already exists. If it is in the current
                //  DP then everything is okay but if it is in another
                //  DP (or if it is file-backed) then we have a zone
                //  conflict and an event must be logged.
                //

                if ( pExistingZone )
                {
                    if ( !pExistingZone->pDpInfo &&
                        IS_ZONE_DSINTEGRATED( pExistingZone ) )
                    {
                        //  Make sure we have a valid DP pointer.
                        pExistingZone->pDpInfo = g_pLegacyDp;
                    }

                    if ( pExistingZone->pDpInfo == pDp )
                    {
                        pExistingZone->dwLastDpVisitTime = dwVisitStamp;
                    }
                    
                    //
                    //  Zone conflict: log an event if we are not loading
                    //  zones immediately (this indicates server startup).
                    //
                    
                    else if ( !fLoadZonesImmediately )
                    {
                        PWSTR   pargs[] = 
                            {
                                pExistingZone->pwsZoneName,
                                displayNameForZoneDp( pExistingZone ),
                                displayNameForDp( pDp )
                            };

                        Ec_LogEvent(
                            pExistingZone->pEventControl,
                            DNS_EVENT_DP_ZONE_CONFLICT,
                            pExistingZone,
                            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
                            pargs,
                            EVENTARG_ALL_UNICODE,
                            status );
                    }
                }

                //  Without the existing zone pointer we don't have conflict
                //  details at hand and can't log an event without doing 
                //  extra work.
                ASSERT( pExistingZone );
            }
            else
            {
                //  JJW must log event!
                DNS_DEBUG( ANY, (
                    "%s: error %lu creating zone\n", fn, status ));
            }
            continue;
        }

        //
        //  Set zone's DP visit member so after enumeration we can find zones
        //  that have been deleted from the DS.
        //

        if ( pZone )
        {
            SET_ZONE_VISIT_TIMESTAMP( pZone, dwVisitStamp );
        }

        //
        //  Load the new zone now if required.
        //

        if ( fLoadZonesImmediately || IS_ZONE_ROOTHINTS( pZone ) )
        {
            status = Zone_Load( pZone );

            if ( status == ERROR_SUCCESS )
            {
                //
                //  What the heck? Zone_Load explicity unlocks the zone but
                //  this code (and other code!) says it should be locked
                //  after load for some screwy reason.
                //

                if ( IS_ZONE_LOCKED_FOR_UPDATE( pZone ) )
                {
                    Zone_UnlockAfterAdminUpdate( pZone );
                }

                //
                //  Zone_Load does not activate the roothint zone.
                //

                if ( IS_ZONE_ROOTHINTS( pZone ) )
                {
                    if ( Zone_LockForAdminUpdate( pZone ) )
                    {
                        Zone_ActivateLoadedZone( pZone );
                        Zone_UnlockAfterAdminUpdate( pZone );
                    }
                    else
                    {
                        DNS_DEBUG( DP, (
                            "%s: could not lock roothint zone for update\n", fn,
                            status ));
                        ASSERT( FALSE );
                    }
                }

            }
            else
            {
                //
                //  Unable to load zone - delete it from memory.
                //

                DNS_DEBUG( DP, (
                    "%s: error %lu loading zone\n", fn,
                    status ));

                ASSERT( IS_ZONE_SHUTDOWN( pZone ) );
                Zone_Delete( pZone, 0 );
            }
        }
    }

    //
    //  Cleanup and return.
    //

    Cleanup:

    Ds_CleanupSearchBlob( &searchBlob );

    DNS_DEBUG( DP, (
        "%s: returning %lu (0x%08X)\n", fn,
        status, status ));
    return status;
}   //  Dp_ScanDpForZones



DNS_STATUS
Dp_BuildZoneList(
    IN      PLDAP           LdapSession
    )
/*++

Routine Description:

    This scans all of the directory partitions in the global DP list
    for zones and adds the zones to the zone list.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_BuildZoneList" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pdp = NULL;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    //
    //  Iterate DP list, loading zone info from each.
    //

    while ( ( pdp = Dp_GetNext( pdp ) ) != NULL )
    {
        if ( !IS_DP_ENLISTED( pdp ) || IS_DP_DELETED( pdp ) )
        {
            continue;
        }

        Dp_ScanDpForZones(
            LdapSession,
            pdp,            //  directory partition
            TRUE,           //  notify SCM
            FALSE,          //  load immediately
            0 );            //  visit stamp
    }

    DNS_DEBUG( DP, (
        "%s: returning %d=0x%X\n", fn,
        status, status ));
    return status;
}   //  Dp_BuildZoneList



DNS_STATUS
Dp_ModifyLocalDsEnlistment(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fEnlist
    )
/*++

Routine Description:

    Modify the replication scope of the specified DP to include or exclude
    the local DS.

    To make any change to the crossref object, we must bind to the enterprise
    domain naming FSMO. 

Arguments:

    pDpInfo - modify replication scope of this directory partition

    fEnlist - TRUE to enlist local DS, FALSE to unenlist local DS

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_ModifyLocalDsEnlistment" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP           ldapSession;
    BOOL            fcloseLdapSession = FALSE;
    BOOL            fhaveDpLock = FALSE;
    BOOL            ffsmoWasUnavailable = FALSE;
    BOOL            flogEnlistEvent = TRUE;

    //
    //  Prepare mod structure.
    //

    PWCHAR          replLocVals[] =
        {
        DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal,
        NULL
        };
    LDAPModW        replLocMod = 
        {
        fEnlist ? LDAP_MOD_ADD : LDAP_MOD_DELETE,
        DNS_DP_ATTR_REPLICAS,
        replLocVals
        };
    LDAPModW *      modArray[] =
        {
        &replLocMod,
        NULL
        };

    ASSERT( replLocVals[ 0 ] != NULL );

    DNS_DEBUG( DP, (
        "%s: %s enlistment in %S with CR\n    %S\n", fn,
        fEnlist ? "adding" : "removing", 
        pDpInfo ? pDpInfo->pwszDpFqdn : NULL,
        pDpInfo ? pDpInfo->pwszCrDn : NULL ));

    #if DBG
    IF_DEBUG( DP )
    {
        Dbg_CurrentUser( ( PCHAR ) fn );
    }
    #endif

    //
    //  For built-in partitions, only enlistment is allowed.
    //

    if ( ( pDpInfo == g_pDomainDp || pDpInfo == g_pForestDp ) &&
        !fEnlist )
    {
        DNS_DEBUG( DP, (
            "%s: denying request on built-in partition", fn ));
        status = DNS_ERROR_RCODE_REFUSED;
        goto Done;
    }

    //
    //  Lock DP globals.
    //

    Dp_Lock();
    fhaveDpLock = TRUE;

    //
    //  Check params.
    //

    if ( !pDpInfo || !pDpInfo->pwszCrDn )
    {
        status = ERROR_INVALID_PARAMETER;
        ASSERT( pDpInfo && pDpInfo->pwszCrDn );
        goto Done;
    }

    if ( !g_pFsmo || !g_pFsmo->pwszDnsHostName )
    {
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        ffsmoWasUnavailable = TRUE;
        goto Done;
    }

    //
    //  Get an LDAP handle to the FSMO server.
    //

    ldapSession = Ds_Connect(
                        g_pFsmo->pwszDnsHostName,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound to %S\n", fn,
            g_pFsmo->pwszDnsHostName ));
        fcloseLdapSession = TRUE;
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to %S status=%d\n", fn,
            g_pFsmo->pwszDnsHostName,
            status ));
        ffsmoWasUnavailable = TRUE;
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        goto Done;
    }

    //
    //  Submit modify request to add local DS to replication scope.
    //

    status = ldap_modify_ext_s(
                    ldapSession,
                    pDpInfo->pwszCrDn,
                    modArray,
                    NULL,               // server controls
                    NULL );             // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: ldap_modify returned error 0x%X\n", fn,
            status ));
        status = Ds_ErrorHandler( status, pDpInfo->pwszCrDn, ldapSession, 0 );
        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
        }
        else if ( status == LDAP_ATTRIBUTE_OR_VALUE_EXISTS )
        {
            //
            //  Value is already on FSMO but has not replicated locally
            //  yet. Pretend that everything is peachy but do not log
            //  event. DEVNOTE: this may be confusing for admins.
            //

            status = ERROR_SUCCESS;
            flogEnlistEvent = FALSE;
        }
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( fhaveDpLock )
    {
        Dp_Unlock();
    }

    if ( fcloseLdapSession )
    {
        Ds_LdapUnbind( &ldapSession );
    }

    DNS_DEBUG( DP, (
        "%s: returning %d\n", fn,
        status ));

    //
    //  If the FSMO was not available, log error.
    //

    if ( ffsmoWasUnavailable )
    {
        PWSTR   pargs[] = 
            {
                ( g_pFsmo && g_pFsmo->pwszDnsHostName ) ?
                    g_pFsmo->pwszDnsHostName : L"\"\""
            };

        DNS_LOG_EVENT(
            DNS_EVENT_DP_FSMO_UNAVAILABLE,
            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
            pargs,
            EVENTARG_ALL_UNICODE,
            status );
    }
    else if ( status == ERROR_SUCCESS && flogEnlistEvent )
    {
        PWSTR   pargs[] = 
            {
                pDpInfo->pwszDpFqdn,
                pDpInfo->pwszDpDn
            };

        DNS_LOG_EVENT(
            fEnlist
                ? DNS_EVENT_DP_ENLISTED
                : DNS_EVENT_DP_UNENLISTED,
            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
            pargs,
            EVENTARG_ALL_UNICODE,
            status );
    }

    return status;
}   //  Dp_ModifyLocalDsEnlistment



DNS_STATUS
Dp_DeleteFromDs(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    This function deletes the directory partition from the directory.

    To delete a DP, we an ldap_delete operation against
    the partition's crossRef object. This must be done on the FSMO.

Arguments:

    pDpInfo - partition to delete

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_DeleteFromDs" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP           ldapFsmo = NULL;
    PWSTR           pwszdn = NULL;

    //
    //  Don't allow deletion of built-in partitions.
    //

    #if !DBG
    if ( !DNS_DP_DELETE_ALLOWED( pDpInfo ) )
    {
        DNS_DEBUG( DP, (
            "%s: denying request on built-in partition\n", fn ));
        status = DNS_ERROR_RCODE_REFUSED;
        goto Done;
    }
    #endif

    //
    //  Check params and grab a pointer to the DN string to protect against 
    //  DP rescan during the delete operation.
    //

    if ( !pDpInfo || !( pwszdn = pDpInfo->pwszCrDn ) )
    {
        status = ERROR_INVALID_PARAMETER;
        ASSERT( pDpInfo && pDpInfo->pwszCrDn );
        goto Done;
    }

    //
    //  Bind to the FSMO.
    //

    status = bindToFsmo( &ldapFsmo );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  Try to delete the crossRef from the DS.
    //

    status = ldap_delete_s( ldapFsmo, pwszdn );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: ldap_delete failed error=%d\n    %S\n", fn,
            status,
            pwszdn ));
        status = Ds_ErrorHandler( status, pwszdn, ldapFsmo, 0 );
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    Ds_LdapUnbind( &ldapFsmo );

    if ( status == ERROR_SUCCESS )
    {
        Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );
    }

    if ( status == ERROR_SUCCESS )
    {
        PWSTR   pargs[] = 
            {
                pDpInfo->pwszDpFqdn,
                pDpInfo->pwszDpDn
            };

        DNS_LOG_EVENT(
            DNS_EVENT_DP_DELETED,
            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
            pargs,
            EVENTARG_ALL_UNICODE,
            status );
    }

    DNS_DEBUG( DP, (
        "%s: returning %d for crossRef DN\n    %S\n", fn,
        status, pwszdn ));

    return status;
}   //  Dp_DeleteFromDs



DNS_STATUS
Dp_UnloadAllZones(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    This function unloads all zones from memory that are in
    the specified directory partition.

    DEVNOTE: This would certainly be faster if we maintained
    a linked list of zones in each DP.

Arguments:

    pDp -- directory partition for which to unload all zones

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_UnloadAllZones" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PZONE_INFO      pzone = NULL;

    ASSERT( pDp );
    ASSERT( pDp->pszDpFqdn );

    DNS_DEBUG( DP, ( "%s: %s\n", fn, pDp->pszDpFqdn ));

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        if ( pzone->pDpInfo != pDp )
        {
            continue;
        }

        //
        //  This zone must now be unloaded from memory. This will also
        //  remove any boot file or registry info we have for it.
        //

        DNS_DEBUG( DP, ( "%s: deleting zone %s\n", fn, pzone->pszZoneName ));
        Zone_Delete( pzone, 0 );
    }

    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return status;
}   //  Dp_UnloadAllZones



DNS_STATUS
Dp_PollIndividualDp(
    IN      PLDAP           LdapSession,
    IN      PDNS_DP_INFO    pDp,
    IN      DWORD           dwVisitStamp
    )
/*++

Routine Description:

    This function polls the specified directory partition for updates.

Arguments:

    LdapSession -- LDAP session (NULL not allowed)

    pDp -- directory partition to poll

    dwVisitStamp -- time stamp to stamp on each visited zone

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_PollIndividualDp" )

    DNS_STATUS      status = ERROR_SUCCESS;

    if ( IS_DP_DELETED( pDp ) )
    {
        goto Done;
    }

    status = Dp_ScanDpForZones(
                    LdapSession,
                    pDp,
                    FALSE,          //  notify SCM
                    TRUE,           //  load zones immediately
                    dwVisitStamp );

    //
    //  Cleanup and return.
    //

    Done:
    
    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return status;
}   //  Dp_PollIndividualDp



DNS_STATUS
Dp_Poll(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollTime,
    IN      BOOL            fForcePoll
    )
/*++

Routine Description:

    This function loops through the known directory partitions, polling each
    partition for directory updates.

Arguments:

    dwPollTime -- time to stamp on zones/DPs as they are visited

Return Value:

    Returns error code from DS operations. This function will attempt to 
    continue through errors but if errors occur the error code will be returned.

    This is important for subsequent operations. If there was an error
    enumerating zones, for example, then it should be assumed that the
    zone list was incomplete, and zones that were not enumerated may not
    actually have been deleted from the DS.

--*/
{
    DBG_FN( "Dp_Poll" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      finalStatus = ERROR_SUCCESS;
    PDNS_DP_INFO    pdp = NULL;
    PZONE_INFO      pzone = NULL;
    static LONG     functionLock = 0;

    if ( !SrvCfg_dwEnableDp ||
         !Ds_IsDsServer() ||
         ( SrvCfg_fBootMethod != BOOT_METHOD_DIRECTORY &&
           SrvCfg_fBootMethod != BOOT_METHOD_REGISTRY ) )
    {
        return ERROR_SUCCESS;
    }

    if ( !fForcePoll &&
         DNS_TIME() < g_dwLastDpPollTime + DP_MAX_POLL_FREQ )
    {
        DNS_DEBUG( DP, (
            "%s: polled to recently\n"
            "    last poll =            %d\n"
            "    current time =         %d\n"
            "    allowed frequency =    %d seconds\n", fn,
            g_dwLastDpPollTime,
            DNS_TIME(),
            DP_MAX_POLL_FREQ ));
        //  ASSERT( !"polled to recently" );
        return ERROR_SUCCESS;
    }

    if ( InterlockedIncrement( &functionLock ) != 1 )
    {
        DNS_DEBUG( DP, (
            "%s: another thread is already polling\n", fn ));
        goto Done;
    }

    g_dwLastDpPollTime = DNS_TIME();

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        finalStatus = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Reload all operational attributes from RootDSE. This protects us from
    //  RootDSE changes, such as if the DC is moved to another site.
    //

    Ds_LoadRootDseAttributes( pServerLdap );

    //
    //  Scan for new/deleted directory partitions.
    //

    Dp_PollForPartitions(
        LdapSession,
        fForcePoll ? DNS_DP_POLL_FORCE : 0 );

    //
    //  Iterate DP list. For DPs that have been deleted, we must unload 
    //  all zones in that DP from memory. For other zones, we must scan
    //  for zones that have been added or deleted.
    //

    while ( ( pdp = Dp_GetNext( pdp ) ) != NULL )
    {
        if ( IS_DP_DELETED( pdp ) )
        {
            //
            //  Unload all zones from the DP, remove the DP from the
            //  the list, and enter the DP into the timeout free system.
            //

            Dp_UnloadAllZones( pdp );
            Dp_RemoveFromList( pdp, TRUE );
            Dp_FreeDpInfo( &pdp );
            continue;
        }

        if ( !IS_DP_ENLISTED( pdp ) )
        {
            //
            //  If the DP is not enlisted we cannot open a zone search.
            //

            continue;
        }

        //
        //  Poll the DP for zones.
        //

        status = Dp_PollIndividualDp(
                    LdapSession,
                    pdp,
                    dwPollTime );
        
        if ( status != ERROR_SUCCESS && finalStatus == ERROR_SUCCESS )
        {
            finalStatus = status;
        }
    }

    //
    //  Cleanup and return.
    //

    Done:
    
    InterlockedDecrement( &functionLock );

    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return finalStatus;
}   //  Dp_Poll



DNS_STATUS
Ds_CheckZoneForDeletion(
    PVOID       pZoneArg
    )
/*++

Routine Description:

    Call this routine when the zone cannot be found in the DS.

    If the zone is in the legacy partition, it will be
    deleted only on delete notification - do not delete here.
    This could be changed.

Arguments:

    pZone -- zone which may be deleted

    dwPollTime -- timestamp for this polling pass

Return Value:

    ERROR_SUCCESS if the zone was not deleted from memory
    ERROR_NOT_FOUND if the zone was deleted from memory

--*/
{
    DBG_FN( "Ds_CheckZoneForDeletion" )

    PZONE_INFO      pzone = ( PZONE_INFO ) pZoneArg;
    PVOID           parg;

    //
    //  Is the zone in the legacy partition?
    //

    if ( IS_DP_LEGACY( ZONE_DP( pzone ) ) )
    {
        goto NoDelete;
    }

    //
    //  Have we found this zone missing enough times to actually delete it?
    //

    if ( ++pzone->dwDeleteDetectedCount < DNS_DP_ZONE_DELETE_RETRY )
    {
        DNSLOG( DSPOLL, (
            "Zone %s has been missing from the DS on %d poll(s)\n",
            pzone->pszZoneName,
            pzone->dwDeleteDetectedCount ));
        goto NoDelete;
    }

    //
    //  This zone must now be deleted.
    //

    DNSLOG( DSPOLL, (
        "Zone %s has been deleted from the DS and will now be deleted from memory\n",
        pzone->pszZoneName ));

    Zone_Delete( pzone, 0 );

    parg = pzone->pwsZoneName;

    DNS_LOG_EVENT(
        DNS_EVENT_DS_ZONE_DELETE_DETECTED,
        1,
        &parg,
        EVENTARG_ALL_UNICODE,
        0 );

    return ERROR_NOT_FOUND;

    NoDelete:

    return ERROR_SUCCESS;
}   //  Ds_CheckZoneForDeletion



DNS_STATUS
Dp_AutoCreateBuiltinPartition(
    DWORD       dwFlag
    )
/*++

Routine Description:

    This routine attempts to create or enlist the appropriate
    built-in directory partition, then re-polls the DS for
    changes and sets the appropriate global DP pointer.

Arguments:

    dwFlag -- DNS_DP_DOMAIN_DEFAULT or DNS_DP_FOREST_DEFAULT

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_AutoCreateBuiltinPartition" )

    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_DP_INFO *      ppdp = NULL;
    PSTR *              ppszdpFqdn = NULL;
    DNS_DP_SECURITY     dnsDpSecurity = dnsDpSecurityDefault;
    BOOL                fchangeMade = FALSE;

    //
    //  Select global DP pointer and DP FQDN pointer.
    //

    if ( dwFlag == DNS_DP_DOMAIN_DEFAULT )
    {
        ppdp = &g_pDomainDp;
        ppszdpFqdn = &g_pszDomainDefaultDpFqdn;
        dnsDpSecurity = dnsDpSecurityDomain;
    }
    else if ( dwFlag == DNS_DP_FOREST_DEFAULT )
    {
        ppdp = &g_pForestDp;
        ppszdpFqdn = &g_pszForestDefaultDpFqdn;
        dnsDpSecurity = dnsDpSecurityForest;
    }

    if ( !ppdp || !ppszdpFqdn || !*ppszdpFqdn )
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Enlist/create the partition as necessary.
    //

    status = manageBuiltinDpEnlistment(
                    *ppdp,
                    dnsDpSecurity,
                    *ppszdpFqdn,
                    FALSE,          //  log events
                    &fchangeMade );

    if ( status == ERROR_SUCCESS && fchangeMade )
    {
        Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );
    }

    Done:

    DNS_DEBUG( RPC, (
        "%s: flag %08X returning 0x%08X\n", fn, dwFlag, status ));

    return status;
}   //  Dp_AutoCreateBuiltinPartition



VOID
Dp_MigrateDcpromoZones(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    This function migrates dcpromo zones are required. Call this
    function when the domain or forest built-in partition comes
    on-line.

    A global variable is used to optimize this function. The RPC zone
    creation code may flip this global if it adds a dcpromo zone. The
    global is just a hint. It's initial value should be true to force
    us to scan the list at least once after startup. 

    This function is not meant to be thread-safe. Call this from a
    single thread only.

Arguments:

    fForce -- ignore last time this function was run

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_MigrateDcpromoZones" )

    PZONE_INFO      pzone = NULL;
    BOOL            fdcPromoZonesPresent = FALSE;

    DNS_DEBUG( DP, (
        "%s g_fDcPromoZonesPresent = %d\n", fn,
        g_fDcPromoZonesPresent ));

    if ( !SrvCfg_dwEnableDp ||
        !g_fDcPromoZonesPresent ||
        Zone_ListGetNextZone( NULL ) == NULL )
    {
        return;
    }
    
    //
    //  Only allow this function to run once every 15 minutes.
    //

    if ( !fForce &&
         DNS_TIME() < g_dwLastDcpromoZoneMigrateCheck + ( 15 * 60 ) )
    {
        DNS_DEBUG( DP, (
            "%s: last ran %d seconds ago so will not run at this time\n", fn,
            time( NULL ) - g_dwLastDcpromoZoneMigrateCheck ));
        return;
    }
    g_dwLastDcpromoZoneMigrateCheck = DNS_TIME();

    //
    //  Scan the zone list for dcpromo zones and migrate them as required.
    //

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        PDNS_DP_INFO    pidealTargetDp = NULL;
        PDNS_DP_INFO    ptargetDp = NULL;
        DWORD           dwnewDcPromoConvert = DCPROMO_CONVERT_NONE;
        DNS_STATUS      status;

        //
        //  Select the target DP for this zone. We can only migrate the
        //  zone if there are no downlevel DCs in the domain scope. But 
        //  for forest dcpromo zones we migrate the zone as soon as the
        //  the forest-wide built-in partition becomes available. This
        //  is per the spec.
        //

        if ( !Zone_LockForAdminUpdate( pzone ) )
        {
            continue;
        }
        
        if ( pzone->dwDcPromoConvert == DCPROMO_CONVERT_DOMAIN )
        {
            pidealTargetDp =
                g_ulDownlevelDCsInDomain
                    ? g_pLegacyDp
                    : g_pDomainDp;
            fdcPromoZonesPresent = TRUE;
        }
        else if ( pzone->dwDcPromoConvert == DCPROMO_CONVERT_FOREST )
        {
            pidealTargetDp = g_pForestDp;
            fdcPromoZonesPresent = TRUE;
        }
        else
        {
            goto FinishedZone;
        }
        ptargetDp = pidealTargetDp;

        if ( !ptargetDp )
        {
            //
            //  The target DP is missing. If possible, move this zone to
            //  the legacy partition so that it can be changed to allow
            //  updates and will replicate. The dcpromo flag will be
            //  retained and the zone will be automatically migrated to
            //  the proper partition at a later time when that partition
            //  becomes available.
            //
            
            ptargetDp = g_pLegacyDp;
            if ( ptargetDp )
            {
                dwnewDcPromoConvert = pzone->dwDcPromoConvert;
            }
            else
            {
                ASSERT( ptargetDp );        //  This should never happen!
                goto FinishedZone;
            }
        }

        //
        //  If the zone's current DP is not the target DP, move the zone.
        //

        if ( ptargetDp != ZONE_DP( pzone ) )
        {

            if ( !IS_DP_ENLISTED( ptargetDp ) )
            {
                //
                //  The target DP is either missing or not enlisted. This 
                //  function is not the place to try and create it. If the
                //  DP hasn't been create/enlisted by this point it will
                //  probably take admin action, so we'll just try again later.
                //

                goto FinishedZone;
            }

            //
            //  Everything looks good - move the zone.
            //

            if ( IS_ZONE_DSINTEGRATED( pzone ) )
            {
                status = Dp_ChangeZonePartition( pzone, ptargetDp );
            }
            else
            {
                status = Rpc_ZoneResetToDsPrimary(
                                pzone,
                                0,      //  no special load flags
                                ptargetDp->dwFlags,
                                ptargetDp->pszDpFqdn );
            }

            DNS_DEBUG( DP, (
                "%s: Dp_ChangeZonePartition error %d = 0x%08X", fn,
                status, status ));
        }

        //
        //  Move was successful so reset the zone's dcpromo flag and
        //  allow secure updates on this zone.
        //

        pzone->dwDcPromoConvert = dwnewDcPromoConvert;
        pzone->fAllowUpdate = ZONE_UPDATE_SECURE;
        pzone->llSecureUpdateTime = 0;

        status = Ds_WriteZoneProperties( NULL, pzone );
        ASSERT( status == ERROR_SUCCESS );

        if ( pzone->dwDcPromoConvert == DCPROMO_CONVERT_NONE )
        {
            Reg_DeleteValue(
                0,                  //  flags
                NULL,
                pzone,
                DNS_REGKEY_ZONE_DCPROMO_CONVERT );
        }
        else
        {
            Reg_SetDwordValue(
                0,                  //  flags
                NULL,
                pzone,
                DNS_REGKEY_ZONE_DCPROMO_CONVERT,
                pzone->dwDcPromoConvert );
        }
        
        FinishedZone:
        
        Zone_UnlockAfterAdminUpdate( pzone );
    }

    //
    //  Cleanup and return.
    //

    g_fDcPromoZonesPresent = fdcPromoZonesPresent;

    DNS_DEBUG( DP, (
        "%s complete\n    g_fDcPromoZonesPresent  = %d\n", fn,
        g_fDcPromoZonesPresent ));
    return;
}   //  Dp_MigrateDcpromoZones



DNS_STATUS
Dp_ChangeZonePartition(
    IN      PVOID           pZone,
    IN      PDNS_DP_INFO    pNewDp
    )
/*++

Routine Description:

    Move the zone from it's current directory partition to a new
    directory partition.

Arguments:

    pZone -- zone to move to a different partition

    pNewDp -- destination directory partition

Return Value:

    Error code or ERROR_SUCCESS

--*/
{
    DBG_FN( "Dp_ChangeZonePartition" )

    PZONE_INFO      pZoneInfo = pZone;
    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fzoneLocked = FALSE;
    BOOL            frestoreZoneOnFail = FALSE;
    PWSTR           pwsznewDn = NULL;
    PWSTR           pwszoriginalDn = NULL;
    PWSTR           pwsztemporaryDn = NULL;
    PWSTR *         ppwszexplodedDn = NULL;
    PDNS_DP_INFO    poriginalDp = NULL;
    PWCHAR *        pexplodedDn = NULL;
    int             retry;
    PWCHAR          pwsznewRecordDn = NULL;
    DS_SEARCH       searchBlob;
    
    PLDAPControl    ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    DNS_DEBUG( DP, (
        "%s:\n"
        "    pZone =            %s\n"
        "    zone name =        %s\n"
        "    pNewDp =           %s\n"
        "    new DP name =      %s\n", fn,
        pZoneInfo,
        pZoneInfo ? pZoneInfo->pszZoneName : "NULL",
        pNewDp,
        pNewDp ? pNewDp->pszDpFqdn : "NULL" ));
        
    if ( !pZone || !pNewDp )
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    if ( !IS_ZONE_DSINTEGRATED( pZoneInfo ) )
    {
        ASSERT( IS_ZONE_DSINTEGRATED( pZoneInfo ) );
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    pwsznewRecordDn = ALLOCATE_HEAP( ( MAX_DN_PATH + 100 ) * sizeof( WCHAR ) );
    if ( !pwsznewRecordDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Is the zone already in the requested DP?
    //

    if ( pZoneInfo->pDpInfo == pNewDp ||
         pZoneInfo->pDpInfo == NULL && IS_DP_LEGACY( pNewDp ) )
    {
        status = ERROR_SUCCESS;
        goto Done;
    }

    //
    //  Lock the zone for update.
    //

    if ( !Zone_LockForAdminUpdate( pZoneInfo ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fzoneLocked = TRUE;
    
    //
    //  Read updated zone properties from DS. If the zone has been
    //  changed in the DS we want the new copy of the zone to have the
    //  very latest properties.
    //
    
    Ds_ReadZoneProperties( pZoneInfo, NULL );

    //
    //  Save current zone values in case something goes wrong and we need
    //  to revert. Expect problems when saving the zone to the new location!
    //  We must be able to put things back exactly as we found them.
    //
    //  Because Ds_SetZoneDp will free the original DN we must allocate a
    //  copy of the original DN.
    //

    ASSERT( pZoneInfo->pwszZoneDN );

    pwszoriginalDn = Dns_StringCopyAllocate_W( pZoneInfo->pwszZoneDN, 0 );
    if ( !pwszoriginalDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    poriginalDp = pZoneInfo->pDpInfo;
    frestoreZoneOnFail = TRUE;

    //
    //  The new zone is written with a temporary DN. Retry this a small
    //  number of times in case there is an orphaned object in the directory 
    //  that collides with our temporary DN.
    //

    for ( retry = 0; retry < 3; ++retry )
    {
        //
        //  If this is not the first retry, sleep briefly.
        //

        if ( retry )
        {
            Sleep( 3000 );
        }
        
        //
        //  Make sure this partition has a MicrosoftDNS object.
        //

        Dp_LoadOrCreateMicrosoftDnsObject( NULL, pNewDp, TRUE );

        //
        //  Set the zone to point to the new directory partition. The new 
        //  DN will be located in the new partition, and it will be have 
        //  special ".." temporary prefix for use while we are writing it out.
        //

        status = Ds_SetZoneDp( pZoneInfo, pNewDp, TRUE );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( RPC, (
                "%s: Ds_SetZoneDp returned 0x%08X\n", fn, status ));
            continue;
        }

        //
        //  Write the new zone head object to the DS.
        //
        
        status = Ds_AddZone( NULL, pZoneInfo, DNS_ADDZONE_WRITESD );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DP, (
                "%s: Ds_AddZone returned 0x%08X\n", fn, status ));
            if ( status == LDAP_ALREADY_EXISTS )
            {
                status = DNS_ERROR_ZONE_ALREADY_EXISTS;
            }
            else if ( status == LDAP_NO_SUCH_OBJECT )
            {
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
            }
            break;
        }
        
        //
        //  Copy the zone records from the original location to the new
        //  location. This must be done with a brute force read/write
        //  loop for two reasons:
        //
        //  1) We need to copy the security descriptors and we do not
        //     hold them in memory.
        //  2) If this operation is interupted the original zone in the
        //     DS must be in the original condition so that the server
        //     can gracefully recover.
        //
        
        pwsztemporaryDn = pZoneInfo->pwszZoneDN;
        pZoneInfo->pwszZoneDN = pwszoriginalDn;
        status = Ds_StartDsZoneSearch(
                    &searchBlob,
                    pZoneInfo,
                    DNSDS_SEARCH_LOAD );
        pZoneInfo->pwszZoneDN = pwsztemporaryDn;
        if ( status != ERROR_SUCCESS )
        {
            continue;
        }

        //
        //  Loop through search results.
        //

        while ( ( status = Ds_GetNextMessageInSearch(
                                &searchBlob ) ) == ERROR_SUCCESS )
        {
            INT                 i;
            BOOL                isTombstoned = FALSE;

            PWCHAR *            ldapValues = NULL;
            struct berval **    ldapValuesLen = NULL;
            PWCHAR *            objectClassValues = NULL;

            INT                 modidx = 0;
            LDAPModW *          modArray[ 10 ];

            LDAPModW            dcMod = 
                {
                LDAP_MOD_ADD,
                DNS_ATTR_DC,
                NULL
                };

            PWCHAR              objectClassVals[ 2 ] = { 0 };
            LDAPModW            objectClassMod = 
                {
                LDAP_MOD_ADD,
                DNS_ATTR_OBJECT_CLASS,
                objectClassVals
                };

            LDAPModW            dnsMod = 
                {
                LDAP_MOD_ADD | LDAP_MOD_BVALUES,
                DSATTR_DNSRECORD,
                NULL
                };
            
            LDAPModW            sdMod = 
                {
                LDAP_MOD_ADD | LDAP_MOD_BVALUES,
                DSATTR_SD,
                NULL
                };
            
            //
            //  If this object is tombstoned we do not need to process it.
            //

            ldapValues = ldap_get_values(
                            pServerLdap,
                            searchBlob.pNodeMessage,
                            LDAP_TEXT( "dNSTombstoned" ) );
            if ( ldapValues &&
                 ldapValues[ 0 ] &&
                 _wcsicmp( ldapValues[ 0 ], L"TRUE" ) == 0 )
            {
                isTombstoned = TRUE;
            }

            ldap_value_free( ldapValues );
            ldapValues = NULL;

            if ( isTombstoned )
            {
                continue;
            }
            
            //
            //  Formulate DN of new object.
            //

            ldapValues = ldap_get_values(
                            pServerLdap,
                            searchBlob.pNodeMessage,
                            DSATTR_DC );
            if ( !ldapValues )
            {
                DNS_DEBUG( DP, (
                    "%s: node missing value of %S\n", fn, DSATTR_DC ));
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                goto DoneEntry;
            }

            wsprintf(
                pwsznewRecordDn,
                L"DC=%s,%s",
                ldapValues[ 0 ],
                pZoneInfo->pwszZoneDN );

            dcMod.mod_vals.modv_strvals = ldapValues;
            modArray[ modidx++ ] = &dcMod;
            ldapValues = NULL;

            //
            //  Object class values.
            //
            
            objectClassValues = ldap_get_values(
                                    pServerLdap,
                                    searchBlob.pNodeMessage,
                                    DNS_ATTR_OBJECT_CLASS );
            if ( !objectClassValues || !objectClassValues[ 0 ] )
            {
                DNS_DEBUG( DP, (
                    "%s: node missing value of %S\n", fn, DNS_ATTR_OBJECT_CLASS ));
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                goto DoneEntry;
            }
            
            for ( i = 0;        //  Set i to index of last object class value.
                  objectClassValues[ i ];
                  ++i );                
            objectClassVals[ 0 ] = objectClassValues[ i - 1 ];
            modArray[ modidx++ ] = &objectClassMod;

            //
            //  Security descriptor values.
            //
            
            ldapValuesLen = ldap_get_values_len(
                                pServerLdap,
                                searchBlob.pNodeMessage,
                                DSATTR_SD );
            if ( ldapValuesLen )
            {
                sdMod.mod_vals.modv_bvals = ldapValuesLen;
                modArray[ modidx++ ] = &sdMod;
            }
            else
            {
                DNS_DEBUG( DP, (
                    "%s: node missing values of %S\n", fn, DSATTR_SD ));
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                goto DoneEntry;
            }

            //
            //  DNS attribute values.
            //
            
            ldapValuesLen = ldap_get_values_len(
                                pServerLdap,
                                searchBlob.pNodeMessage,
                                DSATTR_DNSRECORD );
            if ( ldapValuesLen )
            {
                dnsMod.mod_vals.modv_bvals = ldapValuesLen;
                modArray[ modidx++ ] = &dnsMod;
                ldapValuesLen = NULL;
            }

            //
            //  Add the new entry.
            //
            
            modArray[ modidx++ ] = NULL;

            status = ldap_add_ext_s(
                        pServerLdap,
                        pwsznewRecordDn,
                        modArray,
                        ctrls,          //  server controls
                        NULL );         //  client controls
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: ldap_add_ext_s returned 0x%X\n", fn, status ));
                goto DoneEntry;
            }
            
            //
            //  Cleanup for this entry.
            //
                        
            DoneEntry:
            
            ldap_value_free( objectClassValues );
            ldap_value_free( dcMod.mod_vals.modv_strvals );
            ldap_value_free_len( dnsMod.mod_vals.modv_bvals );
            ldap_value_free_len( sdMod.mod_vals.modv_bvals );

            if ( status != ERROR_SUCCESS )
            {
                break;
            }
        }

        Ds_CleanupSearchBlob( &searchBlob );

        break;  
    }

    if ( status != DNSSRV_STATUS_DS_SEARCH_COMPLETE &&
         status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  Reset the zone DN from the temporary DN to the real DN. Note
    //  that pwsztemporaryDn will be timeout freed by Ds_SetZoneDp.
    //

    pwsztemporaryDn = pZoneInfo->pwszZoneDN;
    status = Ds_SetZoneDp( pZoneInfo, pNewDp, FALSE );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: Ds_SetZoneDp returned %d = 0x%08X\n", fn,
            status, status ));
        goto Done;
    }

    //
    //  Pull apart the new DN to recover the new zone RDN for ldap_rename.
    //

    ppwszexplodedDn = ldap_explode_dn( pZoneInfo->pwszZoneDN, 0 );
    if ( !ppwszexplodedDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Rename the zone from it's temp DN to it's real DN.
    //

    status = ldap_rename_ext_s(
                    ldapSessionHandle( NULL ),
                    pwsztemporaryDn,            //  current DN
                    ppwszexplodedDn[ 0 ],       //  new RDN
                    NULL,                       //  new parent DN
                    TRUE,                       //  delete old RDN
                    NULL,                       //  server controls
                    NULL );                     //  client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error 0x%X renaming zone from temporary to true DN\n"
            "    new RDN =     %S\n"
            "    current DN =  %S\n", fn,
            status,
            ppwszexplodedDn[ 0 ],
            pwsztemporaryDn ));

        status = Ds_ErrorHandler(
                    status,
                    pwsztemporaryDn,
                    ldapSessionHandle( NULL ),
                    0 );
        goto Done;
    }

    //
    //  Update registry parameters. Assume successful.
    //

    status = Zone_WriteZoneToRegistry( pZoneInfo );

    ASSERT( status == ERROR_SUCCESS );
    status = ERROR_SUCCESS;
    
    //
    //  Try to delete the zone from the old directory location. If it fails
    //  return success but log an event. To delete the zone we must
    //  temporarily revert the zone information to the original values.
    //

    pwsznewDn = pZoneInfo->pwszZoneDN;
    pZoneInfo->pwszZoneDN = pwszoriginalDn;
    pZoneInfo->pDpInfo = poriginalDp;

    status = Ds_DeleteZone( pZoneInfo, DNS_DS_DEL_IMPERSONATING );

    pZoneInfo->pwszZoneDN = pwsznewDn;
    pZoneInfo->pDpInfo = pNewDp;

    if ( status != ERROR_SUCCESS )
    {
        PVOID   argArray[ 3 ] =
        {
            pZoneInfo->pwsZoneName,
            pZoneInfo->pwszZoneDN ? pZoneInfo->pwszZoneDN : L"",
            pwszoriginalDn ? pwszoriginalDn : L""
        };

        DNS_DEBUG( RPC, (
            "%s: Ds_DeleteZone returned %d = 0x%08X\n", fn,
            status, status ));

        DNS_LOG_EVENT(
            DNS_EVENT_DP_DEL_DURING_CHANGE_ERR,
            3,
            argArray,
            EVENTARG_ALL_UNICODE,
            status );

        status = ERROR_SUCCESS;
    }

    Done:

    //
    //  Restore original zone values if the operation failed.
    //
    
    if ( frestoreZoneOnFail && status != ERROR_SUCCESS )
    {
        PWSTR       pwszDnToDelete = pZoneInfo->pwszZoneDN;

        DNS_DEBUG( RPC, (
            "%s: restoring original zone values\n", fn ));

        ASSERT( pwszDnToDelete );
        ASSERT( pwszoriginalDn );

        pZoneInfo->pwszZoneDN = pwszoriginalDn;
        pwszoriginalDn = NULL;
        pZoneInfo->pDpInfo = poriginalDp;

        FREE_HEAP( pwszDnToDelete );
    }

    if ( fzoneLocked )
    {
        Zone_UnlockAfterAdminUpdate( pZoneInfo );
    }

    FREE_HEAP( pwszoriginalDn );
    ldap_value_free( ppwszexplodedDn );
    FREE_HEAP( pwsznewRecordDn );

    DNS_DEBUG( DP, ( "%s: returning 0x%08X\n", fn, status ));

    return status;
}   //  Dp_ChangeZonePartition



DNS_STATUS
Dp_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize module, and read DS for current directory partitions.
    No zones are read or loaded. Before calling this routine the server
    should have read global DS configuration.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Initialize" )

    DNS_STATUS      status = ERROR_SUCCESS;
    LONG            init;
    CHAR            szfqdn[ DNS_MAX_NAME_LENGTH + 1 ];
    CHAR            szbase[ DNS_MAX_NAME_LENGTH + 1 ];
    PWCHAR          pwszlegacyDn = NULL;
    PWCHAR          pwsz;
    PDNS_DP_INFO    pdpInfo = NULL;
    INT             len;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    init = InterlockedIncrement( &g_liDpInitialized );
    if ( init != 1 )
    {
        DNS_DEBUG( DP, (
            "%s: already initialized %ld\n", fn,
            init ));
        ASSERT( init == 1 );
        InterlockedDecrement( &g_liDpInitialized );
        goto Done;
    }

    //
    //  Initialize globals.
    //

    status = DnsInitializeCriticalSection( &g_DpCS );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    g_pLegacyDp = NULL;
    g_pDomainDp = NULL;
    g_pForestDp = NULL;

    g_pFsmo = NULL;

    InitializeListHead( &g_DpList );
    g_DpListEntryCount = 0;

    g_fDcPromoZonesPresent = TRUE;

    //
    //  Make sure the DS is present and healthy. This will also cause
    //  rootDSE attributes to be read in case they haven't been already.
    //

    if ( !Ds_IsDsServer() )
    {
        DNS_DEBUG( DP, ( "%s: no directory present\n", fn ));
        SrvCfg_dwEnableDp = 0;
        goto Done;
    }

    status = Ds_OpenServer( DNSDS_WAIT_FOR_DS | DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: error %lu Ds_OpenServer\n", fn,
            status ));
        goto Done;
    }

    ASSERT( DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal );
    ASSERT( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal );
    ASSERT( DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal );

    //
    //  Formulate the FQDNs of the Forest and Domain DPs.
    //

    if ( SrvCfg_pszDomainDpBaseName )
    {
        PCHAR   psznewFqdn = NULL;

        status = Ds_ConvertDnToFqdn( 
                    DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
                    szbase );
        ASSERT( status == ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS && szbase[ 0 ] )
        {
            psznewFqdn = ALLOC_TAGHEAP_ZERO(
                            strlen( szbase ) +
                                strlen( SrvCfg_pszDomainDpBaseName ) + 10,
                            MEMTAG_DS_OTHER );
        }
        if ( psznewFqdn )
        {
            //  NOTE: do not use sprintf here - if base name contains
            //  UTF-8 characters it will truncate.
            strcpy( psznewFqdn, SrvCfg_pszDomainDpBaseName );
            strcat( psznewFqdn, "." );
            strcat( psznewFqdn, szbase );

            Timeout_Free( g_pszDomainDefaultDpFqdn );
            g_pszDomainDefaultDpFqdn = psznewFqdn;
        }
    }
         
    if ( SrvCfg_pszForestDpBaseName )
    {
        PCHAR   psznewFqdn = NULL;

        status = Ds_ConvertDnToFqdn( 
                    DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal,
                    szbase );
        ASSERT( status == ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS && szbase[ 0 ] )
        {
            psznewFqdn = ALLOC_TAGHEAP_ZERO(
                            strlen( szbase ) +
                                strlen( SrvCfg_pszForestDpBaseName ) + 10,
                            MEMTAG_DS_OTHER );
        }
        if ( psznewFqdn )
        {
            //  NOTE: do not use sprintf here - if base name contains
            //  UTF-8 characters it will truncate.
            strcpy( psznewFqdn, SrvCfg_pszForestDpBaseName );
            strcat( psznewFqdn, "." );
            strcat( psznewFqdn, szbase );

            Timeout_Free( g_pszForestDefaultDpFqdn );
            g_pszForestDefaultDpFqdn = psznewFqdn;
        }
    }
         
    DNS_DEBUG( DP, (
        "%s: domain DP is %s\n", fn,
        g_pszDomainDefaultDpFqdn ));
    DNS_DEBUG( DP, (
        "%s: forest DP is %s\n", fn,
        g_pszForestDefaultDpFqdn ));

    //
    //  Create a dummy DP entry for the legacy partition. This entry
    //  is not kept in the list of partitions.
    //

    if ( !g_pLegacyDp )
    {
        g_pLegacyDp = ( PDNS_DP_INFO ) ALLOC_TAGHEAP_ZERO(
                                            sizeof( DNS_DP_INFO ),
                                            MEMTAG_DS_OTHER );
        if ( g_pLegacyDp )
        {
            ASSERT( g_pwszDnsContainerDN );

            g_pLegacyDp->dwFlags = DNS_DP_LEGACY | DNS_DP_ENLISTED;
            g_pLegacyDp->pwszDpFqdn = 
                Dns_StringCopyAllocate_W( L"MicrosoftDNS", 0 );
            g_pLegacyDp->pszDpFqdn = 
                Dns_StringCopyAllocate_A( "MicrosoftDNS", 0 );
            g_pLegacyDp->pwszDnsFolderDn = 
                Dns_StringCopyAllocate_W( g_pwszDnsContainerDN, 0 );
            g_pLegacyDp->pwszDpDn = Ds_GenerateBaseDnsDn( FALSE );
        }
    }
    
    if ( !g_pLegacyDp
         || !g_pLegacyDp->pwszDpFqdn
         || !g_pLegacyDp->pszDpFqdn
         || !g_pLegacyDp->pwszDnsFolderDn
         || !g_pLegacyDp->pwszDpDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        Dp_FreeDpInfo( &g_pLegacyDp );
        goto Done;
    }

    //
    //  Load partitions from DS.
    //

    Dp_PollForPartitions(
        NULL,
        DNS_DP_POLL_FORCE |
            DNS_DP_POLL_NOTIFYSCM |
            DNS_DP_POLL_NOAUTOENLIST );

    Dbg_DumpDpList( "done initialize scan" );

    //
    //  Cleanup and return
    //

    Done:

    FREE_HEAP( pwszlegacyDn );

    DNS_DEBUG( DP, (
        "%s: returning %lu\n", fn,
        status ));
    return status;
}   //  Dp_Initialize



VOID
Dp_TimeoutThreadTasks(
    VOID
    )
/*++

Routine Description:

    This function does processing as required in the context of the
    DNS server timeout thread. This function can also be called 
    once during server initialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_TimeoutThreadTasks" )

    BOOL            fchangeMade = FALSE;

    if ( !SrvCfg_dwEnableDp || !IS_DP_INITIALIZED() )
    {
        return;
    }

    //
    //  Retry these tasks a certain number of times on every timeout
    //  call. Once we have exceeded that limit, attempt the timeout
    //  tasks only infrequently.
    //
    
    if ( g_DpTimeoutFastThreadCalls > DNS_DP_FAST_AUTOCREATE_ATTEMPTS &&
         DNS_TIME() - g_dwLastDpAutoEnlistTime < SrvCfg_dwDpEnlistInterval )
    {
        return;
    }
    g_dwLastDpAutoEnlistTime = DNS_TIME();
    ++g_DpTimeoutFastThreadCalls;

    DNS_DEBUG( DP, (
        "%s: running at time %d\n", fn, g_dwLastDpAutoEnlistTime ));

    //
    //  Reload all operational attributes from RootDSE. This protects us from
    //  RootDSE changes, such as if the DC is moved to another site.
    //

    Ds_LoadRootDseAttributes( pServerLdap );

    //
    //  Attempt to create built-in partitions. This must be retried a couple
    //  of times after server restart because on dcpromo reboot this will
    //  fail the first time. The DS does not appear to be ready to accept
    //  creation attempts for NDNCs until at least a few minutes have passed.
    //
    //  Do not log events for these attempts. In a properly secured enterprise
    //  it's expected that this will fail, but if we can get the job done
    //  we'll do it to make the admins life easier.
    //

    manageBuiltinDpEnlistment(
        g_pDomainDp,
        dnsDpSecurityDomain,
        g_pszDomainDefaultDpFqdn,
        FALSE,                                  //  log events
        &fchangeMade );
    manageBuiltinDpEnlistment(
        g_pForestDp,
        dnsDpSecurityForest,
        g_pszForestDefaultDpFqdn,
        FALSE,                                  //  log events
        fchangeMade ? NULL : &fchangeMade );

    if ( fchangeMade )
    {
        Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );
    }

    return;
}   //  Dp_TimeoutThreadTasks



DNS_STATUS
Dp_FindPartitionForZone(
    IN      DWORD               dwDpFlags,
    IN      LPSTR               pszDpFqdn,
    IN      BOOL                fAutoCreateAllowed,
    OUT     PDNS_DP_INFO *      ppDpInfo
    )
/*++

Routine Description:

    This function finds the directory partition targetted by
    the zone create attempt.

Arguments:

    dwDpFlags - flags for specifying built-in partition

    pszDpFqdn - FQDN for specifying custom partition

    fAutoCreateAllowed -- if the requested DP is a built-in DP
        then it will be auto-created/enlisted if this flag is TRUE

    ppDpInfo -- set to pointer to required DP

Return Value:

    ERROR_SUCCESS -- if successful or error code on failure.

--*/
{
    DBG_FN( "Dp_FindPartitionForZone" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pdp = NULL;
    PSTR            psz;

    //
    //  If a built-in partition was specified by name, substitute the
    //  flag instead.
    //

    if ( pszDpFqdn )
    {
        psz = g_pszDomainDefaultDpFqdn;
        if ( psz && _stricmp( pszDpFqdn, psz ) == 0 )
        {
            dwDpFlags = DNS_DP_DOMAIN_DEFAULT;
        }
        else
        {
            psz = g_pszForestDefaultDpFqdn;
            if ( psz && _stricmp( pszDpFqdn, psz ) == 0 )
            {
                dwDpFlags = DNS_DP_FOREST_DEFAULT;
            }
        }
    }

    //
    //  Find (and auto-create for built-in partitions) the DP.
    //

    if ( dwDpFlags & DNS_DP_LEGACY )
    {
        pdp = g_pLegacyDp;
    }
    else if ( dwDpFlags & DNS_DP_DOMAIN_DEFAULT )
    {
        if ( fAutoCreateAllowed )
        {
            Dp_AutoCreateBuiltinPartition( DNS_DP_DOMAIN_DEFAULT );
        }
        pdp = g_pDomainDp;
    }
    else if ( dwDpFlags & DNS_DP_FOREST_DEFAULT )
    {
        if ( fAutoCreateAllowed )
        {
            Dp_AutoCreateBuiltinPartition( DNS_DP_FOREST_DEFAULT );
        }
        pdp = g_pForestDp;
    }
    else if ( pszDpFqdn )
    {
        pdp = Dp_FindByFqdn( pszDpFqdn );
    }
    else
    {
        pdp = g_pLegacyDp;  //  Default: legacy partition.
    }

    //
    //  Set return values.
    //
        
    if ( !pdp )
    {
        status = DNS_ERROR_DP_DOES_NOT_EXIST;
    }
    else if ( !IS_DP_AVAILABLE( pdp ) )
    {
        status = DNS_ERROR_DP_NOT_AVAILABLE;
    }
    else if ( !IS_DP_ENLISTED( pdp ) )
    {
        status = DNS_ERROR_DP_NOT_ENLISTED;
    }

    //
    //  If we have a valid partition, make sure that the MicrosoftDns
    //  container exists in the partition.
    //
    
    if ( pdp && status == ERROR_SUCCESS )
    {
        status = Dp_LoadOrCreateMicrosoftDnsObject(
                    NULL,                   //  LDAP session
                    pdp,
                    TRUE );                 //  create flag
    }
    
    *ppDpInfo = pdp;

    return status;
}   //  Dp_FindPartitionForZone



VOID
Dp_Cleanup(
    VOID
    )
/*++

Routine Description:

    Free module resources.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Cleanup" )

    LONG            init;

    if ( !SrvCfg_dwEnableDp )
    {
        return;
    }

    init = InterlockedDecrement( &g_liDpInitialized );
    if ( init != 0 )
    {
        DNS_DEBUG( DP, (
            "%s: not initialized %ld\n", fn,
            init ));
        InterlockedIncrement( &g_liDpInitialized );
        goto Done;
    }

    //
    //  Perform cleanup
    //

    DeleteCriticalSection( &g_DpCS );

    Done:
    return;
}   //  Dp_Cleanup


//
//  End dpart.c
//


#if 0

//
//  This is now done on the client side.
//



DNS_STATUS
Dp_CreateForeignDomainPartition(
    IN      LPSTR       pszDomainFqdn
    )
/*++

Routine Description:

    Attempt to create the built-in domain partition for a foreign
    domain. A foreign domain is any domain to which this server does
    not belong.

    To create this partition we must RPC from this server to a remote
    server in that domain that can be found for the forest. This 
    routine should be called from within an RPC operation so that we 
    are currently impersonating the admin. The DNS server is unlikely to 
    have permissions to create new parititions.

Arguments:

    pszDomainFqdn -- UTF-8 FQDN of the foreign domain

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Dp_CreateForeignDomainPartition" )

    DNS_STATUS      status = ERROR_SUCCESS;

    return status;
}   //  Dp_CreateForeignDomainPartition



DNS_STATUS
Dp_CreateAllDomainBuiltinDps(
    OUT     LPSTR *     ppszErrorDp         OPTIONAL
    )
/*++

Routine Description:

    Attempt to create the built-in domain partitions for all domains
    that can be found for the forest. This routine should be called
    from within an RPC operation so that we are currently impersonating
    the admin. The DNS server is unlikely to have permissions to create
    new parititions.

    If an error occurs, the error code and optionally the name of the
    partition will be returned but this function will attempt to create
    the domain partitions for all other domains before returning. The
    error codes for any subsequent partitions will be lost.

Arguments:

    ppszErrorDp -- on error, set to a the name of the first partition
        where an error occured the string must be freed by the caller

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Dp_CreateAllDomainBuiltinDps" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      finalStatus = ERROR_SUCCESS;
    PLDAP           ldapSession = NULL;
    WCHAR           wszpartitionsContainerDn[ MAX_DN_PATH + 1 ];
    DWORD           dwsearchTime;
    DS_SEARCH       searchBlob;
    PLDAPSearch     psearch;
    PWSTR *         ppwszAttrValues = NULL;
    PWSTR           pwszCrDn = NULL;
    PSTR            pszdnsRoot = NULL;
    BOOL            fmadeChange = FALSE;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl_DGO,
        NULL
    };

    #define SET_FINAL_STATUS( status )                                  \
        if ( status != ERROR_SUCCESS && finalStatus == ERROR_SUCCESS )  \
        {                                                               \
            finalStatus = status;                                       \
        }

    Ds_InitializeSearchBlob( &searchBlob );

    //
    //  Get the DN of the partitions container.
    //

    getPartitionsContainerDn(
        wszpartitionsContainerDn,
        sizeof( wszpartitionsContainerDn ) /
            sizeof( wszpartitionsContainerDn[ 0 ] ) );
    if ( !*wszpartitionsContainerDn )
    {
        DNS_DEBUG( DP, (
            "%s: unable to find partitions container\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Bind to the local DS and open up a search for all partitions.
    //

    ldapSession = Ds_Connect(
                        LOCAL_SERVER_W,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to local server status=%d\n", fn,
            status ));
        goto Done;
    }

    DS_SEARCH_START( dwsearchTime );

    psearch = ldap_search_init_page(
                    ldapSession,
                    wszpartitionsContainerDn,
                    LDAP_SCOPE_ONELEVEL,
                    g_szCrossRefFilter,
                    g_CrossRefDesiredAttrs,
                    FALSE,                      //  attrs only flag
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  sort keys

    DS_SEARCH_STOP( dwsearchTime );

    if ( !psearch )
    {
        DWORD       dw = LdapGetLastError();

        DNS_DEBUG( ANY, (
            "%s: search open error %d\n", fn,
            dw ));
        status = Ds_ErrorHandler( dw, wszpartitionsContainerDn, ldapSession, 0 );
        goto Done;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate through crossref search results.
    //

    while ( 1 )
    {
        PLDAPMessage    pldapmsg;
        DWORD           dw;
        PDNS_DP_INFO    pdp;
        CHAR            szfqdn[ DNS_MAX_NAME_LENGTH ];

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( DP, (
                "%s: search error %d\n", fn,
                status ));
            break;
        }
        pldapmsg = searchBlob.pNodeMessage;

        //  Get the DN of this object.
        ldap_memfree( pwszCrDn );
        pwszCrDn = ldap_get_dn( ldapSession, pldapmsg );
        DNS_DEBUG( DP2, (
            "%s: found crossRef\n    %S\n", fn,
            pwszCrDn ));

        //
        //  Read and parse the systemFlags for the crossRef. We only
        //  want domain crossRefs.
        //

        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                            ldapSession,
                            pldapmsg, 
                            DNS_DP_ATTR_SYSTEM_FLAGS );
        if ( !ppwszAttrValues || !*ppwszAttrValues )
        {
            DNS_DEBUG( DP, (
                "%s: error %lu %S value missing from crossRef object\n    %S\n", fn,
                LdapGetLastError(),
                DNS_DP_ATTR_SYSTEM_FLAGS,
                pwszCrDn ));
            ASSERT( ppwszAttrValues && *ppwszAttrValues );
            continue;
        }

        dw = _wtoi( *ppwszAttrValues );
        if ( !( dw & FLAG_CR_NTDS_NC ) || !( dw & FLAG_CR_NTDS_DOMAIN ) )
        {
            DNS_DEBUG( DP, (
                "%s: ignoring crossref with %S=0x%X\n    %S\n", fn,
                DNS_DP_ATTR_SYSTEM_FLAGS,
                dw,
                pwszCrDn ));
            continue;
        }

        //
        //  Found a domain crossRef. Retrieve the dnsRoot name and formulate the
        //  name of the built-in partition for this domain.
        //

        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                            ldapSession,
                            pldapmsg, 
                            DNS_DP_DNS_ROOT );
        if ( !ppwszAttrValues || !*ppwszAttrValues )
        {
            DNS_DEBUG( DP, (
                "%s: error %lu %S value missing from crossRef object\n    %S\n", fn,
                LdapGetLastError(),
                DNS_DP_DNS_ROOT,
                pwszCrDn ));
            ASSERT( ppwszAttrValues && *ppwszAttrValues );
            continue;
        }

        FREE_HEAP( pszdnsRoot );
        pszdnsRoot = Dns_StringCopyAllocate(
                                ( PCHAR ) *ppwszAttrValues,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );
        if ( !pszdnsRoot )
        {
            ASSERT( pszdnsRoot );
            continue;
        }

        if ( strlen( SrvCfg_pszDomainDpBaseName ) +
            strlen( pszdnsRoot ) + 3 > sizeof( szfqdn ) )
        {
            ASSERT( strlen( SrvCfg_pszDomainDpBaseName ) +
                strlen( pszdnsRoot ) + 3 < sizeof( szfqdn ) );
            continue;
        } 

        sprintf( szfqdn, "%s.%s", SrvCfg_pszDomainDpBaseName, pszdnsRoot );

        DNS_DEBUG( DP, ( "%s: domain DP %s", fn, szfqdn ));

        //
        //  Find existing crossRef matching this name. Create/enlist
        //  as required.
        //

        pdp = Dp_FindByFqdn( szfqdn );
        if ( pdp )
        {
            //
            //  If the partition exists and is enlisted there is nothing to do.
            //  If the partition is not enlisted and this is the built-in
            //  domain partition for this server, enlist it.
            //

            if ( !IS_DP_ENLISTED( pdp ) &&
                g_pszDomainDefaultDpFqdn &&
                _stricmp( g_pszDomainDefaultDpFqdn, pdp->pszDpFqdn ) == 0 )
            {
                status = Dp_ModifyLocalDsEnlistment( pdp, TRUE );
                SET_FINAL_STATUS( status );
                if ( status == ERROR_SUCCESS )
                {
                    fmadeChange = TRUE;
                }
            }
        }
        else
        {
            //
            //  This partition does not exist. If the partition matches the
            //  name of this DNS server's domain partition, then we can
            //  create it locally. If this partition is for a foreign
            //  domain, then we must contact a DNS server for that domain
            //  for creation. We cannot create it locally because that 
            //  will enlist us in the partition, which is not what we want.
            //

            if ( g_pszDomainDefaultDpFqdn &&
                _stricmp( g_pszDomainDefaultDpFqdn, pdp->pszDpFqdn ) == 0 )
            {
                //  This partition is for the local server's domain.

                status = Dp_CreateByFqdn( szfqdn, dnsDpSecurityDomain, TRUE );
                SET_FINAL_STATUS( status );
                if ( status == ERROR_SUCCESS )
                {
                    fmadeChange = TRUE;
                }
            }
            else
            {
                //  This partition is for a foreign domain.

                Dp_CreateForeignDomainPartition( pszdnsRoot );
            }
        }
    }

    //
    //  Cleanup and return.
    //
            
    Done:

    FREE_HEAP( pszdnsRoot );

    ldap_memfree( pwszCrDn );

    ldap_value_free( ppwszAttrValues );

    Ds_CleanupSearchBlob( &searchBlob );

    Ds_LdapUnbind( &ldapSession );
    
    if ( fmadeChange )
    {
        Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );
    }

    DNS_DEBUG( RPC, (
        "%s: returning 0x%08X\n", fn, status ));
    return finalStatus;
}   //  Dp_CreateAllDomainBuiltinDps

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dnssrv.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dnssrv.h

Abstract:

    Domain Name System (DNS) Server

    Main header file for DNS server service.

Author:

    Jim Gilroy (jamesg) May 1995

Revision History:

--*/

#ifndef _DNSSRV_INCLUDED_
#define _DNSSRV_INCLUDED_


//
//  flag to indicate building for DNSSRV
//  allows us to ignore conflicting definitions in DNS library
//

#define DNSSRV 1

//
//  Misc switches - comment switch out to disable feature
//

#define DNSSRV_PLUGINS      1

//
//  indicate UTF8 filenames to macro in correct functions
//  from file.h
//

#define UTF8_FILENAMES 1

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#define FD_SETSIZE 300

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS        // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <windowsx.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#ifndef DNS_WINSOCK1
#include <winsock2.h>
#else
#include <winsock.h>
#endif

#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tchar.h>
#include <limits.h>
#include <time.h>

#define LDAP_UNICODE        1
#include <winldap.h>        //  public LDAP
#include <winber.h>         //  for ber formatting
#include <ntldap.h>         //  public server ldap constants
#include <rpc.h>            //  RPC def needed for ntdsapi.h
#include <ntdsapi.h>        //  DS access bit definitions
#include <ntdsadef.h>       //  DS constants
#include <dsrole.h>

#define DNSLIB_SECURITY     //  include security defs
//#define SDK_DNS_RECORD    //  DNS_RECORD in SDK format
#define NO_DNSAPI_DLL       //  build without requiring dnsapi.dll
#include <dnslibp.h>        //  DNS library routines
#include <shlwapi.h>        //  SHDeleteKey

#define STRSAFE_NO_DEPRECATE    //  Do not deprecate strcpy, etc.
#include <strsafe.h>            //  safe string functions

//
//  windns.h fix ups
//

typedef DNS_WIRE_QUESTION  DNS_QUESTION, *PDNS_QUESTION;


//
//  DCR_PERF:  turn on fastcall
//

#ifdef FASTCALL
#undef FASTCALL
#define FASTCALL
#endif

#include "dnsrpc_s.h"       //  DNS RPC definitions

#include "dnsperf.h"
#include "srvcfg.h"
#include "dnsmsg.h"
#include "file.h"
#include "tree.h"
#include "name.h"
#include "record.h"
#include "update.h"
#include "dpart.h"
#include "EventControl.h"
#include "zone.h"
#include "registry.h"
#include "msginfo.h"
#include "socket.h"
#include "packetq.h"
#include "dbase.h"
#include "recurse.h"
#include "nameutil.h"
#include "stats.h"
#include "debug.h"
#include "memory.h"
#include "dfile.h"
#include "wins.h"
#include "rrfunc.h"
#include "dnsprocs.h"
#include "rescodes.h"
#include "sdutl.h"
#include "ds.h"
#include "dsutil.h"
#include "timeout.h"
#include "wrappers.h"
#include "log.h"
#include "tcpcon.h"

#ifdef DNSSRV_PLUGINS
#include "plugin.h"
#endif


//
//  DNS Service Name
//

#define DNS_SERVICE_NAME        TEXT("DNS")


//
//  TEXT Macros independent of build target
//

#define UTF8_TEXT(sz)   (sz)

#define WIDE_TEXT2(sz)  (L##sz)
#define WIDE_TEXT(sz)   WIDE_TEXT2(sz)


//
//  Secure update testing
//
//  DEVNOTE: clear test flag when test cycle complete
//

#define SECURE_UPDATE_TEST  1


//
//  Access control
//

#define DNS_VIEW_ACCESS         0x0001
#define DNS_ADMIN_ACCESS        0x0002

#define DNS_ALL_ACCESS          ( STANDARD_RIGHTS_REQUIRED | \
                                    DNS_VIEW_ACCESS |        \
                                    DNS_ADMIN_ACCESS )


//
//  DNS server error space
//

#define DNS_SERVER_STATUS_ID                    (0x0011D000)
#define DNSSRV_STATUS                           (0x0011D000)

//  General

#define DNSSRV_UNSPECIFIED_ERROR                (DNSSRV_STATUS | 0xC0000100)
#define DNSSRV_STATUS_SERVICE_STOP              (DNSSRV_STATUS | 0x00000101)

//  Recursion

#define DNSSRV_ERROR_MISSING_GLUE               (DNSSRV_STATUS | 0xC0000303)
#define DNSSRV_ERROR_OUT_OF_IP                  (DNSSRV_STATUS | 0xC0000304)
#define DNSSRV_ERROR_ZONE_ALREADY_RESPONDED     (DNSSRV_STATUS | 0xC0000305)
#define DNSSRV_ERROR_ONLY_ROOT_HINTS            (DNSSRV_STATUS | 0xC0000306)

//  Zone transfer

#define DNSSRV_STATUS_AXFR_COMPLETE             (DNSSRV_STATUS | 0x00000400)
#define DNSSRV_STATUS_NEED_AXFR                 (DNSSRV_STATUS | 0x00000401)
#define DNSSRV_STATUS_NEED_TCP_XFR              (DNSSRV_STATUS | 0x00000402)
#define DNSSRV_STATUS_AXFR_IN_IXFR              (DNSSRV_STATUS | 0x00000403)
#define DNSSRV_STATUS_IXFR_UNSUPPORTED          (DNSSRV_STATUS | 0x00000404)

#define DNSSRV_ERROR_MASTER_FAILURE             (DNSSRV_STATUS | 0xC0000405)
#define DNSSRV_ERROR_ABORT_BY_MASTER            (DNSSRV_STATUS | 0xC0000406)
#define DNSSRV_ERROR_MASTER_UNAVAILIABLE        (DNSSRV_STATUS | 0xC0000407)


//  Data files

#define DNSSRV_PARSING_ERROR                    (DNSSRV_STATUS | 0xC0000501)
#define DNSSRV_ERROR_EXCESS_TOKEN               (DNSSRV_STATUS | 0xC0000502)
#define DNSSRV_ERROR_MISSING_TOKEN              (DNSSRV_STATUS | 0xC0000503)
#define DNSSRV_ERROR_INVALID_TOKEN              (DNSSRV_STATUS | 0xC0000504)
#define DNSSRV_WARNING_IGNORED_RECORD           (DNSSRV_STATUS | 0x80000505)
#define DNSSRV_STATUS_ADDED_WINS_RECORD         (DNSSRV_STATUS | 0x00000506)

#if 0
#define DNSSRV_STATUS_FILE_CHAR_SPECIAL         (DNSSRV_STATUS | 0x00000511)
#define DNSSRV_STATUS_FILE_CHAR_OCTAL           (DNSSRV_STATUS | 0x00000512)
#endif

//  Registry

#define DNSSRV_STATUS_REGISTRY_CACHE_ZONE       (DNSSRV_STATUS | 0x00000521)

//  DS

#define DNSSRV_STATUS_DS_SEARCH_COMPLETE        (DNSSRV_STATUS | 0x00000601)
#define DNSSRV_STATUS_DS_ENUM_COMPLETE          (DNSSRV_STATUS | 0x00000602)
#define DNSSRV_STATUS_DS_UNAVAILABLE            (DNSSRV_STATUS | 0x00000603)

//  Timeout

#define DNSSRV_STATUS_NODE_RECENTLY_ACCESSED    (DNSSRV_STATUS | 0x00000621)

//  Update

#define DNSSRV_STATUS_SECURE_UPDATE_CONTINUE    (DNSSRV_STATUS | 0x00000701)
#define DNSSRV_STATUS_UPDATE_NO_DS_WRITE        (DNSSRV_STATUS | 0x00000702)
#define DNSSRV_STATUS_UPDATE_NO_HOST_DELETE     (DNSSRV_STATUS | 0x00000703)

//
//  Status code overlays
//

#define DNSSRV_ERROR_UNSECURE_PACKET            (DNS_ERROR_BAD_PACKET)

//
//  Use this to prevent DNSSRV_STATUS from going back to clients.
//

#define DnsRpcFixStatus( status )                                       \
    if ( status & DNSSRV_STATUS )                                       \
    {                                                                   \
        status = DNS_ERROR_RCODE_SERVER_FAILURE;                        \
    }


//
//  DNS globals
//

//
//  Service control
//

extern  BOOL    fDnsThreadAlert;
extern  BOOL    fDnsServiceExit;

//
//  Service control globals
//

extern  SERVICE_STATUS              DnsServiceStatus;
extern  SERVICE_STATUS_HANDLE       DnsServiceStatusHandle;

#define DNSSRV_SHUTDOWN_WAIT_HINT   (30000)         // 30 seconds
#define DNSSRV_STARTUP_WAIT_HINT    (20000)         // 20 seconds

//
//  Service Events
//

extern  HANDLE  hDnsContinueEvent;
extern  HANDLE  hDnsShutdownEvent;
extern  HANDLE  hDnsCacheLimitEvent;

//
//  Netlogon Notification
//

extern  LPWSTR  g_wszNetlogonServiceName;

//
//  Restart globals
//

extern  DWORD   g_LoadCount;
extern  BOOL    g_fDoReload;

//
//  System
//

extern  DWORD   g_ProcessorCount;

//
//  DNS Database
//

extern  DWORD   Dbase_Type;

//
//  General lock
//

extern  CRITICAL_SECTION    g_GeneralServerCS;

#define GENERAL_SERVER_LOCK()       EnterCriticalSection( &g_GeneralServerCS );
#define GENERAL_SERVER_UNLOCK()     LeaveCriticalSection( &g_GeneralServerCS );


//
//  DS - Name of DNS container.  Used by (srvrpc.c)
//

extern  PWCHAR   g_pwszDnsContainerDN;

//
//  Security globals from startup at dns.c
//

extern  PSECURITY_DESCRIPTOR g_pDefaultServerSD;
extern  PSECURITY_DESCRIPTOR g_pServerObjectSD;
extern  PSID g_pServerSid;
extern  PSID g_pServerGroupSid;
extern  PSID g_pAuthenticatedUserSid;
extern  PSID g_pEnterpriseDomainControllersSid;
extern  PSID g_pDomainControllersSid;
extern  PSID g_pEnterpriseAdminsSid;
extern  PSID g_pBuiltInAdminsSid;
extern  PSID g_pLocalSystemSid;
extern  PSID g_pDnsAdminSid;
extern  PSID g_pDomainAdminsSid;
extern  PSID g_pEveryoneSid;
extern  PSID g_pDynuproxSid;


//
//  Recursion queue
//

extern  PPACKET_QUEUE   g_pRecursionQueue;

//
//  Update queue -- zone lock routines must access
//      to check retries
//

extern  PPACKET_QUEUE   g_UpdateQueue;

extern  PPACKET_QUEUE   g_SecureNegoQueue;

//
//  Cache limit:
//
//  g_dwCacheLimitCurrentTimeAdjustment: seconds to adjust current time
//      by when making TTL comparisons or DNS_CACHE_LIMIT_DISCARD_ALL
//      to force all eligible RRs to be discarded
//
//  g_dwCacheFreeCount: used to track progress of RR free routines
//

extern DWORD        g_dwCacheLimitCurrentTimeAdjustment;
extern DWORD        g_dwCacheFreeCount;

#define DNS_CACHE_LIMIT_DISCARD_ALL     ( ( DWORD ) -1 )

#define DNS_SERVER_CURRENT_CACHE_BYTES \
    ( MemoryStats.MemTags[ MEMTAG_RECORD_CACHE ].Memory +       /*  33  */ \
      MemoryStats.MemTags[ MEMTAG_NODE_CACHE ].Memory )         /*  46  */

//
//  Aging globals
//

extern DWORD   g_LastScavengeTime;


//
//  Misc globals
//

extern DWORD   g_dwEnableAdvancedDatabaseLocking;


//
//  Exception handling
//
//  If retail, AV and out of memory exceptions will be caught at thread top
//      and restart attempted.
//  If debug, no exceptions will be caught at thread top.
//

#define DNS_EXCEPTION_OUT_OF_MEMORY     (0x0000d001)
#define DNS_EXCEPTION_PACKET_FORMERR    (0x0000d003)


//
//  Top level exception
//

#define TOP_LEVEL_EXCEPTION_TEST()  \
            ( (SrvCfg_bReloadException &&                               \
                ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ||   \
                  GetExceptionCode() == DNS_EXCEPTION_OUT_OF_MEMORY ))  \
                    ?   EXCEPTION_EXECUTE_HANDLER                       \
                    :   EXCEPTION_CONTINUE_SEARCH )

#define TOP_LEVEL_EXCEPTION_BODY()


//
//  Locking
//

#define IS_LOCKED( pLock )  \
            ( (pLock)->LockCount > 0 )

#define IS_UNLOCKED( pLock )  \
            ( (pLock)->LockCount == 0 )




//
//  DS access control constants:
//
//  HiteshR explained that ACTRL_DS_LIST_OBJECT is only sometimes enabled.
//  To properly use it you should check to see if the DS currently supports
//  it. If the DS does not, it should be removed from the mask. However,
//  DNS has no need to EVER support ACTRL_DS_LIST_OBJECT, so we will exclude
//  it from all the access control masks.
//

#define DNS_DS_GENERIC_READ         ( DS_GENERIC_READ & ~ACTRL_DS_LIST_OBJECT )
#define DNS_DS_GENERIC_WRITE        ( DS_GENERIC_WRITE )
#define DNS_DS_GENERIC_EXECUTE      ( DS_GENERIC_EXECUTE )
#define DNS_DS_GENERIC_ALL          ( DS_GENERIC_ALL & ~ACTRL_DS_LIST_OBJECT )


//
//  When writing RRs we may need to reserve space at the end of the
//  packet for a minimum-sized OPT RR. (Actually 11 bytes.)
//

#define DNS_MINIMIMUM_OPT_RR_SIZE   12

#define DNS_SERVER_DEBUG_LOG_WRAP   20000000


//
//  Server state global
//

#define DNS_STATE_LOADING           0x0001
#define DNS_STATE_RUNNING           0x0002
#define DNS_STATE_TERMINATING       0x0003

extern DWORD g_ServerState;

#if DBG
extern BOOL g_RunAsService;
#endif


//
//  IPv6 (move to own header file?)
//


WS2TCPIP_INLINE
BOOL
Dns_ValidateDnsAddrArray(
    IN      PDNS_ADDR_ARRAY     pAddrArray,
    IN      DWORD               dwFlag
    )
{
    PIP_ARRAY       pip4array = DnsAddrArray_CreateIp4Array( pAddrArray );
    BOOL            valid;
    
    valid = pip4array &&
            Dns_ValidateIpAddressArray(
                    pip4array->AddrArray,
                    pip4array->AddrCount,
                    dwFlag );

    FREE_HEAP( pip4array );

    return valid;
}


WS2TCPIP_INLINE
VOID
DnsAddrArray_SetPort(
    IN      PDNS_ADDR_ARRAY     pAddrArray,
    IN      WORD                wPort
    )
{
    if ( pAddrArray )
    {
        DWORD   i;

        for ( i = 0; i < pAddrArray->AddrCount; ++i )
        {
            DnsAddr_SetPort( &pAddrArray->AddrArray[ i ], wPort );
        }
    }
}

#define DnsAddr_Reset( p )  DnsAddr_Clear( p ); DnsAddr_SetSockaddrRecvLength( p )


//
//  Misc configuration functions
//


DNS_STATUS
DnsSrv_SetAdminConfigured(
    IN      DWORD       dwNewAdminConfiguredValue
    );


//
//  TEMPORARY SECTION!!! Add new error codes, etc. here so that DNS server
//  checkins do not require sync and build of other components. Remove anything
//  added to this section within a week or two.
//


#endif //   _DNSSRV_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\ds.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ds.c

Abstract:

    Domain Name System (DNS) Server

    Directory Service (DS) integration.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "dnssrv.h"


#define MEMTAG_DS_SECURITY  MEMTAG_DS_OTHER
#define MEMTAG_DS_PROPERTY  MEMTAG_DS_OTHER


#ifdef UNICODE
#undef UNICODE
#endif

#ifdef LDAP_UNICODE
#define  LDAP_TEXT(str)           L ## str
#else
#define  LDAP_TEXT(str)           str
#endif


//
//  Wait up to 1 minute intervals to DS to start
//
//  Note, this is also time between checkpoints to SC
//  while waiting on DS to start.  So interval < one minute
//  is desired.
//

#define DNSSRV_DS_SYNC_WAIT_INTERVAL_MS     30000       // 30s

//
//  Wait up to a total of 15 minutes before placing an event
//

#define DNSSRV_DS_SYNC_WAIT_MAX_MS          900000      // 15min


//
//  DS-DNS internal datatypes
//
//  According to Andy, DS server is somewhat not intelligent and i'll get
//  the best results -- and thrash disk less -- with small page size.
//

#define DNS_LDAP_SEARCH_SIZE_LIMIT  0x01000000  // (0xffffffff)
#define DNS_LDAP_PAGE_SIZE          100

#define LDAP_FILTER_SEARCH_LENGTH   64


//
//  DS Zone polling interval
//  Poll DS for changes from remote at this interval
//

#define DNS_DS_POLLING_INTERVAL     300         // five minutes


//
//  The ACL on the Microsoft DNS object will be read at most
//  this frequently.
//

#define DS_MS_DNS_ACL_REFRESH_INTERVAL      30      //  seconds

//
// Multi-byte single char conversion support
//

//
// MultiByte to WideChar:
// pStr:       IN        multi-byte (LPSTR)
// pwStr:      OUT       wide char (PWSTR )
// ccwStr:      OPTIONAL  size of out buffer in number of wide chars.
//                        if 0, we'll tak MAX_DN_PATH
//
// WideChar to Multibyte is symmetrically reversed.
//
// DEVNOTE: CP_UTF8 with flags==0 seems to be correct - verify?
//
#define UTF8_TO_WC(pStr, pwStr, ccwStr)                   \
{                                                         \
    INT iWritten = MultiByteToWideChar(                   \
               CP_UTF8,                                   \
               0,                                         \
               pStr,                                      \
               -1,                                        \
               pwStr,                                     \
               ccwStr);                                   \
    if ( 0 == iWritten )                                  \
    {                                                     \
        DNS_DEBUG( DS, ("Error <%lu>: UTF8_TO_WC conversion failed\n",   \
                         GetLastError() ));                          \
        ASSERT ( FALSE );                                            \
    }                                                                \
}


#define WC_TO_UTF8(pwStr, pStr, ccStr)                    \
{                                                         \
    INT iWritten = WideCharToMultiByte(                   \
                CP_UTF8,                                  \
                0,                                        \
                pwStr,                                    \
                -1,                                       \
                pStr,                                     \
                ccStr,                                    \
                NULL,                                     \
                NULL);                                    \
    if ( 0 == iWritten )                                  \
    {                                                     \
        DNS_DEBUG( DS, ("Error <%lu>: WC_TO_UTF8 conversion failed\n",   \
                         GetLastError() ));                          \
        ASSERT ( FALSE );                                            \
    }                                                                \
}

#define DS_SAME_AS_PARENT_DISPLAY_NAME  L"(same as parent object)"


extern DSATTRPAIR DSEAttributes[] =
{
    //  attribute name                          multi-valued?  value(s)
    { LDAP_TEXT( "currentTime" ),                   FALSE,      NULL },
    { LDAP_TEXT( "dsServiceName" ),                 FALSE,      NULL },
    { LDAP_TEXT( "defaultNamingContext" ),          FALSE,      NULL },
    { LDAP_TEXT( "schemaNamingContext" ),           FALSE,      NULL },
    { LDAP_TEXT( "configurationNamingContext" ),    FALSE,      NULL },
    { LDAP_TEXT( "rootDomainNamingContext" ),       FALSE,      NULL },
    { LDAP_TEXT( "highestCommittedUSN" ),           FALSE,      NULL },
    { LDAP_TEXT( "dnsHostName" ),                   FALSE,      NULL },
    { LDAP_TEXT( "serverName" ),                    FALSE,      NULL },
    { LDAP_TEXT( "namingContexts" ),                TRUE,       NULL },
    { NULL,                                         FALSE,      NULL }
};

//
//  Directory globals
//

PWCHAR  g_dnMachineAcct;
WCHAR   g_wszDomainFlatName[LM20_DNLEN+1];

//  DNS container created under DS root in system container
//      "cn=dns,cn=system,"<DS rootDN>

PWCHAR  g_pszRelativeDnsSysPath = LDAP_TEXT("cn=MicrosoftDNS,cn=System,");
PWCHAR  g_pszBareRelativeDnsSysPath = LDAP_TEXT("cn=System,");
PWCHAR  g_pszRelativeDnsFolderPath = LDAP_TEXT("cn=MicrosoftDNS,");
PWCHAR  g_pwszDnsContainerDN = NULL;


//
//  Proxies security group
//  Note: used both for samaccountname & for rdn value
//

#define SZ_DYNUPROX_SECGROUP        LDAP_TEXT("DnsUpdateProxy")

#define SZ_DYNUPROX_DESCRIPTION     \
    LDAP_TEXT("DNS clients who are permitted to perform dynamic updates ") \
    LDAP_TEXT("on behalf of some other clients (such as DHCP servers).")

//
//  Save length needed in addition to zone name length, for building zone DN
//      "dc="<zoneDN>","<dnsContainerDN>

DWORD   g_AppendZoneLength;

//
//  Server name for serial synchronization
//

PWCHAR  g_pwsServerName;


//
//  Keep pointer to LDAP structure
//

// disable ldap handle, thus DS interface is unavailable
BOOL g_bDisabledDs;
#define IS_DISABLED_LDAP_HANDLE()       g_bDisabledDs
#define DISABLE_LDAP_HANDLE()           g_bDisabledDs = TRUE;
// enable ldap handle connection attempt
#define ENABLE_LDAP_HANDLE()            g_bDisabledDs = FALSE;

PLDAP   pServerLdap = NULL;


//
//  LDAP reconnect tracking
//

DWORD   g_dwLastLdapReconnectTime =     0;

#define DNS_LDAP_RECONNECT_FREQUENCY    30


PWCHAR  g_pwszEmptyString = L"\0";      //  static empty string

// set client timeout value to be double the server timeout value
LDAP_TIMEVAL    g_LdapTimeout = { DNS_LDAP_TIME_LIMIT_S * 2, 0 };

//
//  The largest LDAP atomic delete operation is currently 16k records.
//  This takes approx 16 minutes on my test machine. So we'll wait
//  50% longer = 24 minutes.
//

LDAP_TIMEVAL    g_LdapDeleteTimeout = { 24 * 60, 0 };


//  Protect against multiple opens

BOOL    g_AttemptingDsOpen;


//
//  DS access serialization.
//
//  We have to serialize wldap usage since the handle may become
//  unusable due to DS access problems.
//  We'll initialize the ptr on first open, assign the ptr & never
//  re-initialize cause the ptr will get assigned on startup.
//  see Ds_OpenServer
//
//  DEVNOTE-DCR: 454319 - Can we eliminate this CS or is it really needed?
//

#define DNS_DS_ACCESS_SERIALIZATION 1

#if DNS_DS_ACCESS_SERIALIZATION

CRITICAL_SECTION        csLdap;
PCRITICAL_SECTION       pcsLdap = NULL;

#define LDAP_LOCK()       { ASSERT ( pcsLdap ); EnterCriticalSection ( pcsLdap ); }
#define LDAP_UNLOCK()     { ASSERT ( pcsLdap ); LeaveCriticalSection ( pcsLdap ); }

#define JUMP_IF_DISCONNECTED( label, status )       \
        if ( !Ds_ValidHandle() )                    \
        {                                           \
            status  = DNS_ERROR_DS_UNAVAILABLE;     \
            goto label;                             \
        }
#else   // no serialization

#define LDAP_LOCK()       (0)
#define LDAP_UNLOCK()     (0)
#define JUMP_IF_DISCONNECTED( label, status)        ( 0 )

#endif


//
//  Attribute list for ldap searches.
//

extern PWSTR    DsTypeAttributeTable[] =
{
    LDAP_TEXT("DC"),
    LDAP_TEXT("DnsRecord"),
    LDAP_TEXT("dnsProperty"),
    LDAP_TEXT("objectGuid"),
    LDAP_TEXT("ntSecurityDescriptor"),
    LDAP_TEXT("whenCreated"),
    LDAP_TEXT("whenChanged"),
    LDAP_TEXT("usnCreated"),
    LDAP_TEXT("usnChanged"),
    LDAP_TEXT("objectClass"),
    NULL
};

//
//  USN query attribute
//

WCHAR    g_szHighestCommittedUsnAttribute[] = LDAP_TEXT("highestCommittedUSN");

//
//  Filter for "get everything" searches.
//
//  September 2002: Andrew Goodsell says that for .NET, objectClass will
//  give better perf than objectCategory for the zone load searches.
//  (Something about intersection of indices.)
//

WCHAR    g_szWildCardFilter[] = LDAP_TEXT("(objectCategory=*)");
WCHAR    g_szChangeNotificationFilter[] = LDAP_TEXT("(objectClass=*)");
WCHAR    g_szDnsNodeFilter[] = LDAP_TEXT("(objectClass=dnsNode)");
WCHAR    g_szDnsZoneFilter[] = LDAP_TEXT("(objectCategory=dnsZone)");
WCHAR    g_szDnsZoneOrNodeFilter[] = LDAP_TEXT("(|(objectCategory=dnsNode)(objectCategory=dnsZone))");


//
//  DNS property attribute.
//  This is used at both server and zone level.
//

typedef struct _DsDnsProperty
{
    DWORD   DataLength;
    DWORD   NameLength;
    DWORD   Flag;
    DWORD   Version;
    DWORD   Id;
    UCHAR   Data[1];
    CHAR    Name[1];

    //  Data follows after name
}
DS_PROPERTY, *PDS_PROPERTY;

#define DS_PROPERTY_VERSION_1       (1)

//
//  Name of root hints "zone" in DS
//

#define DS_CACHE_ZONE_NAME  LDAP_TEXT("RootDNSServers")

//
// as defined in \nt\private\ds\src\dsamain\include\mdlocal.h
// the DS method for marking bad chars
// orig defined name:
// #define BAD_NAME_CHAR 0x000A
// we'll add a ds to it...
#define BAD_DS_NAME_CHAR 0x0A


//  Flag to distiguish DNS node from LDAP object on overloaded delete call

#define DNSDS_LDAP_OBJECT           (0x10000000)


#if 0
//
//  Note, we can not use DS tombstones.
//  Problem is when they replicate the GUID is preserved but the name is lost.
//  The name is now a GUIDized name with additional managaling. The object name is gone.
//  So this eliminates the opportunity for the remote server to use them.
//  Also by keeping them around, we don't generate lots of deleted objects on
//  simply add\delete operations.

LDAPControl     TombstoneControl;
DWORD           TombstoneDataValue = 1;
#endif


//
//  Lazy writing control. Not that the global last commit time is not
//  protected. This is for speed. If the global is stomped on by multiple
//  threads and commits occur too frequently this should not be a problem.
//

LDAPControl     LazyCommitControl;
DWORD           LazyCommitDataValue = 1;

DWORD           g_dwLastLazyCommitTime = 0;


//
//  No-referrals control
//

LDAPControl     NoDsSvrReferralControl;

//
//  SD control info
//

#define SECURITYINFORMATION_LENGTH 5

BYTE    g_SecurityInformation_DGO[] =
    {
    0x30,
    0x03,
    0x02,
    0x01,
    ( BYTE ) DACL_SECURITY_INFORMATION
             | GROUP_SECURITY_INFORMATION
             | OWNER_SECURITY_INFORMATION
    };

BYTE    g_SecurityInformation_D[] =
    {
    0x30,
    0x03,
    0x02,
    0x01,
    ( BYTE ) DACL_SECURITY_INFORMATION
    };

LDAPControl     SecurityDescriptorControl_DGO;      //  DACL, owner, group
LDAPControl     SecurityDescriptorControl_D;        //  DACL only



//
//  LDAP Mod building
//  Avoids repetitive alloc, dealloc of tiny structs
//

typedef struct  _DsModBuffer
{
    DWORD           Attribute;
    DWORD           Count;
    DWORD           MaxCount;
    DNS_STATUS      Error;
    WORD            WriteType;
    DWORD           SerialNo;

    //  buffer position

    PBYTE           pCurrent;
    PBYTE           pBufferEnd;
    PBYTE           pAdditionalBuffer;

    //  current item info

    PLDAP_BERVAL    pBerval;
    PVOID           pData;

    //  LDAP mod and associated berval array

    LDAPMod         LdapMod;
    PLDAP_BERVAL    BervalPtrArray[1];

    //  berval array is followed by attributes
    //
    //  each attribute
    //      - berval
    //          - ptr to data
    //          - data length
    //      - data
    //          - data header (record\property)
    //          - data

}
DS_MOD_BUFFER, *PDS_MOD_BUFFER;

//
//  General MOD building
//

//  Adequate for almost everythingt and insures don't have to realloc berval array
//      up to 2K (1K Win64) entries
//
//

#if DBG
#define RECORD_MOD_BUFFER_SIZE      200
#else
#define RECORD_MOD_BUFFER_SIZE      8192    // 8K
#endif

//  Realloc size, make so big it won't fail

#define MOD_BUFFER_REALLOC_LENGTH   (0x40000)   // 256K, covers anything possible

//
//  For tombstone limited to one record
//

#define RECORD_SMALL_MOD_BUFFER_SIZE    400


//
//  Property mod's are smaller too
//      - currently only about 8 properties
//      - most DWORDS
//

#define MAX_DNS_PROPERTIES          20
#define MAX_ZONE_PROPERTIES         MAX_DNS_PROPERTIES
#define MAX_NODE_PROPERTIES         MAX_DNS_PROPERTIES

#define PROPERTY_MOD_BUFFER_SIZE    (2048)  // 2K


//
//  Active Directory version globals
//

extern ULONG        g_ulDsForestVersion = DNS_INVALID_BEHAVIOR_VERSION;
extern ULONG        g_ulDsDomainVersion = DNS_INVALID_BEHAVIOR_VERSION;
extern ULONG        g_ulDsDsaVersion = DNS_INVALID_BEHAVIOR_VERSION;

extern ULONG        g_ulDownlevelDCsInDomain = DNS_INVALID_COUNT;
extern ULONG        g_ulDownlevelDCsInForest = DNS_INVALID_COUNT;



//
//  Standard LDAP mod
//
//  Avoids repetitive alloc, dealloc of tiny structs
//

typedef struct _DnsLdapSingleMod
{
    LDAPMod         Mod;
    LDAP_BERVAL     Berval;
    PLDAP_BERVAL    pBerval[2];
    PWSTR           rg_szVals[2];
}
DNS_LDAP_SINGLE_MOD, *PDNS_LDAP_SINGLE_MOD;

//
//  Initialize single mod, no side effects
//

#define INIT_SINGLE_MOD_LEN(pMod)   \
        {                           \
            (pMod)->pBerval[0] = &(pMod)->Berval;       \
            (pMod)->pBerval[1] = NULL;                  \
            (pMod)->Mod.mod_bvalues = (pMod)->pBerval;  \
        }

#define INIT_SINGLE_MOD(pMod)   \
        {                       \
            (pMod)->rg_szVals[1] = NULL;                \
            (pMod)->Mod.mod_values = (pMod)->rg_szVals; \
        }

//
//  Keep pre-built Add-Node mod
//
//  Avoid rebuilding each time we add a node.
//

DNS_LDAP_SINGLE_MOD     AddNodeLdapMod;

PLDAPMod    gpAddNodeLdapMod = (PLDAPMod) &AddNodeLdapMod;


//
//  Notification globals
//
#define INVALID_MSG_ID      0xFFFFFFFF

ULONG   g_ZoneNotifyMsgId = INVALID_MSG_ID;


//
// A global to indicate first time run of Dns server
// (known due to creation of CN=MicrosoftDns container
//
BOOL    g_bDsFirstTimeRun = FALSE;

//
//  These strings are used to mark zones that are being processed.
//  DS zones that start with ".." will always be ignored by other 
//  servers.
//

#define DNS_ZONE_DELETE_MARKER              L"..Deleted"
#define DNS_ZONE_IN_PROGRESS_MARKER         L"..InProgress"

#define DNS_MAX_DELETE_RENAME_ATTEMPTS      5

//
//  Private protos
//

DNS_STATUS
Ds_InitializeSecurity(
    IN      PLDAP           pLdap
    );

DNS_STATUS
GeneralizedTimeStringToValue(
    IN      LPSTR           szTime,
    OUT     PLONGLONG       pllTime
    );

BOOL
isDNinDS(
    IN      LDAP    *ld,
    IN      PWSTR   dn,
    IN      ULONG   scope,
    IN      PWSTR  pszFilter, OPTIONAL
    IN OUT  PWSTR  *pFoundDn   OPTIONAL
    );

DNS_STATUS
addProxiesGroup(
    IN      PLDAP           pldap
    );

DNS_STATUS
readAndUpdateNodeSecurityFromDs(
    IN OUT  PDB_NODE        pNode,
    IN      PZONE_INFO      pZone
    );

PDS_RECORD
makeTombstoneRecord(
    IN OUT  PDS_RECORD      pDsRecord,
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
setNotifyForIncomingZone(
    VOID
    );

BOOL
Ds_ValidHandle(
    VOID
    );

#ifndef DBG
#define Dbg_DsBervalArray(h,b,a)
#define Dbg_DsModBuffer(h,d,b)
#endif

DNS_STATUS
Ds_LdapErrorMapper(
    IN      DWORD           LdapStatus
    );



//
//  General utilities
//


PLDAPControl
lazyCommitControlPtr(
    VOID
    )
/*++

Routine Description:

    If this DS write should be committed, returns NULL, else returns
    a pointer to the LazyCommitControl global. Note: no protection on
    global. This could result in too many writes being committed, but
    that is preferable to adding more lock contention on updates.

Arguments:

    None.

Return Value:

    NULL or pointer to LazyCommitControl LDAP control.

--*/
{
    DWORD   now;
    DWORD   interval = SrvCfg_dwDsLazyUpdateInterval;

    if ( !interval )
    {
        return NULL;
    }

    now = DNS_TIME();

    if ( now - g_dwLastLazyCommitTime > interval )
    {
        return NULL;
    }

    g_dwLastLazyCommitTime = now;

    return &LazyCommitControl;
}   //  lazyCommitControlPtr


DNS_STATUS
buildDsNodeNameFromNode(
    OUT     PWSTR           pwszNodeDN,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Create the DS object name.

Arguments:

    pszNodeDN -- buffer to receive node's DS name -- the buffer must be
        at least MAX_DN_PATH characters + 1 character for NULL

    pZone -- zone node is in

    pNode -- node to write name for

Return Value:

    Ptr to copy of record.
    NULL on failure.

--*/
{
    DNS_STATUS          status;
    BYTE                buffer[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];
    WCHAR               wbuffer[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];
    register PCHAR      pch = buffer;

    ASSERT( pZone->pZoneRoot );

    //  if temp node, use real node to build name
    //      - tnode is points to real tree parent, but right AT zone root
    //      this is not sufficient as will not stop building name at zone root


    if ( IS_TNODE( pNode ) )
    {
        pNode = TNODE_MATCHING_REAL_NODE( pNode );
    }

    //
    //  build relative node name to zone root
    //      dc=<relative DNS name to zone root>,<zoneDN>
    //

    if ( pNode == pZone->pZoneRoot || pNode == pZone->pLoadZoneRoot )
    {
        if ( wcslen( pZone->pwszZoneDN ) > MAX_DN_PATH - 6 )
        {
            return DNS_ERROR_INVALID_NAME;
        }
        status = StringCchPrintfW(
                        pwszNodeDN,
                        MAX_DN_PATH,
                        L"DC=@,%s",
                        pZone->pwszZoneDN );
        if ( FAILED( status ) )
        {
            return status;
        }
    }
    else
    {
        pch = Name_PlaceNodeNameInBuffer(
                pch,
                pch + DNS_MAX_NAME_BUFFER_LENGTH,
                pNode,
                pZone->pZoneRoot );     //  stop at zone root, i.e. write relative name
        if ( !pch )
        {
            DNS_DEBUG( ANY, (
                "ERROR couldn't build DS name for node %s (zone %S)!!!\n",
                pNode->szLabel,
                pZone->pwsZoneName ));
            ASSERT( FALSE );
            return DNS_ERROR_INVALID_NAME;
        }
        else
        {
            UTF8_TO_WC ( buffer, wbuffer, DNS_MAX_NAME_BUFFER_LENGTH );
            status = StringCchPrintfW(
                        pwszNodeDN,
                        MAX_DN_PATH,
                        L"DC=%s,%s",
                        wbuffer,
                        pZone->pwszZoneDN );
            if ( FAILED( status ) )
            {
                return status;
            }
        }
    }

    DNS_DEBUG( DS, (
        "Node DS name = %S\n",
        pwszNodeDN ) );

    return ERROR_SUCCESS;
}



//
//  LDAP Mod building routines
//
//  Single value Mods can sit on stack.
//  Multi value mods are allocated on the heap.  They are one allocation
//  (sized based on count of values) and require single free.
//
//  DEVNOTE: At some point we may need a multi-DWORD mod.
//

VOID
buildStringMod(
    OUT     PDNS_LDAP_SINGLE_MOD    pMod,
    IN      DWORD                   dwOperation,
    IN      PWSTR                   pszProperty,
    IN      PWSTR                   pszStringVal
    )
{
    INIT_SINGLE_MOD( pMod );

    pMod->Mod.mod_op = dwOperation;
    pMod->Mod.mod_type = pszProperty;
    pMod->Mod.mod_values[0] =  pszStringVal;
}



VOID
buildDwordMod(
    IN OUT  PDNS_LDAP_SINGLE_MOD    pMod,
    IN      DWORD                   dwOperation,
    IN      PWSTR                   pszProperty,
    IN      PDWORD                  pDword
    )
{
    INIT_SINGLE_MOD_LEN( pMod );

    pMod->Mod.mod_op = dwOperation;
    pMod->Mod.mod_type = pszProperty;
    pMod->Berval.bv_len = sizeof(DWORD);
    pMod->Berval.bv_val = (PCHAR)pDword;
}



//
//  Record and property LDAP Mod building
//

#if DBG
VOID
Dbg_DsBervalArray(
    IN      LPSTR           pszHeader,
    IN      PLDAP_BERVAL *  BervalPtrArray,
    IN      DWORD           AttributeId
    )
/*++

Routine Description:

    Debug print berval data.

Arguments:

Return Value:

    None.

--*/
{
    DWORD           i = 0;
    DWORD           length;
    PCHAR           pch;
    PLDAP_BERVAL    pberval;

    DnsDbg_Lock();

    DnsPrintf(
        "%s\n",
        pszHeader ? pszHeader : "Berval Array:" );

    //
    //  set berval -- ptr to record data and length
    //

    i = 0;

    while ( BervalPtrArray && ( pberval = BervalPtrArray[ i ] ) != NULL )
    {
        length = pberval->bv_len;
        pch = pberval->bv_val;

        if ( AttributeId == I_DSATTR_DNSRECORD )
        {
            PDS_RECORD  precord = (PDS_RECORD)pch;

            if ( length != precord->wDataLength + SIZEOF_DS_RECORD_HEADER )
            {
                DnsPrintf( "ERROR: corrupted record, invalid length!!!\n" );
            }
            DnsPrintf(
                "Record[%d]: length %d, ptr %p\n",
                i,
                length,
                precord );
            Dbg_DsRecord(
                NULL,
                precord );
        }
        else if ( AttributeId == I_DSATTR_DNSPROPERTY )
        {
            PDS_PROPERTY pprop = (PDS_PROPERTY)pch;

            DnsPrintf(
                "Property[%d]: length %d, ptr %p, id %d\n",
                i,
                pprop->DataLength,
                pprop,
                pprop->Id );
        }
        else
        {
            DnsPrintf(
                "Berval[%d]: length %d, ptr %p\n",
                i,
                length,
                pch );
        }
        i++;
    }

    DnsDbg_Unlock();
}



VOID
Dbg_DsModBuffer(
    IN      LPSTR           pszHeader,
    IN      PWSTR           pwszDN,
    IN      PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Debug print berval data.

Arguments:

Return Value:

    None.

--*/
{
    DnsDbg_Lock();

    DnsPrintf(
        "%s\n"
        "Node DN = %S\n",
        ( pszHeader ? pszHeader : "DS Mod:" ),
        pwszDN );

    if ( ! pModBuffer )
    {
        DnsPrintf( "NULL DS Mod ptr\n" );
        goto Done;
    }

    //
    //  print mod info
    //

    DnsPrintf(
        "DS Mod:\n"
        "    Attribute    %d\n"
        "    Count        %d\n"
        "    MaxCount     %d\n"
        "    Error        %d\n"
        "    WriteType    %d\n"
        "    SerialNo     %d\n"
        "    ---------------\n"
        "    pCurrent     %p\n"
        "    pBufEnd      %p\n"
        "    pAdditional  %p\n"
        "    pBerval      %p\n"
        "    pData        %p\n"
        "    ---------------\n"
        "    Mod Op       %p\n"
        "    Mod Type     %S\n"
        "    Mod Value    %p\n",
        pModBuffer->Attribute,
        pModBuffer->Count,
        pModBuffer->MaxCount,
        pModBuffer->Error,
        pModBuffer->WriteType,
        pModBuffer->SerialNo,
        pModBuffer->pCurrent,
        pModBuffer->pBufferEnd,
        pModBuffer->pAdditionalBuffer,
        pModBuffer->pBerval,
        pModBuffer->pData,
        pModBuffer->LdapMod.mod_op,
        pModBuffer->LdapMod.mod_type,
        pModBuffer->LdapMod.mod_bvalues );

    //
    //  print berval(s) for mod
    //

    Dbg_DsBervalArray(
        NULL,
        pModBuffer->LdapMod.mod_bvalues,
        pModBuffer->Attribute );

Done:

    DnsDbg_Unlock();
}
#endif



PWSTR
Ds_GetExtendedLdapErrString(
    IN      PLDAP   pLdapSession
    )
/*++

Routine Description:

    This function returns the extended error string for the given ldap
    session. If there is no extended error, this function returns a pointer
    to a static empty string. The caller must pass the returned pointer
    to Ds_FreeExtendedLdapErrString when finished.

Arguments:

    pLdapSession -- LDAP session or NULL for global server session

Return Value:

    pointer to extended error string - guaranteed to never be NULL

--*/
{
    DBG_FN( "Ds_GetExtendedLdapErrString" )

    DNS_STATUS      status;
    PWSTR           pwszerrString = NULL;
    PWSTR           pwszldapErrString = NULL;

    if ( !pLdapSession )
    {
        pLdapSession = pServerLdap;
    }

    ldap_get_option(
        pLdapSession,
        LDAP_OPT_SERVER_ERROR,
        &pwszldapErrString );

    if ( !pwszldapErrString )
    {
        pwszerrString = g_pwszEmptyString;
        DNS_DEBUG( DS, ( "%s: NULL extended err string\n", fn ));
    }
    else if ( !*pwszldapErrString )
    {
        pwszerrString = g_pwszEmptyString;
        DNS_DEBUG( DS, ( "%s: empty extended err string\n", fn ));
    }
    else
    {
        //
        //  The DS puts a newline at the end of the error string. This
        //  messes up the event log text, so let's make a copy of the string
        //  and zero out the newline.
        //

        INT     len = wcslen( pwszldapErrString );
        PWSTR   pwsz = ALLOC_TAGHEAP(
                            ( len + 2 ) * sizeof( WCHAR ),
                            MEMTAG_DS_OTHER );

        if ( pwsz )
        {
            status = StringCchCopyW( pwsz, len + 1, pwszldapErrString );
            if ( FAILED( status ) )
            {
                ASSERT( status == ERROR_SUCCESS );
                FREE_HEAP( pwsz );
                pwsz = NULL;
                pwszerrString = g_pwszEmptyString;
            }
            else
            {
                if ( pwsz[ len - 1 ] == L'\n' )
                {
                    pwsz[ len - 1 ] = L'\0';
                }
                pwszerrString = pwsz;
            }
        }
        else
        {
            pwszerrString = g_pwszEmptyString;
        }
        DNS_DEBUG( DS, (
            "%s: extended error string is:\n  %S\n", fn,
            pwszerrString ));
    }

    ldap_memfree( pwszldapErrString );
    return pwszerrString;
}   //  Ds_GetExtendedLdapErrString



VOID
Ds_FreeExtendedLdapErrString(
    IN      PWSTR   pwszErrString
    )
/*++

Routine Description:

    Frees an extended error string returned by Ds_GetExtendedLdapErrString.
    The string may be the static empty string, in which case it must not
    be freed.

Arguments:

    pwszErrString -- error string to free

Return Value:

    None.

--*/
{
    if ( pwszErrString && pwszErrString != g_pwszEmptyString )
    {
        FREE_HEAP( pwszErrString );
    }
}   //  Ds_FreeExtendedLdapErrString



DNS_STATUS
Ds_AllocateMoreSpaceInModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Allocate more space in mod buffer.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    register PCHAR   pch;

    //
    //  better not have already allocated!
    //

    if ( pModBuffer->pAdditionalBuffer )
    {
        ASSERT( FALSE );
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  allocate space in buffer
    //

    pch = ALLOC_TAGHEAP( MOD_BUFFER_REALLOC_LENGTH, MEMTAG_DS_MOD );
    IF_NOMEM( !pch )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    pModBuffer->pAdditionalBuffer = pch;
    pModBuffer->pCurrent = pch;
    pModBuffer->pBufferEnd = pch + MOD_BUFFER_REALLOC_LENGTH;

    return ERROR_SUCCESS;
}



VOID
Ds_InitModBufferCount(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwMaxCount
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  determine starting location in buffer
    //      start after berval array, note that reserve one entry
    //      for terminating NULL


    pModBuffer->MaxCount = dwMaxCount;

    pModBuffer->pCurrent = (PBYTE) & pModBuffer->BervalPtrArray[dwMaxCount+1];

    //  ptr array should NEVER overflow initial block
    //      if it does
    //          - use front of allocation for berval array
    //          - NULL old array for debug print

    if ( pModBuffer->pCurrent > pModBuffer->pBufferEnd )
    {
        DNS_DEBUG( ANY, (
            "Reallocating DS buffer for berval array!!!\n" ));

        //ASSERT( FALSE );        // should never be this big

        Ds_AllocateMoreSpaceInModBuffer( pModBuffer );

        pModBuffer->BervalPtrArray[0] = NULL;
        pModBuffer->LdapMod.mod_bvalues = (PLDAP_BERVAL *) pModBuffer->pCurrent;
        pModBuffer->pCurrent += sizeof(PVOID) * (dwMaxCount+1);
    }
}



VOID
Ds_InitModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwBufferLength,
    IN      DWORD           dwAttributeId,
    IN      DWORD           dwMaxCount,         OPTIONAL
    IN      DWORD           dwSerialNo
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwBufferLength -- length of buffer (bytes)

    dwAttributeId -- ID of attribute to write

    dwMaxCount -- record max count

    dwSerialNo -- zone serial number to stamp in records

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  zero fields
    //      - need to do header fields
    //      - also need LdapMod.mod_bvalues == NULL to have check for
    //          realloc

    RtlZeroMemory(
        pModBuffer,
        (PCHAR) &pModBuffer->LdapMod - (PCHAR)pModBuffer );

    //  set mod to point at berval array

    pModBuffer->LdapMod.mod_bvalues = pModBuffer->BervalPtrArray;

#if DBG
    //  clear type for debug print
    pModBuffer->LdapMod.mod_op = 0;
    pModBuffer->LdapMod.mod_type = NULL;
#endif

    //  since not NULL terminating array at end, must do here

    pModBuffer->BervalPtrArray[0] = NULL;

    pModBuffer->pBufferEnd = (PBYTE) pModBuffer + dwBufferLength;

    pModBuffer->Attribute = dwAttributeId;

    pModBuffer->SerialNo = dwSerialNo;

    if ( dwMaxCount )
    {
        Ds_InitModBufferCount( pModBuffer, dwMaxCount );
    }
}



PCHAR
Ds_ReserveBervalInModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwMaxCount -- max count of items in mod

Return Value:

    Ptr to location to write berval data.

--*/
{
    register PCHAR  pch;

    //  check that space adequate, if not realloc

    pch = pModBuffer->pCurrent;

    if ( pch + dwLength + sizeof(LDAP_BERVAL) >= pModBuffer->pBufferEnd )
    {
        DNS_STATUS status;
        status = Ds_AllocateMoreSpaceInModBuffer( pModBuffer );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return NULL;
        }
        pch = pModBuffer->pCurrent;
    }

    //  reserves berval space and sets pointer

    pModBuffer->pBerval = (PLDAP_BERVAL) pch;
    pch += sizeof(LDAP_BERVAL);

    //  reset current to point at begining of record\property

    pModBuffer->pCurrent = pch;
    pModBuffer->pData = pch;

    return pch;
}



DNS_STATUS
Ds_CommitBervalToMod(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PLDAP_BERVAL    pberval = pModBuffer->pBerval;
    DWORD           count;
    PLDAP_BERVAL *  ppbervalPtrArray;

    //
    //  fill out berval
    //

    pberval->bv_len = dwLength;
    pberval->bv_val = pModBuffer->pData;

    //
    //  reset current pointer and DWORD align
    //

    pModBuffer->pCurrent += dwLength;
    ASSERT( pModBuffer->pCurrent < pModBuffer->pBufferEnd );

    pModBuffer->pCurrent = (PCHAR) DNS_NEXT_ALIGNED_PTR( pModBuffer->pCurrent );

    //
    //  fill berval into array
    //  should never exceed max count
    //

    count = pModBuffer->Count;
    if ( count >= pModBuffer->MaxCount )
    {
        DNS_DEBUG( ANY, (
            "Failed to allocate proper DS count!!!\n" ));
        ASSERT( FALSE );
        return ERROR_MORE_DATA;
    }

    ppbervalPtrArray = pModBuffer->LdapMod.mod_bvalues;
    ppbervalPtrArray[ count ] = pberval;
    pModBuffer->Count = ++count;

    //  keep berval array NULL terminated
    //      - need for debug print
    //      - if don't do, then need to NULL terminate at end

    ppbervalPtrArray[ count ] = NULL;

    return ERROR_SUCCESS;
}



VOID
Ds_CleanupModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwBufferLength -- length of buffer (bytes)

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( pModBuffer->pAdditionalBuffer )
    {
        FREE_TAGHEAP(
            pModBuffer->pAdditionalBuffer,
            MOD_BUFFER_REALLOC_LENGTH,
            MEMTAG_DS_MOD );

        //  protect against double free
        //      (should tag structure and ASSERT, then could drop)

        pModBuffer->pAdditionalBuffer = NULL;
    }
}



PLDAPMod
Ds_SetupModForExecution(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PWSTR           pwsAttribute,
    IN      DWORD           dwOperation
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer

    dwOperation -- operation

    pszAttribute -- type attribute string

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  set operation

    pModBuffer->LdapMod.mod_op = dwOperation;

    //  get attribute name for mod type
    //      (dnsRecord, dnsProperty, etc)

    pModBuffer->LdapMod.mod_type = pwsAttribute;

    //  mod berval array is already set in init function
    //      (or possibly overwritten on berval array realloc)

    //  NULL terminate berval ptr array
    //  we keep berval array NULL terminated as we go
    //      - would need to reference actual array
    //

    pModBuffer->LdapMod.mod_bvalues[ pModBuffer->Count ] = NULL;

    //  record write tracking

    if ( pModBuffer->Attribute == I_DSATTR_DNSRECORD )
    {
        register DWORD   writeType = pModBuffer->WriteType;

        if ( writeType > STATS_TYPE_MAX )
        {
            writeType = STATS_TYPE_UNKNOWN;
        }
        STAT_INC( DsStats.DsWriteType[writeType] );
    }

    IF_DEBUG( DS )
    {
        Dbg_DsModBuffer(
            "DS mod ready for use",
            NULL,
            pModBuffer );
    }

    return( &pModBuffer->LdapMod );
}



//
//  Write records to DS routines.
//  DS storage is in same format as in memory copy.
//

VOID
writeDsRecordToBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PDB_RECORD      pRR,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add resource record to flat (RPC or DS) buffer.

Arguments:

    pModBuffer - buffer for DS records

    pZone - ptr to zone

    pRR - dbase RR to write

    dwFlag - flag (UNUSED)

Return Value:

    None

--*/
{
    PDS_RECORD      pdsRR;
    WORD            dataLength;

    DNS_DEBUG( DS2, (
        "writeDsRecordToBuffer()\n"
        "    Writing RR at %p to buffer at %p, with buffer end at %p\n"
        "    Flags = %p\n",
        pRR,
        pModBuffer->pCurrent,
        pModBuffer->pBufferEnd,
        dwFlag ));

    ASSERT( pRR != NULL );

    //  reserve space for berval

    dataLength = pRR->wDataLength;

    pdsRR = (PDS_RECORD) Ds_ReserveBervalInModBuffer(
                            pModBuffer,
                            dataLength + SIZEOF_DNS_RPC_RECORD_HEADER
                            );
    if ( !pdsRR )
    {
        DNS_DEBUG( ANY, (
            "writeDsRecordToBuffer: NULL RR POINTER!\n" ));
        return;
    }

    //
    //  fill RR structure
    //      - set ptr
    //      - set type and class
    //      - set datalength once we're finished
    //

    pdsRR->wDataLength  = dataLength;
    pdsRR->wType        = pRR->wType;
    pdsRR->Version      = DS_NT5_RECORD_VERSION;
    pdsRR->Rank         = RR_RANK(pRR);
    pdsRR->wFlags       = 0;
    pdsRR->dwSerial     = pModBuffer->SerialNo;
    pdsRR->dwTtlSeconds = pRR->dwTtlSeconds;
    pdsRR->dwReserved   = 0;
    pdsRR->dwTimeStamp  = pRR->dwTimeStamp;

    //
    //  write RR data
    //

    RtlCopyMemory(
        & pdsRR->Data,
        & pRR->Data,
        dataLength );

    //
    //  write berval for property
    //

    Ds_CommitBervalToMod( pModBuffer, dataLength+SIZEOF_DNS_RPC_RECORD_HEADER );

    IF_DEBUG( DS2 )
    {
        Dbg_DsRecord(
            "RPC record written to buffer",
            pdsRR );
    }
}



VOID
writeTombstoneRecord(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write tombstone record.

Arguments:

    pModBuffer - buffer for DS records

    pZone - ptr to zone

Return Value:

    Serial no of tombstone write.

--*/
{
    PDS_RECORD      pdsRR;

    //
    //  setup tombstone record
    //      - current system time as FILETIME is data
    //

    DNS_DEBUG( DS, ( "writeTombstoneRecord()\n" ));

    //  reserve space for berval

    pdsRR = (PDS_RECORD) Ds_ReserveBervalInModBuffer(
                            pModBuffer,
                            sizeof(FILETIME) + SIZEOF_DNS_RPC_RECORD_HEADER
                            );
    if ( !pdsRR )
    {
        DNS_DEBUG( ANY, (
            "writeTombstoneRecord: NULL RR POINTER!\n" ));
        return;
    }

    //
    //  fill DS record structure
    //

    pdsRR->wDataLength  = sizeof(FILETIME);
    pdsRR->wType        = DNSDS_TOMBSTONE_TYPE;
    pdsRR->Version      = DS_NT5_RECORD_VERSION;
    pdsRR->Rank         = 0;
    pdsRR->wFlags       = 0;
    pdsRR->dwSerial     = pModBuffer->SerialNo;
    pdsRR->dwTtlSeconds = 0;
    pdsRR->dwReserved   = 0;
    pdsRR->dwTimeStamp  = 0;

    //
    //  write data
    //      - data if filetime

    GetSystemTimeAsFileTime( (PFILETIME) &(pdsRR->Data) );

    //
    //  write berval for property
    //

    Ds_CommitBervalToMod( pModBuffer, sizeof(FILETIME)+SIZEOF_DNS_RPC_RECORD_HEADER );

    DNS_DEBUG( DS, ( "Leave: writeTombstoneRecord()\n" ));
}



DNS_STATUS
buildDsRecordSet(
    IN OUT  PDS_MOD_BUFFER  pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Build RR set.

Arguments:

    pZone -- zone to write into DS

    wType -- type to build, use type ALL for standard updates

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure (just kidding).

--*/
{
    PDB_RECORD      prr;
    WORD            type;
    WORD            writeType = 0;
    PCHAR           precordStart;
    DWORD           count;


    DNS_DEBUG( DS, (
        "buildDsRecordSet() for node with label %s\n",
        pNode->szLabel ));

#if 0
    //
    //  saving this as example of how we'd handle DS versioning
    //  note, NT5 beta2 upgrade itself is dead
    //

    if ( (pZone->ucDsRecordVersion == DS_NT5_BETA2_RECORD_VERSION && !SrvCfg_fTestX )
            ||
            SrvCfg_fTestX == 2 )
    {
        return  buildOldVersionRecordSet(
                    pBuffer,
                    pRecordArray,
                    pdwCount,
                    pZone,
                    pNode,
                    wType );
    }
#endif

    //
    //  count records, and init buffer

    LOCK_READ_RR_LIST(pNode);

    count = RR_ListCountRecords(
                pNode,
                wType,
                TRUE );         //  already locked
    if ( count == 0 )
    {
        goto Cleanup;
    }

    Ds_InitModBufferCount( pBuffer, count );

    //
    //  write records in each set to buffer
    //

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  skip cached record and empty auth records

        if ( IS_CACHE_RR( prr ) || IS_EMPTY_AUTH_RR( prr ) )
        {
            ASSERT( !IS_EMPTY_AUTH_RR( prr ) );
            continue;
        }

        type = prr->wType;

        if ( wType == DNS_TYPE_ALL || wType == type )
        {
            //  save DS write types
            //      - if multiple types, use mixed

            if ( writeType && type != writeType )
            {
                writeType = STATS_TYPE_MIXED;
            }
            else
            {
                writeType = type;
            }

            //  write the record

            writeDsRecordToBuffer(
                pBuffer,
                prr,
                pZone,
                0 );
            continue;
        }

        //  done with desired type?

        else if ( type > wType )
        {
            break;
        }

        //  continue if have not reached desired type
    }

    pBuffer->WriteType = writeType;

Cleanup:

    UNLOCK_READ_RR_LIST(pNode);

    DNS_DEBUG( DS, (
        "Wrote %d DS records of type %d at node label %s to buffer\n",
        count,
        wType,
        pNode->szLabel ));

    return ERROR_SUCCESS;
}



//
//  Record writing
//

VOID
writeTimeStop(
    IN      DWORD           dwStartTime
    )
{
    DWORD   timeDiff;

    timeDiff = GetCurrentTime() - dwStartTime;


    if ( timeDiff < 10 )
    {
        STAT_INC( DsStats.LdapWriteBucket0 );
    }
    else if ( timeDiff < 100 )
    {
        STAT_INC( DsStats.LdapWriteBucket1 );
    }
    else if ( timeDiff < 1000 )
    {
        STAT_INC( DsStats.LdapWriteBucket2 );
    }
    else if ( timeDiff < 10000 )
    {
        STAT_INC( DsStats.LdapWriteBucket3 );
    }
    else if ( timeDiff < 100000 )
    {
        STAT_INC( DsStats.LdapWriteBucket4 );
    }
    else
    {
        STAT_INC( DsStats.LdapWriteBucket5 );
    }

    //  save max

    if ( timeDiff > DsStats.LdapWriteMax )
    {
        DsStats.LdapWriteMax = timeDiff;
    }

    //  calc average

    STAT_INC( DsStats.LdapTimedWrites );
    STAT_ADD( DsStats.LdapWriteTimeTotal, timeDiff );

    DsStats.LdapWriteAverage = DsStats.LdapWriteTimeTotal /
                                        DsStats.LdapTimedWrites;
}



DNS_STATUS
writeRecordsToDsNode(
    IN      PLDAP           pLdapHandle,
    IN      PWSTR           pwsDN,
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwOperation,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Update record list at domain name.

Arguments:

    pLdapHandle -- LdapHandle to object being modified

    pwsDN       -- node DN to write

    pModBuffer  -- buffer with LDAP mod and data to write;
        this is cleaned up by this function

    pZone       -- zone being updated

    dwOperation -- operation
        DNSDS_REPLACE       to replace all existing records
        DNSDS_ADD           to add to existing set of records
        DNSDS_TOMBSTONE     to tombstone records

        DNSDS_TOMBSTONE | DNSDS_REPLACE
                            to for serial number write where we do force
                            tombstone write

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPMod        pmodRecord = NULL;
    PLDAPMod        pmodTombstone = NULL;
    PLDAPMod        pmodArray[4];
    PLDAPControl    controlArray[] =
    {
        lazyCommitControlPtr(),
        NULL
    };
    PLDAPMessage    presult = NULL;
    ULONG           msgId = 0;
    DWORD           writeStartTime;
    BOOL            bmodifyAdd = FALSE;
    PLDAP           pldap = pLdapHandle ? pLdapHandle : pServerLdap;
    INT             retry = 0;
    BOOL            fadd;
    DWORD           count;
    LDAPMod         tombstoneMod;
    PWSTR           tomestoneValues[] = { NULL, NULL };

    IF_DEBUG( DS )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Enter writeRecordsToDsNode()\n"
            "    pZone->pszZoneDN     = %S\n"
            "    node DN              = %S\n"
            "    op                   = %d\n",
            pZone->pwszZoneDN,
            pwsDN,
            dwOperation ));
        DnsDebugUnlock();
    }

    //  shouldn't be writing zero records

    ASSERT( pModBuffer->Count != 0 );

    //
    //  build DS record mod
    //

    pmodRecord = Ds_SetupModForExecution(
                    pModBuffer,
                    DSATTR_DNSRECORD,
                    LDAP_MOD_REPLACE | LDAP_MOD_BVALUES );
    if ( !pmodRecord )
    {
        status = GetLastError();
        goto Failed;
    }

    //
    //  setup up tombstoneMod
    //      anything BUT tombstone operation gets FALSE
    //

    tombstoneMod.mod_op = LDAP_MOD_REPLACE;
    tombstoneMod.mod_type = LDAP_TEXT( "dNSTombstoned" );
    tomestoneValues[ 0 ] = (dwOperation & DNSDS_TOMBSTONE) ?
                                LDAP_TEXT( "TRUE" ) :
                                LDAP_TEXT( "FALSE" );
    tombstoneMod.mod_values = tomestoneValues;
    pmodTombstone = &tombstoneMod;


    //
    //  root hints disappearing check
    //
    //  we no-op the RootHints @ tombstoning, to REALLY clamp down on the
    //  root-hints disappearing problem;   since the @ node will be rewritten
    //  with the new root-hints this is cool
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( _wcsnicmp( pwsDN, L"dc=@", 4 ) == 0 )
        {
            DNS_DEBUG( DS, (
                "DS-write of root-hints @ check\n"
                "    count = %d\n"
                "    type  = %d\n",
                pModBuffer->Count,
                pModBuffer->WriteType ));

            if ( (dwOperation & DNSDS_TOMBSTONE) ||
                 pModBuffer->Count == 0     ||
                 pModBuffer->WriteType != DNS_TYPE_NS )
            {
                DNS_DEBUG( DS, (
                    "Ignoring DS-write of root-hints @\n" ));
                status = ERROR_SUCCESS;
                goto Failed;
            }
        }
        ELSE
        {
            ASSERT( pModBuffer->Count != 0 );
            ASSERT( pModBuffer->WriteType == DNS_TYPE_A ||
                    pModBuffer->WriteType == DNS_TYPE_TOMBSTONE );
        }
    }


    //
    //  if doing add -- start with ldap_add()
    //  otherwise ldap_modify
    //      - includes both update write and tombstone
    //      - update will fail over on "object doesn't exist" error
    //

    fadd = (dwOperation == DNSDS_ADD);

    //
    //  while loop for easy fail over between add\modify operations
    //

    while ( 1 )
    {
        //
        //  keep a retry count so impossible to ping-pong forever
        //      allow a couple passes of getting messed up by replication
        //      then assume stuff is broken

        if ( retry++ > 3 )
        {
            DNS_DEBUG( ANY, (
                "ERROR: Failing DS-write because of retry!\n" ));
            ASSERT( status != ERROR_SUCCESS );
            break;
        }

        if ( fadd )
        {
            //
            //  add ldap mod is
            //      - record data
            //      - and ADD mod
            //
            //  note, don't bother to write tombstone attribute, when
            //  doing non-tombstone add 
            //  currently only tombstone adds are explicit serial number
            //  pushes
            //

            pmodArray[0] = pmodRecord;
            pmodArray[1] = gpAddNodeLdapMod;
            pmodArray[2] = NULL;
            if ( dwOperation & DNSDS_TOMBSTONE )
            {
                pmodArray[2] = pmodTombstone;
                pmodArray[3] = NULL;
            }

            pZone->fInDsWrite = TRUE;
            writeStartTime = GetCurrentTime();

            status = ldap_add_ext(
                            pldap,
                            pwsDN,
                            pmodArray,
                            controlArray,       // include lazy commit control
                            NULL,                // no client controls
                            &msgId
                            );

            pZone->fInDsWrite = FALSE;
            writeTimeStop( writeStartTime );

            //  local failure -- will retry

            if ( (ULONG)-1 == status )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DS, (
                    "Error <%lu %p>: cannot ldap_add_ext( %S )\n"
                    "    Will retry the operation\n",
                    status, status,
                    pwsDN ));

                status = Ds_ErrorHandler( status, pwsDN, pldap, 0 );
                continue;
            }

            //
            //  commit the write
            //      - if object already there, we fall over to ldap_modify()
            //

            status = Ds_CommitAsyncRequest(
                        pldap,
                        LDAP_RES_ADD,
                        msgId,
                        NULL );

            if ( status == LDAP_ALREADY_EXISTS )
            {
                //  object already exists
                //  turn off fadd to fall over to ldap_modify()

                DNS_DEBUG( DS, (
                    "Warning: Object %S failed ldap_add_ext() with ALREADY_EXISTS\n"
                    "    Switching to ldap_modify()\n",
                    pwsDN ));

                fadd = FALSE;
                continue;
            }
            else    // success or another error
            {
                DNS_DEBUG( DS, (
                    "%lu = ldap_add_ext( %S )\n",
                    status,
                    pwsDN ));
                break;
            }
        }

        //
        //  modify
        //

        else
        {
            //   modify mod

            pmodArray[0] = pmodRecord;
            pmodArray[1] = pmodTombstone;
            pmodArray[2] = NULL;

            pZone->fInDsWrite = TRUE;
            writeStartTime = GetCurrentTime();

            status = ldap_modify_ext(
                            pldap,
                            pwsDN,
                            pmodArray,
                            controlArray,       // include lazy commit control
                            NULL,               // no client controls
                            &msgId );

            pZone->fInDsWrite = FALSE;
            writeTimeStop( writeStartTime );

            //  local client side failure

            if ( (ULONG)-1 == status )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DS, (
                    "Error <%lu %p>: ldap_modify_ext( %S )\n"
                    "    Will retry\n",
                    status, status,
                    pwsDN ));

                status = Ds_ErrorHandler( status, pwsDN, pldap, 0 );
                continue;
            }

            //
            //  Commit async request. See if the server has
            //  accepted the request & test error code
            //  if the object's not there, we'll try the add.
            //

            status = Ds_CommitAsyncRequest(
                            pldap,
                            LDAP_RES_MODIFY,
                            msgId,
                            NULL );

            if ( status == LDAP_NO_SUCH_ATTRIBUTE )
            {
                DNS_DEBUG( DS, (
                    "ERROR: Modify error NO_SUCH_ATTRIBUTE\n"
                    "    Schema probably missing dnsTombstoned\n" ));

                pmodTombstone = NULL;
                continue;
            }
            else if ( status == LDAP_NO_SUCH_OBJECT )
            {
                //  no object
                //      - if plain vanilla tombstoning, we're done no object is fine
                //      serial-tombstone will fail this case
                //      - otherwise fall over to add

                if ( dwOperation == DNSDS_TOMBSTONE )
                {
                    //  have a stat here?
                    DNS_DEBUG( DS, (
                        "Tombstone write %s hit NO_SUCH_OBJECT - skipping\n",
                        pwsDN ));

                    //STAT_INC( DsStats.TombstoneWriteNoOp );
                    status = ERROR_SUCCESS;
                    //break;
                    goto Failed;        // skips DS write logging and stats
                }
                else
                {
                    DNS_DEBUG( DS, (
                        "Warning: Object %S was deleted from the DS during this update\n" \
                        "    Recovery attempt via ldap_add\n",
                        pwsDN ));
                    fadd = TRUE;            // fall over to add
                    bmodifyAdd = TRUE;
                    continue;
                }
            }
            else    // success or any error
            {
                //  warn in case we're doing an ADD (like zone write)
                //      and we end up whacking into a node
                //
                //  DEVNOTE: What if we're tombstoning a record and valid data
                //      has replicated in?
                //

                // ASSERT ( dwOperation == DNSDS_REPLACE );
                DNS_DEBUG( DS, (
                    "%lu = ldap_modify_ext( %S )\n",
                    status,
                    pwsDN ));
                break;
            }
        }
    }


    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu (%p)>: Cannot write node %S\n",
            status, status,
            pwsDN ));
        status = Ds_ErrorHandler( status, pwsDN, pldap, 0 );
        goto Failed;
    }

    count = pModBuffer->Count;

    IF_DNSLOG( DSWRITE )
    {
        Log_DsWrite(
            pwsDN,
            (dwOperation & DNSDS_ADD) ? TRUE : FALSE,
            count,
            (PDS_RECORD) pModBuffer->BervalPtrArray[ count-1 ]->bv_val );
    }

    //
    //  Write stats
    //

    if ( fadd )
    {
        STAT_INC( DsStats.DsNodesAdded );
        STAT_ADD( DsStats.DsRecordsAdded, count );
    }
    else
    {
        STAT_INC( DsStats.DsNodesModified );
        STAT_ADD( DsStats.DsRecordsReplaced, count );
    }

Failed:

    if ( status != ERROR_SUCCESS )
    {
        if ( bmodifyAdd )
        {
            //  Modify failed, reverted to add attempt

            STAT_INC( DsStats.FailedLdapModify );
        }
        else if ( dwOperation == DNSDS_REPLACE )
        {
            // Modify failed. Didn't revert.

            STAT_INC( DsStats.FailedLdapModify );
        }
        else
        {
            // Add failed. Didn't revert.

            STAT_INC( DsStats.FailedLdapAdd );
        }
        DNS_DEBUG( ANY, (
            "ERROR: Leaving writeRecordsToDsNode( %S )\n"
            "    status = 0x%X (%d)\n",
            pwsDN,
            status, status ));
    }

    //
    //  successful write, save highest serial written
    //      we won't force serial writes at a given serial
    //      if have already written it
    //

    else
    {
        if ( pZone->dwHighDsSerialNo < pModBuffer->SerialNo )
        {
            pZone->dwHighDsSerialNo = pModBuffer->SerialNo;
            DNS_DEBUG( DS, (
                "Updated highest DS serial to %d for zone %S\n",
                pModBuffer->SerialNo,
                pZone->pwsZoneName ));
        }
        DNS_DEBUG( DS, (
            "Leaving writeRecordsToDsNode( %S )\n"
            "    status = 0x%X (%d)\n",
            pwsDN,
            status, status ));
    }

    Ds_CleanupModBuffer( pModBuffer );

    return status;
}



DNS_STATUS
deleteNodeFromDs(
    IN      PLDAP           pLdapHandle,
    IN      PZONE_INFO      pZone,
    IN      PWSTR           pwsDN,
    IN      DWORD           dwSerialNo      OPTIONAL
    )
/*++

Routine Description:

    Delete domain name from DS.

    Note, this function actually tombstones the node.  Final delete
    is done only when tombstone detected to what timed out during a
    DS node read.  See checkTombstoneForDelete().

Arguments:

    pZone       -- zone being updated

    pNode       -- database node being deleted

    pwsDN       -- DN of the deleted node

    dwSerialNo  -- overwrite zone's current serial with this value

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    BYTE            buffer[ RECORD_SMALL_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;

    DNS_DEBUG( DS, (
        "deleteNodeFromDs()\n"
        "    pZone->pszZoneDN     = %S\n"
        "    DN                   = %S\n",
        pZone->pwszZoneDN,
        pwsDN ));

    //
    //  init mod buffer
    //      - use if passed in
    //      - otherwise prepare small buffer and write with current zone serial no
    //

    if ( dwSerialNo == 0 )
    {
        dwSerialNo = pZone->dwSerialNo;
    }

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_SMALL_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        1,      // one record only
        dwSerialNo );

    //  write DS tombstone record to buffer

    writeTombstoneRecord( pmodBuffer, pZone );

    STAT_INC( DsStats.DsNodesTombstoned );

    //  write to DS

    return writeRecordsToDsNode(
                pLdapHandle,
                pwsDN,
                pmodBuffer,
                DNSDS_TOMBSTONE,
                pZone );
}



VOID
Ds_CheckForAndForceSerialWrite(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwCause,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Check for and if necessary write zone serial to DS.

Arguments:

    pZone -- zone to write serial

    dwCause -- cause of write
        ZONE_SERIAL_SYNC_SHUTDOWN
        ZONE_SERIAL_SYNC_XFR
        ZONE_SERIAL_SYNC_VIEW
        ZONE_SERIAL_SYNC_READ

    fForce -- force always

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    WCHAR           serialDN[ MAX_DN_PATH ];
    BYTE            buffer[ RECORD_SMALL_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;

    DNS_DEBUG( DS, (
        "Ds_CheckForAndForceSerialWrite( %s, %p )\n",
        pZone->pwszZoneDN,
        dwCause ));

    //
    //  skip, if cause not sufficient for serial write
    //

    if ( !pZone->fDsIntegrated )
    {
        ASSERT( FALSE );
        return;
    }
    if ( !fForce && SrvCfg_dwSyncDsZoneSerial < dwCause )
    {
        DNS_DEBUG( DS, ( "Skip zone serial sync -- cause insufficient\n" ));
        return;
    }

    //
    //  skip if this serial already written
    //

    if ( !fForce && pZone->dwSerialNo <= pZone->dwHighDsSerialNo )
    {
        IF_DEBUG( DS )
        {
            DnsPrintf( "Skip zone serial sync -- cause insufficient\n" );
            if ( pZone->dwSerialNo < pZone->dwHighDsSerialNo )
            {
                DnsPrintf(
                    "WARNING: zone serial %d, smaller that HighDsSerial %d\n"
                    "    this is only possible if DS read just occured on another thread\n",
                    pZone->dwSerialNo,
                    pZone->dwHighDsSerialNo );
            }
        }
        return;
    }

    //
    //  bump serial number if shutting down
    //
    //  this protects against the case where we've XFRed current serial
    //  number, but while we reboot, data replicates in that has LOWER
    //  serial than what we had;  in that case we have new data so we
    //  need to make sure we have a higher serial number than last XFR
    //

    if ( dwCause == ZONE_SERIAL_SYNC_SHUTDOWN &&
         HAS_ZONE_VERSION_BEEN_XFRD( pZone ) )
    {
        Zone_IncrementVersion( pZone );
    }

    //
    //  create serial DN
    //      - first need unicode server name
    //

    if ( !g_pwsServerName )
    {
        g_pwsServerName = Dns_StringCopyAllocate(
                            SrvCfg_pszServerName,
                            0,                      // length unknown
                            DnsCharSetUtf8,         // UTF8 in
                            DnsCharSetUnicode );    // unicode out
    }
    if ( !g_pwsServerName )
    {
        goto Done;
    }

    status = StringCchPrintfW(
                serialDN,
                sizeofarray( serialDN ),
                L"DC=..SerialNo-%s,%s",
                g_pwsServerName,
                pZone->pwszZoneDN );
    if ( FAILED( status ) )
    {
        goto Done;
    }

    //
    //  write this as tombstone record
    //

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_SMALL_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        1,      // one record only
        pZone->dwSerialNo );

    writeTombstoneRecord( pmodBuffer, pZone );

    STAT_INC( DsStats.DsSerialWrites );

    //
    //  write to DS
    //      - but unlike tombstone we MODIFY to force to DS
    //

    DNS_DEBUG( DS, (
        "Forcing serial %d write to DS for zone %S\n",
        pmodBuffer->SerialNo,
        pZone->pwsZoneName ));

    writeRecordsToDsNode(
         pServerLdap,
         serialDN,
         pmodBuffer,
         DNSDS_REPLACE | DNSDS_TOMBSTONE,
         pZone );

    Done:
    
    return;
}



DNS_STATUS
Ds_WriteNodeToDs(
    IN      PLDAP           pLdapHandle,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwOperation,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

Arguments:

    pLdapHandle -- LDAP handle

    pNode - node to write

    wType - type to write

    pZone - zone

    dwFlag - additional info propagated from update list flags

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           countRecords;
    BYTE            buffer[ RECORD_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;
    PDB_RECORD      prrDs = NULL;
    BOOL            fmatch;
    BOOL            bNodeinDS = FALSE;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    DWORD           serialNo;


    DNS_DEBUG( DS, (
        "Ds_WriteNodeToDs() label %s for zone %s\n",
        pNode->szLabel,
        pZone->pszZoneName ));

    //  must have already opened DS zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( dwOperation == DNSDS_REPLACE || dwOperation == DNSDS_ADD );

    //
    //  if given update flag, pull out some stats
    //
    //  better to do this right in the update routine ... but
    //  currently there's one for secure one for non, so this is better
    //

    if ( dwFlag )
    {
        STAT_INC( DsStats.UpdateWrites );

        //  type of change requiring update

        if ( TNODE_RECORD_CHANGE(pNode) )
        {
            STAT_INC( DsStats.UpdateRecordChange );
        }
        else if ( TNODE_AGING_REFRESH(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingRefresh );
        }
        else if ( TNODE_AGING_OFF(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingOff );
        }
        else if ( TNODE_AGING_ON(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingOn );
        }
        else
        {
            ASSERT( FALSE );
        }

        //  source of update

        if ( dwFlag & DNSUPDATE_PACKET )
        {
            STAT_INC( DsStats.UpdatePacket );
            if ( dwFlag & DNSUPDATE_PRECON )
            {
                STAT_INC( DsStats.UpdatePacketPrecon );
            }
        }
        else if ( dwFlag & DNSUPDATE_ADMIN )
        {
            STAT_INC( DsStats.UpdateAdmin );
        }
        else if ( dwFlag & DNSUPDATE_AUTO_CONFIG )
        {
            STAT_INC( DsStats.UpdateAutoConfig );
        }
        else if ( dwFlag & DNSUPDATE_SCAVENGE )
        {
            STAT_INC( DsStats.UpdateScavenge );
        }
        else
        {
            ASSERT( FALSE );
        }
    }


    //
    //  read node
    //
    //  note: update path now contains COMPLETE suppression of all
    //      no-op updates;  the pattern is read, copy, execute update
    //      on temp node, check temp against real -- if no need to
    //      write back, don't
    //

    if ( dwOperation == DNSDS_ADD )
    {
        DNS_DEBUG( DS, (
            "reading DS node %s\n",
            pNode->szLabel ));

        //
        //  read this node
        //  if record set at node is identical, no need to write
        //
        //  DEVNOTE-DCR: 454260 - Suppress unnecessary reads/writes (see RAID for more
        //      details from the original B*GB*G).
        //
        //  If this is due to a preup, we should ignore ttl comparison altogether.
        //

        status = Ds_ReadNodeRecords(
                    pZone,
                    pNode,
                    & prrDs,
                    NULL        // no search
                    );
        if ( status == ERROR_SUCCESS )
        {
            fmatch = RR_ListIsMatchingList(
                        pNode,
                        prrDs,
                        DNS_RRCOMP_CHECK_TTL |
                            DNS_RRCOMP_CHECK_TIMESTAMP );
            RR_ListFree( prrDs );

            //
            //  Suppress write if If RRList is matching
            //
            //  DEVNOTE-DCR: 454260 - Related to comment above.
            //

            if ( fmatch  )
            {
                DNS_DEBUG( DS, (
                    "DS write cancelled as existing data matches in memory\n"
                    "    zone = %s, node = %s\n",
                    pZone->pszZoneName,
                    pNode->szLabel ));

                STAT_INC( DsStats.DsWriteSuppressed );
                return ERROR_SUCCESS;
            }
        }
        else
        {
            //
            // Nothing read from the DS (new registration)
            //

            ASSERT ( prrDs == NULL );
        }
    }


    //
    //  need to write
    //

    //
    //  build DS name for this node
    //

    status = buildDsNodeNameFromNode(
                    wsznodeDN,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }
    
    //
    //  For administrative updates, delete the record from the DS. If there is
    //  a tombstone in the DS it must be deleted, otherwise the admin may be
    //  able to reactivate it and create a record in a zone where he should
    //  not be able to create records.
    //
    
    if ( ( dwFlag & DNSUPDATE_ADMIN ) && ( dwFlag & DNSUPDATE_NEW_RECORD ) )
    {
        Ds_DeleteDn( pServerLdap, wsznodeDN, FALSE );
    }

    //
    //  init buffer for data
    //
    //  for update serial number => dwNewSerialNo set during update
    //  for straight write => zone serial no
    //
    //  DEVNOTE: Could add dwWriteSerialNo to the zone so we could eliminate
    //      the serialNo parameter.
    //

    serialNo = dwFlag ? pZone->dwNewSerialNo : pZone->dwSerialNo;

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        0,              // record count not yet fixed
        serialNo );

    //
    //  build DS records for node
    //

    countRecords = 0;

    if ( pNode->pRRList && !IS_NOEXIST_NODE(pNode) )
    {
        status = buildDsRecordSet(
                    pmodBuffer,
                    pZone,
                    pNode,
                    wType );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR: writing RR set to buffer for DS write\n" ));
            ASSERT( FALSE );
            goto Cleanup;
        }
        countRecords = pmodBuffer->Count;
    }

    //
    //  if node is empty, delete it
    //
    //  note, we actually tombstone the node with a private DNS-DS
    //  tombstone, until it has a chance to replicate to all servers
    //  (currently waiting one day);  this is required because actual
    //  DS delete will create a tombstone with a mangled name (guid+LF)
    //  we can read it but would be unable to associate it with a
    //  particular node
    //
    //  on ADD -- like loading subtree or new zone, then skip write
    //      if no records
    //
    //  on REPLACE -- update delete, must still do delete even if no
    //      records (or even if NO object) so delete replicates squashing
    //      any recent ADD
    //
    //      however, if read was done and NOTHING was found, probably
    //      should suppress write;  this is no worse than the suppression
    //      we already do AND avoids an unecessary object create;
    //      downside is it allows the obnoxious "register-deregister-
    //      and-still-there" scenario
    //
    //      to catch this scenario, we need to trap LDAP_NO_SUCH_OBJECT
    //      error from Ds_ReadNodeRecords() above and suppress write on
    //      countRecords==0 case
    //

    if ( countRecords == 0 )
    {
        //  disappearing root-hints check

        if ( IS_ZONE_CACHE(pZone) )
        {
            if ( pNode == pZone->pTreeRoot )
            {
                DNS_DEBUG( ANY, (
                    "ERROR: empty root-hint root!\n"
                    "    operation = %d\n",
                    dwOperation ));
                ASSERT( FALSE );
                goto Cleanup;
            }
        }

        if ( dwOperation == DNSDS_ADD )
        {
            DNS_DEBUG( DS, (
                "DS add operation for node %s with no records\n"
                "    DS write suppressed\n",
                pNode->szLabel ));
            goto Cleanup;
        }
        if ( dwFlag )
        {
            STAT_INC( DsStats.UpdateTombstones );
        }

        DNS_DEBUG( DS, (
            "DS update delete for node %s\n", pNode->szLabel ));

        status = deleteNodeFromDs(
                    pLdapHandle,
                    pZone,
                    wsznodeDN,
                    serialNo );
        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node %S on secure update\n"
                    "    status = %p %d\n",
                    wsznodeDN,
                    status, status ));
            }
            else
            {
                BYTE    argTypeArray[] =
                            {
                                EVENTARG_UTF8,
                                EVENTARG_UTF8,
                                EVENTARG_UNICODE
                            };
                PVOID   argArray[] =
                            {
                                pNode->szLabel,
                                pZone->pszZoneName,
                                NULL
                            };
                PWSTR   perrString;

                perrString = argArray[ 2 ] = Ds_GetExtendedLdapErrString( NULL );
                DNS_LOG_EVENT(
                    DNS_EVENT_DS_WRITE_FAILED,
                    3,
                    argArray,
                    argTypeArray,
                    status );
                Ds_FreeExtendedLdapErrString( perrString );
            }
        }
    }

    //
    //  note: currently single RR attribute, so write entire RR list
    //
    //  if go back to specific type delete, then use wType
    //
    //  (note, how even the DS is smarter than IXFR and needs only
    //  new set)
    //

    else
    {
        DNS_DEBUG( DS, (
            "DS update replace for node %s\n",
            pNode->szLabel ));

        status = writeRecordsToDsNode(
                    pLdapHandle,
                    wsznodeDN,
                    pmodBuffer,
                    dwOperation,
                    pZone );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed update node label %S on secure update\n"
                    "    status = %p %d\n",
                    wsznodeDN,
                    status, status ));
            }
            else
            {
                BYTE    argTypeArray[] =
                            {
                                EVENTARG_UTF8,
                                EVENTARG_UTF8,
                                EVENTARG_UNICODE
                            };
                PVOID   argArray[] =
                            {
                                pNode->szLabel,
                                pZone->pszZoneName,
                                NULL
                            };
                PWSTR   perrString;

                perrString = argArray[ 2 ] = Ds_GetExtendedLdapErrString( NULL );
                DNS_LOG_EVENT(
                    DNS_EVENT_DS_WRITE_FAILED,
                    3,
                    argArray,
                    argTypeArray,
                    status );
                Ds_FreeExtendedLdapErrString( perrString );
            }
        }
    }

Cleanup:

    //  cleanup in case under the covers we allocated data

    Ds_CleanupModBuffer( pmodBuffer );

    DNS_DEBUG( DS, (
        "Leaving Ds_WriteNodeToDs(), zone %s\n"
        "    status = %p (%d)\n",
        pZone->pszZoneName,
        status, status ));

    return status;
}   //  Ds_WriteNodeToDs



//
//  DS initialization and startup
//

VOID
Ds_StartupInit(
    VOID
    )
/*++

Routine Description:

    Initialize DS globals needed whether open DS or not.

Arguments:

    None

Return Value:

    None

--*/
{
    INT     i;

    //  DEVNOTE-DCR: 454307 - clean up this function and usage of globals

    //  global handle

    pServerLdap = NULL;

    //  multiple open protection

    g_AttemptingDsOpen = FALSE;

    //  connection disabled

    g_bDisabledDs = FALSE;

    //  bytes appended to zone to form DN

    g_AppendZoneLength = 0;

    g_dnMachineAcct = NULL;
    g_pwszDnsContainerDN = NULL;
    g_pwsServerName = NULL;

    //  clear security package init flag

    g_fSecurityPackageInitialized = FALSE;


    //  CS

    pcsLdap = NULL;

    //  notification

    g_ZoneNotifyMsgId = INVALID_MSG_ID;

    //  first DS-DNS on this domain

    g_bDsFirstTimeRun = FALSE;

    //
    //  clear RootDSE attribute table
    //

    i = (-1);

    while( DSEAttributes[++i].szAttrType )
    {
        DSEAttributes[i].pszAttrVal = NULL;
    }
}



PWCHAR
Ds_GenerateBaseDnsDn(
    IN      BOOL    fIncludeMicrosoftDnsFolder
    )
/*++

Routine Description:

    Allocates a string and fills it with the base DN of the Microsoft DNS
    object. If you want to tack more DN components on the back pass in
    the size (in WCHARs, not in bytes) of the additional space required.

Arguments:

    fIncludeMicrosoftDnsFolder - include the RDN of the MicrosoftDNS
        folder as the left-most DN component

Return Value:

    WCHAR buffer allocated on the TAGHEAP. The caller MUST free this value
        with FREE_HEAP() - returns NULL on allocation error.

--*/
{
    int     numChars = wcslen( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal ) +
                            wcslen( g_pszRelativeDnsSysPath ) + 5;
    PWCHAR  pwszdns = ( PWCHAR ) ALLOC_TAGHEAP( numChars * sizeof( WCHAR ),
                            MEMTAG_DS_DN );

    if ( !pwszdns )
    {
        DNS_DEBUG( ANY, (
            "Ds_GenerateBaseDnsDn: out of memory (%d bytes)\n",
            numChars ));
        ASSERT( FALSE );
        return NULL;
    }

    wcscpy( pwszdns,
            fIncludeMicrosoftDnsFolder
                ? g_pszRelativeDnsSysPath
                : g_pszBareRelativeDnsSysPath );
    wcscat( pwszdns, DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal );
    return pwszdns;
}   //  Ds_GenerateBaseDnsDn



PSECURITY_DESCRIPTOR *
Ds_ReadSD(
    PLDAP                   LdapSession,
    PLDAPMessage            pLdapMsg
    )
/*++

Routine Description:

    Reads the SD from the an LDAP result message. The result message
    pointer should have been returned by ldap_first_entry or ldap_next_entry.

Arguments:

    LdapSession - ldap session handle to use to read the SD

    pLdapMsg - LDAP result message containing SD attribute value

Return Value:

    Newly allocated SD copy or NULL on error.

--*/
{
    DBG_FN( "Ds_ReadSD" )

    PSECURITY_DESCRIPTOR    pSd = NULL;
    struct berval **        ppval = NULL;

    //
    //  Read the security descriptor attribute value from the entry.
    //

    ppval = ldap_get_values_len( LdapSession, pLdapMsg, DSATTR_SD );
    if ( !ppval || !ppval[ 0 ] )
    {
        DNS_PRINT((
            "%s: missing %S attribute\n", fn,
            DSATTR_SD ));
        ASSERT( ppval && ppval[ 0 ] );
        goto Cleanup;
    }

    pSd = ALLOC_TAGHEAP( ppval[ 0 ]->bv_len, MEMTAG_DS_PROPERTY );
    IF_NOMEM( !pSd )
    {
        ASSERT( pSd );
        goto Cleanup;
    }

    RtlCopyMemory(
        pSd,
        ( PSECURITY_DESCRIPTOR ) ppval[ 0 ]->bv_val,
        ppval[ 0 ]->bv_len );

    Cleanup:

    if ( ppval )
    {
        ldap_value_free_len( ppval );
    }
    
    #if DBG
    Dbg_DumpSD( "Ds_ReadSD", pSd );
    #endif
    
    return pSd;
}   //  Ds_ReadSD



DNS_STATUS
Ds_ReadServerObjectSD(
    PLDAP                   pldap,
    PSECURITY_DESCRIPTOR *  ppSd
    )
/*++

Routine Description:

    Reads the SD from the MicrosoftDNS object in the directory. This
    SD can be used to authorize actions such as adding new zones.

Arguments:

    pldap - ldap session handle to use to read the SD

    ppSd - Pointer to the destination of the new SD. If there is an
        existing SD here (ie. not NULL), it is swapped out and freed
        in a safe manner.

Return Value:

    ERROR_SUCCESS if successful or error code if error.

--*/
{
    DBG_FN( "Ds_ReadServerObjectSD" )

    DNS_STATUS              status = ERROR_SUCCESS;
    PWCHAR                  pwszMicrosoftDnsDn;
    PLDAPMessage            msg = NULL;
    PLDAPMessage            entry;
    PSECURITY_DESCRIPTOR    pSd = NULL;
    static DWORD            g_LastTimeSDRefreshed = 0;

    PLDAPControl            ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    PWSTR                   attrsToRead[] =
    {
        DSATTR_SD,
        NULL
    };

    if ( !Ds_IsDsServer() )
    {
        return ERROR_SUCCESS;
    }
    
    //
    //  Prevent overly frequent refresh. If the SD pointer is NULL however,
    //  allow the refresh attempt.
    //
    
    if ( *ppSd &&
         DNS_TIME() - g_LastTimeSDRefreshed < DS_MS_DNS_ACL_REFRESH_INTERVAL )
    {
        return ERROR_SUCCESS;
    }
    g_LastTimeSDRefreshed = DNS_TIME();

    pwszMicrosoftDnsDn = Ds_GenerateBaseDnsDn( TRUE );    
    IF_NOMEM( !pwszMicrosoftDnsDn )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    ASSERT( pldap );
    ASSERT( ppSd );

    //
    //  Search for the base DNS object.
    //
    
    status = ldap_search_ext_s(
                    pldap,
                    pwszMicrosoftDnsDn,
                    LDAP_SCOPE_BASE,
                    NULL,               // filter
                    attrsToRead,
                    FALSE,              // attrsOnly
                    ctrls,              // serverControls
                    NULL,               // clientControls
                    &g_LdapTimeout,
                    0,
                    &msg );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error %lu reading base DNS object %S\n", fn,
            status,
            pwszMicrosoftDnsDn ));
        ASSERT( FALSE );
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  Pull the entry pointer out of the search result message.
    //

    entry = ldap_first_entry( pldap, msg );
    if ( !entry )
    {
        DNS_DEBUG( DS, (
            "%s: failed to get entry out of base DNS object\n", fn ));
        ASSERT( FALSE );
        status = DNS_ERROR_RECORD_DOES_NOT_EXIST;
        goto Cleanup;
    }

    pSd = Ds_ReadSD( pldap, entry );
    if ( !pSd )
    {
        status = DNS_ERROR_NO_MEMORY;
    }

    //
    //  Free allocated values and return the SD.
    //

    Cleanup:

    if ( pwszMicrosoftDnsDn )
    {
        FREE_HEAP( pwszMicrosoftDnsDn );
    }
    
    if ( msg )
    {
        ldap_msgfree( msg );
    }

    if ( status == ERROR_SUCCESS )
    {
        Timeout_Free( *ppSd );
        *ppSd = pSd;
    }

    return status;
}   //  Ds_ReadServerObjectSD



DNS_STATUS
addObjectValueIfMissing(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDn,
    IN      PWSTR           pwszAttributeName,
    IN      PWSTR           pwszAttributeValue )
/*++

Routine Description:

    Add an attribute value to the directory object specified by DN
    but only if the object does not currently have a value for that
    attribute.

Arguments:

    pLdap -- LDAP session handle

    pwszDn -- DN of object to test/modify

    pwszAttributeName -- attribute name to test/modify

    pwszAttributeValue -- value to add if attribute is missing
    
Return Value:

    ERROR_SUCCESS if successful or error code on failure

--*/
{
    DBG_FN( "addObjectValueIfMissing" )

    DNS_STATUS      status;
    DWORD           searchTime;
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;
    PWSTR *         ppvals = NULL;

    PWSTR           attrs[] =
        {
        pwszAttributeName,
        NULL
        };

    PWCHAR          valueArray[] =
        {
        pwszAttributeValue,
        NULL
        };

    LDAPModW        mod = 
        {
        LDAP_MOD_ADD,
        pwszAttributeName,
        valueArray
        };

    LDAPModW *      modArray[] =
        {
        &mod,
        NULL
        };

    attrs[ 0 ] = pwszAttributeName;
    attrs[ 1 ] = NULL;

    //
    //  See if the object currently has the attribute set. 
    //

    DS_SEARCH_START( searchTime );
    status = ldap_search_ext_s(
                pLdap,
                pwszDn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                attrs,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presult );
    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pwszDn, pLdap, 0 );
        goto Cleanup;
    }

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), pwszDn, pLdap, 0 );
        goto Cleanup;
    }

    ppvals = ldap_get_values( pLdap, pentry, pwszAttributeName );
    if ( ppvals )
    {
        //  Object already has value(s) for this attribute --> do nothing.
        goto Cleanup;
    }

    //
    //  Add the attribute value to the object.
    //

    status = ldap_modify_ext_s(
                    pLdap,
                    pwszDn,
                    modArray,
                    NULL,           // server controls
                    NULL );         // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error during modify 0x%X\n", fn, status ));
        status = Ds_ErrorHandler( status, pwszDn, pLdap, 0 );
        goto Cleanup;
    }

    //
    //  Clean up and return.
    //

    Cleanup:

    if ( ppvals )
    {
        ldap_value_free( ppvals );
    }
    if ( presult )
    {
        ldap_msgfree( presult );
    }
    
    return status;
}   //  addObjectValueIfMissing



DNS_STATUS
addDnsToDirectory(
    IN      PLDAP           pLdap,
    IN      BOOL            fAddDnsAdmin
    )
/*++

Routine Description:

    Add DNS OU to DS.

Arguments:

    pLdap -- LDAP connection to create OU on
    fAddDnsAdmin -- a flag indicating that we should modify the container
    security if it exists (it is used to fix ms dns container if dnsadmin
    has deleted & added for instance).

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_LDAP_SINGLE_MOD modContainer;
    DNS_LDAP_SINGLE_MOD modDns;
    DNS_STATUS          status;
    PWCHAR              pwszdns = NULL;
    PCHAR               pszdns;
    PLDAPMod            pmodArray[3];

    pwszdns = Ds_GenerateBaseDnsDn( TRUE );

    DNS_DEBUG( DS, (
        "Adding DNS container = %S\n",
        pwszdns ));

    if ( !pwszdns )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Error;
    }

    //
    //  one mod -- add the MicrosoftDNS container
    //

    pmodArray[0] = (PLDAPMod) &modContainer;
    pmodArray[1] = (PLDAPMod) &modDns;
    pmodArray[2] = NULL;

    buildStringMod(
        & modContainer,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("container")
        );

    buildStringMod(
        & modDns,
        LDAP_MOD_ADD,
        LDAP_TEXT("cn"),
        LDAP_TEXT("MicrosoftDNS")
        );

    //
    //  create DNS container
    //      - save DN for container
    //      - save length needed in addition to zone name length, for building zone
    //          "dc="<zoneDN>","<dnsContainerDN>

    status = ldap_add_ext_s(
                pLdap,
                pwszdns,
                pmodArray,
                NULL,
                NULL );
    if ( status == ERROR_SUCCESS || status == LDAP_ALREADY_EXISTS )
    {
        g_pwszDnsContainerDN = pwszdns;
        g_AppendZoneLength = ( wcslen( LDAP_TEXT("dc=,") ) +
                               wcslen( g_pwszDnsContainerDN ) +
                               1 + 20 ) * sizeof(WCHAR);

        if ( status == ERROR_SUCCESS ||
            ( status == LDAP_ALREADY_EXISTS && fAddDnsAdmin ) )
        {
            //
            //  First time create.
            //  OR re-create of DnsAdmin group (requiring re-add of ACE to container access).
            //  Modify container security to our default server SD
            //

            g_bDsFirstTimeRun = TRUE;

            status = Ds_AddPrincipalAccess(
                                pLdap,
                                pwszdns,
                                NULL,       //  SID
                                SZ_DNS_ADMIN_GROUP_W,
                                GENERIC_ALL,
                                CONTAINER_INHERIT_ACE,
                                FALSE,      //  whack existing ACE
                                TRUE );     //  take ownership
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                    "Error <%lu>: failed to modify dns root security\n",
                    status));
                status = Ds_ErrorHandler(
                             LdapGetLastError(),
                             pwszdns,
                             pLdap,
                             0 );
            }

            //
            //  We don't want authenticated users having any permissions
            //  by default on the MicrosoftDNS container. If this call
            //  fails, ignore failure.
            //
            
            Ds_RemovePrincipalAccess(
                pLdap,
                pwszdns,
                NULL,                           //  prinipal name
                g_pAuthenticatedUserSid );

            Ds_RemovePrincipalAccess(
                pLdap,
                pwszdns,
                NULL,                           //  prinipal name
                g_pBuiltInAdminsSid );
            
            status = ERROR_SUCCESS;
        }

        //
        //  Add a displayName attribute value to the object. This is the
        //  string that will be displayed by certain MMC controls/dialogs,
        //  such as if you bring up the Advanced properties from the
        //  security properties of the DNS server object.
        //

        addObjectValueIfMissing(
            pLdap,
            pwszdns,
            DSATTR_DISPLAYNAME,
            L"DNS Servers" );

        DNS_DEBUG( DS, (
            "addDnsToDirectory\n"
            "    container DN = %S\n"
            "    append to zone length = %d\n",
            g_pwszDnsContainerDN,
            g_AppendZoneLength ));

        return ERROR_SUCCESS;
    }

    Error:

    DNS_DEBUG( DS, (
        "addDnsToDirectory failed to add %S to DS\n"
        "  status = %d\n",
        pwszdns,
        status ));

    FREE_HEAP( pwszdns );

    return status;
}


#if 0

VOID
setupTombstoneControl(
    VOID
    )
/*++

Routine Description:

    Sets up tombstone control.

Arguments:

    None

Return Value:

    None

--*/
{
    TombstoneControl.ldctl_oid = LDAP_SERVER_SHOW_DELETED_OID_W;

    TombstoneControl.ldctl_iscritical = TRUE;
    TombstoneControl.ldctl_value.bv_len = 0;
    TombstoneControl.ldctl_value.bv_val = (PCHAR) &TombstoneDataValue;

    TombstoneDataValue = 1;
}
#endif



VOID
setupLazyCommitControl(
    VOID
    )
/*++

Routine Description:

    Sets up lazy commit control

Arguments:

    None

Return Value:

    None

--*/
{
    LazyCommitControl.ldctl_oid = LDAP_SERVER_LAZY_COMMIT_OID_W;

    LazyCommitControl.ldctl_iscritical = TRUE;
    LazyCommitControl.ldctl_value.bv_len = 0;
    LazyCommitControl.ldctl_value.bv_val = NULL;
}



VOID
setupSecurityDescriptorControl(
    VOID
    )
/*++

Routine Description:


     set control to ask for SD (ask for all)

     berval to get SD props.
     first 4 bytes are asn1 for specifying the last byte.

    use by setting up the following & putting in server control search arg
        PLDAPControl ctrl[2] = { &SecurityDescriptorControl, NULL};


Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  Set up control that specifies DACL, GROUP, OWNER
    //
    
    SecurityDescriptorControl_DGO.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
    SecurityDescriptorControl_DGO.ldctl_iscritical = TRUE;
    SecurityDescriptorControl_DGO.ldctl_value.bv_len = SECURITYINFORMATION_LENGTH;
    SecurityDescriptorControl_DGO.ldctl_value.bv_val = g_SecurityInformation_DGO;

    //
    //  Set up control that specifies DACL only
    //
    
    SecurityDescriptorControl_D.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
    SecurityDescriptorControl_D.ldctl_iscritical = TRUE;
    SecurityDescriptorControl_D.ldctl_value.bv_len = SECURITYINFORMATION_LENGTH;
    SecurityDescriptorControl_D.ldctl_value.bv_val = g_SecurityInformation_D;
}



VOID
setupNoReferralControl(
    VOID
    )
/*++

Routine Description:

    Sets up no server referral generation control

Arguments:

    None

Return Value:

    None

--*/
{
    //  no-referrals control

    NoDsSvrReferralControl.ldctl_oid = LDAP_SERVER_DOMAIN_SCOPE_OID_W;

    NoDsSvrReferralControl.ldctl_iscritical = FALSE;
    NoDsSvrReferralControl.ldctl_value.bv_len = 0;
    NoDsSvrReferralControl.ldctl_value.bv_val = NULL;
}


DNS_STATUS
Ds_LoadRootDseAttributes(
    IN      PLDAP           pLdap
    )
/*++

Routine Description:

    Load operational attributes from the DS such as configuration NC,
    default NC etc.

Arguments:

    pLdap -- ldap handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DBG_FN( "Ds_LoadRootDseAttributes" )

    ULONG           status;
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;
    PWSTR *         ppvals = NULL;
    PWSTR           pwszAttributeName;
    PVOID           pattributeValue = NULL;
    INT             i;
    DWORD           searchTime;
    PWSTR           svrAttrs[] =
                    {
                        LDAP_TEXT( "serverReference" ),
                        NULL
                    };
    PWSTR           behaviorVerAttrs[] =
                    {
                        DSATTR_BEHAVIORVERSION,
                        NULL
                    };
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pinfo = NULL;
    LPWSTR *        ppszValues = NULL;
    PWSTR           pwsznewdnMachineAcct;

    if ( !pLdap )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  search for base props
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pLdap,
                NULL,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                NULL,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presult );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, NULL, pLdap, 0 );
        goto Cleanup;
    }

    //
    //  parse out & fill in base props
    //

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), NULL, pLdap, 0 );
        goto Cleanup;
    }

    //
    //  read root DSE attributes
    //

    i = (-1);

    while ( ( pwszAttributeName = DSEAttributes[ ++i ].szAttrType ) != NULL )
    {
        //
        //  Get the value(s) for this attribute from the LDAP entry.
        //

        ppvals = ldap_get_values( pLdap, pentry, pwszAttributeName );
        if ( !ppvals || !ppvals[ 0 ] )
        {
            DNS_DEBUG( DS, (
                "rootDSE ERROR: no values for %S\n",
                pwszAttributeName ));
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        //  Copy attribute values - both single and multi-valued
        //  rootDSE attribute are supported. The tables tells us if
        //  we're interested in a single or all values of the attribute.
        //

        if ( DSEAttributes[ i ].fMultiValued )
        {
            //
            //  Copy all values for this attribute.
            //

            ULONG       iValues = ldap_count_values( ppvals );

            if ( iValues )
            {
                ULONG       srcValIdx;
                ULONG       destValIdx;

                ppszValues = ALLOC_TAGHEAP_ZERO(
                                    ( iValues + 1 ) * sizeof( PWCHAR ),
                                    MEMTAG_DS_OTHER );;
                IF_NOMEM( !ppszValues )
                {
                    status = DNS_ERROR_NO_MEMORY;
                    goto Cleanup;
                }

                for ( srcValIdx = destValIdx = 0;
                      srcValIdx < iValues;
                      ++srcValIdx, ++destValIdx )
                {
                    //
                    //  Special processing for I_DSE_NAMINGCONTEXTS: ignore
                    //  config and schema directory partitions.
                    //

                    if ( i == I_DSE_NAMINGCONTEXTS &&
                        ( wcscmp(
                                ppvals[ srcValIdx ],
                                DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ) == 0 ||
                            wcscmp(
                                ppvals[ srcValIdx ],
                                DSEAttributes[ I_DSE_SCHEMA_NC ].pszAttrVal ) == 0 ) )
                    {
                        DNS_DEBUG( DS, (
                            "rootDSE: ignoring %S =\n"
                            "    \"%S\"\n",
                            pwszAttributeName,
                            ppvals[ srcValIdx ] ));
                        --destValIdx;
                        continue;
                    }
            
                    //
                    //  Allocate and copy value.
                    //

                    ppszValues[ destValIdx ] = ALLOC_TAGHEAP(
                            ( wcslen( ppvals[ srcValIdx ] ) + 1 ) * sizeof( WCHAR ),
                            MEMTAG_DS_OTHER );
                    IF_NOMEM( !ppszValues[ destValIdx ] )
                    {
                        status = DNS_ERROR_NO_MEMORY;
                        goto Cleanup;
                    }

                    wcscpy( ppszValues[ destValIdx ], ppvals[ srcValIdx ] );

                    DNS_DEBUG( DS, (
                        "rootDSE: %S[%lu] =\n"
                        "    \"%S\"\n",
                        pwszAttributeName,
                        destValIdx,
                        ppszValues[ destValIdx ] ));
                }
                ppszValues[ destValIdx ] = NULL;     //  null-terminate
                pattributeValue = ( PVOID ) ppszValues;
                ppszValues = NULL;      //  so it isn't freed during cleanup
            }
        }
        else
        {
            //
            //  This attribute is single-valued. Allocate and copy first value.
            //

            ASSERT( ldap_count_values( ppvals ) == 1 );

            pattributeValue = ALLOC_TAGHEAP(
                                    ( wcslen( ppvals[ 0 ] ) + 1 ) * sizeof( WCHAR ),
                                    MEMTAG_DS_OTHER );
            IF_NOMEM( !pattributeValue )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
            wcscpy( pattributeValue, ppvals[ 0 ] );
            DNS_DEBUG( DS, (
                "rootDSE: %S =\n"
                "    \"%S\"\n",
                pwszAttributeName,
                pattributeValue ));
        }

        //
        //  Free previously allocated value. Use timeout free so that
        //  we don't need to make use of these attribute values thread-safe.
        //

        if ( DSEAttributes[ i ].pszAttrVal )
        {
            if ( DSEAttributes[ i ].fMultiValued )
            {
                INT     valIdx;

                for ( valIdx = 0;
                      DSEAttributes[ i ].ppszAttrVals[ valIdx ];
                      ++valIdx )
                {
                    Timeout_Free( DSEAttributes[ i ].ppszAttrVals[ valIdx ] );
                }
            }
            Timeout_Free( DSEAttributes[ i ].pszAttrVal );
        }

        //
        //  Free LDAP value set and assign allocated copy to global.
        //

        ldap_value_free( ppvals );
        ppvals = NULL;
        DSEAttributes[ i ].pszAttrVal = pattributeValue;
    }

    ldap_msgfree( presult );
    presult = NULL;

    //
    //  search for machine account
    //      - base properties, servername attribute
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pLdap,
                    DSEAttributes[I_DSE_SERVERNAME].pszAttrVal,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    svrAttrs,
                    FALSE,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult);
    if ( presult )


    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler(
                     status,
                     DSEAttributes[I_DSE_SERVERNAME].pszAttrVal,
                     pLdap,
                     0 );
        goto Cleanup;
    }

    //
    //  read serverReference attribute -- machine account DN
    //

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler(
                     LdapGetLastError(),
                     DSEAttributes[ I_DSE_SERVERNAME ].pszAttrVal,
                     pLdap,
                     0 );
        goto Cleanup;
    }

    ppvals = ldap_get_values( pLdap, pentry, LDAP_TEXT( "serverReference" ) );
    if ( !ppvals || !ppvals[ 0 ] )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    ASSERT( ldap_count_values( ppvals ) == 1 );

    pwsznewdnMachineAcct = ALLOC_TAGHEAP(
                                ( wcslen( ppvals[ 0 ] ) + 1 ) * sizeof( WCHAR ),
                                MEMTAG_DS_OTHER );
    IF_NOMEM( !pwsznewdnMachineAcct )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    wcscpy( pwsznewdnMachineAcct, ppvals[0] );
    Timeout_Free( g_dnMachineAcct );
    g_dnMachineAcct = pwsznewdnMachineAcct;

    ldap_value_free( ppvals );
    ppvals = NULL;

    //
    //  Read DSA behavior verstion from the machine object.
    //

    if ( presult )
    {
        ldap_msgfree( presult );
        presult = NULL;
    }
    pentry = NULL;

    status = ldap_search_ext_s(
                    pLdap,
                    g_dnMachineAcct,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    behaviorVerAttrs,
                    FALSE,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult);
    if ( presult )
    {
        pentry = ldap_first_entry( pLdap, presult );
    }
    if ( pentry )
    {
        ppvals = ldap_get_values(
                    pLdap,
                    pentry, 
                    DSATTR_BEHAVIORVERSION );
        if ( ppvals && *ppvals )
        {
            SetDsBehaviorVersion( Dsa, ( DWORD ) _wtoi( *ppvals ) );
            DNS_DEBUG( DS, (
                "%s: DSA %S = %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_ulDsDsaVersion ));
        }
        else
        {
            SetDsBehaviorVersion( Dsa, 0 );
            DNS_DEBUG( DS, (
                "%s: DSA %S missing so defaulting to %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_ulDsDsaVersion ));
        }
    }

    //
    //  Read domain behavior version from default naming context object.
    //

    if ( presult )
    {
        ldap_msgfree( presult );
        presult = NULL;
    }
    pentry = NULL;

    status = ldap_search_ext_s(
                    pLdap,
                    DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    behaviorVerAttrs,
                    FALSE,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult );
    if ( presult )
    {
        pentry = ldap_first_entry( pLdap, presult );
    }
    if ( pentry )
    {
        ppvals = ldap_get_values(
                    pLdap,
                    pentry, 
                    DSATTR_BEHAVIORVERSION );
        if ( ppvals && *ppvals )
        {
            SetDsBehaviorVersion( Domain, ( DWORD ) _wtoi( *ppvals ) );
            DNS_DEBUG( DS, (
                "%s: domain %S = %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_ulDsDomainVersion ));
        }
        else
        {
            SetDsBehaviorVersion( Domain, 0 );
            DNS_DEBUG( DS, (
                "%s: domain %S missing so defaulting to %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_ulDsDomainVersion ));
        }
    }

    //
    //  get flat netbios domain name
    //

    status = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE*) &pinfo );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>: DsRoleGetPrimaryDomainInformation failure\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    if ( pinfo && pinfo->DomainNameFlat )
    {
        wcscpy( g_wszDomainFlatName, pinfo->DomainNameFlat);
    }
    // every DC has a flat netbios name accessible locally.
    ELSE_ASSERT( pinfo && pinfo->DomainNameFlat );


Cleanup:

    if ( ppszValues )
    {
        INT         iVal;

        for ( iVal = 0; ppszValues[ iVal ]; ++iVal )
        {
            FREE_HEAP( ppszValues[ iVal ] );
        }
    }
    if ( ppvals )
    {
        ldap_value_free( ppvals );
    }
    if ( presult )
    {
        ldap_msgfree( presult );
    }
    if ( pinfo )
    {
        DsRoleFreeMemory(pinfo);
    }

    return status;
}



PLDAP
Ds_Connect(
    IN      LPCWSTR             pszServer,
    IN      DWORD               dwFlags,
    OUT     DNS_STATUS *        pStatus
    )
/*++

Routine Description:

    Open DS for DNS work.

    Sets up initial mandatory conditions such as
     - controls
     - ldap connection options
     - bind credentials

    Note: differs from Ds_OpenServer in that it doesn't do any
    DNS initialization.  It only handles ldap connection init, so
    can be called repeatedly, on connection failures.

Arguments:

    pszServer - server name

    dwFlags - DNS_DS_OPT_XXX flags

    pStatus - error code output (optional)

Return Value:

    LDAP handle or NULL on error.

--*/
{
    DBG_FN( "Ds_Connect" )

    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       value;

    if ( pStatus )
    {
        *pStatus = 0;
    }

    pldap = ldap_init( ( PWCHAR ) pszServer, LDAP_PORT );
    if ( !pldap )
    {
        status = LdapGetLastError();
        DNS_DEBUG( DS, (
            "%s: error %d initializing connection to remote DS %S\n", fn,
            status,
            pszServer ));
        goto Failure;
    }

    //  Set AREC_EXCLUSIVE to prevent SRV queries on hostname.

    value = TRUE;
    ldap_set_option(
        pldap,
        LDAP_OPT_AREC_EXCLUSIVE,
        &value );

    //
    //  open ldap connection to DS
    //

    status = ldap_connect( pldap, NULL );
    if ( status != LDAP_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error %d connecting to remote DS %S\n", fn,
            status,
            pszServer ));
        goto Failure;
    }

    //
    //  set connection options
    //

    //  set version

    value = 3;
    ldap_set_option(
        pldap,
        LDAP_OPT_VERSION,
        & value );

    //  set maximum timeout for ldap ops

    value = DNS_LDAP_TIME_LIMIT_S;
    ldap_set_option(
        pldap,
        LDAP_OPT_TIMELIMIT,
        & value );

    //  set chasing no referrals

    value = FALSE;
    ldap_set_option(
        pldap,
        LDAP_OPT_REFERRALS,
        & value );

    if ( dwFlags & DNS_DS_OPT_ALLOW_DELEGATION )
    {
        //  Set delegation so LDAP can contact other DCs on our behalf.
        //  This is required when creating a directory partition.

        status = ldap_get_option(
                    pldap,
                    LDAP_OPT_SSPI_FLAGS,
                    & value );
        if ( status == LDAP_SUCCESS )
        {
            value |= ISC_REQ_DELEGATE;
            status = ldap_set_option(
                        pldap,
                        LDAP_OPT_SSPI_FLAGS,
                        & value );
            if ( status != LDAP_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "failed to set LDAP SSPI flags error=%d\n", status ));
            }
            else
            {
                DNS_DEBUG( DS, (
                    "LDAP_OPT_SSPI_FLAGS are now 0x%08x on LDAP session %p\n",
                    value,
                    pldap ));
            }
        }
        else
        {
            DNS_DEBUG( ANY, (
                "failed to get LDAP SSPI flags error=%d\n", status ));
        }
    }

    //
    //  bind with NULL credentials at DS root
    //
    //  DEVNOTE: ldap_bind with KERBEROS
    //      need to either
    //          - directly specifying kerberos OR
    //          - identify that we've fallen over to NTLM, bail out, cleanup
    //              and retry
    //  JeffW: is this a to-do item or a note about the history of the code or what?
    //
    //  want to directly specify KERBEROS as there was some problem with
    //  negotiate not finding KERBEROS and then we'd fall over to NTLM
    //  which would mess up our ACLing and leave us getting ACCESS_DENIED
    //  Richard should investigate the KERB bind failure
    //

    #if DBG
    Dbg_CurrentUser( "Ds_Connect" );
    #endif

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_NEGOTIATE );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error %d binding to remote DS %S\n", fn,
            status,
            pszServer ));

        //
        //  close & NULL out connection.
        //

        Ds_LdapUnbind( &pldap );
        goto Failure;
    }

    #if DBG
    if ( pldap )
    {
        //
        //  Query and log some information about the context.
        //

        CtxtHandle                      hContext = { 0 };
        SecPkgContext_Names             names = { 0 };
        SecPkgContext_Authority         authority = { 0 };
        SecPkgContext_KeyInfo           keyinfo = { 0 };
        SecPkgContext_PackageInfo       pkginfo = { 0 };
        SECURITY_STATUS                 st;

        #define FCB( buff ) FreeContextBuffer( buff )

        ldap_get_option( pldap, LDAP_OPT_SECURITY_CONTEXT, &hContext );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_NAMES,
                         (PVOID) &names );
        DNS_DEBUG( DS, (
            "CTXINF: Names     %08X \"%S\"\n", st, names.sUserName ));
        FCB( names.sUserName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_AUTHORITY,
                         (PVOID) &authority );
        DNS_DEBUG( DS, (
            "CTXINF: Authority %08X %S\n", st, authority.sAuthorityName ));
        FCB( authority.sAuthorityName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_KEY_INFO,
                         (PVOID) &keyinfo );
        DNS_DEBUG( DS, (
            "CTXINF: KeyInfo   %08X sig=\"%S\" enc=\"%S\"\n"
            "CTXINF:           keysize=%d sigalg=0x%X encalg=0x%X\n",
            st,
            keyinfo.sSignatureAlgorithmName,
            keyinfo.sEncryptAlgorithmName,
            keyinfo.KeySize,
            keyinfo.SignatureAlgorithm,
            keyinfo.EncryptAlgorithm ));
        FCB( keyinfo.sSignatureAlgorithmName );
        FCB( keyinfo.sEncryptAlgorithmName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_PACKAGE_INFO,
                         (PVOID) &pkginfo );
        if ( pkginfo.PackageInfo )
        {
            DNS_DEBUG( DS, (
                "CTXINF: PkgInfo   %08X cap=%08X ver=%d rpcid=%d tokmaxsize=%d\n"
                "CTXINF:           name=\"%S\" comment=\"%S\"\n",
                st,
                ( int ) pkginfo.PackageInfo->fCapabilities,
                ( int ) pkginfo.PackageInfo->wVersion,
                ( int ) pkginfo.PackageInfo->wRPCID,
                ( int ) pkginfo.PackageInfo->cbMaxToken,
                pkginfo.PackageInfo->Name,
                pkginfo.PackageInfo->Comment ));
            FCB( pkginfo.PackageInfo );
        }
    }
    #endif

    //
    //  Set up controls
    //

    //  setup lazy commit control for modifies

    setupLazyCommitControl();

    //
    // Set up a control to be used for sepcifying that
    // the DS server won't generate referrals
    //

    setupNoReferralControl();

    //
    // set securitydescriptor access control
    //

    setupSecurityDescriptorControl();

    return pldap;

Failure:

    status = Ds_ErrorHandler(
                    status ? status : GetLastError(),
                    NULL,
                    pldap,
                    0 );

    if ( pStatus )
    {
        *pStatus = status;
    }

    return NULL;
}



DNS_STATUS
setDsaVersionGlobals(
    IN      PLDAP       pldap
    )
/*++

Routine Description:

    Search config container in directory for DSA objects with
    non-current versions so we know if there are downlevel DCs
    in the forest and in the domain.

Arguments:

    pldap -- LDAP session to use for searches

Return Value:

    Error code or ERROR_SUCCESS.

--*/
{
    DBG_FN( "setDsaVersionGlobals" )

    DNS_STATUS      status = ERROR_SUCCESS;
    int             iloop;
    PWSTR           pszbaseDn = DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal;
    ULONG           cbfilter = 0;
    PWCHAR          szfilter = NULL;

    #define SetStatus( _rc )    if ( status == ERROR_SUCCESS ) status = _rc;

    if ( !pszbaseDn )
    {
        ASSERT( pszbaseDn );
        return DNS_ERROR_INVALID_DATA;
    }

    //
    //  Search the config container for DSA objects to figure out
    //  if there are any DCs in the forest/domain that are not
    //  running Whistler or above.
    //

    for ( iloop = 0; iloop < 2; ++iloop )
    {
        DWORD           searchTime;
        PWCHAR          attrarray[] = { NULL };
        PLDAPMessage    presult = NULL;
        PLDAPMessage    pentry;
        DWORD           rc;
        PINT            pioutputCount;
        ULONG           count;
        
        //
        //  Build search filter.
        //

        #define DNS_DOMAIN_FILTER                                           \
            L"(&(objectCategory=ntdsDsa)(!(msDS-Behavior-Version>=%d))"     \
            L"(|(msDS-HasMasterNCs=%s)(hasMasterNCs=%s)))"
        #define DNS_ENTERP_FILTER                                           \
            L"(&(objectCategory=ntdsDsa)(!(msDS-Behavior-Version>=%d)))"

        if ( iloop == 0 )
        {
            //
            //  Search for downlevel DSAs who master this domain.
            //

            cbfilter = ( 1 + wcslen( DNS_DOMAIN_FILTER ) 
                            + ( sizeof( ULONG ) * 8 )   //  max possible %d
                            + 2 * wcslen( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal ) ) *
                       sizeof( WCHAR );
            szfilter = ALLOC_TAGHEAP( cbfilter, MEMTAG_DS_DN );
            if ( !szfilter )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }

            wsprintf(
                szfilter,
                DNS_DOMAIN_FILTER,
                DS_BEHAVIOR_WIN2003,
                DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
                DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal );
            pioutputCount = &g_ulDownlevelDCsInDomain;
        }
        else
        {
            //
            //  Search for downlevel DSAs in the entire forest.
            //
            
            cbfilter = ( 1 + wcslen( DNS_DOMAIN_FILTER ) +
                        ( sizeof( ULONG ) * 8 ) ) * sizeof( WCHAR );
            szfilter = ALLOC_TAGHEAP( cbfilter, MEMTAG_DS_DN );
            if ( !szfilter )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }

            wsprintf(
                szfilter,
                DNS_ENTERP_FILTER,
                DS_BEHAVIOR_WIN2003 );
            pioutputCount = &g_ulDownlevelDCsInForest;
        }
            
        //
        //  Search for matching DSA objects.
        //

        DS_SEARCH_START( searchTime );
        rc = ldap_search_ext_s(
                    pldap,
                    pszbaseDn,
                    LDAP_SCOPE_SUBTREE,
                    szfilter,
                    attrarray,
                    0,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult );
        DS_SEARCH_STOP( searchTime );

        if ( rc != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "%s: unable to search for DSA objects: error %d = 0x%08X\n"
                "    LDAP session =   %p\n"
                "    base DN =        %S\n"
                "    filter =         %S\n", fn,
                rc, rc,
                pldap,
                pszbaseDn,
                szfilter ));
            SetStatus( rc );
            ASSERT( rc == ERROR_SUCCESS );
        }
        else
        {
            ASSERT( presult );

            //
            //  Count the search results.
            //

            count = ldap_count_entries( pldap, presult );

            if ( count == -1 )
            {
                rc = LdapGetLastError();
                DNS_DEBUG( DS, (
                    "%s: unable to count search results: error %d = 0x%08X\n"
                    "    LDAP session =   %p\n"
                    "    base DN =        %S\n"
                    "    filter =         %S\n", fn,
                    rc, rc,
                    pldap,
                    pszbaseDn,
                    szfilter ));
                SetStatus( rc );
                ASSERT( count != -1 );
            }
            else
            {
                *pioutputCount = count;

                DNS_DEBUG( DS, (
                    "%s: found %d downlevel servers in the %s\n"
                    "    base DN =   %S\n"
                    "    filter =    %S\n", fn,
                    count,
                    iloop == 0 ? "domain" : "forest",
                    pszbaseDn,
                    szfilter ));
            }

            ldap_msgfree( presult );
        }

        FREE_TAGHEAP( szfilter, cbfilter, MEMTAG_DS_DN );
        szfilter = NULL;
    }
    
    Done:

    FREE_TAGHEAP( szfilter, 0, MEMTAG_DS_DN );
    
    return status;
}   //  setDsaVersionGlobals



DNS_STATUS
Ds_OpenServer(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Open DS for DNS work.

    Save root domain for building zone DS names.

    Note, this routine NOT multi-thread safe.
    It is called in startup thread our on admin add of first DS
    zone.

Arguments:

    dwFlag  -- some combination of
        DNSDS_WAIT_FOR_DS   -- wait in function attempting to open
        DNSDS_MUST_OPEN     -- error if does not success

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       connectRetry = 0;
    DWORD       elapsedWait = 0;
    BOOL        fwaitForDs = FALSE;
    BOOL        fAddDnsAdmin = FALSE;

    //
    //  check if already open
    //

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        DNS_DEBUG( DS2, ( "DS is disabled due to previous errors\n" ));
        return DNS_ERROR_DS_UNAVAILABLE;
    }

    if ( pServerLdap )
    {
        DNS_DEBUG( DS2, ( "DS already open\n" ));
        ASSERT( DSEAttributes[I_DSE_DEF_NC].pszAttrVal );
        ASSERT( DSEAttributes[I_DSE_ROOTDMN_NC].pszAttrVal );
        return ERROR_SUCCESS;
    }

    if ( !Ds_IsDsServer() )
    {
       DNS_DEBUG( DS, ( "The DS is unavailable\n" ));
       status = DNS_ERROR_DS_UNAVAILABLE;
       goto Failed;
    }

    if ( SD_IsImpersonating() )
    {
        DNS_DEBUG( DS, ( "Attempt to open server in impersonation context!!\n" ));
        ASSERT( FALSE );
        return ERROR_BAD_IMPERSONATION_LEVEL;
    }

    //
    //  protect against multiple open attempts
    //  DS poll thread can detect DS coming on line, AND
    //  can attempt open when directly change boot method;  for
    //  safety just lock this down
    //

    if ( ! Thread_TestFlagAndSet( &g_AttemptingDsOpen ) )
    {
        return DNS_ERROR_DS_UNAVAILABLE;
    }

    //
    //  initialize DS access CS
    //      - note, doing init here as once make connect attempt then
    //      can go into code that calls Ds_ErrorHandler() and this CS
    //      is hard to avoid;
    //      failure cases need to be considered before stuff like this
    //      checked in
    //

#if DNS_DS_ACCESS_SERIALIZATION
    if ( !pcsLdap )
    {
        DNS_DEBUG( DS, (
            "Initializing DS access sync control\n" ));

        status = DnsInitializeCriticalSection( &csLdap );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }

        pcsLdap = &csLdap;
    }
#endif

    //
    //  Open DS
    //  Poll on DS named event.
    //

    while( TRUE )
    {
        //
        //  Wait for DS to get into consistent state.
        //  waiting on a named event or service shutdown notice.
        //

        status = Ds_WaitForStartup( DNSSRV_DS_SYNC_WAIT_INTERVAL_MS );

        if ( status == ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, ( "DS Event notified ready for action\n" ));
            break;
        }

        //
        //  DEVNOTE-DCR: 454328 - Any other (smarter!) error handling possible here?
        // 

        // wait failure: either shutdown, timeout, or some other failure
        // action:
        //    - see if it's because we're shutting down & abort.
        //
        //    - increase interval & try again up to max interval
        //

        DNS_DEBUG( DS, (
            "ERROR <%lu>: Wait for DS sync event failed\n",
            status ));

        //
        //  allow service shutdown to interrupt the wait
        //  BUT ONLY if service exit, otherwise the load thread
        //  will wait on the continue event (which is NOT set on startup)
        //  and we'll be deadlocked
        //

        if ( fDnsServiceExit )
        {
            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, ( "Terminating thread in DS wait\n" ));
                goto Failed;
            }
        }

        //
        //  check point to keep SC happy
        //      - also handles startup announcement on long delay
        //

        Service_LoadCheckpoint();

        //
        //  increase retry interval
        //

        elapsedWait += DNSSRV_DS_SYNC_WAIT_INTERVAL_MS;

        if ( elapsedWait >= DNSSRV_DS_SYNC_WAIT_MAX_MS )
        {
            //
            // Passed maximum wait time-- log an event.
            // Note: If we're DSDC & the DS is unavailble the system is in BAD BAD
            // shape & we're no good & the DS is no good & per DaveStr we're ok
            // to assume this event is mandatory for DSDC & we must wait forever.
            // Hence we will not bailout here.
            // Alternatively, we can say, well it failed to give us an event, then
            // just go on & live w/out it, but for ds-int zones (& if we're here,we care
            // about the DS, we're useless anyway.
            // There's no limit for how long the DS takes to load cause for very big dbase
            // it can take hours.
            //

            DNS_DEBUG( DS, ( "ERROR <%lu>: Wait for DS sync event failed passed max time\n",
                status ));

            DNS_LOG_EVENT(
                DNS_EVENT_DS_OPEN_WAIT,
                0,
                NULL,
                NULL,
                status );

            //
            // Reset wait time so that we'll wait another max interval
            // before logging another event.
            //

            elapsedWait = 0;
        }

        //  loop back to retry wait on DS open
    }

    //
    //  DS notified us that it's ready for action.
    //
    //  Robustness fix: It turns out that on initial connect we can still
    //  fail to connect for unexplained & unexpected reasons (had lots of
    //  discussions around this).
    //  So, to workaound & add a little more robustness we will cycle for
    //  a few times (5) w/ additional attempts-- just giving it a little
    //  more chance to succeed.
    //

    connectRetry = 0;

    do
    {
        pldap = Ds_Connect( LOCAL_SERVER_W, 0, &status );
        if ( pldap )
        {
            break;
        }

        // Log in each cycle. If anyone ever complains, it'll give
        // us an indication that it happened again in free code.

        status = status ? status : DNS_ERROR_DS_UNAVAILABLE;
        DNS_DEBUG( ANY, (
            "ldap_open() failed with error %08X (%d)\n",
            status, status ));

        //  give DS a few seconds, then retry
        //      - give a total of few minutes with gentle backoff

        if ( connectRetry++ < 8 )
        {
            Sleep( 1000*connectRetry );

            //  fail only on last few retries so we can call DS guy to debug
            ASSERT( connectRetry < 5 );
            continue;
        }

        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_WAIT,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "Failed ldap_open() repeatedly -- giving up!\n"
            "    status = %p (%d)\n",
            status, status ));
        goto Failed;
    }
    while ( 1 );

    DNS_DEBUG( DS, ( "Successful ldap_open, pldap = %p\n", pldap ));

    //
    //  Load all operational attributes from RootDSE.
    //

    status = Ds_LoadRootDseAttributes( pldap );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to load Root DSE Attributes\n",
            LdapGetLastError() ));
        goto Failed;
    }

    //
    //  Search the config container for DSA objects to figure out
    //  if there are any downlevel DCs in the forest or domain.
    //

    setDsaVersionGlobals( pldap );

    //
    //  init security info
    //  Dependency: Must come before AddDNsToDirectory (below)
    //  Must come AFTER load RootDSE Attributes.
    //

    status = Ds_InitializeSecurity( pldap );
    if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
    {
        fAddDnsAdmin = TRUE;
    }
    else if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  conditionaly, add dynamic update proxy sec group
    //

    status = addProxiesGroup( pldap );
    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG( DS, (
           "Error <%lu>: Failed to add proxies group\n",
           LdapGetLastError() ));
       //   This is not a fatal condition, continue.
    }

    DNS_DEBUG( DS, (
        "Saved DS root domain = %S\n",
        DSEAttributes[I_DSE_DEF_NC].pszAttrVal));

    //
    //  Create DNS directory if doesn't exist.
    //  Dependency: depends on initializaiton by Ds_InitializeSecurity.
    //

    status = addDnsToDirectory( pldap, fAddDnsAdmin );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  keep around some commonly used structures,
    //      - Add-Name mod
    //      - tombstone control
    //  rather than building each time
    //

    buildStringMod(
        (PDNS_LDAP_SINGLE_MOD) gpAddNodeLdapMod,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("dnsNode") );

    //
    // Assign to global handle
    //

    pServerLdap = pldap;
    SrvCfg_fDsAvailable = TRUE;
    //SrvCfg_fDsOpen = TRUE;

    DNS_DEBUG( DS, (
        "Opened DS, ldap = %p\n",
        pldap ));

    //
    //  Read the SD from the MicrosoftDNS object.
    //

    Ds_ReadServerObjectSD( pServerLdap, &g_pServerObjectSD );

    Thread_ClearFlag( &g_AttemptingDsOpen );

    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenServer failed, status = %d (%p)\n",
        status, status ) );

    if ( dwFlag & DNSDS_MUST_OPEN )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
    }

    //  DEVNOTE-DCR: 454336 - Critical errors will trigger reconnect in async thread!

    status = Ds_ErrorHandler( status, NULL, NULL, 0 );
    Ds_LdapUnbind( &pldap );

    SrvCfg_fDsAvailable = FALSE;
    pServerLdap = NULL;

    Thread_ClearFlag( &g_AttemptingDsOpen );

    return status;
}



DNS_STATUS
Ds_OpenServerForSecureUpdate(
    OUT     PLDAP *         ppLdap
    )
/*++

Routine Description:

    Open DS connection in client context.

Arguments:

    None.
    Keep dummy arg until determine MT issue.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.


--*/
{
    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       value;

    //
    //  check if already open
    //

    ASSERT( ppLdap );
    if ( *ppLdap )
    {
        DNS_DEBUG( DS2, ( "DS already open for secure update;  pldap = %p\n" ));
        ASSERT( pServerLdap );
        return ERROR_SUCCESS;
    }

    //  open DS

    pldap = ldap_open( LOCAL_SERVER_W, LDAP_PORT );
    if ( !pldap )
    {
        DNS_DEBUG( ANY, ( "Failed ldap_open()\n" ));
        status = GetLastError();
        goto Failed;
    }
    
    //
    //  LDAP strangeness: reusing sessions?
    //
    
    ASSERT( pldap == NULL || pldap != pServerLdap );

    //  Make sure we're using Ldap v3

    value = 3;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_VERSION,
                & value );

    //  set default time limit on all ops

    value = DNS_LDAP_TIME_LIMIT_S;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_TIMELIMIT,
                & value );

    //  Never chase referrals

    value = FALSE;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_REFERRALS,
                & value );


    //  bind with NULL credentials

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_SSPI );       //  was LDAP_AUTH_NEGOTIATE
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Failed ldap_bind_s() with NULL credentials => status %d (%p)\n"
            "    errno    = %d (%p)\n",
            status, status,
            pldap->ld_errno, pldap->ld_errno ));
        goto Failed;
    }

    //  bind succeeded, return ldap ptr

    pldap->ld_timelimit = 0;
    pldap->ld_sizelimit = 0;
    pldap->ld_deref = LDAP_DEREF_NEVER;

    *ppLdap = pldap;

    DNS_DEBUG( DS, ( "Opened DS for secure update, ldap = %p\n", pldap ));
    #if DBG
    Dbg_CurrentUser( "New LDAP session" );
    #endif
    
    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenServerForSecureUpdate failed, status = %d (%p)\n",
        status, status ) );
    ASSERT( status != ERROR_SUCCESS );

    Ds_LdapUnbind( &pldap );
    return status;
}



DNS_STATUS
Ds_CloseServerAfterSecureUpdate(
    IN OUT  PLDAP *          ppLdap
    )
/*++

Routine Description:

    Close LDAP connection.

Arguments:

    pLdap -- ldap connection to close

Return Value:

    ERROR_SUCCESS if successful.
    Error code on Ds_LdapUnbind failure.

--*/
{
    return Ds_LdapUnbind( ppLdap );
}



VOID
Ds_Shutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup DS for reload shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_DEBUG( DS, ( "Ds_Shutdown()\n" ) );

    //
    //  only work is to close LDAP connection
    //

    Ds_LdapUnbind( &pServerLdap );
}



//
//  Private DS-DNS utilities
//

INT
usnCompare(
    IN      PCHAR           pszUsn1,
    IN      PCHAR           pszUsn2
    )
/*++

Routine Description:

    Compare and save copy if new USN is largest encountered in search.

Arguments:

    pszUsn1 -- USN sting

    pszUsn2 -- USN sting

Return Value:

    0 if USNs the same.
    1 is pszUsn1 is greater.
    -1 is pszUsn2 is greater.

--*/
{
    DWORD   length1 = strlen( pszUsn1 );
    DWORD   length2 = strlen( pszUsn2 );

    //  if lengths the same, USN compare is just string compare

    if ( length1 == length2 )
    {
        return strcmp( pszUsn1, pszUsn2 );
    }

    else if ( length1 > length2 )
    {
        return 1;
    }
    else
    {
        return -1;
    }
}



BOOL
saveStartUsnToZone(
    IN OUT  PZONE_INFO      pZone,
    IN      HANDLE          pSearchBlob
    )
/*++

Routine Description:

    Save highest USN found in search to zone.

Arguments:

    pZone -- zone searched

    pSearchBlob -- search context

Return Value:

    TRUE if updated zone with new filter USN.
    FALSE if no new USN

--*/
{
    //
    //  if have search USN, save it to zone
    //

    if ( ((PDS_SEARCH)pSearchBlob)->szStartUsn[0] )
    {
        strcpy(
            pZone->szLastUsn,
            ((PDS_SEARCH)pSearchBlob)->szStartUsn );

        DNS_DEBUG( DS, (
            "Saved search USN %s to zone %s\n",
            pZone->szLastUsn,
            pZone->pszZoneName ));
            
        return TRUE;
    }

    ASSERT( !"search blob has blank szStartUsn" );

    return FALSE;
}



BOOL
isDsProcessedName(
    IN      PWSTR           pwsDN
    )
/*++

Routine Description:

    Check if name generated by DS collision or tombstoning.

Arguments:

    pwsDN -- name to check -- this can be a DN or a zone name

    JJW: add flag or something so we know if this is a DN?
    or clone to a separate zone name checking function to avoid
    searching for deleted marker in non-zone nodes

Return Value:

    TRUE if DS processed generated name.
    FALSe otherwise.

--*/
{
    PWSTR pws;

    //
    //  Search for "ds-processed" DS entries with invalid character
    //      - collisions
    //      - tombstones
    //
    //  If not "ds-processed" check and see if the DN starts with a special
    //  string, such as "..Deleted-" for zones that are delete-in-progress.
    //

    if ( wcschr( pwsDN, BAD_DS_NAME_CHAR ) )
    {
        return TRUE;
    }

    // Skip over distinguished attribute name, if present.
    pws = wcschr( pwsDN, L'=' );
    if ( pws )
    {
        ++pws;          // Advance over '=' character in DN.
    }
    else
    {
        pws = pwsDN;    // The name is not a full DN - nothing to skip over.
    }

    if ( wcsncmp( pws, DNS_ZONE_DELETE_MARKER,
         wcslen( DNS_ZONE_DELETE_MARKER ) ) == 0 )
    {
        return TRUE;
    }
    return FALSE;
}



BOOL
readDsDeletedName(
    IN OUT  PWSTR           pwsDN,
    OUT     PWSTR           pwsDeletedName
    )
/*++

Routine Description:

    Check for and extract DS deleted name.

Arguments:

    pwsDN -- name to check;  assumes DN in form "DC=<name>";
        if delete marker found, pwsDN buffer is altered in processing

    ppwsDeletedName -- deleted DS name;  if found

Return Value:

    TRUE if DS deleted name
    FALSE otherwise.

--*/
{
    register PWCHAR     pwch;

    //
    //  deleted name may have "..Deleted-" marker in front of it
    //      - "DC=..Deleted-<name>\0ADEL:GUID"
    //      - "DC=..Deleted-13.com\0ADEL:GUID"
    //
    //  Whistler: Now a deleted zone will look like:
    //  "DC=..Deleted-FFFFFFFF-ZONENAME" where FFFFFFFF is a 8 hex digit tick count
    //
    //  In W2K the DS delete sequence is "\nDEL" where \n is a single 0x0A 
    //  character, but in Whistler the encoding has been changed so the 
    //  encoding is "\0ADEL" which actually has the characters '\', '0', and
    //  'A' followed by "DEL".
    //
    //  A collision will have COL instead of DEL.
    //

    pwch = wcsstr( pwsDN, L"\\0ADEL" );
    if ( !pwch )
    {
        pwch = wcsstr( pwsDN, L"\\\nDEL" );
    }
    if ( !pwch )
    {
        return FALSE;
    }

    //  NULL terminate before sequence

    *pwch = '\0';

    //  Copy the name to the output buffer.
    //  The name may begin with the deleted marker, which must
    //  be skipped over if present.

    if ( ( pwsDN = wcschr( pwsDN, L'=' ) ) == NULL )
    {
        ASSERT( FALSE ); // No "distinguished_attribute_name="?! Strange!!
        return FALSE;
    }

    ++pwsDN; // Skip over the '=' character.

    //
    //  If this zone is in the process of being deleted, the DN will contain
    //  the delete marker, then possible a numeric string for uniqueness, then a
    //  hyphen character. The hyphen marks the end of the delete marker.
    //

    if ( wcsncmp(
            pwsDN,
            DNS_ZONE_DELETE_MARKER,
            wcslen( DNS_ZONE_DELETE_MARKER ) ) == 0 )
    {
        pwsDN = wcschr( pwsDN, L'-' );      //  Skip to end of marker.
        if ( pwsDN )
        {
            ++pwsDN;                        //  Jump over the hyphen character.
        }
    }

    if ( pwsDN )
    {
        wcscpy( pwsDeletedName, pwsDN );
    }
    else
    {
        *pwsDeletedName = L'\0';
    }

    return TRUE;
} // readDsDeletedName




#if 0
VOID
saveUsnIfHigher(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PCHAR           pszUsn
    )
/*++

Routine Description:

    Compare and save copy if new USN is largest encountered in search.

Arguments:

    pSearchBlob -- search blob with currently highest USN

    pszUsn -- current USN to check

Return Value:

    None.

--*/
{
    DWORD   length = strlen( pszUsn );
    DWORD   i;

    //
    //  since we must put up with the abject ability of getting these
    //  as strings, might as well speed up the compare by checking length
    //  first
    //

    //  common case is USNs in search are same length

    if ( pSearchBlob->dwHighUsnLength == length )
    {
        for ( i=0; i<length; i++ )
        {
            if ( pSearchBlob->szHighUsn[i] > pszUsn[i] )
            {
                return;
            }
            else if ( pSearchBlob->szHighUsn[i] < pszUsn[i] )
            {
                goto Copy;
            }
        }
        //  strings the same (odd)
        return;
    }

    //  current high is longer, hence larger

    if ( pSearchBlob->dwHighUsnLength > length )
    {
        return;
    }

    //  new USN is longer, hence larger

Copy:

    strcpy( pSearchBlob->szHighUsn, pszUsn );
    pSearchBlob->dwHighUsnLength = length;
}
#endif



VOID
buildUpdateFilter(
    OUT     LPSTR       pszFilter,
    IN      LPSTR       pszUsn
    )
/*++

Routine Description:

    Build update search filter.

Arguments:

    pszFilter -- buffer to receive filter string

    pszUsn -- zone USN string at last update

Return Value:

    None.

--*/
{
    INT     i, initialLength;
    CHAR    filterUsn[ MAX_USN_LENGTH ];

    //  for filter need "uSNChanged>=" DS does not support "uSNChanged>"
    //  so must increment the USN at last read, so we don't keep

    //  handle empty string case, make "0" USN

    if ( pszUsn[ 0 ] == '\0' )
    {
        filterUsn[ 0 ] = '0';
        filterUsn[ 1 ] = '\0';
    }
    else
    {
        strcpy( filterUsn, pszUsn );
    }

    initialLength = i = strlen( filterUsn );

    while ( i-- )
    {
        if ( filterUsn[ i ] < '9' )
        {
            filterUsn[ i ]++;
            break;
        }
        filterUsn[ i ] = '0';
        continue;
    }

    //
    //  If USN was all nines, then add another zero and set the first
    //  character to "1". Example: 999 => 1000
    //

    if ( i < 0 )
    {
        filterUsn[ 0 ] = '1';
        filterUsn[ initialLength ] = '0';
        filterUsn[ initialLength + 1 ] = '\0';
    }

    //  build filter condition

#if 1

    //
    //  Filter on object category and USN. BrettSh tells me that this is
    //  the most DS-friendly way to perform this search.
    //

    strcpy( pszFilter, "(&(objectCategory=dnsNode)(uSNChanged>=" );
    strcat( pszFilter, filterUsn );
    strcat( pszFilter, "))" );

#else

    //
    //  Filter on USN only.
    //

    strcpy( pszFilter, "uSNChanged>=" );
    strcat( pszFilter, filterUsn );

#endif

    DNS_DEBUG( DS, (
        "Built update filter %s\n"
        "    from USN = %s\n",
        pszFilter,
        pszUsn ));
}



VOID
buildTombstoneFilter(
    OUT     PWSTR       pwsFilter
    )
/*++

Routine Description:

    Build tombstone search filter.

Arguments:

    pszFilter -- buffer to receive filter string

Return Value:

    None.

--*/
{
    wcscpy( pwsFilter, L"dnsTombstone=TRUE" );

    DNS_DEBUG( DS, (
        "Built tombstone filter %S\n",
        pwsFilter ));
}



PWSTR
DS_CreateZoneDsName(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Allocate and create zone's DS name

Arguments:

    pszZoneName -- zone FQDN

Return Value:

    Zone DN if successful.
    NULL on error.

--*/
{
    DBG_FN( "DS_CreateZoneDsName" )

    DNS_STATUS      status;
    PWSTR           pwszzoneName;
    PWSTR           pwszzoneDN;
    WCHAR           wszbuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
    int             len;

    //
    //  If zone already has DN, do nothing.
    //

    if ( pZone->pwszZoneDN )
    {
        ASSERT( pZone->pwszZoneDN == NULL );
        return NULL;
    }

    //
    //  Allocate zone name buffer.
    //

    DNS_DEBUG( DS, ( "%s: for %s\n", pZone->pszZoneName, fn ));

    if ( IS_ZONE_CACHE( pZone ) )
    {
        pwszzoneName = DS_CACHE_ZONE_NAME;
    }
    else
    {
        UTF8_TO_WC (pZone->pszZoneName, wszbuf, DNS_MAX_NAME_BUFFER_LENGTH);
        pwszzoneName = wszbuf;
    }

    len = g_AppendZoneLength + (wcslen(pwszzoneName) + 1) * sizeof(WCHAR);
    pwszzoneDN = (PWCHAR) ALLOC_TAGHEAP( len, MEMTAG_DS_DN );
    IF_NOMEM( !pwszzoneDN )
    {
        return NULL;
    }

    //
    //  Compose and return DN of zone object.
    //

    status = StringCbPrintfW(
                pwszzoneDN,
                len,
                L"DC=%s,%s",
                pwszzoneName,
                g_pwszDnsContainerDN );
    if ( FAILED( status ) )
    {
        return NULL;
    }

    DNS_DEBUG( DS, (
        "%s: built DN\n  %S\n", fn,
        pwszzoneDN ));
    return pwszzoneDN;
}   //  DS_CreateZoneDsName



DNS_STATUS
Ds_SetZoneDp(
    IN      PZONE_INFO          pZone,
    IN      PDNS_DP_INFO        pDpInfo,
    IN      BOOL                fUseTempDsName
    )
/*++

Routine Description:

    Set the zone to be in a directory partition partition.

    This function should be called during load, before any other
    operations are done on the zone, and before it's available for
    RPC enumeration.

    If the zone does not have a DN yet, a default DN is created
    for the zone in the naming context.

Arguments:

    pZone -- zone

    pDpInfo -- info of directory partition this zone is located in

    fUseTempDsName -- when formulating the new DN of the zone,
        prepend a temp string starting with ".." - this is used when 
        moving a zone between partitions so that the in-progress 
        copy of the zone is not mistakenly picked up as a real zone; the 
        ".." zone is renamed later

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "Ds_SetZoneDp" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            flocked = FALSE;
    LONG            newCount;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  Lock the zone and update parameters.
    //

    Zone_UpdateLock( pZone );
    flocked = TRUE;

    //
    //  Re-create the zone's DN. 
    //

    if ( pDpInfo && pDpInfo->pwszDpDn )
    {
        PWSTR   pwszzoneDN;
        WCHAR   wszbuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
        int     len;
        WCHAR    wsztempbuf[ 100 ] = L"";

        if ( IS_ZONE_ROOTHINTS( pZone ) )
        {
            wcscpy( wszbuf, DS_CACHE_ZONE_NAME );
        }
        else
        {
            UTF8_TO_WC( pZone->pszZoneName, wszbuf, DNS_MAX_NAME_BUFFER_LENGTH );
        }

        len = ( wcslen( wszbuf ) +
                wcslen( g_pszRelativeDnsFolderPath ) +
                wcslen( pDpInfo->pwszDpDn ) +
                40 +    //  pad for optional .. prefix
                20 ) *  //  pad for distinguished attr
                sizeof( WCHAR ),

        pwszzoneDN = ( PWSTR ) ALLOC_TAGHEAP( len, MEMTAG_DS_DN );
        IF_NOMEM( !pwszzoneDN )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        if ( fUseTempDsName )
        {
            //  Use time and tick count to generate something nice and random.
            status = StringCchPrintfW(
                            wsztempbuf,
                            sizeofarray( wsztempbuf ),
                            DNS_ZONE_IN_PROGRESS_MARKER L"-%08X%08X-",
                            time( NULL ),
                            GetTickCount() );
            if ( FAILED( status ) )
            {
                goto Done;
            }
        }

        status = StringCbPrintfW(
                        pwszzoneDN,
                        len,
                        L"DC=%s%s,%s%s",
                        wsztempbuf,
                        wszbuf,
                        g_pszRelativeDnsFolderPath,
                        pDpInfo->pwszDpDn );
        if ( FAILED( status ) )
        {
            goto Done;
        }

        Timeout_Free( pZone->pwszZoneDN );
        pZone->pwszZoneDN = pwszzoneDN;
    }

    //
    //  Adjust DP zone counts: must increment the new DP zone count and
    //  decrement the old zone count. Note: legacy counting is not supported
    //  at this point.
    //

    if ( pZone->pDpInfo != pDpInfo )
    {
        if ( pZone->pDpInfo )
        {
            newCount = InterlockedDecrement(
                            &( ZONE_DP( pZone )->liZoneCount ) );
            DNS_DEBUG( DP2, (
                "%s DP count is now %d for old DP %s\n", fn,
                ( int ) newCount,
                ZONE_DP( pZone )->pszDpFqdn ));
            ASSERT( ( int ) newCount >= 0 || pZone->pDpInfo == g_pLegacyDp );
        }
        if ( pDpInfo )
        {
            newCount = InterlockedIncrement( &pDpInfo->liZoneCount );
            DNS_DEBUG( DP2, (
                "%s DP count is now %d for new DP %s\n", fn,
                ( int ) newCount,
                pDpInfo->pszDpFqdn ));
        }
    }

    //
    //  Set the zone to point to the new DP.
    //

    pZone->pDpInfo = pDpInfo;

    Done:

    if ( flocked )
    {
        Zone_UpdateUnlock( pZone );
    }

    DNS_DEBUG( RPC, (
        "%s( %s ) returning %d\n"
        "    DP =        %p -> \"%s\"\n"
        "    zone DN =   %S\n", fn,
        pZone->pszZoneName,
        status,
        pDpInfo,
        pDpInfo ? pDpInfo->pszDpFqdn : "NULL",
        pZone->pwszZoneDN ));

    return status;
}   //  Ds_SetZoneDp



DNS_STATUS
buildNodeNameFromLdapMessage(
    OUT     PWSTR           pwszNodeDN,
    IN      PLDAPMessage    pNodeObject
    )
/*++

Routine Description:

    Build node name from object DN.

Arguments:

    pszNodeDN -- buffer to hold DN


    pNodeObject -- DS object for node returned by ldap

Return Value:

    ERROR_SUCCESS or failure code.

--*/
{
    DNS_STATUS  status      = ERROR_SUCCESS;
    PWSTR       wdn = NULL;

    //
    //  build DS name for this node name
    //

    wdn = ldap_get_dn( pServerLdap, pNodeObject );

    //
    //  see if we're ok
    //
    if ( !wdn )
    {
        status = LdapGetLastError();

        DNS_PRINT((
            "Error <%lu>: cannot get object's DN\n",
            status ));

        status = Ds_ErrorHandler( status, NULL, pServerLdap, 0 );

        return status;
    }

    //
    //  copy to OUT param
    //

    wcscpy( pwszNodeDN, wdn );

    DNS_DEBUG( DS, (
        "Built DN = <%S> from ldap object\n",
        pwszNodeDN ));

    //
    //  cleanup
    //

    if ( wdn )
    {
        ldap_memfree( wdn );
    }

    return status;
}



DNS_STATUS
getCurrentUsn(
    OUT     PCHAR           pUsnBuf
    )
/*++

Routine Description:

    Get current USN.

Arguments:

    pUsn -- addr to receive USN

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR  *        ppvalUsn = NULL;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry;
    DWORD           searchTime;

    PWCHAR          arrayAttributes[] =
    {
        g_szHighestCommittedUsnAttribute,
        NULL
    };

    //
    //  Make sure buffer isn't junk if we fail.
    //

    *pUsnBuf = '\0';

    //
    //  open DS if not open
    //

    if ( !pServerLdap )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  Get search result for base object with USN attribute.
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                NULL,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                arrayAttributes,
                0,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: failed to get server USN. %S\n",
            status,
            ldap_err2string(status) ));
        ASSERT( !"ldap_search_ext_s failed for USN" );
        status = Ds_ErrorHandler( status, NULL, pServerLdap, 0 );
        goto Done;
    }

    pentry = ldap_first_entry(
                    pServerLdap,
                    presultMsg );
    if ( !pentry )
    {
        DNS_DEBUG( DS, (
            "Error: failed to get server USN. Entry does not exist!\n." ));
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( !"ldap_first_entry returned NULL for USN result" );
        goto Done;
    }

    //
    //  Retrieve USN attribute value.
    //

    ppvalUsn = ldap_get_values(
                    pServerLdap,
                    pentry,
                    g_szHighestCommittedUsnAttribute );

    if ( !ppvalUsn || !ppvalUsn[0] )
    {
        DNS_PRINT((
            "ERROR: <%S> attribute no-exist\n"
            "    root domain  = %S\n"
            "    ppvalUsn     = %p\n"
            "    ppvalUsn[0]  = %S\n",
            g_szHighestCommittedUsnAttribute,
            DSEAttributes[I_DSE_DEF_NC].pszAttrVal,
            ppvalUsn,
            ppvalUsn ? ppvalUsn[0] : NULL ));

        ASSERT( !"retrieved empty USN attribute value" );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    DNS_DEBUG( ANY, (
        "Start USN val ptr = %p\n"
        "Start USN val = %S\n",
        ppvalUsn[ 0 ],
        ppvalUsn[ 0 ] ));

    //  copy USN to buffer

    WC_TO_UTF8( ppvalUsn[ 0 ], pUsnBuf, MAX_USN_LENGTH );

Done:

    if ( ppvalUsn )
    {
        ldap_value_free( ppvalUsn );
    }
    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }

    DNS_DEBUG( DS, (
        "getCurrentUsn: returning %d\n",
        status ) );

    //  This function should rarely fail.
    ASSERT( status == ERROR_SUCCESS );

    return status;
}



PDS_RECORD
allocateDS_RECORD(
    IN      PDS_RECORD  pDsRecord
    )
/*++

Routine Description:

    allocate copy of DS record.

Arguments:

    pDsRecord -- existing record to copy

Return Value:

    Ptr to copy of record.
    NULL on failure.

--*/
{
    PDS_RECORD  precordCopy;
    WORD        length = sizeof(DS_RECORD) + pDsRecord->wDataLength;

    precordCopy = (PDS_RECORD) ALLOC_TAGHEAP( length, MEMTAG_DS_RECORD );
    IF_NOMEM( !precordCopy )
    {
        return NULL;
    }
    RtlCopyMemory(
        precordCopy,
        pDsRecord,
        length );

    return precordCopy;
}




//
// Functions to process GeneralizedTime for DS time values (whenChanged kinda strings)
// Mostly taken & sometimes modified from \nt\private\ds\src\dsamain\src\dsatools.c
//


//
// MemAtoi - takes a pointer to a non null terminated string representing
// an ascii number  and a character count and returns an integer
//

int MemAtoi(BYTE *pb, ULONG cb)
{
#if ( 1)
    int res = 0;
    int fNeg = FALSE;

    if ( *pb == '-') {
        fNeg = TRUE;
        pb++;
    }
    while (cb--) {
        res *= 10;
        res += *pb - '0';
        pb++;
    }
    return (fNeg ? -res : res);
#else
    char ach[20];
    if ( cb >= 20)
        return(INT_MAX);
    memcpy(ach, pb, cb);
    ach[cb] = 0;

    return atoi(ach);
#endif
}





DNS_STATUS
GeneralizedTimeStringToValue(
    IN      LPSTR           szTime,
    OUT     PLONGLONG       pllTime
    )
/*++
Function   : GeneralizedTimeStringToValue
Description: converts Generalized time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    SYSTEMTIME  tmConvert;
    FILETIME    fileTime;
    LONGLONG    tempTime;
    ULONG       cb;
    int         sign    = 1;
    DWORD       timeDifference = 0;
    char *      pLastChar;
    int         len=0;

    //
    // param sanity
    //

    if ( !szTime || !pllTime )
    {
        return STATUS_INVALID_PARAMETER;
    }


    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    len = strlen(szTime);
    pLastChar = szTime + len - 1;

    if( len < 15 || szTime[14] != '.')
    {
        return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(&tmConvert, 0, sizeof(SYSTEMTIME));
    *pllTime = 0;

    // Set up and convert all time fields

    // year field
    cb=4;
    tmConvert.wYear = (USHORT)MemAtoi(szTime, cb) ;
    szTime += cb;
    // month field
    tmConvert.wMonth = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // day of month field
    tmConvert.wDay = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // hours
    tmConvert.wHour = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // minutes
    tmConvert.wMinute = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // seconds
    tmConvert.wSecond = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    //  Ignore the 1/10 seconds part of GENERALISED_TIME_STRING
    szTime += 2;


    // Treat the possible deferential, if any
    if ( szTime <= pLastChar) {
        switch (*szTime++) {

          case '-':               // negative differential - fall through
            sign = -1;
          case '+':               // positive differential

            // Must have at least 4 more chars in string
            // starting at pb

            if ( (szTime+3) > pLastChar) {
                // not enough characters in string
                DNS_DEBUG(DS, ("Not enough characters for differential\n"));
                return STATUS_INVALID_PARAMETER;
            }

            // hours (convert to seconds)
            timeDifference = (MemAtoi(szTime, (cb=2))* 3600);
            szTime += cb;

            // minutes (convert to seconds)
            timeDifference  += (MemAtoi(szTime, (cb=2)) * 60);
            szTime += cb;
            break;


          case 'Z':               // no differential
          default:
            break;
        }
    }

    if ( SystemTimeToFileTime(&tmConvert, &fileTime)) {
       *pllTime = (LONGLONG) fileTime.dwLowDateTime;
       tempTime = (LONGLONG) fileTime.dwHighDateTime;
       *pllTime |= (tempTime << 32);
       // this is 100ns blocks since 1601. Now convert to
       // seconds
       *pllTime = *pllTime/(10*1000*1000L);
    }
    else {
       return GetLastError();
    }


    if ( timeDifference )
    {
        // add/subtract the time difference
        switch (sign)
        {
        case 1:
            // We assume that adding in a timeDifference will never overflow
            // (since generalised time strings allow for only 4 year digits, our
            // maximum date is December 31, 9999 at 23:59.  Our maximum
            // difference is 99 hours and 99 minutes.  So, it won't wrap)
            *pllTime += timeDifference;
            break;

        case -1:
            if(*pllTime < timeDifference)
            {
                // differential took us back before the beginning of the world.
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                *pllTime -= timeDifference;
            }
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    return status;
}




//
//  Generic search routines
//

VOID
Ds_InitializeSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Initialize search.

Arguments:

    pSearchBlob -- search context

Return Value:

    None

--*/
{
    RtlZeroMemory(
        pSearchBlob,
        sizeof(DS_SEARCH) );
}



VOID
Ds_CleanupSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Cleanup search blob.
    Specifically free allocated ldap data.

    Note that this routine specifically MUST NOT clean out static data.
    Several data fields may be used after the search is completed.

Arguments:

    pSearchBlob -- ptr to search blob to cleanup

Return Value:

    None

--*/
{
    if ( !pSearchBlob )
    {
        return;
    }

    //  if outstanding record data, delete it

    if ( pSearchBlob->ppBerval )
    {
        DNS_DEBUG( DS, (
            "WARNING: DS search blob free with existing record berval\n" ));
        ldap_value_free_len( pSearchBlob->ppBerval );
        pSearchBlob->ppBerval = NULL;
    }

    //  if search terminated by user, may have current result message

    if ( pSearchBlob->pResultMessage )
    {
        DNS_DEBUG( DS, (
            "WARNING: DS search blob free with existing result message\n" ));
        ldap_msgfree( pSearchBlob->pResultMessage );
        pSearchBlob->pResultMessage = NULL;
    }

    if ( pSearchBlob->pSearchBlock )
    {
        ldap_search_abandon_page(
            pServerLdap,
            pSearchBlob->pSearchBlock );
        pSearchBlob->pSearchBlock = NULL;
    }

    return;
}



DNS_STATUS
Ds_GetNextMessageInSearch(
    IN OUT  PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Find next node in ldap search.

    This function simply wraps up the LDAP paged results search calls.

Arguments:

    pSearchBlob -- addr of current search context

    ppMessage   -- addr to recv next LDAP message in search

Return Value:

    ERROR_SUCCESS if successful and returning next message.
    DNSSRV_STATUS_DS_SEARCH_COMPLETE if succesfful complete search.
    Error code on failure.

--*/
{
    PLDAPMessage    pmessage;
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           searchTime;

    DNS_DEBUG( DS2, ( "Ds_GetNextMessageInSearch()\n" ));

    ASSERT( pSearchBlob );

    //
    //  keep total counts during search
    //

    pSearchBlob->dwTotalNodes++;
    pSearchBlob->dwTotalRecords += pSearchBlob->dwRecordCount;

    if ( pSearchBlob->dwTombstoneVersion )
    {
        pSearchBlob->dwTotalTombstones++;
    }

    //
    //  get message (next object) found in search
    //
    //  for caller's coding simplicity allow this to retrieve either
    //  next message or first message
    //

    pmessage = pSearchBlob->pNodeMessage;

    //  if existing result page, try to get next message in current page

    if ( pmessage )
    {
        pmessage = ldap_next_entry(
                        pServerLdap,
                        pmessage );

    }

    //  otherwise get first message in next page of results

    if ( !pmessage )
    {
        DWORD   count;

        if ( pSearchBlob->pResultMessage )
        {
            ldap_msgfree( pSearchBlob->pResultMessage );
            pSearchBlob->pResultMessage = NULL;
        }
        DNS_DEBUG( DS2, (
            "ldap_get_next_page_s():\n"
            "    pServerLdap  = %p\n"
            "    pSearchBlock = %p\n"
            "    %p\n"
            "    page size    = %d\n"
            "    pcount       = %p\n"
            "    presult      = %p\n",
            pServerLdap,
            pSearchBlob->pSearchBlock,
            NULL,
            DNS_LDAP_PAGE_SIZE,
            & count,
            & pSearchBlob->pResultMessage ));

        DS_SEARCH_START( searchTime );

        status = ldap_get_next_page_s(
                    pServerLdap,
                    pSearchBlob->pSearchBlock,
                    &g_LdapTimeout,
                    DNS_LDAP_PAGE_SIZE,
                    & count,
                    & pSearchBlob->pResultMessage );

        DS_SEARCH_STOP( searchTime );

        DNS_DEBUG( DS2, (
            "Got paged result message at %p\n"
            "    count = %d\n"
            "    status = %d, (%p)\n",
            pSearchBlob->pResultMessage,
            count,
            status, status ));

        if ( status != ERROR_SUCCESS )
        {
            pSearchBlob->LastError = status;

            if ( status == LDAP_NO_RESULTS_RETURNED ||
                 status == LDAP_MORE_RESULTS_TO_RETURN )
            {
                ASSERT( pSearchBlob->pResultMessage == NULL );
                pSearchBlob->pResultMessage = NULL;
                status = DNSSRV_STATUS_DS_SEARCH_COMPLETE;
                goto SearchEnd;
            }
            else
            {
                ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
                DNS_DEBUG( ANY, (
                    "DS Search error: %d (%p)\n",
                    status, status ));

                //
                // Jeff W: I have commented out this assert. I found this scenario:
                // Thread A is iterating through a large search result.
                // Thread B deletes some DS records referenced in that
                //   search result.
                // Thread A may hit this assert with error code 1.
                //
                // ASSERT( FALSE );

                goto SearchEnd;
            }
        }
        else
        {
            ASSERT( pSearchBlob->pResultMessage );
            pmessage = ldap_first_entry(
                            pServerLdap,
                            pSearchBlob->pResultMessage );
        }
    }

    //  should catch no message above
    //  this is ok, since the last message could be valid empty.

    if ( ! pmessage )
    {
        status = DNSSRV_STATUS_DS_SEARCH_COMPLETE;
        goto SearchEnd;
    }

    //  save new message to search blob

    pSearchBlob->pNodeMessage = pmessage;

    return ERROR_SUCCESS;


SearchEnd:

    pSearchBlob->pNodeMessage = NULL;

    Ds_CleanupSearchBlob( pSearchBlob );

    DNS_DEBUG( DS, (
        "End of DS search ... status = %d, (%p)\n"
        "    zone             %s\n"
        "    start USN        %s\n"
        "    time             %p %p\n"
        "    flag             %p\n"
        "    high version     %d\n"
        "    total nodes      %d\n"
        "    total tombstones %d\n"
        "    total records    %d\n",
        status, status,
        pSearchBlob->pZone ? pSearchBlob->pZone->pszZoneName : NULL,
        pSearchBlob->szStartUsn,
        (DWORD) (pSearchBlob->SearchTime >> 32),    (DWORD)pSearchBlob->SearchTime,
        pSearchBlob->dwSearchFlag,
        pSearchBlob->dwHighestVersion,
        pSearchBlob->dwTotalNodes,
        pSearchBlob->dwTotalTombstones,
        pSearchBlob->dwTotalRecords ));

    if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
    {
        return status;
    }

    //
    //  DEVNOTE-DCR: 454355 (Jim sez "this is boring")
    //

    return Ds_ErrorHandler(
                status,
                pSearchBlob->pZone ? pSearchBlob->pZone->pwszZoneDN : NULL,
                pServerLdap,
                0 );
}



//
//  Zone search
//

DNS_STATUS
checkTombstoneForDelete(
    IN      PDS_SEARCH          pSearchBlob,
    IN      PLDAPMessage        pNodeObject,
    IN      PDS_RECORD          pdsRecord
    )
/*++

Routine Description:

    Check tombstone for delete.
    Do actual delete if tombstone has aged enough to have propagated everywhere.

Arguments:

    pSearchBlob -- addr of current search context

    pNodeMessage -- LDAP message for DNS object to check for tombstone

    pdsRecord -- tombstone record

Return Value:

    ERROR_SUCCESS if successful check (whether deleted tombstone or not)
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    CHAR        sznodeName[ DNS_MAX_NAME_LENGTH ];
    WCHAR       wsznodeDN[ MAX_DN_PATH ];

    //
    //  if no search time, get it
    //      - subtract tombstone timeout interval to get time less than
    //      which tombstones should be discarded
    //      - note, interval is in seconds, Win32 file time is in 100ns
    //      intervals so multiply interval by 10,000,000 to get in file time
    //

    if ( pSearchBlob->SearchTime == 0 )
    {
        LONGLONG    tombInterval;

        tombInterval = (LONGLONG) SrvCfg_dwDsTombstoneInterval;
        tombInterval *= 10000000;

        GetSystemTimeAsFileTime( (PFILETIME) &pSearchBlob->SearchTime );

        pSearchBlob->TombstoneExpireTime = pSearchBlob->SearchTime - tombInterval;
    }

    //  compare (this is LONGLONG (64bit) compare)

    if ( pSearchBlob->TombstoneExpireTime < pdsRecord->Data.Tombstone.EntombedTime )
    {
        DNS_DEBUG( DS, (
            "DS tombstone node still within tombstone expire interval\n"
            "    tombstone expire %I64d\n"
            "    tomestone time   %I64d\n"
            "    search time      %I64d\n",
            pSearchBlob->TombstoneExpireTime,
            pdsRecord->Data.Tombstone.EntombedTime,
            pSearchBlob->SearchTime ));

        //  tombstone can happen after search starts, so this is no good
        //ASSERT( pSearchBlob->SearchTime > pdsRecord->Data.Tombstone.EntombedTime );

        return ERROR_SUCCESS;
    }

    //
    //  build DS name for this node name
    //

    status = buildNodeNameFromLdapMessage(
                    wsznodeDN,
                    pNodeObject );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        DNS_PRINT(( "ERROR: unable to build name of tombstone!\n" ));
        return status;
    }

    DNS_DEBUG( DS, (
        "DS node <%S> tombstoned at %I64d is ready for final delete\n"
        "    tombstone timeout at %I64d\n",
        wsznodeDN,
        pdsRecord->Data.Tombstone.EntombedTime,
        pSearchBlob->SearchTime ));

    status = Ds_DeleteDn(
                 pServerLdap,
                 wsznodeDN,
                 FALSE );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Failed deleting node <%S> in DS zone\n"
            "    ldap_delete_s() status %d (%p)\n",
            wsznodeDN,
            status, status ));
    }
    else
    {
        DNS_DEBUG( DS, (
            "Successful delete of tombstone <%S> node\n",
            wsznodeDN ));
        STAT_INC( DsStats.DsNodesDeleted );
    }

    return status;
}



BOOL
readDsRecordsAndCheckForTombstone(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN OUT  PDB_NODE        pNode       OPTIONAL
    )
/*++

Routine Description:

    Check if DS node is DNS tombstone.

Arguments:

    pSearchBlob  -- search blob

Return Value:

    TRUE    -- if tombstone
    FALSE   -- otherwise

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP_BERVAL *  ppvals = pSearchBlob->ppBerval;
    DWORD           serial = 0;
    PDS_RECORD      pdsRecord;
    PWSTR           pwszdn;

    DNS_DEBUG( DS2, (
        "readDsRecordsAndCheckForTombstone()\n" ));

    //  free any previous record data in search

    if ( ppvals )
    {
        ldap_value_free_len( ppvals );
        pSearchBlob->ppBerval = NULL;
    }

    //
    //  read DNS record attribute data
    //

    ppvals = ldap_get_values_len(
                    pServerLdap,
                    (PLDAPMessage) pSearchBlob->pNodeMessage,
                    DSATTR_DNSRECORD );
    IF_DEBUG( DS )
    {
        Dbg_DsBervalArray(
            "DS record berval from database:\n",
            ppvals,
            I_DSATTR_DNSRECORD );
    }

    //
    //  no record data is a bug (should have records or tombstone)
    //  set record for delete with tombstone
    //

    if ( !ppvals  ||  !ppvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: readDsRecordsAndCheckForTombstone() encountered object with no record data\n" ));

        //  we'll have this condition until all old nodes are culled
        //ASSERT( FALSE );

        pSearchBlob->dwTombstoneVersion = 1;
        pSearchBlob->dwNodeVersion = 1;

        pwszdn = ldap_get_dn(
                        pServerLdap,
                        pSearchBlob->pNodeMessage );
        if ( !pwszdn )
        {
            ASSERT( pwszdn );
            goto NoRecords;
        }
        
        deleteNodeFromDs(
            NULL,
            pSearchBlob->pZone,
            pwszdn,
            0 );            //  default serial number

        DNS_DEBUG( DS2, (
            "readDsRecordsAndCheckForTombstone() deleted node %S\n",
            pwszdn ));

        ldap_memfree( pwszdn );
        goto NoRecords;
    }

    //
    //  get first record
    //      - save it's version (since single attribute, this is current
    //          version for all the data)
    //      - can then check if tombstone
    //

    pdsRecord = ( PDS_RECORD ) ( ppvals[0]->bv_val );

    pSearchBlob->dwNodeVersion = serial = pdsRecord->dwSerial;
    if ( serial > pSearchBlob->dwHighestVersion )
    {
        pSearchBlob->dwHighestVersion = serial;
    }

    //
    //  check for tombstone
    //

    if ( pdsRecord->wType == DNSDS_TOMBSTONE_TYPE )
    {
        ASSERT( ppvals[1] == NULL );
        DNS_DEBUG( DS2, (
            "readDsRecordsAndCheckForTombstone() encountered tombstone\n" ));

        STAT_INC( DsStats.DsTombstonesRead );
        pSearchBlob->dwTombstoneVersion = serial;

        checkTombstoneForDelete(
            pSearchBlob,
            pSearchBlob->pNodeMessage,
            pdsRecord );
        goto NoRecords;
    }

    //
    //  valid records, not a tombstone
    //

    pSearchBlob->ppBerval = ppvals;
    pSearchBlob->dwTombstoneVersion = 0;
    return FALSE;

NoRecords:

    if ( ppvals )
    {
        ldap_value_free_len( ppvals );
        pSearchBlob->ppBerval = NULL;
    }
    pSearchBlob->dwRecordCount = 0;
    pSearchBlob->pRecords = NULL;
    return TRUE;
}



DNS_STATUS
buildRecordsFromDsRecords(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next record at domain node.

    DEVNOTE-DCR: 454345 - Remove pNode argument and write second function
        to install record into node and do data ranking.

Arguments:

    pSearchBlob -- search blob

    pNode -- node records are at

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PLDAP_BERVAL *  ppvals = pSearchBlob->ppBerval;
    PDS_RECORD      pdsRecord;
    DWORD           serial = 0;
    DWORD           count;
    INT             i;
    INT             length;
    PDB_RECORD      prrFirst;
    PDB_RECORD      prr;

    DNS_DEBUG( DS2, ( "buildRecordsFromDsRecords()\n" ));

    //
    //  if not given existing berval, then must initiate attribute read
    //

    if ( !ppvals )
    {
        if ( readDsRecordsAndCheckForTombstone(pSearchBlob, pNode) )
        {
            //  tombstone -- no records
            ASSERT( pSearchBlob->dwRecordCount == 0 );
            ASSERT( pSearchBlob->pRecords == NULL );
            pSearchBlob->pRecords = NULL;
            return ERROR_SUCCESS;
        }
        ppvals = pSearchBlob->ppBerval;
        ASSERT( ppvals );
    }

    //
    //  get first record
    //      - save it's version (since single attribute, this is current
    //          version for all the data)
    //      - can then check if tombstone
    //

    prrFirst = NULL;
    count = 0;
    i = (-1);

    while ( ppvals[++i] )
    {
        pdsRecord = (PDS_RECORD) ppvals[i]->bv_val;
        length = ppvals[i]->bv_len - SIZEOF_DS_RECORD_HEADER;

        if ( length < 0  ||  (INT)pdsRecord->wDataLength != length )
        {
            //
            //  DEVNOTE-LOG: log ignoring corrupted record
            //

            DNS_DEBUG( ANY, (
                "ERROR: read corrupted record (invalid length) from DS at node %s\n"
                "    length (ppval length - header len) = %d\n"
                "    wDataLength = %d\n"
                "    wType = %d\n",
                pNode->szLabel,
                length,
                pdsRecord->wDataLength,
                pdsRecord->wType ));
            ASSERT( FALSE );
            continue;
        }
        if ( pdsRecord->wType == DNS_TYPE_ZERO )
        {
            DNS_DEBUG( DS, (
                "Tombstone record read at node %s\n"
                "    ignoring, no record built\n",
                pNode->szLabel ));
            continue;
        }

        prr = Ds_CreateRecordFromDsRecord(
                    pSearchBlob->pZone,
                    pNode,
                    pdsRecord );
        if ( !prr )
        {
            //
            //  DEVNOTE-LOG: log ignoring unkwnown or corrupted record
            //

            DNS_DEBUG( ANY, (
                "ERROR: building record type %d from DS record\n"
                "    at node %s\n",
                pdsRecord->wType,
                pNode->szLabel ));
            continue;
        }
        prrFirst = RR_ListInsertInOrder(
                        prrFirst,
                        prr );
        count++;
    }

    STAT_ADD( DsStats.DsTotalRecordsRead, count );
    ldap_value_free_len( ppvals );

    pSearchBlob->ppBerval = NULL;
    pSearchBlob->dwRecordCount = count;
    pSearchBlob->pRecords = prrFirst;

    return ERROR_SUCCESS;
}



DNS_STATUS
Ds_StartDsZoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwSearchFlag
    )
/*++

Routine Description:

    Do LDAP search on zone.

Arguments:

    pZone -- zone found

    dwSearchFlag -- type of search to do on node

    pSearchBlob -- ptr to search blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPSearch     psearch = NULL;
    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        NULL
    };
    PWCHAR          pwszfilter;
    CHAR            szfilter[ LDAP_FILTER_SEARCH_LENGTH ];
    WCHAR           wszfilter[ LDAP_FILTER_SEARCH_LENGTH ];
    ULONG           data = 1;
    INT             resultUsnCompare;
    DWORD           searchTime;


    DNS_DEBUG( DS2, (
        "Ds_StartDsZoneSearch()\n"
        "    zone         = %S\n"
        "    search flag  = %p\n",
        (LPSTR) pZone->pwszZoneDN,
        dwSearchFlag ));

    ASSERT( pZone->pwszZoneDN );

    //
    //  init search blob
    //  get USN before search start
    //

    Ds_InitializeSearchBlob( pSearchBlob );

    //
    //  get current USN before starting search
    //

    status = getCurrentUsn( pSearchBlob->szStartUsn );
    if ( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: cannot get current USN\n",
            status ));
        goto Failed;
    }
    ASSERT( pSearchBlob->szStartUsn[0] );

    //
    //  DS names are relative to zone root
    //

    pSearchBlob->dwLookupFlag = LOOKUP_NAME_RELATIVE;

    //
    //  determine search type
    //      - for update filter above last version
    //      - for delete get everything
    //      - for load get everything;  set lookup flag to use load zone tree
    //

    //
    //  update search
    //      - if USN same as last, then skip
    //      - build USN changed filter
    //

    if ( dwSearchFlag == DNSDS_SEARCH_UPDATES )
    {
        resultUsnCompare = usnCompare( pSearchBlob->szStartUsn, pZone->szLastUsn );

        if ( resultUsnCompare < 0 && pSearchBlob->szStartUsn[0] )
        {
            DNS_DEBUG( DS2, (
                "Skip update search on zone %S\n"
                "    current USN %s < zone search USN %s\n"
                "    NOTE: current USN should be only 1 behind zone search\n",
                (LPSTR) pZone->pwszZoneDN,
                pSearchBlob->szStartUsn,
                pZone->szLastUsn ));
            return( DNSSRV_STATUS_DS_SEARCH_COMPLETE );
        }

        buildUpdateFilter(
            szfilter,
            pZone->szLastUsn );
        UTF8_TO_WC( szfilter, wszfilter, LDAP_FILTER_SEARCH_LENGTH );
        pwszfilter = wszfilter;
        STAT_INC( DsStats.DsUpdateSearches );

        DNSLOG( DSPOLL, ( 
            "Opening update search in zone %S\n"
            LOG_INDENT "current USN  = %s\n"
            LOG_INDENT "zone USN     = %s\n"
            LOG_INDENT "poll filter  = %S\n",
            pZone->pwsZoneName,
            pSearchBlob->szStartUsn,
            pZone->szLastUsn,
            wszfilter ));
    }

    //
    //  tombstone search
    //      - build tombstone filter
    //

    else if ( dwSearchFlag == DNSDS_SEARCH_TOMBSTONES )
    {
        DNS_DEBUG( DS, ( "Tombstone search\n" ));

        buildTombstoneFilter( wszfilter );
        pwszfilter = wszfilter;
        //STAT_INC( DsStats.TombstoneSearches );
    }

    //
    //  load or delete searches
    //      - no node screening filter
    //      - LOOKUP_LOAD on load search, delete searches operate on current zone
    //

    else
    {
        pwszfilter = g_szDnsNodeFilter;
        if ( dwSearchFlag == DNSDS_SEARCH_LOAD )
        {
            pSearchBlob->dwLookupFlag |= LOOKUP_LOAD;
        }
    }


    //
    //  start zone search
    //

    DNS_DEBUG( DS2, (
        "ldap_search_init_page:\n"
        "    pServerLdap  = %p\n"
        "    zone         = %S\n"
        "    LDAP_SCOPE_ONELEVEL\n"
        "    filter       = %S\n"
        "    NULL\n"                  // no attributes
        "    FALSE\n"
        "    NULL\n"                  // server control
        "    NULL\n"                  // no client controls
        "    0\n"                     // no time limit
        "    size limit   = %d\n"
        "    NULL\n",
        pServerLdap,
        pZone->pwszZoneDN,
        pwszfilter,
        0 ));

    DS_SEARCH_START( searchTime );

    psearch = ldap_search_init_page(
                    pServerLdap,
                    pZone->pwszZoneDN,
                    LDAP_SCOPE_ONELEVEL,
                    pwszfilter,
                    DsTypeAttributeTable,       // no attributes
                    FALSE,
                    ctrls,                      // server ctrls for faster search
                    NULL,                       // no client controls
                    0,                          // use default connection time limit (ldap_opt...)
                    0,
                    NULL );                     // no sort

    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler(
                        LdapGetLastError(),
                        pZone->pwszZoneDN,
                        pServerLdap,
                        0 );
        DNS_DEBUG( ANY, (
            "Error <%lu>: Failed to init search for zone DN %S\n",
            status,
            pZone->pwszZoneDN ));

        ASSERT( status != ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
        }

        goto Failed;
    }

    //
    //  DEVNOTE: "Check for no results if the ldap_search doesn't report it."
    //  That was the original B*GB*G - what does it mean?
    //

    //
    //  setup node search context
    //      - save search result message
    //      - keep ptr to message for current node
    //
    //  return LDAP message for node as node object
    //

    pSearchBlob->pSearchBlock = psearch;
    pSearchBlob->pZone = pZone;
    pSearchBlob->dwSearchFlag = dwSearchFlag;

    DNS_DEBUG( DS2, (
        "Leaving DsSearchZone()\n"
        "    pSearch blob     = %p\n"
        "    pSearch block    = %p\n",
        pSearchBlob,
        pSearchBlob->pSearchBlock ));

    return ERROR_SUCCESS;


Failed:

    if ( psearch )
    {
        ldap_search_abandon_page(
            pServerLdap,
            psearch );
    }
    DNS_DEBUG( ANY, (
        "ERROR: DsSearchZone() failed %d (%p)\n"
        "    zone handle = %S\n",
        status, status,
        pZone->pwszZoneDN ));

    return status;
}



DNS_STATUS
getNextNodeInDsZoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    OUT     PDB_NODE *      ppNode
    )
/*++

Routine Description:

    Find next node in search of DS zone.

    This function simply wraps up a bunch of tasks done whenever we
    are enumerating DS nodes.

    Mainly this avoids duplicate code between zone load and update, but
    also it avoids unnecessary copies of node names and USNs.

Arguments:

    pSearchBlob -- addr of current search context

    ppLdapMessage -- addr to receive ptr to object for node;  when NULL
        search is complete

    ppOwnerNode -- addr to receive ptr to corresponding in memory DNS node

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDB_NODE        pnodeOwner = NULL;
    PDB_NODE        pnodeClosest = NULL;
    PWSTR *         ppvalName = NULL;
    PWSTR           pwsname = NULL;
    DNS_STATUS      status = ERROR_SUCCESS;
    CHAR            szName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNS_DEBUG( DS2, ( "getNextNodeInDsZoneSearch()\n" ));

    ASSERT( pSearchBlob );
    ASSERT( ppNode );


    //
    //  get message (next object) found in search
    //

    status = Ds_GetNextMessageInSearch( pSearchBlob );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
        goto Done;
    }

    //
    //  if delete search, we're done
    //      => no need to find memory node or USN
    //
    //  note, this is still used by root-hints
    //

    if ( pSearchBlob->dwSearchFlag == DNSDS_SEARCH_DELETE )
    {
        goto Done;
    }

    //
    //  read domain name from LDAP message
    //

    STAT_INC( DsStats.DsTotalNodesRead );

    ppvalName = ldap_get_values(
                    pServerLdap,
                    pSearchBlob->pNodeMessage,
                    DSATTR_DC );

    if ( !ppvalName || !(pwsname = ppvalName[0]) )
    {
        DNS_PRINT((
            "ERROR: Container name value is missing for message %p\n",
            pSearchBlob->pNodeMessage ));
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( FALSE );
        goto Done;
    }

    DNS_DEBUG( DS, ( "Found DS node <%S>\n", pwsname ));
    IF_DEBUG( DS )
    {
        PWSTR   dn = ldap_get_dn( pServerLdap, pSearchBlob->pNodeMessage );
        
        DNS_DEBUG( DS, ( "DS node DN: %S\n", dn ));
        ldap_memfree( dn );
    }

    //
    //  eliminate collision "GUIDized" names
    //      - delete them from DS
    //

    if ( isDsProcessedName( pwsname ) )
    {
        PWSTR   pwdn;

        DNS_DEBUG( DS, (
            "Read DS collision name %S\n"
            "    removing from DS\n",
            pwsname ));

        pwdn = ldap_get_dn(
                    pServerLdap,
                    pSearchBlob->pNodeMessage );
        ASSERT( pwdn );

        if ( pwdn )
        {
            status = Ds_DeleteDn(
                        pServerLdap,
                        pwdn,
                        FALSE );
            ldap_memfree ( pwdn );
        }
        goto Done;
    }

    //
    //  extract DNS record attribute
    //  then check for tombstone -- no point in doing node create (below)
    //      if node is tombstone
    //

    readDsRecordsAndCheckForTombstone( pSearchBlob, NULL );

    //
    //  check if serial number name
    //  do after tombstone read, so unused names will eventually be
    //      deleted from DS

    if ( pwsname[0] == '.' )
    {
        if ( wcsncmp( pwsname, L"..SerialNo", 10 ) == 0 )
        {
            DNS_DEBUG( DS, (
                "Skipped DS read of serial name %S\n",
                pwsname ));
            goto Done;
        }
        ASSERT( FALSE );
    }

    //
    //  get node in database
    //      - if tombstone, just find (skip node creation)
    //      - if records, create
    //

    WC_TO_UTF8( pwsname, szName, DNS_MAX_NAME_BUFFER_LENGTH );

    pnodeOwner = Lookup_ZoneNodeFromDotted(
                    pSearchBlob->pZone,
                    szName,
                    0,
                    pSearchBlob->dwLookupFlag,
                    ( pSearchBlob->dwTombstoneVersion )
                        ?   &pnodeClosest               // find if tombstone
                        :  NULL,                       // otherwise create
                    &status );


    //  build RRs from DS records

    if ( pnodeOwner )
    {
        status = buildRecordsFromDsRecords(
                    pSearchBlob,
                    pnodeOwner );
    }

    //  tombstone node AND and memory node does NOT already exist

    else if ( pSearchBlob->dwTombstoneVersion )
    {
        DNS_DEBUG( DS2, (
            "Skipping DS tombstone for node not already in memory\n" ));
        ASSERT( pSearchBlob->dwRecordCount == 0 );
        ASSERT( pSearchBlob->pRecords == NULL );
        ASSERT( status == DNS_ERROR_NAME_DOES_NOT_EXIST );
        status = ERROR_SUCCESS;
    }

    //  node creation error
    //
    //  DEVNOTE-DCR: 454348 - Delete or flag error nodes.
    //
    //  DEVNOTE-LOG: special event for invalid name
    //      status == DNS_ERROR_INVALID_NAME
    //

    else
    {
        PCHAR   argArray[2];

        DNS_PRINT((
            "ERROR: creating node <%S> in zone %s\n"
            "    status = %p (%d)\n",
            pwsname,
            pSearchBlob->pZone->pszZoneName,
            status, status ));

        argArray[0]  = szName;
        argArray[1]  = pSearchBlob->pZone->pszZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_DS_NODE_LOAD_FAILED,
            2,
            argArray,
            EVENTARG_ALL_UTF8,
            status );

        ASSERT( status != ERROR_SUCCESS );
    }


Done:

    //
    //  return current LDAPMessage as node object
    //

    *ppNode = pnodeOwner;

    IF_DEBUG( ANY )
    {
        if ( status != ERROR_SUCCESS && status != DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_PRINT((
                "ERROR: Failed getNextNodeInDsZoneSearch()\n"
                "    status   = %d (%p)\n",
                status, status ));
        }
        DNS_DEBUG( DS2, (
            "Leaving getNextNodeInDsZoneSearch()\n"
            "    search blob  = %p\n"
            "    pnode        = %p\n"
            "    name         = %S\n",
            pSearchBlob,
            pnodeOwner,
            pwsname ));
    }

    if ( ppvalName )
    {
        ldap_value_free( ppvalName );
    }
    return status;
}



//
//  Public zone API
//

DNS_STATUS
Ds_OpenZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Open a DS zone on the server.

    Fills zone info with necessary DS info.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR           pwszzoneDN = NULL;
    PLDAP           pldap;
    PLDAPMessage    presultMsg;
    PLDAPMessage    pentry;
    DWORD           searchTime;

    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    //
    //  open DS if not open
    //

    if ( !pServerLdap )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }

    //
    //  DEVNOTE: Zone DN is used as open/closed flag - check to see
    //      if there are any MT issues here (we set the DN up top
    //      but don't complete the zone search until way down below).
    //
    //  DEVNOTE: this is awkward. It assumes we can always recreate
    //      the DN of the zone from only the zone name and globals,
    //      which is not true with NDNC support. So I will be removing
    //      this usage and frequent regeneration of DN.
    //

    //
    //  If this is the root hint zone and it does not yet have a DN
    //  associated with it, check the DS Domain DP and legacy containers
    //  for a root hint zone.
    //
    
    if ( IS_ZONE_CACHE( pZone ) && !pZone->pwszZoneDN )
    {
        int         cblen = ( MAX_DN_PATH + 1 ) * sizeof( WCHAR );
        PWSTR       pwszdn = ALLOCATE_HEAP( cblen );
        
        if ( pwszdn )
        {
            DNS_DP_INFO *   dpsToCheck[] = { g_pDomainDp, g_pLegacyDp };
            int             i;
            PLDAPMessage    pcacheZoneEntry;
            
            for ( i = 0; i < sizeofarray( dpsToCheck ); ++i )
            {
                DNS_DP_INFO *   pdp = dpsToCheck[ i ];
                
                if ( !pdp || !pdp->pwszDpDn )
                {
                    continue;
                }
                
                //
                //  Formulate DN for this DP.
                //
                
                status = StringCbPrintfW(
                                pwszdn,
                                cblen,
                                L"DC=%s,%s%s",
                                DS_CACHE_ZONE_NAME,
                                g_pszRelativeDnsFolderPath,
                                pdp->pwszDpDn );
                if ( status != ERROR_SUCCESS )
                {
                    ASSERT( status == ERROR_SUCCESS );
                    return DNS_ERROR_NO_MEMORY;
                }
                
                //
                //  Does this object exist in the DS?
                //
                
                pcacheZoneEntry = DS_LoadOrCreateDSObject(
                                        NULL,           //  LDAP session
                                        pwszdn,         //  DN of object
                                        NULL,           //  object class
                                        FALSE,          //  create flag
                                        NULL,           //  created flag output
                                        NULL );         //  status output
                if ( pcacheZoneEntry )
                {
                    //
                    //  We've found root hints in the DS! Set the root zone
                    //  to point to these root hints and exist.
                    //
                    
                    status = Zone_DatabaseSetup(
                                pZone,
                                TRUE,           //  DS integrated
                                NULL,           //  filename
                                0,              //  filename length
                                0,              //  flags
                                pdp,            //  DP pointer
                                0,              //  DP flags
                                NULL );         //  DP FQDN
                    ldap_msgfree( pcacheZoneEntry );
                    break;
                }
            }

            FREE_HEAP( pwszdn );
        }
        else
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }
    
    //
    //  If the zone DN does not exist, build it. This should only ever
    //  happen for zones stored in the legacy directory partition.
    //

    if ( !pZone->pwszZoneDN )
    {
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        IF_NOMEM( !pZone->pwszZoneDN )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
    }

    //
    //  find zone in DS
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                pZone->pwszZoneDN,
                LDAP_SCOPE_BASE,
                g_szDnsZoneFilter,
                DsTypeAttributeTable,
                0,
                ctrls,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pZone->pwszZoneDN, pServerLdap, 0 );
        goto Failed;
    }

    //
    //  read zone properties
    //

    pentry = ldap_first_entry(
                    pServerLdap,
                    presultMsg );

    Ds_ReadZoneProperties(
        pZone,
        pentry );

    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }

    //
    //  Have we read a zone type we are not capable of handling?
    //

    if ( pZone->fZoneType != DNS_ZONE_TYPE_CACHE &&
         pZone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
         pZone->fZoneType != DNS_ZONE_TYPE_STUB &&
         pZone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        DNS_PRINT((
            "ERROR: read unsupported zone type %d from the DS for zone %s\n",
            pZone->fZoneType,
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Failed;
    }

    DNS_DEBUG( DS, (
        "Ds_OpenZone() succeeded for zone %s\n"
        "    zone DN = %S\n",
        pZone->pszZoneName,
        pZone->pwszZoneDN ));

    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenZone() failed for %s, status = %d (%p)\n",
        pZone->pszZoneName,
        status, status ) );

    return status;
}



DNS_STATUS
Ds_CloseZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Close a DS zone.
    Simply free memory associated with handle.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PVOID   pwszDn = pZone->pwszZoneDN;

    DNS_DEBUG( DS, (
        "Ds_CloseZone( %S )\n",
        ( LPSTR ) pZone->pwszZoneDN ));

    pZone->pwszZoneDN = NULL;
    FREE_HEAP( pwszDn );
    return ERROR_SUCCESS;
}



DNS_STATUS
Ds_AddZone(
    IN      PLDAP           pLdap,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Add a zone to DS.

Arguments:

    pLdap -- LDAP session or NULL to use server LDAP session
    
    pZone -- zone to add
    
    dwFlags -- valid flag bits are:

        DNS_ADDZONE_WRITESD
            - write security descriptor in memory to DS zone object

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    DNS_STATUS              statusAdd = ERROR_SUCCESS;
    PLDAPMod                pmodArray[3];
    DNS_LDAP_SINGLE_MOD     modZone;
    DNS_LDAP_SINGLE_MOD     modCN;
    BOOL                    faddedZoneButCouldNotModify = FALSE;

    DNS_DEBUG( DS, (
        "Ds_AddZone( %s )\n",
        pZone->pszZoneName ) );

    if ( !pLdap )
    {
        pLdap = pServerLdap;
    }
    
    //
    //  build and save zone DS name
    //

    if ( !pZone->pwszZoneDN )
    {
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        if ( !pZone->pwszZoneDN )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
    }
    
    //
    //  For zones in directory partitions, make sure that the zone parent
    //  MicrosoftDNS object exists.
    //
    
    if ( !IS_DP_LEGACY( ZONE_DP( pZone ) ) )
    {
        Dp_LoadOrCreateMicrosoftDnsObject( pLdap, ZONE_DP( pZone ), TRUE );
    }

    //
    //  one mod -- add the zone
    //

    pmodArray[0] = (PLDAPMod) &modZone;
    pmodArray[1] = (PLDAPMod) &modCN;
    pmodArray[2] = NULL;

    buildStringMod(
        & modZone,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("dnsZone") );

    buildStringMod(
        & modCN,
        LDAP_MOD_ADD,
        LDAP_TEXT("cn"),
        LDAP_TEXT("Zone") );

    statusAdd = ldap_add_s(
                        pLdap,
                        pZone->pwszZoneDN,
                        pmodArray );
    if ( statusAdd == LDAP_ALREADY_EXISTS )
    {
        //
        //  Continue as if succeeded, but reserve error code.
        //
        DNS_DEBUG( DS, (
            "Warning: Attempt to add an existing zone to DS\n" ));
    }
    else if ( statusAdd != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Ds_AddZone unable to add zone %s to directory\n"
            "    status = %p\n",
            pZone->pszZoneName,
            statusAdd ) );
        status = Ds_ErrorHandler( statusAdd, pZone->pwszZoneDN, pLdap, 0 );
        goto Cleanup;
    }
    else
    {
        faddedZoneButCouldNotModify = TRUE;
    }

    //
    //  Write zone DS properties.
    //

    status = Ds_WriteZoneProperties( pLdap, pZone );
    if ( status == ERROR_SUCCESS )
    {
        faddedZoneButCouldNotModify = FALSE;
    }
    else
    {
        DNS_DEBUG( ANY, (
            "ERROR: Failed to write properties for zone %S to directory\n"
            "    status = %p (%d)\n",
            pZone->pwszZoneDN,
            status, status ) );
        goto Cleanup;
    }
    
    //
    //  Write security descriptor if required.
    //
    
    do
    {
        struct berval       sdBerVal =
        {
            pZone->dwSdLen,
            pZone->pSD
        };
        
        struct berval *     sdBerArray[] =
        {
            &sdBerVal,
            NULL
        };
        
        LDAPModW            sdMod = 
            {
            LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
            DSATTR_SD,
            ( PWCHAR * ) sdBerArray
            };
        
        LDAPModW *          modArray[] = { &sdMod, NULL };

        if ( !( dwFlags & DNS_ADDZONE_WRITESD ) ||
             !pZone->pSD ||
             !pZone->dwSdLen )
        {
            break;
        }

        if ( !IsValidSecurityDescriptor( pZone->pSD ) )
        {
            DNS_DEBUG( ANY, (
                "Ds_AddZone: can't write back SD because SD is not valid\n" ));
            ASSERT( IsValidSecurityDescriptor( pZone->pSD ) );
            break;
        }
        
        status = ldap_modify_s(
                        pLdap,
                        pZone->pwszZoneDN, 
                        modArray );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "Ds_AddZone: error 0x%X writing back SD to\n    %S\n",
                status,
                pZone->pwszZoneDN ));
            ASSERT( status == ERROR_SUCCESS );

            status = Ds_ErrorHandler( status, pZone->pwszZoneDN, pLdap, 0 );
        }

        status = ERROR_SUCCESS;     //  failure writing back SD is ignored.
    } while ( 0 );

    //
    //  Open zone.
    //      - sets up the zone DN field.
    //      - refresh zone props (redundent)
    //      - double check that the zone is on the DS & happy (redundent, but ok)
    //

    status = Ds_OpenZone( pZone );

    ( DWORD ) Ds_ErrorHandler( status, pZone->pwszZoneDN, pLdap, 0 );
    ASSERT ( ERROR_SUCCESS == status );

    //
    //  convert status to most important error
    //

    status = statusAdd ? statusAdd : status;

    DNS_DEBUG( DS, (
        "Leave Ds_AddZone( %s )\n"
        "    zone DN  = %S\n"
        "    status   = %d (%p)\n",
        pZone->pszZoneName,
        pZone->pwszZoneDN,
        status, status ));

Cleanup:

    //
    //  If the zone was added to AD but there was a failure writing the new
    //  zone's properties, delete the zone object that was just created.
    //  This step is necessary because an admin could conceivable have
    //  permission to add a zone object but not write properties on it. 
    //  If the admin cannot write properties to the zone, we cannot allow
    //  him to create the zone.
    //
    
    if ( status != ERROR_SUCCESS && faddedZoneButCouldNotModify && pZone )
    {
        Ds_DeleteDn( pServerLdap, pZone->pwszZoneDN, TRUE );
    }

    return status;
}



DNS_STATUS
Ds_TombstoneZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Tombstone all records in zone.

    Need to do this before reloading zone into DS.
    This allows us to reuse the DS objects -- which have a very long
    DS-tombstoning, if actually deleted.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PLDAPMessage    pmessage;
    PDB_NODE        pnodeDummy;
    PWSTR           pwszdn;


    DNS_DEBUG( DS, (
        "Ds_TombstoneZone( %s )\n",
        pZone->pszZoneName ) );

    //
    //  open server
    //      delete from DS, may be called without open DS zone, so must
    //      make sure we are running
    //

    status = Ds_OpenServer( DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  open zone -- if can not, zone already gone
    //

    status = Ds_OpenZone( pZone );
    if ( status != ERROR_SUCCESS )
    {
        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            status = ERROR_SUCCESS;
        }
        return status;
    }

    //
    //  search zone for delete -- get everything
    //

    status = Ds_StartDsZoneSearch(
                &searchBlob,
                pZone,
                DNSDS_SEARCH_DELETE );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status != DNSSRV_STATUS_DS_SEARCH_COMPLETE );
        return status;
    }

    //
    //  tombstone each node in zone
    //
    //  we do not fail on node delete failure, that shows up in final
    //  failure to delete zone container;  just continue to delete as
    //  much as possible
    //

    while ( 1 )
    {
        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeDummy );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                break;
            }
            continue;
        }

        pwszdn = ldap_get_dn(
                    pServerLdap,
                    searchBlob.pNodeMessage );

        ASSERT( pwszdn );

        status = deleteNodeFromDs(
                    pServerLdap,
                    pZone,
                    pwszdn,
                    0 );            //  default serial number
        ldap_memfree( pwszdn );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "deleteNodeFromDs() failed %p (%d) on tombstoning of zone %s\n",
                status, status,
                pZone->pszZoneName ));
        }
    }

    //  cleanup search blob

    Ds_CleanupSearchBlob( &searchBlob );

    DNS_DEBUG( DS, (
        "Leaving Ds_TombstoneZone( %S )\n"
        "    status = %d\n",
        pZone->pwszZoneDN,
        status ) );

    return status;
}



DNS_STATUS
Ds_DeleteZone(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Delete a zone in DS.

Arguments:

    pZone -- ptr to zone info
    
    dwFlags -- operation flags

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR *         dnComponents = NULL;
    PLDAP           pldap = pServerLdap;
    int             iRenameAttempt = 0;
    WCHAR           newRDN[ MAX_DN_PATH ];
    WCHAR           newDN[ MAX_DN_PATH +
                                sizeof( DNS_ZONE_DELETE_MARKER ) +
                                30 ];   //  pad for uniqueness stamp
    int             i;

    DNS_DEBUG( DS, (
        "Ds_DeleteZone( %s )\n",
        pZone->pszZoneName ) );

    //
    //  open server
    //      delete from DS, may be called without open DS zone, so must
    //      make sure we are running
    //

    status = Ds_OpenServer( DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  open zone
    //      -- if can => delete zone
    //      -- if not => zone already gone
    //

    status = Ds_OpenZone( pZone );
    if ( status == LDAP_NO_SUCH_OBJECT )
    {
        status = ERROR_SUCCESS;
        goto Done;
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    
    //
    //  If impersonating, open up a new LDAP session.
    //
    
    if ( dwFlags & DNS_DS_DEL_IMPERSONATING )
    {
        pldap = NULL;
        status = Ds_OpenServerForSecureUpdate( &pldap );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: can't open DS session\n" ));
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Done;
        }
    }

    //
    //  Write a property to the zone so that we can retrieve the name of
    //  the host who deleted the zone. This is necessary so that we can
    //  filter out deletes in the DS polling thread.
    //

    if ( !g_pwsServerName )
    {
        g_pwsServerName = Dns_StringCopyAllocate(
                            SrvCfg_pszServerName,
                            0,                      //  length unknown
                            DnsCharSetUtf8,         //  UTF8 in
                            DnsCharSetUnicode );    //  unicode out
    }
    if ( !g_pwsServerName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    pZone->pwsDeletedFromHost = Dns_StringCopyAllocate_W(
        g_pwsServerName, 0 );
    status = Ds_WriteZoneProperties( NULL, pZone );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: error %lu deleting writing zone\n",
            status ));
    }

    //
    //  Before we delete the DN, we must rename it so that it starts
    //  with the "..Deleted" prefix so while the delete is in
    //  progress we don't mistakenly do anything with the zone records.
    //
    //  On the first rename attempt, try to rename the zone to
    //  "..Deleted-ZONENAME". If that fails, try
    //  "..Deleted.TICKCOUNT-ZONENAME". This failover gives us good
    //  compatibility with older servers. If we use the TICKCOUNT rename
    //  the zone delete will not replicate properly to older servers, but
    //  that should be infrequent, and the gains by not deleting the
    //  zone in place are large enough that breaking the occasional
    //  zone deletion replication is acceptable.
    //

    while ( 1 )
    {
        //
        //  On first attempt, no uniqueness marker. On later attempts, use
        //  tick count to try and generate a unique RDN.
        //

        if ( iRenameAttempt++ == 0 )
        {
            status = StringCchPrintfW(
                        newRDN,
                        sizeofarray( newRDN ),
                        L"DC=%s-%s",
                        DNS_ZONE_DELETE_MARKER,
                        pZone->pwsZoneName );
            if ( FAILED( status ) )
            {
                goto Done;
            }
        }
        else
        {
            status = StringCchPrintfW(
                        newRDN,
                        sizeofarray( newRDN ),
                        L"DC=%s.%08X-%s",
                        DNS_ZONE_DELETE_MARKER,
                        GetTickCount() + iRenameAttempt,
                        pZone->pwsZoneName );
            if ( FAILED( status ) )
            {
                goto Done;
            }
        }

        status = ldap_rename_ext_s(
                        pServerLdap,                // ldap
                        pZone->pwszZoneDN,          // current DN
                        newRDN,                     // new RDN
                        NULL,                       // new parent DN
                        TRUE,                       // delete old RDN
                        NULL,                       // server controls
                        NULL );                     // client controls
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: status %lu on rename attempt %d to RDN %S\n"
            "    DN %S\n",
            status,
            iRenameAttempt,
            newRDN,
            pZone->pwszZoneDN ));
        if ( status == ERROR_SUCCESS )
        {
            break;          //  Rename successful!
        }
        if ( iRenameAttempt < DNS_MAX_DELETE_RENAME_ATTEMPTS )
        {
            continue;       //  Try renaming to a unique name.
        }

        //
        //  Total failure to rename - try DS delete in place.
        //

        DNS_DEBUG( DS, (
            "Ds_DeleteZone: could not rename so doing in place delete\n"
            "    DN %S\n",
            pZone->pwszZoneDN ));
        status = Ds_DeleteDn(
                    pldap,
                    pZone->pwszZoneDN,
                    TRUE );              // delete zone subtree
        goto Done;
    }

    //
    //  The zone has been renamed - proceed with DS delete.
    //

    DNS_DEBUG( DS, (
        "Ds_DeleteZone: renamed to RDN %S\n"
        "    from %S\n",
        newRDN, pZone->pwszZoneDN ) );

    // Formulate the new DN of the renamed zone.
    dnComponents = ldap_explode_dn( pZone->pwszZoneDN, 0 );
    if ( !dnComponents )
    {
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: unable to explode DN %S\n",
            pZone->pwszZoneDN ));
        goto Done;
    }
    wcscpy( newDN, newRDN );
    for ( i = 1; dnComponents[ i ]; ++i )
    {
        wcscat( newDN, L"," );
        wcscat( newDN, dnComponents[ i ] );
    }

    DNS_DEBUG( DS, (
        "Ds_DeleteZone: deleting renamed zone %S\n",
        newDN ));

    status = Ds_DeleteDn(
                pldap,
                newDN,
                TRUE );             // delete zone subtree

    //
    //  If the delete failed, rename the zone back.
    //
    
    if ( status != ERROR_SUCCESS )
    {
        DNS_STATUS  renameStatus;
        
        renameStatus = ldap_rename_ext_s(
                            pServerLdap,                // ldap
                            newDN,                      // current DN
                            dnComponents[ 0 ],          // new RDN
                            NULL,                       // new parent DN
                            TRUE,                       // delete old RDN
                            NULL,                       // server controls
                            NULL );                     // client controls
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: status %lu on renaming zone back to RDN %S\n"
            "    DN %S\n",
            renameStatus,
            dnComponents[ 0 ],
            newDN ));
    }

Done:

    if ( dnComponents )
    {
        ldap_value_free( dnComponents );
    }

    //  return Win32 error code, as return
    //  is passed back to admin tool

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Failed Ds_DeleteZone from DS status %d (0x%08X)\n",
            status, status ));
        status = Ds_LdapErrorMapper( status );
    }
    else
    {
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: returning %d\n",
            status ) );
    }

    if ( pldap && pldap != pServerLdap )
    {
        Ds_CloseServerAfterSecureUpdate( &pldap );
    }

    return status;
}



//
//  Load\Read from DS
//

DNS_STATUS
Ds_ReadNodeRecords(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD *    ppRecords,
    IN      PVOID           pSearchBlob     OPTIONAL
    )
/*++

Routine Description:

    Read records in DS at node.

Arguments:

    pZone -- zone found

    pNode -- node to find records for

    ppRecords -- addr to recv the records

    pSearchBlob -- search blob if in context of existing search

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    PLDAPMessage    pmessage = NULL;
    PLDAPMessage    pentry;
    DS_SEARCH       searchBlob;
    PDS_SEARCH      psearchBlob;
    BOOL            bstatus;
    DWORD           searchTime;
    PLDAPControl ctrls[] = {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    //
    // ensures we're not referencing some uninit var
    // somewhere.
    //

    *ppRecords = NULL;

    DNS_DEBUG( DS2, (
        "Ds_ReadNodeRecords()\n"
        "    zone     = %S\n"
        "    node     = %s\n",
        (LPSTR) pZone->pwszZoneDN,
        pNode->szLabel ));

    //  Zone must have a DN.

    ASSERT( pZone->pwszZoneDN );
    if ( !pZone->pwszZoneDN )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  build DS name for this domain name

    status = buildDsNodeNameFromNode(
                    wsznodeDN,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: Failed to build DS name\n"
            ));
        // why would we fail to create a DS name?
        ASSERT ( FALSE );
        goto Failed;
    }

    //
    //  get DS node
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                wsznodeDN,
                LDAP_SCOPE_BASE,
                g_szDnsNodeFilter,
                DsTypeAttributeTable,
                0,
                ctrls,
                NULL,
                &g_LdapTimeout,
                0,
                &pmessage );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ldap_search_s() failed %p %d\n",
            status, status ));
        goto Failed;
    }

    pentry = ldap_first_entry(
                    pServerLdap,
                    pmessage );
    if ( !pentry )
    {
        DNS_DEBUG( DS, (
            "Error: Node %S base search returned no results\n",
            wsznodeDN ));
        // must set status to non success before bailing out,
        status = LDAP_NO_SUCH_OBJECT;
        goto Failed;
    }

    //
    //  create search blob if not already given
    //

    psearchBlob = (PDS_SEARCH) pSearchBlob;
    if ( !psearchBlob )
    {
        psearchBlob = & searchBlob;
        Ds_InitializeSearchBlob( psearchBlob );
    }
    psearchBlob->pZone = pZone;
    psearchBlob->pNodeMessage = pentry;

    //
    //  get out the records
    //      - this saves highest version number to search blob
    //

    status = buildRecordsFromDsRecords(
                psearchBlob,
                pNode );


Failed:

    if ( status == ERROR_SUCCESS )
    {
        *ppRecords = psearchBlob->pRecords;
    }
    else
    {
        STAT_INC( DsStats.FailedReadRecords );
        *ppRecords = NULL;
        status = Ds_ErrorHandler( status, wsznodeDN, pServerLdap, 0 );
    }

    DNS_DEBUG( DS, (
        "Ds_ReadNodeRecords() for %S, status = %d (%p)\n",
        wsznodeDN,
        status, status ) );

    if ( pmessage )
    {
        ldap_msgfree( pmessage );
    }
    return status;
}



DNS_STATUS
Ds_LoadZoneFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    )
/*++

Routine Description:

    Load zone from DS.

Arguments:

    pZone -- zone to load

    dwOptions
        0   -  straight startup type load
        MERGE currently not supported;  generally zones will be atomic,
        assume either want stuff from DS, or will toss DS data and rewrite
        from existing copy

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeOwner;
    PDB_RECORD      prr;
    PDB_RECORD      prrNext;
    PDS_RECORD      pdsRecord;
    LONG            recordCount = 0;
    DWORD           highestVersion = 0;
    BOOL            bsearchInitiated = FALSE;

    DNS_DEBUG( INIT, (
        "Ds_LoadZoneFromDs() for zone %s\n\n",
        pZone->pszZoneName ));

    //
    //  init DS
    //      if attempting, but not requiring load of zone from DS
    //      as is the case for root-hints, with cache file not explicitly
    //      specified, THEN do not log event if we fail to find zone
    //

    status = Ds_OpenServer( (pZone->fDsIntegrated) ? DNSDS_MUST_OPEN : 0 );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  open zone
    //      - if failure on startup (as opposed to admin add), log error
    //      but do not include root-hints zone as load of this is attempted
    //      before checking whether cache.dns exists
    //

    status = Ds_OpenZone( pZone );
    if ( status != ERROR_SUCCESS )
    {
        if ( !SrvCfg_fStarted && !IS_ZONE_CACHE(pZone) )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_OPEN_FAILED,
                1,
                &pZone->pwsZoneName,
                NULL,
                status );
        }
        goto Failed;
    }

    //
    //  query zone for all nodes
    //      - LOAD flag so build nodes in zone's load tree
    //
    //  note: for later use;  if MERGE desired, merge would be accomplished
    //      by loading here with SEARCH_UPDATES flag so DS data brought into
    //      current zone without deleting current data;  then would need to
    //      write back entire zone to DS
    //

    status = Ds_StartDsZoneSearch(
                &searchBlob,
                pZone,
                DNSDS_SEARCH_LOAD );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_PRINT((
                "ERROR: attempt to load zone %s from DS found no DS records\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            status = ERROR_NO_DATA;
            goto Failed;
        }
        DNS_PRINT((
            "Failure searching zone %s for zone load\n",
            pZone->pszZoneName ));
        ASSERT( FALSE );
        goto EnumError;
    }
    bsearchInitiated = TRUE;

    //
    //  load every domain object in the zone
    //

    while ( 1 )
    {
        #define DNS_RECORDS_BETWEEN_SCM_UPDATES     ( 8192 )

        //
        //  Keep SCM happy.
        //

        if ( recordCount % DNS_RECORDS_BETWEEN_SCM_UPDATES == 0 )
        {
            Service_LoadCheckpoint();
        }

        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeOwner );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                    "loading zone %s\n"
                    "    unexpected error %d searchBlob.LastError %d\n",
                    pZone->pszZoneName,
                    status,
                    searchBlob.LastError ));
                ASSERT( FALSE );
                goto EnumError;
            }
            continue;
        }

        if ( !pnodeOwner )
        {
            DNS_DEBUG( DS, (
                "Encountered tombstone or bad DS node during load of zone %s\n"
                "    Continuing search \n",
                pZone->pszZoneName ));
            continue;
        }
        DsStats.DsNodesLoaded++;

        //
        //  load all the records for this node into memory database
        //

        prr = searchBlob.pRecords;

        while ( prr )
        {
            prrNext = NEXT_RR( prr );

            status = RR_AddToNode(
                        pZone,
                        pnodeOwner,
                        prr );
            if ( status != ERROR_SUCCESS )
            {
                //
                //  DEVNOTE-LOG: log and continue
                //
                DNS_PRINT((
                    "ERROR: Failed to load DS record into database node (%s)\n"
                    "    of zone %s\n",
                    pnodeOwner->szLabel,
                    pZone->pszZoneName ));
            }
            else
            {
                DsStats.DsRecordsLoaded++;
                recordCount++;
            }
            prr = prrNext;
        }

        IF_DEBUG( DS2 )
        {
            Dbg_DbaseNode(
               "Node after DS create of new record\n",
               pnodeOwner );
        }
    }

    //
    //  save zone info
    //      - save USN for catching updates
    //      - use USN in SOA in case non-DS secondaries
    //      - pick up other zone changes (e.g. WINS records)
    //
    //      - activate loaded zone
    //      must do this ourselves rather than have Zone_Load function
    //      handle it, as must call Zone_UpdateVersionAfterDsRead() on
    //      fully loaded zone so that version change made to real SOA
    //
    //  ideally the zone load would be a bit more atomic with all these
    //  changes made on loading data, than simple flick of switch would
    //  bring on-line
    //

    saveStartUsnToZone( pZone, &searchBlob );

    if ( !IS_ZONE_CACHE(pZone) )
    {
        DWORD   previousSerial = pZone->dwSerialNo;

        status = Zone_ActivateLoadedZone( pZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR: Failed activate of newly loaded DS zone %s\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            goto EnumError;
        }
        if ( IS_ZONE_PRIMARY( pZone ) )
        {
            Zone_UpdateVersionAfterDsRead(
                pZone,
                searchBlob.dwHighestVersion,    //  highest serial read
                TRUE,                           //  zone load
                previousSerial );               //  previous serial, if reload
        }
    }

    ZONE_NEXT_DS_POLL_TIME(pZone) = DNS_TIME() + DNS_DS_POLLING_INTERVAL;

    //  save zone record count

    pZone->iRRCount = recordCount;

    //  successful load
    //      - set DS flag as may have be "if found" load

    DNS_DEBUG( INIT, (
        "Successful DS load of zone %s\n",
        pZone->pszZoneName ));

    CLEAR_DSRELOAD_ZONE( pZone );
    pZone->fDsIntegrated = TRUE;
    STARTUP_ZONE( pZone );

    //  cleanup after search

    Ds_CleanupSearchBlob( &searchBlob );

    return ERROR_SUCCESS;

EnumError:

    DNS_PRINT((
        "ERROR: Failed to load zone %s from DS!\n"
        "    status = %d (%p)\n",
        pZone->pszZoneName,
        status, status ));

    {
        PVOID   argArray[ 2 ] = { pZone->pwsZoneName };
        PWSTR   perrString;

        perrString = argArray[ 1 ] = Ds_GetExtendedLdapErrString( NULL );
        DNS_LOG_EVENT(
            DNS_EVENT_DS_ZONE_ENUM_FAILED,
            2,
            argArray,
            NULL,
            status );
        Ds_FreeExtendedLdapErrString( perrString );
    }
 
Failed:

    //  on failure with explicit DS zone, set flag so will try to reload

    if ( pZone->fDsIntegrated )
    {
        SET_DSRELOAD_ZONE( pZone );
    }

    //  cleanup after search

    if ( bsearchInitiated )
    {
        Ds_CleanupSearchBlob( &searchBlob );
    }

    DNS_DEBUG( DS, (
        "WARNING: Failed to load zone %s from DS!\n"
        "    status = %d (%p)\n"
        "    zone is %sset for DS reload\n",
        pZone->pszZoneName,
        status, status,
        IS_ZONE_DSRELOAD(pZone) ? "" : "NOT" ));
    return status;
}



DNS_STATUS
Ds_ZonePollAndUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Check for and read in changes to zone from DS.

Arguments:

    pZone -- zone to check and refresh

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeOwner;
    PUPDATE         pupdate;
    BOOL            fupdatedRoot = FALSE;
    DWORD           highestVersion = 0;
    DWORD           pollingTime;
    UPDATE_LIST     updateList;
    PWSTR           pwszzoneDN = NULL;
    BOOL            bsearchInitiated = FALSE;
    PDB_NODE        prefreshHostNode = NULL;
    PDB_NODE        prefreshRootNode = NULL;
    BOOL            fDsErrorsWhilePolling = FALSE;

    if ( !pZone->fDsIntegrated )
    {
        DNS_DEBUG( DS, (
            "skipping zone: type=%d ds=%d name=%s\n",
            pZone->fZoneType,
            pZone->fDsIntegrated,
            pZone->pszZoneName ));
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  if never loaded -- try load
    //

    if ( IS_ZONE_DSRELOAD( pZone ) )
    {
        return Zone_Load( pZone );
    }

    //
    //  zone should always have zone DN
    //

    if ( !pZone->pwszZoneDN )
    {
        DNS_PRINT((
            "ERROR: Fixing zone DN in polling cycle %s!\n",
            pZone->pszZoneName ));

        ASSERT( FALSE );

        pwszzoneDN = DS_CreateZoneDsName( pZone );
        if ( !pwszzoneDN )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        pZone->pwszZoneDN = pwszzoneDN;
    }

    //
    //  if recently polled -- then don't bother
    //

    UPDATE_DNS_TIME();

    if ( !fForce  &&  ZONE_NEXT_DS_POLL_TIME(pZone) > DNS_TIME() )
    {
        DNSLOG( DSPOLL, (
            "Zone %s will not be polled for another %d seconds\n",
            pZone->pszZoneName,
            ZONE_NEXT_DS_POLL_TIME( pZone ) - DNS_TIME() ));
        return ERROR_SUCCESS;
    }

    DNSLOG( DSPOLL, (
        "Polling zone %s\n",
        pZone->pszZoneName ));

    //
    //  lock zone for update
    //

    if ( !Zone_LockForDsUpdate(pZone) )
    {
        DNS_PRINT((
            "WARNING: Failed to lock zone %s for DS poll!\n",
            pZone->pszZoneName ));
        return DNS_ERROR_ZONE_LOCKED;
    }

    //  init update list

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    //
    //  read any updates to zone properties
    //      - if zone doesn't exist in DS, bail
    //

    status = Ds_ReadZoneProperties(
                pZone,
                NULL );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            DNSLOG( DSPOLL, (
                "Zone %s is missing from the DS, may have been deleted\n",
                pZone->pszZoneName ));

            Ds_CheckZoneForDeletion( pZone );

            goto ZoneDeleted;
        }

        //  Failure to read properties doesn't affect zone load
        //      but this should not fail if zone exists

        DNS_DEBUG( ANY, (
            "Error <%lu>: failed to update zone property\n",
            status));

        //  ASSERT( FALSE );
    }

    //
    //  Have we read a zone type we are not capable of handling?
    //

    if ( pZone->fZoneType != DNS_ZONE_TYPE_CACHE &&
         pZone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
         pZone->fZoneType != DNS_ZONE_TYPE_STUB &&
         pZone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        DNS_PRINT((
            "ERROR: read unsupported zone type %d from the DS for zone %s\n",
            pZone->fZoneType,
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        //  Need to delete the zone from memory here or in caller!!
        goto Done;
    }

    //
    //  query zone for updates
    //

#if DBG
    pollingTime = GetCurrentTime();
#endif

    status = Ds_StartDsZoneSearch(
                & searchBlob,
                pZone,
                DNSDS_SEARCH_UPDATES );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_DEBUG( DS, (
                "DS Poll and update on zone %s found no records\n",
                pZone->pszZoneName ));
            goto Done;
        }
        DNS_PRINT((
            "Failure searching zone %s for poll and update\n"
            "    version = %p\n",
            pZone->pszZoneName,
            pZone->szLastUsn ));
        goto Done;
    }
    bsearchInitiated = TRUE;

    //
    //  read in new data at nodes with updates
    //
    //  DEVNOTE: could implement more intelligent zone locking here
    //      should be able to poll off-lock,
    //          - read USN up front (start search above)
    //      then when done, lock zone with hard, going to get
    //      it and you can't stop me lock
    //

    while ( TRUE )
    {
        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeOwner );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                fDsErrorsWhilePolling = TRUE;
                break;
            }
            continue;
        }
        if ( ! pnodeOwner )
        {
            continue;
        }
        DsStats.DsUpdateNodesRead++;

        //
        //  suppress new data for this DNS server's host node
        //      - ignore TTL and aging;  not worth writing back for that
        //
        //  DEVNOTE: could make this-host changed check more sophisticated
        //      - check for A record change
        //

        if ( IS_THIS_HOST_NODE( pnodeOwner ) )
        {
            if ( ! RR_ListIsMatchingList(
                            pnodeOwner,
                            searchBlob.pRecords,    // new list
                            0 ) )
            {
                prefreshHostNode = pnodeOwner;
                RR_ListFree( searchBlob.pRecords );
                continue;
            }
        }

        //
        //  verify DNS server's NS record
        //
        //      - if not there, stick it in and continue
        //      then set ptr to indicate write back to DS
        //

        else if ( IS_AUTH_ZONE_ROOT( pnodeOwner ) )
        {
            PDB_RECORD      prrNs;

            prrNs = RR_CreatePtr(
                        NULL,                       //  no dbase name
                        SrvCfg_pszServerName,
                        DNS_TYPE_NS,
                        pZone->dwDefaultTtl,
                        MEMTAG_RECORD_AUTO );
            if ( prrNs )
            {
                if ( RR_IsRecordInRRList(
                            pnodeOwner->pRRList,
                            prrNs,
                            0 ) )
                {
                    //
                    //  The zone has the local NS ptr, remove it if required.
                    //

                    if ( pZone->fDisableAutoCreateLocalNS )
                    {
                        //
                        //  Add the RR as a deletion to the update list and remove the
                        //  RR from the searchBlob list so it doesn't get added by
                        //  the update below.
                        //

                        PDB_RECORD      pRRDelete;

                        DNS_DEBUG( DS, (
                            "zone (%S) root node %p DS info has local NS record\n"
                            "    BUT auto create disabled on this zone so removing\n",
                            pZone->pwsZoneName,
                            prefreshRootNode ));
                        
                        pupdate = Up_CreateAppendUpdate(
                                        &updateList,
                                        pnodeOwner,
                                        NULL,               //  add list
                                        DNS_TYPE_NS,        //  delete type
                                        prrNs );            //  delete list
                        pupdate->dwVersion = searchBlob.dwNodeVersion;

                        //  Delete the RR from the searchBlob list.

                        pRRDelete = RR_RemoveRecordFromRRList(
                                        &searchBlob.pRecords,
                                        prrNs,
                                        0 );
                        if ( pRRDelete )
                        {
                            RR_Free( pRRDelete );
                        }
                    }
                    else
                    {
                        RR_Free( prrNs );
                    }
                }
                else if ( !pZone->fDisableAutoCreateLocalNS )
                {
                    //
                    //  The zone has no local NS ptr, add one.
                    //

                    DNS_DEBUG( DS, (
                        "WARNING: zone (%S) root node %p DS info missing local NS record\n"
                        "    Rebuilding list to include local NS\n",
                        pZone->pwsZoneName,
                        prefreshRootNode ));

                    SET_RANK_ZONE( prrNs );

                    searchBlob.pRecords = RR_ListInsertInOrder(
                                                searchBlob.pRecords,
                                                prrNs );
                    prefreshRootNode = pnodeOwner;
                }
                else
                {
                    //
                    //  The zone has no local NS ptr but auto create disabled
                    //  so do nothing.
                    //

                    DNS_DEBUG( DS, (
                        "WARNING: zone (%S) root node %p DS info missing local NS record\n"
                        "    BUT auto create is disabled so not rebuilding NS list\n",
                        pZone->pwsZoneName,
                        prefreshRootNode ));
                }
            }
        }

        //
        //  build type-ALL replace update
        //

        ASSERT( pnodeOwner->pZone == pZone || !pnodeOwner->pZone );

        STAT_ADD( DsStats.DsUpdateRecordsRead, searchBlob.dwRecordCount );

        pupdate = Up_CreateAppendUpdate(
                        &updateList,
                        pnodeOwner,
                        searchBlob.pRecords,    //  new list
                        DNS_TYPE_ALL,           //  delete all existing
                        NULL );                 //  no specific delete records

        pupdate->dwVersion = searchBlob.dwNodeVersion;
    }

#if DBG
    pollingTime = GetCurrentTime() - pollingTime;
#endif

    //
    //  execute updates in memory
    //
    //  DEVNOTE: need to no-op duplicates leaving in list ONLY
    //      the changes and their serials
    //      then get highest serial
    //
    //      but also keep highest serial read -- as must at least be
    //      that high
    //

    status = Up_ApplyUpdatesToDatabase(
                &updateList,
                pZone,
                DNSUPDATE_DS );

    ASSERT( status == ERROR_SUCCESS );
    if ( status != ERROR_SUCCESS )
    {
        fDsErrorsWhilePolling = TRUE;
    }
    status = ERROR_SUCCESS;

    //
    //  Save highest USN as baseline for next update but do this only if
    //  we did not encounter any DS errors during this pass. If there
    //  were any DS errors, keep the zone USN where it is so on the next
    //  pass we will retry any records we missed.
    //
    
    if ( fDsErrorsWhilePolling )
    {
        STAT_INC( DsStats.PollingPassesWithDsErrors );
    }
    else
    {
        saveStartUsnToZone( pZone, &searchBlob );
    }

Done:

    //
    //  finish update
    //      - no zone unlock (done below)
    //      - no rewriting records to DS
    //      - reset zone serial for highest version read
    //
    //  note, that first update zone serial for DS read;  so that
    //  Up_CompleteZoneUpdate() will write update list with any
    //  updated serial from DS included;
    //  note: getting a new SOA does not lose this updated serial
    //  as Zone_UpdateVersionAfterDsRead() makes the new serial THE
    //  zone serial, so new SOA can only move it forward -- not backwards
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( IS_ZONE_CACHE(pZone) )
        {
            Up_FreeUpdatesInUpdateList( &updateList );
        }
        else
        {
            if ( updateList.dwCount != 0 )
            {
                Zone_UpdateVersionAfterDsRead(
                    pZone,
                    searchBlob.dwHighestVersion,    // highest serial read
                    FALSE,                          // not zone load
                    0 );
            }
            Up_CompleteZoneUpdate(
                pZone,
                &updateList,
                DNSUPDATE_NO_UNLOCK | DNSUPDATE_NO_INCREMENT );
        }
    }
    else
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            PVOID   argArray[ 2 ] = { pZone->pwsZoneName };
            PWSTR   perrString;

            status = Ds_ErrorHandler( status, pZone->pwszZoneDN, NULL, 0 );

            //
            //  Log event so that we know we lost communications. No
            //  throttling because this is a serious condition, although
            //  perhaps we should rethink throttling at some point.
            //

            perrString = argArray[ 1 ] = Ds_GetExtendedLdapErrString( NULL );
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_ENUM_FAILED,
                2,
                argArray,
                NULL,
                status );
            Ds_FreeExtendedLdapErrString( perrString );
        }
        Up_FreeUpdatesInUpdateList( &updateList );
    }

    ZONE_NEXT_DS_POLL_TIME(pZone) = DNS_TIME() + SrvCfg_dwDsPollingInterval;

    DNS_DEBUG( DS, (
        "Leaving DsPollAndUpdate of zone %s\n"
        "    read %d records from DS\n"
        "    highest version read     = %d\n"
        "    polling time interval    = %d (ms)\n"
        "    next polling time        = %d\n"
        "    status = %p (%d)\n",
        pZone->pszZoneName,
        searchBlob.dwTotalRecords,
        searchBlob.dwHighestVersion,        // highest serial read
        pollingTime,
        ZONE_NEXT_DS_POLL_TIME(pZone),
        status, status ));

    Zone_UnlockAfterDsUpdate( pZone );

    if ( bsearchInitiated )
    {
        Ds_CleanupSearchBlob( &searchBlob );
    }

    //
    //  DS has incorrect host node info
    //      - rewrite existing
    //

    if ( prefreshHostNode )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( DS, (
            "WARNING: DNS server host node %p (%s) DS info out of sync with\n"
            "    local data.  Forcing write of local in-memory info\n",
            prefreshHostNode,
            prefreshHostNode->szLabel ));

        tempStatus = Ds_WriteNodeToDs(
                        NULL,               // default LDAP handle
                        prefreshHostNode,
                        DNS_TYPE_ALL,
                        DNSDS_REPLACE,
                        pZone,
                        0 );                // no flags
        if ( tempStatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR %p (%d) refreshing DNS server host node in DS\n",
                tempStatus, tempStatus ));
        }
    }

    //
    //  root node needs NS refresh?
    //

    if ( prefreshRootNode )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( DS, (
            "WARNING: zone (%S) root node %p DS info missing local NS record\n"
            "    Forcing write of NS local to DS\n",
            pZone->pwsZoneName,
            prefreshRootNode ));

        tempStatus = Ds_WriteNodeToDs(
                        NULL,               // default LDAP handle
                        prefreshRootNode,
                        DNS_TYPE_ALL,
                        DNSDS_REPLACE,
                        pZone,
                        0                   // no flags
                        );
        if ( tempStatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR %p (%d) refreshing zone %S root node in DS\n",
                tempStatus, tempStatus,
                pZone->pwsZoneName ));
        }
    }

    return status;

    ZoneDeleted:

    //
    //  The zone was missing from the DS and may have been deleted
    //  from memory. Perform cleanup.
    //

    Zone_UnlockAfterDsUpdate( pZone );

    if ( bsearchInitiated )
    {
        Ds_CleanupSearchBlob( &searchBlob );
    }

    return ERROR_SUCCESS;
}   //  Ds_ZonePollAndUpdate



//
//  Update\Write to DS
//

DNS_STATUS
writeDelegationToDs(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Write delegation at node to DS.

Arguments:

    pZone -- zone to write into DS

    pNode -- delegation node

    dwFlags -- write options

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrNs;
    PDB_NODE        pnodeNs;

    DNS_DEBUG( DS2, (
        "writeDelegationToDs() for node with label %s\n",
        pNode->szLabel ));

    //
    //  end of zone -- write delegation
    //

    if ( !IS_ZONE_CACHE(pZone)  &&  !IS_DELEGATION_NODE(pNode) )
    {
        DNS_DEBUG( ANY, (
            "ERROR: node %s NOT delegation of DS zone %s being written!\n",
            pNode->szLabel,
            pZone->pszZoneName ));
        ASSERT( FALSE );
        return ERROR_SUCCESS;
    }

    ASSERT( !IS_ZONE_CACHE(pZone) || pNode == DATABASE_CACHE_TREE );

    //
    //  write NS records
    //
    //  DEVNOTE: if glue NS exist should limit to rank glue
    //           if does NOT exists and AUTH data does
    //

    status = Ds_WriteNodeToDs(
                NULL,           // default LDAP handle
                pNode,
                DNS_TYPE_NS,    // only NS records for delegation
                DNSDS_ADD,
                pZone,
                0 );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: response from Ds_WriteNodeToDs() while loading delegation\n"
            "    status = %p\n",
            status ));
    }

    //
    //  write "glue" A records ONLY when necessary
    //
    //  We need these records, when they are within a subzone of
    //  the zone we are writing:
    //
    //  example:
    //      zone:      ms.com.
    //      sub-zones: nt.ms.com.  psg.ms.com.
    //
    //      If NS for nt.ms.com:
    //
    //      1) foo.nt.ms.com
    //          In this case glue for foo.nt.ms.com MUST be added
    //          as ms.com server has no way to lookup foo.nt.ms.com
    //          without knowning server for nt.ms.com to refer query
    //          to.
    //
    //      2) foo.psg.ms.com
    //          Again SHOULD be added unless we already know how to
    //          get to psg.ms.com server.  This is too complicated
    //          sort out, so just include it.
    //
    //      2) bar.ms.com or bar.b26.ms.com
    //          Do not need to write glue record as it is in ms.com.
    //          zone and will be written anyway. (However might want
    //          to verify that it is there and alert admin to
    //          delegation if it is not.)
    //
    //      3) bar.com
    //          Outside ms.com.  Don't need to include, as it can
    //          be looked up in its domain.  Do not WANT to include
    //          as we don't own it, so we don't want to propagate
    //          information that may change without our knowledge.
    //
    //  Note, for reverse lookup domains, name servers are never IN
    //  the domain, and hence no glue is ever needed.
    //
    //  Note, for "cache" zone (writing root hints), name servers are
    //  always needed (always in "subzone") and we can skip test.
    //

    prrNs = NULL;
    LOCK_RR_LIST(pNode);

    while ( prrNs = RR_FindNextRecord(
                        pNode,
                        DNS_TYPE_NS,
                        prrNs,
                        0 ) )
    {
        //
        //  find glue node
        //
        //  node does NOT have to be IN delegation
        //  it should simply NOT be in zone
        //
        //  might insist on glue inside subtree of zone BUT
        //  that limits ability to strictly refer on delegations in
        //  reverse zones (ie. don't send host As)
        //

        pnodeNs = Lookup_FindGlueNodeForDbaseName(
                        pZone,
                        & prrNs->Data.NS.nameTarget );
        if ( !pnodeNs )
        {
            continue;
        }
        status = Ds_WriteNodeToDs(
                    NULL,           // default LDAP handle
                    pnodeNs,
                    DNS_TYPE_A,     // A records of delegated NS
                    DNSDS_ADD,
                    pZone,
                    0
                    );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: response from Ds_WriteNodeToDs() while loading delegation\n"
                "    status = %p\n",
                status ));
        }
    }

    UNLOCK_RR_LIST(pNode);
    return ERROR_SUCCESS;
}



DNS_STATUS
writeNodeSubtreeToDs(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Write node to DS.

Arguments:

    pZone   -- zone to write into DS

    pNode   -- delegation node to write

    dwFlags -- write options

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pchild;

    ASSERT( pZone );
    ASSERT( pNode );

    DNS_DEBUG( DS2, (
        "writeNodeSubtreeToDs() for node with label %s\n",
        pNode->szLabel ));

    //
    //  end of zone -- write delegation
    //

    if ( IS_DELEGATION_NODE(pNode) )
    {
        return  writeDelegationToDs(
                    pZone,
                    pNode,
                    dwFlags );
    }

    //
    //  if node has records -- write them
    //
    //  load into DS
    //
    //  - if we know we are new node, then for first RR set,
    //      faster to do add
    //  - otherwise should just call update
    //

    if ( pNode->pRRList )
    {
        status = Ds_WriteNodeToDs(
                   NULL,            // default LDAP handle
                   pNode,
                   DNS_TYPE_ALL,    // all records
                   DNSDS_ADD,
                   pZone,
                   0 );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: response from Ds_WriteNodeToDs() while loading zone\n"
                "    status = %p\n",
                status ));
        }
    }

    DNS_DEBUG( DS, (
        "Wrote records to DS for node label %s\n",
        pNode->szLabel ));

    //
    //  check children
    //
    //  DEVNOTE: determine errors that stop DS load
    //      some may merit stopping -- indicating DS problem
    //      some (last was INVALID_DN_SYNTAX) just indicate problem with
    //          individual name (party on)
    //

    if ( pNode->pChildren )
    {
        pchild = NTree_FirstChild( pNode );
        ASSERT( pchild );

        while ( pchild )
        {
            status = writeNodeSubtreeToDs(
                        pZone,
                        pchild,
                        dwFlags );

            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                    "ERROR: %p, %d, writing subtree to DS!\n",
                    status, status ));
                //  see DEVNOTE above
                //  break;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    return ERROR_SUCCESS;
    //  return status;
}



DNS_STATUS
Ds_WriteNodeSecurityToDs(
    IN      PZONE_INFO              pZone,
    IN      PDB_NODE                pNode,
    IN      PSECURITY_DESCRIPTOR    pSd
    )
/*++

Routine Description:

    Writes an SD on the DS node associated w/ the pNode


Arguments:

    pNode - Node to extract DN & write

    pSd - the SD to write out.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];

    DNS_DEBUG(DS2, ("Call:Ds_WriteNodeSecurityToDs\n"));

    //
    //  param sanity
    //

    if ( !pServerLdap || !pSd )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // extract node DN
    //

    status = buildDsNodeNameFromNode( wsznodeDN,
                                      pZone,
                                      pNode );

    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    status = Ds_WriteDnSecurity( pServerLdap,
                                 wsznodeDN,
                                 pSd,
                                 TRUE );        //  rewrite owner

    return status;
}   //  Ds_WriteNodeSecurityToDs




DNS_STATUS
Ds_WriteZoneToDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    )
/*++

Routine Description:

    Write zone to DS. The calling thread may be impersonating
    an RPC client. We must open a new LDAP session using this
    thread's current credentials so that Active Directory access
    checking is properly performed.

Arguments:

    pZone -- zone to write into DS

    dwOptions -- options if existing data
        0   -- fail if existing zone
        DNS_ZONE_LOAD_OVERWRITE_DS -- overwrite DS with in memory zone

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    BUFFER          buffer;
    BOOLEAN         fdeleted;
    DS_SEARCH       searchBlob;
    PLDAP           pldap = NULL;

    DNS_DEBUG( DS, (
        "Ds_WriteZoneToDs() for zone %s\n"
        "    options flag = %p\n",
        pZone->pszZoneName,
        (UINT_PTR) dwOptions ));

    //
    //  init DS
    //

    status = Ds_OpenServerForSecureUpdate( &pldap );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "FAILURE: can't open DS session\n" ));
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Cleanup;
    }

    //  create new zone

    status = Ds_AddZone( pldap, pZone, 0 );
    if ( status != ERROR_SUCCESS )
    {
        if ( status != LDAP_ALREADY_EXISTS )
        {
            goto Cleanup;
        }

        //
        //  collided with existing DS zone
        //  depending on flag
        //      - return error
        //      - overwrite memory copy and load DS version
        //      - tombstone DS version and write memory copy
        //

        DNS_DEBUG( ANY, (
            "Ds_AddZone failed, zone %s already exists in DS\n"
            "    load options flag = %p\n",
            pZone->pszZoneName,
            dwOptions ));

        if ( dwOptions & DNS_ZONE_LOAD_OVERWRITE_DS )
        {
            status = Ds_TombstoneZone( pZone );
            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                goto Cleanup;
            }
            //  drop through to load into DS
        }

        else
        {
            DNS_DEBUG( DS, (
               "Ds_WriteZoneToDs(%S) fails, zone already exists in DS\n",
               pZone->pwszZoneDN ));

            status = DNS_ERROR_DS_ZONE_ALREADY_EXISTS;
            goto Cleanup;
        }

    }

    //
    //  write in memory zone to DS
    //  recursively walk zone writing all nodes into DS
    //  Stub zones: we save the zone object ONLY in the DS to avoid
    //  replication storms when the zone expires. The actual SOA and NS
    //  records for the zone are kept in memory only.
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        status = writeDelegationToDs(
                    pZone,
                    DATABASE_CACHE_TREE,
                    0 );
    }
    else if ( !IS_ZONE_STUB( pZone ) && pZone->pZoneRoot )
    {
        status = writeNodeSubtreeToDs(
                    pZone,
                    pZone->pZoneRoot,
                    0 );
    }

    if ( status == ERROR_SUCCESS )
    {
        //pZone->fDsLoadVersion = TRUE;
        DNS_DEBUG( DS, (
            "Successfully wrote zone %s into DS\n",
            pZone->pszZoneName ));
    }
    else
    {
        DNS_DEBUG( DS, (
            "ERROR writing zone %s to DS\n"
            "    status = %p\n",
            pZone->pszZoneName,
            status ));
        Ds_CloseZone( pZone );
    }

    //
    //  save current USN to track updates from
    //

    getCurrentUsn( searchBlob.szStartUsn );

    DNS_DEBUG( DS, (
        "Saving USN %s after zone load\n",
        searchBlob.szStartUsn ));

    saveStartUsnToZone(
        pZone,
        & searchBlob );

    //
    //  write zone properties to DS
    //

    Ds_WriteZoneProperties( NULL, pZone );

    Cleanup:
    
    Ds_CloseServerAfterSecureUpdate( &pldap );

    return status;
}



DNS_STATUS
Ds_WriteUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

    DEVNOTE-DCR: 455357 - eliminate re-reading of data after update

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DBG_FN( "Ds_WriteUpdateToDs" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pnode;
    PDB_NODE        pnodePrevious = NULL;
    PUPDATE         pupdate;
    DWORD           serial;
    DWORD           countRecords;
    BOOL            bAllowWorld = FALSE;
    BOOL            bNewNode = FALSE;
    HANDLE          hClientToken = NULL;
    BOOL            bstatus;
    BOOL            bProxyClient;
    DWORD           dwdsWriteFlags;
    PSECURITY_DESCRIPTOR    pClientSD = NULL;


    DNS_DEBUG( DS, (
        "%s() for zone %s\n", fn,
        pZone->pszZoneName ));

    //  must have already opened zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( pZone->fDsIntegrated );
    ASSERT( pZone->dwNewSerialNo != 0 );

    //
    //  open thread token for secure update to identify proxy client
    //

    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
    {
        bstatus = OpenThreadToken(
                        GetCurrentThread(),     // use thread's pseudo handle
                        TOKEN_QUERY,
                        TRUE,                   // bOpenAsSelf
                        & hClientToken );
        if ( !bstatus )
        {
            status = GetLastError();
            DNS_DEBUG( ANY, (
                "Error <%lu>: cannot get thread token\n", status));
            ASSERT(FALSE);
            return status;
        }
    }

    #if DBG
    Dbg_CurrentUser( ( PCHAR ) fn );
    #endif

    //
    //  loop through all temp nodes
    //      - write only those marked writable
    //      (some update nodes might have no-op'd out
    //

    STAT_INC( DsStats.UpdateLists );

    for ( pnode = pUpdateList->pTempNodeList;
          pnode != NULL;
          pnode = TNODE_NEXT_TEMP_NODE(pnode) )
    {
        //
        //  if no write required, skip
        //

        STAT_INC( DsStats.UpdateNodes );

        if ( !TNODE_NEEDS_DS_WRITE( pnode ) )
        {
            STAT_INC( DsStats.DsWriteSuppressed );
            STAT_INC( DsStats.UpdateSuppressed );
            continue;
        }

        //
        //  secure update
        //

        bNewNode = FALSE;

        if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
        {

            //
            // get security information
            //
            //   DEVNOTE: multiple reads
            //       this adds another read;  instead of getting down to one, we've
            //       now got THREE
            //       - preparing node for update
            //       - checking security (here)
            //       - before write back
            //

            //
            // Access the DS & retrieve security related info:
            //  - expired status
            //  - tombstoned status
            //  - Avail for AU update
            // Only flag that's not is found here is, admin reserved state.
            // That one is found in Up_ApplyUpdatesToDatabase
            //

            status = readAndUpdateNodeSecurityFromDs(pnode,pZone);

            DNS_DEBUG( DS2, (
                "%s: readAndUpdateNodeSecurityFromDs returned 0x%08X\n", fn,
                status ));

            if ( status != ERROR_SUCCESS )
            {
                if ( LDAP_NO_SUCH_OBJECT == status )
                {
                    DNS_DEBUG(DS2, ("Cannot find node %s in the DS\n",pnode->szLabel));
                    bNewNode = TRUE;
                }
                else
                {
                    DNS_DEBUG( ANY, (
                        "Error <%lu>: readAndUpdateNodeSecurityFromDs failed\n",
                        status ));
                    //
                    // Clearing all flags for a clean bail out
                    // In properly operational OS we should not fail on the
                    // call above.
                    // Thus, we do not proceed w/ other attempts, but just bail out.
                    //

                    CLEAR_NODE_SECURITY_FLAGS(pnode);
                    CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                    goto Failed;
                }
            }

            else
            {
                //
                // object exists on the DS, we can process further
                //

                //
                // A. DO WE NEED TO PREP SECURITY?
                //
                // In other words, a node security should be updated iff:
                // 1. It is marked as belonging to Authenticated Users (basically, open) BUT
                //    the client is not in the proxy group (to prevent dhcp client pingpong) OR
                // 2. It is tombstone  OR
                // 3. It's security stamp is old
                //
                //

                // identify client. is it in the preferred proxy group?
                bProxyClient = SD_IsProxyClient( hClientToken );

                DNS_DEBUG( DS2, (
                    "%s: testing SD fixup for node %p\n"
                    "    pnode->wNodeFlags    0x%08X\n"
                    "    pUpdateList->Flag    0x%08X\n"
                    "    bProxyClient         %d\n"
                    "    pClientSD            0x%08x\n", fn,
                    pnode,
                    pnode->dwNodeFlags,
                    pUpdateList->Flag,
                    bProxyClient,
                    pClientSD ));

                if ( ( IS_AVAIL_TO_AUTHUSER(pnode)          &&
                       !bProxyClient )                      ||
                       IS_SECURITY_UPDATE_NODE(pnode) )
                {
                     //
                     // If we're here, then we should modify the node SD
                     // so that client can write update.
                     // Note, we're using server connection handle (not client context)
                     // to slap the new SD
                     //
                     DNS_DEBUG(DS2, (" > preparing to write SD on node %p\n", pnode));

                     if( !pClientSD )
                     {

                        // CREATE SECURITY DESCRIPTOR
                        // create client sd only first time needed through the loop
                        // or when it is not admin intervention
                        //

                        if ( ( pUpdateList->Flag & DNSUPDATE_ADMIN ) &&
                             ( pUpdateList->Flag & DNSUPDATE_OPEN_ACL ) ||
                             bProxyClient )
                        {

                            //
                            // CREATE OPEN NODE SECURITY DESCRIPTOR
                            //
                            // if
                            // 1. Admin modifies
                            // 2. Proxy client modifies a security-udpate-enabled node.
                            //
                            DNS_DEBUG( DS2, (
                                " > Creating OPENED-SECURITY node (flags = 0x%x)\n",
                                pnode->dwNodeFlags));
                            bAllowWorld = TRUE;
                        }

                        status = SD_CreateClientSD(
                                         &pClientSD,
                                         pZone->pSD ?
                                                pZone->pSD :
                                                g_pDefaultServerSD,     //  base SD
                                         g_pServerSid,                  //  owner SID
                                         g_pServerGroupSid,             //  group SID
                                         bAllowWorld );

                        if ( status != ERROR_SUCCESS )
                        {
                            DNS_DEBUG( UPDATE2, ( "Error <%lu>: failed to create SD\n", status ));
                            ASSERT(FALSE);
                            pClientSD = NULL;
                            CLEAR_NODE_SECURITY_FLAGS(pnode);
                            CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                            goto Failed;
                        }
                    }
                    //
                    // else use sd from prev cycle
                    //

                    //
                    // WRITE SECURITY
                    // slap SD on the object
                    //
                    
                    status = Ds_WriteNodeSecurityToDs( pZone, pnode, pClientSD );
                    if( status != ERROR_SUCCESS )
                    {
                       //
                       // any error
                       //
                       DNS_DEBUG( DS, (
                           "Failed to write client SD for node %s\n"
                           "    status = %d\n",
                           pnode->szLabel,
                           status ));
                       //
                       // Fow now we don't continue, letting the client attempt write the update
                       // using whatever rights it has.
                       //
                    }

                    //
                    // clear security flags, don't need them anymore
                    //

                    CLEAR_NODE_SECURITY_FLAGS(pnode);
                    CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                }

            }       // got security info

        }          // we're in secure zone update


        //
        //  write updated record list for node
        //
        //  currently single RR attribute, so write always specify TYPE_ALL
        //
        //  if go to specific type attributes, should probably just
        //  add or delete specific RR set
        //      - replace with CURRENT (possibly empty) RR set
        //
        //  (note, how even the DS is smarter than IXFR and needs only
        //  new set)
        //
        
        dwdsWriteFlags = pUpdateList->Flag;
        if ( bNewNode )
        {
            dwdsWriteFlags |= DNSUPDATE_NEW_RECORD;
        }

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnode,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    dwdsWriteFlags );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node label %s on secure update\n"
                    "    status = %p %d\n",
                    pnode->szLabel,
                    status, status ));

                CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                break;
            }
        }

        //
        //  POST UPDATE SECURITY FIX FOR NEW NODES ONLY
        //
        //  fix security if node just got created or client is in proxy group
        //

        DNS_DEBUG( DS2, (
            "%s: test need to write SD on new node %p\n"
            "    pZone->fAllowUpdate  %d\n"
            "    bNewNode             %d\n"
            "    pnode->dwNodeFlags   0x%08X\n"
            "    pUpdateList->Flag    0x%08X\n"
            "    hClientToken         %p\n"
            "    is proxy client      %d\n", fn,
            pnode,
            ( int ) pZone->fAllowUpdate,
            ( int ) bNewNode,
            ( int ) pnode->dwNodeFlags,
            ( int ) pUpdateList->Flag,
            ( void * ) hClientToken,
            ( int ) SD_IsProxyClient( hClientToken ) ));

        if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE      &&
             bNewNode                                       &&
             ( ( pUpdateList->Flag & DNSUPDATE_ADMIN )      ||
                SD_IsProxyClient( hClientToken ) ) )
        {
            //
            //  Create security descriptor.
            //

            DNS_DEBUG(DS2, (" > preparing to write SD on NEW NODE %p\n", pnode));

            //  Should never have an existing SD - if do, should free!
            ASSERT( !pClientSD );

            //
            //  Allow world if the update is either a DNS wire update
            //  packet or if it is an admin update that has OPEN_ACL.
            //

            status = SD_CreateClientSD(
                            &pClientSD,
                            pZone->pSD ?
                                pZone->pSD :
                                g_pDefaultServerSD,
                            g_pServerSid,
                            g_pServerGroupSid,
                            pUpdateList->Flag &
                                ( DNSUPDATE_OPEN_ACL | DNSUPDATE_PACKET )
                                ? TRUE
                                : FALSE );

            if ( status == ERROR_SUCCESS )
            {
                status = Ds_WriteNodeSecurityToDs( pZone, pnode, pClientSD );
            }
            else
            {
                DNS_PRINT(( "FAILURE: cannot create client SD\n" ));
                ASSERT( status == ERROR_SUCCESS );
            }
        }

        CLEAR_AVAIL_TO_AUTHUSER_NODE( pnode );

        DNS_DEBUG( DS2, (
            "Cleared node(%p) flags 0x%x\n",
            pnode,
            pnode->dwNodeFlags ));
    }

    //  clear new update serial number

    pZone->dwNewSerialNo = 0;

Failed:

    //  save pointer to failing temp node
    //  secure update can use this to roll back DS writes already completed

    if ( pnode )
    {
        ASSERT( status != ERROR_SUCCESS );
        pUpdateList->pNodeFailed = pnode;
    }

    //
    //  free allocated SD
    //

    if ( pClientSD )
    {
        FREE_HEAP( pClientSD );
    }

    DNS_DEBUG( DS, (
        "Leaving %s(), zone %s\n"
        "    status = %d\n", fn,
        pZone->pszZoneName,
        status ));

    if ( hClientToken)
    {
       CloseHandle( hClientToken );
    }

    return status;
}   //  Ds_WriteUpdateToDs



DNS_STATUS
Ds_WriteNonSecureUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

    DEVNOTE-DCR: 455357 - eliminate re-reading of data after update

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pnode;
    PDB_NODE        pnodePrevious = NULL;
    PUPDATE         pupdate;


    DNS_DEBUG( DS, (
        "Ds_WriteNonSecureUpdateToDs() for zone %s\n",
        pZone->pszZoneName ));

    //  must have already opened zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( pZone->fDsIntegrated );
    ASSERT( pZone->dwNewSerialNo != 0 );


    //
    //  loop through all temp nodes
    //      - write only those marked writable
    //      (some update nodes might have no-op'd out
    //

    STAT_INC( DsStats.UpdateLists );

    for ( pnode = pUpdateList->pTempNodeList;
          pnode != NULL;
          pnode = TNODE_NEXT_TEMP_NODE(pnode) )
    {
        //
        //  if no write required, skip
        //

        STAT_INC( DsStats.UpdateNodes );

        if ( !TNODE_NEEDS_DS_WRITE( pnode ) )
        {
            STAT_INC( DsStats.DsWriteSuppressed );
            STAT_INC( DsStats.UpdateSuppressed );
            continue;
        }

        //
        //  write updated record list for node
        //  currently single RR attribute, so write always specify TYPE_ALL
        //
        //  if go to specific type attributes, should probably just
        //  add or delete specific RR set
        //      - replace with CURRENT (possibly empty) RR set
        //
        //  (note, how even the DS is smarter than IXFR and needs only
        //  new set)
        //

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnode,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    pUpdateList->Flag );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node label %s on secure update\n"
                    "    status = %p %d\n",
                    pnode->szLabel,
                    status, status ));
                break;
            }
        }

        DNS_DEBUG( DS2, (
            "Cleared node(%p) flags 0x%x\n",
            pnode,
            pnode->dwNodeFlags ));
    }

    //  clear new update serial number

    pZone->dwNewSerialNo = 0;

    // Failed: this is where we would like to have this label if we had
    // a goto...

    //  save pointer to failing temp node
    //  secure update can use this to roll back DS writes already completed

    if ( pnode )
    {
        ASSERT( status != ERROR_SUCCESS );
        pUpdateList->pNodeFailed = pnode;
    }

    DNS_DEBUG( DS, (
        "Leaving Ds_WriteNonSecureUpdateToDs(), zone %s\n"
        "    status = %p\n",
        pZone->pszZoneName,
        status ));

    return status;
}   //  Ds_WriteNonSecureUpdateToDs



//
//  DS Property routines
//

DNS_STATUS
setPropertyValueToDsProperty(
    IN      PDS_PROPERTY    pProperty,
    IN      PVOID           pData,
    IN      DWORD           dwDataLength    OPTIONAL
    )
/*++

Routine Description:

    Write DS property structure to buffer.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pProperty -- property struct read from DS

    pData -- ptr to position to write data;

        if this is allocated property (dwDataLength == 0), then pData
        is address  to receive ptr to newly allocated property

        note, it's caller's responsibility to manage "disposal" of
        previous property -- if any

    dwDataLength -- max datalength (if zero, allocate memory) and
        pData receives ptr

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_DATA on error.

--*/
{
    DNS_DEBUG( DS, (
        "setPropertyValueToDsProperty()\n"
        "    property     = %p\n"
        "    data         = %p\n"
        "    data length  = %d\n",
        pProperty,
        pData,
        dwDataLength ));

    //
    //  DEVNOTE: could implement version validation here
    //

    if ( pProperty->Version != DS_PROPERTY_VERSION_1 )
    {
        ASSERT( FALSE );
        goto Failed;
    }

    //  fixed length property -- just copy in

    if ( dwDataLength )
    {
        if ( dwDataLength != pProperty->DataLength )
        {
            DNS_PRINT((
                "ERROR: Invalid property datalength\n" ));
            ASSERT( FALSE );
            goto Failed;
        }
        RtlCopyMemory(
            pData,
            pProperty->Data,
            dwDataLength );
    }

    //
    //  allocated property
    //      - allocate blob of required size and copy in
    //      - free old value (if any)
    //      - special case NULL property
    //

    else if ( pProperty->DataLength == 0 )
    {
        * ((PCHAR *)pData) = NULL;
    }

    else
    {
        PCHAR   pch;

        pch = ALLOC_TAGHEAP( pProperty->DataLength, MEMTAG_DS_PROPERTY );
        IF_NOMEM( !pch )
        {
            goto Failed;
        }
        RtlCopyMemory(
            pch,
            pProperty->Data,
            pProperty->DataLength );

        * ((PCHAR *)pData) = pch;
    }

    return ERROR_SUCCESS;

Failed:

    DNS_PRINT((
        "ERROR: Invalid DS property!\n"
        "    DataLength   = %d\n"
        "    Id           = %d\n"
        "    Version      = %d\n",
        pProperty->DataLength,
        pProperty->Id,
        pProperty->Version ));

    return ERROR_INVALID_DATA;
}



PDNS_ADDR_ARRAY
getIpArrayFromDsProp(
    PZONE_INFO          pZone,
    DWORD               dwPropertyID,
    PDS_PROPERTY        pProperty
    )
/*++

Routine Description:

    Read, allocate, and validate an IP_ARRAY from a DS property.

Arguments:

    pProperty -- source property

    dwPropertyID -- ID of property pProperty was read from

    pZone -- zone we're reading

Return Value:

    Returns NULL if property did not contain valid IP_ARRAY, otherwise
    returns a ptr to a newly allocated IP_ARRAY.

--*/
{
    PDNS_ADDR_ARRAY     piparray = NULL;
    PIP4_ARRAY          pip4array = NULL;

    setPropertyValueToDsProperty(
        pProperty,
        &pip4array,
        0 );                // allocate memory

    //
    //  Validate memory blob as IP array. Treat empty array like NO array.
    //

    if ( pip4array )
    {
        if ( Dns_SizeofIpArray( pip4array ) != pProperty->DataLength ||
             pip4array->AddrCount == 0 )
        {
            DNS_DEBUG( ANY, (
                "ERROR: read invalid IP array DS property %X\n"
                "    zone = %S\n"
                "    Not valid IP array OR IP array is empty\n",
                dwPropertyID,
                pZone->pwsZoneName ));

            ASSERT( !"read invalid IP array property value from DS" );
        }
        
        if ( pip4array )
        {
            piparray = DnsAddrArray_CreateFromIp4Array( pip4array );
            
            //
            //  Set ports to 53.
            //
            
            DnsAddrArray_SetPort( piparray, DNS_PORT_NET_ORDER );
        }

        IF_DEBUG( DS2 )
        {
            DNS_PRINT((
                "Read IP array DS property %X for zone %S\n",
                dwPropertyID,
                pZone->pwsZoneName ));
            DnsDbg_DnsAddrArray(
                "DS property IP array:\n",
                "IP",
                piparray );
        }
    }
    ELSE
    {
        DNS_DEBUG( DS2, (
            "No IP array read for property %X zone %S\n",
            dwPropertyID,
            pZone->pwsZoneName ));
    }

    FREE_HEAP( pip4array );

    return piparray;
}   //  getIpArrayFromDsProp



DNS_STATUS
rewriteRootHintsSecurity(
    IN      PLDAP                   LdapSession,
    IN      PLDAPMessage            pentry,
    IN      PSECURITY_DESCRIPTOR    pSd
    )
/*++

Routine Description:

    Read zone properties from zone message. The error code is fluffy
    because the caller doesn't really care if we succeed or not. This is
    a self-contained DS fix-up operation.

    History: the default SD for all DS-integrated zones, including the
    roothint zone, contains an Autheticated Users allow ACE. This allows
    for new records to be created through dynamic update. However, for the
    root hint zone Authenticated Users has need for access, so we take a
    sledgehammer approach and remove any ACE granting any access to
    Authenticated Users on the roothint zone.

Arguments:

    LdapSession -- ldap session handle

    pentry -- entry pointing at DS roothints zone object

    pSd -- pointer to security descriptor read from pentry's object

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "rewriteRootHintsSecurity" )

    DNS_STATUS                  status = ERROR_SUCCESS;
    BOOL                        fwriteback = FALSE;
    PWSTR                       pdn = NULL;
    PSID                        psidAuthUsers = NULL;
    BOOL                        fdaclPresent = FALSE;
    BOOL                        fdaclDefaulted = FALSE;
    PACL                        pacl = NULL;
    DWORD                       dwaceIndex;
    PVOID                       pace = NULL;
    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;

    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    DNS_LDAP_SINGLE_MOD     modSd;
    LDAPModW *              modArray[] = { &modSd.Mod, NULL };

    //
    //  Get the SID of Authenticated Users so we can compare against it.
    //
    
    if( !AllocateAndInitializeSid( 
                   &ntAuthority,
                   1,
                   SECURITY_AUTHENTICATED_USER_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &psidAuthUsers ) )
    {
        DNS_DEBUG( DS, (
            "%s: error retrieving Authenticated Users SID\n", fn ));
        goto Done;
    }
    
    //
    //  Get the DACL from the security descriptor.
    //

    if ( !GetSecurityDescriptorDacl(
                pSd,
                &fdaclPresent,
                &pacl,
                &fdaclDefaulted ) ||
         fdaclPresent == FALSE ||
         pacl == NULL )
    {
        DNS_DEBUG( DS, (
            "%s: no dacl! fdaclPresent=%d pacl=%p\n", fn,
            fdaclPresent,
            pacl ));
        goto Done;
    }

    //
    //  Scan the DACL looking for Authenticated Users ACE.
    //

    for ( dwaceIndex = 0;
          dwaceIndex < pacl->AceCount &&
            GetAce( pacl, dwaceIndex, &pace ) &&
            pace;
          ++dwaceIndex )
    {
        PSID    pthisSid;

        if ( ( ( ACE_HEADER *) pace )->AceType != ACCESS_ALLOWED_ACE_TYPE )
        {
            continue;
        }
        pthisSid = ( PSID ) ( &( ( ACCESS_ALLOWED_ACE * ) pace )->SidStart );
        if ( RtlEqualSid( pthisSid, psidAuthUsers ) )
        {
            DNS_DEBUG( DS, (
                "%s: deleting ACE index=%d for Authenticated Users\n", fn,
                dwaceIndex ));
            DeleteAce( pacl, dwaceIndex );
            fwriteback = TRUE;
            break;      //  Assume only one Auth Users ACE so break.
        }
    }

    if ( !fwriteback )
    {
        goto Done;
    }

    //
    //  Write the updated SD back to the directory.
    //

    pdn = ldap_get_dn( LdapSession, pentry );
    if ( !pdn )
    {
        DNS_DEBUG( DS, (
            "%s: unable to get DN of entry %p\n", fn,
            pentry ));
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    INIT_SINGLE_MOD_LEN( &modSd );
    modSd.Mod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    modSd.Mod.mod_type = DSATTR_SD;
    modSd.Mod.mod_bvalues[0]->bv_val = ( LPVOID ) pSd;
    modSd.Mod.mod_bvalues[0]->bv_len = GetSecurityDescriptorLength( pSd );

    status = ldap_modify_ext_s(
                    LdapSession,
                    pdn,
                    modArray,
                    ctrls,              // server controls
                    NULL );             // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: modify got ldap error 0x%X\n", fn,
            status ));
        status = Ds_ErrorHandler( status, pdn, LdapSession, 0 );
    }

    DNS_DEBUG( DS, (
        "%s: wrote modified SD back to\n  %S\n", fn,
        pdn ));

    //
    //  Cleanup and return.
    //

    Done:

    if ( psidAuthUsers )
    {
        FreeSid( psidAuthUsers );
    }
    if ( pdn )
    {
        ldap_memfree( pdn );
    }

    return status;
}   //  rewriteRootHintsSecurity



DNS_STATUS
Ds_ReadZoneProperties(
    IN OUT  PZONE_INFO      pZone,
    IN      PLDAPMessage    pZoneMessage    OPTIONAL
    )
/*++

Routine Description:

    Read zone properties from zone message.

Arguments:

    pZoneMessage -- LDAP message with zone info

    ppZone -- addr to receive zone pointer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    struct berval **    ppvalProperty = NULL;
    DNS_STATUS          status = ERROR_SUCCESS;
    PDS_PROPERTY        property;
    INT                 i;
    PLDAPMessage        msg = NULL;
    PLDAPMessage        pentry;
    BOOL                bOwnSearchMessage = FALSE;
    DWORD               searchTime;
    DWORD               oldValue;
    UCHAR               byteValue;
    PWSTR               propAttrs[] =
    {
        DSATTR_DNSPROPERTY,
        DSATTR_SD,
        DNS_ATTR_OBJECT_GUID,
        NULL
    };
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };
    PSECURITY_DESCRIPTOR    pSd = NULL;
    PGUID                   pnewguid = NULL;

    DNS_DEBUG( DS, ( "Ds_ReadZoneProperties()\n" ));

    //
    //  if have zone property message -- use it
    //  otherwise search for zone
    //
    //  DEVNOTE: could we search with a USN changed filter?
    //

    if ( pZoneMessage )
    {
        pentry = pZoneMessage;
    }
    else
    {
        //
        //  search for zone
        //

        DS_SEARCH_START( searchTime );

        status = ldap_search_ext_s(
                        pServerLdap,
                        pZone->pwszZoneDN,
                        LDAP_SCOPE_BASE,
                        g_szDnsZoneFilter,
                        propAttrs,
                        FALSE,
                        ctrls,
                        NULL,
                        &g_LdapTimeout,
                        0,
                        &msg );

        DS_SEARCH_STOP( searchTime );

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Error <%lu>: failed to get zone property. %S\n",
                status,
                ldap_err2string(status) ));
            return Ds_ErrorHandler( status, pZone->pwszZoneDN, pServerLdap, 0 );
        }

        bOwnSearchMessage = TRUE;

        pentry = ldap_first_entry( pServerLdap, msg );
        if ( !pentry )
        {
            DNS_DEBUG( DS, (
                "Error: failed to get zone property. No such object\n" ));
            status = LDAP_NO_SUCH_OBJECT;
            goto Done;
        }
    }

    ASSERT( pentry );

    //
    //  read zone ntSecurityDescriptor
    //      - replace in memory copy
    //

    ppvalProperty = ldap_get_values_len(
                        pServerLdap,
                        pentry,
                        DSATTR_SD );

    if ( !ppvalProperty  ||  !ppvalProperty[0] )
    {
        DNS_PRINT((
            "ERROR: missing ntSecurityDescriptor attribute on zone %s\n",
            pZone->pszZoneName ));

        //  DEVNOTE: if we can tolerate this failure, and drop to property
        //      read ... then need to cleanup ppvalProperty if exists

        ASSERT( FALSE );
        status = LDAP_NO_SUCH_OBJECT;
        goto Done;
    }
    else
    {
        //  copy security descriptor onto zone

        DWORD   sdLen = ppvalProperty[ 0 ]->bv_len;

        pSd = ALLOC_TAGHEAP( sdLen, MEMTAG_DS_PROPERTY );
        IF_NOMEM( !pSd )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        RtlCopyMemory(
            pSd,
            (PSECURITY_DESCRIPTOR) ppvalProperty[0]->bv_val,
            ppvalProperty[0]->bv_len );

        //
        //  Munge the SD on the cache zone, writing it back if necessary.
        //

        if ( IS_ZONE_ROOTHINTS( pZone ) )
        {
            rewriteRootHintsSecurity(
                pServerLdap,
                pentry,
                pSd );
        }

        //  replace SD

        Zone_UpdateLock( pZone );

        Timeout_FreeAndReplaceZoneData( pZone, &pZone->pSD, pSd );
        pZone->dwSdLen = sdLen;

        Zone_UpdateUnlock( pZone );

        ldap_value_free_len( ppvalProperty );
    }

    //
    //  get zone's properties
    //

    ppvalProperty = ldap_get_values_len(
                        pServerLdap,
                        pentry,
                        DSATTR_DNSPROPERTY );
    if ( !ppvalProperty )
    {
        DNS_PRINT((
            "No property attribute on zone %s\n",
            pZone->pszZoneName ));
        //ASSERT( FALSE );
    }
    else
    {
        i = 0;
        while ( ppvalProperty[i] )
        {
            property = (PDS_PROPERTY) ppvalProperty[i]->bv_val;
            i++;

            DNS_DEBUG( DS, (
                "Found DS zone property %d\n"
                "    data length = %d\n",
                property->Id,
                property->DataLength ));

            switch ( property->Id )
            {

            case DSPROPERTY_ZONE_TYPE:

                setPropertyValueToDsProperty(
                   property,
                   (PCHAR) & pZone->fZoneType,
                   sizeof( pZone->fZoneType ) );
                DNS_DEBUG( DS2, (
                    "Setting zone type to %d\n",
                    pZone->fZoneType ));
                break;

            case DSPROPERTY_ZONE_SECURE_TIME:

                setPropertyValueToDsProperty(
                   property,
                   (PCHAR) & pZone->llSecureUpdateTime,
                   sizeof(LONGLONG) );
                DNS_DEBUG( DS2, (
                    "Setting zone secure time to %I64d\n",
                    pZone->llSecureUpdateTime));
                break;

            case DSPROPERTY_ZONE_DCPROMO_CONVERT:

                setPropertyValueToDsProperty(
                    property,
                    ( PCHAR ) &pZone->dwDcPromoConvert,
                    sizeof( pZone->dwDcPromoConvert ) );
                DNS_DEBUG( DS2, (
                    "Setting zone dcpromo convert flag to %d\n",
                    pZone->dwDcPromoConvert ));
                break;

            case DSPROPERTY_ZONE_ALLOW_UPDATE:

                oldValue = pZone->fAllowUpdate;

                setPropertyValueToDsProperty(
                    property,
                    & byteValue,
                    1 );

                DNS_DEBUG( DS2, (
                    "Read update property = %d\n",
                    byteValue ));

                pZone->fAllowUpdate = (DWORD) byteValue;

                //
                //  if turning update ON
                //      - reset scavenging start time, as won't have been doing aging
                //          updates while update was off
                //      - notify netlogon if turning on updates on an existing zone
                //

                if ( pZone->fAllowUpdate != oldValue &&
                     pZone->fAllowUpdate != ZONE_UPDATE_OFF )
                {
                    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

                    if ( g_ServerState != DNS_STATE_LOADING && !IS_ZONE_REVERSE( pZone ) )
                    {
                        Service_SendControlCode(
                            g_wszNetlogonServiceName,
                            SERVICE_CONTROL_DNS_SERVER_START );
                    }
                }
                DNS_DEBUG(DS2, ("Setting zone fAllowUpdate to %d\n", pZone->fAllowUpdate));
                break;

            case DSPROPERTY_ZONE_NOREFRESH_INTERVAL:

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->dwNoRefreshInterval,
                    sizeof(DWORD) );
                DNS_DEBUG(DS2, ("Setting zone NoRefreshInterval to %lu\n", pZone->dwNoRefreshInterval));
                break;

            case DSPROPERTY_ZONE_REFRESH_INTERVAL:

                oldValue = pZone->dwRefreshInterval;

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->dwRefreshInterval,
                    sizeof(DWORD) );
                DNS_DEBUG( DS2, ( "Setting zone RefreshInterval to %lu\n", pZone->dwRefreshInterval));
                break;

            case DSPROPERTY_ZONE_AGING_STATE:

                oldValue = pZone->bAging;

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->bAging,
                    sizeof(DWORD) );

                DNS_DEBUG( DS2, ("Setting zone bAging to %d\n", pZone->bAging));

                //  if scavenging turning ON, then change start of scavenging
                //      to be refresh interval from now

                if ( pZone->bAging && !oldValue )
                {
                    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
                }
                break;

            case DSPROPERTY_ZONE_SCAVENGING_SERVERS:
            {
                PDNS_ADDR_ARRAY     pipArray;

                pipArray = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_SCAVENGING_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneIPArray(
                    pZone,
                    &pZone->aipScavengeServers,
                    pipArray );
                break;
            }

            case DSPROPERTY_ZONE_AUTO_NS_SERVERS:
            {
                PDNS_ADDR_ARRAY     pipArray;

                pipArray = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_AUTO_NS_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneIPArray(
                    pZone,
                    &pZone->aipAutoCreateNS,
                    pipArray );
                break;
            }


            case DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME:
            {
                PWSTR       pwsDeletedFromHost = NULL;

                setPropertyValueToDsProperty(
                    property,
                    &pwsDeletedFromHost,
                    0 );        //  allocate memory
                Timeout_FreeAndReplaceZoneData(
                    pZone,
                    &pZone->pwsDeletedFromHost,
                    pwsDeletedFromHost );
                break;
            }

            case DSPROPERTY_ZONE_MASTER_SERVERS:
            {
                PDNS_ADDR_ARRAY     piparray;

                piparray = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_MASTER_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneIPArray(
                    pZone,
                    &pZone->aipMasters,
                    piparray );
                break;
            }

            default:

                DNS_DEBUG( ANY, (
                    "ERROR: Unknown property ID %d, read from DS!!!\n",
                    property->Id ));
            }
        }
    }
    
    //
    //  Read the zone object's GUID and save it.
    //

    if ( ppvalProperty )
    {
        ldap_value_free_len( ppvalProperty );
    }

    ppvalProperty = ldap_get_values_len(
                        pServerLdap,
                        pentry,
                        DNS_ATTR_OBJECT_GUID );
    if ( ppvalProperty &&
         ppvalProperty[ 0 ] &&
         ppvalProperty[ 0 ]->bv_len == sizeof( GUID ) )
    {
        pnewguid = ALLOC_TAGHEAP( ppvalProperty[ 0 ]->bv_len, MEMTAG_DS_OTHER );
        if ( pnewguid )
        {
            RtlCopyMemory(
                pnewguid,
                ppvalProperty[ 0 ]->bv_val,
                ppvalProperty[ 0 ]->bv_len );
        }
    }
    ASSERT( ppvalProperty &&
            ppvalProperty[ 0 ] &&
            ppvalProperty[ 0 ]->bv_len == sizeof( GUID ) );

    //
    //  Save GUID in zone structure. If we did not get a new GUID, leave the
    //  existing zone GUID in place (or NULL).
    //
    
    if ( pnewguid )
    {
        Timeout_FreeAndReplaceZoneData(
            pZone,
            &pZone->pZoneObjectGuid,
            pnewguid );
    }

    //
    //  DEVNOTE-LOG: log event if busted property in DS
    //  DEVNOTE: self-repair properties, read everything that's readable
    //      then write back to clean up the data
    //

Done:

    //
    //  Check defaults. On DS poll we pick up new zones. Some of the
    //  properties on these zones will be unset since not all zone
    //  properties are stored in the DS.
    //
    
    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        if ( pZone->dwForwarderTimeout == 0 )
        {
            pZone->dwForwarderTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
        }
    }
    
    DNS_DEBUG( DS, (
        "Leaving Ds_ReadZoneProperties()\n"
        "    status = %d (%p)\n",
        status, status ));

    if ( ppvalProperty )
    {
        ldap_value_free_len( ppvalProperty );
    }

    if ( bOwnSearchMessage )
    {
        ldap_msgfree( msg );
    }

    //
    //  Post-processing: set any zone members based on information we just
    //  read in.
    //

    Zone_SetAutoCreateLocalNS( pZone );

    return status;
}



DNS_STATUS
writePropertyToDsNode(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwsDN,
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Write property to DS node.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pLdap -- LDAP session to use or NULL for server ldap session
    
    pwsDN -- DS node to write at

    pModBuffer -- mod buffer containing property mod;
        note, this is cleaned up by this function

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPMod        pmod;
    PLDAPMod        pmodArray[ 3 ];
    int             modIdx = 0;

    LDAPMod         descMod;

    PLDAPControl    controlArray[] =
    {
        lazyCommitControlPtr(),
        NULL
    };
    
    if ( !pLdap )
    {
        pLdap = pServerLdap;
    }
      
    DNS_DEBUG( DS, (
        "writeDnsPropertyToDsNode( %S )\n"
        "    property array   = %p\n"
        "    array count      = %d\n",
        pwsDN,
        pModBuffer,
        pModBuffer->Count ));

    //  build property mod

    pmod = Ds_SetupModForExecution(
                pModBuffer,
                DSATTR_DNSPROPERTY,
                LDAP_MOD_REPLACE | LDAP_MOD_BVALUES );
    if ( !pmod )
    {
        status = GetLastError();
        goto Failed;
    }

    pmodArray[ modIdx++ ] = pmod;

    //
    //  If this is an @ node, set description attribute so that the 
    //  security properties dialog won't show "@".
    //

    if ( pwsDN[ 0 ] && pwsDN[ 1 ] && pwsDN[ 2 ] &&
         pwsDN[ 3 ] == L'@' &&
         pwsDN[ 4 ] == L',' )
    {
        PWSTR   descVals[] =
        {
            DS_SAME_AS_PARENT_DISPLAY_NAME,
            NULL
        };

        descMod.mod_op = LDAP_MOD_REPLACE;
        descMod.mod_type = DSATTR_DISPLAYNAME;
        descMod.mod_values = descVals;
        pmodArray[ modIdx++ ] = &descMod;
    }

    pmodArray[ modIdx++ ] = NULL;

    DNS_DEBUG( DS, (
        "Writing property to DS node %S\n",
        pwsDN ));

    status = ldap_modify_ext_s(
                    pLdap,
                    pwsDN,
                    pmodArray,
                    controlArray,       // include lazy commit control
                    NULL );             // no client controls
    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pwsDN, pServerLdap, 0 );
    }

Failed:

    DNS_DEBUG( ANY, (
        "Leaving writeNodePropertyToDs( %S )\n"
        "    status = %p (%d)\n",
        pwsDN,
        status, status ));

    Ds_CleanupModBuffer( pModBuffer );
    return status;
}



VOID
writeDsPropertyStruct(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwPropId,
    IN      PVOID           pData,
    IN      DWORD           dwDataLength
    )
/*++

Routine Description:

    Write DS property structure to buffer.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pModBuffer -- ptr to buffer to write DS property

    dwPropId -- property ID

    pData -- property data

    dwDataLength -- property data length (in bytes)

Return Value:

    None.

--*/
{
    PDS_PROPERTY    pprop;

    DNS_DEBUG( DS, (
        "writeDsPropertyStruct()\n"
        "    pbuffer      = %p\n"
        "    prop ID      = %d\n"
        "    data         = %p\n"
        "    data length  = %d\n",
        pModBuffer,
        dwPropId,
        pData,
        dwDataLength ));

    //  reserve space for berval

    pprop = ( PDS_PROPERTY ) Ds_ReserveBervalInModBuffer(
                                pModBuffer,
                                sizeof( DS_PROPERTY ) + dwDataLength );
    if ( !pprop )
    {
        ASSERT( FALSE );
        return;
    }

    //  write property

    pprop->DataLength   = dwDataLength;
    pprop->Id           = dwPropId;
    pprop->Flag         = 0;
    pprop->Version      = DS_PROPERTY_VERSION_1;

    if ( pData && dwDataLength )
    {
        RtlCopyMemory( pprop->Data, ( PCHAR ) pData, dwDataLength );
    }

    //  write berval for property

    Ds_CommitBervalToMod( pModBuffer, sizeof( DS_PROPERTY ) + dwDataLength );

    return;
}



VOID
writeDnsAddrArrayDsPropertyStruct(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwPropId,
    IN      PDNS_ADDR_ARRAY pDnsAddrArray
    )
/*++

Routine Description:

    Write a DNSADDR array DS property structure to buffer.

    For .NET we will convert to an IP_ARRAY and write. For Longhorn
    we will have to figure out a real solution.

Arguments:

    pModBuffer -- ptr to buffer to write DS property

    dwPropId -- property ID

    pDnsAddrArray -- array of addresses

Return Value:

    None.

--*/
{
    PIP_ARRAY       piparray = NULL;
    
    if ( pDnsAddrArray )
    {
        piparray = DnsAddrArray_CreateIp4Array( pDnsAddrArray );
    }

    writeDsPropertyStruct(
        pModBuffer,
        dwPropId,
        piparray,
        piparray ? Dns_SizeofIpArray( piparray ) : 0 );
}   //  writeDnsAddrArrayDsPropertyStruct



DNS_STATUS
Ds_WriteZoneProperties(
    IN      PLDAP           pLdap,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write zone's properties to DS.

Arguments:

    pLdap -- LDAP session to use or NULL for server ldap session
    
    pZone -- zone info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    BYTE            buffer[ PROPERTY_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;

    if ( !pLdap )
    {
        pLdap = pServerLdap;
    }
    
    DNS_DEBUG( DS, (
        "Ds_WriteZoneProperties( %s )\n",
        pZone->pszZoneName ));

    if ( !pZone->fDsIntegrated )
    {
        DNS_DEBUG( DS, (
            "Ds_WriteZoneProperties( %s ) not a DS zone -- bailing\n",
            pZone->pszZoneName ));
        return ERROR_SUCCESS;
    }

    //
    //  buffer up zone properties as DS property structures
    //

    //  init buffer for data

    Ds_InitModBuffer(
        pmodBuffer,
        PROPERTY_MOD_BUFFER_SIZE,
        I_DSATTR_DNSPROPERTY,
        MAX_ZONE_PROPERTIES,
        0 );        //  no serial needed

    //  zone type

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_TYPE,
        &pZone->fZoneType,
        sizeof( pZone->fZoneType ) );

    //  allow update

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_ALLOW_UPDATE,
        &pZone->fAllowUpdate,
        sizeof(BYTE) );
                       
    //  time when zone went secure

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_SECURE_TIME,
        & pZone->llSecureUpdateTime,
        sizeof(LONGLONG) );

    //
    //  Aging
    //      - enabled on zone
    //      - no-refresh interval
    //      - refresh interval
    //      - IP array of scavenging servers'
    //

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_AGING_STATE,
        & pZone->bAging,
        sizeof(DWORD) );

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_NOREFRESH_INTERVAL,
        & pZone->dwNoRefreshInterval,
        sizeof(DWORD) );

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_REFRESH_INTERVAL,
        & pZone->dwRefreshInterval,
        sizeof(DWORD) );

    //
    //  send zero count if no-exist server
    //

    writeDnsAddrArrayDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_SCAVENGING_SERVERS,
        pZone->aipScavengeServers );

    writeDnsAddrArrayDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_AUTO_NS_SERVERS,
        pZone->aipAutoCreateNS );

    if ( pZone->pwsDeletedFromHost )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME,
            pZone->pwsDeletedFromHost,
            ( wcslen( pZone->pwsDeletedFromHost ) + 1 ) * sizeof( WCHAR ) );
    }

    //  dcpromo flag

    if ( pZone->dwDcPromoConvert )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_DCPROMO_CONVERT,
            &pZone->dwDcPromoConvert,
            sizeof( pZone->dwDcPromoConvert ) );
    }

    //  optionally, write master server list

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        writeDnsAddrArrayDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_MASTER_SERVERS,
            pZone->aipMasters );
    }

    //
    //  perform the DS write
    //

    status = writePropertyToDsNode(
                pLdap,
                pZone->pwszZoneDN,
                pmodBuffer );

    DNS_DEBUG( ANY, (
        "Ds_WriteZoneProperties( %s ) status = %d (%p)\n",
        pZone->pszZoneName,
        status, status ));

    return status;
}


DNS_STATUS
Ds_WriteNodeProperties(
    IN      PDB_NODE      pNode,
    IN      DWORD         dwPropertyFlag
    )
/*++

Routine Description:

    Write node's DNS-property to DS.

    DEVNOTE: JG comments: "this function is not good". Currently this function
    is called from ResetZoneDwordProperty(). Could investigate and clean up.

Arguments:

    pZone -- zone info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.
--*/
{
    DNS_STATUS      status;
    BYTE            buffer[ PROPERTY_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    PZONE_INFO      pzone;

    DNS_DEBUG( DS, (
        "Call: Ds_WriteNodeProperties()\n"
        ));

    ASSERT( pNode );

    //  must have zone

    pzone = pNode->pZone;

    if ( !pzone )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //  init buffer for data

    Ds_InitModBuffer(
        pmodBuffer,
        PROPERTY_MOD_BUFFER_SIZE,
        I_DSATTR_DNSPROPERTY,
        MAX_ZONE_PROPERTIES,
        0 );        //  no serial needed

    //
    //  DB_NODE.dwNodeFlags
    //

    if ( dwPropertyFlag & DSPROPERTY_NODE_DBFLAGS )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_NODE_DBFLAGS,
            &pNode->dwNodeFlags,
            sizeof( pNode->dwNodeFlags ) );
    }

    //
    //  Write the time the node's zone went secure.
    //  This is used to update the time stamp on zone's @ node
    //  We must write a modified property so that the timestamp on the DS whenChanged
    //  will get incremented (& the security on the node will not be expired).
    //
    //  DEVNOTE: unnecessary code
    //      the comment means "just needed to touch the node"
    //      so that it will appear to have been written "post-security-change"
    //      alternatively, we could simply special case the root on updates so that it
    //      is NEVER considered expired
    //

    if ( dwPropertyFlag & DSPROPERTY_ZONE_SECURE_TIME )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_SECURE_TIME,
            & pzone->llSecureUpdateTime,
            sizeof(pzone->llSecureUpdateTime) );
    }

    //
    // extract node DN
    //

    status = buildDsNodeNameFromNode(
                wsznodeDN,
                pzone,
                pNode );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG(ANY , (
            "Ds_WriteNodeProperties( %S ) status = %d (%p)\n",
            wsznodeDN,
            status, status ));
        ASSERT(FALSE);
        goto Done;
    }

    //
    //  perform the DS write
    //

    status = writePropertyToDsNode(
                NULL,
                wsznodeDN,
                pmodBuffer );

    DNS_DEBUG( DS, (
        "Ds_WriteNodeProperties( %S ) status = %d (%p)\n",
        wsznodeDN,
        status, status ));

Done:

    //  cleanup in case under the covers we allocated data

    Ds_CleanupModBuffer( pmodBuffer );
    return status;
}




DNS_STATUS
Ds_BuildNodeUpdateFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PDS_SEARCH      pSearchBlob     OPTIONAL
    )
/*++

Routine Description:

    Build update from DS.

    Does NOT execute the update in memory, this is left to the caller.

    DEVNOTE-DCR: 455373 - massage update list - see RAID

Arguments:

    pZone - zone being updated

    pNode - node to check

    pUpdateList - list with update

    pSearchBlob - ptr to search blob;  passed to Ds_ReadNodeRecords() if given

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrDs = NULL;
    BOOL            fmatch;
    BUFFER          buffer;
    DWORD           dwrrCompFlag;

    //
    //  Set up RR comparison flag. We want to check the TTLs always and the
    //  timestamps only if this is an aging zone. If this is a DS-integrated
    //  zone then we should not compare SOA serial numbers because the serial
    //  number of the zone is not represented by the serial number stored in
    //  the DS SOA record.
    //
    
    dwrrCompFlag = DNS_RRCOMP_CHECK_TTL;
    if ( pZone->bAging )
    {
        dwrrCompFlag |= DNS_RRCOMP_CHECK_TIMESTAMP;
    }
    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        dwrrCompFlag |= DNS_RRCOMP_IGNORE_SOA_SERIAL;
    }

    DNS_DEBUG( DS, (
        "Ds_BuildNodeUpdateFromDs() label %s comp flag %04X for zone %s\n",
        pNode->szLabel,
        dwrrCompFlag,
        pZone->pszZoneName ));

    //  must have already opened DS zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }

    //
    //  read this node
    //  if record set at node is identical, no need to write
    //
    //  note this will always fail at authoritative zone \ sub-zone boundaries
    //      as always have mixture of auth and NS-glue and neither DS zone will
    //      have complete set, we'll live with these extra writes -- not a big issue
    //

    status = Ds_ReadNodeRecords(
                pZone,
                pNode,
                &prrDs,
                pSearchBlob );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR: unable to read DS update node!\n"
            "    zone = %s, node = %s\n",
            pZone->pszZoneName,
            pNode->szLabel ));

        return status;
    }

    //
    //  Match data just read from DS to data in memory.
    //

    fmatch = RR_ListIsMatchingList( pNode, prrDs, dwrrCompFlag );
    if ( fmatch )
    {
        RR_ListFree( prrDs );
        DNS_DEBUG( DS, (
            "DS update read -- data matches in memory\n"
            "    zone = %s, node = %s\n",
            pZone->pszZoneName,
            pNode->szLabel ));
        return ERROR_SUCCESS;
    }

    //
    //  if new data, write appropriate update
    //

    ASSERT( pNode->pZone == pZone || !pNode->pZone );

    // STAT_ADD( DsStats.DsUpdateRecordsRead, searchBlob.dwRecordCount );

    //  delete all yields same result as specifying list entries, BUT is
    //      more robust if ever do SIXFR

    Up_CreateAppendUpdate(
          pUpdateList,
          pNode,
          prrDs,
          DNS_TYPE_ALL,             //  delete all existing
          NULL );                   //  no specific delete records

    DNS_DEBUG( DS, (
        "DS update read yields new data, update created\n"
        "    zone = %s, node = %s\n",
        pZone->pszZoneName,
        pNode->szLabel ));

    return ERROR_SUCCESS;
}



DNS_STATUS
Ds_UpdateNodeListFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pTempNodeList
    )
/*++

Routine Description:

    Update nodes from DS.

    This is used prior to an update to make sure we are operating on the
    LATEST version of the data from the DS.

Arguments:

    pZone - zone being updated

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    UPDATE_LIST     updateList;
#if DBG
    DWORD           updateTime = GetCurrentTime();
#endif


    DNS_DEBUG( DS, (
        "\nDs_UpdateNodeListFromDs() for zone %s\n",
        pZone->pszZoneName ));

    //  skip DS init
    //  must be running and have loaded zone from DS to make this call
    //
    //  zone which is freshly created, and is NOT in the DS can hit this when it tries
    //  to write default records back to DS
    //

    // ASSERT( pZone->pwszZoneDN );

    if ( !pZone->pwszZoneDN )
    {
        DNS_PRINT((
            "ERROR: Fixing zone DN in update %s!\n"
            "    Ok if initial zone create\n",
            pZone->pszZoneName ));

        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        IF_NOMEM( !pZone->pwszZoneDN )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }

    //  init update list

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    //  setup search blob
    //  only purpose is to track highest version read

    Ds_InitializeSearchBlob( &searchBlob );
    searchBlob.pZone = pZone;

    //
    //  loop through temp nodes in update list
    //      - read DS for node
    //      - if different add update to list
    //
    //  note: could simply build update for all data, but direct list compare
    //      is a simpler operation than executing a big add update and having
    //      all the adds be no-op duplicates
    //
    //      furthermore, executing a full RR list whack-n-add current doesn't
    //      do a list compare, but simply whack's and adds
    //

    pnodeTemp = pTempNodeList;

    while ( pnodeTemp )
    {
        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        status = Ds_BuildNodeUpdateFromDs(
                    pZone,
                    pnodeReal,
                    & updateList,
                    & searchBlob );

        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            //
            //  just continue as DS read may fail, simply because object not there
            //

            DNS_DEBUG( ANY, (
                "WARNING: continuing through error = %p (%d)\n"
                "    updating node (label=%s) from DS\n",
                status, status,
                pnodeReal->szLabel ));

            //  could execute updates on failure, but we do that on next
            //      poll anyway -- just quit

            status = ERROR_SUCCESS;
        }
        else if ( status != ERROR_SUCCESS )
        {
            //
            // Error loading data from the DS. No use to continue.
            // (we'd covered no such object case above).
            // We can't ignore this since it can results w/ inconsistent sync
            // w/ the DS.
            //

            DNS_DEBUG( ANY, (
                "ERROR: Failed reading from the DS. status = %p (%d)\n"
                "    updating node (label=%s) from DS\n",
                status, status,
                pnodeReal->szLabel ));

            break;
        }
        //freadNode = TRUE;
        DsStats.DsUpdateNodesRead++;

        pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp);
    }

    //  most of the time, nodes have NOT been updated,

    if ( !updateList.pListHead )
    {
        DNS_DEBUG( DS, (
            "No DS changes read for nodes in pending update in zone %s\n",
            pZone->pszZoneName ));
        ASSERT( updateList.dwCount == 0 );
        return ERROR_SUCCESS;
    }

    //
    //  execute updates in memory
    //

    status = Up_ApplyUpdatesToDatabase(
                & updateList,
                pZone,
                DNSUPDATE_DS
                );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
    }

    //
    //  finish update
    //      - reset zone serial for highest version read
    //      - no zone unlock, done in actual update
    //      - no rewriting records to DS
    //      - no notify, actual update will notify when it is done
    //

    if ( status == ERROR_SUCCESS )
    {
        Zone_UpdateVersionAfterDsRead(
            pZone,
            searchBlob.dwHighestVersion,    // highest serial read
            FALSE,                          // not zone load
            0 );
        Up_CompleteZoneUpdate(
            pZone,
            &updateList,
            DNSUPDATE_NO_UNLOCK |
                DNSUPDATE_NO_INCREMENT |
                DNSUPDATE_NO_NOTIFY );
    }
    else
    {
        Up_FreeUpdatesInUpdateList( &updateList );
    }

    DNS_DEBUG( DS, (
        "Leaving DsUpdateNodeListFromDs of zone %s\n"
        "    read %d records from DS\n"
        "    highest version read     = %d\n"
        "    update time              = %d (ms)\n"
        "    update interval          = %d (ms)\n"
        "    status = %p (%d)\n",
        pZone->pszZoneName,
        searchBlob.dwTotalRecords,
        searchBlob.dwHighestVersion,        // highest serial8 read
        updateTime,
        GetCurrentTime() - updateTime,
        status, status ));

    return status;
}



BOOL
isDNinDS(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDn,
    IN      ULONG           Scope,
    IN      PWSTR           pszFilter,  OPTIONAL
    IN OUT  PWSTR  *        pFoundDn    OPTIONAL
    )
/*++

Routine Description:

    Is given domain name (DN) in DS.

Arguments:

    pLdap -- ldap handle

    pwszDn -- name (DN) to check

    Scope -- search scope

    pszFilter -- search filter

    pFoundDn  -- optional;  addr to recevie ptr to allocated DN (if found)

Return Value:

    TRUE if name is found in DS.
    FALSE otherwise.

--*/
{
    ULONG           status;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry;
    DWORD           searchTime;
    PLDAPControl    ctrls[] = {
                            &NoDsSvrReferralControl,
                            NULL
                            };

    DNS_DEBUG( DS, (
        "isDnInDs() for %S\n",
        pwszDn ));

    if ( pFoundDn )
    {
        *pFoundDn = NULL;
    }
    
    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pLdap,
                    pwszDn,
                    Scope,
                    pszFilter ? pszFilter : g_szWildCardFilter,
                    NULL,
                    TRUE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg );

    DS_SEARCH_STOP( searchTime );

    ASSERT( status == ERROR_SUCCESS || status == LDAP_NO_SUCH_OBJECT );

    if ( status == ERROR_SUCCESS )
    {
        pentry = ldap_first_entry( pLdap, presultMsg );
        if ( pentry )
        {
            //  optionally, copy DN found

            if ( pFoundDn )
            {
                PWSTR  ptmp;
                PWSTR  pname;

                ptmp = ldap_get_dn( pLdap, presultMsg );
                ASSERT( ptmp );

                *pFoundDn = pname = ALLOC_TAGHEAP(
                                        (wcslen(ptmp) + 1) * sizeof(WCHAR),
                                        MEMTAG_DS_DN );
                if ( pname )
                {
                    wcscpy( pname, ptmp );
                }
                ldap_memfree(ptmp);
            }
        }
        else
        {
            status = LDAP_NO_SUCH_OBJECT;
        }
        ldap_msgfree( presultMsg );
    }
    ELSE_ASSERT( !presultMsg );

    return status == ERROR_SUCCESS;
}


DNS_STATUS
addProxiesGroup(
    IN          PLDAP       pLdap
    )
/*++

Routine Description:

    Add dynamic upate proxies security group

Arguments:

    pLdap -- LDAP handle

Return Value:

    ERROR_SUCCESS if successful.
    LDAP error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                bDnInDs;
    PWSTR               dn=NULL;
    DWORD               searchTime;
    PLDAPMessage        presultMsg=NULL;
    PLDAPMessage        pentry=NULL;
    struct berval **    ppbvals=NULL;
    WCHAR               wszDescriptionBuffer[DNS_MAX_NAME_LENGTH]; // use arbitrary large const.

    PWSTR  SidAttrs[] =     {   LDAP_TEXT("objectSid"), NULL };
    PWCHAR pSamAcctName[] = {   SZ_DYNUPROX_SECGROUP, NULL };
    LDAPMod modSamAcct =    {   LDAP_MOD_ADD,
                                LDAP_TEXT("samAccountName"),
                                {pSamAcctName}
                                };
    PWCHAR pObjClass[] =    {   LDAP_TEXT("group"), NULL };
    LDAPMod modObjClass =   {   LDAP_MOD_ADD,
                                LDAP_TEXT("objectClass"),
                                {pObjClass}
                                };
    WCHAR  szGroupType[128];
    PWCHAR pGroupType[] =   {   szGroupType, NULL};
    LDAPMod modGroupType =  {   LDAP_MOD_ADD,
                                LDAP_TEXT("groupType"),
                                {pGroupType}
                                };
    PWCHAR pDescription[] = {   wszDescriptionBuffer,
                                NULL
                                };
    LDAPMod modDescription = {  LDAP_MOD_ADD,
                                LDAP_TEXT("Description"),
                                {pDescription}
                                };
    PLDAPMod mods[] =       {   &modSamAcct,
                                &modObjClass,
                                &modGroupType,
                                &modDescription,
                                NULL
                                };
    WCHAR szFilter[64];


    if ( !pLdap )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // set group type
    //

    _ultow(
        GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_SECURITY_ENABLED,
        szGroupType,
        10);

    // create filter searching for proxy group

    wsprintf( szFilter, L"samAccountName=%s", SZ_DYNUPROX_SECGROUP );

    // search for it in the entire ds by indexed samaccountname attribute

    bDnInDs = isDNinDS(
                    pLdap,
                    DSEAttributes[I_DSE_DEF_NC].pszAttrVal,
                    LDAP_SCOPE_SUBTREE,
                    szFilter,
                    & dn );
    if ( !bDnInDs )
    {
        //
        // create default dn string
        //
        ASSERT ( dn == NULL );

        dn = ALLOC_TAGHEAP(
                    ( wcslen( L"CN=" ) +
                         wcslen( SZ_DYNUPROX_SECGROUP ) +
                         wcslen( L",CN=Users," ) +
                         wcslen( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal ) +
                         1 ) * sizeof( WCHAR ),
                    MEMTAG_DS_DN );
        if ( !dn )
        {
            status = DNS_ERROR_NO_MEMORY;
            DNS_DEBUG( ANY, (
                "Error <%lu>: cannot allocate memory in addProxiesGroup\n",
                status));
            goto Cleanup;
        }

        wsprintf(
            dn,
            L"CN=%s,CN=Users,%s",
            SZ_DYNUPROX_SECGROUP,
            DSEAttributes[I_DSE_DEF_NC].pszAttrVal);

        //
        // Load description string
        //

        if ( !Dns_GetResourceString(
                  ID_PROXY_GROUP_DESCRIPTION,
                  wszDescriptionBuffer,
                  DNS_MAX_NAME_LENGTH ) )
        {
            status = GetLastError();
            DNS_DEBUG( DS, (
               "Error <%lu>: Failed to load resource string for Proxy group\n",
               status ));
            // set default
            wcscpy ( wszDescriptionBuffer, SZ_DYNUPROX_DESCRIPTION );
        }

        //
        //   Add it in the default location
        //

        status = ldap_add_ext_s(
                    pLdap,
                    dn,
                    mods,
                    NULL,
                    NULL );
        if (status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "Error: Could not add %S to DS with handle %p\n",
                dn,
                pLdap ));
            status = Ds_ErrorHandler( status, dn, pLdap, 0 );
            goto Cleanup;
        }
    }

    //
    // else,we found it & allocated the dn in isDNinDS()
    //
    ASSERT ( dn );

    //
    // Get group SD
    //

    if ( g_pDynuproxSid )
    {
        DNS_DEBUG(ANY, ("Logic error: proxy group SID is not NULL\n"));
        ASSERT(FALSE);
        FREE_HEAP(g_pDynuproxSid);
        g_pDynuproxSid = NULL;
    }

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pLdap,
                dn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                SidAttrs,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg);

    DS_SEARCH_STOP( searchTime );

    if ( status == ERROR_SUCCESS )
    {
        pentry = ldap_first_entry( pLdap, presultMsg );
        if ( !pentry )
        {
            goto Cleanup;
        }

        ppbvals = ldap_get_values_len( pLdap, pentry, LDAP_TEXT("objectSid") );
        if ( !ppbvals || !ppbvals[0])
        {
            DNS_DEBUG( ANY, ( "Error: cannot get proxy group SID\n" ));
            ASSERT( FALSE );
            goto Cleanup;
        }

        g_pDynuproxSid = ALLOC_TAGHEAP( ppbvals[0]->bv_len, MEMTAG_DS_SECURITY );
        if ( !g_pDynuproxSid)
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory(g_pDynuproxSid, ppbvals[0]->bv_val, ppbvals[0]->bv_len);

        ldap_value_free_len( ppbvals ), ppbvals = NULL;
        ldap_msgfree( presultMsg ), presultMsg=NULL;
    }
    else
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: Cannot get Dynuprox SID\n",
            status));
        status = Ds_ErrorHandler( status, dn, pLdap, 0 );
    }

    return status;

Cleanup:

   FREE_HEAP( dn );
   ldap_value_free_len( ppbvals );
   ldap_msgfree( presultMsg );

   return status;
}



DNS_STATUS
readAndUpdateNodeSecurityFromDs(
    IN OUT  PDB_NODE        pNode,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Read security state of node.

Arguments:

    pNode -- node to check security for;
        security status is reported back through node flags

    pZone -- zone node is in

Return Value:

    ERROR_SUCCESS if security properly read.
    ErrorCode on failure.

--*/
{
    ULONG status;
    PWSTR  attrs[] =
    {
        DSATTR_WHENCHANGED,
        DSATTR_SD,
        DSATTR_DNSRECORD,
        NULL
    };
    PLDAPMessage            presultMsg = NULL;
    PLDAPMessage            pentry;
    LONGLONG                llTime;
    BOOL                    baccess = FALSE;
    PLDAP_BERVAL *          ppbvals = NULL;
    WCHAR                   dn[ MAX_DN_PATH ];
    PDS_RECORD              precord;
    DWORD                   searchTime;
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };


    if ( !pServerLdap ||
        !pNode ||
        !pZone)
    {
       return ERROR_INVALID_PARAMETER;
    }

    DNS_DEBUG( DS, ( "readAndUpdateNodeSecurityFromDs\n" ));


    //
    //  get node DN
    //

    status = buildDsNodeNameFromNode(
                    dn,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  read node - all attributes relevant to security:
    //      - when changed
    //      - DNS records
    //      - security descriptor
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pServerLdap,
                    dn,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    attrs,
                    FALSE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg);

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "ERROR <%lu>: cannot find node %S. %s\n",
            status,
            dn,
            ldap_err2stringA(status) ));
        status = Ds_ErrorHandler( status, dn, pServerLdap, 0 );
        goto Cleanup;
    }

    pentry = ldap_first_entry(
                pServerLdap,
                presultMsg );
    if ( !pentry )
    {
        DNS_DEBUG(DS2, (
            "Error: Failed to get first pentry when searching for node security\n"
            "    DN = %S\n",
            dn ));
        goto Cleanup;
    }

    //
    //  read whenChanged attribute
    //      - if whenChanged was before zone's switch to secure time
    //      then node is "open"
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_WHENCHANGED );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no whenChanged value\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    status = GeneralizedTimeStringToValue( ppbvals[0]->bv_val, &llTime );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>: Failed to read whenChanged value\n", status ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    DNS_DEBUG( DS2, (
        "Testing node %s security expiration [%I64d ?< %I64d]\n",
        pNode->szLabel,
        llTime,
        pZone->llSecureUpdateTime));

    if ( llTime < pZone->llSecureUpdateTime )
    {
        DNS_DEBUG( DS, ("    SECNODE: Expired security\n"));
        SET_SECURE_EXPIRED_NODE( pNode );
    }

    ldap_value_free_len( ppbvals );

    //
    //  read security descriptor
    //      - see if it is available to authenticated users
    //      require authenticated user to have GENERIC_WRITE access
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_SD );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no ntSecurityDescriptor value\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    status = SD_AccessCheck(
                ( PSECURITY_DESCRIPTOR ) ppbvals[ 0 ]->bv_val,
                g_pAuthenticatedUserSid,
                DNS_DS_GENERIC_WRITE,
                &baccess );

    ASSERT( status == ERROR_SUCCESS );

    if ( ERROR_SUCCESS == status && baccess )
    {
        DNS_DEBUG(DS2, ("    SECNODE: Set open security node (avail to AU)\n"));
        SET_AVAIL_TO_AUTHUSER_NODE(pNode);
    }

    ldap_value_free_len( ppbvals );

    //
    //  read dNSRecord attribute
    //      - if we're tombstoned, then available to authenticated users
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_DNSRECORD );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no dnsRecord value\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }
    precord = (PDS_RECORD)ppbvals[0]->bv_val;

    if ( precord->wType == DNSDS_TOMBSTONE_TYPE )
    {
        DNS_DEBUG( DS2, ("    SECNODE: tombstoned\n" ));
        SET_TOMBSTONE_NODE(pNode);
    }


Cleanup:

    if ( ppbvals )
    {
        ldap_value_free_len( ppbvals );
    }

    if ( presultMsg != NULL )
    {
        ldap_msgfree( presultMsg );
    }

    return status;
}



DNS_STATUS
Ds_RegisterSpnDnsServer(
    PLDAP pLdap
    )
/*++
Function   : Ds_RegisterSpnDnsServer
Description: Registers a DNS service "Service Principal Name"
Parameters :
Return     :
Remarks    : none.
--*/
{
    DNS_STATUS status=ERROR_SUCCESS;
    PWCHAR *pszSpn = NULL;
    DWORD cSpn = 0;
    HANDLE hDs = NULL;

    DNS_DEBUG(DS2, ("Call: Dns_RegisterSpnDnsServer()\n"));



    //
    //  generate spn string
    //

    status = DsGetSpnW(
                       DS_SPN_DNS_HOST,                // registration type
                       DNS_SPN_SERVICE_CLASS_W,         // class name
                       NULL,                           // instance name. generated w/ our type
                       0,                              // instance port. default
                       0,                              // cInstanceNames, default
                       NULL,                           // pInstanceNames, default
                       NULL,                           // pInstancePorts, default
                       &cSpn,                          // elements in spn array below
                       &pszSpn);                       // generated names

    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG(ANY, ("Error <%lu>: cannot DsGetSpn\n", status));
       goto Cleanup;
    }


    ASSERT(cSpn > 0);
    ASSERT(pszSpn[0] != NULL);

    DNS_DEBUG(DS2, ("    SPN{%d}: %S\n",
                    cSpn, pszSpn[0]));

    //
    // see if we're not there yet
    //

    status = ldap_compare_s(
                            pLdap,
                            g_dnMachineAcct,
                            LDAP_TEXT("servicePrincipalName"),
                            pszSpn[0]);

    if ( LDAP_COMPARE_TRUE == status)
    {
       DNS_DEBUG(DS2, ("DNS SPN service already registered. exiting\n"));
       status = ERROR_SUCCESS;
       goto Cleanup;
    }
    else if ( LDAP_COMPARE_FALSE != status)
    {
       //
       // Assume that it is simply not there yet.
       //

       DNS_DEBUG(DS2, ("Warning<%lu>: Failed to search for SPN\n",
                            status));

       if ( status != LDAP_NO_SUCH_ATTRIBUTE )
       {
           ASSERT ( status == LDAP_NO_SUCH_ATTRIBUTE );
           //
           // We'll report an error but set status to success so as to recover.
           // It affects relatively fewer clients if we don't have an SPN, but
           // we can still go on, so just report, init to success & go on.
           //
           DNS_LOG_EVENT(
               DNS_EVENT_DS_SECURITY_INIT_FAILURE,
               0,
               NULL,
               NULL,
               status );
       }

       //
       // Regardless, the DNS server can live w/out SPN registration,
       // and we wanna give it a shot anyway.
       //

       status = ERROR_SUCCESS;
    }


    //
    // RPC bind to server
    //

    ASSERT ( DSEAttributes[I_DSE_DNSHOSTNAME].pszAttrVal );

    status = DsBindW(DSEAttributes[I_DSE_DNSHOSTNAME].pszAttrVal,
                     NULL,
                     &hDs);

    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG(DS2, ("Error<%lu>: cannot DsBind\n", status));
       ASSERT (FALSE);
       goto Cleanup;
    }

    //
    // Write
    //

    DNS_DEBUG(DS2, (
        "Before calling DsWriteAccountSpnW(0x%p, DS_SPN_ADD_SPN_OP, %S, %d, %S)\n",
        hDs,
        g_dnMachineAcct,
        cSpn,
        pszSpn[0] ));
    status = DsWriteAccountSpnW(
                    hDs,
                    DS_SPN_ADD_SPN_OP,
                    g_dnMachineAcct,
                    cSpn,
                    pszSpn );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG(ANY, (
            "Error <%lu>: cannot DsWriteAccountSpn\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    DNS_DEBUG( DS2, (
        "Successfull SPN registration in machine account:\n\t%s\n",
        g_dnMachineAcct ));

Cleanup:

    if ( hDs )
    {
        DsUnBindW(&hDs);
    }

    if ( pszSpn )
    {
        DsFreeSpnArrayW( cSpn, pszSpn );
    }
    return status;
}



BOOL
Ds_IsDsServer(
    VOID
    )
/*++

Routine Description:

    Determine if we are running on a DC (ie. run the DS).

    This does not necessarily indicate that the DS is up.

Arguments:

    None.

Return Value:

    TRUE -- box is DC
    FALSE -- not a DC, no DS

--*/
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pinfo = NULL;
    BOOL        bstatus = FALSE;
    DNS_STATUS  status;

    //
    //  check if DC
    //

    status = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE*) &pinfo );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>: DsRoleGetPrimaryDomainInformation failure\n",
            status ));
        ASSERT( status == ERROR_SUCCESS );
        goto Cleanup;
    }


    if ( pinfo->Flags & DSROLE_PRIMARY_DS_RUNNING )
    {
        bstatus = TRUE;
        SrvCfg_fDsAvailable = TRUE;
    }
    else
    {
        SrvCfg_fDsAvailable = FALSE;
        DNS_DEBUG( DS, (
            "Ds_IsDsServer() NON-DS. pinfo->Flags ==  0x%X\n",
            pinfo->Flags ));
    }

Cleanup:

    DNS_DEBUG( DS, (
        "Ds_IsDsServer() returns %s\n",
        bstatus ? "TRUE" : "FALSE" ));

    if ( pinfo )
    {
        DsRoleFreeMemory(pinfo);
    }
    return bstatus;
}




//
//  Security stuff
//

BOOL
setSecurityPrivilege(
    IN      BOOL            bOn
    )
/*++

Function   : SetSecurityPrivilege
Description: sets the security privilege for this process
Parameters : bOn: set or unset
Return     : BOOL: success status
Remarks    : in DNS contexts, called upon process init & doesn't realy need to be called
             ever again
--*/
{
    HANDLE  hToken;
    LUID    seSecVal;
    TOKEN_PRIVILEGES tkp;
    BOOL    bRet = FALSE;

    DNS_DEBUG( DS, (
        "setSecurityPrivilege()\n",
        "    bOn = %d\n",
        bOn ));


    // Retrieve a handle of the access token.

    if ( OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken))
    {
        if ( LookupPrivilegeValue(
                NULL,
                SE_SECURITY_NAME,
                &seSecVal))
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = seSecVal;
            tkp.Privileges[0].Attributes = bOn ? SE_PRIVILEGE_ENABLED : 0L;

            AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES) NULL,
                (PDWORD) NULL);
        }

        if ( GetLastError() == ERROR_SUCCESS )
        {
            bRet = TRUE;
        }

        if ( hToken )
        {
            CloseHandle( hToken );
        }
    }

    return bRet;
}



DNS_STATUS
Ds_InitializeSecurity(
    IN      PLDAP           pLdap
    )
/*++

Routine Description:

    Initialize security from directory.
    Server SD, global SIDS.

Arguments:

    pLdap   -- LDAP handle

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DWORD   status;
    SID_IDENTIFIER_AUTHORITY NtAuthority =  SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority =  SECURITY_WORLD_SID_AUTHORITY;
    BOOL fAddDnsAdmin = FALSE;


    DNS_DEBUG( DS, (
        "Ds_InitializeSecurity()\n",
        "    pLdap = %p\n",
        pLdap ));

    //
    //  DEVNOTE: move DS security to be globally useful
    //      some of this perhaps needs to be moved to security.c
    //      ideally we'd create this default DNS server SD, then
    //      could use that to secure all sorts of stuff
    //      (RPC interface, perfmon pages, etc.)
    //


    //
    //  Set security enhanced privilege (to accesss SD)
    //

    setSecurityPrivilege( TRUE );

    // free previous allocations

    if ( g_pServerObjectSD )
    {
        FREE_HEAP( g_pServerObjectSD );
        g_pDefaultServerSD = NULL;
    }
    if ( g_pDefaultServerSD )
    {
        FREE_HEAP( g_pDefaultServerSD );
        g_pDefaultServerSD = NULL;
    }
    if ( g_pServerSid )
    {
        SD_Delete( g_pServerSid );
        g_pServerSid = NULL;
    }
    if ( g_pServerGroupSid )
    {
        SD_Delete( g_pServerGroupSid );
        g_pServerGroupSid = NULL;
    }


    //
    //  Load or create the DnsAdmins group.
    //

    status = SD_LoadDnsAdminGroup();
    if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
    {
        //  The group was created by SD_LoadDnsAdminGroup().
        fAddDnsAdmin = TRUE;
    }
    else if ( status != ERROR_SUCCESS )
    {
        //
        //  Uh-oh. The DnsAdmins group could not be loaded and could not
        //  be created. This is probably because some admin went into Users
        //  and Computers and changed the Group Name from "DnsAdmins" to
        //  something more friendly like "Dns Admins". Since this has no
        //  negative implications, log a warning event and continue.
        //

        DNS_LOG_EVENT(
            DNS_EVENT_DS_DNSADMINS_ERROR,
            0,
            NULL,
            NULL,
            status );

        ASSERT( !"DnsAdmins groups could not be loaded and could not be created" );
    }

    //
    // Get process SIDs
    //

    status = SD_GetProcessSids( &g_pServerSid, &g_pServerGroupSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
           "ERROR: failed to get server sids!\n"
           "    error = %lu\n",
           status));
        goto Exit;
    }

    //
    // Allocate Sever default DS write security descriptor
    //

    //
    // DEPENDENCY:
    // SD_CreateServerSD depends on SD_GetProcessSids assigning the globals
    // above!!
    // g_pServerSid & g_pServerGroupSid
    //
    status = SD_CreateServerSD( &g_pDefaultServerSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
           "ERROR: failed to create default server SD\n"
           "    error = %lu\n",
           status));
        goto Exit;
    }

    //
    //  create standard SIDS
    //

    status = Security_CreateStandardSids();
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  register DNS server SPN
    //

    status = Ds_RegisterSpnDnsServer( pLdap );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: Cannot register spn service\n",
            status ));

        //
        // We'll report an error but set status to success so as to recover.
        // It affects relatively fewer clients if we don't have an SPN, but
        // we can still go on, so just report, init to success & go on.
        //
        DNS_LOG_EVENT(
            DNS_EVENT_DS_SECURITY_INIT_FAILURE,
            0,
            NULL,
            NULL,
            status );
        status = ERROR_SUCCESS;
    }

Exit:

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: <%lu>: Failed to initialize DS related security\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_DS_SECURITY_INIT_FAILURE,
            0,
            NULL,
            NULL,
            status );
    }
    else if ( fAddDnsAdmin )
    {
        // success & we had just created the group (possibly "again").
        status = DNS_ERROR_NAME_DOES_NOT_EXIST;
    }

    return status;
}



DNS_STATUS
Ds_WriteDnSecurity(
    IN      PLDAP                   pLdap,
    IN      PWSTR                   pwsDN,
    IN      PSECURITY_DESCRIPTOR    pSd,
    IN      BOOL                    fRewriteOwner
    )
/*++

Routine Description:

    Writes the specified SD on the given object

Arguments:

    pLdap -- ldap connection handle
    pwsDN -- object to write sd
    pSd -- the security descriptor to write
    fRewriteOwner -- include owner and group in DS write

Return Value:

    ERROR_SUCCESS if good, otherwise error code

--*/
{
    DWORD               status = ERROR_SUCCESS;
    DNS_LDAP_SINGLE_MOD modSD;
    PLDAPMod            mods[] = { &(modSD.Mod), NULL };

    PLDAPControl        controlArray[] =
        {
        fRewriteOwner
            ? &SecurityDescriptorControl_DGO
            : &SecurityDescriptorControl_D,
        lazyCommitControlPtr(),
        NULL
        };

    //
    //  build ldap_mod
    //

    INIT_SINGLE_MOD_LEN(&modSD);

    modSD.Mod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    modSD.Mod.mod_type = DsTypeAttributeTable [ I_DSATTR_SD ];
    modSD.Mod.mod_bvalues[0]->bv_val = (LPVOID)pSd;
    modSD.Mod.mod_bvalues[0]->bv_len = GetSecurityDescriptorLength(pSd);

    DNS_DEBUG( DS2, (
        "ldap_modify SD @%p w/ length %d\n",
        modSD.Mod.mod_bvalues[0]->bv_val,
        modSD.Mod.mod_bvalues[0]->bv_len ));

    status = ldap_modify_ext_s(
                    pLdap,
                    pwsDN,
                    mods,
                    controlArray,       // include lazy commit control
                    NULL );             // no client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Failed to write SD onto ( %S )\n"
            "    status = %d\n",
            pwsDN,
            status));
        status = Ds_ErrorHandler( status, pwsDN, pLdap, 0 );
    }

    return status;
}



DNS_STATUS
Ds_AddPrincipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwsDN,
    IN      PSID            pSid,        OPTIONAL
    IN      LPTSTR          pwsName,     OPTIONAL
    IN      DWORD           AccessMask,
    IN      DWORD           AceFlags,    OPTIONAL
    IN      BOOL            bWhackExistingAce,
    IN      BOOL            bTakeOwnership
    )
/*++

Routine Description:

    Add the principal to the ACL in the SD for
    the specified object (given dn)

Arguments:

    pLdap       --  ldap handle
    pwsDN       --  object to apply extended security
    pSid        --  SID to add access, specify or leave NULL and specify pwsName
    pwsName     --  principal name to add access
    AccessMask  --  specific access to add
    AceFlags    --  additional security flags such as inheritance
    bWhackExistingAce -- passed to SD routine - delete ACE before adding
    bTakeOwnership -- passed to SD routine - take ownership of object

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure

--*/
{
    DBG_FN( "Ds_AddPrincipalAccess" )
    
    DWORD           status = ERROR_SUCCESS;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry = NULL;
    PLDAP_BERVAL *  ppbval = NULL;
    PWSTR           sdAttrs[] = {
                                DsTypeAttributeTable [ I_DSATTR_SD ] ,
                                NULL
                                };
    PSECURITY_DESCRIPTOR    pSd     =   NULL;
    PSECURITY_DESCRIPTOR    pNewSD  =   NULL;

    PLDAPControl            ctrls[] =
    {
        bTakeOwnership
            ? &SecurityDescriptorControl_DGO
            : &SecurityDescriptorControl_D,
        NULL
    };

    DNS_DEBUG( DS, (
        "Ds_AddPrincipalAccess( %s )\n",
        pwsDN ));

    status = ldap_search_ext_s(
                    pLdap,
                    pwsDN,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    sdAttrs,
                    FALSE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: cannot find %S\n",
            status, pwsDN));
        return Ds_ErrorHandler( status, pwsDN, pLdap, 0 );
    }

    pentry = ldap_first_entry(
                    pLdap,
                    presultMsg );
    ASSERT( pentry );

    ppbval = ldap_get_values_len(
                    pLdap,
                    pentry,
                    DsTypeAttributeTable[ I_DSATTR_SD ] );

    if ( !ppbval || !ppbval[0])
    {
        DNS_DEBUG( DS, ( "Error: cannot find ntSecurityDescriptor in search\n" ));
        status = LdapGetLastError();
        status = status ? status : LDAP_NO_SUCH_ATTRIBUTE;
        goto Cleanup;
    }

    pSd = ppbval[0]->bv_val;

    status = SD_AddPrincipalToSD(
                    pSid,
                    pwsName,
                    pSd,
                    &pNewSD,
                    AccessMask,
                    AceFlags,
                    NULL,
                    NULL,
                    bWhackExistingAce,
                    bTakeOwnership );
    
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: cannot add principal %S/%p to %S\n",
            pwsName,
            pSid,
            pwsDN ));
        goto Cleanup;
    }
    
    DNS_DEBUG( DS, (
        "%s: rewriting %S\n"
        "    on DN: %S\n", fn,
        DsTypeAttributeTable[ I_DSATTR_SD ],
        pwsDN ));

    #if DBG
    Dbg_DumpSD( fn, pNewSD );
    #endif

    status = Ds_WriteDnSecurity(
                    pLdap,
                    pwsDN,
                    pNewSD,
                    bTakeOwnership );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: cannot write new SD %S\n",
            pwsDN ));
        goto Cleanup;
    }


Cleanup:

    if ( presultMsg )
    {
        ldap_msgfree(presultMsg);
    }
    if ( ppbval )
    {
        ldap_value_free_len( ppbval );
    }
    if ( pNewSD )
    {
        FREE_HEAP( pNewSD );
    }

    return status;
}   //  Ds_AddPrincipalAccess



DNS_STATUS
Ds_RemovePrincipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDN,
    IN      PWSTR           pwszName,   OPTIONAL
    IN      PSID            pSid        OPTIONAL
    )
/*++

Routine Description:

    Remove the named principle from the object given by DN.

Arguments:

    pLdap --  ldap handle

    pwszDN --  object to apply extended security
    
    pwszName --  principal name to remove access for

    pSid -- if pwszName is NULL, SID of principle

Return Value:

    ERROR_SUCCESS if successful or error on failure.

--*/
{
    DBG_FN( "Ds_RemovePrincipalAccess" )

    DWORD           status = ERROR_SUCCESS;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry = NULL;
    PLDAP_BERVAL *  ppbval = NULL;
    PWSTR           sdAttrs[] = {
                                DsTypeAttributeTable [ I_DSATTR_SD ] ,
                                NULL
                                };
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;

    PLDAPControl            ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        NULL
    };

    DNS_DEBUG( DS, (
        "%s( %S )\n", fn, pwszDN ));
    
    status = ldap_search_ext_s(
                    pLdap,
                    pwszDN,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    sdAttrs,
                    FALSE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: cannot find %S\n",
            status, pwszDN));
        return Ds_ErrorHandler( status, pwszDN, pLdap, 0 );
    }

    pentry = ldap_first_entry(
                    pLdap,
                    presultMsg );
    ASSERT( pentry );

    ppbval = ldap_get_values_len(
                    pLdap,
                    pentry,
                    DsTypeAttributeTable[ I_DSATTR_SD ] );

    if ( !ppbval || !ppbval[0])
    {
        DNS_DEBUG( DS, ( "Error: cannot find ntSecurityDescriptor in search\n" ));
        status = LdapGetLastError();
        status = status ? status : LDAP_NO_SUCH_ATTRIBUTE;
        goto Cleanup;
    }

    pSD = ppbval[0]->bv_val;

    status = SD_RemovePrincipalFromSD(
                    pSid,
                    pwszName,
                    pSD,
                    NULL,
                    NULL,
                    &pNewSD );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: could not remove principal %S to %S\n",
            pwszName,
            pwszDN ));
        goto Cleanup;
    }

    status = Ds_WriteDnSecurity(
                    pLdap,
                    pwszDN,
                    pNewSD,
                    TRUE );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: cannot write new SD %S\n",
            pwszDN ));
        goto Cleanup;
    }


Cleanup:

    if ( presultMsg )
    {
        ldap_msgfree(presultMsg);
    }
    if ( ppbval )
    {
        ldap_value_free_len( ppbval );
    }
    if ( pNewSD )
    {
        FREE_HEAP( pNewSD );
    }

    return status;
}   //  Ds_RemovePrincipalAccess



DNS_STATUS
Ds_CommitAsyncRequest(
    IN      PLDAP           pLdap,
    IN      ULONG           OpType,
    IN      ULONG           MessageId,
    IN      PLDAP_TIMEVAL   pTimeout        OPTIONAL
    )
/*++

Routine Description

    Commit async ldap request.

    This call wraps ldap_result & execute time limited commit of
    async requests

Arguments:

    pLdap       --  ldap connectin handle
    OpType      --  type of originating async call (LDAP_RES_ADD etc)
    MessageId   --  message id to process
    pTimeout    --  can be NULL for default

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure

--*/
{
    PLDAPMessage    presultMsg    = NULL;
    DWORD           status = ERROR_SUCCESS;

    if ( !pTimeout )
    {
        pTimeout = &g_LdapTimeout;
    }
    ASSERT( pTimeout );

    status = ldap_result(
                    pLdap,
                    MessageId,
                    LDAP_MSG_ALL,
                    pTimeout,
                    &presultMsg );

    if ( OpType != status )
    {
        // ldap result timed out or got a parameter error or some other failure.

        DNS_DEBUG( DS, (
            "Warning <%lu>: ldap_result returned unexpected results (unless timeout)\n",
            status ));
    }

    status = ldap_result2error(
                pLdap,
                presultMsg,
                TRUE );

    if ( status != ERROR_SUCCESS )
    {
        //
        // Server operation failed.
        // Could be timeout, refused, just about anything.
        //

        PWSTR  pwszErr = NULL;
        DWORD  dwErr = 0;

        DNS_DEBUG( DS, (
            "Warning <%lu>: cannot commit request %lu. %S\n",
            status, MessageId,
            ldap_err2string(status) ));

        ldap_get_option(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwErr );
        DNS_DEBUG( DS, (
            "Error <%lu>: DS Commit failed\n",
            dwErr ));

        return status;
    }

    return status;
}



DNS_STATUS
Ds_DeleteDn(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDN,
    IN      BOOL            bSubtree
    )
/*++

Routine Description:

    Shells on ldap_delete_ext so that we do it in async fashion.

    Deletion of a large subtree can fail with error LDAP_ADMIN_LIMIT_EXCEEDED.
    If this happens we must resubmit the delete. This could happen a number of times,
    but do not loop forever. Currently, the limit is 16k objects per deletion,
    so to delete a zone with 1,000,000 objects you would need 62 retries.

    This function also allows for a limited number of other DS errors during
    the delete operation - the DS could be busy or grumpy or something.

Arguments:

    pLdap       -   ldap connection handle

    pwszDN      -   DN to delete

    bSubtree    -   TRUE to do a subtree delete;  FALSE to delete only DN

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    #define         DNS_MAX_SUBTREE_DELETION_ERRORS     30
    #define         DNS_MAX_SUBTREE_DELETION_ATTEMPTS   300

    INT             iAttemptCount = 0;
    INT             iErrorCount = 0;
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           msgId = 0;

    LDAPControl     ctrlDelSubtree =
    {
        LDAP_SERVER_TREE_DELETE_OID_W,
        { 0 , NULL },
        TRUE
    };
    PLDAPControl    ctrls[]  =  { &ctrlDelSubtree, NULL };
    
    if ( !pwszDN )
    {
        goto Done;
    }

    while ( ++iAttemptCount <= DNS_MAX_SUBTREE_DELETION_ATTEMPTS )
    {
        DNS_DEBUG( DS, (
            "Ds_DeleteDn:\n"
            "    bSubtree = %d\n"
            "    attempt =  %d\n"
            "    DN =       %S\n",
            bSubtree,
            iAttemptCount,
            pwszDN ));

        //
        //  Submit delete request and wait for completion.
        //  

        status = ldap_delete_ext(
                    pLdap,
                    pwszDN,
                    bSubtree ? ctrls : NULL,
                    NULL,
                    &msgId );

        if ( ( ULONG ) -1 == status )
        {
            //
            //  Local operation failed. Ldap is in bad shape
            //

            status = LdapGetLastError();
            DNS_DEBUG( DS, (
                "Ds_DeleteDn could not submit delete %lu\n"
                "    %S\n",
                status,
                pwszDN ));
            status = Ds_ErrorHandler( status, pwszDN, pLdap, 0 );
            status = status ? status : LDAP_LOCAL_ERROR;
            break;
        }

        status = Ds_CommitAsyncRequest(
                        pLdap,
                        LDAP_RES_DELETE,
                        msgId,
                        &g_LdapDeleteTimeout );
        DNS_DEBUG( DS, (
            "Ds_DeleteDn: Ds_CommitAsyncRequest status %lu\n",
            status ));

        if ( status == ERROR_SUCCESS || status == LDAP_NO_SUCH_OBJECT )
        {
            status = ERROR_SUCCESS;
            break;
        }

        //
        //  Allow for a limited number of retries on DS errors because
        //  Anand found his deletes on a busy server would sometimes
        //  get a DS_UNAVAILABLE error.
        //
        
        if ( status == LDAP_INSUFFICIENT_RIGHTS )
        {
            break;
        }

        if ( status != LDAP_ADMIN_LIMIT_EXCEEDED )
        {
            if ( ++iErrorCount > DNS_MAX_SUBTREE_DELETION_ERRORS )
            {
                DNS_DEBUG( DS, (
                    "Ds_DeleteDn: too many (%d) DS errors so giving up\n"
                    "    %S\n",
                    iErrorCount,
                    pwszDN ));
                break;
            }
            DNS_DEBUG( DS, (
                "Ds_DeleteDn: continuing through error %lu (error #%d)\n",
                status,
                iErrorCount ));
        }
    }

    //
    //  Log event if iAttemptCount >= DNS_MAX_SUBTREE_DELETION_ATTEMPTS?
    //

    DNS_DEBUG( DS, (
        "Ds_DeleteDn: returning %lu after %d delete attempts\n"
        "    %S",
        status,
        iAttemptCount,
        pwszDN ));

    if ( status != ERROR_SUCCESS )
    {
        STAT_INC( DsStats.FailedDeleteDsEntries );
    }
    
    Done:

    return status;
}



DNS_STATUS
setNotifyForIncomingZone(
    VOID
    )
/*++

Routine Description:

    Sets change-notify for getting zone adds\deletes.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           msgId = 0;
    LDAPControl     ctrlNotify =
    {
        LDAP_SERVER_NOTIFICATION_OID_W,
        { 0 , NULL },
        TRUE
    };
    PLDAPControl    ctrls[]  =
    {
        & ctrlNotify,
        & NoDsSvrReferralControl,
        & SecurityDescriptorControl_DGO,
        NULL
    };

    DNS_DEBUG( DS, (
        "setNotifyForIncomingZone()\n" ));

    if ( INVALID_MSG_ID != g_ZoneNotifyMsgId )
    {
        DNS_DEBUG( ANY, (
            "Error: g_ZoneNotifyMsgId has already been set unexpectedly\n" ));
        ASSERT ( INVALID_MSG_ID == g_ZoneNotifyMsgId );
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  launch search at MicrosoftDns with change-notify control
    //

    status = ldap_search_ext(
                    pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_ONELEVEL,
                    g_szChangeNotificationFilter,
                    DsTypeAttributeTable,
                    FALSE,
                    ctrls,
                    NULL,
                    0,
                    0,
                    &msgId );

    if ( status != ERROR_SUCCESS || (DWORD)msgId <= 0 )
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: failed to set zone notification. %s (msg = %lu)\n",
            status,
            ldap_err2string(status),
            msgId ));
        status = Ds_ErrorHandler( status, g_pwszDnsContainerDN, pServerLdap, 0 );
        goto Cleanup;
    }
    else
    {
        g_ZoneNotifyMsgId = msgId;
    }


Cleanup:

    DNS_DEBUG( DS2, (
        "Exit <%lu>: setNotifyForIncomingZone\n",
        status ));

    return status;
}



void
logDsError(
    IN      PLDAP       pLdap,
    IN      DWORD       Status,
    IN      DWORD       LdapStatus
    )
/*++

Routine Description:

    Helper function for Ds_ErrorHandler.

Arguments:

Return Value:

--*/
{
    if ( pLdap && Status != ERROR_SUCCESS )
    {
        PWSTR           perrString;
        DNS_STATUS      dwExtendedError;

        ldap_get_option( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwExtendedError );
        DNS_DEBUG( DS, (
            "LDAP extended error code: %d = 0x%X\n",
            dwExtendedError,
            dwExtendedError ));

        perrString = Ds_GetExtendedLdapErrString( pLdap );
        DNS_LOG_EVENT(
            DNS_EVENT_DS_INTERFACE_ERROR,
            1,
            &perrString,
            NULL,
            LdapStatus );
        DNS_DEBUG( DS, (
            "LDAP extended error string: \"%S\"\n",
            perrString ));
        Ds_FreeExtendedLdapErrString( perrString );
    }
}   //  logDsError

    

DNS_STATUS
Ds_ErrorHandler(
    IN      DWORD       LdapStatus,
    IN      LPWSTR      pwszNameArg,    OPTIONAL
    IN      PLDAP       pLdap,          OPTIONAL
    IN      DWORD       dwFlags         OPTIONAL
    )
/*++

Routine Description:

    Handle & maps ldap errors based on error semantics

    DEVNOTE-DCR: 454336 - Critical errors will trigger reconnect in async thread!
        This needs some rethink.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR           perrString;

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        //
        // We had previous errors w/ the DS & we shutdown
        // DS interfaces
        //

        DNS_DEBUG( DS, (
            "Error: DS is unavailable due to previous problems\n" ));
        return DNS_ERROR_RCODE_SERVER_FAILURE;
    }

    if ( !pLdap )
    {
        pLdap = pServerLdap;
    }
    
    switch ( LdapStatus )
    {
        //
        //  KLUDGE ALERT:
        //  Critical or unexpected LDAP errors that we shouldn't log
        //  an error for. DEVNOTE: This is a not a great design. While it
        //  is cool to have centralized error handling this doesn't allow
        //  fine-grained control over event logging. Worse: the event logs
        //  are without context and so for debugging purposes are useless.
        //
        
        case LDAP_REFERRAL:
        case LDAP_REFERRAL_V2:

            #ifdef DBG
            perrString = Ds_GetExtendedLdapErrString( pLdap );
            DNS_DEBUG( DS, (
                "DS error %lu: %S\n"
                "    Extended error: %S\n",
                LdapStatus,
                ldap_err2string ( LdapStatus ),
                perrString ));
            Ds_FreeExtendedLdapErrString( perrString );
            #endif

            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;

        //
        //  Critical or unexpected LDAP errors
        //
       
        case (DWORD)-1:    // -1 for async ops when the DS is unavailable
        case LDAP_BUSY:
        case LDAP_OPERATIONS_ERROR:
        case LDAP_PROTOCOL_ERROR:
        case LDAP_ADMIN_LIMIT_EXCEEDED:
        case LDAP_UNAVAILABLE_CRIT_EXTENSION:
        case LDAP_CONFIDENTIALITY_REQUIRED:
        case LDAP_CONSTRAINT_VIOLATION:
        case LDAP_INVALID_SYNTAX:
        case LDAP_INVALID_DN_SYNTAX:
        case LDAP_LOOP_DETECT:
        case LDAP_NAMING_VIOLATION:
        case LDAP_OBJECT_CLASS_VIOLATION:
        case LDAP_OTHER:
        case LDAP_LOCAL_ERROR:
        case LDAP_ENCODING_ERROR:
        case LDAP_DECODING_ERROR:
        case LDAP_FILTER_ERROR:
        case LDAP_PARAM_ERROR:
        case LDAP_CONNECT_ERROR:
        case LDAP_NOT_SUPPORTED:
        case LDAP_NO_MEMORY:
        case LDAP_CONTROL_NOT_FOUND:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));

            status = DNS_ERROR_RCODE_SERVER_FAILURE;

            if ( !( dwFlags & DNS_DS_NO_EVENTS ) )
            {
                logDsError( pLdap, status, LdapStatus );
            }
            
            break;

        //
        //  Object state (exist, missing etc)
        //  Missing objects/attributes
        //  Already exist errors
        //  Action -
        //    increase stats
        //

        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
        case LDAP_ALREADY_EXISTS:
        case LDAP_INAPPROPRIATE_MATCHING:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));
            status = LdapStatus;
            break;

        //
        // Authentication / security
        // Action -
        //   Report event? probably not (security attack).
        //   best if we could set reporting to optional.
        //   increase stats
        //

        case LDAP_INAPPROPRIATE_AUTH:
        case LDAP_INVALID_CREDENTIALS:
        case LDAP_UNWILLING_TO_PERFORM:
        case LDAP_AUTH_UNKNOWN:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));
            status = DNS_ERROR_RCODE_REFUSED;
            break;

        case LDAP_INSUFFICIENT_RIGHTS:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));
            status = ERROR_ACCESS_DENIED;
            break;

        //
        // Server state
        // Action -
        //      - mark handle as invalid so that async thread will attempt a reconnect.
        //      - report event
        //      - treat as SERVER_FAILURE
        //

        case LDAP_UNAVAILABLE:
        case LDAP_SERVER_DOWN:


            LDAP_LOCK();

            if ( pLdap == NULL || pLdap == pServerLdap )
            {
                DISABLE_LDAP_HANDLE();
            }

            LDAP_UNLOCK();

            DNS_DEBUG( DS, (
                "Critical LDAP error %lu: %s\n",
                LdapStatus,
                ldap_err2string( LdapStatus ) ));

            status = DNS_ERROR_RCODE_SERVER_FAILURE;

            logDsError( pLdap, status, LdapStatus );

            break;

        //
        // Warning state
        // Action -
        //   Report event
        //

        case LDAP_TIMEOUT:

            {
                PWSTR   parg = pwszNameArg;

                if ( !parg )
                {
                    parg = L"---";
                }

                if ( !( dwFlags & DNS_DS_NO_EVENTS ) )
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_DS_LDAP_TIMEOUT,
                        1,
                        & parg,
                        NULL,
                        LdapStatus );
                }
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                break;
            }

        //
        // search status  & other valid
        //

        case LDAP_NO_RESULTS_RETURNED:
        case LDAP_MORE_RESULTS_TO_RETURN:
        case ERROR_SUCCESS:

            status = LdapStatus;
            break;

        default:
            DNS_DEBUG( DS, (
                "Ldap Error <%lu>: %S (unhandled)\n",
                 LdapStatus,
                ldap_err2string( LdapStatus ) ));
            status = DNS_ERROR_INVALID_DATA;
            break;
    }

    return status;
}



DNS_STATUS
Ds_WaitForStartup(
    IN      DWORD           dwMilliSeconds
    )
/*++

Routine Description:

    Wait for DS startup / readiness event.

    The DS notifies other processes that it is internally consistent
    and ready for clients via a named event. We'll wait for it.

Arguments:

    dwMilliSeconds: as specified to wait functions.  INFINITE is the recommended value

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    HANDLE      hEvent = NULL;
    HANDLE      rg_WaitHandles[2];

    DNS_DEBUG( DS, (
       "Call: Ds_WaitForStartup(0x%x)\n",
       dwMilliSeconds ));

    //
    //  Get DS event
    //

    hEvent = OpenEventW(
                    SYNCHRONIZE,
                    FALSE,
                    DS_SYNCED_EVENT_NAME_W );
    if ( !hEvent )
    {
        status = GetLastError();
        ASSERT( status != ERROR_SUCCESS );

        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to open event '%S'\n",
            status,
            DS_SYNCED_EVENT_NAME_W ));

        #if DBG
        if ( !g_RunAsService && status == ERROR_FILE_NOT_FOUND )
        {
            status = ERROR_SUCCESS;
            goto Done;
        }
        #endif

        // trap when the DS event is unavailable & we still call it.

        ASSERT ( FALSE );
        goto Done;
    }

    //
    // Wait for DS event & DNS shutdown event (since we're a service).
    //

    rg_WaitHandles[0] = hEvent;
    rg_WaitHandles[1] = hDnsShutdownEvent;

    status = WaitForMultipleObjects(
                 2,
                 rg_WaitHandles,
                 FALSE,                     // fWaitAll
                 dwMilliSeconds );

    if ( status == WAIT_OBJECT_0 )
    {
        //
        // DS event fired. We're ready to proceed.
        // return is the index of fired event ie: status - WAIT_OBJECT_0 == nCount-1 == 0 for hEvent,
        // thus status == WAIT_OBJECT_0
        //
        status = ERROR_SUCCESS;
        goto Done;
    }
    else
    {
        //
        // Some other return:
        // timeout, shutdown event, abandoned, or any other error
        //
        DNS_DEBUG( DS, (
            "Error <%lu>: Wait for DS startup failed\n",
            status ));
        status = DNS_ERROR_DS_UNAVAILABLE;
    }


Done:


    if ( status != ERROR_SUCCESS )
    {
        //
        //  Report DS search failure.
        //  DEVNOTE-LOG: Should be more generic event (not a write timeout but
        //      just a timeout)? Must be careful that the frequency of this event
        //      is not onerous!
        //
#if 0
//
// We're logging an event later on. If caller calls this (now it's every min) too
// frequently, we'll fill up the event log too much
//
        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_WAIT,
            0,
            NULL,
            NULL,
            status );
#endif
        DNS_DEBUG( DS, (
            "Error <%lu>: Cannot wait on DS startup event\n",
            status ));
    }


    if ( hEvent )
    {
        CloseHandle ( hEvent );
    }

    return ( status );
}


BOOL
Ds_ValidHandle(
    VOID
    )
/*++

Routine Description:

    Checks if ldap handle is valid wrapped by a CS.


Arguments:

    None

Return Value:

    TRUE on valid
    FALSE on invalid

--*/
{
    BOOL bRet;

    LDAP_LOCK();
    bRet = !IS_DISABLED_LDAP_HANDLE();
    LDAP_UNLOCK();

    return bRet;
}


DNS_STATUS
Ds_TestAndReconnect(
    VOID
    )
/*++

Routine Description:

    If ldap handle is invalid, we'll attempt to reconnect

    DEVNOTE-DCR: 455374 - when swapping in new handle, what about threads that
        are in the middle of an operation using the old handle?

Arguments:

    None

Return Value:

    ERROR_SUCCESS or error code
--*/
{
    DBG_FN( "Ds_TestAndReconnect" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP           pNewLdap = NULL;
    PLDAP           pOldLdap;

    //
    //  verify DS initialized\open
    //  if pServerLdap == NULL && IS_DISABLED_LDAP_HANDLE() you will never reconnect here
    //  w/out the additional test.
    //  Ds_OpenServer returns an error if disabled flag is on. If pServerLdap was NULL,
    //  you will never reconnect here. Thus, the additional test.
    //

    if ( !pServerLdap && !IS_DISABLED_LDAP_HANDLE() )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
    }

    LDAP_LOCK();

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        if ( DNS_TIME() >
             g_dwLastLdapReconnectTime + DNS_LDAP_RECONNECT_FREQUENCY )
        {
            STAT_INC( DsStats.LdapReconnects );

            //
            //  Attempt LDAP reconnect.
            //

            pNewLdap = Ds_Connect( LOCAL_SERVER_W, 0, &status );
            if ( !pNewLdap )
            {
                DNS_DEBUG( DS, (
                    "%s: error %lu reconnecting server LDAP session\n", fn,
                    status ));

                Ec_LogEvent(
                    g_pServerEventControl,
                    DNS_EVENT_DS_OPEN_FAILED,
                    NULL,                       //  event instance ID
                    0,                          //  arg count
                    NULL,                       //  arg value array
                    NULL,                       //  arg type array
                    status );

                status = DNS_ERROR_DS_UNAVAILABLE;

                // just to ensure that nobody change it under us (can't happen today).
                ASSERT( IS_DISABLED_LDAP_HANDLE() );
            }
            else
            {
                //
                //  Assign to handle to global and unbind current handle.
                //

                DNS_DEBUG( DS, (
                    "%s: successfully reconnected LDAP session at %lu\n"
                    "    old LDAP handle =      %p\n"
                    "    new LDAP handle =      %p\n", fn,
                    DNS_TIME(),
                    pServerLdap,
                    pNewLdap ));

                pOldLdap = pServerLdap;
                pServerLdap = pNewLdap;
                Ds_LdapUnbind( &pOldLdap );
                ENABLE_LDAP_HANDLE();
            }

            g_dwLastLdapReconnectTime = DNS_TIME();
        }
        else
        {
            DNS_DEBUG( DS, (
                "%s: DS unavailable at %lu but reconnect attempted too recently\n"
                "    last reconnect attempt =       %lu\n", fn,
                DNS_TIME(),
                g_dwLastLdapReconnectTime ));
            status = DNS_ERROR_DS_UNAVAILABLE;
        }
    }

    LDAP_UNLOCK();
    return status;
}




//
//  DS polling thread
//

//  wait between tests for DC suddenly on-line
//  longer wait saves wasted cycles

#define DS_POLL_NON_DC_WAIT         (600)

//  minimum wait, should never constantly poll no
//  matter how many zones

#if DBG
#define DS_POLL_MINIMUM_WAIT        (10)
#else
#define DS_POLL_MINIMUM_WAIT        (30)
#endif



DNS_STATUS
Ds_PollingThread(
    IN      LPVOID          pvDummy
    )
/*++

Routine Description:

    Thread for DS polling.

    Note: this has been separated from other threads because the polling
    operation can be long and is synchronous.  Could move this to a dispatchable
    thread model -- like XFR, and only determine NEED for polling in a
    common "random tasks" thread like XFR control thread.

    DEVNOTE-DCR: 455375 - this thread needs a bit of rethink?

Arguments:

    pvDummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;
    DWORD           dwpollTime;
    DWORD           dwwaitInterval = SrvCfg_dwDsPollingInterval;

    //
    //  loop until service exit
    //

    while ( TRUE )
    {
        BOOL        fdeleteUnvisitedZones;
        //
        //  wait until next polling required OR shutdown
        //      - only wait longer than interval should be
        //          non-DC wait
        //      - wait a minimum interval no matter how
        //          admin misconfigures dwDsPollingInterval
        //

        if ( dwwaitInterval > SrvCfg_dwDsPollingInterval )
        {
            dwwaitInterval = DS_POLL_NON_DC_WAIT;
        }

        if ( dwwaitInterval < DS_POLL_MINIMUM_WAIT )
        {
            dwwaitInterval = DS_POLL_MINIMUM_WAIT;
        }

        dwwaitInterval *= 1000;

        status = WaitForSingleObject(
                     hDnsShutdownEvent,
                     dwwaitInterval );

        ASSERT (status == WAIT_OBJECT_0 || status == WAIT_TIMEOUT );

        if ( status == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating DS polling thread on shutdown\n" ));
            return ( 1 );
        }

        //
        //  Check and possibly wait on service status
        //
        //  Note, we MUST do this check BEFORE any processing to make
        //  sure all zones are loaded before we begin checks.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating DS poll thread\n" ));
            return( 1 );
        }

        //  set default for next wait

        dwwaitInterval = SrvCfg_dwDsPollingInterval;

        //
        //  update time
        //

        dwpollTime = UPDATE_DNS_TIME();

        DNSLOG( DSPOLL, (
            "Polling thread awake at %lu seconds\n",
            dwpollTime ));

        //
        //  booting from file
        //      - if so long wait until retest
        //  non-DS?
        //      - if so long wait
        //
        //  should use flag for test, then test "still not-DS" inside
        //      block so tested only occasionally during long

        if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
        {
            DNS_DEBUG( DS, (
                "DS poll thread.  File boot -- long rewait\n"
                ));
            dwwaitInterval = DS_POLL_NON_DC_WAIT;
            continue;
        }
        if ( !SrvCfg_fDsAvailable )
        {
            if ( !Ds_IsDsServer() )
            {
                DNS_DEBUG( DS, (
                    "DS poll thread.  Non-DC -- long rewait\n"
                    ));
                dwwaitInterval = DS_POLL_NON_DC_WAIT;
                continue;
            }
        }

        //
        //  wait if still waiting on DS
        //  if have DS, initialize if not already done;
        //      this allows us to run after DC promo
        //

        if ( !SrvCfg_fStarted )
        {
            DNSLOG( DSPOLL, (
                "Server is not started, rewaiting\n" ));
            continue;
        }

        if ( !pServerLdap )
        {
            status = Ds_OpenServer( DNSDS_MUST_OPEN );
            if ( status != ERROR_SUCCESS )
            {
                dwwaitInterval = DS_POLL_NON_DC_WAIT;
                continue;
            }
        }

        //
        //  test and reconnect if necessary
        //      protects against LDAP whacking us
        //

        status = Ds_TestAndReconnect();

        if ( status != ERROR_SUCCESS )
        {
            DNSLOG( DSPOLL, (
                "Error %lu attempted to restablish DS connectivity\n",
                status ));
            continue;
        }

        //
        //  Poll for new zones in the legacy DNS container.
        //

        Ds_ListenAndAddNewZones();

        //
        //  Poll directory partitions for new/deleted zones.
        //

        status = Dp_Poll( NULL, dwpollTime, FALSE );

        fdeleteUnvisitedZones = status == ERROR_SUCCESS;

        //
        //  Loop through DS zones checking for updated records.
        //
        //  All zones in the zone list that live in a directory partition
        //  that have not recently been deleted from the DS will now have
        //  their visit timestamped. Any DP zone in the zone list with an
        //  old visit timestamp has been deleted from the DS.
        //

        pzone = NULL;
        while ( pzone = Zone_ListGetNextZone( pzone ) )
        {
            if ( !pzone->fDsIntegrated )
            {
                continue;       //  Not DS-integrated so skip zone.
            }

            //
            //  Reload zone if necessary - no polling required after reload.
            //

            if ( IS_ZONE_DSRELOAD( pzone ) )
            {
                status = Zone_Load( pzone );
                if ( ERROR_SUCCESS == status )
                {
                    CLEAR_DSRELOAD_ZONE ( pzone );
                }
                continue;
            }

            if ( IS_ZONE_INACTIVE( pzone ) )
            {
                continue;
            }

            //
            //  DS polling
            //      - since zone polling can be time consuming, check
            //          for service termination first
            //
            //  note: could check for last poll here, but instead we're
            //      taking a poll-all\wait\poll-all\wait sort of approach
            //

            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( ASYNC, (
                    "Terminating Async task zone control thread\n" ));
                return( 1 );
            }

            Ds_ZonePollAndUpdate( pzone, FALSE );
        }
    }

}   //  Ds_PollingThread




//
//  Zone list DS routines
//
//  Boot from DS routines
//

DNS_STATUS
Ds_CreateZoneFromDs(
    IN      PLDAPMessage    pZoneMessage,
    IN      PDNS_DP_INFO    pDpInfo,
    OUT     PZONE_INFO *    ppZone,         OPTIONAL
    OUT     PZONE_INFO *    ppExistingZone  OPTIONAL
    )
/*++

Routine Description:

    Create zone from an LDAP search message.

    If a zone with this name already exists, a pointer to the
    existing zone info blob is returned in ppZone and the return
    code is DNS_ERROR_ZONE_ALREADY_EXISTS.

    Special handling for DS-integrated Root Hints:

    It is possible that the root hints will exist in both the legacy
    partition and another directory partition. In this case, the
    legacy partition root hints will be loaded first. Then this
    function will be called again to try and load the Root Hints
    from the directory partition.

    If the current root hints are in the legacy partition and the
    new roots hints are in the built-in domain partition, we should
    unload the existing root hints and reload the domain partition
    roots hints. We also need to set the DN in the root hint zone
    so that when we write the root hints back they go into the
    domain partition. This leaves the legacy partition root hints
    orphaned. They will be used as a "backup" for any DNS server
    that does not have access to the domain partition.

Arguments:

    pZoneMessage -- LDAP message with zone info

    ppZone -- addr to receive zone pointer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "Ds_CreateZoneFromDs" )

    PZONE_INFO      pzone = NULL;
    PWSTR  *        ppwvalName = NULL;
    PWCHAR          pwzoneName;
    CHAR            pzoneName [ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_STATUS      status = ERROR_SUCCESS;
    PDS_PROPERTY    property;
    INT             i;

    DNS_DEBUG( DS, ( "Ds_CreateZoneFromDs()\n" ));

    ASSERT( pZoneMessage );

    //
    //  read zone name from LDAP message
    //

    //STAT_INC( DsStats.DsTotalZonesRead );

    ppwvalName = ldap_get_values(
                    pServerLdap,
                    pZoneMessage,
                    DSATTR_DC );
    if ( !ppwvalName  ||  !ppwvalName [0] )
    {
        DNS_PRINT((
            "ERROR: Container name value count != 1 on domain object at %p\n",
            pZoneMessage ));
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( FALSE );
        goto Done;
    }
    DNS_DEBUG( DS, ( "Found DS zone <%S>\n", ppwvalName[0] ));
    pwzoneName = ppwvalName[0];

    //
    //  check for DS munged name -- collision or deleted
    //

    if ( isDsProcessedName( pwzoneName ) )
    {
        DNS_DEBUG( DS, (
            "DS zone name %S was processed name -- skipping load\n",
            pwzoneName ));
        status = ERROR_INVALID_NAME;
        goto Done;
    }

    WC_TO_UTF8( pwzoneName, pzoneName, DNS_MAX_NAME_BUFFER_LENGTH );

    //
    //  cache zone?
    //      - reset database to DS
    //

    if ( wcsicmp_ThatWorks( DS_CACHE_ZONE_NAME, pwzoneName ) == 0 )
    {
        //
        //  Have we already loaded the root hints from this location?
        //

        if ( g_pRootHintsZone &&
            g_pRootHintsZone->pDpInfo == pDpInfo )
        {
            if ( ppExistingZone )
            {
                *ppExistingZone = g_pRootHintsZone;
            }
            status = DNS_ERROR_ZONE_ALREADY_EXISTS;
            goto Done;
        }

        //
        //  If these root hints are in a directory partition but it is
        //  not an allowable directory partition do not load them.
        //

        if ( !IS_DP_ALLOWED_TO_HAVE_ROOTHINTS( pDpInfo ) )
        {
            DNS_DEBUG( DS, (
                "Ignoring root hints found in partition where they are not allowed\n"
                "    %s\n",
                pDpInfo ? pDpInfo->pszDpFqdn : "NULL" ));
            status = DNS_ERROR_ZONE_CONFIGURATION_ERROR;
            goto Done;
        }

        //
        //  If root hints have already been loaded, throw them away.
        //

        Zone_DumpData( g_pRootHintsZone );

        //
        //  Set partition for the root hint zone.
        //

        g_pRootHintsZone->fDsIntegrated = TRUE;
        Ds_SetZoneDp( g_pRootHintsZone, pDpInfo, FALSE );

        //
        //  Load these root hints.
        //

        status = Ds_OpenZone( g_pRootHintsZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "ERROR: <%lu>: Failed to open RootHints zone although found in DS\n",
                status ));
            goto Done;
        }

        status = Zone_DatabaseSetup(
                    g_pRootHintsZone,
                    TRUE,           //  DS integrated
                    NULL,           //  filename
                    0,              //  filename length
                    0,              //  flags
                    pDpInfo,        //  DP pointer
                    0,              //  DP flags
                    NULL );         //  DP FQDN
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR: Cache zone database reset to DS failed\n" ));
            goto Done;
        }

        pzone = g_pRootHintsZone;
    }

    //
    //  Create a zone (other than cache zone). The zone will created with
    //  type primary then we will reset the zone type later when we read
    //  the zone properties from the DS.
    //

    else
    {
        status = Zone_Create(
                    &pzone,
                    DNS_ZONE_TYPE_PRIMARY,
                    pzoneName,
                    0,
                    0,          //  flags
                    NULL,       //  no masters
                    TRUE,       //  DS-integrated
                    pDpInfo,    //  directory partition
                    NULL,       //  no file
                    0,
                    NULL,
                    ppExistingZone );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "%s: error 0x%X creating zone %S\n", fn,
                status,
                ppwvalName[ 0 ] ));
            goto Done;
        }

        //  read zone properties

        Ds_ReadZoneProperties(
            pzone,
            pZoneMessage );

        //
        //  Have we read a zone type we are not capable of handling?
        //

        if ( pzone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
             pzone->fZoneType != DNS_ZONE_TYPE_STUB &&
             pzone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
        {
            DNS_PRINT((
                "ERROR: read unsupported zone type %d from the DS for zone %s\n",
                pzone->fZoneType,
                pzone->pszZoneName ));
    
            Zone_Delete( pzone, 0 );
            pzone = NULL;

            status = DNS_ERROR_INVALID_ZONE_TYPE;
        }
    }

Done:

    if ( ppZone )
    {
        *ppZone = pzone;
    }

    DNS_DEBUG( DS2, (
        "Leaving DsGetNextZoneInSearch()\n"
        "    pZone    = %p\n"
        "    name     = %s\n"
        "    status   = %p (%d)\n",
        pzone,
        pzone ? pzone->pszZoneName : NULL,
        status, status ));

    if ( ppwvalName )
    {
        ldap_value_free( ppwvalName );
    }
    return status;
}



DNS_STATUS
buildZoneListFromDs(
    VOID
    )
/*++

Routine Description:

    Do LDAP search on zone.

Arguments:

    pZone -- zone found

    dwSearchFlag -- type of search to do on node

    pSearchBlob -- ptr to search blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAPSearch     psearch;
    DS_SEARCH       searchBlob;
    PWCHAR          pwszfilter;
    WCHAR           wszfilter[ 50 ];
    ULONG           data = 1;
    DWORD           searchTime;
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl_DGO,
        &NoDsSvrReferralControl,
        NULL
    };


    DNS_DEBUG( DS2, (
        "Ds_CreateZonesFromDs()\n" ));

    Ds_InitializeSearchBlob( &searchBlob );

    //
    //  start search for zones
    //

    DNS_DEBUG( DS2, (
        "ldap_search_init_page:\n"
        "    pServerLdap  = %p\n"
        "    search root  = %S\n"
        "    filter       = %S\n",
        pServerLdap,
        g_pwszDnsContainerDN,
        g_szDnsZoneFilter ));

    DS_SEARCH_START( searchTime );

    psearch = ldap_search_init_page(
                    pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_ONELEVEL,
                    g_szDnsZoneFilter,
                    DsTypeAttributeTable,
                    FALSE,
                    ctrls,
                    NULL,                       // no client controls
                    DNS_LDAP_TIME_LIMIT_S,      // time limit
                    0,
                    NULL                        // no sort
                    );

    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler(
                        LdapGetLastError(),
                        g_pwszDnsContainerDN,
                        pServerLdap,
                        0 );
        goto Failed;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  continue zone search
    //  build zones for each DS zone found
    //

    while ( 1 )
    {
        //
        //  Keep SCM happy.
        //

        Service_LoadCheckpoint();

        //
        //  Process the next zone.
        //

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                DNS_DEBUG( DS2, ( "All zones read from DS\n" ));
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( ANY, ( "ERROR: Ds_GetNextMessageInSearch for zones failed\n" ));
            goto Failed;
        }

        status = Ds_CreateZoneFromDs(
                    searchBlob.pNodeMessage,
                    NULL,       //  directory partition
                    NULL,       //  output zone pointer
                    NULL );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR: Unable to create zone from DS message!\n" ));
        }

    }

    //
    //  Search the non-legacy directory partitions for zones.
    //

    status = Dp_BuildZoneList( NULL );

Failed:

    if ( searchBlob.pSearchBlock )
    {
        ldap_search_abandon_page(
            pServerLdap,
            searchBlob.pSearchBlock );
    }

    DNS_DEBUG( ANY, (
        "Leaving DsCreateZonesFromDs() %p (%d)\n",
        status, status ));

    return status;
}



DNS_STATUS
Ds_BootFromDs(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Boot from directory.

Arguments:

    dwFlag - flag indicating DS open requirements
        0
        DNSDS_MUST_OPEN
        DNSDS_WAIT_FOR_DS

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_DS_UNAVAILABLE if DS not available on this server.
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( INIT, (
        "\n\nDs_BootFromDs()\n",
        "    flag = %p\n",
        dwFlag ));

    //
    //  open DS
    //

    status = Ds_OpenServer( dwFlag );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR %lu: DS open failed!\n",
            status ));
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Failed;
    }

    //
    //  read server properties
    //

    if ( !isDNinDS( pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_BASE,
                    NULL,
                    NULL) )
    {
        DNS_DEBUG( ANY, ("Cannot find DNS container on the DS\n"));
        goto Failed;
    }

    //
    //  build zone list from DS
    //  if successful, setup notify for zone add\delete
    //

    status = buildZoneListFromDs();
    if ( status == ERROR_SUCCESS )
    {
        setNotifyForIncomingZone ();
    }
    ELSE
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to create zone list from the DS\n",
            status ));
    }

Failed:

    //
    //  if unitialized
    //      - fail, if failure
    //      - cleanup registry if success
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        //  when uninitialized boot, final status is DS-boot status so
        //  boot routine can make determination on switching method

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "Failed to load from DS on uninitialized load\n" ));
        }
        else
        {
            Boot_ProcessRegistryAfterAlternativeLoad(
                FALSE,      // not boot file load
                FALSE       // do not load other zones -- delete them
                );
        }
    }

    //
    //  if DS boot, load any other registry zones
    //      - even if unable to open directory, still load non-DS registry zones
    //

    else
    {
        DNS_STATUS tempStatus;

        ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY );

        tempStatus = Boot_ProcessRegistryAfterAlternativeLoad(
                        FALSE,      // not boot file load
                        TRUE        // load other registry zones
                        );
        if ( tempStatus == ERROR_SUCCESS )
        {
            status = ERROR_SUCCESS;
        }
    }

    DNS_DEBUG( DS, (
        "Leaving Ds_BootFromDs()\n"
        "    status = 0x%X (%d)\n\n",
        status, status ));

    return status;
}



DNS_STATUS
Ds_ListenAndAddNewZones(
    VOID
    )
/*++

Routine Description:

    Listen for a new zone notification & add arriving ones
    to our zone list.

    DEVNOTE-DCR: 455376 - g_ZoneNotifyMsgId is not thread safe?

Arguments:


Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS          status;
    BOOL                bstatus;
    LDAP_TIMEVAL        timeval = { 0, 0 };      // poll
    PLDAPMessage        presultMsg = NULL;
    PLDAPMessage        pentry;
    WCHAR               wzoneName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR                zoneName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PWCHAR              pwch;
    PWSTR               pwdn = NULL;
    PWSTR  *            ppvals = NULL;
    PZONE_INFO          pzone = NULL;
    static DWORD        s_dwNotifications = 0;
    INT                 i;

    DNS_DEBUG( DS, (
        "Ds_ListenAndAddNewZones()\n" ));

    if ( SrvCfg_fBootMethod != BOOT_METHOD_DIRECTORY )
    {
        DNS_DEBUG( DS, (
            "Warning: Cannot add replicating zones since boot method is not DS\n" ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  lost (or never started) zone notify
    //      - try restart
    //

    if ( INVALID_MSG_ID == g_ZoneNotifyMsgId )
    {
        DNS_DEBUG( ANY, (
            "Error: g_ZoneNotifyMsgId is invalid!\n" ));
        status = setNotifyForIncomingZone();
        return status;
    }

    //
    //  query for new zones
    //
    //  Note: we'll get only one at a time. This is the only option we can use for ldap
    //  notifications.
    //
    //  NOTE: sadly the DS will notify us of ANY changed to zone objects ("by design"),
    //  so we'll have to filter & process zone additions/deletion/attribute value change
    //  based on whether we have the zone or not.
    //

    //
    //  loop to exhaust notifications for this polling interval
    //
    //  DEVNOTE: for zone add\delete ought to spin up thread to keep polling rolling
    //

    while ( 1 )
    {
        if ( presultMsg )
        {
            ldap_msgfree( presultMsg );
        }

        //STAT_INC( PrivateStats.LdapZoneAddResult );

        status = ldap_result(
                        pServerLdap,
                        g_ZoneNotifyMsgId,
                        LDAP_MSG_ONE,
                        &timeval,
                        &presultMsg );

        //
        //  timeout -- no more data for this poll -- bail
        //

        if ( status == 0 )
        {
            //STAT_INC( PrivateStats.LdapZoneAddResultTimeout );

            DNS_DEBUG( DS, (
                "Zone-add search timeout -- no zone changes\n" ));
            break;
        }

        //
        //  have change -- check if add or delete of zone
        //

        else if ( status == LDAP_RES_SEARCH_ENTRY )
        {
            //
            //  increment notifications so that we know eventually to re-issue
            //  query.
            //
            //  DEVNOTE: there's no query reissue from this variable?
            //      this is useless, remove when get stats up and replace
            //      references to it
            //

            s_dwNotifications++;

            //STAT_INC( PrivateStats.LdapZoneAddResultSuccess );

            //
            //  check each message in result
            //

            for ( pentry = ldap_first_entry( pServerLdap, presultMsg );
                  pentry != NULL;
                  pentry = ldap_next_entry( pServerLdap, pentry ) )
            {
                //STAT_INC( PrivateStats.LdapZoneAddResultMessage );
                
                ldap_memfree( pwdn );

                pwdn = ldap_get_dn( pServerLdap, pentry );
                if ( !pwdn )
                {
                    ASSERT( pwdn );
                    continue;
                }

                DNS_DEBUG( DS, (
                    "Received DS notification (%d) for new zone %S\n",
                     s_dwNotifications,
                     pwdn ));

                IF_DEBUG ( DS2 )
                {
                    DNS_DEBUG( ANY, (
                        "ZONE CHANGE NOTIFY #%ld: %S\n",
                        s_dwNotifications,
                        pwdn ));

                    ppvals = ldap_get_values(
                                    pServerLdap,
                                    pentry,
                                    L"usnChanged" );
                    if ( ppvals && ppvals[0] )
                    {
                        DNS_DEBUG( ANY, (
                            "    ZONE SEARCH: usnChanged: %S\n",
                            ppvals[0] ));
                        ldap_value_free( ppvals );
                        ppvals = NULL;
                    }
                    ppvals = ldap_get_values(
                                    pServerLdap,
                                    pentry,
                                    L"whenChanged" );
                    if ( ppvals && ppvals[0] )
                    {
                        DNS_DEBUG( ANY, (
                            "    ZONE SEARCH: whenChanged: %S\n",
                            ppvals[0] ));
                        ldap_value_free ( ppvals );
                        ppvals = NULL;
                    }
                }

                //
                //  zone deletion
                //
                //  first determine if DS "processed name" -- collision or deletion
                //  if deletion, pull out zone name and delete
                //

                if ( isDsProcessedName( pwdn ) )
                {
                    if ( !readDsDeletedName( pwdn, wzoneName ) )
                    {
                        DNS_DEBUG( DS, (
                            "DS processed name %S is not deletion, continuing zone search\n",
                            pwdn ));
                        continue;
                    }
                    DNS_DEBUG( DS, (
                        "Received notification for replication of deleted zone %S\n",
                        wzoneName ));

                    //
                    //  found zone name to delete -- convert to UTF8
                    //

                    WC_TO_UTF8( wzoneName, zoneName, DNS_MAX_NAME_LENGTH );

                    //
                    //  delete zone
                    //      - zone exists AND
                    //      - has not been converted to another type
                    //

                    pzone = Zone_FindZoneByName( zoneName );
                    if ( pzone  &&  pzone->fDsIntegrated )
                    {
                        PVOID               parg = wzoneName;
                        struct berval **    ppvalProperty;
                        BOOL                match;

                        //
                        //  If the zone that is being deleted is not currently 
                        //  located in the legacy partition we can ignore this
                        //  notification - because we only listen for
                        //  notifications on the legacy partition. Probably
                        //  what happened is the admin moved the zone from
                        //  the legacy partition to another partition.
                        //
                        
                        if ( !IS_DP_LEGACY( ZONE_DP( pzone ) ) )
                        {
                            DNS_DEBUG( DS, (
                                "Received bogus DS notification for zone %S\n",
                                wzoneName ));
                            continue;
                        }
                        
                        //
                        //  Check the GUID of the object being deleted. If this
                        //  is not the same as the GUID in memory for this zone,
                        //  then this delete notification is an echo of a past
                        //  deletion we have already processed, so ignore it.
                        //
                        
                        ppvalProperty = ldap_get_values_len(
                                            pServerLdap,
                                            pentry,
                                            DNS_ATTR_OBJECT_GUID );

                        ASSERT( ppvalProperty &&
                                ppvalProperty[ 0 ] &&
                                ppvalProperty[ 0 ]->bv_len == sizeof( GUID ) );

                        if ( !pzone->pZoneObjectGuid )
                        {
                            //
                            //  If we have not loaded a GUID for this zone for
                            //  some reason we must process this notification.
                            //
                            
                            ASSERT( pzone->pZoneObjectGuid );
                            match = TRUE;
                        }
                        else
                        {
                            match = ppvalProperty &&
                                    ppvalProperty[ 0 ] &&
                                    ppvalProperty[ 0 ]->bv_len == sizeof( GUID ) &&
                                    RtlEqualMemory(
                                            ppvalProperty[ 0 ]->bv_val,
                                            pzone->pZoneObjectGuid,
                                            sizeof( GUID ) );
                        }
    
                        ldap_value_free_len( ppvalProperty );
                        ppvalProperty = NULL;

                        if ( !match )
                        {
                            //
                            //  The GUIDs do not match. Ignore this notification.
                            //

                            DNS_DEBUG( DS, (
                                "Received DS delete notification for zone %S with bad GUID\n",
                                wzoneName ));
                            continue;
                        }

                        //
                        //  This looks like a valid zone delete.
                        //
                        
                        Zone_Delete( pzone, 0 );

                        //STAT_INC( PrivateStats.LdapZoneAddDelete );

                        DNS_LOG_EVENT(
                            DNS_EVENT_DS_ZONE_DELETE_DETECTED,
                            1,
                            & parg,
                            NULL,
                            0 );
                    }
                    else
                    {
                        DNS_DEBUG( DS, (
                            "Skipping DS poll zone delete for %S\n"
                            "    zone %s\n",
                            wzoneName,
                            pzone ? "exists but is not DS integrated" : "does not exist" ));

                        //STAT_INC( PrivateStats.LdapZoneAddDeleteAlready );
                    }
                    continue;
                }

                //
                //  potential zone create
                //    - create zone dotted name
                //    - see if zone's here
                //

                ppvals = ldap_get_values(
                                pServerLdap,
                                pentry,
                                DsTypeAttributeTable[I_DSATTR_DC]
                                );
                if ( ppvals && ppvals[0] )
                {
                    ASSERT( wcslen(ppvals[0]) <= DNS_MAX_NAME_LENGTH );
                    wcscpy( wzoneName, ppvals[0] );
                    ldap_value_free( ppvals );
                    ppvals = NULL;
                }
                else
                {
                    DNS_DEBUG( ANY, (
                        "Error: failed to get DC value for zone %S\n",
                        pwdn ));
                    continue;
                }

                //
                //  Convert to UTF8 for db lookup
                //

                WC_TO_UTF8( wzoneName, zoneName, DNS_MAX_NAME_LENGTH );

                //
                //  ignore RootDNSServers (already have RootHints zone)
                //

                if ( !wcscmp(wzoneName, DS_CACHE_ZONE_NAME) )
                {
                    DNS_DEBUG( DS, (
                        "Notification for RootHints: Skipping notification %ld for Zone %S creation\n",
                        s_dwNotifications,
                        wzoneName ));
                    continue;
                }

                //
                //  If the zone already exists but is not in the legacy 
                //  partition (note: we only receive notifications for
                //  zones in the legacy partitions), then we must toss
                //  out the zone in memory and load the new zone. This
                //  is likely to occur when a zone is moved from an
                //  NDNC to the legacy partition.
                //

                pzone = Zone_FindZoneByName( zoneName );
                if ( pzone )
                {
                    if ( !ZONE_DP( pzone ) || IS_DP_LEGACY( ZONE_DP( pzone ) ) )
                    {
                        DNS_DEBUG( DS, (
                            "Zone Exist: Skipping notification %ld for Zone %S creation\n",
                            s_dwNotifications,
                            wzoneName ));
                        continue;
                    }
                    
                    //
                    //  Delete in-memory copy of the zone and reload the
                    //  zone from it's new location.
                    //

                    Zone_Delete( pzone, 0 );
                }

                //
                //  create the new zone
                //

                status = Ds_CreateZoneFromDs(
                            pentry,
                            NULL,       //  directory partition
                            &pzone,
                            NULL );     //  existing zone

                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( DS, (
                        "Error <%lu>: Failed to create zone from notification\n",
                        status ));
                    continue;
                }

                status = Zone_Load( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    //
                    //  failed to load zone
                    //  this can be caused by zone that was added and then deleted
                    //  since last poll, so no zone is currently in directory
                    //

                    DNS_DEBUG( DS, (
                        "Error <%lu>: Failed to load zone from notification\n",
                        status ));

                    ASSERT( IS_ZONE_SHUTDOWN( pzone ) );
                    ASSERT( IS_ZONE_LOCKED ( pzone ) );

                    Zone_Delete( pzone, 0 );
                    continue;
                }

                //STAT_INC( PrivateStats.LdapZoneAddSuccess );

                // Zone must be locked due to Zone_Create()
                ASSERT( IS_ZONE_LOCKED( pzone ) );
                Zone_UnlockAfterAdminUpdate( pzone );
                continue;

            }   // loop thru search results

            //
            //  retry ldap_result() to check for more data
            //

            continue;
        }

        //
        //  anything else is error
        //      - abandon the current change-notify search
        //      - reissue new search
        //

        else
        {
            ASSERT( status == LDAP_RES_ANY || status == LDAP_RES_SEARCH_RESULT );

            //STAT_INC( PrivateStats.LdapZoneAddResultFailure );

            //  log error and free message

            status = ldap_result2error(
                            pServerLdap,
                            presultMsg,
                            TRUE );
            presultMsg = NULL;

            DNS_DEBUG( ANY, (
                "ERROR <%lu> (%S): from ldap_result() in zone-add-delete search\n",
                status,
                ldap_err2string( status ) ));

            //
            //  abandon old search
            //  start new change-notify search
            //

            ldap_abandon(
                pServerLdap,
                g_ZoneNotifyMsgId );
            
            g_ZoneNotifyMsgId = INVALID_MSG_ID;

            status = setNotifyForIncomingZone();
            break;
        }
    }

    //
    //  cleanup
    //

    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }
    if ( pwdn )
    {
        ldap_memfree( pwdn );
    }

    IF_DEBUG( ANY )
    {
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR: <%lu (%p)>: Ds_ListenAndAddNewZones() failed\n",
                status, status ));
        }
        else
        {
            DNS_DEBUG( DS, ( "Exit Ds_ListenAndAddNewZones\n" ));
        }
    }

    return status;
}



//
//  LDAP error mapping code
//

//
//  Map generic responses
//
//  DEVNOTE: should have LDAP to WIN32 error handler that works
//  DEVNOTE: should have generic LDAP failed error
//  DEVNOTE: generic DS server failed LDAP operation error

#define _E_LDAP_RUNTIME             DNS_ERROR_DS_UNAVAILABLE
#define _E_LDAP_MISSING             ERROR_DS_UNKNOWN_ERROR
#define _E_LDAP_SECURITY            ERROR_ACCESS_DENIED
#define _E_LDAP_NO_DS               DNS_ERROR_DS_UNAVAILABLE

//
//  LDAP error to DNS Win32 error table
//

DNS_STATUS  LdapErrorMappingTable[] =
{
    ERROR_SUCCESS,
    _E_LDAP_RUNTIME,                    //  LDAP_OPERATIONS                 =   0x01,
    _E_LDAP_RUNTIME,                    //  LDAP_PROTOCOL                   =   0x02,
    _E_LDAP_RUNTIME,                    //  LDAP_TIMELIMIT_EXCEEDED         =   0x03,
    _E_LDAP_RUNTIME,                    //  LDAP_SIZELIMIT_EXCEEDED         =   0x04,
    _E_LDAP_RUNTIME,                    //  LDAP_COMPARE_FALSE              =   0x05,
    _E_LDAP_RUNTIME,                    //  LDAP_COMPARE_TRUE               =   0x06,
    _E_LDAP_SECURITY,                   //  LDAP_AUTH_METHOD_NOT_SUPPORTED  =   0x07,
    _E_LDAP_SECURITY,                   //  LDAP_STRONG_AUTH_REQUIRED       =   0x08,
    _E_LDAP_RUNTIME,                    //  LDAP_PARTIAL_RESULTS            =   0x09,
    _E_LDAP_RUNTIME,                    //  LDAP_REFERRAL                   =   0x0a,
    _E_LDAP_RUNTIME,                    //  LDAP_ADMIN_LIMIT_EXCEEDED       =   0x0b,
    _E_LDAP_RUNTIME,                    //  LDAP_UNAVAILABLE_CRIT_EXTENSION =   0x0c,
    _E_LDAP_SECURITY,                   //  LDAP_CONFIDENTIALITY_REQUIRED   =   0x0d,
    _E_LDAP_RUNTIME,                    //  LDAP_SASL_BIND_IN_PROGRESS      =   0x0e,
    _E_LDAP_MISSING,                    //  0x0f

    _E_LDAP_RUNTIME,                    //  LDAP_NO_SUCH_ATTRIBUTE          =   0x10,
    _E_LDAP_RUNTIME,                    //  LDAP_UNDEFINED_TYPE             =   0x11,
    _E_LDAP_RUNTIME,                    //  LDAP_INAPPROPRIATE_MATCHING     =   0x12,
    _E_LDAP_RUNTIME,                    //  LDAP_CONSTRAINT_VIOLATION       =   0x13,
    _E_LDAP_RUNTIME,                    //  LDAP_ATTRIBUTE_OR_VALUE_EXISTS  =   0x14,
    _E_LDAP_RUNTIME,                    //  LDAP_INVALID_SYNTAX             =   0x15,
    _E_LDAP_MISSING,                    //  0x16
    _E_LDAP_MISSING,                    //  0x17
    _E_LDAP_MISSING,                    //  0x18
    _E_LDAP_MISSING,                    //  0x19
    _E_LDAP_MISSING,                    //  0x1a
    _E_LDAP_MISSING,                    //  0x1b
    _E_LDAP_MISSING,                    //  0x1c
    _E_LDAP_MISSING,                    //  0x1d
    _E_LDAP_MISSING,                    //  0x1e
    _E_LDAP_MISSING,                    //  0x1f

    ERROR_DS_OBJ_NOT_FOUND,             //  LDAP_NO_SUCH_OBJECT             =   0x20,
    _E_LDAP_RUNTIME,                    //  LDAP_ALIAS_PROBLEM              =   0x21,
    _E_LDAP_RUNTIME,                    //  LDAP_INVALID_DN_SYNTAX          =   0x22,
    _E_LDAP_RUNTIME,                    //  LDAP_IS_LEAF                    =   0x23,
    _E_LDAP_RUNTIME,                    //  LDAP_ALIAS_DEREF_PROBLEM        =   0x24,
    _E_LDAP_MISSING,                    //  0x25
    _E_LDAP_MISSING,                    //  0x26
    _E_LDAP_MISSING,                    //  0x27
    _E_LDAP_MISSING,                    //  0x28
    _E_LDAP_MISSING,                    //  0x29
    _E_LDAP_MISSING,                    //  0x2a
    _E_LDAP_MISSING,                    //  0x2b
    _E_LDAP_MISSING,                    //  0x2c
    _E_LDAP_MISSING,                    //  0x2d
    _E_LDAP_MISSING,                    //  0x2e
    _E_LDAP_MISSING,                    //  0x2f

    _E_LDAP_SECURITY,                   //  LDAP_INAPPROPRIATE_AUTH         =   0x30,
    _E_LDAP_SECURITY,                   //  LDAP_INVALID_CREDENTIALS        =   0x31,
    _E_LDAP_SECURITY,                   //  LDAP_INSUFFICIENT_RIGHTS        =   0x32,
    _E_LDAP_RUNTIME,                    //  LDAP_BUSY                       =   0x33,
    _E_LDAP_NO_DS,                      //  LDAP_UNAVAILABLE                =   0x34,
    _E_LDAP_SECURITY,                   //  LDAP_UNWILLING_TO_PERFORM       =   0x35,
    _E_LDAP_RUNTIME,                    //  LDAP_LOOP_DETECT                =   0x36,
    _E_LDAP_MISSING,                    //  0x37
    _E_LDAP_MISSING,                    //  0x38
    _E_LDAP_MISSING,                    //  0x39
    _E_LDAP_MISSING,                    //  0x3a
    _E_LDAP_MISSING,                    //  0x3b
    _E_LDAP_MISSING,                    //  0x3c
    _E_LDAP_MISSING,                    //  0x3d
    _E_LDAP_MISSING,                    //  0x3e
    _E_LDAP_MISSING,                    //  0x3f

    _E_LDAP_RUNTIME,                    //  LDAP_NAMING_VIOLATION           =   0x40,
    _E_LDAP_RUNTIME,                    //  LDAP_OBJECT_CLASS_VIOLATION     =   0x41,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_ALLOWED_ON_NONLEAF     =   0x42,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_ALLOWED_ON_RDN         =   0x43,
    _E_LDAP_RUNTIME,                    //  LDAP_ALREADY_EXISTS             =   0x44,
    _E_LDAP_RUNTIME,                    //  LDAP_NO_OBJECT_CLASS_MODS       =   0x45,
    _E_LDAP_RUNTIME,                    //  LDAP_RESULTS_TOO_LARGE          =   0x46,
    _E_LDAP_RUNTIME,                    //  LDAP_AFFECTS_MULTIPLE_DSAS      =   0x47,
    _E_LDAP_MISSING,                    //  0x48
    _E_LDAP_MISSING,                    //  0x49
    _E_LDAP_MISSING,                    //  0x4a
    _E_LDAP_MISSING,                    //  0x4b
    _E_LDAP_MISSING,                    //  0x4c
    _E_LDAP_MISSING,                    //  0x4d
    _E_LDAP_MISSING,                    //  0x4e
    _E_LDAP_MISSING,                    //  0x4f

    _E_LDAP_RUNTIME,                    //  LDAP_OTHER                      =   0x50,
    _E_LDAP_NO_DS,                      //  LDAP_SERVER_DOWN                =   0x51,
    _E_LDAP_RUNTIME,                    //  LDAP_LOCAL                      =   0x52,
    _E_LDAP_RUNTIME,                    //  LDAP_ENCODING                   =   0x53,
    _E_LDAP_RUNTIME,                    //  LDAP_DECODING                   =   0x54,
    ERROR_TIMEOUT,                      //  LDAP_TIMEOUT                    =   0x55,
    _E_LDAP_SECURITY,                   //  LDAP_AUTH_UNKNOWN               =   0x56,
    _E_LDAP_RUNTIME,                    //  LDAP_FILTER                     =   0x57,
    _E_LDAP_RUNTIME,                    //  LDAP_USER_CANCELLED             =   0x58,
    _E_LDAP_RUNTIME,                    //  LDAP_PARAM                      =   0x59,
    ERROR_OUTOFMEMORY,                  //  LDAP_NO_MEMORY                  =   0x5a,
    _E_LDAP_RUNTIME,                    //  LDAP_CONNECT                    =   0x5b,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_SUPPORTED              =   0x5c,
    _E_LDAP_RUNTIME,                    //  LDAP_NO_RESULTS_RETURNED        =   0x5e,
    _E_LDAP_RUNTIME,                    //  LDAP_CONTROL_NOT_FOUND          =   0x5d,
    _E_LDAP_RUNTIME,                    //  LDAP_MORE_RESULTS_TO_RETURN     =   0x5f,

    _E_LDAP_RUNTIME,                    //  LDAP_CLIENT_LOOP                =   0x60,
    _E_LDAP_RUNTIME,                    //  LDAP_REFERRAL_LIMIT_EXCEEDED    =   0x61
};

#define MAX_MAPPED_LDAP_ERROR   (LDAP_REFERRAL_LIMIT_EXCEEDED)


DNS_STATUS
Ds_LdapErrorMapper(
    IN      DWORD           LdapStatus
    )
/*++

Routine Description:

    Maps LDAP errors to Win32 errors.

Arguments:

    LdapStatus -- LDAP error code status

Return Value:

    Win32 error code.

--*/
{
    if ( LdapStatus > MAX_MAPPED_LDAP_ERROR )
    {
        return LdapStatus;
    }

    return ( DNS_STATUS ) LdapErrorMappingTable[ LdapStatus ];
}


DNS_STATUS
Ds_LdapUnbind(
    IN OUT  PLDAP *         ppLdap
    )
/*++

Routine Description:

    Thin wrapper around ldap_unbind.

Arguments:

    pLdap -- LDAP session to unbind

Return Value:

    Win32 error code.

--*/
{
    ULONG       status;

    if ( ppLdap && *ppLdap )
    {    
        ASSERT( g_ServerState == DNS_STATE_TERMINATING ||
                *ppLdap != pServerLdap );

        status = ldap_unbind( *ppLdap );
        
        if ( status == 0 )
        {
            *ppLdap = NULL;
            return ERROR_SUCCESS;
        }
        return Ds_LdapErrorMapper( status );
    }

    return ERROR_SUCCESS;
}


//
//  End ds.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\ds.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    ds.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to DS.C 

Author:

    Jeff Westhead, September 1999

Revision History:

--*/


#ifndef _DS_H_INCLUDED
#define _DS_H_INCLUDED


#ifdef LDAP_UNICODE
#define  LDAP_TEXT(str)           L ## str
#else
#define  LDAP_TEXT(str)           str
#endif


//
//  Open specifying NULL for server name.
//  LDAP will connect this to local DS if available.
//
//  Note: can not use loopback address due to reduced security.
//

#define LOCAL_SERVER                NULL
#define LOCAL_SERVER_W              NULL


//
//  DN path is essentially:
//      - DN for DS root, which is essentially limited to 255 of DNS name, plus
//      overhead;  overhead may substaintial since labels individual broken out in DN
//      meaning each has "dc=" overhead (absolute worst case 127 labels x 4 bytes per)
//      - MicrosoftDns and System containers
//      - zone DNS path (255 limit + dc=)
//      - node DNS name (255 limit + dc=)
//

#define MAX_DN_PATH                 1280


//
// Default time limit on LDAP operations
//

#define DNS_LDAP_TIME_LIMIT_S       180        // seconds
#define DNS_LDAP_TIME_LIMIT_MS      180000     // milliseconds


extern PLDAP    pServerLdap;


//
// DS attribute definitions
//

extern LDAP_TIMEVAL    g_LdapTimeout;

//
//
//

typedef struct _DsAttrPair
{
    PWSTR           szAttrType;
    BOOL            fMultiValued;
    union
    {
        PWSTR       pszAttrVal;     //  single-valued
        PWSTR *     ppszAttrVals;   //  multi-valued (allocated array of allocated strings)
    };
}
DSATTRPAIR, *PDSATTRPAIR;

extern DSATTRPAIR DSEAttributes[];

#define I_DSE_CURRENTTIME    0
#define I_DSE_DSSERVICENAME  1
#define I_DSE_DEF_NC         2
#define I_DSE_SCHEMA_NC      3      //  must be before NamingContexts
#define I_DSE_CONFIG_NC      4      //  must be before NamingContexts
#define I_DSE_ROOTDMN_NC     5
#define I_DSE_HIGHEST_USN    6
#define I_DSE_DNSHOSTNAME    7
#define I_DSE_SERVERNAME     8
#define I_DSE_NAMINGCONTEXTS 9      //  must be after SchemaNC and ConfigNC
#define I_DSE_NULL           10

//
//  Attribute list table. This is not really a necessary construct.
//  could just use constants and trust compiler to optimize dups.
//

extern PWSTR    DsTypeAttributeTable[];

#define I_DSATTR_DC             0
#define I_DSATTR_DNSRECORD      1
#define I_DSATTR_DNSPROPERTY    2
#define I_DSATTR_OBJECTGUID     3
#define I_DSATTR_SD             4
#define I_DSATTR_WHENCREATED    5
#define I_DSATTR_WHENCHANGED    6
#define I_DSATTR_USNCREATED     7
#define I_DSATTR_USNCHANGED     8
#define I_DSATTR_OBJECTCLASS    9
#define I_DSATTR_NULL           10

#define DSATTR_DC               ( DsTypeAttributeTable[ I_DSATTR_DC ] )
#define DSATTR_DNSRECORD        ( DsTypeAttributeTable[ I_DSATTR_DNSRECORD ] )
#define DSATTR_DNSPROPERTY      ( DsTypeAttributeTable[ I_DSATTR_DNSPROPERTY ] )
#define DSATTR_SD               ( DsTypeAttributeTable[ I_DSATTR_SD ])
#define DSATTR_USNCHANGED       ( DsTypeAttributeTable[ I_DSATTR_USNCHANGED ] )
#define DSATTR_WHENCHANGED      ( DsTypeAttributeTable[ I_DSATTR_WHENCHANGED ] )
#define DSATTR_OBJECTCLASS      ( DsTypeAttributeTable[ I_DSATTR_OBJECTCLASS ] )
#define DSATTR_ENABLED          ( L"Enabled" )
#define DSATTR_DISPLAYNAME      ( L"displayName" )
#define DSATTR_BEHAVIORVERSION  ( L"msDS-Behavior-Version" )

#define DNSDS_TOMBSTONE_TYPE    ( DNS_TYPE_ZERO )
#define DNS_TYPE_TOMBSTONE      ( DNS_TYPE_ZERO )


//
//  Forest/domain/DSA behavior version constants.
//

//
//  Use this macro to set behavior version globals with "Forest", "Domain",
//  or "Dsa" as _LEVEL_. The actual value will be boosted up to the forced
//  value if it is lower.
//

#define SetDsBehaviorVersion( _LEVEL_, _VALUE_ )                        \
    g_ulDs##_LEVEL_##Version =                                          \
        ( SrvCfg_dwForce##_LEVEL_##BehaviorVersion !=                   \
            DNS_INVALID_BEHAVIOR_VERSION &&                             \
        SrvCfg_dwForce##_LEVEL_##BehaviorVersion > _VALUE_ ) ?          \
            SrvCfg_dwForce##_LEVEL_##BehaviorVersion :                  \
            _VALUE_;

#define IS_WHISTLER_FOREST()    \
    ( g_ulDsForestVersion >= DS_BEHAVIOR_WIN2003 )

#define IS_WHISTLER_DOMAIN()    \
    ( g_ulDsDomainVersion >= DS_BEHAVIOR_WIN2003 )


//
//  Active Directory version globals
//

extern ULONG        g_ulDsForestVersion;
extern ULONG        g_ulDsDomainVersion;
extern ULONG        g_ulDsDsaVersion;

#define DNS_INVALID_BEHAVIOR_VERSION    (-1)

extern ULONG        g_ulDownlevelDCsInDomain;   //  count of DCs that are
extern ULONG        g_ulDownlevelDCsInForest;   //      less than Whistler

#define DNS_INVALID_COUNT               (-1)


//
//  Misc globals
//

extern  WCHAR    g_szWildCardFilter[];
extern  WCHAR    g_szDnsZoneFilter[];
extern  PWCHAR   g_pszRelativeDnsSysPath;
extern  PWCHAR   g_pszRelativeDnsFolderPath;


//
//  Lazy writing control
//

extern LDAPControl      LazyCommitControl;
extern DWORD            LazyCommitDataValue;

//
//  No-referrals control
//

extern LDAPControl      NoDsSvrReferralControl;

//
//  SD control info
//

extern LDAPControl     SecurityDescriptorControl_DGO;
extern LDAPControl     SecurityDescriptorControl_D;

//
//  Search blob
//

typedef struct _DnsDsEnum
{
    PLDAPSearch     pSearchBlock;           // ldap search result on zone
    PLDAPMessage    pResultMessage;         // current page of message
    PLDAPMessage    pNodeMessage;           // message for current node
    PZONE_INFO      pZone;
    LONGLONG        SearchTime;
    LONGLONG        TombstoneExpireTime;
    DNS_STATUS      LastError;
    DWORD           dwSearchFlag;
    DWORD           dwLookupFlag;
    DWORD           dwHighestVersion;
    DWORD           dwTotalNodes;
    DWORD           dwTotalTombstones;
    DWORD           dwTotalRecords;
#if 0
    DWORD           dwHighUsnLength;
    CHAR            szHighUsn[ MAX_USN_LENGTH ];    // largest USN in enum
#endif
    CHAR            szStartUsn[ MAX_USN_LENGTH ];   // USN at search start

    //  node record data

    PLDAP_BERVAL *  ppBerval;           // the values in the array
    PDB_RECORD      pRecords;
    DWORD           dwRecordCount;
    DWORD           dwNodeVersion;
    DWORD           dwTombstoneVersion;
    BOOL            bAuthenticatedUserSD;
}
DS_SEARCH, *PDS_SEARCH;


#define DNSDS_SEARCH_LOAD       (0)
#define DNSDS_SEARCH_UPDATES    (1)
#define DNSDS_SEARCH_DELETE     (2)
#define DNSDS_SEARCH_TOMBSTONES (3)

//
//  Time LDAP searches
//

#define DS_SEARCH_START( searchTime ) \
        ( searchTime = GetTickCount() )

#define DS_SEARCH_STOP( searchTime ) \
        STAT_ADD( DsStats.LdapSearchTime, (GetTickCount() - searchTime) )


//
//  Function prototypes
//

PWCHAR
Ds_GenerateBaseDnsDn(
    IN      BOOL    fIncludeMicrosoftDnsFolder
    );

VOID
Ds_InitializeSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    );

VOID
Ds_CleanupSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    );

DNS_STATUS
Ds_GetNextMessageInSearch(
    IN OUT  PDS_SEARCH      pSearchBlob
    );

PWSTR
DS_CreateZoneDsName(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Ds_SetZoneDp(
    IN      PZONE_INFO          pZone,
    IN      PDNS_DP_INFO        pDpInfo,
    IN      BOOL                fUseTempDsName
    );

DNS_STATUS
Ds_CreateZoneFromDs(
    IN      PLDAPMessage    pZoneMessage,
    IN      PDNS_DP_INFO    pDpInfo,
    OUT     PZONE_INFO *    ppZone,         OPTIONAL
    OUT     PZONE_INFO *    ppExistingZone  OPTIONAL
    );

DNS_STATUS
Ds_StartDsZoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwSearchFlag
    );

DNS_STATUS
Ds_ReadZoneProperties(
    IN OUT  PZONE_INFO      pZone,
    IN      PLDAPMessage    pZoneMessage        OPTIONAL
    );

DNS_STATUS
Ds_LdapUnbind(
    IN OUT  PLDAP *         ppLdap
    );

DNS_STATUS
Ds_ReadServerObjectSD(
    PLDAP                   pldap,
    PSECURITY_DESCRIPTOR *  ppSd
    );

DNS_STATUS
Ds_LoadRootDseAttributes(
    IN      PLDAP           pLdap
    );
    
    
#endif  //  _DS_H_INCLUDED

//
//  end of ds.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dsutil.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    dsutil.c

Abstract:

    Domain Name System (DNS) Server

    Utility routines for Active Directory ops

Author:

    Jeff Westhead (jwesth)  September, 2002

Revision History:

    jwesth      09/2002     initial implementation

--*/


//
//  Includes
//


#include "dnssrv.h"



//
//  Definitions
//


//
//  External prototypes
//


PWSTR *
copyStringArray(
    IN      PWSTR *     ppVals
    );


//
//  Functions
//



PWSTR *
Ds_GetRangedAttributeValues(
    IN      PLDAP           LdapSession,
    IN      PLDAPMessage    pLdapMsg,
    IN      PWSTR           pwszDn,
    IN      PWSTR           pwszAttributeName,
    IN      PLDAPControl  * pServerControls,
    IN      PLDAPControl  * pClientControls,
    OUT     DNS_STATUS    * pStatus
    )
/*++

Routine Description:

    Use this function in place of ldap_get_values() when it is
    possible that the attribute value might have more than
    1500 values. On .NET the attribute value page size is 1500.
    This limit can only be exceeded by certain types of attributes
    such as DN lists -- see BrettSh for more details.

Arguments:

    LdapSession -- LDAP session handle
    
    pLdapMsg -- existing LDAP search response containing the
        first result for this attribute
    
    pwszDn -- DN of the object
    
    pwszAttributeName -- attribute to retrieve
    
    pServerControls -- controls to pass to further LDAP searches

    pClientControls -- controls to pass to further LDAP searches
    
    pStatus -- error code

Return Value:

    NULL on error or an array of string attribute values for
    this array. The array must be freed with freeStringArray().

--*/
{
    DBG_FN( "Ds_GetRangedAttributeValues" )
    
    #define DNS_MAXIMUM_ATTR_VALUE_SETS     20
    
    DNS_STATUS      status = ERROR_SUCCESS;
    PWSTR *         ppwszFinalValueArray = NULL;
    PWSTR *         ppwszldapAttrValues = NULL;
    PWSTR           pwszattrName = NULL;
    BerElement *    pbertrack = NULL;
    UINT            desiredAttrNameLen = wcslen( pwszAttributeName );
    PWSTR           pwszrover;
    PWSTR *         attributeValueSets[ DNS_MAXIMUM_ATTR_VALUE_SETS ] = { 0 };
    UINT            attributeValueSetIndex = 0;
    PLDAPMessage    pldapAttrSearchMsg = NULL;
    PLDAPMessage    pldapAttrSearchEntry = NULL;
    PWSTR           attrList[ 2 ] = { 0, 0 };
    DWORD           attrlen;
    UINT            attributeValueCount = 0;
    UINT            finalIdx;
    UINT            i;
    BOOL            finished = FALSE;

    DNS_DEBUG( DS, (
        "%s: retrieving attribute %S at DN\n    %S\n", fn,
        pwszAttributeName,
        pwszDn ));

    //
    //  First, attempt to get the attribute values the regular way.
    //  If this succeeds, jump immedately to the bottom of the
    //  function and return. This is the fast path.
    //
    
    ppwszldapAttrValues = ldap_get_values(
                            LdapSession,
                            pLdapMsg, 
                            pwszAttributeName );
    if ( ppwszldapAttrValues && *ppwszldapAttrValues )
    {
        ppwszFinalValueArray = copyStringArray( ppwszldapAttrValues );
        if ( !ppwszFinalValueArray )
        {
            ASSERT( ppwszFinalValueArray );
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        DNS_DEBUG( DS, (
            "%s: found values of %S without range\n", fn, pwszAttributeName ));
        goto Done;
    }
    
    //
    //  The attribute did not have traditional values so we must now
    //  examine all attribute names present in the response to see if
    //  one of them is a ranged instance of the requested attribute.
    //
    
    while ( 1 )
    {
        PLDAPMessage    pldapCurrentMsg = pldapAttrSearchEntry
                                                ? pldapAttrSearchEntry
                                                : pLdapMsg;

        //
        //  For convenienece I have a hard limit on the number of attribute 
        //  value pages that we can collect.
        //
        
        if ( attributeValueSetIndex >= DNS_MAXIMUM_ATTR_VALUE_SETS )
        {
            ASSERT( attributeValueSetIndex >= DNS_MAXIMUM_ATTR_VALUE_SETS );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            DNS_DEBUG( DS, (
                "%s: attribute %S has too many values!\n", fn,
                pwszAttributeName ));
            break;
        }

        //
        //  Clean up stuff from the last search loop iteration.
        //
        
        if ( pwszattrName )
        {
            ldap_memfree( pwszattrName );
            pwszattrName = NULL;
        }
        if ( pbertrack )
        {
            ber_free( pbertrack, 0 );
            pbertrack = NULL;
        }
        
        //
        //  Iterate the attribute values in the message to see if one 
        //  of them is a ranged value of the requested attribute.
        //

        while ( 1 )
        {
            if ( pwszattrName == NULL )
            {
                pwszattrName = ldap_first_attribute(
                                    LdapSession,
                                    pldapCurrentMsg,
                                    &pbertrack );
            }
            else
            {
                ldap_memfree( pwszattrName );
                pwszattrName = ldap_next_attribute(
                                    LdapSession,
                                    pldapCurrentMsg,
                                    pbertrack );
            }
            if ( !pwszattrName )
            {
                break;
            }

            DNS_DEBUG( DS, (
                "%s: examining attribute %S in search %p\n", fn,
                pwszattrName,
                pldapCurrentMsg ));
            
            //
            //  Test this attribute name - is it a ranged value of the
            //  requested attribute?
            //
            
            if ( _wcsnicmp( pwszattrName,
                            pwszAttributeName,
                            desiredAttrNameLen ) == 0 &&
                 pwszattrName[ desiredAttrNameLen ] == L';' )
            {
                break;
            }
        }

        //
        //  If this search contained no ranged value, we are either finished
        //  (if we have found some values already) or we have errored.
        //
        
        if ( !pwszattrName )
        {
            status = attributeValueCount ?
                        ERROR_SUCCESS :
                        LDAP_NO_SUCH_ATTRIBUTE;
            DNS_DEBUG( DS, (
                "%s: no more values (error=%d)\n", fn, status ));
            break;
        }

        DNS_DEBUG( DS, (
            "%s: found ranged attribute value %S\n", fn, pwszattrName ));

        //
        //  Verify that the attribute name we have found is really a
        //  ranged value of the requested arribute. Also, test if this
        //  is the final attribute value page -- the final page will
        //  have "*" as the end range, e.g. "attributeName;range=1500-*".
        //
        
        pwszrover = wcschr( pwszattrName, L';' );
        if ( !pwszrover )
        {
            ASSERT( pwszrover );
            break;
        }
        pwszrover = wcschr( pwszrover, L'-' );
        if ( !pwszrover )
        {
            ASSERT( pwszrover );
            break;
        }
        finished = *( pwszrover + 1 ) == L'*';

        //
        //  Get the values and save them in an array for later.
        //

        ppwszldapAttrValues = ldap_get_values(
                                    LdapSession,
                                    pldapCurrentMsg,
                                    pwszattrName );
        if ( !ppwszldapAttrValues )
        {
            ASSERT( ppwszldapAttrValues );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;
        }
        attributeValueSets[ attributeValueSetIndex++ ] = ppwszldapAttrValues;
        
        //
        //  Update the total count of attribute values.
        //
        
        for ( i = 0; ppwszldapAttrValues[ i ]; ++i )
        {
            ++attributeValueCount;
        }

        DNS_DEBUG( DS, (
            "%s: attribute set %d gives new total of %d values of %S\n", fn,
            attributeValueSetIndex,
            attributeValueCount,
            pwszAttributeName ));

        ppwszldapAttrValues = NULL;
        
        if ( finished )
        {
            break;
        }
        
        //
        //  Open a new search to get the next range of attribute values.
        //  First, format the attribute name we need to request. It will
        //  be of the form "attributeName;range=X-*" where X is the
        //  first attribute value we need. If the last search gave us
        //  0-1499, for example, then we need to request "1500-*" in
        //  this next search.
        //
        
        FREE_HEAP( attrList[ 0 ] );
        attrlen = ( wcslen( pwszAttributeName ) + 30 ) * sizeof( WCHAR );
        attrList[ 0 ] = ALLOCATE_HEAP( attrlen + 1 );
        if ( !attrList[ 0 ] )
        {
            ASSERT( attrList[ 0 ] );
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        status = StringCbPrintfW(
                    attrList[ 0 ],
                    attrlen,
                    L"%ws;range=%d-*",
                    pwszAttributeName,
                    attributeValueCount );
        if ( status != ERROR_SUCCESS )
        {
            break;
        }
        attrList[ 1 ] = NULL;

        //
        //  If we have a search message from the last iteration, free it
        //  but never free the caller's search message.
        //
        
        if ( pldapAttrSearchMsg != pLdapMsg )
        {
            ldap_msgfree( pldapAttrSearchMsg );
            pldapAttrSearchMsg = NULL;
        }
        
        //
        //  Perform LDAP search for next page of ranged attribute values.
        //
        
        status = ldap_search_ext_s(
                    LdapSession,
                    pwszDn,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    attrList,
                    0,
                    pServerControls,
                    pClientControls,
                    &g_LdapTimeout,
                    0,
                    &pldapAttrSearchMsg );

        DNS_DEBUG( DS, (
            "%s: search for %S returned %d with pointer %p\n", fn,
            attrList[ 0 ],
            status,
            pldapAttrSearchMsg ));
        
        if ( status != ERROR_SUCCESS )
        {
            //
            //  If the error is LDAP_OPERATIONS_ERROR, the search is complete.
            //  NOTE: this is left-over and should probably be removed but I
            //  do not have time to re-run this on a DC with >1500 replicas
            //  to verify. In Longhorn, remove the if() immediately below
            //  and always assume that this path means unexpected failure.
            //
            
            if ( status == LDAP_OPERATIONS_ERROR )
            {
                status = ERROR_SUCCESS;
                break;
            }
            status = Ds_ErrorHandler( status, pwszDn, LdapSession, 0 );
            break;
        }

        if ( !pldapAttrSearchMsg )
        {
            ASSERT( pldapAttrSearchMsg );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;
        }
        
        //
        //  Get the first search entry out of the search message.
        //

        pldapAttrSearchEntry = ldap_first_entry( LdapSession, pldapAttrSearchMsg );
        if ( !pldapAttrSearchEntry )
        {
            DNS_DEBUG( DS, (
                "%s: failed to get entry out of search %p\n", fn,
                pldapAttrSearchEntry ));
            ASSERT( pldapAttrSearchEntry );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;
        }
    }
    
    //
    //  Gather return strings into one array.
    //

    finalIdx = 0;
    if ( attributeValueSetIndex &&
         status == ERROR_SUCCESS &&
         !ppwszFinalValueArray )
    {
        UINT    attrset;
        UINT    validx;
        
        ppwszFinalValueArray =
            ALLOCATE_HEAP( ( attributeValueCount + 1 ) * sizeof( PWSTR ) );
        if ( !ppwszFinalValueArray )
        {
            ASSERT( ppwszFinalValueArray );
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        
        for ( attrset = 0; attrset < attributeValueSetIndex; ++attrset )
        {
            if ( !attributeValueSets[ attrset ] )
            {
                ASSERT( attributeValueSets[ attrset ] );
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                goto Done;
            }

            for ( validx = 0; attributeValueSets[ attrset ][ validx ]; ++validx )
            {
                ppwszFinalValueArray[ finalIdx ] =
                    Dns_StringCopyAllocate_W(
                            attributeValueSets[ attrset ][ validx ],
                            0 );
                if ( !ppwszFinalValueArray[ finalIdx ] )
                {
                    ASSERT( ppwszFinalValueArray[ finalIdx ] );
                    status = DNS_ERROR_NO_MEMORY;
                    goto Done;
                }

                DNS_DEBUG( DS, (
                    "%s: %04d %S\n", fn, finalIdx, ppwszFinalValueArray[ finalIdx ] ));
                ++finalIdx;
            }
        }
        
        //
        //  The attribute value list must be NULL-terminated.
        //
        
        ppwszFinalValueArray[ finalIdx ] = NULL;
    }

    Done:

    //
    //  Free stuff.
    //

    for ( i = 0; i < attributeValueSetIndex; ++i )
    {
        if ( attributeValueSets[ i ] )
        {
            ldap_value_free( attributeValueSets[ i ] );
        }
    }                
    if ( pbertrack )
    {
        ber_free( pbertrack, 0 );
    }
    if ( ppwszldapAttrValues )
    {
        ldap_value_free( ppwszldapAttrValues );
    }
    if ( pwszattrName )
    {
        ldap_memfree( pwszattrName );
    }
    if ( pldapAttrSearchMsg != pLdapMsg )
    {
        ldap_msgfree( pldapAttrSearchMsg );
    }
    if ( status != ERROR_SUCCESS && ppwszFinalValueArray )
    {
        for ( i = 0; i < finalIdx; ++i )
        {
            FREE_HEAP( ppwszFinalValueArray[ i ] );
        }
        FREE_HEAP( ppwszFinalValueArray );
        ppwszFinalValueArray = NULL;
    }
    FREE_HEAP( attrList[ 0 ] );

    if ( pStatus )
    {
        *pStatus = status;
    }

    DNS_DEBUG( DS, (
        "%s: returning %p with %d values for attribute %S at DN\n    %S\n", fn,
        ppwszFinalValueArray,
        finalIdx,
        pwszAttributeName,
        pwszDn ));

    return ppwszFinalValueArray;
}   //  Ds_GetRangedAttributeValues
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dpartrpc.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    dpartrpc.c

Abstract:

    Domain Name System (DNS) Server

    Directory partition routines for admin access.

Author:

    Jeff Westhead (jwesth)  Sept, 2000

Revision History:

    jwesth      09/2000     initial implementation

--*/


//
//  Includes
//


#include "dnssrv.h"


#include "ds.h"


//
//  Definitions/constants
//

#define MAX_RPC_DP_COUNT_DEFAULT    ( 0x10000 )


//
//  Functions
//



VOID
freeDpEnum(
    IN OUT  PDNS_RPC_DP_ENUM    pDpEnum
    )
/*++

Routine Description:

    Deep free a DNS_RPC_DP_ENUM structure.

Arguments:

    pDpEnum -- ptr to DNS_RPC_DP_ENUM structure to free

Return Value:

    None

--*/
{
    if ( !pDpEnum )
    {
        return;
    }
    if ( pDpEnum->pszDpFqdn )
    {
        MIDL_user_free( pDpEnum->pszDpFqdn );
    }
    MIDL_user_free( pDpEnum );
}   //  freeDpEnum



VOID
freeDpRpcInfo(
    IN OUT  PDNS_RPC_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Deep free a DNS_RPC_DP_INFO structure.

Arguments:

    pDp -- ptr to DNS_RPC_DP_INFO structure to free

Return Value:

    None

--*/
{
    DWORD               j;

    if ( !pDpInfo )
    {
        return;
    }

    MIDL_user_free( pDpInfo->pszDpFqdn );
    MIDL_user_free( pDpInfo->pszDpDn );
    MIDL_user_free( pDpInfo->pszCrDn );
    for ( j = 0; j < pDpInfo->dwReplicaCount; j++ )
    {
        PDNS_RPC_DP_REPLICA     p = pDpInfo->ReplicaArray[ j ];

        if ( p )
        {
            if ( p->pszReplicaDn )
            {
                MIDL_user_free( p->pszReplicaDn );
            }
            MIDL_user_free( p );
        }
    }
    MIDL_user_free( pDpInfo );
}   //  freeDpRpcInfo



VOID
freeDpList(
    IN OUT  PDNS_RPC_DP_LIST    pDpList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_DP_ENUM structures.

Arguments:

    pDpList -- ptr to DNS_RPC_DP_LIST structure to free

Return Value:

    None

--*/
{
    DWORD       i;

    for ( i = 0; i < pDpList->dwDpCount; ++i )
    {
        freeDpEnum( pDpList->DpArray[ i ] );
    }
    MIDL_user_free( pDpList );
}



PDNS_RPC_DP_INFO
allocateRpcDpInfo(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Allocate and populate RPC directory partition struct.

Arguments:

    pDp -- directory partition to create RPC DP struct for

Return Value:

    RPC directory partition struct or NULL on error

--*/
{
    DBG_FN( "allocateRpcDpInfo" )

    PDNS_RPC_DP_INFO    pRpcDp;
    DWORD               replicaCount = 0;

    DNS_DEBUG( RPC2, ( "%s( %s )\n", fn, pDp->pszDpFqdn ));

    //  Count replica strings

    if ( pDp->ppwszRepLocDns )
    {
        for ( ;
            pDp->ppwszRepLocDns[ replicaCount ];
            ++replicaCount );
    }

    //  Allocate RPC struct.

    pRpcDp = ( PDNS_RPC_DP_INFO ) MIDL_user_allocate_zero(
                sizeof( DNS_RPC_DP_INFO ) +
                sizeof( PDNS_RPC_DP_REPLICA ) * replicaCount );
    if ( !pRpcDp )
    {
        return( NULL );
    }

    //  Copy strings to RPC struct.

    pRpcDp->pszDpFqdn = Dns_StringCopyAllocate_A( pDp->pszDpFqdn, 0 );
    pRpcDp->pszDpDn = Dns_StringCopyAllocate_W( pDp->pwszDpDn, 0 );
    pRpcDp->pszCrDn = Dns_StringCopyAllocate_W( pDp->pwszCrDn, 0 );
    if ( !pRpcDp->pszDpFqdn || !pRpcDp->pszDpDn || !pRpcDp->pszCrDn )
    {
        goto Failure;
    }

    //  Copy replica strings into RPC struct.

    pRpcDp->dwReplicaCount = replicaCount;
    if ( replicaCount )
    {
        DWORD   i;

        for ( i = 0; i < replicaCount; ++ i )
        {
            pRpcDp->ReplicaArray[ i ] =
                MIDL_user_allocate_zero( sizeof( DNS_RPC_DP_REPLICA ) );
            if ( !pRpcDp->ReplicaArray[ i ] )
            {
                goto Failure;
            }
            pRpcDp->ReplicaArray[ i ]->pszReplicaDn =
                Dns_StringCopyAllocate_W( pDp->ppwszRepLocDns[ i ], 0 );
            if ( !pRpcDp->ReplicaArray[ i ]->pszReplicaDn )
            {
                goto Failure;
            }
        }
    }

    //  Set flags in RPC struct.

    pRpcDp->dwFlags         = pDp->dwFlags;
    pRpcDp->dwZoneCount     = ( DWORD ) pDp->liZoneCount;
    pRpcDp->dwState         = pDp->State;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcDpInfo( "New DP RPC info: ", pRpcDp, FALSE );
    }
    return pRpcDp;

    //
    //  Failed... cleanup and return NULL.
    //

    Failure:

    freeDpRpcInfo( pRpcDp );

    return NULL;
}   //  allocateRpcDpInfo



PDNS_RPC_DP_ENUM
allocateRpcDpEnum(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Allocate and populate RPC directory partition struct.

Arguments:

    pDp -- directory partition to create RPC DP struct for

Return Value:

    RPC directory partition struct or NULL on error

--*/
{
    DBG_FN( "allocateRpcDpEnum" )

    PDNS_RPC_DP_ENUM    pRpcDp;

    DNS_DEBUG( RPC2, ( "%s( %s )\n", fn, pDp->pszDpFqdn ));

    //  Allocate RPC struct.

    pRpcDp = ( PDNS_RPC_DP_ENUM ) MIDL_user_allocate_zero(
                                    sizeof( DNS_RPC_DP_ENUM )  );
    if ( !pRpcDp )
    {
        return( NULL );
    }

    //  Copy strings to RPC struct.

    pRpcDp->pszDpFqdn = Dns_StringCopyAllocate_A( pDp->pszDpFqdn, 0 );
    if ( !pRpcDp->pszDpFqdn  )
    {
        goto Failure;
    }

    //  Set flags in RPC struct.

    pRpcDp->dwFlags = pDp->dwFlags;
    pRpcDp->dwZoneCount = ( DWORD ) pDp->liZoneCount;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcDpEnum( "New DP RPC enum: ", pRpcDp );
    }
    return pRpcDp;

    //
    //  Failed... cleanup and return NULL.
    //

    Failure:

    freeDpEnum( pRpcDp );

    return NULL;
}   //  allocateRpcDpEnum



DNS_STATUS
Rpc_EnumDirectoryPartitions(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate directory partitions.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_EnumDirectoryPartitions" )

    PDNS_DP_INFO                pDp = NULL;
    DWORD                       rpcIdx = 0;
    PDNS_RPC_DP_ENUM            pRpcDp;
    DNS_STATUS                  status = ERROR_SUCCESS;
    PDNS_RPC_DP_LIST            pDpList;
    DWORD                       dwfilter = 0;

    DNS_DEBUG( RPC, ( "%s\n", fn ));

    if ( dwTypeIn == DNSSRV_TYPEID_DWORD )
    {
        dwfilter = ( DWORD ) ( DWORD_PTR ) pDataIn;
    }
    
    if ( !IS_DP_INITIALIZED() || !Ds_IsDsServer() )
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    //  Allocate enumeration block.
    //

    pDpList = ( PDNS_RPC_DP_LIST )
                    MIDL_user_allocate_zero(
                        sizeof( DNS_RPC_DP_LIST ) +
                        sizeof( PDNS_RPC_DP_ENUM ) *
                            MAX_RPC_DP_COUNT_DEFAULT );
    IF_NOMEM( !pDpList )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  Enumerate the NCs, adding each to the RPC list.
    //

    while ( pDp = Dp_GetNext( pDp ) )
    {
        if ( ( dwfilter & DNS_ENUMDPS_CUSTOMONLY ) &&
             ( pDp->dwFlags & DNS_DP_AUTOCREATED ) )
        {
            continue;
        }
        
        //
        //  Create RPC directory partition struct and add to RPC list.
        //

        pRpcDp = allocateRpcDpEnum( pDp );
        IF_NOMEM( !pRpcDp )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }
        pDpList->DpArray[ rpcIdx++ ] = pRpcDp;

        //
        //  DEVNOTE: what to do if we have too many NCs?
        //

        if ( rpcIdx >= MAX_RPC_DP_COUNT_DEFAULT )
        {
            break;
        }
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  Set count, return value, and return type.
    //

    pDpList->dwDpCount = rpcIdx;
    *( PDNS_RPC_DP_LIST * ) ppDataOut = pDpList;
    *pdwTypeOut = DNSSRV_TYPEID_DP_LIST;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcDpList(
            "Rpc_EnumDirectoryPartitions created list:",
            pDpList );
    }
    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( ANY, ( "%s: returning status %d\n", fn, status ));

    pDpList->dwDpCount = rpcIdx;
    freeDpList( pDpList );
    return status;
}   //  Rpc_EnumDirectoryPartitions



DNS_STATUS
Rpc_DirectoryPartitionInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Get detailed info for a directory partition.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_DirectoryPartitionInfo" )

    PDNS_DP_INFO                pDp = NULL;
    PDNS_RPC_DP_INFO            pRpcDp = NULL;
    DNS_STATUS                  status = ERROR_SUCCESS;
    PSTR                        pfqdn = NULL;

    DNS_DEBUG( RPC, ( "%s\n", fn ));

    if ( !IS_DP_INITIALIZED() || !Ds_IsDsServer() )
    {
        status = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    if ( dwTypeIn != DNSSRV_TYPEID_LPSTR ||
        !( pfqdn = ( PSTR ) pDataIn ) )
    {
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Enumerate the NCs, adding each to the RPC list.
    //

    pDp = Dp_FindByFqdn( pfqdn );

    if ( pDp )
    {
        pRpcDp = allocateRpcDpInfo( pDp );
        IF_NOMEM( !pRpcDp )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
    }
    else
    {
        status = DNS_ERROR_DP_DOES_NOT_EXIST;
    }

    //
    //  Set return info.
    //

    Done: 

    if ( status == ERROR_SUCCESS )
    {
        *( PDNS_RPC_DP_INFO * ) ppDataOut = pRpcDp;
        *pdwTypeOut = DNSSRV_TYPEID_DP_INFO;
        IF_DEBUG( RPC )
        {
            DnsDbg_RpcDpInfo(
                "Rpc_DirectoryPartitionInfo created:",
                pRpcDp,
                FALSE );
        }
    }
    else
    {
        *( PDNS_RPC_DP_INFO * ) ppDataOut = NULL;
        *pdwTypeOut = DNSSRV_TYPEID_NULL;
        DNS_DEBUG( ANY, ( "%s: returning status %d\n", fn, status ));
        freeDpRpcInfo( pRpcDp );
    }

    return status;
}   //  Rpc_DirectoryPartitionInfo



DNS_STATUS
createBuiltinPartitions(
    PDNS_RPC_ENLIST_DP  pDpEnlist
    )
/*++

Routine Description:

    Use the admin's credentials to create some or all of the
    built-in directory partitions.

    When creating multiple DPs, all will be attempted to be created
    even if some attempts fail. The error code from the first failure
    will be returned. The error codes from any subsequent failures
    will be lost.

Arguments:

    pDpEnlist -- enlist struct (only operation member is used)

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "createBuiltinPartitions" )

    DNS_STATUS      status = ERROR_INVALID_DATA;
    DWORD           opcode = 0; 

    if ( !pDpEnlist )
    {
        goto Done;
    }

    opcode = pDpEnlist->dwOperation;

    DNS_DEBUG( RPC, ( "%s: dwOperation=%d\n", fn, opcode ));

    switch ( opcode )
    {
        case DNS_DP_OP_CREATE_FOREST:

            //
            //  Create/enlist forest built-in DP as necessary.
            //

            if ( g_pForestDp )
            {
                status = 
                    IS_DP_ENLISTED( g_pForestDp ) ?
                        DNS_ERROR_DP_ALREADY_EXISTS :
                        Dp_ModifyLocalDsEnlistment( g_pForestDp, TRUE );
            }
            else if ( g_pszForestDefaultDpFqdn )
            {
                status = Dp_CreateByFqdn(
                                g_pszForestDefaultDpFqdn,
                                dnsDpSecurityForest,
                                TRUE );
            }

            //
            //  Need to poll to pick up the new partition.
            //  DEVNOTE: it would be cool if we added an optional partition
            //  argument to Dp_PollForPartitions so we could poll only 
            //  the partition we care about.
            //
            
            Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );

            //
            //  Add ACE for enterprise domain controllers if it's missing.
            //

            if ( ( status == ERROR_SUCCESS ||
                   status == DNS_ERROR_DP_ALREADY_EXISTS ) &&
                   g_pForestDp && g_pForestDp->pCrSd )
            {
                Dp_AlterPartitionSecurity(
                        g_pForestDp->pwszDpDn,
                        dnsDpSecurityForest );
            }

            break;

        case DNS_DP_OP_CREATE_DOMAIN:

            //
            //  Create/enlist domain built-in DP as necessary.
            //

            if ( g_pDomainDp )
            {
                status = 
                    IS_DP_ENLISTED( g_pDomainDp ) ?
                        DNS_ERROR_DP_ALREADY_EXISTS :
                        Dp_ModifyLocalDsEnlistment( g_pDomainDp, TRUE );
            }
            else if ( g_pszDomainDefaultDpFqdn )
            {
                status = Dp_CreateByFqdn(
                                g_pszDomainDefaultDpFqdn,
                                dnsDpSecurityDomain,
                                TRUE );
            }

            //
            //  Need to poll to pick up the new partition.
            //  DEVNOTE: it would be cool if we added an optional partition
            //  argument to Dp_PollForPartitions so we could poll only 
            //  the partition we care about.
            //
            
            Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );

            //
            //  Add ACE for domain controllers if it's missing.
            //

            if ( ( status == ERROR_SUCCESS ||
                   status == DNS_ERROR_DP_ALREADY_EXISTS ) &&
                   g_pDomainDp && g_pDomainDp->pCrSd )
            {
                Dp_AlterPartitionSecurity(
                        g_pDomainDp->pwszDpDn,
                        dnsDpSecurityDomain );
            }

            break;

        default:
            DNS_DEBUG( RPC, ( "%s: invalid opcode %d\n", fn, opcode ));
            break;
    }
    
    Done:
    
    DNS_DEBUG( RPC, (
        "%s: dwOperation=%d returning %d\n", fn, opcode, status ));
    return status;
}   //  createBuiltinPartitions



DNS_STATUS
Rpc_EnlistDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    This function is used to manage all aspects of the DNS server's
    enlistment in a directory partition. Possible operations:

        DNS_DP_OP_CREATE
        DNS_DP_OP_DELETE
        DNS_DP_OP_ENLIST
        DNS_DP_OP_UNENLIST
        DNS_DP_OP_CREATE_DOMAIN         *
        DNS_DP_OP_CREATE_FOREST         *
        DNS_DP_OP_CREATE_ALL_DOMAINS    *

    * These operations are used by an Enterprise Admin to tell the
    DNS server to use his credentials to create built-in partitions.

    DNS_DP_OP_CREATE_DOMAIN - Create the domain built-in partition
    for the domain in which this DNS server is a DC.

    DNS_DP_OP_CREATE_FOREST - Create the forest built-in partition
    for the forest in which this DNS server is a DC.

    DNS_DP_OP_CREATE_ALL_DOMAINS - Create all the built-in partitions
    for every domain that can be found.

    For the enlist operation if the DP does not exist it will be created.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_EnlistDirectoryPartition" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pDp;
    BOOL            fmadeChange = FALSE;
    INT             i;

    PDNS_RPC_ENLIST_DP  pDpEnlist =
            ( PDNS_RPC_ENLIST_DP ) pData;

    ASSERT( dwTypeId == DNSSRV_TYPEID_ENLIST_DP );

    DNS_DEBUG( RPC, (
        "%s: dwOperation=%d\n"
        "    FQDN: %s\n", fn,
        pDpEnlist->dwOperation,
        pDpEnlist->pszDpFqdn ));

    if ( !IS_DP_INITIALIZED() || !Ds_IsDsServer() )
    {
        return ERROR_NOT_SUPPORTED;
    }

    if ( !pDpEnlist )
    {
        return ERROR_INVALID_DATA;
    }

    //
    //  Verify that operation is valid.
    //

    if ( ( int ) pDpEnlist->dwOperation < DNS_DP_OP_MIN ||
        ( int ) pDpEnlist->dwOperation > DNS_DP_OP_MAX )
    {
        DNS_DEBUG( RPC,
            ( "%s: invalid operation %d\n", fn,
            pDpEnlist->dwOperation ));
        return ERROR_INVALID_DATA;
    }

    //
    //  If this operation is actually on a built-in partition, call the
    //  appropriate routine. This is important because security on built-in
    //  partitions is set up differently.
    //

    if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE_DOMAIN ||
        pDpEnlist->dwOperation == DNS_DP_OP_CREATE_FOREST ||
        pDpEnlist->dwOperation == DNS_DP_OP_CREATE_ALL_DOMAINS )
    {
        status = createBuiltinPartitions( pDpEnlist );
        fmadeChange = TRUE;
        goto Done;
    }

    if ( !pDpEnlist->pszDpFqdn )
    {
        return ERROR_INVALID_DATA;
    }

    if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE &&
         g_pszDomainDefaultDpFqdn &&
         _stricmp( g_pszDomainDefaultDpFqdn, pDpEnlist->pszDpFqdn ) == 0 )
    {
        pDpEnlist->dwOperation = DNS_DP_OP_CREATE_DOMAIN;
        status = createBuiltinPartitions( pDpEnlist );
        fmadeChange = TRUE;
        goto Done;
    }

    if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE &&
         g_pszForestDefaultDpFqdn &&
         _stricmp( g_pszForestDefaultDpFqdn, pDpEnlist->pszDpFqdn ) == 0 )
    {
        pDpEnlist->dwOperation = DNS_DP_OP_CREATE_FOREST;
        status = createBuiltinPartitions( pDpEnlist );
        fmadeChange = TRUE;
        goto Done;
    }

    //
    //  Removing trailing dot(s) from the the partition FQDN.
    //

    while ( pDpEnlist->pszDpFqdn[ i = strlen( pDpEnlist->pszDpFqdn ) - 1 ] == '.' )
    {
        pDpEnlist->pszDpFqdn[ i ] = '\0';
    }

    //
    //  Rescan the DS for new directory partitions. Possibly this should
    //  not be done on the RPC client's thread.
    //

    status = Dp_PollForPartitions( NULL, 0 );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Find the specified directory partition in the DP list and decide
    //  how to proceed based on it's state.
    //

    pDp = Dp_FindByFqdn( pDpEnlist->pszDpFqdn );

    //
    //  Screen out certain operations on built-in partitions.
    //

    if ( pDp == NULL || IS_DP_DELETED( pDp ) )
    {
        //
        //  The DP does not currently exist.
        //

        if ( pDpEnlist->dwOperation != DNS_DP_OP_CREATE )
        {
            DNS_DEBUG( RPC, (
                "%s: DP does not exist and create not specified\n", fn ));
            status = DNS_ERROR_DP_DOES_NOT_EXIST;
            goto Done;
        }

        //
        //  Create the new DP.
        //

        DNS_DEBUG( RPC, (
            "%s: %s DP %s\n", fn,
            pDp ? "recreating deleted" : "creating new",
            pDpEnlist->pszDpFqdn ));

        status = Dp_CreateByFqdn(
                        pDpEnlist->pszDpFqdn,
                        dnsDpSecurityDefault,
                        TRUE );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( RPC, (
                "%s: error %d creating DP %s\n", fn,
                status,
                pDpEnlist->pszDpFqdn ));
        }
        else
        {
            fmadeChange = TRUE;
        }
    }
    else
    {
        //
        //  The DP currently exists.
        //

        if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE )
        {
            DNS_DEBUG( RPC, (
                "%s: create specified but DP already exists\n", fn ));
            status = DNS_ERROR_DP_ALREADY_EXISTS;
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_DELETE )
        {
            //
            //  Delete the DP.
            //

            status = Dp_DeleteFromDs( pDp );
            if ( status == ERROR_SUCCESS )
            {
                fmadeChange = TRUE;
            }
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_ENLIST )
        {
            if ( IS_DP_ENLISTED( pDp ) )
            {
                DNS_DEBUG( RPC, (
                    "%s: enlist specified but DP is already enlisted\n", fn ));
                status = DNS_ERROR_DP_ALREADY_ENLISTED;
                goto Done;
            }

            //
            //  Enlist the local DS in the replication scope for the DP.
            //

            status = Dp_ModifyLocalDsEnlistment( pDp, TRUE );

            fmadeChange = TRUE;
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_UNENLIST )
        {
            if ( !IS_DP_ENLISTED( pDp ) )
            {
                DNS_DEBUG( RPC, (
                    "%s: unenlist specified but DP is not enlisted\n", fn ));
                status = DNS_ERROR_DP_NOT_ENLISTED;
                goto Done;
            }

            //
            //  Remove the local DS from the replication scope for the DP 
            //

            status = Dp_ModifyLocalDsEnlistment( pDp, FALSE );

            fmadeChange = TRUE;
            goto Done;
        }
    }
    
Done:

    if ( fmadeChange && pDpEnlist->dwOperation == DNS_DP_OP_CREATE )
    {
        Dp_PollForPartitions( NULL, DNS_DP_POLL_FORCE );
        
        //
        //  If possible, create the MicrosoftDNS object. It's not critical
        //  that this happen at this time, but it makes sense to do it here.
        //  If this fails the container will be created when the first zone
        //  is created in this partition.
        //
        
        pDp = Dp_FindByFqdn( pDpEnlist->pszDpFqdn );
        if ( pDp &&
             IS_DP_ENLISTED( pDp ) &&
             IS_DP_AVAILABLE( pDp ) )
        {
            Dp_LoadOrCreateMicrosoftDnsObject(
                    NULL,                   //  LDAP session
                    pDp,
                    TRUE );                 //  create flag
        }
    }
    DNS_DEBUG( ANY, ( "%s returning status %d\n", fn, status ));

    return status;
}   //  Rpc_EnlistDirectoryPartition



DNS_STATUS
Rpc_ChangeZoneDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    This function attempts to move a DS zone from one directory partition
    to another directory partition. The basic algorithm is:

    - save current DN/DP information from zone blob
    - insert new DN/DP information in zone blob
    - attempt to save zone back to DS in new location
    - attempt to delete zone from old location in DS

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Rpc_ChangeZoneDP" )

    PDNS_RPC_ZONE_CHANGE_DP         pinfo = ( PDNS_RPC_ZONE_CHANGE_DP ) pData;
    DNS_STATUS                      status = ERROR_SUCCESS;
    PDNS_DP_INFO                    pnewDp = NULL;

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "    new partition = %s\n", fn,
        pZone->pszZoneName,
        pinfo->pszDestPartition ));

    ASSERT( pData );
    if ( !pData )
    {
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Find the DP list entry for the specified destination DP.
    //

    pnewDp = Dp_FindByFqdn( pinfo->pszDestPartition );
    if ( !pnewDp )
    {
        status = DNS_ERROR_DP_DOES_NOT_EXIST;
        goto Done;
    }
    
    //
    //  W2K protection: do not allow stub and forwarders to be moved to
    //  the legacy partition unless we are in Whistler domain mode.
    //
    
    if ( !IS_WHISTLER_DOMAIN() &&
         IS_DP_LEGACY( pnewDp ) &&
         ( IS_ZONE_FORWARDER( pZone ) || IS_ZONE_STUB( pZone ) ) )
    {
        status = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    //
    //  Move the zone.
    //

    status = Dp_ChangeZonePartition( pZone, pnewDp );

    //
    //  Cleanup and return. On success log an event. On failure, the
    //  error code will be returned to the admin. No event log is 
    //  necessary.
    //

    if ( status == ERROR_SUCCESS )
    {
        PVOID   argArray[] =
        {
            pZone->pszZoneName,
            pZone->pwszZoneDN ? pZone->pwszZoneDN : L"N/A"
        };

        BYTE    typeArray[] =
        {
            EVENTARG_UTF8,
            EVENTARG_UNICODE
        };

        Ec_LogEvent(
            g_pServerEventControl,
            DNS_EVENT_ZONE_MOVE_COMPLETE_DS,
            NULL,
            sizeof( argArray ) / sizeof( argArray[ 0 ] ),
            argArray,
            typeArray,
            ERROR_SUCCESS );
    }
    
    Done:

    DNS_DEBUG( RPC, (
        "%s returning %d\n", fn,
        status ));
    return status;
}   //  Rpc_ChangeZoneDirectoryPartition


//
//  End dpartrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\dsutil.h ===
/*++

Copyright(c) 1995-2000 Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to directory partition 
    implementation.

Author:

    Jeff Westhead, June 2000

Revision History:

--*/


#ifndef _DNS_DSUTIL_H_INCLUDED
#define _DNS_DSUTIL_H_INCLUDED


//
//  Function prototypes
//


PWSTR *
Ds_GetRangedAttributeValues(
    IN      PLDAP           LdapSession,
    IN      PLDAPMessage    pLdapMsg,
    IN      PWSTR           pwszDn,
    IN      PWSTR           pwszAttributeName,
    IN      PLDAPControl  * pServerControls,
    IN      PLDAPControl  * pClientControls,
    OUT     DNS_STATUS    * pStatus
    );


#endif  // _DNS_DSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\eventcontrol.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    EventControl.c

Abstract:

    Domain Name System (DNS) Server

    This module provides tracking of which events have been logged and
    when so that the DNS server can determine if an event should be
    suppressed.

    Goals of Event Control

    -> Allow suppression of events at the server level and per zone.

    -> Identify events with a parameter so that events can be logged
    multiple times for unique entities. This is an optional feature.
    Some events do not require this.

    -> Track the time of last log and statically store the allowed
    frequency of each event so that events can be suppressed if
    required.

Author:

    Jeff Westhead (jwesth)     May 2001

Revision History:

--*/


#include "dnssrv.h"


#define DNS_MAX_RAW_DATA    1024


//
//  Globals
//


PDNS_EVENTCTRL  g_pServerEventControl;


//
//  Static event table
//

#if 0

//  Shortened definitions for private dev testing.

#define EC_1MIN         ( 60 )
#define EC_10MINS       ( EC_1MIN * 10 )
#define EC_1HOUR        ( EC_1MIN * 60 )
#define EC_1DAY         ( EC_1HOUR * 24 )
#define EC_1WEEK        ( EC_1DAY * 7 )

#define EC_DEFAULT_COUNT_BEFORE_SUPPRESS        10          //  events per suppression window
#define EC_DEFAULT_SUPPRESSION_WINDOW           ( 30 )
#define EC_DEFAULT_SUPPRESSION_BLACKOUT         ( 30 )

#else

#define EC_1MIN         ( 60 )
#define EC_10MINS       ( EC_1MIN * 10 )
#define EC_1HOUR        ( EC_1MIN * 60 )
#define EC_1DAY         ( EC_1HOUR * 24 )
#define EC_1WEEK        ( EC_1DAY * 7 )

#define EC_DEFAULT_COUNT_BEFORE_SUPPRESS        10          //  events per suppression window
#define EC_DEFAULT_SUPPRESSION_WINDOW           ( EC_1MIN * 5 )
#define EC_DEFAULT_SUPPRESSION_BLACKOUT         ( EC_1MIN * 30 )

#endif


#define EC_INVALID_ID               ( -1 )
#define EC_NO_SUPPRESSION_EVENT     ( -1 )

struct _EvtTable
{
    //
    //  Range of events (inclusive) this entry applies to. To specify
    //  a rule that applies to a single event only set both limits to ID.
    //

    DWORD       dwStartEvent;
    DWORD       dwEndEvent;

    //
    //  Event parameters
    //
    //
    //  dwCountBeforeSuppression - the number of times this event
    //      can be logged in a suppression window before suppression 
    //      will be considered
    //
    //  dwSuppressionWindow - period of time during which events
    //      are counted and considered for suppression
    //
    //  dwSuppressionBlackout - period of time for which this event
    //      is suppressed when suppression criteria are met
    //
    //  Example:
    //          dwCountBeforeSuppression = 10
    //          dwSuppressionWindow = 60
    //          dwSuppressionBlackout = 600
    //      This means that if we receive 10 events within 60 seconds we
    //      suppress this event until such 600 seconds have passed.
    //
    //  dwSuppressionLogFrequency - during event suppression, how 
    //      often should a suppression event be logged - should be less 
    //      than dwSuppressionWindow or EC_NO_SUPPRESSION_EVENT to disable
    //      suppression logging
    //

    DWORD       dwCountBeforeSuppression;           //  number of events
    DWORD       dwSuppressionWindow;                //  in seconds
    DWORD       dwSuppressionBlackout;              //  in seconds
    DWORD       dwSuppressionLogFrequency;          //  in seconds
}

g_EventTable[] =

{
    DNS_EVENT_DP_ZONE_CONFLICT,
    DNS_EVENT_DP_ZONE_CONFLICT,
    EC_DEFAULT_COUNT_BEFORE_SUPPRESS,
    EC_DEFAULT_SUPPRESSION_WINDOW,
    EC_DEFAULT_SUPPRESSION_BLACKOUT,
    EC_NO_SUPPRESSION_EVENT,

    DNS_EVENT_DP_CANT_CREATE_BUILTIN,
    DNS_EVENT_DP_CANT_JOIN_DOMAIN_BUILTIN,
    EC_DEFAULT_COUNT_BEFORE_SUPPRESS,
    EC_DEFAULT_SUPPRESSION_WINDOW,
    EC_DEFAULT_SUPPRESSION_BLACKOUT,
    EC_NO_SUPPRESSION_EVENT,

    DNS_EVENT_BAD_QUERY,
    DNS_EVENT_BAD_RESPONSE_PACKET,
    EC_DEFAULT_COUNT_BEFORE_SUPPRESS,
    EC_DEFAULT_SUPPRESSION_WINDOW,
    EC_DEFAULT_SUPPRESSION_BLACKOUT,
    EC_NO_SUPPRESSION_EVENT,

    DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
    DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
    EC_DEFAULT_COUNT_BEFORE_SUPPRESS,
    EC_DEFAULT_SUPPRESSION_WINDOW,
    EC_DEFAULT_SUPPRESSION_BLACKOUT,
    EC_NO_SUPPRESSION_EVENT,

    DNS_EVENT_DS_OPEN_FAILED,
    DNS_EVENT_DS_OPEN_FAILED + 499,                 //  covers all DS events
    EC_DEFAULT_COUNT_BEFORE_SUPPRESS,
    EC_DEFAULT_SUPPRESSION_WINDOW,
    EC_DEFAULT_SUPPRESSION_BLACKOUT,
    EC_NO_SUPPRESSION_EVENT,
    
    EC_INVALID_ID, EC_INVALID_ID, 0, 0, 0, 0        //  terminator
};


#define lastSuppressionLogTime( pTrack )                                \
    ( ( pTrack )->dwLastSuppressionLogTime ?                            \
        ( pTrack )->dwLastSuppressionLogTime :                          \
        ( pTrack )->dwLastLogTime )

//
//  Functions
//



VOID
startNewWindow(
    IN      PDNS_EVENTTRACK     pTrack
    )
/*++

Routine Description:

    Resets the values in the event tracking structure to start a
    new window. This should be called at the start of a tracking
    window or a blackout window.

Arguments:

    pTrack -- ptr to event tracking structure to be reset

Return Value:

    None.
    
--*/
{
    if ( pTrack )
    {
        pTrack->dwStartOfWindow = DNS_TIME();
        pTrack->dwEventCountInCurrentWindow = 0;
        pTrack->dwLastSuppressionLogTime = 0;
        pTrack->dwSuppressionCount = 0;
    }
}   //  startNewWindow



VOID
logSuppressionEvent(
    IN      PDNS_EVENTCTRL      pEventControl,
    IN      DWORD               dwEventId,
    IN      PDNS_EVENTTRACK     pTrack
    #if DBG
    ,
    IN      LPSTR               pszFile,
    IN      INT                 LineNo,
    IN      LPSTR               pszDescription
    #endif
    )
/*++

Routine Description:

    An event is being suppressed and it is time for a suppression
    event to be logged.

Arguments:

    pEventControl -- event control structure

    dwEventID -- ID of event being suppressed
    
    pTrack -- ptr to event tracking structure to be reset

Return Value:

    None.
    
--*/
{
    DBG_FN( "SuppressEvent" )
    
    DWORD       now = DNS_TIME();

    ASSERT( pEventControl );
    ASSERT( dwEventId );
    ASSERT( pTrack );
    
    DNS_DEBUG( EVTCTRL, (
        "%s: logging suppression event at %d\n"
        "    Supressed event ID           %d\n"
        "    Last event time              %d\n"
        "    Last supression event time   %d\n"
        "    Suppression count            %d\n",
        fn,
        now,
        dwEventId,
        pTrack->dwLastLogTime,
        pTrack->dwLastSuppressionLogTime ,
        pTrack->dwSuppressionCount ));

    if ( pEventControl->dwTag == MEMTAG_ZONE && pEventControl->pOwner )
    {
        PWSTR   args[] = 
            {
                ( PVOID ) ( DWORD_PTR )( dwEventId & 0x0FFFFFFF ),
                ( PVOID ) ( DWORD_PTR )( pTrack->dwSuppressionCount ),
                ( PVOID ) ( DWORD_PTR ) ( ( now -
                            lastSuppressionLogTime( pTrack ) ) ), // JJW / 60 ),
                ( ( PZONE_INFO ) pEventControl->pOwner )->pwsZoneName
            };

        BYTE types[] =
        {
            EVENTARG_DWORD,
            EVENTARG_DWORD,
            EVENTARG_DWORD,
            EVENTARG_UNICODE
        };

        Eventlog_LogEvent(
            #if DBG
            pszFile,
            LineNo,
            pszDescription,
            #endif
            DNS_EVENT_ZONE_SUPPRESSION,
            DNSEVENTLOG_DONT_SUPPRESS,
            sizeof( args ) / sizeof( args[ 0 ] ),
            args,
            types,
            0,          //  error code
            0,          //  raw data size
            NULL );     //  raw data
    }
    else
    {
        DWORD   args[] = 
            {
                dwEventId & 0x0FFFFFFF,
                pTrack->dwSuppressionCount,
                now - lastSuppressionLogTime( pTrack ) // JJW / 60
            };

        Eventlog_LogEvent(
            #if DBG
            pszFile,
            LineNo,
            pszDescription,
            #endif
            DNS_EVENT_SERVER_SUPPRESSION,
            DNSEVENTLOG_DONT_SUPPRESS,
            sizeof( args ) / sizeof( args[ 0 ] ),
            ( PVOID ) args,
            EVENTARG_ALL_DWORD,
            0,          //  error code
            0,          //  raw data size
            NULL );     //  raw data
    }

    pTrack->dwLastSuppressionLogTime = now;
}   //  logSuppressionEvent



PDNS_EVENTCTRL
Ec_CreateControlObject(
    IN      DWORD           dwTag,
    IN      PVOID           pOwner,
    IN      int             iMaximumTrackableEvents     OPTIONAL
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    dwTag -- what object does this contol apply to?
                0               ->  server
                MEMTAG_ZONE     ->  zone

    pOwner -- pointer to owner entity for tag
                0               ->  ignored
                MEMTAG_ZONE     ->  PZONE_INFO

    iMaximumTrackableEvents -- maximum event trackable by this object
                               or zero for the default

Return Value:

    Pointer to new object or NULL on memory allocation failure.

--*/
{
    PDNS_EVENTCTRL  p;

    #define     iMinimumTrackableEvents     20      //  default/minimum

    if ( iMaximumTrackableEvents < iMinimumTrackableEvents )
    {
        iMaximumTrackableEvents = iMinimumTrackableEvents;
    }

    p = ALLOC_TAGHEAP_ZERO(
                    sizeof( DNS_EVENTCTRL ) + 
                        iMaximumTrackableEvents *
                        sizeof( DNS_EVENTTRACK ),
                    MEMTAG_EVTCTRL );

    if ( p )
    {
        if ( DnsInitializeCriticalSection( &p->cs ) != ERROR_SUCCESS )
        {
            FREE_HEAP( p );
            p = NULL;
            goto Done;
        }

        p->iMaximumTrackableEvents = iMaximumTrackableEvents;
        p->dwTag = dwTag;
        p->pOwner = pOwner;
    }
    
    Done:

    return p;
}   //  Ec_CreateControlObject



void
Ec_DeleteControlObject(
    IN      PDNS_EVENTCTRL  p
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    iMaximumTrackableEvents -- maximum event trackable by this object

Return Value:

    Pointer to new object or NULL on memory allocation failure.

--*/
{
    if ( p )
    {
        DeleteCriticalSection( &p->cs );
        Timeout_Free( p );
    }
}   //  Ec_DeleteControlObject



BOOL
Ec_LogEventEx(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      PDNS_EVENTCTRL  pEventControl,
    IN      DWORD           dwEventId,
    IN      PVOID           pvEventParameter,
    IN      int             iEventArgCount,
    IN      PVOID           pEventArgArray,
    IN      BYTE            pArgTypeArray[],
    IN      DNS_STATUS      dwStatus,           OPTIONAL
    IN      DWORD           dwRawDataSize,      OPTIONAL
    IN      PVOID           pRawData            OPTIONAL
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    pEventControl -- event control structure to record event and
        use for possible event suppression or NULL to use the
        server global event control (if one has been set up)

    dwEventId -- DNS event ID

    pvEventParameter -- parameter associated with this event
        to make it unique from other events of the same ID or
        NULL if this event is not unique

    iEventArgCount -- count of elements in pEventArgArray

    pEventArgArray -- event replacement parameter arguments

    pArgTypeArray -- type of the values in pEventArgArray or
        a EVENTARG_ALL_XXX constant if all args are the same type

    dwStatus -- status code to be included in event

    dwRawDataSize -- size of raw binary event data (zero if none)

    pRawData -- pointer to raw event data buffer containing at least
        dwRawDataSize bytes of data (NULL if no raw data)

Return Value:

    TRUE - event was logged
    FALSE - event was suppressed

--*/
{
    DBG_FN( "Ec_LogEvent" )

    BOOL                logEvent = TRUE;
    int                 i;
    struct _EvtTable *  peventDef = NULL;
    PDNS_EVENTTRACK     ptrack = NULL;
    DWORD               now = UPDATE_DNS_TIME();
    DWORD               dwlogEventFlag = DNSEVENTLOG_DONT_SUPPRESS;

    //
    //  If no control specified, use server global. If there is
    //  none, log the event without suppression.
    //

    if ( !pEventControl )
    {
        pEventControl = g_pServerEventControl;
    }
    if ( !pEventControl )
    {
        ASSERT( !"g_pServerEventControl should have been initialized" );
        goto LogEvent;
    }
    
    //
    //  .NET: Disable this feature for now. Customers are confused by our
    //  suppression model. This feature attempts to add intelligence but
    //  it will be difficult to explain to customers and will end up making
    //  the product overly complex.
    //
    
    dwlogEventFlag = 0;
    goto LogEvent;

    //
    //  If event control is disabled, log all events. Note: the use of
    //  this DWORD may be expanded in future.
    //

    if ( SrvCfg_dwEventControl != 0 )
    {
        goto LogEvent;
    }

    //
    //  Find controlling entry in static event table. If there isn't one
    //  then log the event with no suppression.
    //
    
    for ( i = 0; g_EventTable[ i ].dwStartEvent != EC_INVALID_ID; ++i )
    {
        if ( dwEventId >= g_EventTable[ i ].dwStartEvent && 
            dwEventId <= g_EventTable[ i ].dwEndEvent )
        {
            peventDef = &g_EventTable[ i ];
            break;
        }
    }
    if ( !peventDef )
    {
        goto LogEvent;
    }

    //
    //  See if this event has been logged before.
    //

    EnterCriticalSection( &pEventControl->cs );

    for ( i = 0; i < pEventControl->iMaximumTrackableEvents; ++i )
    {
        PDNS_EVENTTRACK p = &pEventControl->EventTrackArray[ i ];

        if ( p->dwEventId == dwEventId &&
            p->pvEventParameter == pvEventParameter )
        {
            ptrack = p;
            break;
        }
    }

    if ( ptrack )
    {
        //
        //  This event has been logged before. See if the event needs
        //  to be suppressed. If it is being suppressed we may need to
        //  write out a suppression event.
        //

        if ( ptrack->dwSuppressionCount )
        {
            //
            //  The last instance of this event was suppressed. 
            //
            
            BOOL    suppressThisEvent = FALSE;

            if ( now - ptrack->dwStartOfWindow >
                 peventDef->dwSuppressionBlackout )
            {
                //
                //  The blackout window has expired. Start a new window
                //  and log this instance of the event.
                //
                
                DNS_DEBUG( EVTCTRL, (
                    "%s: 0x%08X blackout window expired\n", fn, dwEventId ));

                startNewWindow( ptrack );
                ++ptrack->dwEventCountInCurrentWindow;
            }
            else
            {
                //
                //  The blackout window is still in effect
                //
                
                if ( peventDef->dwSuppressionLogFrequency !=
                        EC_NO_SUPPRESSION_EVENT &&
                    now - lastSuppressionLogTime( ptrack ) >
                        peventDef->dwSuppressionLogFrequency )
                {
                    //
                    //  It is time to log a suppression event. Note we do not
                    //  start a new window at this time.
                    //

                    DNS_DEBUG( EVTCTRL, (
                        "%s: 0x%08X logging suppression event and starting new window\n", fn, dwEventId ));

                    logSuppressionEvent(
                        pEventControl,
                        dwEventId,
                        ptrack
                        #if DBG
                        ,
                        pszFile,
                        LineNo,
                        pszDescription
                        #endif
                        );

                    ptrack->dwLastSuppressionLogTime = now;
                }

                logEvent = FALSE;
                ++ptrack->dwSuppressionCount;

                DNS_DEBUG( EVTCTRL, (
                    "%s: suppressing event (last instance suppressed)at %d\n"
                    "    Supressed event ID           0x%08X\n"
                    "    Last event time              %d\n"
                    "    Last supression event time   %d\n"
                    "    Suppression count            %d\n",
                    fn,
                    now,
                    dwEventId,
                    ptrack->dwLastLogTime,
                    ptrack->dwLastSuppressionLogTime,
                    ptrack->dwSuppressionCount ));
            }
        }
        else
        {
            //
            //  The last instance of this event was logged.
            //
            
            if ( now - ptrack->dwStartOfWindow >
                 peventDef->dwSuppressionWindow )
            {
                //
                //  The event tracking window has expired. Log this 
                //  event and start a new window.
                //

                DNS_DEBUG( EVTCTRL, (
                    "%s: 0x%08X starting new window\n", fn, dwEventId ));
                startNewWindow( ptrack );
            }
            else if ( ptrack->dwEventCountInCurrentWindow >=
                      peventDef->dwCountBeforeSuppression )
            {
                //
                //  This event has been logged too many times in this 
                //  window. Start a blackout window and suppress this
                //  event.
                //
                
                startNewWindow( ptrack );
                ++ptrack->dwSuppressionCount;
                logEvent = FALSE;

                DNS_DEBUG( EVTCTRL, (
                    "%s: suppressing event (last instance logged)at %d\n"
                    "    Supressed event ID           0x%08X\n"
                    "    Last event time              %d\n"
                    "    Last supression event time   %d\n"
                    "    Suppression count            %d\n",
                    fn,
                    now,
                    dwEventId,
                    ptrack->dwLastLogTime,
                    ptrack->dwLastSuppressionLogTime,
                    ptrack->dwSuppressionCount ));
            }
            
            //
            //  Else do nothing and drop below to log this event.
            //

            ++ptrack->dwEventCountInCurrentWindow;
        }
    }
    else
    {
        //
        //  This event has no entry in the control structure, so record this
        //  event and write it to the event log. Make sure all fields in the
        //  event track are overwritten so we don't use grundge from an old
        //  log entry to control this event!
        //

        ptrack = &pEventControl->EventTrackArray[
                                    pEventControl->iNextTrackableEvent ];

        ptrack->dwEventId = dwEventId;
        ptrack->pvEventParameter = pvEventParameter;
        startNewWindow( ptrack );
        ++ptrack->dwEventCountInCurrentWindow;

        //  Advance index of next available event.

        if ( ++pEventControl->iNextTrackableEvent >=
            pEventControl->iMaximumTrackableEvents )
        {
            pEventControl->iNextTrackableEvent = 0;
        }
    }

    LeaveCriticalSection( &pEventControl->cs );

    //
    //  Log the event.
    //

    LogEvent:

    if ( logEvent )
    {
        //
        //  Hard upper limit for size of raw data.
        //

        if ( dwRawDataSize > DNS_MAX_RAW_DATA )
        {
            dwRawDataSize = DNS_MAX_RAW_DATA;
        }

        Eventlog_LogEvent(
            #if DBG
            pszFile,
            LineNo,
            pszDescription,
            #endif
            dwEventId,
            dwlogEventFlag,
            ( WORD ) iEventArgCount,
            pEventArgArray,
            pArgTypeArray,
            dwStatus,
            dwRawDataSize,
            pRawData );
        
        if ( ptrack )
        {
            ptrack->dwLastLogTime = now;
        }
    }

    return logEvent;
}   //  Ec_LogEventEx


//
//  End EventControl.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\eventlog.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    Domain Name System (DNS) Server

    Routines to write to event log.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

    jamesg  May 1995    -   Single routine logging
    jamesg  Jul 1995    -   DnsDebugLogEvent
                        -   Event logging macros
    jamesg  Jan 1997    -   Bad packet logging suppression

--*/


#include "dnssrv.h"

#define DNS_ID_FROM_EVENT_ID( EventId )     ( ( EventId ) & 0x0000ffff )


//
//  Private globals.
//

HANDLE g_hEventSource;


//
//  Bad packet logging suppression
//

#define NO_SUPPRESS_INTERVAL    180         //  3 minutes
#define SUPPRESS_INTERVAL       (60*60)     //  60 minutes

#define BAD_PACKET_EVENT_LIMIT  20          //  20 bad packets then suppress


//
//  Key path to DNS log
//

#define DNS_REGISTRY_CLASS          ("DnsRegistryClass")
#define DNS_REGISTRY_CLASS_SIZE     sizeof(DNS_REGISTRY_CLASS)

#define DNSLOG_REGKEY           ("System\\CurrentControlSet\\Services\\Eventlog\\DNS Server")
#define DNSLOG_FILE             ("File")
#define DNSLOG_FILE_VALUE       ("%SystemRoot%\\system32\\config\\DnsEvent.Evt")
#define DNSLOG_MAXSIZE          ("MaxSize")
#define DNSLOG_MAXSIZE_VALUE    (0x80000)
#define DNSLOG_RETENTION        ("Retention")
#define DNSLOG_RETENTION_VALUE  (0x93a80)
#define DNSLOG_SOURCES          ("Sources")

#define DNSSOURCE_REGKEY        ("DNS")
#define DNSSOURCE_MSGFILE       ("EventMessageFile")
#define DNSSOURCE_MSGFILE_VALUE ("%SystemRoot%\\system32\\dns.exe")
#define DNSSOURCE_TYPES         ("TypesSupported")
#define DNSSOURCE_TYPES_VALUE   (7)


//
//  DNS source string with multi-sz double NULL termination
//

CHAR szDnsSource[] = { 'D','N','S', 0, 0 };



BOOL
suppressBadPacketEventLogging(
    IN  DWORD       dwEventId
    )
/*++

Routine Description:

    Checks if logging of bad packet event should be suppressed.

Arguments:

    dwEventId -- ID of the event that is about to be logged

Return Value:

    TRUE if event should be suppressed.
    FALSE otherwise.

--*/
{
    static  BOOL    fBadPacketSuppression = FALSE;
    static  DWORD   BadPacketEventCount = 0;
    static  DWORD   BadPacketSuppressedCount = 0;
    static  DWORD   BadPacketTimeFirst = 0;
    static  DWORD   BadPacketTimePrevious = 0;

    DWORD           time;
    BOOL            fsuppress = FALSE;

    //
    //  No suppression of events outside of range. Also, if the EventControl
    //  configuration property is non-zero then never suppress any event. The
    //  meaning of this property may be expanded in future.
    //
    
    if ( SrvCfg_dwEventControl != 0 ||
         DNS_ID_FROM_EVENT_ID( dwEventId ) <=
            DNS_ID_FROM_EVENT_ID( DNS_EVENT_START_LOG_SUPPRESS ) ||
         DNS_ID_FROM_EVENT_ID( dwEventId ) >=
            DNS_ID_FROM_EVENT_ID( DNS_EVENT_CONTINUE_LOG_SUPPRESS ) )
    {
        goto Done;
    }
    
    time = GetCurrentTimeInSeconds();

    BadPacketEventCount++;

    //  multiple bad packets
    //  don't suppress first ones as they provide information to admin

    if ( BadPacketEventCount < BAD_PACKET_EVENT_LIMIT )
    {
        // no op, drop down to save time
    }

    //
    //  if haven't had a bad packet in a whiledon't suppress and don't count
    //

    else if ( time > BadPacketTimePrevious + NO_SUPPRESS_INTERVAL )
    {
        BadPacketEventCount = 0;
        BadPacketSuppressedCount = 0;
        BadPacketTimeFirst = time;
        //
        //  DEVNOTE-LOG:  want to log when stop bad packet suppression
        //
        fBadPacketSuppression = FALSE;
    }

    //
    //  log start of suppression
    //

    else if ( !fBadPacketSuppression )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_START_LOG_SUPPRESS,
            0,
            NULL,
            NULL,
            0 );

        BadPacketSuppressedCount = 1;
        fBadPacketSuppression = TRUE;
        BadPacketTimeFirst = time;
        fsuppress = TRUE;
    }

    //  if have suppressed for a while (15 minutes) note
    //  this in the log, allow this event to be logged
    //  so admin can get info as to cause

    else if ( time > BadPacketTimeFirst + SUPPRESS_INTERVAL )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_CONTINUE_LOG_SUPPRESS,
            0,
            NULL,
            NULL,
            BadPacketSuppressedCount );

        BadPacketSuppressedCount = 1;
        BadPacketTimeFirst = time;
    }

    //  full suppress -- do NOT log event

    else
    {
        fsuppress = TRUE;
    }

    BadPacketTimePrevious = time;

    if ( fsuppress )
    {
        ++BadPacketSuppressedCount;
    }
    else
    {
        BadPacketSuppressedCount = 0;
    }
    
    Done:
    
    return fsuppress;
}



BOOL
Eventlog_CheckPreviousInitialize(
    VOID
    )
/*++

Routine Description:

    Checks to see if we had initialized this before
    We'll try to open the data of the last written registry value
    in the initialize function. If it's there, we'll assume, the
    initialization has been run on this server in the past &
    that we have an event source.

    This is supposed to address the problem of, when values are set by an admin,
    don't overide them. I would expect RegCreateKeyExA (Eventlog_Initialize)
    in to return error if the key already exist, but it returns success, thus
    the need for this check.

Arguments:

    None

Return Value:

    TRUE if we found previous installation.
    Otherwise FALSE.

--*/
{
    DNS_STATUS  status;
    HKEY        hOpenDnsLog = NULL;
    HKEY        hOpenDnsSource = NULL;
    DWORD       dwData;
    DWORD       dwcbData;
    BOOL        bstatus = FALSE;


    status = RegOpenKeyA(
                  HKEY_LOCAL_MACHINE,
                  DNSLOG_REGKEY,
                  &hOpenDnsLog );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    status = RegOpenKeyA(
                  hOpenDnsLog,
                  DNSSOURCE_REGKEY,
                  &hOpenDnsSource );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS source log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    dwcbData = sizeof (DWORD);

    status = Reg_GetValue(
                  hOpenDnsSource,
                  NULL,
                  DNSSOURCE_TYPES,
                  REG_DWORD,
                  &dwData,
                  &dwcbData
                  );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS source log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    DNS_DEBUG( ANY, (
        "Found existing DNS event log settings. Re-using existing logging\n"
        ));

    //
    //  ok to use existing DNS log
    //

    bstatus = TRUE;

Cleanup:

    if ( hOpenDnsLog )
    {
        RegCloseKey( hOpenDnsLog );
    }
    if ( hOpenDnsSource )
    {
        RegCloseKey( hOpenDnsSource );
    }
    return bstatus;
}



INT
Eventlog_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the event log.

Arguments:

    None

Return Value:

    NO_ERROR if successful.
    Win32 error code on failure.

--*/
{
    HKEY        hkeyDnsLog = NULL;
    HKEY        hkeyDnsSource = NULL;
    DWORD       disposition;
    DNS_STATUS  status;
    PCHAR       pszlogSource = ("Dns");


    if ( Eventlog_CheckPreviousInitialize() )
    {
        pszlogSource = DNSSOURCE_REGKEY;
        goto SystemLog;
    }

    //
    //  if desired create our own log, otherwise use system log
    //

    if ( SrvCfg_dwUseSystemEventLog )
    {
         goto SystemLog;
    }

#if 1
    //
    //  create a DNS log in the eventlog
    //

    status = RegCreateKeyExA(
                HKEY_LOCAL_MACHINE,
                DNSLOG_REGKEY,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                & hkeyDnsLog,
                & disposition );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating DNS log, status = %p (%d)\n",
            status, status ));
        goto SystemLog;
    }

    //  set values under DNS log key

    status = Reg_SetValue(
                0,                  //  flags
                hkeyDnsLog,
                NULL,               //  no zone
                DNSLOG_FILE,
                REG_EXPAND_SZ,
                DNSLOG_FILE_VALUE,
                sizeof( DNSLOG_FILE_VALUE ) );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                0,                  //  flags
                hkeyDnsLog,
                NULL,               //  no zone
                DNSLOG_MAXSIZE,
                DNSLOG_MAXSIZE_VALUE );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                0,                  //  flags
                hkeyDnsLog,
                NULL,               //  no zone
                DNSLOG_RETENTION,
                DNSLOG_RETENTION_VALUE );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    status = Reg_SetValue(
                0,                  //  flags
                hkeyDnsLog,
                NULL,               //  no zone
                DNSLOG_SOURCES,
                REG_MULTI_SZ,
                szDnsSource,
                sizeof( szDnsSource ) );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    //  logging source subkey

    status = RegCreateKeyExA(
                hkeyDnsLog,
                DNSSOURCE_REGKEY,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                & hkeyDnsSource,
                & disposition );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating DNS source, status = %p (%d)\n",
            status, status ));
        goto SystemLog;
    }

    //  set values under DNS source key

    status = Reg_SetValue(
                0,                  //  flags
                hkeyDnsSource,
                NULL,               //  no zone
                DNSSOURCE_MSGFILE,
                REG_EXPAND_SZ,
                DNSSOURCE_MSGFILE_VALUE,
                sizeof( DNSSOURCE_MSGFILE_VALUE ) );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                0,                  //  flags
                hkeyDnsSource,
                NULL,               //  no zone
                DNSSOURCE_TYPES,
                DNSSOURCE_TYPES_VALUE );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    //  success, then use this log

    pszlogSource = DNSSOURCE_REGKEY;
#endif

SystemLog:


    if ( hkeyDnsSource )
    {
        RegCloseKey( hkeyDnsSource );
    }
    if ( hkeyDnsLog )
    {
        RegCloseKey( hkeyDnsLog );
    }

    //
    //  Register as an event source.
    //

    g_hEventSource = RegisterEventSourceA( NULL, pszlogSource );

    if ( g_hEventSource == NULL )
    {
        status = GetLastError();

        DNS_PRINT((
            "ERROR:  Event log startup failed\n"
            "    RegisterEventSource returned NULL\n"
            "    status = %d\n",
            status ));
        return status;
    }

    //
    //  Initialize server-level event control object.
    //

    if ( !g_pServerEventControl )
    {
        g_pServerEventControl = Ec_CreateControlObject(
                                    0,
                                    NULL,
                                    DNS_EC_SERVER_EVENTS );
    }

    //
    //  Annouce attempt to start that contains version number
    //  for tracking purposes.
    //

    DNS_LOG_EVENT(
        DNS_EVENT_STARTING,
        0,
        NULL,
        NULL,
        0 );

    return ERROR_SUCCESS;
}



VOID
Eventlog_Terminate(
    VOID
    )
{
    LONG err;

    //
    //  Deregister as an event source.
    //

    if( g_hEventSource != NULL )
    {
        err = DeregisterEventSource( g_hEventSource );
#if DBG
        if ( !err )
        {
            DNS_PRINT((
                "ERROR:  DeregisterEventSource failed\n"
                "    error = %d\n",
                GetLastError() ));
        }
#endif
        g_hEventSource = NULL;
    }
}



BOOL
Eventlog_LogEvent(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      DWORD           EventId,
    IN      DWORD           dwFlags,
    IN      WORD            ArgCount,
    IN      PVOID           ArgArray[],
    IN      BYTE            ArgTypeArray[],     OPTIONAL
    IN      DWORD           ErrorCode,          OPTIONAL
    IN      DWORD           RawDataSize,        OPTIONAL
    IN      PVOID           pRawData            OPTIONAL
    )
/*++

Routine Description:

    Logs DNS event.

    Determines severity of event, optionally debug prints, and
    writes to event log.

    DEVNOTE-DCR: 455471 - unicode usage, use FormatMessage

Arguments:

    pszFile -- name of file logging the event
    LineNo -- line number of call to event logging
    pszDescription -- description of event

    EventId -- event id
    
    dwFlags -- flags that modify logging options

    ArgCount -- count of message arguments

    ArgArray -- array of ptrs to message arguments

    ArgTypeArray -- array of argument types
        supported argument types:
            EVENTARG_UNICODE
            EVENTARG_UTF8
            EVENTARG_ANSI
            EVENTARG_DWORD
            EVENTARG_IP_ADDRESS

        may also be one of several standard types:
            EVENTARG_ALL_UNICODE
            EVENTARG_ALL_UTF8
            EVENTARG_ALL_ANSI
            EVENTARG_ALL_DWORD
            EVENTARG_ALL_IP_ADDRESS

        if NULL, all arguments are assumed to be UNICODE

    ErrorCode -- error code associated with event, this will
        be logged as the event data if it is non-zero

    RawDataSize -- bytes of data pointed to be pRawData

    pRawData -- raw data pointer, note that ErrorCode takes
        precednce as raw data so if you with the raw data to
        be logged you must pass zero for ErrorCode

Return Value:

    TRUE if arguments parsed.
    FALSE otherwise.

--*/
{
#define MAX_ARG_CHARS           (5000)
#define MAX_SINGLE_ARG_CHARS    (1000)
#define MAX_ARG_COUNT           (20)

    WORD    eventType = 0;      // init to statisfy some code checking script
    PVOID   rawData  = NULL;
    DWORD   rawDataSize = 0;
    DWORD   err;
    BOOL    retVal = FALSE;
    DWORD   i;
    DWORD   fsuppress = 0xFFFFFFFF;
    DWORD   dnsEventId = DNS_ID_FROM_EVENT_ID( EventId );

    PWSTR   argArrayUnicode[ MAX_ARG_COUNT ];
    WCHAR   buffer[ MAX_ARG_CHARS ];
    CHAR    argBuffer[ MAX_SINGLE_ARG_CHARS ];

    ASSERT( ( ArgCount == 0 ) || ( ArgArray != NULL ) );
    ASSERT( ArgCount <= MAX_ARG_COUNT );

    //
    //  protect against failed event log init
    //

    if ( !g_hEventSource )
    {
        goto Done;
    }
    
    //
    //  defeat attempt to bury us with eventlog messages through bad packets
    //      if not logging then can skip even argument conversion
    //

    if ( ( dwFlags & ( DNSEVENTLOG_DONT_SUPPRESS |
                       DNSEVENTLOG_FORCE_LOG_ALWAYS ) ) == 0 &&
         !SrvCfg_dwDebugLevel &&
         !SrvCfg_dwLogLevel )
    {
        fsuppress = suppressBadPacketEventLogging( EventId );
        if ( fsuppress )
        {
            goto Done;
        }
    }
    
    //
    //  If shutting down, do not log DS errors. It is likely that the DS
    //  has shutdown too fast. We should not be writing data back to the DS
    //  on shutdown anyways, although this may change in Longhorn.
    //
    
    if ( dnsEventId >= 4000 &&
         dnsEventId < 5000 &&
         g_ServerState == DNS_STATE_TERMINATING )
    {
        goto Done;
    }

    //
    //  Determine the type of event to log based on the severity field of
    //  the message id.
    //

    if ( NT_SUCCESS( EventId ) || NT_INFORMATION( EventId ) )
    {
        eventType = EVENTLOG_INFORMATION_TYPE;
    }
    else if( NT_WARNING( EventId ) )
    {
        eventType = EVENTLOG_WARNING_TYPE;
    }
    else if( NT_ERROR( EventId ) )
    {
        eventType = EVENTLOG_ERROR_TYPE;
    }
    ELSE_ASSERT_FALSE;

    //
    //  Determine if any raw data should be included in the event. The
    //  ErrorCode is logged as the raw data if it is non zero. If ErrorCode
    //  is zero then the raw data arguments will be checked.
    //

    if ( ErrorCode != 0 )
    {
        rawData  = &ErrorCode;
        rawDataSize = sizeof( ErrorCode );
    }
    else if ( RawDataSize && pRawData )
    {
        rawData = pRawData;
        rawDataSize = RawDataSize;
    }
    if ( rawDataSize > DNS_EVENT_MAX_RAW_DATA )
    {
        rawDataSize = DNS_EVENT_MAX_RAW_DATA;
    }

    //  if not going to log this event in any fashion, then do not convert args

    if ( SrvCfg_dwEventLogLevel < eventType &&
         !SrvCfg_dwDebugLevel &&
         !SrvCfg_dwLogLevel &&
         ( dwFlags & ( DNSEVENTLOG_DONT_SUPPRESS |
                       DNSEVENTLOG_FORCE_LOG_ALWAYS ) ) == 0 )
    {
        goto Done;
    }

    if ( ArgArray != NULL && ArgCount > 0 )
    {
        INT     stringType;
        PCHAR   pch = (PCHAR)buffer;
        PCHAR   pchstop = pch + MAX_ARG_CHARS - 500;
        DWORD   cch;
        PCHAR   pargUtf8;

        for ( i = 0; i < ArgCount; i++ )
        {
            //
            //  convert string, based on type
            //      if dummy type array
            //      - default to unicode (no array at all)
            //      - default to type "hidden" in ptr
            //

            if ( !ArgTypeArray )
            {
                stringType = EVENTARG_UNICODE;
            }
            else if ( (UINT_PTR) ArgTypeArray < 1000 )
            {
                stringType = (INT)(UINT_PTR) ArgTypeArray;
                ASSERT( stringType <= EVENTARG_LOOKUP_NAME );
            }
            else
            {
                stringType = ArgTypeArray[i];
            }

            //
            //  convert individual string types (IP, etc) to UTF8
            //  then convert everyone from UTF8 to unicode
            //
            //  default to no-conversion case -- arg in UTF8 and
            //      ready for conversion
            //

            pargUtf8 = ArgArray[i];

            switch( stringType )
            {
                case EVENTARG_FORMATTED:
                case EVENTARG_ANSI:

                    if ( Dns_IsStringAscii(ArgArray[i]) )
                    {
                        break;
                    }
                    Dns_StringCopy(
                        argBuffer,
                        NULL,               // no buffer length restriction
                        ArgArray[i],
                        0,                  // unknown length
                        DnsCharSetAnsi,     // ANSI in
                        DnsCharSetUtf8      // unicode out
                        );
                    pargUtf8 = argBuffer;
                    break;

                case EVENTARG_UTF8:
                    break;

                case EVENTARG_UNICODE:

                    //  arg already in unicode
                    //      - no conversion
                    //      - just copy ptr

                    argArrayUnicode[i] = (LPWSTR) ArgArray[i];
                    continue;

                case EVENTARG_DWORD:
                    sprintf( argBuffer, "%lu", (DWORD)(ULONG_PTR) ArgArray[i] );
                    pargUtf8 = argBuffer;
                    break;

                case EVENTARG_IP_ADDRESS:
                {
                    CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

                    DnsAddr_WriteIpString_A( szaddr, ( PDNS_ADDR ) ArgArray[ i ] );
                    strcpy( argBuffer, szaddr );
                    pargUtf8 = argBuffer;
                    break;
                }

                case EVENTARG_LOOKUP_NAME:
                    Name_ConvertLookupNameToDottedName(
                        argBuffer,
                        (PLOOKUP_NAME) ArgArray[i] );
                    if ( !*argBuffer )
                    {
                        argBuffer[ 0 ] = '.';
                        argBuffer[ 1 ] = '\0';
                    }
                    pargUtf8 = argBuffer;
                    break;

                default:
                    ASSERT( FALSE );
                    continue;
            }

            //
            //  convert UTF8 args to UNICODE
            //      - copy into buffer, converting to unicode
            //      - do extra NULL termination for safety
            //          (including conversion errors)
            //      - move along buffer ptr
            //      - but stop if out of buffer space
            //

            cch = Dns_StringCopy(
                        pch,
                        NULL,               // no buffer length restriction
                        pargUtf8,
                        0,                  // unknown length
                        DnsCharSetUtf8,     // UTF8 in
                        DnsCharSetUnicode   // unicode out
                        );

            ASSERT( ((DWORD)cch & 0x1)==0  &&  ((UINT_PTR)pch & 0x1)==0 );

            argArrayUnicode[i] = (LPWSTR) pch;
            pch += cch;
            *((PWCHAR)pch)++ = 0;

            if ( pch < pchstop )
            {
                continue;
            }
            break;
        }
    }

    //  if debugging or logging write event to log

    if ( SrvCfg_dwDebugLevel || SrvCfg_dwLogLevel )
    {
        LPWSTR   pformattedMsg = NULL;

        err = FormatMessageW(
                FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,                       // module is this exe
                EventId,
                0,                          // default language
                (PWCHAR) &pformattedMsg,    // message buffer
                0,                          // allocate buffer
                (va_list *) argArrayUnicode );

        if ( err == 0 )
        {
            DNS_PRINT((
                "ERROR: formatting eventlog message %d (%p)\n"
                "    error = %d\n",
                DNS_ID_FROM_EVENT_ID( EventId ), EventId,
                GetLastError() ));
        }
        else
        {
            DNS_PRINT((
                "Log EVENT message %d (%p):\n"
                "%S\n",
                (EventId & 0x0000ffff), EventId,
                pformattedMsg ));

            DNSLOG( EVENT, ( "%S", pformattedMsg ));
        }
        LocalFree( pformattedMsg );
    }

    //  arguments parsed

    retVal = TRUE;

    //
    //  check for event suppression, may have converted arguments for logging
    //      purposes but still need to suppress from eventlog
    //

    if ( ( dwFlags & ( DNSEVENTLOG_DONT_SUPPRESS |
                       DNSEVENTLOG_FORCE_LOG_ALWAYS ) ) == 0 )
    {
        if ( fsuppress == 0xFFFFFFFF )
        {                       
            fsuppress = suppressBadPacketEventLogging( EventId );
        }
        if ( fsuppress )
        {
            goto Done;
        }
    }

    //
    //  log the event
    //

    if ( SrvCfg_dwEventLogLevel >= eventType ||
         dwFlags & DNSEVENTLOG_FORCE_LOG_ALWAYS )
    {
        err = ReportEventW(
                g_hEventSource,
                eventType,
                0,                              // no fwCategory
                EventId,
                NULL,                           // no pUserSid,
                ArgCount,
                rawDataSize,
                (LPCWSTR *) argArrayUnicode,    // unicode Argv
                rawData );
#if DBG
        if ( !err )
        {
            DNS_PRINT((
                "ERROR: DNS cannot report event, error %lu\n",
                GetLastError() ));
        }
#endif
    }

Done:

    //
    //  print debug message
    //

    IF_DEBUG( EVENTLOG )
    {
        DnsDebugLock();
        DNS_PRINT((
            "\n"
            "Reporting EVENT %08lx (%d)%s%s:\n"
            "    File:  %s\n"
            "    Line:  %d\n"
            "    Data = %lu\n",
            EventId,
            (EventId & 0x0000ffff),             // decimal Id, without severity
            (pszDescription ? " -- " : "" ),
            (pszDescription ? pszDescription : "" ),
            pszFile,
            LineNo,
            ErrorCode ));

        if ( retVal )
        {
            for( i=0; i < ArgCount; i++ )
            {
                DNS_PRINT(( "    Arg[%lu] = %S\n", i, argArrayUnicode[i] ));
            }
            DNS_PRINT(( "\n" ));
        }
        DnsDebugUnlock();
    }

    return retVal;
}



VOID
EventLog_BadPacket(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      DWORD           EventId,
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Logs DNS event in response to a bad packet.

    Any event can be used but it must take exactly 1 replacement
    parameter, which is the IP address of the client machine.

Arguments:

    pszFile -- name of file logging the event

    LineNo -- line number of call to event logging

    pszDescription -- description of event

    EventId -- event id

    pMsg -- message from remote client which is bad

Return Value:

    None.

--*/
{
    int     rawLen;
    PVOID   eventArgs[ 1 ];

    ASSERT( EventId );
    ASSERT( pMsg );

    if ( !pMsg )
    {
        goto Done;
    }

    //
    //  Compute length of raw data to include in event. The event
    //  log function may truncate if the packet is too large.
    //

    rawLen = ( DWORD ) ( DWORD_PTR )
                ( DNSMSG_END( pMsg ) - ( PBYTE ) ( &pMsg->Head ) );
    
    //
    //  All events in this family have a single replacement parameter
    //  which is the IP address of the client.
    //

    eventArgs[ 0 ] = &pMsg->RemoteAddr;

    Ec_LogEventRaw(
        NULL,
        EventId,
        0,
        1,
        eventArgs,
        EVENTARG_ALL_IP_ADDRESS,
        rawLen,
        ( PBYTE ) ( &pMsg->Head ) );

    Done:

    return;
}   //  EventLog_BadPacketEvent


//
//  End of eventlog.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\except.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    except.c

Abstract:

    Domain Name System (DNS) Server

    Exception handling routines.

Author:

    Jim Gilroy (jamesg)     October 1996

Revision History:

--*/


#include "dnssrv.h"

//
//  Exception restart
//

BOOL    gExceptionRestart       = FALSE;
INT     gExceptionRestartCount  = 0;
INT     gExceptionCountAV       = 0;
INT     gExceptionCountMemory   = 0;

//
//  Exception state -- for capturing exception info
//

INT     gExceptionCount = 0;
DWORD   gExceptionCode = 0;
DWORD   gExceptionFlags;
DWORD   gExceptionArgc;
CONST ULONG_PTR *  gExceptionArgv;
LPSTR   gExceptionFile;
INT     gExceptionLine;



VOID
Ex_RaiseException(
    IN      DWORD             dwCode,
    IN      DWORD             dwFlags,
    IN      DWORD             Argc,
    IN      CONST ULONG_PTR * Argv,
    IN      LPSTR             pszFile,
    IN      INT               iLineNo
    )
/*++

Routine Description:

    Raise expection.

Arguments:

    dwCode,
    dwFlags,
    Argc,
    Argv    -- these four are standard arguments to Win32 RaiseException

    pszFile -- file generating exception

    iLineNo -- line number of exception

Return Value:

    None.

--*/
{
    DNS_DEBUG( EXCEPT, (
        "Raising exception (%p, flag %p) at %s, line %d\n",
        dwCode,
        dwFlags,
        __FILE__,
        __LINE__ ));

    gExceptionCount++;

    gExceptionCode = dwCode;
    gExceptionFlags = dwFlags;
    gExceptionArgc = Argc;
    gExceptionArgv = Argv;
    gExceptionFile = pszFile;
    gExceptionLine = iLineNo;

    RaiseException( dwCode, dwFlags, Argc, Argv );

}   //  Ex_RaiseException



VOID
Ex_RaiseFormerrException(
    IN      PDNS_MSGINFO    pMsg,
    IN      LPSTR           pszFile,
    IN      INT             iLineNo
    )
/*++

Routine Description:

    Raises FORMERR exception for message.

Arguments:

    pMsg -- message with form error

Return Value:

    None.

--*/
{
    //
    //  debug info
    //

    IF_DEBUG( EXCEPT )
    {
        DnsDebugLock();
        DNS_PRINT((
            "ERROR:  FORMERR in msg %p from %s, detected at %s, line %d\n",
            pMsg,
            DNSADDR_STRING( &pMsg->RemoteAddr ),
            pszFile,
            iLineNo ));
        Dbg_DnsMessage(
            "FORMERR message:",
            pMsg );
        DnsDebugUnlock();
    }

    //
    //  DEVNOTE-LOG: log bad packet?
    //


    //
    //  raise the exception
    //

    RaiseException(
        DNS_EXCEPTION_PACKET_FORMERR,
        EXCEPTION_NONCONTINUABLE,
        0,
        NULL );

}   //  Ex_RaiseFormerrException

//
//  End of except.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\eventcontrol.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    EventControl.h

Abstract:

    Domain Name System (DNS) Server

    Event control system.

Author:

    Jeff Westhead, May 2001

Revision History:

--*/


#ifndef _EVENTCONTROL_H_INCLUDED
#define _EVENTCONTROL_H_INCLUDED


//
//  Types
//


//
//  This struct tracks the last time an event was logged. The 
//  pvEventParameter member allows us to track different occurences of
//  the same event independantly.
//

typedef struct _EvtTrack
{
    //  Key fields

    DWORD       dwEventId;
    PVOID       pvEventParameter;

    //  Tracking fields

    DWORD       dwLastLogTime;
    DWORD       dwStartOfWindow;
    DWORD       dwEventCountInCurrentWindow;
    DWORD       dwLastSuppressionLogTime;
    DWORD       dwSuppressionCount;
} DNS_EVENTTRACK, *PDNS_EVENTTRACK;


//
//  The event control structure tracks the events that have been logged.
//  This structure should be instantiated for the server itself and for
//  each zone. It may also be instantiated for other entities as necessary.
//
//  The array is a circular buffer of events. If it wraps then the last
//  event info for an event will be lost and the event will be logged the
//  next time it occurs.
//

typedef struct _EvtCtrl
{
    CRITICAL_SECTION    cs;
    DWORD               dwTag;
    PVOID               pOwner;
    int                 iMaximumTrackableEvents;
    int                 iNextTrackableEvent;
    DNS_EVENTTRACK      EventTrackArray[ 1 ];
} DNS_EVENTCTRL, *PDNS_EVENTCTRL;


//
//  Globals
//


extern PDNS_EVENTCTRL   g_pServerEventControl;


//
//  Constants
//


#define DNS_EC_SERVER_EVENTS        20
#define DNS_EC_ZONE_EVENTS          20


//
//  Functions
//


PDNS_EVENTCTRL
Ec_CreateControlObject(
    IN      DWORD           dwTag,
    IN      PVOID           pOwner,
    IN      int             iMaximumTrackableEvents
    );

void
Ec_DeleteControlObject(
    IN      PDNS_EVENTCTRL  pEventControl
    );

BOOL
Ec_LogEventEx(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      PDNS_EVENTCTRL  pEventControl,
    IN      DWORD           dwEventId,
    IN      PVOID           pvEventParameter,
    IN      int             iEventArgCount,
    IN      PVOID           pEventArgArray,
    IN      BYTE            pArgTypeArray[],
    IN      DNS_STATUS      dwStatus,           OPTIONAL
    IN      DWORD           RawDataSize,        OPTIONAL
    IN      PVOID           pRawData            OPTIONAL
    );

#if DBG

#define Ec_LogEvent(            \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, Status )   \
            Ec_LogEventEx(      \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                Status,         \
                0,              \
                NULL )

#define Ec_LogEventRaw(         \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, RawSize, RawData )   \
            Ec_LogEventEx(      \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                0,              \
                RawSize,        \
                RawData )

#else

#define Ec_LogEvent(            \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, Status )   \
            Ec_LogEventEx(      \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                Status,         \
                0,              \
                NULL )

#define Ec_LogEventRaw(         \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, RawSize, RawData )   \
            Ec_LogEventEx(      \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                0,              \
                RawSize,        \
                RawData )

#endif

#endif // _EVENTCONTROL_H_INCLUDED


//
//  end of EventControl.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\heapdbg.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    Domain Name System (DNS) Server

    Heap debugging routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "dnssrv.h"

//
//  Include these functions only for debug versions.
//

#if DBG

#include "heapdbg.h"

//
//  Heap Globals
//

ULONG   gTotalAlloc         = 0;
ULONG   gTotalFree          = 0;
ULONG   gCurrentAlloc       = 0;

ULONG   gAllocCount         = 0;
ULONG   gFreeCount          = 0;
ULONG   gCurrentAllocCount  = 0;

//
//  Heap alloc list
//

LIST_ENTRY          listHeapListHead;
CRITICAL_SECTION    csHeapList;

//
//  Full heap checks before all operations?
//

BOOL    fHeapDbgCheckAll = FALSE;

//
//  Exception on allocation failures
//

DWORD   dwHeapFailureException = 0;

//
//  Heap Header / Trailer Flags
//

#define HEAP_CODE          0xdddddddd
#define HEAP_CODE_ACTIVE   0xaaaaaaaa
#define HEAP_CODE_FREE     0xeeeeeeee

//
//  Heap Trailer from Header
//

#define HEAP_TRAILER(_head_)            \
    ( (PHEAP_TRAILER) (                 \
            (PCHAR)(_head_)             \
            + (_head_)->AllocSize       \
            - sizeof(HEAP_TRAILER) ) )



//
//  Debug Heap Operations
//

PVOID
HeapDbgAlloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT alloc_size;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    if ( iSize <= 0 )
    {
        HEAP_DEBUG_PRINT(( "Invalid alloc size = %d\n", iSize ));
        return NULL;
    }

    //
    //  allocate memory
    //
    //  first add heap header to size
    //

    alloc_size = HeapDbgAllocSize( iSize );

    h = (PHEAP_HEADER) RtlAllocateHeap( hHeap, dwFlags, (alloc_size) );
    if ( ! h )
    {
        HeapDbgGlobalInfoPrint();
        return NULL;
    }

    //
    //  setup header / globals for new alloc
    //
    //  return ptr to first byte after header
    //

    return  HeapDbgHeaderAlloc(
                h,
                iSize,
                pszFile,
                dwLine );
}



PVOID
HeapDbgRealloc(
    IN      HANDLE          hHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PHEAP_HEADER    h;
    PHEAP_HEADER    newhead;
    INT             previous_size;
    INT             alloc_size;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    if ( iSize <= 0 )
    {
        HEAP_DEBUG_PRINT(( "Invalid realloc size = %d\n", iSize ));
        return NULL;
    }

    //
    //  validate memory
    //
    //  extract pointer to actual alloc'd block
    //  mark as free, and reset globals appropriately
    //

    h = HeapDbgHeaderFree( pMem );

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    alloc_size = HeapDbgAllocSize( iSize );

    newhead = (PHEAP_HEADER) RtlReAllocateHeap( hHeap, dwFlags, (h), (alloc_size) );
    if ( !newhead )
    {
        HeapDbgGlobalInfoPrint();
        return NULL;
    }
    h = newhead;

    //
    //  setup header / globals for realloc
    //
    //  return ptr to first byte after header
    //

    return  HeapDbgHeaderAlloc(
                h,
                iSize,
                pszFile,
                dwLine );
}



VOID
HeapDbgFree(
    IN      HANDLE          hHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by  MEMORY routines.

Arguments:

    pMem    - ptr to memory to be freed

Return Value:

    None.

--*/
{
    register PHEAP_HEADER h;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    //
    //  validate header
    //
    //  reset heap header / globals for free
    //

    h = HeapDbgHeaderFree( pMem );

    RtlFreeHeap( hHeap, dwFlags, h );
}



//
//  Heap Utilities
//


BOOL
HeapDbgInit(
    IN      DWORD           dwException,
    IN      BOOL            fFullHeapChecks
    )
/*++

Routine Description:

    Initialize heap debugging.

    MUST call this routine before using HeapDbgMessage routines.

Arguments:

    dwException -- exception to raise if out of heap

    fFullHeapChecks -- flag, TRUE for full heap checks

Return Value:

    TRUE/FALSE on success/error.

--*/
{
    //  set globals
    //      - full heap checks before all heap operations?
    //      - raise exception on alloc failure?

    fHeapDbgCheckAll = fFullHeapChecks;
    dwHeapFailureException = dwException;
    //  alloc list
    //      - alloc list head
    //      - critical section to protect list operations

    InitializeListHead( &listHeapListHead );
    if ( DnsInitializeCriticalSection( &csHeapList ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    return TRUE;
}



INT
HeapDbgAllocSize(
    IN      INT iRequestSize
    )
/*++

Routine Description:

    Determines actual size of debug alloc.

    Adds in sizes of DWORD aligned header and trailer.

Arguments:

    iRequestSize   - requested allocation size

Return Value:

    None

--*/
{
    register INT imodSize;

    //
    //  find DWORD multiple size of original alloc,
    //  this is required so debug trailer will be DWORD aligned
    //

    imodSize = iRequestSize % sizeof(DWORD);
    if ( imodSize )
    {
        imodSize = sizeof(DWORD) - imodSize;
    }

    imodSize += iRequestSize + sizeof(HEAP_HEADER) + sizeof(HEAP_TRAILER);

    ASSERT( ! (imodSize % sizeof(DWORD)) );

    return imodSize;
}




PVOID
HeapDbgHeaderAlloc(
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Sets/Resets heap globals and heap header info.

Arguments:

    h       - ptr to new memory block
    iSize   - size allocated

Return Value:

    None

--*/
{
    register PHEAP_TRAILER t;
    INT     alloc_size;

    ASSERT( iSize > 0 );

    //
    //  determine actual alloc
    //

    alloc_size = HeapDbgAllocSize( iSize );

    //
    //  update heap info globals
    //

    gTotalAlloc     += alloc_size;
    gCurrentAlloc   += alloc_size;
    gAllocCount++;
    gCurrentAllocCount++;

    //
    //  fill in header
    //

    h->HeapCodeBegin     = HEAP_CODE;
    h->AllocCount        = gAllocCount;
    h->AllocSize         = alloc_size;
    h->RequestSize       = iSize;

    h->AllocTime         = GetCurrentTime();
    h->LineNo            = dwLine;

    alloc_size = strlen(pszFile) - HEAP_HEADER_FILE_SIZE;
    if ( alloc_size > 0 )
    {
        pszFile = &pszFile[ alloc_size ];
    }
    strncpy(
        h->FileName,
        pszFile,
        HEAP_HEADER_FILE_SIZE );

    h->TotalAlloc        = gTotalAlloc;
    h->CurrentAlloc      = gCurrentAlloc;
    h->FreeCount         = gFreeCount;
    h->CurrentAllocCount = gCurrentAllocCount;
    h->HeapCodeEnd       = HEAP_CODE_ACTIVE;

    //
    //  fill in trailer
    //

    t = HEAP_TRAILER( h );
    t->HeapCodeBegin = h->HeapCodeBegin;
    t->AllocCount    = h->AllocCount;
    t->AllocSize     = h->AllocSize;
    t->HeapCodeEnd   = h->HeapCodeEnd;

    //
    //  attach to alloc list
    //

    EnterCriticalSection( &csHeapList );
    InsertTailList( &listHeapListHead, &h->ListEntry );
    LeaveCriticalSection( &csHeapList );

    //
    //  return ptr to user memory
    //      - first byte past header
    //

    return( h+1 );
}



PHEAP_HEADER
HeapDbgHeaderFree(
    IN OUT  PVOID   pMem
    )
/*++

Routine Description:

    Resets heap globals and heap header info for free.

Arguments:

    pMem - ptr to user memory to free

Return Value:

    Ptr to block to be freed.

--*/
{
    register PHEAP_HEADER h;

    //
    //  validate memory block -- get ptr to header
    //

    h = HeapDbgValidateMemory( pMem, TRUE );

    //
    //  remove from current allocs list
    //

    EnterCriticalSection( &csHeapList );
    RemoveEntryList( &h->ListEntry );
    LeaveCriticalSection( &csHeapList );

    //
    //  update heap info globals
    //

    gCurrentAlloc -= h->AllocSize;
    gTotalFree += h->AllocSize;
    gFreeCount++;
    gCurrentAllocCount--;

    //
    //  reset header
    //

    h->HeapCodeEnd = HEAP_CODE_FREE;
    HEAP_TRAILER(h)->HeapCodeBegin = HEAP_CODE_FREE;

    //
    //  return ptr to block to be freed
    //

    return( h );
}



//
//  Heap Validation
//

PHEAP_HEADER
HeapDbgValidateMemory(
    IN      PVOID   pMem,
    IN      BOOL    fAtHeader
    )
/*++

Routine Description:

    Validates users heap pointer, and returns actual.

    Note:  This memory MUST have been allocated by THESE MEMORY routines.

Arguments:

    pMem - ptr to memory to validate

    fAtHeader - TRUE if pMem is known to be immediately after a head header,
        otherwise this function will search backwards through memory starting
        at pMem looking for a valid heap header

Return Value:

    Pointer to actual heap pointer.

--*/
{
    register PHEAP_HEADER   pheader;

    //
    //  Get pointer to heap header.
    //

    pheader = ( PHEAP_HEADER ) pMem - 1;
    if ( !fAtHeader )
    {
        int     iterations = 32 * 1024;

        //
        //  Back up from pMem a DWORD at a time looking for HEAP_CODE.
        //  If we don't find one, eventually we will generate an exception,
        //  which will be interesting. This could be handled, but for now
        //  this loop will just walk to past the start of valid memory.
        //

        while ( 1 )
        {
            //
            //  Break if we've found the heap header.
            //

            if ( pheader->HeapCodeBegin == HEAP_CODE &&
                ( pheader->HeapCodeEnd == HEAP_CODE_ACTIVE ||
                    pheader->HeapCodeEnd == HEAP_CODE_FREE ) )
            {
                break;
            }

            //
            //  Sanity check: too many iterations?
            //

            if ( ( --iterations ) == 0 )
            {
                ASSERT( iterations > 0 );
                return NULL;
            }

            //
            //  Back up another DWORD.
            //

            pheader = ( PHEAP_HEADER ) ( ( PBYTE ) pheader - 4 );
        }
    }

    //
    //  Verify header and trailer.
    //

    HeapDbgValidateHeader( pheader );

    return pheader;
}



VOID
HeapDbgValidateHeader(
    IN      PHEAP_HEADER    h
    )
/*++

Routine Description:

    Validates heap header.

Arguments:

    h - ptr to header of block

Return Value:

    None.

--*/
{
    register PHEAP_TRAILER t;

    //
    //  extract trailer
    //

    t = HEAP_TRAILER( h );

    //
    //  verify header
    //

    if ( h->HeapCodeBegin != HEAP_CODE
            ||
        h->HeapCodeEnd != HEAP_CODE_ACTIVE )
    {
        HEAP_DEBUG_PRINT((
            "Invalid memory block at %p -- invalid header.\n",
            h ));

        if ( h->HeapCodeEnd == HEAP_CODE_FREE )
        {
            HEAP_DEBUG_PRINT((
                "ERROR:  Previous freed memory.\n" ));
        }
        goto Invalid;
    }

    //
    //  match header, trailer alloc number
    //

    if ( h->HeapCodeBegin != t->HeapCodeBegin
            ||
        h->AllocCount != t->AllocCount
            ||
        h->AllocSize != t->AllocSize
            ||
        h->HeapCodeEnd != t->HeapCodeEnd )
    {
        HEAP_DEBUG_PRINT((
            "Invalid memory block at %p -- header / trailer mismatch.\n",
            h ));
        goto Invalid;
    }
    return;

Invalid:

    HeapDbgHeaderPrint( h, t );
    ASSERT( FALSE );
    HeapDbgGlobalInfoPrint();
    HeapDbgDumpAllocList();
    ASSERT( FALSE );
    return;
}



VOID
HeapDbgValidateAllocList(
    VOID
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pEntry;

    //
    //  loop through all outstanding alloc's, validating each one
    //

    EnterCriticalSection( &csHeapList );
    pEntry = listHeapListHead.Flink;

    while( pEntry != &listHeapListHead )
    {
        HeapDbgValidateHeader( HEAP_HEADER_FROM_LIST_ENTRY(pEntry) );

        pEntry = pEntry->Flink;
    }
    LeaveCriticalSection( &csHeapList );
}



//
//  Heap Printing
//

VOID
HeapDbgGlobalInfoPrint(
    VOID
    )
/*++

Routine Description:

    Prints global heap info.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_PRINT((
        "Heap Information:\n"
        "    Total Memory Allocated   = %d\n"
        "    Current Memory Allocated = %d\n"
        "    Alloc Count              = %d\n"
        "    Free Count               = %d\n"
        "    Outstanding Alloc Count  = %d\n",
        gTotalAlloc,
        gCurrentAlloc,
        gAllocCount,
        gFreeCount,
        gCurrentAllocCount ));
}



VOID
HeapDbgHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    )
/*++

Routine Description:

    Prints heap header and trailer.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( h )
    {
        HEAP_DEBUG_PRINT((
            "Heap Header at %p:\n"
            "    HeapCodeBegin     = %08lx\n"
            "    AllocCount        = %d\n"
            "    AllocSize         = %d\n"
            "    RequestSize       = %d\n"
            "    AllocTime         = %d\n"
            "    FileName          = %.*s\n"
            "    LineNo            = %d\n"
            "    TotalAlloc        = %d\n"
            "    CurrentAlloc      = %d\n"
            "    FreeCount         = %d\n"
            "    CurrentAllocCount = %d\n"
            "    HeapCodeEnd       = %08lx\n",
            h,
            h->HeapCodeBegin,
            h->AllocCount,
            h->AllocSize,
            h->RequestSize,
            h->AllocTime / 1000,
            HEAP_HEADER_FILE_SIZE,
            h->FileName,
            h->LineNo,
            h->TotalAlloc,
            h->CurrentAlloc,
            h->FreeCount,
            h->CurrentAllocCount,
            h->HeapCodeEnd ));
    }

    if ( t )
    {
        HEAP_DEBUG_PRINT((
            "Heap Trailer at %p:\n"
            "    HeapCodeBegin     = %08lx\n"
            "    AllocCount        = %d\n"
            "    AllocSize         = %d\n"
            "    HeapCodeEnd       = %08lx\n",
            t,
            t->HeapCodeBegin,
            t->AllocCount,
            t->AllocSize,
            t->HeapCodeEnd ));
    }
}



VOID
HeapDbgDumpAllocList(
    VOID
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pEntry;
    PHEAP_HEADER pHead;

    HEAP_DEBUG_PRINT(( "Dumping Alloc List:\n" ));

    //
    //  loop through all outstanding alloc's, dumping output
    //

    EnterCriticalSection( &csHeapList );
    pEntry = listHeapListHead.Flink;

    while( pEntry != &listHeapListHead )
    {
        pHead = HEAP_HEADER_FROM_LIST_ENTRY( pEntry );

        HeapDbgHeaderPrint(
            pHead,
            HEAP_TRAILER( pHead )
            );
        pEntry = pEntry->Flink;
    }
    LeaveCriticalSection( &csHeapList );

    HEAP_DEBUG_PRINT(( "End Dump of Alloc List.\n" ));
}

#endif

//
// End of heapdbg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\heapdbg.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    heapdbg,h

Abstract:

    Heap debugging definitions and declarations.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#ifndef _HEAPDBG_INCLUDED_
#define _HEAPDBG_INCLUDED_


#if DBG

//
//  Heap debug print routine
//      - set to print routine for environment
//

#define HEAP_DEBUG_PRINT(_x_)   DNS_PRINT(_x_)

//
//  Heap Debugging Public Global Info
//

extern  ULONG   gTotalAlloc;
extern  ULONG   gCurrentAlloc;
extern  ULONG   gAllocCount;
extern  ULONG   gFreeCount;
extern  ULONG   gCurrentAllocCount;

//
//  Full heap checks before all operations?
//

extern  BOOL    fHeapDbgCheckAll;


//
//  Heap Header
//

#define HEAP_HEADER_FILE_SIZE   (16)

typedef struct _HEAP_HEADER
{
    //
    //  Note, if move or add fields, MUST update list entry offset below
    //

    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       RequestSize;
    ULONG       AllocSize;

    //
    //  Put LIST_ENTRY in middle of header
    //      - keep begin code at front
    //      - less likely to be corrupted
    //

    LIST_ENTRY  ListEntry;

    DWORD       AllocTime;
    DWORD       LineNo;
    CHAR        FileName[ HEAP_HEADER_FILE_SIZE ];

    ULONG       TotalAlloc;
    ULONG       CurrentAlloc;
    ULONG       FreeCount;
    ULONG       CurrentAllocCount;
    ULONG       HeapCodeEnd;
}
HEAP_HEADER, * PHEAP_HEADER;

//
//  Heap Trailer
//

typedef struct _HEAP_TRAILER
{
    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       HeapCodeEnd;
}
HEAP_TRAILER, * PHEAP_TRAILER;


//
//  Header from list entry
//

#define HEAP_HEADER_LIST_ENTRY_OFFSET   (16)

#define HEAP_HEADER_FROM_LIST_ENTRY( pList )    \
            ( (PHEAP_HEADER)( (PCHAR)pList - HEAP_HEADER_LIST_ENTRY_OFFSET ))


//
//  Main Debug Heap Routines
//

PVOID
HeapDbgAlloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    );

PVOID
HeapDbgRealloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN OUT  PVOID   pMem,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    );

VOID
HeapDbgFree(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN OUT  PVOID   pMem
    );


//
//  Heap Debug Utilities
//

BOOL
HeapDbgInit(
    IN      DWORD   dwException,
    IN      BOOL    fFullHeapChecks
    );

INT
HeapDbgAllocSize(
    IN      INT     iRequestSize
    );

VOID
HeapDbgValidateHeader(
    IN      PHEAP_HEADER    h
    );

PHEAP_HEADER
HeapDbgValidateMemory(
    IN      PVOID   pMem,
    IN      BOOL    fAtHeader
    );

VOID
HeapDbgValidateAllocList(
    VOID
    );

PVOID
HeapDbgHeaderAlloc(
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

PHEAP_HEADER
HeapDbgHeaderFree(
    IN OUT  PVOID   pMem
    );

VOID
HeapDbgGlobalInfoPrint(
    VOID
    );

VOID
HeapDbgHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    );

VOID
HeapDbgDumpAllocList(
    VOID
    );

#else   // non-debug

//
//  Non debug
//
//  Macroize these debug functions to no-ops
//

#define HeapDbgAlloc(iSize)
#define HeapDbgRealloc(pMem,iSize)
#define HeapDbgFree(pMem)

#define HeapDbgInit()
#define HeapDbgAllocSize(iSize)
#define HeapDbgValidateHeader(h)
#define HeapDbgValidateMemory(pMem)
#define HeapDbgValidateAllocList()
#define HeapDbgHeaderAlloc(h,iSize)
#define HeapDbgHeaderFree(pMem)
#define HeapDbgGlobalInfoPrint()
#define HeapDbgHeaderPrint(h,t)
#define HeapDbgDumpAllocList()

#endif

#endif  //  _HEAPDBG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\file.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    file.c

Abstract:

    Domain Name System (DNS) Server

    Database file utility routines.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  File directory globals
//
//  Initialized in srvcfg.c when directory info loaded.
//

PWSTR   g_pFileDirectoryAppend;
DWORD   g_FileDirectoryAppendLength;

PWSTR   g_pFileBackupDirectoryAppend;
DWORD   g_FileBackupDirectoryAppendLength;




//
//  Simplified file mapping routines
//

DNS_STATUS
copyAnsiStringToUnicode(
    OUT     LPWSTR      pszUnicode,
    IN      LPSTR       pszAnsi
    )
/*++

Routine Description:

    Copy ANSI string to UNICODE.

    Assumes adequate length.

Arguments:

    pszUnicode -- buffer to receive unicode string

    pszAnsi -- incoming ANSI string

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on errors.

--*/
{
    DNS_STATUS      status;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;

    RtlInitAnsiString(
        & ansiString,
        pszAnsi );

    unicodeString.Length = 0;
    unicodeString.MaximumLength = MAX_PATH;
    unicodeString.Buffer = pszUnicode;

    status = RtlAnsiStringToUnicodeString(
                & unicodeString,
                & ansiString,
                FALSE       // no allocation
                );
    ASSERT( status == ERROR_SUCCESS );

    return status;
}



DNS_STATUS
OpenAndMapFileForReadW(
    IN      PWSTR           pwsFilePath,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    )
/*++

Routine Description:

    Opens and maps file.

    Note, does not log error for FILE_NOT_FOUND condition if fMustFind
    is not set -- no file is legitimate for secondary file.

Arguments:

    pwsFilePath - name/path of file

    pmfFile - ptr to file mapping struct to hold results

    fMustFind - file must be found

Return Value:

    ERROR_SUCCESS if file opened and mapped.
    ERROR_FILE_NOT_FOUND if file not found.
    ErrorCode on errors.

--*/
{
    HANDLE  hfile = NULL;
    HANDLE  hmapping = NULL;
    PVOID   pvdata;
    DWORD   fileSizeLow;
    DWORD   fileSizeHigh;
    DWORD   status;

    //
    //  Open the file
    //

    hfile = CreateFileW(
                pwsFilePath,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( hfile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "Could not open file: %S\n",
            pwsFilePath ));

        if ( fMustFind || status != ERROR_FILE_NOT_FOUND )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_FILE_OPEN_ERROR,
                1,
                (LPSTR *) &pwsFilePath,
                NULL,
                0 );
        }
        return status;
    }

    //
    //  Get file size
    //

    fileSizeLow = GetFileSize( hfile, &fileSizeHigh );

    if ( ( fileSizeLow == 0xFFFFFFFF ) &&
         ( ( status = GetLastError() ) != NO_ERROR ) )
    {
        DNS_DEBUG( INIT, (
            "Map of file %S failed.  Invalid file size: %d\n",
            pwsFilePath,
            status ));

        goto Failed;
    }

    hmapping = CreateFileMapping(
                    hfile,
                    NULL,
                    PAGE_READONLY | SEC_COMMIT,
                    0,
                    0,
                    NULL );

    if ( hmapping == NULL )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "CreateFileMapping() failed for %S.  Error = %d\n",
            pwsFilePath,
            status ));
        goto Failed;
    }

    pvdata = MapViewOfFile(
                    hmapping,
                    FILE_MAP_READ,
                    0,
                    0,
                    0 );

    if ( pvdata == NULL )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "MapViewOfFile() failed for %s.  Error = %d.\n",
            pwsFilePath,
            status ));
        goto Failed;
    }

    //
    //  If we somehow mapped a file larger than 4GB, it must be RNT
    //      = really new technology.
    //

    ASSERT( fileSizeHigh == 0 );

    pmfFile->hFile = hfile;
    pmfFile->hMapping = hmapping;
    pmfFile->pvFileData = pvdata;
    pmfFile->cbFileBytes = fileSizeLow;

    return ERROR_SUCCESS;


Failed:

    DNS_LOG_EVENT(
        DNS_EVENT_FILE_NOT_MAPPED,
        1,
        (LPSTR *) &pwsFilePath,
        NULL,
        status );

    if ( hmapping )
    {
        CloseHandle( hmapping );
    }
    if ( hfile )
    {
        CloseHandle( hfile );
    }
    return status;
}



DNS_STATUS
OpenAndMapFileForReadA(
    IN      LPSTR           pwsFilePath,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    )
/*++

Routine Description:

    Opens and maps file.

    Note, does not log error for FILE_NOT_FOUND condition if fMustFind
    is not set -- no file is legitimate for secondary file.

Arguments:

    pwsFilePath - name/path of file

    pmfFile - ptr to file mapping struct to hold results

    fMustFind - file must be found

Return Value:

    ERROR_SUCCESS if file opened and mapped.
    ERROR_FILE_NOT_FOUND if file not found.
    ErrorCode on errors.

--*/
{
    DNS_STATUS  status;
    WCHAR       szunicode[ MAX_PATH ];

    status = copyAnsiStringToUnicode(
                szunicode,
                pwsFilePath );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }
    return  OpenAndMapFileForReadW(
                szunicode,
                pmfFile,
                fMustFind );
}



VOID
CloseMappedFile(
    IN      PMAPPED_FILE    pmfFile
    )
/*++

Routine Description:

    Closes mapped file.

Arguments:

    hmapfile    - ptr to mapped file struct

Return Value:

    None.

--*/
{
    UnmapViewOfFile( pmfFile->pvFileData );
    CloseHandle( pmfFile->hMapping );
    CloseHandle( pmfFile->hFile );
}



//
//  File writing
//

HANDLE
OpenWriteFileExW(
    IN      PWSTR           pwsFileName,
    IN      BOOLEAN         fAppend
    )
/*++

Routine Description:

    Open file for write.

Arguments:

    pwsFileName -- path to file to write

    fAppend -- if TRUE append; if FALSE overwrite

Return Value:

    Handle to file, if successful.
    NULL otherwise.

--*/
{
    HANDLE hfile;

    //
    //  open file for write
    //

    hfile = CreateFileW(
                pwsFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,                // let folks use "list.exe"
                NULL,                           // no security
                fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                0,
                NULL );

    if ( hfile == INVALID_HANDLE_VALUE )
    {
        DWORD   status = GetLastError();
        PVOID   parg = pwsFileName;

        DNS_LOG_EVENT(
            DNS_EVENT_FILE_NOT_OPENED_FOR_WRITE,
            1,
            & parg,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to open file %S for write.\n",
            pwsFileName ));

        hfile = NULL;
    }
    return( hfile );
}



HANDLE
OpenWriteFileExA(
    IN      LPSTR           pwsFileName,
    IN      BOOLEAN         fAppend
    )
/*++

Routine Description:

    Open file for write.

Arguments:

    pwsFileName -- path to file to write

    fAppend -- if TRUE append; if FALSE overwrite

Return Value:

    Handle to file, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    WCHAR       szunicode[MAX_PATH];

    status = copyAnsiStringToUnicode(
                szunicode,
                pwsFileName );
    if ( status != ERROR_SUCCESS )
    {
        return( NULL );
    }
    return  OpenWriteFileExW(
                szunicode,
                fAppend );
}



BOOL
FormattedWriteFile(
    IN      HANDLE          hfile,
    IN      PCHAR           pszFormat,
    ...
    )
/*++

Routine Description:

    Write formatted string to file.

Arguments:

    pszFormat -- standard C format string

    ... -- standard arg list

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    DNS_STATUS      status;
    va_list         arglist;
    CHAR            OutputBuffer[ 1024 ];
    ULONG           length;
    BOOL            ret;

    //
    //  print  format string to buffer
    //

    va_start( arglist, pszFormat );

    status = StringCchVPrintfA(
                OutputBuffer,
                sizeofarray( OutputBuffer ),
                pszFormat,
                arglist );

    va_end( arglist );
    
    if ( FAILED( status ) )
    {
        return FALSE;
    }

    //
    //  write resulting buffer to file
    //

    length = strlen( OutputBuffer );

    ret = WriteFile(
                hfile,
                (LPVOID) OutputBuffer,
                length,
                &length,
                NULL );
    if ( !ret )
    {
        DWORD   st = GetLastError();

        DNS_LOG_EVENT(
            DNS_EVENT_WRITE_FILE_FAILURE,
            0,
            NULL,
            NULL,
            st );

        DNS_DEBUG( ANY, (
            "ERROR:  WriteFile failed, err = 0x%08lx.\n",
            st ));
    }
    return ret;
}   //  FormattedWriteFile



VOID
ConvertUnixFilenameToNt(
    IN OUT  LPSTR           pwsFileName
    )
/*++

Routine Description:

    Replace UNIX slash, with NT backslash.

Arguments:

    pszFilename -- filename to convert, must be NULL terminated

Return Value:

    None.

--*/
{
    if ( ! pwsFileName )
    {
        return;
    }
    while ( *pwsFileName )
    {
        if ( *pwsFileName == '/' )
        {
            *pwsFileName = '\\';
        }
        pwsFileName++;
    }
}



DWORD
WriteMessageToFile(
    IN      HANDLE          hFile,
    IN      DWORD           dwMessageId,
    ...
    )
/*++

Routine Description:

    Write message to file.

Arguments:

    hFile -- handle to file

    dwMessageId -- message id to write

    ... -- argument strings

Return Value:

    Number of bytes written.  Zero if failure.

--*/
{
    DWORD   writeLength;
    PVOID   messageBuffer;
    va_list arglist;

    //
    //  write formatted message to buffer
    //      - call allocates message buffer
    //

    va_start( arglist, dwMessageId );

    writeLength = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER      // allocate msg buffer
                            | FORMAT_MESSAGE_FROM_HMODULE,
                        NULL,                       // message table in this module
                        dwMessageId,
                        0,                          // default country ID.
                        (LPTSTR) &messageBuffer,
                        0,
                        &arglist );

    //
    //  write formatted message to file
    //      - note, using unicode version, so write length is twice
    //          message length in chars
    //      - free formatted message buffer
    //

    if ( writeLength )
    {
        writeLength *= 2;

        WriteFile(
            hFile,
            messageBuffer,
            writeLength,
            & writeLength,
            NULL
            );
        LocalFree( messageBuffer );
    }

    return( writeLength );
}



//
//  File buffer routines
//

BOOL
WriteBufferToFile(
    IN      PBUFFER         pBuffer
    )
/*++

Routine Description:

    Write buffer to file.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    ULONG   length;
    BOOL    ret;

    DNS_DEBUG( WRITE, (
        "Writing buffer to file.\n"
        "    handle = %d\n"
        "    length = %d\n",
        pBuffer->hFile,
        (pBuffer->pchCurrent - pBuffer->pchStart) ));

    //
    //  write current data in buffer to file
    //

    ret = WriteFile(
                pBuffer->hFile,
                (PVOID) pBuffer->pchStart,
                (DWORD)(pBuffer->pchCurrent - pBuffer->pchStart),
                &length,
                NULL
                );
    if ( !ret )
    {
        DWORD   status = GetLastError();

        DNS_LOG_EVENT(
            DNS_EVENT_WRITE_FILE_FAILURE,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "ERROR:  WriteFile failed, err = 0x%08lx.\n",
            status ));
    }

    RESET_BUFFER( pBuffer );
    return ret;
}   //  WriteBufferToFile



BOOL
FormattedWriteToFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pszFormat,
    ...
    )
/*++

Routine Description:

    Write formatted string to file buffer.

Arguments:

    pszFormat -- standard C format string

    ... -- standard arg list

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    va_list arglist;
    ULONG   length;

    //
    //  if buffer approaching full, write it
    //

    length = (ULONG)(pBuffer->pchCurrent - pBuffer->pchStart);

    if ( (INT)(pBuffer->cchLength - length) < MAX_FORMATTED_BUFFER_WRITE )
    {
        WriteBufferToFile( pBuffer );

        ASSERT( IS_EMPTY_BUFFER(pBuffer) );
    }

    //
    //  print format string into buffer
    //

    va_start( arglist, pszFormat );

    vsprintf( pBuffer->pchCurrent, pszFormat, arglist );

    va_end( arglist );

    //
    //  reset buffer for write
    //

    length = strlen( pBuffer->pchCurrent );

    pBuffer->pchCurrent += length;

    ASSERT( pBuffer->pchCurrent < pBuffer->pchEnd );

    return TRUE;
}   // FormattedWriteToFileBuffer



VOID
FASTCALL
InitializeFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pData,
    IN      DWORD       dwLength,
    IN      HANDLE      hFile
    )
/*++

Routine Description:

    Initialize file buffer.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    None.

--*/
{
    pBuffer->cchLength = dwLength;
    pBuffer->cchBytesLeft = dwLength;

    pBuffer->pchStart = pData;
    pBuffer->pchCurrent = pData;
    pBuffer->pchEnd = pData + dwLength;

    pBuffer->hFile = hFile;
    pBuffer->dwLineCount = 0;
}



VOID
CleanupNonFileBuffer(
    IN      PBUFFER         pBuffer
    )
/*++

Routine Description:

    Cleanup non-file buffer if has heap data.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    None.

--*/
{
    if ( pBuffer->hFile == BUFFER_NONFILE_HEAP )
    {
        FREE_HEAP( pBuffer->pchStart );
        pBuffer->pchStart = NULL;
        pBuffer->hFile = NULL;
    }
}




//
//  DNS specific file utilities
//

BOOL
File_CreateDatabaseFilePath(
    IN OUT  PWCHAR          pwFileBuffer,
    IN OUT  PWCHAR          pwBackupBuffer,     OPTIONAL
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Creates full path name to database file.

Arguments:

    pwFileBuffer -- buffer to hold file path name - it is assumed that
        this buffer will be able to hold MAX_PATH characters

    pwBackupBuffer -- buffer to hold backup file path name,

    pwszFileName -- database file name

Return Value:

    TRUE -- if successful
    FALSE -- on error;  filename, directory or full path invalid;
        if full backup path invalid, simply return empty string

--*/
{
    INT     lengthFileName;

    ASSERT( SrvCfg_pwsDatabaseDirectory );
    ASSERT( g_pFileDirectoryAppend );
    ASSERT( g_pFileBackupDirectoryAppend );

    DNS_DEBUG( INIT2, (
        "File_CreateDatabaseFilePath()\n"
        "    SrvCfg directory = %S\n"
        "    file name = %S\n",
        SrvCfg_pwsDatabaseDirectory,
        pwsFileName ));

    //
    //  Initialize output buffers (makes PREFIX happy).
    //

    if ( pwFileBuffer )
    {
        *pwFileBuffer = L'\0';
    }
    if ( pwBackupBuffer )
    {
        *pwBackupBuffer = L'\0';
    }

    //
    //  get directory, verify name suitability
    //

    if ( !pwsFileName || !SrvCfg_pwsDatabaseDirectory )
    {
        return FALSE;
    }

    lengthFileName  = wcslen( pwsFileName );

    if ( g_FileDirectoryAppendLength + lengthFileName >= MAX_PATH )
    {
        PVOID   argArray[2];

        argArray[0] = pwsFileName;
        argArray[1] = SrvCfg_pwsDatabaseDirectory;

        DNS_LOG_EVENT(
            DNS_EVENT_FILE_PATH_TOO_LONG,
            2,
            argArray,
            NULL,
            0 );

        DNS_DEBUG( ANY, (
            "Could not create path for database file %S\n"
            "    in current directory %S.\n",
            pwsFileName,
            SrvCfg_pwsDatabaseDirectory ));
        return FALSE;
    }

    //
    //  build file path name
    //      - copy append directory name
    //      - copy file name
    //

    wcscpy( pwFileBuffer, g_pFileDirectoryAppend );
    wcscat( pwFileBuffer, pwsFileName );

    //
    //  if no backup path -- done
    //

    if ( ! pwBackupBuffer )
    {
        return TRUE;
    }

    //
    //  check backup path length
    //      - note backup subdir string has both directory separators
    //      (i.e "\\backup\\") so no extra bytes for separator needed
    //

    if ( !g_pFileBackupDirectoryAppend  ||
         g_FileBackupDirectoryAppendLength + lengthFileName >= MAX_PATH )
    {
        *pwBackupBuffer = 0;
        return TRUE;
    }

    wcscpy( pwBackupBuffer, g_pFileBackupDirectoryAppend );
    wcscat( pwBackupBuffer, pwsFileName );

    return TRUE;
}



BOOL
File_CheckDatabaseFilePath(
    IN      PWCHAR          pwFileName,
    IN      DWORD           cFileNameLength     OPTIONAL
    )
/*++

Routine Description:

    Checks validity of file path.

Arguments:

    pwFileName -- database file name

    cFileNameLength -- optional specification of file name length,
        name assumed to be string if zero

Return Value:

    TRUE if file path valid
    FALSE on error

--*/
{
    //
    //  basic validity check
    //

    if ( !pwFileName || !SrvCfg_pwsDatabaseDirectory )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Missing %S to check path!\n",
            pwFileName ? "file" : "directory" ));
        return FALSE;
    }

    //
    //  get file name length
    //

    if ( ! cFileNameLength )
    {
        cFileNameLength = wcslen( pwFileName );
    }

    //
    //  verify name suitability
    //

    if ( g_FileDirectoryAppendLength + cFileNameLength >= MAX_PATH )
    {
        DNS_DEBUG( INIT, (
            "Filename %.*S exceeds MAX file path length\n"
            "    with current directory %S.\n",
            cFileNameLength,
            pwFileName,
            SrvCfg_pwsDatabaseDirectory ));
        return FALSE;
    }
    return TRUE;
}



BOOL
File_MoveToBackupDirectory(
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Move file to backup directory.

Arguments:

    pwsFileName -- file to move

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    WCHAR   wsfile[ MAX_PATH ];
    WCHAR   wsbackup[ MAX_PATH ];

    //
    //  secondaries may not have file
    //

    if ( !pwsFileName )
    {
        return FALSE;
    }

    //
    //  create path to file and backup directory
    //

    if ( ! File_CreateDatabaseFilePath(
                wsfile,
                wsbackup,
                pwsFileName ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        return FALSE;
    }

    return  MoveFileEx(
                wsfile,
                wsbackup,
                MOVEFILE_REPLACE_EXISTING );
}

//
//  End of file.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\file.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    file.h

Abstract:

    Domain Name System (DNS) Server

    File mapping definitions and declarations.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#ifndef _FILE_INCLUDED_
#define _FILE_INCLUDED_


//
//  Mapped file structure
//

typedef struct
{
    HANDLE  hFile;
    HANDLE  hMapping;
    PVOID   pvFileData;
    DWORD   cbFileBytes;
}
MAPPED_FILE, * PMAPPED_FILE;


//
//  Buffer structure
//

typedef struct _Buffer
{
    HANDLE  hFile;
    DWORD   cchLength;
    PCHAR   pchStart;
    PCHAR   pchEnd;
    PCHAR   pchCurrent;
    DWORD   cchBytesLeft;
    DWORD   dwLineCount;
}
BUFFER, *PBUFFER;

#define RESET_BUFFER(pBuf)  \
        {                   \
            PBUFFER _pbuf = (pBuf);                     \
            _pbuf->pchCurrent = _pbuf->pchStart;        \
            _pbuf->cchBytesLeft = _pbuf->cchLength;     \
        }

#define IS_EMPTY_BUFFER(pBuf)   (pBuf->pchCurrent == pBuf->pchStart)

//
// Sundown: Following macros assume buffer length < 4GB.
//

#define BUFFER_LENGTH_TO_CURRENT( pBuf ) \
            ( (DWORD) ((pBuf)->pchCurrent - (pBuf)->pchStart) )

#define BUFFER_LENGTH_FROM_CURRENT_TO_END( pBuf ) \
            ( (DWORD) ((pBuf)->pchEnd - (pBuf)->pchCurrent) )

#define MAX_FORMATTED_BUFFER_WRITE  (0x2000)    // 8K


//  hFile field may be overloaded in non-file case
//  to indicate STACK or HEAP data

#define BUFFER_NONFILE_STACK    ((HANDLE)(-1))
#define BUFFER_NONFILE_HEAP     ((HANDLE)(-3))



//
//  File mapping routines
//

DNS_STATUS
OpenAndMapFileForReadW(
    IN      LPWSTR          pszFilePathName,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    );

DNS_STATUS
OpenAndMapFileForReadA(
    IN      LPSTR           pszFilePathName,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    );

#ifdef  UNICODE
#define OpenAndMapFileForRead(p,m,f)    OpenAndMapFileForReadW(p,m,f)
#else
#define OpenAndMapFileForRead(p,m,f)    OpenAndMapFileForReadA(p,m,f)
#endif

VOID
CloseMappedFile(
    IN      PMAPPED_FILE    pmfFile
    );


//
//  File writing routines
//

HANDLE
OpenWriteFileExW(
    IN      LPWSTR          pszFileName,
    IN      BOOLEAN         fAppend
    );

HANDLE
OpenWriteFileExA(
    IN      LPSTR           pszFileName,
    IN      BOOLEAN         fAppend
    );

#ifdef  UNICODE
#define OpenWriteFileEx(p,f)   OpenWriteFileExW(p,f)
#else
#define OpenWriteFileEx(p,f)   OpenWriteFileExA(p,f)
#endif


BOOL
FormattedWriteFile(
    IN      HANDLE  hFile,
    IN      PCHAR   pszFormat,
    ...
    );

DWORD
WriteMessageToFile(
    IN      HANDLE  hFile,
    IN      DWORD   dwMessageId,
    ...
    );

//
//  Miscellaneous file utilities
//

VOID
ConvertUnixFilenameToNt(
    IN OUT  LPSTR       pszFileName
    );

//
//  Writing using file buffer
//

BOOL
WriteBufferToFile(
    IN      PBUFFER     pBuffer
    );

BOOL
FormattedWriteToFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pszFormat,
    ...
    );

VOID
FASTCALL
InitializeFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pData,
    IN      DWORD       dwLength,
    IN      HANDLE      hFile
    );

VOID
CleanupNonFileBuffer(
    IN      PBUFFER     pBuffer
    );

#endif  //  _FILE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\log.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Domain Name System (DNS) Server

    Retail logging (debug logging for retail product)

Author:

    Jeff Westhead (jwesth)      July 2001

Revision History:

--*/


#ifndef _DNS_LOG_H_INCLUDED_
#define _DNS_LOG_H_INCLUDED_


/*

Log Levels
----------

The log level is a 64 bit flag, made of up two 32 bit DWORDs read from the
registry. The low DWORD is read from DNS_REGKEY_OPS_LOG_LEVEL1. The high
DWORD is ready from DNS_REGKEY_OPS_LOG_LEVEL2.

Log Messages
------------

All log messages should start with capitals and NOT end with periods.

*/


#define DNSLOG_UPDATE_LEVEL()  (                                    \
    SrvCfg_dwOperationsLogLevel =                                   \
        ( SrvInfo.dwOperationsLogLevel_HighDword << 32 ) |          \
        SrvCfg_dwOperationsLogLevel_LowDword )


//
//  Log levels
//

#define DNSLOG_WRITE_THROUGH            0x0000000000000001i64

#define DNSLOG_EVENT                    0x0000000000000010i64
#define DNSLOG_INIT                     0x0000000000000020i64

#define DNSLOG_ZONE                     0x0000000000000100i64
#define DNSLOG_ZONEXFR                  0x0000000000000200i64

#define DNSLOG_DS                       0x0000000000001000i64
#define DNSLOG_DSPOLL                   0x0000000000002000i64
#define DNSLOG_DSWRITE                  0x0000000000004000i64

#define DNSLOG_AGING                    0x0000000000010000i64
#define DNSLOG_TOMBSTN                  0x0000000000020000i64   //  tombstone

#define DNSLOG_LOOKUP                   0x0000000000100000i64
#define DNSLOG_RECURSE                  0x0000000000200000i64
#define DNSLOG_REMOTE                   0x0000000000400000i64

#define DNSLOG_PLUGIN                   0x0100000000000000i64

#define DNSLOG_ANY                      0xffffffffffffffffi64


//
//  Log macros
//

#define LOG_INDENT      "                     "
#define LOG_INDENT1     "                         "

#define IF_DNSLOG( _level_ )                                        \
    if ( SrvCfg_dwOperationsLogLevel & DNSLOG_ ## _level_ )

#define IF_NOT_DNSLOG( _level_ )                                    \
    if ( ( SrvCfg_dwOperationsLogLevel & DNSLOG_ ## _level_ ) == 0 )

#define DNSLOG( _level_, _printargs_ )                             \
    IF_DNSLOG( _level_ )                                            \
    {                                                               \
        if ( Log_EnterLock() )                                      \
        {                                                           \
            g_pszCurrentLogLevelString = #_level_;                  \
            ( Log_Printf _printargs_ );                             \
            g_pszCurrentLogLevelString = NULL;                      \
            Log_LeaveLock();                                        \
        }                                                           \
    }


//
//  Log functions
//


PCHAR
Log_FormatPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PBYTE           pPacketName
    );

PCHAR
Log_FormatNodeName(
    IN      PDB_NODE        pNode
    );

PCHAR
Log_CurrentSection(
    IN      PDNS_MSGINFO    pMsg
    );

DNS_STATUS
Log_InitializeLogging(
    BOOL        fAlreadyLocked
    );

VOID
Log_Shutdown(
    VOID
    );

BOOL
Log_EnterLock(
    VOID
    );

VOID
Log_LeaveLock(
    VOID
    );

VOID
Log_PushToDisk(
    VOID
    );

VOID
Log_PrintRoutine(
    IN      PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           Format,
    ...
    );

VOID
Log_Printf(
    IN      LPSTR           Format,
    ...
    );

VOID
Log_Message(
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fSend,
    IN      BOOL            fForce
    );

#define DNSLOG_MESSAGE_RECV( pMsg )                     \
            if ( SrvCfg_dwLogLevel )                    \
            {                                           \
                Log_Message( (pMsg), FALSE, FALSE );    \
            }
#define DNSLOG_MESSAGE_SEND( pMsg )                     \
            if ( SrvCfg_dwLogLevel )                    \
            {                                           \
                Log_Message( (pMsg), TRUE, FALSE );     \
            }

VOID
Log_DsWrite(
    IN      LPWSTR          pwszNodeDN,
    IN      BOOL            fAdd,
    IN      DWORD           dwRecordCount,
    IN      PDS_RECORD      pRecord
    );

VOID
Log_SocketFailure(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pSocket,
    IN      DNS_STATUS      Status
    );


//
//  Globals
//

extern LPSTR    g_pszCurrentLogLevelString;


#endif  // _DNS_LOG_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\log.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Domain Name System (DNS) Server

    Logging routines.

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#include "dnssrv.h"


//
//  Log file globals
//

#define LOG_FILE_PATH               TEXT("system32\\dns\\dns.log")
#define LOG_FILE_DEFAULT_DIR        TEXT("dns\\")
#define LOG_FILE_BACKUP_PATH        TEXT("dns\\backup\\dns.log")

#define LOGS_BETWEEN_FREE_SPACE_CHECKS      100
#define LOG_MIN_FREE_SPACE                  25000000i64     //  25MB

#define LOG_DISK_FULL_WARNING \
    "\nThe disk is dangerously full.\nNo more logs will " \
    "be written until disk space is freed.\n\n"

HANDLE  hLogFile = NULL;

DWORD   BytesWrittenToLog = 0;

#define LOG_DISABLED()  ( hLogFile == NULL || hLogFile == INVALID_HANDLE_VALUE )


//
//  Logging buffer globals
//

#define LOG_BUFFER_LENGTH           (0x20000)   //  128k
#define MAX_LOG_MESSAGE_LENGTH      (0x2000)    //  largest allowable event message
#define MAX_PRINTF_BUFFER_LENGTH    (0x2000)    //  8K


BUFFER  LogBuffer = { 0 };

CHAR    pchLogBuffer[ LOG_BUFFER_LENGTH ];

LPWSTR  g_pwszLogFileName = NULL;
LPWSTR  g_pwszLogFileDrive = NULL;

BOOL    g_fLastLogWasDiskFullMsg = FALSE;

LPSTR   g_pszCurrentLogLevelString = NULL;


//
//  Backup constants
//

#define DNS_BACKUP_KEY_NAME         \
    TEXT( "SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup" )
#define DNS_BACKUP_VALUE_NAME       \
    TEXT( "DNS Server" )
#define DNS_BACKUP_LOG_BACK_FILE    \
    TEXT( "%SystemRoot%\\system32\\dns\\backup\\dns.log" )


//
//  Logging Lock
//

BOOL fLogCsInit = FALSE;

CRITICAL_SECTION csLogLock;

#define LOCK_LOG()      EnterCriticalSection( &csLogLock );
#define UNLOCK_LOG()    LeaveCriticalSection( &csLogLock );



//
//  Private logging utilities
//


VOID
writeAndResetLogBuffer(
    VOID
    )
/*++

Routine Description:

    Write log to disk and reset.

    DEVNOTE-DCR: Make logging asynchronous, return immediately.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD       length;
    DWORD       written;

    //
    //  get length to write
    //  update global for size of log file
    //

    length = BUFFER_LENGTH_TO_CURRENT( &LogBuffer );

    BytesWrittenToLog += length;

    do
    {
        static BOOL     fLastWriteWasDiskSpaceWarning = FALSE;
        static int      logsSinceFreeSpaceCheck = 0;

        //
        //  Check free disk space.
        //

        if ( g_pwszLogFileDrive &&
            ( fLastWriteWasDiskSpaceWarning || 
                ++logsSinceFreeSpaceCheck > LOGS_BETWEEN_FREE_SPACE_CHECKS ) )
        {
            ULARGE_INTEGER      uliFreeSpace = { 0, 0 };

            if ( GetDiskFreeSpaceExW(
                    g_pwszLogFileDrive,
                    NULL,
                    NULL,
                    &uliFreeSpace ) )
            {
                if ( uliFreeSpace.QuadPart < LOG_MIN_FREE_SPACE )
                {
                    DNS_PRINT((
                        "ERROR: disk full while logging, %d bytes free\n",
                        uliFreeSpace.LowPart ));
                    if ( !fLastWriteWasDiskSpaceWarning )
                    {
                        WriteFile(
                                hLogFile,
                                LOG_DISK_FULL_WARNING,
                                strlen( LOG_DISK_FULL_WARNING ),
                                & written,
                                NULL );
                        fLastWriteWasDiskSpaceWarning = TRUE;
                    }
                    goto Reset;
                }
            }
            else
            {
                DNS_PRINT((
                    "GetDiskFreeSpaceExW failed %d\n",
                    GetLastError() ));
            }
            logsSinceFreeSpaceCheck = 0;
        }
        
        //
        //  Write log buffer to file.
        //

        fLastWriteWasDiskSpaceWarning = FALSE;

        if ( ! WriteFile(
                    hLogFile,
                    (LPVOID) pchLogBuffer,
                    length,
                    & written,
                    NULL
                    ) )
        {
            DNS_STATUS status = GetLastError();

            DNS_PRINT((
                "ERROR:  Logging write failed = %d (%p).\n"
                "\tlength = %d\n",
                status, status,
                length ));

            //  DEVNOTE-LOG: log write error
            //      - log event (limited event)
            //      - start next buffer log with notice of write failures

            goto Reset;
        }

        length -= written;
        ASSERT( (LONG)length >= 0 );
    }
    while ( (LONG)length > 0 );

Reset:

    RESET_BUFFER( &LogBuffer );

    //
    //  limit log file size to something reasonable
    //      - but don't let them mess it up by going to less than 64k
    //

    if ( SrvCfg_dwLogFileMaxSize < 0x10000 )
    {
        SrvCfg_dwLogFileMaxSize = 0x10000;
    }
    if ( BytesWrittenToLog > SrvCfg_dwLogFileMaxSize )
    {
        Log_InitializeLogging( TRUE );
    }
}



VOID
writeLogBootInfo(
    VOID
    )
/*++

Routine Description:

    Write boot info to log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR    szTime[ 50 ];

    //
    //  write server startup time
    //

    Dns_WriteFormattedSystemTimeToBuffer(
        szTime,
        (PSYSTEMTIME) &TimeStats.ServerStartTime );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "DNS Server log file creation at %s UTC\n",
            szTime );
}



VOID
writeLogWrapInfo(
    VOID
    )
/*++

Routine Description:

    Write log file wrap info into log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    SYSTEMTIME  systemTime;
    DWORD       seconds;
    CHAR        sztime[50];

    //
    //  get time of log wrap
    //

    GetLocalTime( &systemTime );
    seconds = GetCurrentTimeInSeconds();

    Dns_WriteFormattedSystemTimeToBuffer(
        sztime,
        & systemTime );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "Log file wrap at %s\n",
            sztime );
}



VOID
writeMessageInfoHeader(
    VOID
    )
/*++

Routine Description:

    Write message logging key to log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "\nMessage logging key:\n"
            "\tField #  Information         Values\n"
            "\t-------  -----------         ------\n"
            "\t   1     Remote IP\n"
            "\t   2     Xid (hex)\n"
            "\t   3     Query/Response      R = Response\n"
            "\t                             blank = Query\n"
            "\t   4     Opcode              Q = Standard Query\n"
            "\t                             N = Notify\n"
            "\t                             U = Update\n"
            "\t                             ? = Unknown\n"
            "\t   5     [ Flags (hex)\n"
            "\t   6     Flags (char codes)  A = Authoritative Answer\n"
            "\t                             T = Truncated Response\n"
            "\t                             D = Recursion Desired\n"
            "\t                             R = Recursion Available\n"
            "\t   7     ResponseCode ]\n"
            "\t   8     Question Name\n\n" );
}



VOID
logPrefix(
    LPSTR       pszLogLevel
    )
/*++

Routine Description:

    Write message logging key to log.

Arguments:

    pszLogLevel -- string representation of log level

Return Value:

    None.

--*/
{
    SYSTEMTIME      st;

    GetLocalTime( &st );

    if ( pszLogLevel )
    {
        LogBuffer.pchCurrent += sprintf(
                                    LogBuffer.pchCurrent,
                                    "%02d:%02d:%02d %03X %-7s ",
                                    ( int ) st.wHour,
                                    ( int ) st.wMinute,
                                    ( int ) st.wSecond,
                                    GetCurrentThreadId(),
                                    pszLogLevel );
    }
    else
    {
        LogBuffer.pchCurrent += sprintf(
                                    LogBuffer.pchCurrent,
                                    "%02d:%02d:%02d %03X ",
                                    ( int ) st.wHour,
                                    ( int ) st.wMinute,
                                    ( int ) st.wSecond,
                                    GetCurrentThreadId() );
    }
}   //  logPrefix



//
//  Public logging routines
//


BOOL
Log_EnterLock(
    VOID
    )
/*++

Routine Description:

    Enter the logging lock and perform housekeeping tasks such as
    log wrap and write-through.

Arguments:

    None.

Return Value:

    Returns FALSE if logging is disabled -> caller should not log anything
    and should not try to unlock the log.

--*/
{
    if ( LOG_DISABLED() )
    {
        return FALSE;
    }

    LOCK_LOG();

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_LOG_MESSAGE_LENGTH )
    {
        writeAndResetLogBuffer();
    }

    return TRUE;
}   //  Log_EnterLock


VOID
Log_LeaveLock(
    VOID
    )
/*++

Routine Description:

    Leave the logging lock and perform housekeeping tasks such as
    log wrap and write-through.

    The caller must have called Log_EnterLock previously (and Log_EnterLock
    must have returned TRUE).

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH ||
         SrvCfg_dwOperationsLogLevel & DNSLOG_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
}   //  Log_LeaveLock


VOID
Log_Message(
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fSend,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Log the DNS message.

Arguments:

    pMsg - message received to process

Return Value:

    None

--*/
{
    DWORD           flag;
    CHAR            szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    //
    //  check if loggable message
    //      - send\recv
    //      - TCP\UDP
    //      - answer\question
    //      - logging this OPCODE
    //

    if ( !fForce )
    {
        flag = fSend ? DNS_LOG_LEVEL_SEND : DNS_LOG_LEVEL_RECV;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
        flag = pMsg->fTcp ? DNS_LOG_LEVEL_TCP : DNS_LOG_LEVEL_UDP;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
        flag = pMsg->Head.IsResponse ? DNS_LOG_LEVEL_ANSWERS : DNS_LOG_LEVEL_QUESTIONS;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }

        flag = 1 << pMsg->Head.Opcode;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
    }

    //
    //  Check this packet's remote IP address against the log filter list.
    //
    
    if ( SrvCfg_aipLogFilterList &&
         !DnsAddrArray_ContainsAddr(
            SrvCfg_aipLogFilterList,
            &pMsg->RemoteAddr,
            0 ) )                       //  match flag
    {
        return;
    }

    if ( !Log_EnterLock() )
    {
        return;
    }

    //
    //  print packet info
    //
    //  note, essentially two choices, build outside lock and
    //  copy or build inside lock;  i believe the later while
    //  causing more contention, will have less overhead
    //

    logPrefix( "PACKET" );

    DnsAddr_WriteIpString_A( szaddr, &pMsg->RemoteAddr );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "%s %s %-15s %04x %c %c [%04x %c%c%c%c %8s] ",
            pMsg->fTcp ? "TCP" : "UDP",
            fSend ? "Snd" : "Rcv",
            szaddr,
            pMsg->Head.Xid,
            pMsg->Head.IsResponse            ? 'R' : ' ',
            Dns_OpcodeCharacter( pMsg->Head.Opcode ),
            DNSMSG_FLAGS(pMsg),
            pMsg->Head.Authoritative         ? 'A' : ' ',
            pMsg->Head.Truncation            ? 'T' : ' ',
            pMsg->Head.RecursionDesired      ? 'D' : ' ',
            pMsg->Head.RecursionAvailable    ? 'R' : ' ',
            Dns_ResponseCodeString( pMsg->Head.ResponseCode ) );

    //
    //  write question name
    //      - then append newline
    //  NOTE: this isn't so good for update packets (this is the zone name)
    //

    Dns_WritePacketNameToBuffer(
        LogBuffer.pchCurrent,
        & LogBuffer.pchCurrent,
        pMsg->MessageBody,
        DNS_HEADER_PTR( pMsg ),
        DNSMSG_END( pMsg ) );

    ASSERT( *LogBuffer.pchCurrent == 0 );
    *LogBuffer.pchCurrent++ = '\r';
    *LogBuffer.pchCurrent++ = '\n';

    //
    //  full message write?
    //

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_FULL_PACKETS )
    {
        Print_DnsMessage(
            Log_PrintRoutine,
            NULL,       // no print context
            NULL,
            pMsg );
    }
    else
    {
        *LogBuffer.pchCurrent++ = '\r';
        *LogBuffer.pchCurrent++ = '\n';
    }

    Log_LeaveLock();

    return;
}




VOID
Log_DsWrite(
    IN      LPWSTR          pwszNodeDN,
    IN      BOOL            fAdd,
    IN      DWORD           dwRecordCount,
    IN      PDS_RECORD      pRecord
    )
/*++

Routine Description:

    Log a DS write.

Arguments:

    pwszNodeDN       -- DS DN write is at

    fAdd            -- TRUE if add, FALSE for modify

    dwRecordCount   -- count of records written

    pRecord         -- last (highest type) record written

Return Value:

    None

--*/
{
    IF_NOT_DNSLOG( DSWRITE )
    {
        return;
    }

    DNSLOG( DSWRITE, (
        "%s: %S\n"
        LOG_INDENT "records =        %d\n"
        LOG_INDENT "highest type =   %s\n"
        LOG_INDENT "serial number =  %lu\n",
        fAdd ? "Add" : "Mod",
        pwszNodeDN,
        dwRecordCount,
        pRecord->wType
            ? Dns_RecordStringForType( pRecord->wType )
            : "TOMBSTONE",
        pRecord->dwSerial ));
}



VOID
Log_vsprint(
    IN      LPSTR           Format,
    IN      va_list         ArgList
    )
/*++

Routine Description:

    Log printf.

Arguments:

    Format -- standard C format string

    ArgList -- argument list from variable args print function

Return Value:

    None.

--*/
{
    #if DBG
    PCHAR       pszstart = LogBuffer.pchCurrent;
    #endif
    
    if ( !Log_EnterLock() )
    {
        return;
    }

    LogBuffer.pchCurrent += vsprintf(
                                LogBuffer.pchCurrent,
                                Format,
                                ArgList );

    #if DBG

    //
    //  Echo log to debug log.
    //

    DNS_DEBUG( ANY, (
        "%.*s",
        ( LogBuffer.pchCurrent - pszstart ),
        pszstart ));

    #endif

    Log_LeaveLock();
}



VOID
Log_PrintRoutine(
    IN      PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Log routine matching signature of PRINT_ROUTINE.

    This allows this routine to be passed to print routines
    for standard types.

Arguments:

    pPrintContext -- dummy, need in signature to allow printing
        to this function from standard library print routines

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    va_start( arglist, Format );

    Log_vsprint( Format, arglist );

    va_end( arglist );
}



VOID
Log_Printf(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Log printf.

Arguments:

    LogLevel -- string representation of log level

    Format -- standard C printf format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    logPrefix( g_pszCurrentLogLevelString );

    va_start( arglist, Format );
    Log_vsprint( Format, arglist );
    va_end( arglist );
}



VOID
Log_SocketFailure(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pSocket,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Log some socket problem.

Arguments:

    pszHeader -- descriptive message

    pSocket -- ptr to socket info

Return Value:

    None.

--*/
{
    CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    DnsAddr_WriteIpString_A( szaddr, &pSocket->ipAddr );

    Log_Printf(
        "%s"
        " status=%d, socket=%d, pcon=%p, state=%d, IP=%s\n",
        pszHeader,
        Status,
        ( INT ) pSocket->Socket,
        pSocket,
        pSocket->State,
        szaddr );
}



void
massageLogFile(
    LPWSTR          pwszFilePath )
/*++

Routine Description:

    This routine examines the current log file name and allocates a
    new "massaged" version. We assume that the working directory of the
    server is %SystemRoot%\system32. This function also allocates a new
    directory string for the log file, to be used in free space checks.

    If the file name contains no "\", we must prepend "dns\" to it
    because all relatives paths are from %SystemRoot%\system32 and if
    there is no "\" we assume the admin wants the log file to go in
    the DNS server directory.

    If the file name contains a "\" but is not an absolute path,
    we must prepend "%SystemRoot%\" to it because we want relative paths to
    be relative to %SystemRoot%, not to %SystemRoot%\system32. This
    is from Levon's spec.

    If the file name is an absolute path, allocate a direct copy of it.

    How do we know if the path is an absolute or relative path? Good
    question! Let's assume it's an absolute path if it starts with
    "\\" (two backslashes) or it contains ":\" (colon backslash).

Arguments:

    pwszFilePath -- the input log file name

Return Value:

    None.

--*/
{
    LPWSTR      pwszNewFilePath = NULL;
    LPWSTR      pwszNewFileDrive = NULL;

    if ( pwszFilePath == NULL || *pwszFilePath == L'\0' )
    {
        //
        //  The log file path is empty or NULL so use the default.
        //

        pwszFilePath = LOG_FILE_PATH;
    }
    
    if ( wcsncmp( pwszFilePath, L"\\\\", 2 ) == 0 ||
        wcsstr( pwszFilePath, L":\\" ) != NULL )
    {
        //
        //  The path is an absolute path so we don't need to massage it.
        //

        pwszNewFilePath = Dns_StringCopyAllocate_W( pwszFilePath, 0 );
        IF_NOMEM( !pwszNewFilePath )
        {
            goto Done;
        }
    }
    else 
    {
        //
        //  The path is a relative path in one of these categories:
        //  Starts with a backslash:
        //      - relative to root of SystemRoot drive
        //  Contains a backslash:
        //      - relative to SystemRoot
        //  Contains no backslash:
        //      - relative to SystemRoot\system32\dns
        //

        LPWSTR      pwszSysRoot = _wgetenv( L"SystemRoot" );

        if ( pwszSysRoot == NULL )
        {
            //
            //  This is unlikely but PREFIX requires a test. If no SystemRoot
            //  stick the file in the root of the current drive.
            //

            pwszSysRoot = L"\\"; 
        }

        if ( *pwszFilePath == L'\\' )
        {
            //
            //  Starts with backslash - grab the drive letter of SystemRoot.
            //

            pwszNewFilePath = ALLOCATE_HEAP(
                                sizeof( WCHAR ) *
                                ( 10 + wcslen( pwszFilePath ) ) );
            if ( !pwszNewFilePath )
            {
                goto Done;
            }

            wcsncpy( pwszNewFilePath, pwszSysRoot, 2 );
            wcscpy( pwszNewFilePath + 2, pwszFilePath );
        } 
        else 
        {
            //
            //  No backslash:       SystemRoot\system32\dns\FILEPATH, or
            //  has one backslash:  SystemRoot\FILEPATH
            //

            pwszNewFilePath = ALLOCATE_HEAP(
                                sizeof( WCHAR ) *
                                ( wcslen( pwszSysRoot ) +
                                    wcslen( pwszFilePath ) + 40 ) );
            if ( !pwszNewFilePath )
            {
                goto Done;
            }

            wcscpy( pwszNewFilePath, pwszSysRoot );
            if ( wcschr( pwszFilePath, L'\\' ) == NULL )
            {
                wcscat( pwszNewFilePath, L"\\system32\\dns" );
            }
            wcscat( pwszNewFilePath, L"\\" );
            wcscat( pwszNewFilePath, pwszFilePath );
        }
    }

    //
    //  Pull out a directory name appropriate to pass to GetDriveSpaceEx()
    //  by removing everything after the final backslash.
    //

    if ( pwszNewFilePath )
    {
        LPWSTR  pwszSlash = wcschr( pwszNewFilePath, L'\\' );

        if ( pwszSlash )
        {
            pwszNewFileDrive = Dns_StringCopyAllocate_W( pwszNewFilePath, 0 );
            IF_NOMEM( !pwszNewFileDrive )
            {
                goto Done;
            }
            
            pwszSlash = wcsrchr( pwszNewFileDrive, L'\\' );
            if ( pwszSlash )
            {
                *( pwszSlash + 1 ) = 0;
            }
        }
    }

    Done:

    //
    //  Set globals.
    //

    g_pwszLogFileName = pwszNewFilePath;
    g_pwszLogFileDrive = pwszNewFileDrive;
}   //  massageLogFile



void
regenerateBackupExclusionKey(
    void
    )
/*++

Routine Description:

    To prevent backup tools from attempting to back up our log files we
    must write the name of the current log file and the name of the
    backup log file to the registry.

    Note: if the key does not already exist, this function will silently
    error and do nothing. It's not our place to create the key if it
    does not exist.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "regenerateBackupExclusionKey" )

    LONG    rc = 0;
    HKEY    hkey = 0;
    PWSTR   pwszData = 0;
    DWORD   cbData;
    PWSTR   pwszlogFileName = g_pwszLogFileName;

    if ( !pwszlogFileName )
    {
        goto Done;
    }
    
    //
    //  Allocate memory for registry value: buffer of NULL-terminated
    //  strings terminated by another NULL (double NULL at end).
    //

    cbData = ( wcslen( DNS_BACKUP_LOG_BACK_FILE ) + 1 +
               wcslen( pwszlogFileName ) + 1
               + 1 ) *      //  for final NULL
             sizeof( WCHAR );
    pwszData = ALLOCATE_HEAP( cbData );
    if ( pwszData == NULL )
    {
        rc = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    wsprintfW(
        pwszData,
        TEXT( "%s%c%s%c" ),
        DNS_BACKUP_LOG_BACK_FILE,
        0,
        pwszlogFileName,
        0 );

    //
    //  Open the backup key.
    //

    rc = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_BACKUP_KEY_NAME,
                0,
                KEY_WRITE,
                &hkey );
    if ( rc != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ( "%s: rc=%lu from RegOpenKey\n", fn, rc ));
        goto Done;
    }

    //
    //  Set our exclusion value.
    //

    rc = RegSetValueExW(
                hkey,
                DNS_BACKUP_VALUE_NAME,
                0,
                REG_MULTI_SZ,
                ( PBYTE ) pwszData,
                cbData );
    if ( rc != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ( "%s: rc=%lu from RegSetValue\n", fn, rc ));
        goto Done;
    }

    //
    //  Cleanup and return
    //

    Done:

    FREE_HEAP( pwszData );
    if ( hkey )
    {
        RegCloseKey( hkey );
    }
    
    DNS_DEBUG( INIT, (
        "%s: rc=%lu writing key\n  HKLM\\%S\n", fn,
        rc,
        DNS_BACKUP_KEY_NAME ));

    return;
}   //  regenerateBackupExclusionKey



PCHAR
Log_FormatPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PBYTE           pPacketName
    )
/*++

Routine Description:

    This routine dumps a packet name into a dynamically allocated
    output buffer.

Arguments:

    pMsg -- DNS message packet that holds the name
    
    pPacketName -- name within pMsg to be formatted for output
    
Return Value:

    Allocated output buffer. Caller must free with FREE_HEAP().

--*/
{
    PCHAR   pszbuffer = ALLOCATE_HEAP( 2 * DNS_MAX_NAME_LENGTH + 2 );

    if ( !pszbuffer )
    {
        goto Done;
    }

    Dns_WritePacketNameToBuffer(
                    pszbuffer,
                    NULL,
                    pPacketName,
                    &pMsg->Head,
                    DNSMSG_END( pMsg ) );
    
    Done:
    
    return pszbuffer;
}   //  Log_FormatPacketName



PCHAR
Log_FormatNodeName(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    This routine dumps the FQDN of a node into a dynamically allocated
    output buffer.

Arguments:

    pNode -- node whose name will be printed to buffer
    
Return Value:

    Allocated output buffer. Caller must free with FREE_HEAP().

--*/
{
    PCHAR   pszbuffer = ALLOCATE_HEAP( 2 * DNS_MAX_NAME_LENGTH + 2 );

    if ( !pszbuffer )
    {
        goto Done;
    }

    if ( !pNode )
    {
        pszbuffer[ 0 ] = '.';
        pszbuffer[ 1 ] = '\0';
        goto Done;
    }

    Name_PlaceNodeNameInBuffer(
                pszbuffer,
                pszbuffer + 2 * DNS_MAX_NAME_LENGTH,
                pNode,
                NULL );         //  stop node
    
    Done:
    
    return pszbuffer;
}   //  Log_FormatPacketName



PCHAR
Log_CurrentSection(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    This routine returns a pointer the name of the current
    section of the message (answer, authority, etc). The returned
    pointer is a static string.

Arguments:

    pMsg -- DNS message
    
Return Value:

    Returns pointer to current section name of pMsg.

--*/
{
    static PCHAR pszQuerySections[] =
        {
        "question",
        "answer",
        "authority",
        "additional",
        "INVALID SECTION"
        };
    
    static PCHAR pszUpdateSections[] =
        {
        "zone",
        "prereq",
        "update",
        "additional",
        "INVALID SECTION"
        };
    
    PCHAR * pszarray = ( pMsg->Head.Opcode == DNS_OPCODE_UPDATE )
                            ? pszUpdateSections
                            : pszQuerySections;

    if ( pMsg->Section >=0 && pMsg->Section < 5 )
    {
        return pszarray[ pMsg->Section ];
    }
    return pszarray[ 4 ];       //  error string
}   //  Log_CurrentSection



DNS_STATUS
Log_InitializeLogging(
    BOOL        fAlreadyLocked
    )
/*++

Routine Description:

    Initialize logging.

    This routine can be called in three scenario:

    1) On server startup
    2) On continuation, from writeAndResetLogBuffer()
    3) From the config module, when the SrvCfg_pwsLogFilePath is changed

Arguments:

    fAlreadyLocked: if FALSE, this function will acquire the log lock
        before touching any globals, and will release the lock before
        returning, if TRUE then the caller already has the lock

Return Value:

    Error code from file open/move operation or ERROR_SUCCESS.

--*/
{
    BOOL            fUnlockOnExit = FALSE;
    DNS_STATUS      status = ERROR_SUCCESS;

    //
    //  On the first call to this function, initialize module globals.
    //

    if ( !fLogCsInit )
    {
        status = DnsInitializeCriticalSection( &csLogLock );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        fLogCsInit = TRUE;
        LOCK_LOG();
        fUnlockOnExit = TRUE;
    }
    else if ( !fAlreadyLocked )
    {
        LOCK_LOG();
        fUnlockOnExit = TRUE;
    }

    if ( hLogFile )
    {
        CloseHandle( hLogFile );
        hLogFile = NULL;
    }

    //
    //  Move any existing file to backup directory. 
    //

    if ( g_pwszLogFileName )
    {
        if ( MoveFileEx(
                g_pwszLogFileName,
                LOG_FILE_BACKUP_PATH,
                MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ) == 0 )
        {
            DNS_PRINT((
                "ERROR: failed back up log file %S to %S\n"
                "\tstatus = %d\n",
                g_pwszLogFileName,
                LOG_FILE_BACKUP_PATH,
                GetLastError() ));
            //
            //  Losing the backup file is not life-threatening, so don't bother
            //  to log an event or notify the admin. More hassle than it's worth.
            //
        }
    }
    Timeout_Free( g_pwszLogFileName );
    g_pwszLogFileName = NULL;
    Timeout_Free( g_pwszLogFileDrive );
    g_pwszLogFileDrive = NULL;

    //
    //  Take the SrvCfg input log file path and turn it into a "real"
    //  file path that we can open. Note: we re-massage the log file
    //  every time even if the global file path has not changed. This
    //  is inefficient but it should be performed that often so don't
    //  worry about it.
    //

    massageLogFile( SrvCfg_pwsLogFilePath );

    //
    //  Rewrite log file exclusion key.
    //

    regenerateBackupExclusionKey();

    //
    //  Open log file
    //

    hLogFile = OpenWriteFileEx(
                    g_pwszLogFileName,
                    FALSE           // overwrite
                    );
    if ( !hLogFile )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR: failed to open log file %S\n"
            "\tstatus = %d\n",
            g_pwszLogFileName,
            status ));

        //
        //  Why does this function return ERROR_IO_PENDING? Not helpful!
        //  

        if ( status == ERROR_IO_PENDING )
        {
            status = ERROR_FILE_NOT_FOUND;
        }
        goto Cleanup;
    }

    //  set\reset buffer globals

    RtlZeroMemory(
        & LogBuffer,
        sizeof(BUFFER) );

    InitializeFileBuffer(
        & LogBuffer,
        pchLogBuffer,
        LOG_BUFFER_LENGTH,
        hLogFile );

#if 0
    // this doesn't set end of buffer properly
    LogBuffer.pchStart  = pchLogBuffer;
    LogBuffer.cchLength = LOG_BUFFER_LENGTH;

    RESET_BUFFER( &LogBuffer );
#endif

    BytesWrittenToLog = 0;


    //  write basic info
    //
    //  DEVNOTE: could write log encoding message
    //

    if ( SrvCfg_fStarted )
    {
        writeLogBootInfo();
        writeLogWrapInfo();
        writeMessageInfoHeader();
    }
    else
    {
        writeLogBootInfo();
        writeMessageInfoHeader();
    }

    DNS_DEBUG( INIT, (
        "Initialized logging:  level = %p\n"
        "\thandle %p\n",
        SrvCfg_dwLogLevel,
        hLogFile ));

    Cleanup:

    #if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "error %d setting log file to %S\n",
            status,
            SrvCfg_pwsLogFilePath ));
    }
    #endif

    if ( fUnlockOnExit )
    {
        UNLOCK_LOG();
    }
    return status;
}



VOID
Log_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown logging.

    Mostly just get rid of globals, since the heap will soon be destroyed, 
    and if we keep pointers global pointers around they will be invalid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  Final log processing.
    //

    Log_PushToDisk();

    if ( hLogFile )
    {
        CloseHandle( hLogFile );
        hLogFile = NULL;
    }

    //
    //  Cleanup globals.
    //

    g_pwszLogFileName = NULL;
    g_pwszLogFileDrive = NULL;
    g_fLastLogWasDiskFullMsg = FALSE;
}   //  Log_Shutdown



VOID
Log_PushToDisk(
    VOID
    )
/*++

Routine Description:

    Push buffered log data to disk.

    This is simply the safe, locking version of the private
    writeAndResetLogBuffer() routine.
    It is specifically designed to be called at shutdown but can
    be called by any random thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( LOG_DISABLED() )
    {
        return;
    }

    LOCK_LOG();

    writeAndResetLogBuffer();

    UNLOCK_LOG();
}


//
//  End of log.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\memory.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Server

    Memory routines for DNS.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Handle to DNS server heap
//

HANDLE  hDnsHeap;

//
//  Allocation failure
//

DWORD       g_dwLastAllocationFailureTime = 0;
ULONG       g_AllocFailureCount = 0;
ULONG       g_AllocFailureLogTime = 0;

#define ALLOC_FAILURE_LOG_INTERVAL      (900)       // 15 minutes




//
//  Debug heap routines
//

#if DBG


//
//  Debug memory routines.
//


PVOID
reallocMemory(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMemory - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    //
    //  reallocate memory
    //

    pMemory = HeapDbgRealloc(
                hDnsHeap,
                0,
                pMemory,
                iSize,
                pszFile,
                LineNo );
    if ( !pMemory )
    {
        DNS_PRINT(( "ReAllocation of %d bytes failed\n", iSize ));
        HeapDbgGlobalInfoPrint();

        DNS_LOG_EVENT(
            DNS_EVENT_OUT_OF_MEMORY,
            0,
            NULL,
            NULL,
            0 );
        FAIL( "ReAllocation" );
        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
        
        return NULL;
    }

    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Reallocating %d bytes at %p to %p.\n"
            "    in %s line %d\n",
            iSize,
            pMemory,
            (PBYTE)pMemory + iSize,
            pszFile,
            LineNo
            ));
        HeapDbgGlobalInfoPrint();
    }

    //
    //  return ptr to first byte after header
    //

    return pMemory;
}



VOID
freeMemory(
    IN OUT  PVOID           pMemory,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by  MEMORY routines.

Arguments:

    pMemory    - ptr to memory to be freed

Return Value:

    None.

--*/
{
    if ( !pMemory )
    {
        return;
    }
    ASSERT( Mem_HeapMemoryValidate(pMemory) );

    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Free bytes at %p.\n"
            "    in %s line %d\n",
            pMemory,
            pszFile,
            LineNo ));
        HeapDbgGlobalInfoPrint();
    }

    //  free the memory

    HeapDbgFree(
        hDnsHeap,
        0,
        pMemory );

    MemoryStats.Memory = gCurrentAlloc;
    STAT_INC( MemoryStats.Free );
}



#else


//
//  Non-Debug DNS heap routines.
//

DWORD   gCurrentAlloc;


PVOID
reallocMemory(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMemory - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PVOID   pnew;

    //
    //  reallocate memory
    //

    pnew = RtlReAllocateHeap( hDnsHeap, 0, pMemory, iSize );
    if ( !pnew )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_OUT_OF_MEMORY,
            0,
            NULL,
            NULL,
            GetLastError()
            );
        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
    }

    return pnew;
}



VOID
freeMemory(
    IN OUT  PVOID           pMemory,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Frees memory.

Arguments:

    pMemory - ptr to memory to be freed

Return Value:

    None.

--*/
{
    if ( !pMemory )
    {
        return;
    }
    RtlFreeHeap( hDnsHeap, 0, pMemory );


    STAT_INC( MemoryStats.Free );
}

#endif  // no-debug



PVOID
allocMemory(
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PVOID  palloc;
    DWORD           failureCount = 0;


    //
    //  allocate memory
    //
    //  operate in loop as we'll wait on the allocation failure case
    //

    do
    {
#if DBG
        palloc = HeapDbgAlloc(
                    hDnsHeap,
                    0,
                    iSize,
                    pszFile,
                    LineNo
                    );
#else
        palloc = RtlAllocateHeap(
                    hDnsHeap,
                    0,
                    iSize );
#endif
        if ( palloc )
        {
            break;
        }

        //
        //  allocation failure
        //      - debug log, but only on first pass
        //      - log event
        //      but only on first pass AND
        //      MUST be sure eventlogging doesn't require allocation or
        //      we can overflow stack in mutual recursion;
        //      (currently event buffer comes from LocalAllow() through
        //      FormatMessage and so is not a problem)
        //

        DNS_PRINT(( "Allocation of %d bytes failed\n", iSize ));

        g_AllocFailureCount++;
        g_dwLastAllocationFailureTime = UPDATE_DNS_TIME();

        if ( failureCount == 0 )
        {
            HeapDbgGlobalInfoPrint();

            //  It would be cool to print out stats here but printing stats
            //  requires allocations, and if allocations are failing we will
            //  end up in infinite recursion!
            //  Dbg_Statistics();

            //  ASSERT( FALSE );

            if ( g_AllocFailureLogTime == 0 ||
                g_AllocFailureLogTime + ALLOC_FAILURE_LOG_INTERVAL < DNS_TIME() )
            {
                //  put this before logging to kill off possibility of
                //  mutual recursion stack overflow with event log allocation

                g_AllocFailureLogTime = DNS_TIME();

                DNS_LOG_EVENT(
                    DNS_EVENT_OUT_OF_MEMORY,
                    0,
                    NULL,
                    NULL,
                    GetLastError() );
            }
        }

#if 0
        //  DEVNOTE: RaiseException on memory failure
        //      once have server restart, should raise exception
        //      if
        //          - fail several times \ for a certain time
        //          - DNS server memory is THE problem (is huge)

        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
#endif

        //
        //  if shutting down server -- bail!
        //      ExitThread to avoid any possible AV going back up stack

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread.\n" ));
            ExitThread( 0 );
        }

        //
        //  otherwise sleep briefly
        //      - start small (100 ms) to allow fast recovery from transient
        //      - but wait with long interval (3s) to avoid CPU load
        //

        if ( failureCount++ < 50 )
        {
            Sleep( 100 );
        }
        else
        {
            Sleep( 3000 );
        }

    }
    while ( 1 );


    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Allocating %d bytes at %p to %p\n"
            "    in %s line %d\n",
            iSize,
            palloc,
            (PBYTE)palloc + iSize,
            pszFile,
            LineNo
            ));
        HeapDbgGlobalInfoPrint();
    }

    //
    //  return ptr to first byte after header
    //

#if DBG
    MemoryStats.Memory = gCurrentAlloc;
#endif
    STAT_INC( MemoryStats.Alloc );

    return palloc;
}



//
//  Standard record and node allocation
//
//  Almost all RR are the same size in the database -- DWORD of data.
//  This covers A, and all the single indirection records:  NS, PTR, CNAME,
//  etc.
//
//  To make this more efficient, we allocate these standard sized records
//  in larger blocks and keep a free list.
//
//  Advantages:
//      - save space that otherwise goes to heap info in each RR
//      - speedier than going to heap
//
//
//  Standard allocations available of various commonly used sizes.
//  Free list head points at first allocation.
//  First field in each allocation points at next element of free list.
//



//
//  Header on standard allocs
//
//  This preceeds all standard alloc blocks to save allocation info
//  -- size, which list, alloc tag -- outside purview of users memory.
//
//  Since all allocations DWORD aligned, store size with last three bits
//  chopped off.  If the complier's smart enough it doesn't even have to
//  shift -- just mask.
//

struct _DnsFreeBlock;

typedef struct _DnsMemoryHeader
{
#ifdef _WIN64
    DWORD                       Boundary64;
#endif
    UCHAR                       Boundary;
    BYTE                        Tag;
    WORD                        Size;
    struct _DnsFreeBlock *      pNextFree;
}
MEMHEAD, *PMEMHEAD;

#define SIZEOF_MEMHEAD      sizeof( MEMHEAD )

#ifdef _WIN64
#define MEMHEAD_IN_USE_NEXT_PTR ( ( PVOID ) ( UINT_PTR )  ( 0xFF0C0C0C0C0C0C0C ) )
#define FREE_BLOCK_TAG          ( ( PVOID ) ( UINT_PTR )  ( 0xFF0B0BFFFF0B0BFF ) )
#else
#define MEMHEAD_IN_USE_NEXT_PTR ( ( PVOID ) ( DWORD_PTR ) ( 0xFF0B0BFF ) )
#define FREE_BLOCK_TAG          ( ( PVOID ) ( DWORD_PTR ) ( 0xFF0B0BFF ) )
#endif


//
//  User memory <-> MEMHEAD conversions
//

#define RECOVER_MEMHEAD_FROM_USER_MEM( pMem )     ( ( PMEMHEAD )( pMem ) - 1 )
#define RECOVER_USER_MEM_FROM_MEMHEAD( pMem )     ( ( PBYTE ) ( ( PMEMHEAD )( pMem ) + 1 ) )


//
//  Trailer on standard allocs
//

typedef struct _DnsMemoryTrailer
{
    DWORD   Tail;
#ifdef _WIN64
    DWORD   Boundary64;
#endif
}
MEMTAIL, *PMEMTAIL;


//
//  Size field will be overlay of size and standard alloc index
//
//  Since allocs are DWORD aligned, we have two bits, that are essentially
//  unused in size field.  We use these to write index to low 2 bits.
//  The only caveat here is that heap allocations must always be rounded up
//  to nearest DWORD, so that there is no confusion for allocation at
//  boundary of standard allocs and heap (i.e. heap allocs must always have
//  a size greater than max standard alloc, excluding trailing bits)
//
//  We'll do this rounding up in ALL heap allocs effectively leaving
//  heap "index" zero.
//

#define MEM_MAX_SIZE        (0xfffc)

#define MEM_SIZE_MASK       (0xfffc)
#define MEM_INDEX_MASK      (0x0003)

#define RECOVER_MEM_SIZE( pBlock )  ( ( ( pBlock )->Size ) & MEM_SIZE_MASK )

#define RECOVER_MEM_INDEX( pBlock)  ( ( ( pBlock )->Size) & MEM_INDEX_MASK )

#define HEAP_INDEX                  (0)

//  alloc boundary tags

#define BOUNDARY_64         (0x64646464)
#define BOUNDARY_ACTIVE     (0xbb)
#define BOUNDARY_FREE       (0xee)

//
//  Free list
//
//  Note low 0xff is specifically set to break the RANK field of
//  a record.  With this tag the rank becomes 0xff -- the highest
//  possible rank, yet not a zone rank.  This immediately causes
//  failures.
//

typedef struct _DnsFreeBlock
{
    MEMHEAD                 MemHead;
    PVOID                   FreeTag;
}
FREE_BLOCK, *PFREE_BLOCK;



//
//  Standard allocation lists
//

typedef struct _DnsStandardRecordList
{
    PFREE_BLOCK         pFreeList;
    DWORD               Index;
    DWORD               Size;
    DWORD               AllocBlockCount;
    DWORD               FreeCount;
    DWORD               HeapAllocs;
    DWORD               TotalCount;
    DWORD               UsedCount;
    DWORD               ReturnCount;
    DWORD               Memory;
    CRITICAL_SECTION    Lock;
}
STANDARD_ALLOC_LIST, *PSTANDARD_ALLOC_LIST;

//
//  Handle several different standard sizes
//      A records       -- the 95% case A
//      small names     -- NS, PTR, CNAME possibly MX;  update blocks
//      NODE            -- standard size domain node, some SOA records
//      big NODE        -- large label, almost all SOA
//
//  Note:  these sizes MUST be appropriately aligned for both 32 and
//      64 bit implementations
//
//  Currently
//      RR fixed    = 16 (32bit), 20 (64bit)
//      RR A        = 20 (32bit), 24 (64bit)
//      Update      = 24 (32bit), 40 (64bit)
//      Node        = 64 (32bit), 96 (64bit)
//
//  Sizes:
//      32-bit:     20, 44, 64, 88
//      64-bit:     24, 48, 96, 120
//
//  Sizes with memhead:
//      32-bit:     24, 48, 68, 92
//      64-bit:     32, 56, 104, 128
//
//  Note, there is some unnecessary wastage here for 64-bit.  Should
//  have block starts 64-aligned, BUT instead of wasting the leading DWORD
//  should use it also -- then offset by DWORD only on original alloc.
//  The sizes with MEMHEAD stay the same, but the useful space
//  increases by 4bytes.
//


#define ROUND_PTR(x) (((ULONG)(x) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))

#define SIZE1   ROUND_PTR(SIZEOF_DBASE_RR_FIXED_PART + SIZEOF_IP_ADDRESS)
#define SIZE2   ROUND_PTR(SIZEOF_DBASE_RR_FIXED_PART + 28)
#define SIZE3   ROUND_PTR(sizeof(DB_NODE))
#define SIZE4   ROUND_PTR(sizeof(DB_NODE) + 24)

//  Actual sizes of blocks

#define BLOCKSIZE1  (SIZEOF_MEMHEAD + SIZE1)
#define BLOCKSIZE2  (SIZEOF_MEMHEAD + SIZE2)
#define BLOCKSIZE3  (SIZEOF_MEMHEAD + SIZE3)
#define BLOCKSIZE4  (SIZEOF_MEMHEAD + SIZE4)

C_ASSERT((BLOCKSIZE1 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE2 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE3 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE4 % sizeof(PVOID)) == 0);

#define SIZEOF_MAX_STANDARD_ALLOC   BLOCKSIZE4

//  alloc all sizes in roughly page based clumps

#define PAGE_SIZE   (0x1000)            // 4K

#define COUNT1  (PAGE_SIZE / BLOCKSIZE1)
#define COUNT2  (PAGE_SIZE / BLOCKSIZE2)
#define COUNT3  (PAGE_SIZE / BLOCKSIZE3)
#define COUNT4  (PAGE_SIZE / BLOCKSIZE4)

//
//  Table of standard block info
//

#define MEM_MAX_INDEX           (3)
#define STANDARD_BLOCK_COUNT    (4)

STANDARD_ALLOC_LIST     StandardAllocLists[] =
{
    { NULL, 0,  BLOCKSIZE1, COUNT1, 0,  0,  0,  0,  0,  0 },
    { NULL, 1,  BLOCKSIZE2, COUNT2, 0,  0,  0,  0,  0,  0 },
    { NULL, 2,  BLOCKSIZE3, COUNT3, 0,  0,  0,  0,  0,  0 },
    { NULL, 3,  BLOCKSIZE4, COUNT4, 0,  0,  0,  0,  0,  0 },
};

//
//  Each list individually locked (to minimize contention)
//

#define STANDARD_ALLOC_LOCK(plist)      EnterCriticalSection( &(plist)->Lock );
#define STANDARD_ALLOC_UNLOCK(plist)    LeaveCriticalSection( &(plist)->Lock );


//
//  For valid stats, need mem stats lock
//

#define MEM_STATS_LOCK()        GENERAL_SERVER_LOCK()
#define MEM_STATS_UNLOCK()      GENERAL_SERVER_UNLOCK()



#if DBG
BOOL
standardAllocFreeListValidate(
    IN      PSTANDARD_ALLOC_LIST    pList
    );
#else
#define standardAllocFreeListValidate(pList)    (TRUE)
#endif



#if DBG


BOOL
Mem_HeapMemoryValidate(
    IN      PVOID           pMemory
    )
/*++

Routine Description:

    Validate memory as being valid heap memory.

Arguments:

    pMemory -- ptr to heap memory

Return Value:

    TRUE if pMemory could be valid heap memory
    FALSE if pMemory definitely invalid

--*/
{
    PVOID       p;

    if ( (ULONG_PTR)pMemory & (sizeof(PVOID)-1) )
    {
        DNS_PRINT((
            "ERROR:  pMemory %p, not aligned.\n"
            "    Must be DWORD (Win32) or LONGLONG (Win64) aligned.\n",
            pMemory ));
        return FALSE;
    }

    return TRUE;
}



BOOL
Mem_HeapHeaderValidate(
    IN      PVOID           pMemory
    )
/*++

Routine Description:

    Validate heap headers and trailers.

Arguments:

    pMemory -- ptr to heap memory

Return Value:

    TRUE if headers appear to be valid.

--*/
{
    PVOID       p;

    if ( !Mem_HeapMemoryValidate( pMemory ) )
    {
        return FALSE;
    }

    p = ( PMEMHEAD ) pMemory - 1;
    HeapDbgValidateMemory( p, FALSE );

    return TRUE;
}


#endif



DWORD
Mem_GetTag(
    IN      PVOID           pMem
    )
/*++

Routine Description:

    Get tag associated with memory.

Arguments:

    pMem -- memory block to get tag for

Return Value:

    Tag

--*/
{
    PMEMHEAD    phead;

    phead = RECOVER_MEMHEAD_FROM_USER_MEM( pMem );

    return ( DWORD ) phead->Tag;
}



VOID
Mem_ResetTag(
    IN      PVOID           pMem,
    IN      DWORD           Tag
    )
/*++

Routine Description:

    Reset tag associated with a particular memory block.

    Note there is no protection here.  This is only safe
    when block is newly created by calling thread and
    not enlisted in any data structure where other threads
    may have access.

    The purpose of this function is to have a quicky workaround
    for applying detailed source tags to records, without
    changing code which currently creates the record.  Caller
    creates record through normal path where it receives a
    default tag -- then retags using this function.

Arguments:

    pMem -- memory block to reset tag on

    Tag -- new tag for block

Return Value:

    Tag

--*/
{
    PMEMHEAD    phead;
    BYTE        currentTag;
    WORD        size;

    phead = RECOVER_MEMHEAD_FROM_USER_MEM(pMem);

    //
    //  reset tag and tag stats
    //      - decrement count for current tag
    //      - increment count for new tag
    //      - reset tag in block
    //
    //  note:  this function only used for resetting record tags
    //      so expect a record tag
    //

    currentTag = phead->Tag;
    size = RECOVER_MEM_SIZE(phead);

    ASSERT( currentTag >= MEMTAG_RECORD_BASE );
    ASSERT( currentTag <= MEMTAG_NODE_MAX );

    STAT_DEC( MemoryStats.MemTags[ currentTag ].Alloc );
    STAT_SUB( MemoryStats.MemTags[ currentTag ].Memory, size );

    ASSERT( (INT)MemoryStats.MemTags[ currentTag ].Alloc >= 0 );
    ASSERT( (INT)MemoryStats.MemTags[ currentTag ].Memory >= 0 );

    STAT_INC( MemoryStats.MemTags[ Tag ].Alloc );
    STAT_ADD( MemoryStats.MemTags[ Tag ].Memory, size );

    phead->Tag = (BYTE) Tag;
}



PVOID
setAllocHeader(
    IN      PMEMHEAD        pMem,
    IN      DWORD           Index,
    IN      DWORD           Size,
    IN      DWORD           Tag
    )
/*++

Routine Description:

    Set standard memory header.

Arguments:

Return Value:

    Ptr to memory to return.

--*/
{
    ASSERT( Index <= MEM_MAX_INDEX );
    ASSERT( (Size & MEM_INDEX_MASK) == 0 );

    //  count allocation under its tag

    if ( Tag > MEMTAG_MAX )
    {
        ASSERT( Tag <= MEMTAG_MAX );
        Tag = 0;
    }

    MEM_STATS_LOCK();
    STAT_ADD( MemoryStats.Memory, Size );
    STAT_INC( MemoryStats.Alloc );

    //
    //  Note: if the DNS server has been up for a very long time these
    //  counters can wrap and appear bogus!
    //
    
    if ( MemoryStats.MemTags[ Tag ].Free > MemoryStats.MemTags[ Tag ].Alloc )
    {
        DNS_PRINT((
            "Tag %d with negative in-use count!\n"
            "    alloc = %d\n"
            "    free = %d\n",
            Tag,
            MemoryStats.MemTags[ Tag ].Alloc,
            MemoryStats.MemTags[ Tag ].Free ));
        ASSERT( FALSE );
    }
    if ( ( LONG ) MemoryStats.MemTags[ Tag ].Memory < 0 )
    {
        DNS_PRINT((
            "Tag %d with negative memory count = %d!\n",
            Tag,
            ( LONG ) MemoryStats.MemTags[ Tag ].Memory ));
        ASSERT( FALSE );
    }

    STAT_INC( MemoryStats.MemTags[ Tag ].Alloc );
    STAT_ADD( MemoryStats.MemTags[ Tag ].Memory, Size );

    MEM_STATS_UNLOCK();

    ASSERT( (Size & MEM_SIZE_MASK) == Size );

    //  write header
    //
    //  since allocs DWORD aligned, the last two bits can be used to
    //      overlay standard alloc index info to provide check
    //
    //  note that at boundary between standard and heap, heap allocs
    //      must be rounded up to size at least a DWORD greated than
    //      last standard alloc, to avoid confusion
    //

    pMem->Boundary  = BOUNDARY_ACTIVE;
    pMem->Tag       = (UCHAR) Tag;
    pMem->Size      = (WORD) Size | (WORD)(Index);
    pMem->pNextFree = MEMHEAD_IN_USE_NEXT_PTR;

    //
    //  Clear the free block tag. This block is no longer free.
    //
    
    ( ( PFREE_BLOCK ) pMem )->FreeTag = 0;

    DNS_DEBUG( HEAP2, (
        "Mem_Alloc() complete %p, size=%d, tag=%d, index=%d.\n",
        (PCHAR)pMem + SIZEOF_MEMHEAD,
        Size,
        Tag,
        Index ));

    return ( PCHAR ) pMem + SIZEOF_MEMHEAD;
}



BOOL
Mem_VerifyHeapBlock(
    IN      PVOID           pMem,
    IN      DWORD           dwTag,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Verify valid alloc header.

Arguments:

    pMem -- memory to validate

    dwTag -- required Tag value

    dwLength -- required Length value;  actually length must be >= to this value

Return Value:

    TRUE -- if pMem is valid DNS server heap block
    FALSE -- on error

--*/
{
    PMEMHEAD    pmemhead;
    DWORD       tag;
    DWORD       size;

    //  skip NULL ptrs

    if ( !pMem )
    {
        return TRUE;
    }

    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pmemhead = RECOVER_MEMHEAD_FROM_USER_MEM( pMem );

    if ( pmemhead->Boundary != BOUNDARY_ACTIVE )
    {
        ASSERT( pmemhead->Boundary == BOUNDARY_ACTIVE );
        return FALSE;
    }

    if ( pmemhead->pNextFree != MEMHEAD_IN_USE_NEXT_PTR )
    {
        ASSERT( pmemhead->pNextFree == MEMHEAD_IN_USE_NEXT_PTR );
        return FALSE;
    }

    tag = pmemhead->Tag;
    if ( dwTag && dwTag != tag )
    {
        DNS_PRINT((
            "ERROR:  invalid block tag on pMem = %p!\n"
            "    Expected tag value %d, pMem->Tag = %d\n",
            pMem,
            dwTag,
            tag ));
        ASSERT( !"block has invalid tag" );
        return FALSE;
    }

    //  check desired length fits in this block

    size = RECOVER_MEM_SIZE( pmemhead );
    size -= SIZEOF_MEMHEAD;

    if ( dwLength && dwLength > size )
    {
        DNS_PRINT((
            "ERROR:  invalid length on pMem = %p!\n"
            "    Expected length %d > pMem size = %d\n",
            pMem,
            dwLength,
            size ));
        ASSERT( !"block has invalid length" );
        return FALSE;
    }
    return TRUE;
}



PVOID
Mem_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Get a standard allocation.

    This keeps us from needing to hit heap, for common RR and node operations.
    AND saves overhead of heap fields on each RR.

    As optimization, assuming list locked by caller.

Arguments:

    Length -- length of allocation required.

Return Value:

    Ptr to memory of desired size, if successful.
    NULL on allocation failure.

--*/
{
    PSTANDARD_ALLOC_LIST    plist;
    PFREE_BLOCK             pnew;
    DWORD                   allocSize;
    DWORD                   size;
    DWORD                   i;

    DNS_DEBUG( HEAP2, (
        "Mem_Alloc( %d, tag=%d, %s line=%d )\n",
        Length,
        Tag,
        pszFile,
        LineNo ));

    //  add header to required length

    Length += SIZEOF_MEMHEAD;

    //
    //  non-standard size -- grab from heap
    //

    if ( Length > SIZEOF_MAX_STANDARD_ALLOC || SrvCfg_fTest7 )
    {
        pnew = allocMemory( (INT)Length, pszFile, LineNo );

        //  set header on new block
        //  then return user portion of block
        //  always report alloc length as nearest DWORD aligned

        if ( Length > MEM_MAX_SIZE )
        {
            Length = MEM_MAX_SIZE;
        }
        else if ( Length & MEM_INDEX_MASK )
        {
            Length &= MEM_SIZE_MASK;
            Length += sizeof(DWORD);
        }
        STAT_INC( MemoryStats.StdToHeapAlloc );
        STAT_ADD( MemoryStats.StdToHeapMemory, Length );

        pnew = setAllocHeader(
                    ( PMEMHEAD ) pnew,
                    HEAP_INDEX,
                    Length,
                    Tag );
        goto Done;
    }

    //
    //  check all standard sizes
    //  if desired length <= this standard size, then use it
    //

    plist = StandardAllocLists;
    while( 1 )
    {
        if ( Length <= plist->Size )
        {
            break;
        }
        plist++;
    }
    ASSERT( plist->Size >= Length );

    //
    //  found proper list
    //      - take list CS

    STANDARD_ALLOC_LOCK( plist );

    //
    //  no current entries in free list -- allocate another block
    //

    if ( !plist->pFreeList )
    {
        PFREE_BLOCK     pfirstBlock;
        PFREE_BLOCK     pnext;
        
        ASSERT( plist->FreeCount == 0 );

        //
        //  free list empty
        //      - grab another page (254 RR * 16bytes);  leaving 32 bytes for
        //          heap info
        //      - add all the RRs to the free list
        //

        size = plist->Size;
        allocSize = size * plist->AllocBlockCount;

        pfirstBlock = pnew = allocMemory( allocSize, pszFile, LineNo );
        IF_NOMEM( !pnew )
        {
            goto Done;
        }
        plist->Memory += allocSize;
        plist->HeapAllocs++;
        plist->TotalCount += plist->AllocBlockCount;
        plist->FreeCount += plist->AllocBlockCount;

        //
        //  cut memory into desired blocks and build free list
        //

        for ( i = 0; i < plist->AllocBlockCount; ++i )
        {
            if ( i )
            {
                pnew = pnext;
            }
            
            pnext = ( PFREE_BLOCK )( ( PBYTE ) pnew + size );

            pnew->MemHead.Boundary      = BOUNDARY_FREE;
            pnew->MemHead.Tag           = 0;
            pnew->MemHead.Size          = 0;
            pnew->MemHead.pNextFree     = pnext;
            pnew->FreeTag               = FREE_BLOCK_TAG;
        }

        //  attach new blocks to list
        //  last new RR points to existing free list (probably NULL)
        //      but not necessarily so since unlocked around alloc

        pnew->MemHead.pNextFree = plist->pFreeList;
        plist->pFreeList = pfirstBlock;
    }

    //
    //  Test if the block tag has been overwritten in the next free block.
    //  If so then leak this block and remove it from the free list.
    //  If the heap debug flag is set or if we are in DBG mode then HARD_ASSERT.
    //
    //  This code allows us to work around this bug:
    //      730550 ITG: Tracking: DNS heap corruption; .NET  Build 3678
    //  
    
    if ( plist->pFreeList )
    {
        PFREE_BLOCK         pfreeListHead = plist->pFreeList;
    
        #if DBG
        if ( 1 )
        #else
        if ( SrvCfg_dwHeapDebug )
        #endif
        {
            //
            //  Debug-enabled - break if the free list appears corrupt.
            //
            
            HARD_ASSERT( pfreeListHead->FreeTag == FREE_BLOCK_TAG );
            if ( pfreeListHead->MemHead.pNextFree )
            {
                HARD_ASSERT(
                    pfreeListHead->MemHead.pNextFree->FreeTag == FREE_BLOCK_TAG );
            }
        }
        else
        {
            int     maxCorruptFreeBlocks = 10;
            
            //
            //  No debug - if the next block is corrupt, leak it and continue.
            //
            
            while ( --maxCorruptFreeBlocks &&
                    pfreeListHead->FreeTag != FREE_BLOCK_TAG )
            {
                DNS_PRINT((
                    "WARNING: Mem_Alloc() leaking corrupt free block %p\n",
                    "    User Mem  = %p\n"
                    "    Length    = %d\n"
                    "    File      = %s\n"
                    "    Line      = %d\n",
                    pfreeListHead,
                    RECOVER_USER_MEM_FROM_MEMHEAD( pfreeListHead ),
                    Length,
                    pszFile,
                    LineNo ));
                pfreeListHead = pfreeListHead->MemHead.pNextFree;
                plist->FreeCount--;
            }
            
            //
            //  We might as well crash if things look really bad.
            //
            
            if ( maxCorruptFreeBlocks == 0 )
            {
                HARD_ASSERT( !"free list corruption detected" );
            }
        }
    }

    //
    //  Found standard size alloc.
    //
    //  Take block from front of list.
    //      - reset list head to next block
    //      - clear free tag on block
    //      - update counters
    //

    pnew = plist->pFreeList;

    ASSERT( plist->FreeCount );

#if DBG
    if ( !pnew || pnew->FreeTag != FREE_BLOCK_TAG )
    {
        DNS_PRINT((
            "pnew = %p on free list without tag!\n",
            pnew ));
        ASSERT( !"free block missing tag!" );
    }
    if ( pnew )
    {
        pnew->FreeTag = 0;
    }
#endif

    plist->pFreeList = pnew ? pnew->MemHead.pNextFree : NULL;
    plist->FreeCount--;
    plist->UsedCount++;
    
    IF_DEBUG( FREE_LIST )
    {
        ASSERT( standardAllocFreeListValidate(plist) );
    }

    STANDARD_ALLOC_UNLOCK( plist );

    //  set header on new block
    //  then return user portion of block

    pnew = setAllocHeader(
                ( PMEMHEAD ) pnew,
                plist->Index,
                plist->Size,
                Tag );

    Done:

    return pnew;
}



PVOID
Mem_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Allocates and zeros memory.

Arguments:

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PVOID  palloc;

    palloc = Mem_Alloc( Length, Tag, pszFile, LineNo );
    if ( palloc )
    {
        RtlZeroMemory(
            palloc,
            Length );
    }
    return( palloc );
}



PVOID
Mem_Realloc(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocate.

Arguments:

    pMemory -- existing memory block

    Length -- length of allocation required.

    Tag --

Return Value:

    Ptr to memory of desired size, if successful.
    NULL on allocation failure.

--*/
{
    PMEMHEAD    pblock;
    PMEMHEAD    pnew;
    DWORD       tag;
    DWORD       size;

    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pblock = RECOVER_MEMHEAD_FROM_USER_MEM(pMemory);

    HARD_ASSERT( pblock->Boundary == BOUNDARY_ACTIVE );

    size = RECOVER_MEM_SIZE(pblock);
    ASSERT( size > SIZEOF_MAX_STANDARD_ALLOC );
    ASSERT( Length > size );

    ASSERT( Tag == 0 || Tag == pblock->Tag );
    Tag = pblock->Tag;

    DNS_PRINT((
        "ERROR:  Mem_Realloc() called!\n",
        "    pMem     = %s\n"
        "    Length   = %d\n"
        "    Tag      = %d\n"
        "    File     = %s\n"
        "    Line     = %d\n",
        pMemory,
        Length,
        Tag,
        pszFile,
        LineNo ));

    //
    //  realloc
    //
    //  DEVNOTE: need to inc free stats on realloc, otherwise
    //      this throws stats off
    //

    size = Length + sizeof(MEMHEAD);
    pnew = reallocMemory( pblock, size, pszFile, LineNo );
    if ( !pnew )
    {
        return( pnew );
    }
    if ( size > MEM_MAX_SIZE )
    {
        size = MEM_MAX_SIZE;
    }
    else if ( size & MEM_INDEX_MASK )
    {
        size &= MEM_SIZE_MASK;
        size += sizeof(DWORD);
    }

    pnew = setAllocHeader(
                (PMEMHEAD) pnew,
                HEAP_INDEX,
                size,
                Tag );

    return pnew;
}



VOID
Mem_Free(
    IN OUT  PVOID           pFree,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Free a standard sized allocation.

    As optimization, assuming list locked by caller.

Arguments:

    pFree -- allocation to free

    Length -- length of this allocation

Return Value:

    TRUE if successful.
    FALSE if not a standard allocation.

--*/
{
    PFREE_BLOCK             pfreeblock;
    PSTANDARD_ALLOC_LIST    plist;
    DWORD                   tag;
    DWORD                   size;
    INT                     index;

    if ( !pFree )
    {
        return;
    }

    DNS_DEBUG( HEAP2, (
        "Mem_Free( %p, len=%d, tag=%d, %s line=%d )\n",
        pFree,
        Length,
        Tag,
        pszFile,
        LineNo ));
    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pfreeblock = ( PFREE_BLOCK ) RECOVER_MEMHEAD_FROM_USER_MEM( pFree );

    if ( pfreeblock->MemHead.Boundary != BOUNDARY_ACTIVE )
    {
        HARD_ASSERT( pfreeblock->MemHead.Boundary == BOUNDARY_ACTIVE );
        return;
    }

    pfreeblock->MemHead.Boundary = BOUNDARY_FREE;

    size = RECOVER_MEM_SIZE( &pfreeblock->MemHead );

    tag = pfreeblock->MemHead.Tag;

    DNS_DEBUG( HEAP2, (
        "Mem_Free( %p -- recovered tag=%d, size=%d )\n",
        pFree,
        tag,
        size ));

    HARD_ASSERT( tag <= MEMTAG_MAX );
    ASSERT( Tag == 0 || tag == Tag );

    MEM_STATS_LOCK();

    STAT_INC( MemoryStats.MemTags[ tag ].Free );
    STAT_SUB( MemoryStats.MemTags[ tag ].Memory, size );

    if ( MemoryStats.MemTags[ tag ].Free > MemoryStats.MemTags[ tag ].Alloc )
    {
        DNS_PRINT((
            "Tag %d with negative in-use count!\n"
            "    alloc = %d\n"
            "    free = %d\n",
            tag,
            MemoryStats.MemTags[ tag ].Alloc,
            MemoryStats.MemTags[ tag ].Free ));
        ASSERT( FALSE );
    }
    if ( (LONG)MemoryStats.MemTags[ tag ].Memory < 0 )
    {
        DNS_PRINT((
            "Tag %d with negative memory count = %d!\n",
            tag,
            (LONG)MemoryStats.MemTags[ tag ].Memory ));
        ASSERT( FALSE );
    }

    STAT_INC( MemoryStats.Free );
    STAT_SUB( MemoryStats.Memory, size );
    MEM_STATS_UNLOCK();

    ASSERT( Length == 0 || size == MEM_MAX_SIZE || Length <= size-sizeof(MEMHEAD) );

    //
    //  non-standard size -- free on heap
    //

    if ( size > SIZEOF_MAX_STANDARD_ALLOC || SrvCfg_fTest7 )
    {
        HARD_ASSERT( RECOVER_MEM_INDEX( &pfreeblock->MemHead ) == HEAP_INDEX );

        freeMemory( pfreeblock, pszFile, LineNo );

        STAT_INC( MemoryStats.StdToHeapFree );
        STAT_SUB( MemoryStats.StdToHeapMemory, size );
        return;
    }

    //
    //  standard size
    //  find correct standard block list from index in header
    //

    HARD_ASSERT( size >= Length );

    index = ( INT ) RECOVER_MEM_INDEX( &pfreeblock->MemHead );

    HARD_ASSERT( index <= MEM_MAX_INDEX );

    plist = &StandardAllocLists[index];

    HARD_ASSERT( size == plist->Size );

    //
    //  slap freed block to front of freelist
    //

    STANDARD_ALLOC_LOCK( plist );

    pfreeblock->MemHead.pNextFree = plist->pFreeList;
    pfreeblock->FreeTag = FREE_BLOCK_TAG;

    plist->pFreeList = pfreeblock;
    plist->ReturnCount++;
    plist->FreeCount++;

    IF_DEBUG( FREE_LIST )
    {
        ASSERT( standardAllocFreeListValidate(plist) );
    }
    STANDARD_ALLOC_UNLOCK( plist );
}



BOOL
Mem_IsStandardBlockLength(
    IN      DWORD           Length
    )
/*++

Routine Description:

    Check if length covered by standard block list or heap.

Arguments:

    Length -- length

Return Value:

    TRUE if standard block.
    FALSE otherwise.

--*/
{
    return( Length <= SIZEOF_MAX_STANDARD_ALLOC  &&  !SrvCfg_fTest7 );
}



VOID
Mem_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Derive standard alloc stats.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSTANDARD_ALLOC_LIST    plist;

    //
    //  non-standard size -- get outstanding count
    //

    MemoryStats.StdToHeapInUse = MemoryStats.StdToHeapAlloc - MemoryStats.StdToHeapFree;

    //
    //  sum standard size counts
    //

    MemoryStats.StdBlockAlloc           = 0;
    MemoryStats.StdBlockMemory          = 0;
    MemoryStats.StdBlockFreeList        = 0;
    MemoryStats.StdBlockUsed            = 0;
    MemoryStats.StdBlockReturn          = 0;
    MemoryStats.StdBlockFreeListMemory  = 0;

    plist = StandardAllocLists;
    do
    {
        MemoryStats.StdBlockAlloc       += plist->TotalCount;
        MemoryStats.StdBlockMemory      += plist->Memory;
        MemoryStats.StdBlockFreeList    += plist->FreeCount;

        MemoryStats.StdBlockUsed        += plist->UsedCount;
        MemoryStats.StdBlockReturn      += plist->ReturnCount;

        MemoryStats.StdBlockFreeListMemory += plist->FreeCount * plist->Size;
        plist++;
    }
    while( plist->Size < SIZEOF_MAX_STANDARD_ALLOC );

    MemoryStats.StdBlockInUse = MemoryStats.StdBlockUsed - MemoryStats.StdBlockReturn;

    //
    //  combined standard system stats
    //

    MemoryStats.StdUsed     = MemoryStats.StdToHeapAlloc + MemoryStats.StdBlockUsed;
    MemoryStats.StdReturn   = MemoryStats.StdToHeapFree + MemoryStats.StdBlockReturn;

    MemoryStats.StdInUse    = MemoryStats.StdUsed - MemoryStats.StdReturn;

    MemoryStats.StdMemory   = MemoryStats.StdToHeapMemory + MemoryStats.StdBlockMemory;
}



BOOL
Mem_IsStandardFreeBlock(
    IN      PVOID           pFree
    )
/*++

Routine Description:

    Validate block is free block.

Arguments:

    pFree -- ptr to free block

Return Value:

    TRUE if free block.
    FALSE otherwise.

--*/
{
    PFREE_BLOCK pblock = (PFREE_BLOCK) ((PCHAR)pFree - sizeof(MEMHEAD));

    return ( ( PFREE_BLOCK ) pblock )->FreeTag == FREE_BLOCK_TAG;
}



#if DBG
BOOL
standardAllocFreeListValidate(
    IN      PSTANDARD_ALLOC_LIST    pList
    )
/*++

Routine Description:

    Validate the free list.

    Assumes list locked.

Arguments:

    pList -- standard allocation list

Return Value:

    TRUE if list validates.
    FALSE if error in free list.

--*/
{
    PFREE_BLOCK     pfreeblock;
    DWORD           count;

    //STANDARD_ALLOC_LOCK();

    count = pList->FreeCount;
    pfreeblock = pList->pFreeList;

    DNS_PRINT((
        "Alloc list head = %p, for size %d, Length = %d.\n",
        pfreeblock,
        pList->Size,
        count ));

    while ( pfreeblock )
    {
        count--;
        ASSERT( pfreeblock->FreeTag == FREE_BLOCK_TAG );
        pfreeblock = pfreeblock->MemHead.pNextFree;
    }

    if ( count > 0 )
    {
        DNS_PRINT((
            "ERROR:  Free list failure.\n"
            "    Element count %d at end of list.\n"
            "Terminating element:\n",
            count ));

        ASSERT( FALSE );
        //STANDARD_ALLOC_UNLOCK();
        return FALSE;
    }

    //STANDARD_ALLOC_UNLOCK();
    return TRUE;
}

#endif // DBG




BOOL
Mem_HeapInit(
    VOID
    )
/*++

Routine Description:

    Initialize heap. If this function fails, it is catastrophic and
    the service must not continue startup.

    MUST call this routine before using memory allocation.

Arguments:

    None.

Return Value:

    TRUE/FALSE for success/failure.

--*/
{
    DWORD   heapFlags;
    DWORD   i;
    BOOL    rc = FALSE;

    //
    //  verify blocks properly aligned
    //  32 or 64 bit should be aligned accordingly
    //

    ASSERT( BLOCKSIZE1 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE2 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE3 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE4 % sizeof(PVOID) == 0 );

    //
    //  init tracking globals

    g_AllocFailureCount = 0;
    g_AllocFailureLogTime = 0;

    gCurrentAlloc = 0;

    //
    //  create DNS heap
    //

    heapFlags = HEAP_GROWABLE |
#if DBG
                HEAP_TAIL_CHECKING_ENABLED |
                HEAP_FREE_CHECKING_ENABLED |
#endif
                HEAP_CREATE_ALIGN_16 |
                HEAP_CLASS_1;

    hDnsHeap = RtlCreateHeap(
                    heapFlags,
                    NULL,           // no base specified
                    0,              // default reserve size
                    0,              // default commit size
                    NULL,           // no lock
                    NULL            // no parameters
                    );
    if ( !hDnsHeap )
    {
        goto Done;
    }

#if DBG
    //
    //  debug heap stuff disabled until updated for separate heaps
    //
    //  set for full heap checking?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        rc = HeapDbgInit( DNS_EXCEPTION_OUT_OF_MEMORY, TRUE );
    }
    else
    {
        rc = HeapDbgInit( DNS_EXCEPTION_OUT_OF_MEMORY, FALSE );
    }

    if ( !rc )
    {
        goto Done;
    }

#endif

    //
    //  initialize standard alloc lists
    //
    //  note this is static structure, so we can simply do
    //  static init of fixed values -- index, blocksize, etc.
    //  they are unaffected by restart
    //

    for ( i=0;  i<=MEM_MAX_INDEX; i++ )
    {
        PSTANDARD_ALLOC_LIST    plist = &StandardAllocLists[i];

        if ( DnsInitializeCriticalSection( &plist->Lock ) != ERROR_SUCCESS )
        {
            goto Done;
        }

        plist->pFreeList    = NULL;
        plist->FreeCount    = 0;
        plist->HeapAllocs   = 0;
        plist->TotalCount   = 0;
        plist->UsedCount    = 0;
        plist->ReturnCount  = 0;
        plist->Memory       = 0;
    }

    rc = TRUE;

    Done:

    return rc;
}



VOID
Mem_HeapDelete(
    VOID
    )
/*++

Routine Description:

    Delete heap.

    Need this to allow restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   i;

    //
    //  delete process heap
    //  then cleanup CS for individual lists
    //  cleanup of lists is more likely to generate exception
    //  and MUST succeed with heap or we're done
    //

    DNS_DEBUG( ANY, (
        "RtlDestroyHeap() on DNS heap %p\n",
        hDnsHeap ));

    RtlDestroyHeap( hDnsHeap );

    //
    //  delete CS for each standard list
    //

    for ( i=0;  i<=MEM_MAX_INDEX; i++ )
    {
        PSTANDARD_ALLOC_LIST    plist = &StandardAllocLists[i];

        DeleteCriticalSection( &plist->Lock );
    }
}



//
//  This set may be registered with DnsApi.dll to allow interchangeable
//  use of memory.
//
//  These functions simply cover the standard heap functions, eliminating the
//  debug tag, file and line parameters.
//

#define DNSLIB_HEAP_FILE    "DnsLib"
#define DNSLIB_HEAP_LINE    0


PVOID
Mem_DnslibAlloc(
    IN      INT             iSize
    )
{
    return  Mem_Alloc(
                iSize,
                MEMTAG_DNSLIB,
                DNSLIB_HEAP_FILE,
                DNSLIB_HEAP_LINE );
}

PVOID
Mem_DnslibRealloc(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize
    )
{
    return  Mem_Realloc(
                pMemory,
                iSize,
                MEMTAG_DNSLIB,
                DNSLIB_HEAP_FILE,
                DNSLIB_HEAP_LINE );
}


VOID
Mem_DnslibFree(
    IN OUT  PVOID           pMemory
    )
{
    Mem_Free(
        pMemory,
        0,
        MEMTAG_DNSLIB,
        DNSLIB_HEAP_FILE,
        DNSLIB_HEAP_LINE );
}


#if 0
//
//  For bad unknown memory stomping, as a last ditch effort you can sprinkle
//  code with calls to this function to try and narrow down the corruption.
//

int Debug_TestFreeLists( void )
{
    int i;
    for ( i = 0; i < STANDARD_BLOCK_COUNT; ++i )
    {
        standardAllocFreeListValidate( &StandardAllocLists[ i ] );
    }
    return 0;
}
#endif


DWORD
Mem_GetLastAllocFailureTime(
    VOID
    )
{
    return g_dwLastAllocationFailureTime;
}


//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\ics.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ics.c

Abstract:

    Domain Name System (DNS) Server

    Routines for interacting with ICS.

Author:

    Jeff Westhead (jwesth)     March 2001

Revision History:

--*/


#include "dnssrv.h"

#include <ipnathlp.h>
#include "..\natlib\iprtrint.h"


const WCHAR c_szSharedAccessName[] = L"SharedAccess";



VOID
logNotificationFailureEvent(
    IN      PWSTR       pwszServiceName,
    IN      DWORD       dwErrorCode
    )
/*++

Routine Description:

    Send appropriate notifications to the ICS service as requested by
    Raghu Gatta (rgatta).

Arguments:

    fDnsIsStarting -- TRUE if the DNS server service is starting,
        FALSE if the DNS server service is shutting down

Return Value:

    None - the DNS server doesn't care if this succeeds or fails, but
        an event may be logged on failure

--*/
{
    BYTE    argTypeArray[] =
                {
                    EVENTARG_UNICODE,
                    EVENTARG_DWORD
                };
    PVOID   argArray[] =
                {
                    ( PVOID ) pwszServiceName,
                    ( PVOID ) ( DWORD_PTR ) dwErrorCode
                };

    DNS_LOG_EVENT(
        DNS_EVENT_SERVICE_NOTIFY,
        2,
        argArray,
        argTypeArray,
        0 );
}   //  logNotificationFailureEvent



VOID
ICS_Notify(
    IN      BOOL        fDnsIsStarting
    )
/*++

Routine Description:

    Send appropriate notifications to the ICS service as requested by
    Raghu Gatta (rgatta).

Arguments:

    fDnsIsStarting -- TRUE if the DNS server service is starting,
        FALSE if the DNS server service is shutting down

Return Value:

    None - the DNS server doesn't care if this succeeds or fails, but
        an event may be logged on failure

--*/
{
    DBG_FN( "ICS_Notify" )

    ULONG           Error = ERROR_SUCCESS;
    LPVOID          lpMsgBuf;
    SC_HANDLE       hScm = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  Status;
    BOOL            fLogEventOnError = FALSE;

    do
    {
        hScm = OpenSCManager(NULL, NULL, GENERIC_READ);

        if (!hScm)
        {
            Error = GetLastError();
            fLogEventOnError = TRUE;
            break;
        }

        hService = OpenServiceW(
                       hScm,
                       c_szSharedAccessName,
                       SERVICE_USER_DEFINED_CONTROL |
                       SERVICE_QUERY_CONFIG         |
                       SERVICE_QUERY_STATUS         |
                       SERVICE_START                |
                       SERVICE_STOP );

        if ( !hService )
        {
            //  If ICS is not installed don't log an error.
            //  Error = GetLastError();
            Error = ERROR_SUCCESS;
            break;
        }

        if ( QueryServiceStatus( hService, &Status ) )
        {
             if (SERVICE_RUNNING == Status.dwCurrentState)
             {
                DWORD   dwControl;
            
                //
                // send signal to SharedAccess DNS
                //
                if (fDnsIsStarting)
                {
                    //
                    // SharedAccess DNS should be disabled
                    //
                    dwControl = IPNATHLP_CONTROL_UPDATE_DNS_DISABLE;
                }
                else
                {
                    //
                    // SharedAccess DNS should be enabled
                    //
                    dwControl = IPNATHLP_CONTROL_UPDATE_DNS_ENABLE;               
                }

                if (!ControlService(hService, dwControl, &Status))
                {
                    Error = GetLastError();
                    fLogEventOnError = TRUE;
                    break;
                }

             }
        }
        else
        {
            Error = GetLastError();
            fLogEventOnError = TRUE;
            break;
        }
    }
    while (FALSE);

    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hScm)
    {
        CloseServiceHandle(hScm);
    }

    //
    //  Log error on failure.
    //
        
    if ( ERROR_SUCCESS != Error && fLogEventOnError )
    {
        logNotificationFailureEvent( ( PWSTR ) c_szSharedAccessName, Error );
    }

    DNS_DEBUG( INIT, ( "%s: ICS status=%d\n", fn, Error ));

    //
    //  Now notify NAT. The DNSProxy functions are from natlib.
    //

    fLogEventOnError = TRUE;

    Error = fDnsIsStarting ?
                DNSProxyDisable() :
                DNSProxyRestoreConfig();

    //
    //  Do not log RPC errors. These probably indicate that the service is not installed
    //  or not running, which is the normal state for a machine non-NAT machine. We do
    //  not want to log an error in this case.
    //
    
    if ( Error != ERROR_SUCCESS &&
         ( Error < 1700 || Error > 1900 ) &&
         fLogEventOnError )
    {
        logNotificationFailureEvent( L"NAT", Error );
    }

    DNS_DEBUG( INIT, ( "%s: NAT status=%d\n", fn, Error ));

    return;
}   //  ICS_Notify


//
//  End ics.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\msginfo.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    msginfo.h

Abstract:

    Message info type.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

    jamesg  Feb 1995    - Direct question pointer
    jamesg  Mar 1995    - Packet protection fields:
                            - BufferLength
                            - AvailLength
                            - pCurrent
                        - Alignment for TCP
    jamesg  May 1995    - Separate into this file.

--*/

#ifndef _DNS_MSGINFO_INC_
#define _DNS_MSGINFO_INC_


//
//  Additional records info
//
//  DEVNOTE-DCR: combine with compression?
//      - advantage, one clear, need to compress additional anyway
//          more efficient if banging on end of both
//      - disadvantage, a bit more complexity in overwriting compression
//          entries if get to the end
//

#define MAX_ADDITIONAL_RECORD_COUNT (50)

typedef struct      //  336 bytes
{
    DWORD       cMaxCount;
    DWORD       cCount;
    DWORD       iIndex;
    DWORD       iRecurseIndex;
    DWORD       dwStateFlags;   //  use DNS_ADDSTATE_XXX constants
    PDB_NAME    pNameArray[ MAX_ADDITIONAL_RECORD_COUNT ];
    WORD        wOffsetArray[ MAX_ADDITIONAL_RECORD_COUNT ];
    WORD        wTypeArray[ MAX_ADDITIONAL_RECORD_COUNT ];
}
ADDITIONAL_INFO, *PADDITIONAL_INFO;

#define INITIALIZE_ADDITIONAL( pMsg ) \
        {                          \
            (pMsg)->Additional.cMaxCount        = MAX_ADDITIONAL_RECORD_COUNT; \
            (pMsg)->Additional.cCount           = 0;   \
            (pMsg)->Additional.iIndex           = 0;   \
            (pMsg)->Additional.iRecurseIndex    = 0;   \
            (pMsg)->Additional.dwStateFlags     = 0;   \
        }

#define HAVE_MORE_ADDITIONAL_RECORDS( pAdd ) \
            ( (pAdd)->cCount > (pAdd)->iIndex )

#define DNS_ADDSTATE_WROTE_A            0x0001
#define DNS_ADDSTATE_ONLY_WANT_A        0x0002
#define DNS_ADDSTATE_NOT_ADDITIONAL     0x0004

#define DNS_ADDITIONAL_WROTE_A( padd ) \
    ( ( padd )->dwStateFlags & DNS_ADDSTATE_WROTE_A )

#define DNS_ADDITIONAL_ONLY_WANT_A( padd ) \
    ( ( padd )->dwStateFlags & DNS_ADDSTATE_ONLY_WANT_A )

#define DNS_ADDITIONAL_SET_WROTE_A( padd ) \
    ( ( padd )->dwStateFlags |= DNS_ADDSTATE_WROTE_A )

#define DNS_ADDITIONAL_SET_ONLY_WANT_A( padd ) \
    ( ( padd )->dwStateFlags |= DNS_ADDSTATE_ONLY_WANT_A )



//
//  Compression node info
//
//  Each compressed name can be represented by
//      - node compressed (if any)
//      - offset of compression
//      - label length
//      - label depth
//
//  The two label fields enable fast comparison without
//  necessitating actual visit (and accompaning ptr deref)
//  to the offset.
//

#define MAX_COMPRESSION_COUNT (50)

typedef struct      //  362 bytes
{
    DWORD                   cCount;
    WORD                    wLastOffset;
    PDB_NODE                pLastNode;
    PDB_NODE                pNodeArray[ MAX_COMPRESSION_COUNT ];
    WORD                    wOffsetArray[ MAX_COMPRESSION_COUNT ];
    UCHAR                   chDepthArray[ MAX_COMPRESSION_COUNT ];
}
COMPRESSION_INFO, *PCOMPRESSION_INFO;

#define INITIALIZE_COMPRESSION( pMsg )  \
        {                               \
            (pMsg)->Compression.cCount      = 0;    \
            (pMsg)->Compression.pLastNode   = 0;    \
        }


//
//  DNS Server Message Info structure
//
//  This is structure in which requests are held while being
//  processed by the DNS server.
//

typedef struct _DNS_MSGINFO
{
    LIST_ENTRY      ListEntry;          //  for queuing

    //
    //  Basic packet info
    //

    //  8
    PCHAR           pBufferEnd;         //  ptr to byte after buffer
    PBYTE           pCurrent;           //  current location in buffer

    //
    //  When a packet is allocated BufferLength is set to the
    //  usable buffer length but the packet buffer may actually be
    //  larger. This is used in UDP EDNS.
    //
    
    //  16
    DWORD           Tag;
    DWORD           BufferLength;       // usable buffer size
    DWORD           MaxBufferLength;    // total allocated buffer size

    //
    //  Addressing
    //

    SOCKET          Socket;

    #if 1
    DNS_ADDR        RemoteAddr;
    #else
    INT             RemoteAddressLength;
    SOCKADDR_IN     RemoteAddress;
    #endif

    //
    //  Current lookup info
    //

    //  52
    PDB_NODE        pnodeCurrent;       //  current node, may be NULL
    PDB_NODE        pnodeClosest;       //  closest found to current
    PZONE_INFO      pzoneCurrent;
    PDB_NODE        pnodeGlue;          //  effectively node in delegation
    //  68
    PDB_NODE        pnodeDelegation;    //  effectively closest in delegation
    PDB_NODE        pnodeCache;
    PDB_NODE        pnodeCacheClosest;

    //  JJW fix offsets!
    PDB_NODE        pnodeNxt;           //  use this node for DNSSEC NXT

    //  80
    WORD            wTypeCurrent;       //  current type being looked up
    WORD            wOffsetCurrent;

    //  Question node

    //  84
    PDB_NODE        pNodeQuestion;
    PDB_NODE        pNodeQuestionClosest;

    //  92
    PDNS_WIRE_QUESTION  pQuestion;          //  ptr to original question
    WORD                wQuestionType;      //  type in question

    //
    //  Queuing
    //

    WORD            wQueuingXid;        //  match XID to response
    //  100
    DWORD           dwQueryTime;        //  time of original query
    DWORD           dwMsQueryTime;      //  time of query in milliseconds
    DWORD           dwQueuingTime;      //  time queued
    DWORD           dwExpireTime;       //  queue timeout

    //  Opt RR info

    //  116
    struct _DNS_OPTINFO     // size is 12 bytes
    {
        BOOLEAN     fFoundOptInIncomingMsg;
        BOOLEAN     fInsertOptInOutgoingMsg;
        UCHAR       cExtendedRCodeBits;
        UCHAR       cVersion;
        WORD        wUdpPayloadSize;
        WORD        wOptOffset;                 //  0 -> no OPT present
        WORD        wOriginalQueryPayloadSize;  //  0 -> no OPT in client query
        WORD        PadToMakeOptAlignOnDWord;
    } Opt;

    //
    //  Recursion info
    //

    //  132
    struct _DNS_MSGINFO  *  pRecurseMsg;    //  recursion msg info
    PDB_NODE        pnodeRecurseRetry;
    PVOID           pNsList;                //  visited NS list

    //
    //  TCP message reception
    //

    //  144
    PVOID           pConnection;        //  ptr to connection struct
    PCHAR           pchRecv;            //  ptr to next pos in message


    //
    //  Lookup types
    //

    //  152
    DWORD           UnionMarker;

    //  156
    union
    {
        //
        //  Wins / Nbstat stored info during lookup
        //

        struct      //  6 bytes
        {
            PVOID           pWinsRR;
            CHAR            WinsNameBuffer[16];
            UCHAR           cchWinsName;
        }
        Wins;

        //
        //  Nbstat info
        //

        struct      //  20 bytes
        {
            PDB_RECORD      pRR;                    // zone's WINSR record
            PVOID           pNbstat;
            DNS_ADDR        ipNbstat;
            DWORD           dwNbtInterfaceMask;
            BOOLEAN         fNbstatResponded;       //  response from WINS
        }
        Nbstat;

        //
        //  Xfr
        //

        struct      //  32 bytes
        {
            DWORD           dwMessageNumber;

            DWORD           dwSecondaryVersion;
            DWORD           dwMasterVersion;
            DWORD           dwLastSoaVersion;

            BOOLEAN         fReceivedStartSoa;      // read startup SOA
            BOOLEAN         fBindTransfer;          // transfer to old BIND servers
            BOOLEAN         fMsTransfer;            // transfer to MS server
            BOOLEAN         fLastPassAdd;           // last IXFR pass was add
        }
        Xfr;

        //
        //  Forwarding info
        //

        struct      //  24 bytes
        {
            SOCKET          OriginalSocket;
            DNS_ADDR        ipOriginal;
            WORD            wOriginalPort;
            WORD            wOriginalXid;
        }
        Forward;
    }
    U;              // 32 bytes

    //
    //  Ptr to internal lookup name
    //

    //  188
    PLOOKUP_NAME    pLooknameQuestion;

    //
    //  Basic packet flags
    //

    //  192
    DWORD           FlagMarker;

    //  196
    BOOLEAN         fDelete;                //  delete after send
    BOOLEAN         fTcp;
    BOOLEAN         fMessageComplete;       //  complete message received
    UCHAR           Section;

    //
    //  Additional processing flag
    //

    //  212
    BOOLEAN         fDoAdditional;

    //
    //  Recursion flags
    //

    //  recursion allowed for packet when recursion desired and not
    //      disabled on server

    //  216
    BOOLEAN         fRecurseIfNecessary;    //  recurse this packet
    BOOLEAN         fRecursePacket;         //  recursion query msg

    //  clear fQuestionRecursed on every new question being looked up
    //      for query (original, CNAME indirection, additional)
    //  set fQuestionRecursed when go out for recursion (or WINS)
    //
    //  clear fQuestionComplete when go out for recursion (or WINS)
    //  set fQuestionComplete when Authoritative answer of recursion;
    //      indicates cut off of further attempts
    //

    //  224
    BOOLEAN         fQuestionRecursed;
    BOOLEAN         fQuestionCompleted;
    BOOLEAN         fRecurseQuestionSent;

    //  completed recursion through list of servers -- waiting for
    //      final timeout

    //  236
    BOOLEAN         fRecurseTimeoutWait;
    INT             nTimeoutCount;          //  total number of timeouts
    CHAR            nForwarder;             //  index of current forwarder

    //
    //  CNAME processing
    //

    //  244
    BOOLEAN         fReplaceCname;          //  replace with CNAME lookup
    UCHAR           cCnameAnswerCount;

    //
    //  Saving compression offsets (may turn off for XFR)
    //

    //  252
    BOOLEAN         fNoCompressionWrite;    // do NOT save offsets for comp.

    //
    //  Wins and Nbstat
    //

    BOOLEAN         fWins;                  //  WINS lookup

    //
    //  Wildcarding
    //

    UCHAR           fQuestionWildcard;

    //
    //  NS List buffer -- not a message
    //      - used to detect on cleanup
    //

    BOOLEAN         fNsList;

    //
    //  Additional records info
    //

    //  268 -- +100 - must add 100 to all following offsets!
    ADDITIONAL_INFO     Additional;

    //
    //  Name compresion info
    //

    //  604
    COMPRESSION_INFO    Compression;

    //
    //  For debug enlist for packet leak tracking
    //

    //  966
#if DBG
    LIST_ENTRY          DbgListEntry;
#endif

#if 0
    //
    //  Parsed RR lists. We use anonymous unions so that in the update
    //  code we can transparently refer to the RR lists by their proper
    //  names. When a message is received and it becomes apparent that
    //  we will want to process it further, we parse it and set the
    //  fRRListsParsed flag. When a change is made to any data in any
    //  of the RR lists, we set the fRRListsDirty flag. Once the dirty
    //  flag is set, the raw message body in MessageBody absolutely
    //  must NOT be read. If this message is sent on the wire, if the
    //  dirty flag is true, the body must be re-written with the
    //  contents of the lists.
    //

    BOOLEAN             fRRListsParsed;
    BOOLEAN             fRRListsDirty;

    union
    {
        PDB_RECORD      pQuestionList;
        PDB_RECORD      pZoneList;
    };
    union
    {
        PDB_RECORD      pAnswerList;
        PDB_RECORD      pPreReqList;
    };
    union
    {
        PDB_RECORD      pAuthList;
        PDB_RECORD      pUpdateList;
    };
    PDB_RECORD          pAdditionalList;
#endif
        
    //
    //  WARNING !
    //
    //  Message length MUST
    //      - be a WORD type
    //      - immediately preceed message itself
    //  for proper send/recv of TCP messages.
    //
    //  Message header (i.e. message itself) MUST be on WORD boundary
    //  so its fields are all WORD aligned.
    //  May be no need to keep it on DWORD boundary, as it has no DWORD
    //  fields.
    //
    //  Since I don't know whether a DNS_HEADER struct will align
    //  itself on a DWORD (but I think it will), force MessageLength
    //  to be the SECOND WORD in a DWORD.
    //

    //  970/966 (debug/retail)
    DWORD           dwForceAlignment;

    //  974/970
    WORD            BytesToReceive;
    WORD            MessageLength;

    //
    //  DNS Message itself
    //

    //  978/974
    DNS_HEADER      Head;       //  12 bytes

    //
    //  Question and RR section
    //
    //  This simply provides some coding simplicity in accessing
    //  this section given MESSAGE_INFO structure.
    //

    //  990/986
    CHAR            MessageBody[1];

}
DNS_MSGINFO, *PDNS_MSGINFO;


//
//  DNS Message Macros
//

#define DNS_HEADER_PTR( pMsg )          ( &(pMsg)->Head )

#define DNSMSG_FLAGS( pMsg )            DNS_HEADER_FLAGS( DNS_HEADER_PTR(pMsg) )

#define DNSMSG_SWAP_COUNT_BYTES( pMsg ) DNS_BYTE_FLIP_HEADER_COUNTS( DNS_HEADER_PTR(pMsg) )

#define DNSMSG_OFFSET( pMsg, p )        ((WORD)((PCHAR)(p) - (PCHAR)DNS_HEADER_PTR(pMsg)))

#define DNSMSG_OFFSET_DWORD( pMsg, p )  ((DWORD)((PCHAR)(p) - (PCHAR)DNS_HEADER_PTR(pMsg)))

#define DNSMSG_CURRENT_OFFSET( pMsg )   DNSMSG_OFFSET( (pMsg), (pMsg)->pCurrent )

#define DNSMSG_CURRENT_OFFSET_DWORD( pMsg )     DNSMSG_OFFSET_DWORD( (pMsg), (pMsg)->pCurrent )

#define DNSMSG_BYTES_REMAINING( pMsg )  ( ( pMsg )->pBufferEnd > ( pMsg )->pCurrent ?   \
                                          ( pMsg )->pBufferEnd - ( pMsg )->pCurrent : 0 )

#define DNSMSG_PTR_FOR_OFFSET( pMsg, wOffset )  \
            ( (PCHAR)DNS_HEADER_PTR(pMsg) + wOffset )

#define DNSMSG_OPT_PTR( pMsg )  \
            ( (PCHAR)DNS_HEADER_PTR(pMsg) + pMsg->Opt.wOptOffset )

#define DNSMSG_END( pMsg )      ( (PCHAR)DNS_HEADER_PTR(pMsg) + (pMsg)->MessageLength )


//
//  Offset to\from name compression
//

#define DNSMSG_QUESTION_NAME_OFFSET         (0x000c)

#define DNSMSG_COMPRESSED_QUESTION_NAME     (0xc00c)

#define OFFSET_FOR_COMPRESSED_NAME( wOffset )   ((WORD)((wOffset) & 0x3fff))

#define COMPRESSED_NAME_FOR_OFFSET( wComp )     ((WORD)((wComp) | 0xc000))


//
//  DnsSec macros
//

#define DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( _pMsg )                  \
    ( SrvCfg_dwEnableDnsSec == DNS_DNSSEC_ENABLED_ALWAYS ||         \
        SrvCfg_dwEnableDnsSec == DNS_DNSSEC_ENABLED_IF_EDNS &&      \
            ( _pMsg )->Opt.fFoundOptInIncomingMsg )

//
//  Use these defines to assert that the end of buffer marker is intact.
//  

#ifdef _WIN64
#define DNS_END_OF_BUFFER_MARKER        0xFFCCCCFFFFCCCCFF
#define DNS_END_OF_BUFFER_MARKER_TYPE   UINT64
#define DNS_END_OF_BUFFER_MARKER_PTYPE  PUINT64
#else
#define DNS_END_OF_BUFFER_MARKER        0xFFCCCCFF
#define DNS_END_OF_BUFFER_MARKER_TYPE   DWORD
#define DNS_END_OF_BUFFER_MARKER_PTYPE  PDWORD
#endif

#define DNS_MSG_SET_BUFFER_MARKER( pMsg )                               \
     * ( DNS_END_OF_BUFFER_MARKER_PTYPE )                               \
        ( ( PCHAR ) DNS_HEADER_PTR( pMsg ) +                            \
            pMsg->MaxBufferLength ) =                                   \
        DNS_END_OF_BUFFER_MARKER                                        \

#if DBG
#define DNS_MSG_ASSERT_BUFF_INTACT( pMsg )
/*
It would be very cool to make this work at some point - Blackcomb.

#define DNS_MSG_ASSERT_BUFF_INTACT( pMsg )                              \
    if ( pMsg->pBufferEnd )                                             \
    MSG_ASSERT(                                                         \
        pMsg,                                                           \
        * ( DNS_END_OF_BUFFER_MARKER_PTYPE )                            \
            ( ( PCHAR ) DNS_HEADER_PTR( pMsg ) +                        \
                       pMsg->MaxBufferLength ) ==                       \
                       DNS_END_OF_BUFFER_MARKER );
*/
#else
#define DNS_MSG_ASSERT_BUFF_INTACT( pMsg )
#endif


//
//  Define size of allocations, beyond message buffer itself
//
//      - size of message info struct, outside of header
//      - lookname buffer after message buffer
//
//  Note:  the lookname buffer is placed AFTER the message buffer.
//
//  This allows us to avoid STRICT overwrite checking for small
//  items writing RR to buffer:
//      - compressed name
//      - RR (or Question) struct
//      - IP address (MX preference, SOA fixed fields)
//
//  After RR write, we check whether we are over the end of the buffer
//  and if so, we send and do not use lookup name info again anyway.
//  Cool.
//

#define DNS_MSG_INFO_HEADER_LENGTH                                  \
            ( sizeof( DNS_MSGINFO )                                 \
            - sizeof( DNS_HEADER )                                  \
            + 16                           /* alignment monkeying */\
            + sizeof( DNS_END_OF_BUFFER_MARKER_TYPE )               \
            + sizeof( LOOKUP_NAME ) )   

//
//  UDP allocation
//      - info struct, max message length, a little padding
//

#define DNSSRV_UDP_PACKET_BUFFER_LENGTH     DNS_RFC_MAX_UDP_PACKET_LENGTH

//#define DNSSRV_UDP_PACKET_BUFFER_LENGTH     (1472)

#define DNS_UDP_ALLOC_LENGTH                        \
            ( DNS_MSG_INFO_HEADER_LENGTH + DNSSRV_UDP_PACKET_BUFFER_LENGTH + 50 )

//
//  DNS TCP allocation.
//
//  Key point, is this is used almost entirely for zone transfer.
//
//      - 16K is maximum compression offset (14bits) so a
//        good default size for sending AXFR packets but BIND9
//        is now going to be sending TCP AXFR packets >16 KB
//
//      - we will continue to write a maximum of 16k on outbound
//        TCP sends so we can take advantage of name compression
//        (why is BIND9 doing this anyways??? - need to research)
//
//  Note:  Critical that packet lengths are DWORD aligned, as
//      lookname buffer follows message at packet length.
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   ( 0x10000 )     //  16K
#define DNS_TCP_DEFAULT_ALLOC_LENGTH    ( DNS_TCP_DEFAULT_PACKET_LENGTH + \
                                            DNS_MSG_INFO_HEADER_LENGTH )

#define DNS_TCP_MAXIMUM_RECEIVE_LENGTH  ( 0x10000 )     //  64K

#define DNSSRV_MAX_COMPRESSION_OFFSET   ( 0x4000 )

#define MIN_TCP_PACKET_SIZE             ( 0x4000 )
#define MAX_TCP_PACKET_SIZE             DNS_TCP_MAXIMUM_RECEIVE_LENGTH

//
//  DEVNOTE: should allocate 64K to receive, but limit writes to 16K for
//      compression purposes
//

#define DNS_TCP_REALLOC_PACKET_LENGTH   (0xfffc)
#define DNS_TCP_REALLOC_LENGTH          (0xfffc + \
                                        DNS_MSG_INFO_HEADER_LENGTH)

//
//  Mark boundaries, just to make debugging easier
//

#define PACKET_UNION_MARKER   (0xdcbadbca)

#define PACKET_FLAG_MARKER    (0xf1abf1ab)

//
//  Message tags for debug
//

#define PACKET_TAG_ACTIVE_STANDARD  (0xaaaa1111)
#define PACKET_TAG_ACTIVE_TCP       (0xaaaa2222)
#define PACKET_TAG_FREE_LIST        (0xffffffff)
#define PACKET_TAG_FREE_HEAP        (0xeeeeeeee)

#define SET_PACKET_ACTIVE_UDP(pMsg) ((pMsg)->Tag = PACKET_TAG_ACTIVE_STANDARD)
#define SET_PACKET_ACTIVE_TCP(pMsg) ((pMsg)->Tag = PACKET_TAG_ACTIVE_TCP)
#define SET_PACKET_FREE_LIST(pMsg)  ((pMsg)->Tag = PACKET_TAG_FREE_LIST)
#define SET_PACKET_FREE_HEAP(pMsg)  ((pMsg)->Tag = PACKET_TAG_FREE_HEAP)

#define IS_PACKET_ACTIVE_UDP(pMsg)  ((pMsg)->Tag == PACKET_TAG_ACTIVE_STANDARD)
#define IS_PACKET_ACTIVE_TCP(pMsg)  ((pMsg)->Tag == PACKET_TAG_ACTIVE_TCP)
#define IS_PACKET_FREE_LIST(pMsg)   ((pMsg)->Tag == PACKET_TAG_FREE_LIST)
#define IS_PACKET_FREE_HEAP(pMsg)   ((pMsg)->Tag == PACKET_TAG_FREE_HEAP)


//
//  Message info overlays for zone transfer
//

#define XFR_MESSAGE_NUMBER(pMsg)            ((pMsg)->U.Xfr.dwMessageNumber)

#define IXFR_CLIENT_VERSION(pMsg)           ((pMsg)->U.Xfr.dwSecondaryVersion)
#define IXFR_MASTER_VERSION(pMsg)           ((pMsg)->U.Xfr.dwMasterVersion)
#define IXFR_LAST_SOA_VERSION(pMsg)         ((pMsg)->U.Xfr.dwLastSoaVersion)
#define IXFR_LAST_PASS_ADD(pMsg)            ((pMsg)->U.Xfr.fLastPassAdd)

#define RECEIVED_XFR_STARTUP_SOA(pMsg)      ((pMsg)->U.Xfr.fReceivedStartSoa)
#define XFR_MS_CLIENT(pMsg)                 ((pMsg)->U.Xfr.fMsTransfer)
#define XFR_BIND_CLIENT(pMsg)               ((pMsg)->U.Xfr.fBindTransfer)


//
//  Message remote IP as string
//

#define MSG_IP_STRING( pMsg )   DNSADDR_STRING( &( pMsg )->RemoteAddr )


//
//  Query XID space
//
//  The DNS packet is fundamentally broken in requiring processing of
//  name fields to find question or response information.
//
//  To simplify identification of responses, we partition our query XID
//  space.
//
//  WINS XIDs also constrained.
//
//  To operate on the same server as the WINS server, the packets
//  MUST have XIDs that netBT, which recevies the packets, considers
//  to be in the WINS range -- the high bit set (host order).
//
//
//  XID Partion (HOST order)
//
//      WINS query      =>  high bit set
//      recursive query =>  high bit clear, second bit clear
//      zone check      =>  high bit clear, second bit set
//        SOA query     =>  high bit clear, second bit set, third bit set
//        IXFR query    =>  high bit clear, second bit set, third bit clear
//
//  Note that WINS high bit MUST be set in HOST BYTE ORDER.  So we set
//  these XIDS and queue in HOST byte order, then MUST flip bytes before
//  send and after recv before test.
//
//  (We could get around this by simply setting byte flipped high bit
//  0x0080 for WINS and not flipping bytes.   But then we'd have only
//  128 WINS queries before XID wrap.)
//

#define MAKE_WINS_XID( xid )        ( (xid) | 0x8000 )

#define IS_WINS_XID( xid )          ( (xid) & 0x8000 )


#define MAKE_RECURSION_XID( xid )   ( (xid) & 0x3fff )

#define IS_RECURSION_XID( xid )     ( ! ((xid) & 0xc000) )


#define MAKE_SOA_CHECK_XID( xid )   ( ((xid) & 0x1fff) | 0x6000 )

#define IS_SOA_CHECK_XID( xid )     ( ((xid) & 0xe000) == 0x6000 )


#define MAKE_IXFR_XID( xid )        ( ((xid) & 0x1fff) | 0x4000 )

#define IS_IXFR_XID( xid )          ( ((xid) & 0xe000) == 0x4000 )


//
//  For recursion XIDs we attempt to be "effectively random" -- not
//  predictable and hence vulnerable to security attack that requires
//  knowledge of next XID.  Yet use sequential piece to insure no possible
//  reuse in reasonable time even under "bizzaro" conditions.
//
//  To make this less obvious on the wire, put sequential piece on
//  non-hex digit boundary.
//
//  1 = always 1
//  0 = always 0
//  R = Random portion of XID
//  S = Sequential portion of XID
//
//  BIT ---->       151413121110 9 8 7 6 5 4 3 2 1 0
//  SOA CHECK XID    0 1 1 R R S S S S S S S S R R R
//  IXFR XID         0 1 0 R R S S S S S S S S R R R
//  RECURSION XID    0 0 R R R S S S S S S S S R R R
//  WINS XID         1 R R R R S S S S S S S S R R R
//

#define XID_RANDOM_MASK             0xf807  //  1111 1000 0000 0111
#define XID_SEQUENTIAL_MASK         0x07f8  //  0000 0111 1111 1000
#define XID_SEQUENTIAL_SHIFT        ( 3 )

#define XID_SEQUENTIAL_MAKE(Xid)    ( ((Xid) << XID_SEQUENTIAL_SHIFT) & XID_SEQUENTIAL_MASK )

#define XID_RANDOM_MAKE(Xid)        ( (Xid) & XID_RANDOM_MASK )



//
//  Forwarding info save \ restore
//

#define SAVE_FORWARDING_FIELDS(pMsg)                                        \
{                                                                           \
    PDNS_MSGINFO  pmsg = (pMsg);                                            \
    pmsg->U.Forward.OriginalSocket = pmsg->Socket;                          \
    pmsg->U.Forward.wOriginalXid   = pmsg->Head.Xid;                        \
    DnsAddr_Copy( &pmsg->U.Forward.ipOriginal, &pmsg->RemoteAddr );         \
}

#define RESTORE_FORWARDING_FIELDS(pMsg)                                     \
{                                                                           \
    PDNS_MSGINFO  pmsg = (pMsg);                                            \
    pmsg->Socket                        = pmsg->U.Forward.OriginalSocket;   \
    pmsg->Head.Xid                      = pmsg->U.Forward.wOriginalXid;     \
    DnsAddr_Copy( &pmsg->RemoteAddr, &pmsg->U.Forward.ipOriginal );         \
}

#define COPY_FORWARDING_FIELDS(pMsgTarget, pMsgOriginal)                            \
{                                                                                   \
    pMsgTarget->Head.Xid    = pMsgOriginal->U.Forward.wOriginalXid;                 \
    pMsgTarget->Socket      = pMsgOriginal->U.Forward.OriginalSocket;               \
    DnsAddr_Copy( &pMsgTarget->RemoteAddr, &pMsgOriginal->U.Forward.ipOriginal );   \
}


//
//  Query response resets
//      - turn on additional section processing
//      - other values are clear by default
//

#define SET_MESSAGE_FOR_QUERY_RESPONSE( pMsg )  \
    {                                           \
        (pMsg)->fDoAdditional       = TRUE;     \
    }

//
//  Break into pre\post drop pieces.
//
//  If I do the SET_MESSAGE_FOR_UDP_RECV() before dropping packet,
//  on a quiet net the time may be stale, by the time we actually receive
//  a packet.
//  However if wait until after recv(), then WSARecvFrom() failures that are
//  will hit ASSERT()s on free, checking for issues like NO pRecurseMsg and
//  not on queue.
//  To simplify, do everything before drop, then reset time after drop.
//
//  Before Drop
//      -- Nothing necessary, allocator clears all fields
//
//  After Recv
//      -- Set receive time
//

#define SET_MESSAGE_FIELDS_AFTER_RECV( pMsg )   \
        {                                       \
            (pMsg)->dwQueryTime     = DNS_TIME();   \
        }

//
//  This macro returns the number of seconds since this query was 
//  initially received.
//

#define TIME_SINCE_QUERY_RECEIVED( pMsg )   ( DNS_TIME() - ( pMsg )->dwQueryTime )

//
//  This handy after fail to write IXFR in UDP and need answer normally
//

#define RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg ) \
    {                                           \
        (pMsg)->pCurrent            = (PCHAR)((pMsg)->pQuestion + 1);   \
        (pMsg)->Head.AnswerCount    = 0;        \
        (pMsg)->Compression.cCount  = 0;        \
    }


//
//  Wildcard flag states
//
//  When test wildcard track the result so we don't have to test again before
//  sending NAME_ERROR
//

#define WILDCARD_UNKNOWN            (0)
#define WILDCARD_EXISTS             (0x01)
#define WILDCARD_NOT_AVAILABLE      (0xff)

//  Wildcard check but no write lookup
//  Use when verifying presence of wildcard data for NAME_ERROR \ NO_ERROR
//      determination

#define WILDCARD_CHECK_OFFSET       ((WORD)0xffff)


//
//  RR count reading
//

#define QUESTION_SECTION_INDEX      (0)
#define ANSWER_SECTION_INDEX        (1)
#define AUTHORITY_SECTION_INDEX     (2)
#define ADDITIONAL_SECTION_INDEX    (3)

#define ZONE_SECTION_INDEX          QUESTION_SECTION_INDEX
#define PREREQ_SECTION_INDEX        ANSWER_SECTION_INDEX
#define UPDATE_SECTION_INDEX        AUTHORITY_SECTION_INDEX

#define RR_SECTION_COUNT_HEADER(pHead, section) \
            ( ((PWORD) &pHead->QuestionCount)[section] )

#define RR_SECTION_COUNT(pMsg, section) \
            ( ((PWORD) &pMsg->Head.QuestionCount)[section] )

//
//  RR count writing
//

#define CURRENT_RR_SECTION_COUNT( pMsg )    \
            RR_SECTION_COUNT( pMsg, (pMsg)->Section )


#define SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            ((pMsg)->Section = QUESTION_SECTION_INDEX)

#define SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->Section = ANSWER_SECTION_INDEX)

#define SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->Section = AUTHORITY_SECTION_INDEX)

#define SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->Section = ADDITIONAL_SECTION_INDEX)


#define IS_SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            ((pMsg)->Section == QUESTION_SECTION_INDEX)

#define IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->Section == ANSWER_SECTION_INDEX)

#define IS_SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->Section == AUTHORITY_SECTION_INDEX)

#define IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->Section == ADDITIONAL_SECTION_INDEX)


//
//  Fast AXFR tag
//
//  Alerts MS master that MS secondary, so it can do fast zone transfer.
//

#define DNS_FAST_AXFR_TAG   (0x534d)

#define APPEND_MS_TRANSFER_TAG( pmsg )                                  \
        if ( SrvCfg_fAppendMsTagToXfr )                                 \
        {                                                               \
            *(UNALIGNED WORD *) (pmsg)->pCurrent = DNS_FAST_AXFR_TAG;   \
            (pmsg)->pCurrent += sizeof(WORD);                           \
        }


//
//  Packet reads and writes are unaligned
//

//  Write value to unaligned position in packet

#define WRITE_PACKET_HOST_DWORD(pch, dword)  \
            ( *(UNALIGNED DWORD *)(pch) = htonl(dword) )

#define WRITE_PACKET_NET_DWORD(pch, dword)  \
            ( *(UNALIGNED DWORD *)(pch) = (dword) )

#define WRITE_PACKET_HOST_WORD(pch, word)  \
            ( *(UNALIGNED WORD *)(pch) = htons(word) )

#define WRITE_PACKET_NET_WORD(pch, word)  \
            ( *(UNALIGNED WORD *)(pch) = (word) )

//  Write value and move ptr

#define WRITE_PACKET_HOST_DWORD_MOVEON(pch, dword)  \
            ( WRITE_PACKET_HOST_DWORD(pch, dword), (PCHAR)(pch) += sizeof(DWORD) )

#define WRITE_PACKET_NET_DWORD_MOVEON(pch, dword)  \
            ( WRITE_PACKET_NET_DWORD(pch, dword), (PCHAR)(pch) += sizeof(DWORD) )

#define WRITE_PACKET_HOST_WORD_MOVEON(pch, word)  \
            ( WRITE_PACKET_HOST_WORD(pch, dword), (PCHAR)(pch) += sizeof(WORD) )

#define WRITE_PACKET_NET_WORD_MOVEON(pch, word)  \
            ( WRITE_PACKET_NET_WORD(pch, dword), (PCHAR)(pch) += sizeof(WORD) )


//  Read unaligned value from given position in packet

#define READ_PACKET_HOST_DWORD(pch)  \
            FlipUnalignedDword( pch )

#define READ_PACKET_NET_DWORD(pch)  \
            ( *(UNALIGNED DWORD *)(pch) )

#define READ_PACKET_HOST_WORD(pch)  \
            FlipUnalignedWord( pch )

#define READ_PACKET_NET_WORD(pch)  \
            ( *(UNALIGNED WORD *)(pch) )

//  Read unaligned value and move ptr

#define READ_PACKET_HOST_DWORD_MOVEON(pch)  \
            READ_PACKET_HOST_DWORD( ((PDWORD)pch)++ )

//            ( (dword) = READ_PACKET_HOST_DWORD(pch), (PCHAR)(pch) += sizeof(DWORD) )

#define READ_PACKET_NET_DWORD_MOVEON(pch)  \
            READ_PACKET_NET_DWORD( ((PDWORD)pch)++ )


//            ( (dword) = READ_PACKET_NET_DWORD(pch), (PCHAR)(pch) += sizeof(DWORD) )

#define READ_PACKET_HOST_WORD_MOVEON(pch)  \
            READ_PACKET_HOST_WORD( ((PWORD)pch)++ )

//            ( (word) = READ_PACKET_HOST_WORD(pch), (PCHAR)(pch) += sizeof(WORD) )

#define READ_PACKET_NET_WORD_MOVEON(pch)  \
            READ_PACKET_NET_WORD( ((PWORD)pch)++ )

//            ( (word) = READ_PACKET_NET_WORD(pch), (PCHAR)(pch) += sizeof(WORD) )

#define SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg ) \
    { \
    pMsg->Opt.fInsertOptInOutgoingMsg = \
        pMsg->Opt.wOriginalQueryPayloadSize != 0; \
    pMsg->Opt.wUdpPayloadSize = pMsg->Opt.wOriginalQueryPayloadSize; \
    }

#define SET_SEND_OPT( pMsg ) \
    pMsg->Opt.fInsertOptInOutgoingMsg = TRUE;

#define CLEAR_SEND_OPT( pMsg ) \
    pMsg->Opt.fInsertOptInOutgoingMsg = FALSE;


#endif  // _DNS_MSGINFO_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\ipnotify.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    IpNotify.c

Abstract:

    Domain Name System (DNS) Server

    IP notification thread

Author:

    Jeff Westhead (jwesth)  July, 2002

Revision History:

    jwesth      7/2002      initial implementation

--*/


/****************************************************************************


****************************************************************************/


//
//  Includes
//


#include "dnssrv.h"

#include <iphlpapi.h>


//
//  Globals
//


LONG    g_IpNotifyThreadRunning = 0;


//
//  Functions
//



DNS_STATUS
IpNotify_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    This thread waits for IP change notification and performs appropriate
    action.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DBG_FN( "IpNotify_Thread" )

    DNS_STATUS      status = ERROR_SUCCESS;
    HANDLE          ipNotifyEvent;
    OVERLAPPED      ipNotifyOverlapped;
    HANDLE          ipNotifyHandle = NULL;

    DNS_DEBUG( INIT, ( "%s: thread starting\n", fn ));

    //
    //  Make sure only 1 copy of this thread is ever running.
    //
    
    if ( InterlockedIncrement( &g_IpNotifyThreadRunning ) != 1 )
    {
        DNS_DEBUG( INIT, ( "%s: thread already running\n", fn ));
        goto Done;
    }
    
    //
    //  Register an IP change notification request.
    //

    ipNotifyEvent = CreateEvent(
                        NULL,       //  no security descriptor
                        FALSE,      //  manual reset event
                        FALSE,      //  start signalled
                        NULL );     //  name
    if ( !ipNotifyEvent )
    {
        status = GetLastError();
        DNS_DEBUG( ANY, ( "%s: error %d opening event\n", fn, status ));
        goto Done;
    }

    RtlZeroMemory( &ipNotifyOverlapped, sizeof( ipNotifyOverlapped ) );
    ipNotifyOverlapped.hEvent = ipNotifyEvent;

    status = NotifyAddrChange( &ipNotifyHandle, &ipNotifyOverlapped );
    if ( status != ERROR_IO_PENDING )
    {
        DNS_DEBUG( ANY, ( "%s: error %d opening initial NotifyAddrChange\n", fn, status ));
        ASSERT( status == ERROR_IO_PENDING );
        goto Done;
    }
    
    //
    //  Main thread loop.
    //

    while ( 1 )
    {
        DWORD           waitstatus;
        BOOL            fhaveIpChange;
        DWORD           bytesRecvd = 0;
        HANDLE          waitHandles[ 2 ];
        
        waitHandles[ 0 ] = hDnsShutdownEvent;
        waitHandles[ 1 ] = ipNotifyEvent;
        
        //
        //  Spin protection. 
        //

        waitstatus = WaitForSingleObject( waitHandles[ 0 ], 10000 );
        if ( waitstatus == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( ANY, ( "%s: server termination detected\n", fn ));
            break;
        }
        else if ( waitstatus != WAIT_TIMEOUT )
        {
            //  Wait error - hardcode spin protection sleep.
            DNS_DEBUG( ANY, (
                "%s: unexpected wait code %d in spin protection\n", fn,
                waitstatus ));
            ASSERT( waitstatus == WAIT_TIMEOUT );
            Sleep( 10000 );
        }

        //
        //  Wait for stop event or IP change notification.
        //

        waitstatus = WaitForMultipleObjects( 2, waitHandles, FALSE, INFINITE );
        if ( waitstatus == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( ANY, ( "%s: server termination detected\n", fn ));
            break;
        }
        else if ( waitstatus != WAIT_OBJECT_0 + 1 )
        {
            DNS_DEBUG( ANY, (
                "%s: unexpected wait code %d in spin protection\n", fn,
                waitstatus ));
            ASSERT( waitstatus == WAIT_OBJECT_0 + 1 );
            continue;
        }
        
        //
        //  Receive notification.
        //
        
        fhaveIpChange = GetOverlappedResult(
                            ipNotifyHandle,
                            &ipNotifyOverlapped,
                            &bytesRecvd,
                            TRUE );                     //  wait flag
        if ( !fhaveIpChange )
        {
            status = GetLastError();
            DNS_DEBUG( ANY, (
                "%s: error %d waiting for IP change notification\n", fn,
                status ));
            goto Done;
        }
        
        //
        //  IP notification received!
        //
        
        DNS_DEBUG( INIT, ( "%s: received IP change notification!\n", fn ));

        Sock_ChangeServerIpBindings();
        
        //
        //  Queue up another IP change notification request.
        //

        ipNotifyHandle = NULL;
        ipNotifyOverlapped.hEvent = ipNotifyEvent;
        status = NotifyAddrChange( &ipNotifyHandle, &ipNotifyOverlapped );
        if ( status != ERROR_IO_PENDING )
        {
            DNS_DEBUG( ANY, ( "%s: error %d opening NotifyAddrChange\n", fn, status ));
            ASSERT( status == ERROR_IO_PENDING );
            goto Done;
        }
    }

    Done:
    
    DNS_DEBUG( INIT, ( "%s: thread terminating\n", fn ));

    Thread_Close( FALSE );
    
    InterlockedDecrement( &g_IpNotifyThreadRunning );

    return status;
}   //  IpNotify_Thread


//
//  End IpNotify.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\lock.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lock.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database routines.

Author:

    Jim Gilroy (jamesg)     June 4, 1998

Revision History:

--*/


#include "dnssrv.h"


#if 0

//
//  .NET This does not really buy us much given the features available
//  in current OS and debuggers.
//



//
//  Locking
//
//  Debug lock tracking
//  Keep history of last several (default 256) operation.
//  Keep history of last several operations at a given count
//

typedef struct _LockEntry
{
    LPSTR   File;

    //  note for WIN64, if want simple display, need to squeeze
    //  Line and Thread Id into WORDs to make space for pointer

    DWORD   Line;
    DWORD   ThreadId;
    LONG    Count;
}
LOCK_ENTRY, *PLOCK_ENTRY;

#define LOCK_CHANGE_COUNT_SIZE   (7)

typedef struct _LockTable
{
    LPSTR       pszName;

    //  make the lock entry fields start on 16 byte boundary
    //  for easy viewing in debug
#ifdef _WIN64
    PVOID       pAlignmentDummy;
#else
    DWORD       dwAlignmentDummy[3];
#endif

    DWORD       Index;
    DWORD       Size;
    DWORD       MaxLockTime;
    LONG        CurrentLockCount;

    DWORD       FailuresSinceLockFree;
    DWORD       LastFreeLockTime;
    DWORD       NextAssertFailureCount;
    DWORD       NextAssertLockTime;

    LOCK_ENTRY  OffenderLock;

    //  last change at given count history
    //      +1 on array leaves empty line to simplify debug viewing

    LOCK_ENTRY  LockUpHistory[ LOCK_CHANGE_COUNT_SIZE+1 ];
    LOCK_ENTRY  LockDownHistory[ LOCK_CHANGE_COUNT_SIZE+1 ];

    //  full history of last lock operations

    LOCK_ENTRY  LockHistory[ 1 ];
}
LOCK_TABLE, * PLOCK_TABLE;


//
//  Table defaults
//

#define MAX_LOCKED_TIME     (600)   // 10 minutes

#define LOCK_HISTORY_SIZE   (256)

//
//  Marker
//

#define HISTORY_MARKER  (0xeeeeeeee)



PVOID
Lock_CreateLockTable(
    IN      LPSTR           pszName,
    IN      DWORD           Size,
    IN      DWORD           MaxLockTime
    )
/*++

Routine Description:

    Create lock table.

Arguments:

    pszName -- name of lock table

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable;

    //
    //  allocate lock table
    //      - first fix size
    //

    if ( Size == 0 )
    {
        Size = LOCK_HISTORY_SIZE;
    }

    ptable = (PLOCK_TABLE) ALLOC_TAGHEAP_ZERO(
                                sizeof(LOCK_TABLE) + sizeof(LOCK_ENTRY)*Size,
                                MEMTAG_TABLE );
    IF_NOMEM( !ptable )
    {
        return( NULL );
    }
    ptable->pszName = pszName;
    ptable->Size = Size;

    if ( MaxLockTime == 0 )
    {
        MaxLockTime = MAX_LOCKED_TIME;
    }
    ptable->MaxLockTime = MaxLockTime;
    ptable->LastFreeLockTime = DNS_TIME();

    return( ptable );
}


VOID
Lock_SetLockHistory(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    pLockTable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;
    PLOCK_ENTRY plockEntry;
    DWORD       i;

    if ( !ptable )
    {
        return;
    }

    //  last count up\down history
    //      this tracks changes by lock count so you can
    //      always view last move at a particular count

    if ( Count < 0 )
    {
        i = -Count;
    }
    else
    {
        i = Count;
    }

    if ( i < LOCK_CHANGE_COUNT_SIZE )
    {
        if ( Count > ptable->CurrentLockCount )
        {
            plockEntry = &ptable->LockUpHistory[i];
        }
        else
        {
            plockEntry = &ptable->LockDownHistory[i];
        }
        plockEntry->File        = pszFile;
        plockEntry->Line        = Line;
        plockEntry->Count       = Count;
        plockEntry->ThreadId    = ThreadId;
    }
    ptable->CurrentLockCount = Count;

    //
    //  set full history
    //

    i = ptable->Index;
    plockEntry = &ptable->LockHistory[i];

    plockEntry->File       = pszFile;
    plockEntry->Line       = Line;
    plockEntry->Count      = Count;
    plockEntry->ThreadId   = ThreadId;

    i++;
    if ( i >= ptable->Size )
    {
        i = 0;
    }
    ptable->Index = i;
    plockEntry = &ptable->LockHistory[i];

    plockEntry->File       = (LPSTR) 0;
    plockEntry->Line       = HISTORY_MARKER;
    plockEntry->Count      = HISTORY_MARKER;
    plockEntry->ThreadId   = HISTORY_MARKER;

    //  reset when lock comes clear

    if ( Count == 0 )
    {
        ptable->FailuresSinceLockFree = 0;
        ptable->LastFreeLockTime = DNS_TIME();
    }
}


VOID
Lock_SetOffenderLock(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    ptable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;
    DWORD       i;

    if ( !ptable )
    {
        return;
    }
    i = ptable->Index - 1;

    ptable->OffenderLock.File       = pszFile;
    ptable->OffenderLock.Line       = Line;
    ptable->OffenderLock.Count      = Count;
    ptable->OffenderLock.ThreadId   = ThreadId;

    DNS_PRINT((
        "ERROR:  Lock offense!\n"
        "\toffending thread = %d\n"
        "\t  file           = %s\n"
        "\t  line           = %d\n"
        "\n"
        "\towning thread    = %d\n"
        "\t  file           = %s\n"
        "\t  line           = %d\n"
        "\t  lock count     = %d\n\n",

        ThreadId,
        pszFile,
        Line,
        ptable->LockHistory[ i ].ThreadId,
        ptable->LockHistory[ i ].File,
        ptable->LockHistory[ i ].Line,
        ptable->LockHistory[ i ].Count
        ));
}



VOID
Dbg_LockTable(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      BOOL            fPrintHistory
    )
/*++

Routine Description:

    Debug print database locking info.

Arguments:

    ptable -- lock table to debug

    fPrintHistory -- include lock history

Return Value:

    None

--*/
{
    PLOCK_TABLE     ptable = (PLOCK_TABLE) pLockTable;
    PLOCK_ENTRY     plockHistory;
    DWORD           i = ptable->Index - 1;

    //  protect against 0 index

    if ( i == (DWORD)(-1) )
    {
        i = ptable->Size - 1;
    }
    plockHistory = ptable->LockHistory;

    DnsDebugLock();

    DnsPrintf(
        "Lock %s Info:\n"
        "\tsince last free\n"
        "\t\tfailures   = %d\n"
        "\t\ttime       = %d\n"
        "\t\tcur time   = %d\n"
        "\tcurrent state\n"
        "\tthread       = %d\n"
        "\tlock count   = %d\n"
        "\tfile         = %s\n"
        "\tline         = %d\n"
        "History:\n",
        ptable->pszName,
        ptable->FailuresSinceLockFree,
        ptable->LastFreeLockTime,
        DNS_TIME(),
        plockHistory[ i ].ThreadId,
        plockHistory[ i ].Count,
        plockHistory[ i ].File,
        plockHistory[ i ].Line
        );

    if ( fPrintHistory )
    {
        DnsPrintf(
            "Up Lock History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );

        plockHistory = ptable->LockUpHistory;

        for ( i=0; i<LOCK_CHANGE_COUNT_SIZE; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }

        DnsPrintf(
            "Down Lock History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );

        plockHistory = ptable->LockDownHistory;

        for ( i=0; i<LOCK_CHANGE_COUNT_SIZE; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }

        DnsPrintf(
            "History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );
        for ( i=0; i<ptable->Size; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }
    }

    DnsDebugUnlock();
}


VOID
Lock_FailedLockCheck(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    pLockTable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;

    if ( !ptable )
    {
        return;
    }

    //  set initial ASSERT conditions
    //      - 256 lock failures
    //      - 10 minutes under lock

    if ( ptable->FailuresSinceLockFree == 0 )
    {
        ptable->NextAssertFailureCount = 0x100;
        ptable->NextAssertLockTime = ptable->LastFreeLockTime + ptable->MaxLockTime;
    }

    ptable->FailuresSinceLockFree++;

    if ( ptable->NextAssertLockTime < DNS_TIME() )
    {
        DnsDebugLock();

        DNS_PRINT((
            "WARNING:  Possible LOCK-FAILURE:\n"
            "Failed to lock %s:\n"
            "\tthread       = %d\n"
            "\tfile         = %s\n"
            "\tline         = %d\n",
            ptable->pszName,
            GetCurrentThreadId(),
            pszFile,
            Line
            ));
        Dbg_LockTable(
            pLockTable,
            TRUE            // print lock history
            );
        //ASSERT( FALSE );
        DnsDebugUnlock();

        //  wait an additional 10 minutes before refiring ASSERT

        ptable->NextAssertLockTime += ptable->MaxLockTime;
    }

    else if ( ptable->NextAssertFailureCount > ptable->FailuresSinceLockFree )
    {
        DnsDebugLock();

        DNS_PRINT((
            "WARNING:  Another lock failure on %s:\n"
            "Failed to lock:\n"
            "\tthread       = %d\n"
            "\tfile         = %s\n"
            "\tline         = %d\n",
            ptable->pszName,
            GetCurrentThreadId(),
            pszFile,
            Line
            ));
        Dbg_LockTable(
            pLockTable,
            TRUE            // print lock history
            );
        DnsDebugUnlock();

        //  up failure count for ASSERT by factor of eight

        ptable->NextAssertFailureCount <<= 3;
    }
}

#endif


//
//  End lock.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\memory.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Domain Name System (DNS) Server

    Memory routines declarations.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

--*/

#ifndef _MEMORY_INCLUDED_
#define _MEMORY_INCLUDED_


//
//  Skippable out-of-memory checks
//

#define IF_NOMEM(a)     if (a)


//
//  Private debug heap routines
//

#include    "heapdbg.h"


//
//  Heap global
//

extern HANDLE       hDnsHeap;

//
//  Heap alloc minimal validity check
//

#ifndef IS_QWORD_ALIGNED
#define IS_QWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)7) )
#endif

#ifdef _WIN64
#define IS_DNS_HEAP_DWORD(p)    ( IS_QWORD_ALIGNED(p) )
#else
#define IS_DNS_HEAP_DWORD(p)    ( IS_DWORD_ALIGNED(p) )
#endif


//
//  DnsLib heap routines
//  Standard looking heap functions that can be registered with DnsLib
//

VOID *
Mem_DnslibAlloc(
    IN      INT             iSize
    );

VOID *
Mem_DnslibRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Mem_DnslibFree(
    IN OUT  PVOID           pFree
    );


//
//  Standard Heap Operations
//

BOOL
Mem_HeapInit(
    VOID
    );

VOID
Mem_HeapDelete(
    VOID
    );


#if DBG

BOOL
Mem_HeapMemoryValidate(
    IN      PVOID           pMem
    );

BOOL
Mem_HeapHeaderValidate(
    IN      PVOID           pMemory
    );

#endif

//
//  Heap Routines
//
//  DO NOT directly use these routines.
//
//  Use the covering macros below, which make the correct call for
//  both debug and non-debug situations.
//

PVOID
Mem_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

PVOID
Mem_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

VOID *
Mem_Realloc(
    IN OUT  PVOID           pMem,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

VOID
Mem_Free(
    IN OUT  PVOID           pMem,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define ALLOCATE_HEAP(size)             Mem_Alloc( size, 0, __FILE__, __LINE__ )
#define ALLOCATE_HEAP_ZERO(size)        Mem_AllocZero( size, 0, __FILE__, __LINE__ )

#define REALLOCATE_HEAP(p,size)         Mem_Realloc( (p), (size), 0, __FILE__, __LINE__ )

#define FREE_HEAP(p)                    Mem_Free( (p), 0, 0, __FILE__, __LINE__ )

//  with tagging

#define ALLOC_TAGHEAP( size, tag )      Mem_Alloc( (size), (tag), __FILE__, __LINE__ )
#define ALLOC_TAGHEAP_ZERO( size, tag)  Mem_AllocZero( (size), (tag), __FILE__, __LINE__ )
#define FREE_TAGHEAP( p, len, tag )     Mem_Free( (p), (len), (tag), __FILE__, __LINE__ )


//
//  Tag manipulation
//

DWORD
Mem_GetTag(
    IN      PVOID           pMem
    );

VOID
Mem_ResetTag(
    IN      PVOID           pMem,
    IN      DWORD           MemTag
    );



//
//  Standard allocations
//

BOOL
Mem_IsStandardBlockLength(
    IN      DWORD           Length
    );

BOOL
Mem_IsStandardFreeBlock(
    IN      PVOID           pFree
    );

BOOL
Mem_VerifyHeapBlock(
    IN      PVOID           pMem,
    IN      DWORD           dwTag,
    IN      DWORD           dwLength
    );

#define IS_ON_FREE_LIST(ptr)    (Mem_IsStandardFreeBlock(ptr))

VOID
Mem_WriteDerivedStats(
    VOID
    );
    
DWORD
Mem_GetLastAllocFailureTime(
    VOID
    );


#endif  //  _MEMORY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\name.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Domain Name System (DNS) Server

    Name definitions.

Author:

    Jim Gilroy (jamesg)     May 1998

Revision History:

--*/

#ifndef _NAME_INCLUDED_
#define _NAME_INCLUDED_


//
//  Lookup name definition
//

#define DNS_MAX_NAME_LABELS 40

typedef struct _lookup_name
{
    WORD    cLabelCount;
    WORD    cchNameLength;
    PCHAR   pchLabelArray[ DNS_MAX_NAME_LABELS ];
    UCHAR   cchLabelArray[ DNS_MAX_NAME_LABELS ];
}
LOOKUP_NAME, *PLOOKUP_NAME;


//
//  Raw name is uncompressed packet format (counted label)
//

typedef LPSTR   PRAW_NAME;


//
//  Counted name definition
//

typedef struct _CountName
{
    UCHAR   Length;
    UCHAR   LabelCount;
    CHAR    RawName[ DNS_MAX_NAME_LENGTH+1 ];
}
COUNT_NAME, *PCOUNT_NAME;

#define SIZEOF_COUNT_NAME_FIXED     (sizeof(WORD))

#define COUNT_NAME_SIZE( pName )    ((pName)->Length + sizeof(WORD))

#define IS_ROOT_NAME( pName )       ((pName)->RawName[0] == 0)


//
//  Dbase name
//      - currently setup as COUNT_NAME
//

typedef COUNT_NAME  DB_NAME, *PDB_NAME;

#define SIZEOF_DBASE_NAME_FIXED     SIZEOF_COUNT_NAME_FIXED

#define DBASE_NAME_SIZE( pName )    COUNT_NAME_SIZE(pName)


#endif  // _NAME_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\nameutil.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nameutil.c

Abstract:

    Domain Name System (DNS) Server

    Name processing utilities.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/


#include "dnssrv.h"



//
//  Node name to packet writing utilities
//

PCHAR
FASTCALL
Name_PlaceFullNodeNameInPacket(
    IN OUT  PCHAR               pch,
    IN      PCHAR               pchStop,
    IN      PDB_NODE            pNode
    )
/*++

Routine Description:

    Write domain name to packet.

    This writes FULL domain name -- no compression.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;    // bytes in current label

    if ( !pNode )
    {
        ASSERT( pNode );
        return NULL;
    }

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        ASSERT( pNode->cchLabelLength <= DNS_MAX_LABEL_LENGTH );

        labelLength = pNode->cchLabelLength;

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        if ( pch + labelLength + 1 > pchStop )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing node (%p) name to message\n",
                pNode ));
            return NULL;
        }

        //
        //  write this node's label
        //      - length byte
        //      - return if at root
        //      - otherwise copy label itself
        //

        *pch++ = (UCHAR) labelLength;

        if ( labelLength == 0 )
        {
            return pch;
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );
        pch += labelLength;

        //  get parent node

        pNode = pNode->pParent;
    }
    while ( pNode != NULL );

    //
    //  database error, root not properly identified
    //

    DNS_PRINT((
        "ERROR:  writing name to packet.  Bad root name\n" ));

    ASSERT( FALSE );
    return NULL;
}



PCHAR
FASTCALL
Name_PlaceNodeLabelInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode,
    IN      WORD            wCompressedDomain
    )
/*++

Routine Description:

    Write domain label to packet.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

    wCompressedDomain - compressed domain name

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;     // bytes in current label
    INT writtenCount;         // count bytes written

    //
    //  check length
    //

    ASSERT( pNode->cchLabelLength <= DNS_MAX_LABEL_LENGTH );

    labelLength = pNode->cchLabelLength;

    ASSERT( pNode->cchLabelLength > 0 );

    //
    //  check length
    //      - must handle BYTE for length + length + WORD compressed domain
    //

    if ( pch + sizeof(BYTE) + labelLength + sizeof(WORD) > pchStop )
    {
        return NULL;
    }

    //
    //  this node's label
    //      - length byte
    //      - copy label
    //

    *pch = (UCHAR) labelLength;
    pch++;

    RtlCopyMemory(
        pch,
        pNode->szLabel,
        labelLength );

    pch += labelLength;

    //
    //  write compressed domain name
    //

    * (UNALIGNED WORD *) pch = htons( (WORD)((WORD)0xC000 | wCompressedDomain) );

    return pch + sizeof(WORD);
}



PCHAR
FASTCALL
Name_PlaceNodeNameInPacketWithCompressedZone(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode,
    IN      WORD            wZoneOffset,
    IN      PDB_NODE        pNodeZoneRoot
    )
/*++

Routine Description:

    Write domain name to packet, with compression for zone name.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

    wZoneOffset - offset in packet to compressed zone name

    pNodeZoneRoot - zone root node

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;        // bytes in current label
    INT writtenCount = 0;   // count bytes written

    //
    //  traverse back up database, writing domain name
    //      - go through at least once, writing current label
    //

    while ( pNode != pNodeZoneRoot )
    {
        ASSERT( pNode->cchLabelLength <= DNS_MAX_LABEL_LENGTH );

        labelLength = pNode->cchLabelLength;

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        if ( pch + labelLength + sizeof(BYTE) > pchStop )
        {
            return NULL;
        }

        //
        //  write this node's label
        //      - length byte
        //      - break if at root
        //      - otherwise copy label itself
        //

        *pch = (UCHAR) labelLength;
        pch++;

        if ( labelLength == 0 )
        {
            pNode = NULL;
            break;
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;

        //
        //  get parent node
        //

        pNode = pNode->pParent;
        ASSERT( pNode );
    }

    //
    //  write zone compressed label
    //      - if didn't write all the way to root

    if ( pNode )
    {
        if ( pch + sizeof(WORD) > pchStop )
        {
            return NULL;
        }
        *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000 | wZoneOffset) );
        pch += sizeof(WORD);
    }
    return pch;
}



//
//  Lookup name to packet
//

PCHAR
FASTCALL
Name_PlaceLookupNameInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PLOOKUP_NAME    pLookupName,
    IN      BOOL            fSkipFirstLabel
    )
/*++

Routine Description:

    Write lookup name to packet.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pLookupName -- lookup name to put in packet

    fSkipFirstLabel - flag, TRUE to avoid writing first label;
        used to add domain name (as scope) to WINS lookups

Return Value:

    Number of bytes written.
    Zero on length error.

--*/
{
    INT cchLabel;           // bytes in current label
    INT i;                  // label index
    INT iStart;             // starting name label index

    ASSERT( pch != NULL );
    ASSERT( pLookupName != NULL );
    ASSERT( pLookupName->cchNameLength <= DNS_MAX_NAME_LENGTH );

    //
    //  skip first label?
    //      special case for WINS lookups where domain name used as scope
    //

    iStart = 0;
    if (fSkipFirstLabel )
    {
        iStart = 1;
    }

    //
    //  loop until end of lookup name
    //

    for ( i = iStart;
          i < pLookupName->cLabelCount;
          i++ )
    {
        cchLabel = pLookupName->cchLabelArray[i];

        ASSERT( cchLabel > DNS_MAX_LABEL_LENGTH );

        if ( pch + cchLabel + 1 > pchStop )
        {
            DNS_DEBUG( ANY, ( "Lookupname too long for available packet length\n" ));
            return NULL;
        }

        //  write label count

        *pch = (UCHAR) cchLabel;
        pch++;

        //  write label

        RtlCopyMemory(
            pch,
            pLookupName->pchLabelArray[i],
            cchLabel );

        pch += cchLabel;
    }

    //  NULL terminate
    //      - name terminates with zero label count
    //      - packet has space to allow safe write of this byte
    //          without test

    *pch++ = 0;

    return pch;
}




#if 0
//
//  On second thought name sig idea is goofy --
//  doesn't pay for itself.
//
//  DEVNOTE: So if it's goofy, can we remove this code completely?
//
//  Name signature routines.
//
//  Better signature.
//      Before doing better sig want to nail down pNode
//      downcasing issue so making sig not arduous
//

DWORD
FASTCALL
makeSignatureOnBuffer(
    IN      PCHAR           pchRawName,
    IN      PCHAR           pchNameEnd
    )
/*++

Routine Description:

    Make signature.

    Utility to do final signature writing common to both
    node and raw name signature routines below.

Arguments:

    pchRawName -- ptr to name to make signature for, in buffer
        that can be overwritten

    pchNameEnd -- end of name in buffer, ptr to byte that should
        be terminating NULL, however NULL need not be written
        as this routine writes it here as part of terminating pad

Return Value:

    Signature for name.

--*/
{
    PCHAR       pch;
    DWORD       signature;

    //
    //  signature
    //
    //  name in net format
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    //  NULL terminate and pad DWORD
    //
    //  do not need four bytes, as pchNameEnd is not included in the
    //  sig if it is DWORD aligned -- it's zero adds no value to sig

    pch = (PCHAR) pchNameEnd;
    *pch++ = 0;
    *pch++ = 0;
    *pch++ = 0;

    //  downcase
    //      - can skip if know string already cannonical

    _strlwr( pchRawName );

    //  sum into DWORD

    pch = pchRawName;
    signature = 0;

    while ( pch < pchNameEnd )
    {
        signature += *(PDWORD) pch;
        pch += sizeof(DWORD);
    }

    return( signature );
}



DWORD
FASTCALL
Name_MakeNodeNameSignature(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Make name signature for node.

Arguments:

    pNode -- node to make signature for

Return Value:

    Signature for name of node.

--*/
{
    PDB_NODE    pnodeTemp = pNode;
    PUCHAR      pch;
    UCHAR       labelLength;
    DWORD       signature;
    CHAR        buffer[ DNS_MAX_NAME_LENGTH+50 ];

    ASSERT( pnodeTemp != NULL );

    //
    //  if already have sig -- we're done
    //

    if ( pnodeTemp->dwSignature )
    {
        return( pnodeTemp->dwSignature );
    }

    //
    //  signature
    //
    //  copy name -- in net format to buffer
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    pch = buffer;

    while ( pnodeTemp->pParent )
    {
        labelLength = pnodeTemp->cchLabelLength;
        *pch++ = labelLength;
        RtlCopyMemory(
            pch,
            pnodeTemp->szLabel,
            labelLength );

        pch += labelLength;

        pnodeTemp = pnodeTemp->pParent;
    }

    signature = makeSignatureOnBuffer(
                    buffer,
                    pch );

    //  save signature to node

    pNode->dwSignature = signature;

    DNS_DEBUG( WRITE, (
        "Node (%p) signature %lx\n",
        pNode,
        signature ));

    return( signature );
}



DWORD
FASTCALL
Name_MakeRawNameSignature(
    IN      PCHAR           pchRawName
    )
/*++

Routine Description:

    Make raw name signature.

Arguments:

    pchRawName -- ptr to name to make signature for

Return Value:

    Signature for name.

--*/
{
    DWORD       signature;
    DWORD       len;
    CHAR        buffer[ DNS_MAX_NAME_LENGTH+50 ];

    ASSERT( pchRawName != NULL );

    //
    //  signature
    //
    //  copy name -- in net format to buffer
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    len = strlen( pchRawName );

    RtlCopyMemory(
        buffer,
        pchRawName,
        len );

    signature = makeSignatureOnBuffer(
                    buffer,
                    buffer + len );

    DNS_DEBUG( WRITE, (
        "Raw name (%p) signature %lx\n",
        pchRawName,
        signature ));

    return( signature );
}



DWORD
FASTCALL
Name_MakeNameSignature(
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Make name signature.

Arguments:

    pName -- name to make signature for

Return Value:

    Signature for name.

--*/
{
    return  Name_MakeRawNameSignature( pName->RawName );
}
#endif



//
//  Node name to packet writing utilities
//

BOOL
FASTCALL
Name_IsNodePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Check if name in packet matches a given node.

Arguments:

    pMsg -- ptr to message

    pchPacket -- ptr to name in message

    pNode -- node to check if matches name

Return Value:

    TRUE if node matches name.
    FALSE if not a match.

--*/
{
    UCHAR   labelLength;

    DNS_DEBUG( WRITE, (
        "Name_IsNodePacketName( pMsg=%p, ptr=%p, pnode=%p )\n",
        pMsg,
        pchPacket,
        pNode ));

    //
    //  loop back through packet name and up through pNode
    //      - either fail a label match
    //      - or reach root, in which case have compression match
    //

    while( 1 )
    {
        //  grab label length and position pch at label
        //  if encounter offset, drop to actual packet label
        //      and recheck for offset

        while( 1 )
        {
            //  must always be looking BACK in the packet

            if ( pchPacket >= pMsg->pCurrent )
            {
                ASSERT( FALSE );
                return( FALSE );
            }

            labelLength = (UCHAR) *pchPacket++;

            if ( (labelLength & 0xC0) == 0 )
            {
                //  name not offset
                break;
            }
            pchPacket = DNSMSG_PTR_FOR_OFFSET(
                            pMsg,
                            (((WORD)(labelLength&0x3f) << 8) + *pchPacket) );
        }

        if ( pNode->cchLabelLength != labelLength )
        {
            return( FALSE );
        }
        if ( _strnicmp( pchPacket, pNode->szLabel, labelLength ) != 0 )
        {
            return( FALSE );
        }

        //  move to parent node, and continue check

        pNode = pNode->pParent;
        if ( pNode->pParent )
        {
            pchPacket += labelLength;
            continue;
        }

        //  at root node

        break;
    }

    //  at root node
    //      - if packet name at root -- success
    //      - if not -- no match

    ASSERT( pNode->cchLabelLength == 0 );

    return( *pchPacket == 0 );
}



BOOL
FASTCALL
Name_IsRawNamePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchRawName
    )
/*++

Routine Description:

    Check if name in packet matches a given node.

Arguments:

    pMsg -- ptr to message

    pchPacket -- ptr to name in message

    pchRawName -- ptr to name in raw wire format

Return Value:

    TRUE if node matches name.
    FALSE if not a match.

--*/
{
    UCHAR   labelLength;

    DNS_DEBUG( WRITE, (
        "Name_IsRawNamePacketName( pMsg=%p, ptr=%p, pchRaw=%p )\n",
        pMsg,
        pchPacket,
        pchRawName ));

    //
    //  loop back through packet name and up through pRawName
    //      - either fail a label match
    //      - or reach root, in which case have compression match
    //

    while( 1 )
    {
        //  grab label length and position pch at label
        //  if encounter offset, drop to actual packet label
        //      and recheck for offset

        while( 1 )
        {
            //  protect against out-of-packet access
            //  note:  unlike node checking routine above, can't use pCurrent
            //      as when writing SOA names, may legitimately be checking the
            //      the first name when writing the second

            if ( pchPacket >= pMsg->pBufferEnd )
            {
                ASSERT( FALSE );
                return( FALSE );
            }

            labelLength = *pchPacket++;

            if ( (labelLength & 0xC0) == 0 )
            {
                //  name not offset
                break;
            }
            pchPacket = DNSMSG_PTR_FOR_OFFSET(
                            pMsg,
                            (((WORD)(labelLength&0x3f) << 8) + (UCHAR)*pchPacket) );
        }

        if ( *pchRawName++ != labelLength )
        {
            return( FALSE );
        }

        //  at root -- success
        //      - with test here, we've already verified both at root label

        if ( labelLength == 0 )
        {
            return( TRUE );
        }

        if ( _strnicmp( pchPacket, pchRawName, labelLength ) != 0 )
        {
            return( FALSE );
        }

        //  move to next label, and continue check

        pchRawName += labelLength;
        pchPacket += labelLength;
    }

    ASSERT( FALSE );        // unreachable
}



PCHAR
FASTCALL
Name_PlaceNodeNameInPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR           pch,
    IN      PDB_NODE        pNode,
    IN      BOOL            fUseCompression
    )
/*++

Routine Description:

    Write domain name to packet.

Arguments:

    pch - location to write name

    cAvailLength - available length remaining in packet

    pnodeTemp - node in database of domain name to write

Return Value:

    Number of bytes written.
    Zero on length error.

--*/
{
    PDB_NODE    pnodeCheck = pNode;
    INT         labelLength;     // bytes in current label
    INT         i;
    INT         compressCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;

    ASSERT( pnodeCheck != NULL );

    //
    //  same as previous node?
    //
    //  this is very frequent case -- special casing here allows
    //  us to throw out code to track this in higher level functions;
    //
    //  implementation note:  it is easier to insure that previous node
    //  is available by having special entry in compression blob, than to
    //  handle in compression array;  (last entry doesn't work, if you want
    //  compression for higher nodes in tree corresponding to a name);
    //  it is also more efficient as we avoid going through array, or even
    //  intializing array lookup
    //

    if ( pMsg->Compression.pLastNode == pNode )
    {
        *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                            | pMsg->Compression.wLastOffset) );
        pch += sizeof(WORD);

        DNS_DEBUG( WRITE2, (
            "Wrote same-as-previous node (%p) to message %p\n"
            "    original offset %04x;  compression at %04x\n",
            pNode,
            pMsg,
            pMsg->Compression.wLastOffset,
            pch - sizeof(WORD) ));
        return pch;
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //  can not be writing first RR and have existing compression list

    ASSERT( pch != pMsg->MessageBody || compressCount == 0 );

    //
    //  traverse back up database, writing complete domain name
    //

    while( 1 )
    {
        DWORD       offset;
        
        //
        //  Compression cannot be used if we are beyond the limit of DNS
        //  compression within the packet.
        //
        
        if ( fUseCompression &&
             DNSMSG_CURRENT_OFFSET_DWORD( pMsg ) >
                DNSSRV_MAX_COMPRESSION_OFFSET )
        {
            fUseCompression = FALSE;
        }

        //
        //  break from loop when reach root
        //      no need to check or save compression of root
        //

        labelLength = pnodeCheck->cchLabelLength;
        if ( labelLength == 0 )
        {
            ASSERT( !pnodeCheck->pParent );
            *pch++ = 0;      // length byte
            break;
        }

        //
        //  use compression if this node already in packet
        //

        if ( fUseCompression )
        {
            //  check for direct node match
            //      - start check with nodes written before call to function

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressNode[i] == pnodeCheck )
                {
                    goto UseCompression;
                }
            }

            //
            //  check all other offsets
            //      - ignore one's with nodes
            //      - first match name depth
            //      - then attempt to match packet name
            //

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressNode[i] )
                {
                    continue;
                }
                if ( compressDepth[i] != pnodeCheck->cLabelCount )
                {
                    continue;
                }
                if ( ! Name_IsNodePacketName(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET( pMsg, compressOffset[i] ),
                        pnodeCheck ) )
                {
                    continue;
                }

                //  matched name
                goto UseCompression;
            }
        }

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        if ( pch + labelLength + sizeof(BYTE) > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing node (%p) name to message\n",
                pnodeCheck ));
            return NULL;
        }

        //
        //  save compression for node
        //
        //  DEVNOTE: should have flag to compress ONLY the top node
        //      (as in SOA fields for IXFR) rather than every node
        //      in name
        //
        //  DEVNOTE: also way to compress ONLY domain names -- i.e.
        //      everything BELOW given node
        //      this will be useful during XFR to compress domains but
        //      not individual nodes
        //

        offset = DNSMSG_OFFSET_DWORD( pMsg, pch );
        if ( offset < DNSSRV_MAX_COMPRESSION_OFFSET &&
             offset > 0 &&
             !pMsg->fNoCompressionWrite &&
             compressCount < MAX_COMPRESSION_COUNT )
        {
            compressOffset[compressCount]   = ( WORD ) offset;
            compressNode[compressCount]     = pnodeCheck;
            compressDepth[compressCount]    = pnodeCheck->cLabelCount;
            compressCount++;
        }

        //
        //  always save last node written
        //  this is the high percentage case (of compressable nodes)
        //      see comment above
        //

        if ( pnodeCheck == pNode )
        {
            pMsg->Compression.pLastNode = pnodeCheck;
            pMsg->Compression.wLastOffset = DNSMSG_OFFSET(pMsg, pch);
        }

        //
        //  write the name
        //      - length
        //      - label
        //      - position current pointer after name
        //

        *pch++ = (UCHAR) labelLength;

        RtlCopyMemory(
            pch,
            pnodeCheck->szLabel,
            labelLength );

        pch += labelLength;

        //
        //  get parent node
        //      - should always have parent as root node kicks us out above
        //

        pnodeCheck = pnodeCheck->pParent;
        ASSERT( pnodeCheck );
    }

    goto Done;


UseCompression:

    //
    //  use existing compression
    //      - verify compressing to PREVIOUS name in packet
    //      - write compression, reset packet ptr
    //

    ASSERT( DNSMSG_OFFSET(pMsg, pch) > (INT)compressOffset[i] );

    *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                        | compressOffset[i]) );
    pch += sizeof(WORD);

    //  if no node associated with offset -- add it
    //  this speeds reuse of names written by packet RR data;
    //  overwrite,  because if different node exists, better
    //  to have most recent anyway, as another RR write may
    //  immediately follow

    compressNode[i] = pnodeCheck;


Done:

    //  save new compression count to packet

    pMsg->Compression.cCount = compressCount;

    IF_DEBUG( WRITE2 )
    {
        Dbg_Compression( "Compression after writing node:\n", pMsg );
    }
    return pch;
}



PCHAR
Name_WriteCountNameToPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pch,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fUseCompression
    )
/*++

Routine Description:

    Writes packet name to counted name format.

    Note similarity to routine above.  Only differences are
    name vs. node as sig\label source, and lack of storage
    or "last node" reference.  If changes required here, check
    above routine also.

Arguments:

    pMsg        - ptr to message

    pch         - postion in message to write name

    pName       - dbase name to write

    fUseCompression - TRUE if compression allowed

Return Value:

    Ptr to next position in buffer, if successful.
    NULL on error (truncation).

--*/
{
    PUCHAR      pchlabel;
    INT         labelLength;     // bytes in current label
    UCHAR       labelCount;
    INT         i;
    DWORD       signature;
    INT         compressCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;


    ASSERT( pName != NULL );

    //
    //  neither using or saving compression?
    //      => flat write
    //

    if ( !fUseCompression && !pMsg->fNoCompressionWrite )
    {
        PCHAR   pchafterName;

        pchafterName = pch + pName->Length;
        if ( pchafterName > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing name (%s) name to message\n",
                pName ));
            return NULL;
        }

        RtlCopyMemory(
            pch,
            pName->RawName,
            pName->Length );

        return( pchafterName );
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //  can not be writing first RR and have existing compression list

    ASSERT( pch != pMsg->MessageBody || compressCount == 0 );


    //
    //  traverse back through name a label at a time
    //      - check for compression (if desired)
    //      - write label
    //      - save compression (if desired)
    //

    pchlabel = pName->RawName;
    labelCount = pName->LabelCount;

    while( 1 )
    {
        //
        //  break from loop when reach root
        //      no need to check or save compression of root
        //

        labelLength = (UCHAR) *pchlabel;
        if ( labelLength == 0 )
        {
            *pch++ = 0;      // length byte
            goto Done;
        }

        //
        //  use compression if this node already in packet
        //

        if ( fUseCompression )
        {
            //
            //  check for matching name in compress list
            //      - start check with nodes written before call to function
            //      - check name depth first
            //      - then full name compare
            //

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressDepth[i] != labelCount )
                {
                    continue;
                }
                if ( ! Name_IsRawNamePacketName(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET( pMsg, compressOffset[i] ),
                        pchlabel ) )
                {
                    continue;
                }

                //  matched name
                goto UseCompression;
            }
        }

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        if ( pch + labelLength + sizeof(BYTE) > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing name (%p) to message (%p)\n",
                pName,
                pMsg ));
            return NULL;
        }

        //
        //  save compression for name
        //
        //  DEVNOTE:  should have flag to compress ONLY the top node
        //      (as in SOA fields for IXFR) rather than every node
        //      in name
        //
        //  DEVNOTE:  also way to compress ONLY domain names -- i.e.
        //      everything BELOW given node
        //      this will be useful during XFR to compress domains but
        //      not individual nodes
        //

        if ( !pMsg->fNoCompressionWrite &&
            compressCount < MAX_COMPRESSION_COUNT )
        {
            compressOffset[compressCount]   = (WORD)DNSMSG_OFFSET(pMsg, pch);
            compressNode[compressCount]     = NULL;
            compressDepth[compressCount]    = labelCount;
            compressCount++;
        }

        //
        //  write the label
        //      - length
        //      - label
        //      - position current pointer after name
        //      - position label pointer at next label
        //

        *pch++ = (UCHAR) labelLength;
        pchlabel++;

        RtlCopyMemory(
            pch,
            pchlabel,
            labelLength );

        pch += labelLength;
        pchlabel += labelLength;

        //  drop label count -- need to compare next label

        labelCount--;
        ASSERT( labelCount >= 0 );
    }

    //  unreachable
    ASSERT( FALSE );


UseCompression:

    //
    //  use existing compression
    //      - verify compressing to PREVIOUS name in packet
    //      - write compression, reset packet ptr
    //

    ASSERT( DNSMSG_OFFSET(pMsg, pch) > (INT)compressOffset[i] );

    *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                        | compressOffset[i]) );
    pch += sizeof(WORD);


Done:

    //  save new compression count to packet

    pMsg->Compression.cCount = compressCount;

    IF_DEBUG( WRITE2 )
    {
        Dbg_Compression( "Compression after writing name:\n", pMsg );
    }
    return pch;
}



//
//  Compression utilities
//

VOID
Name_SaveCompressionForLookupName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PLOOKUP_NAME    pLookname,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Save lookup name (for question), to packet.

Arguments:

    pch - location to write name

    pLookname - lookup name for question

    pNode - node for lookup name

Return Value:

    None

--*/
{
    INT         ilabel;
    INT         compressCount;
    UCHAR       labelCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;

    ASSERT( pNode != NULL );

    IF_DEBUG( READ )
    {
        Dbg_Compression( "Enter Name_SaveLookupNameCompression():\n", pMsg );
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //
    //  traverse back up database, saving complete domain name
    //

    ilabel = 0;
    labelCount = (UCHAR) pLookname->cLabelCount;

    while ( labelCount )
    {
        //
        //  If our ducks are all in a row pNode will never be NULL but
        //  let's play it safe and check anyways.
        //
        
        if ( !pNode )
        {
            ASSERT( pNode );
            goto Done;
        }
        
        ASSERT( (PBYTE)DNS_HEADER_PTR(pMsg) < (pLookname->pchLabelArray[ilabel]) );
        ASSERT( (PBYTE)pMsg->pBufferEnd > (pLookname->pchLabelArray[ilabel]) );

        if ( compressCount >= MAX_COMPRESSION_COUNT )
        {
            Dbg_LookupName(
                "WARNING:  Unable to write compressionn for lookup name",
                pLookname );
            DNS_PRINT((
                "WARNING:  Unable to write compressionn for lookup name"
                "    current compression count = %d\n"
                "    starting compression count = %d\n",
                compressCount,
                pMsg->Compression.cCount ));
            goto Done;
        }

        //
        //  save compression for this node
        //      - note offset is to one byte less than label ptr to account
        //        for count byte
        //

        compressNode[compressCount] = pNode;
        compressOffset[compressCount] = (WORD)
                DNSMSG_OFFSET( pMsg, (pLookname->pchLabelArray[ilabel] - 1) );
        compressDepth[compressCount] = labelCount--;

        pMsg->Compression.cCount = ++compressCount;

        ilabel++;

        //  get parent node
        //      - should always have parent as root node kicks us out above

        pNode = pNode->pParent;
        ASSERT( pNode );
    }

    //  one leaving should be at root node, which is NOT in lookup name
    //  and which we do not save

    ASSERT( pNode && !pNode->pParent );

    IF_DEBUG( READ )
    {
        Dbg_Compression( "Lookup name compression saved:\n", pMsg );
    }
    
    Done:
    
    return;
}   //  Name_SaveCompressionForLookupName



VOID
FASTCALL
Name_SaveCompressionWithNode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PDB_NODE        pNode       OPTIONAL
    )
/*++

Routine Description:

    Save compression at a node.

    Currently using this routine in reset function, so
    pNode for question may not exist.

Arguments:

    pMsg -- ptr to message

    pchPacketName -- name in packet

    pNode -- node corresponding to packet name

Return Value:

    None

--*/
{
    DWORD   i;
    UCHAR   labelCount;

    ASSERT( pchPacketName );

    //  if compression list full, save node as last ptr as
    //      last node is most commonly compressed name

    i = pMsg->Compression.cCount;
    if ( i >= MAX_COMPRESSION_COUNT )
    {
        ASSERT( i == MAX_COMPRESSION_COUNT );
        i--;
    }

    pMsg->Compression.pNodeArray[i] = pNode;
    pMsg->Compression.wOffsetArray[i] = (WORD) DNSMSG_OFFSET( pMsg, pchPacketName );

    //  name's label count
    //      - if no node, zero
    //
    //  DEVNOTE:  get label count if offset, but no name given
    //      only use of this routine in that manner is on packet reset

    labelCount = 0;
    if ( pNode )
    {
        labelCount = pNode->cLabelCount;
    }
    pMsg->Compression.chDepthArray[i] = labelCount;
    pMsg->Compression.cCount = ++i;

    DNS_DEBUG( DATABASE, (
        "Saving compression to node at %p, offset %x\n",
        pNode,
        (WORD) DNSMSG_OFFSET( pMsg, pchPacketName ) ));
}



PDB_NODE
FASTCALL
Name_CheckCompressionForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Check name for previously retrieved node in compression table.

Arguments:

    pMsg -- ptr to message

    pchPacketName -- name in packet

Return Value:

    Ptr to node matching packet name -- if found.
    NULL otherwise.

--*/
{
    PDB_NODE    pnode;
    WORD        offset;
    DWORD       i;

    offset = FlipUnalignedWord( pchPacketName );
    if ( (offset & 0xC000) == 0xC000 )
    {
        offset &= 0x4fff;

        //  matching "LastNode"?
        //      - only valid when pLastNode exists

        if ( offset == pMsg->Compression.wLastOffset &&
            pMsg->Compression.pLastNode )
        {
            return( pMsg->Compression.pLastNode );
        }

        //  match any node in compression list

        i = pMsg->Compression.cCount;

        while ( i-- )
        {
            if ( offset == pMsg->Compression.wOffsetArray[i] &&
                (pnode = pMsg->Compression.pNodeArray[i]) )
            {
                return( pnode );
            }
        }
    }
    return NULL;
}



#if DBG
VOID
Dbg_Compression(
    IN      LPSTR           pszHeader,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Debug print compression info.

Arguments:

Return Value:

    None

--*/
{
    DWORD       i;
    PDB_NODE    pnode;

    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( pszHeader );
    }
    DnsPrintf(
        "Compression for packet at %p\n"
        "    count = %d\n",
        pMsg,
        pMsg->Compression.cCount );

    //
    //  print compression list
    //

    for( i=0;  i < pMsg->Compression.cCount;  i++ )
    {
        pnode = pMsg->Compression.pNodeArray[i];

        DNS_PRINT((
            "    [%2d] Offset %04x, Depth %d, Node %p (%s)\n",
            i,
            pMsg->Compression.wOffsetArray[i],
            pMsg->Compression.chDepthArray[i],
            pnode,
            pnode ? pnode->szLabel : NULL ));
    }

    DnsDebugUnlock();
}

#endif  // DBG



//
//  Reverse lookup node utility
//

BOOL
Name_GetIpAddressForReverseNode(
    IN      PDB_NODE        pNodeReverse,
    OUT     PDNS_ADDR       pIpAddress
    )
/*++

Routine Description:

    Build IP address for reverse lookup node.
    
    Note: the Length field of pIpAddress is set based on mask found. 

Arguments:

    pNodeReverse -- node in reverse lookup domain

    pIpAddress -- addr to write mask for IP address;  this is a mask of
        bits that are significant in the address, useful for reverse lookup
        domain nodes, which will not contain complete IP address

Return Value:

    TRUE if successful.

--*/
{
    PDB_NODE    pnodeLastWrite; // last node written
    IP_ADDRESS  ip = 0;
    DWORD       mask = 0;
    ULONG       octet;
    BOOL        ip6 = FALSE;

    ASSERT( pNodeReverse != NULL );

    DNS_DEBUG( LOOKUP2, ( "Getting IP for reverse lookup node\n" ));

    //
    //  Verify the node is reverse lookup domain.
    //

    ip6 = Dbase_IsNodeInReverseIP6LookupDomain(
                pNodeReverse,
                DATABASE_FOR_CLASS( DNS_RCLASS_INTERNET ) );

    if ( !ip6 &&
         !Dbase_IsNodeInReverseIP4LookupDomain(
                pNodeReverse,
                DATABASE_FOR_CLASS( DNS_RCLASS_INTERNET ) ) )
    {
        if ( pNodeReverse == DATABASE_ARPA_NODE )
        {
            goto Done;
        }
        return FALSE;
    }

    //
    //  Walk back through nodes until hit in-addr.arpa domain.
    //

    if ( !ip6 )
    {
        pnodeLastWrite = DATABASE_REVERSE_NODE;

        while ( pNodeReverse != pnodeLastWrite )
        {
            //  current ip and mask shift down, write node label to high octet

            mask += 8;      //  Add another 8 bits of mask.

            octet = strtoul( pNodeReverse->szLabel, NULL, 10 );

            if ( octet > 0xff )
            {
                DNS_PRINT((
                    "Invalid node label %s in reverse lookup zone!\n",
                    pNodeReverse->szLabel ));

                ASSERT( octet <= 0xff );
                return FALSE;
            }
            ip >>= 8;
            ip |= octet << 24;

            //  get parent

            pNodeReverse = pNodeReverse->pParent;
        }
    }

    //
    //  Write mask to zone. This is unused currently. For IP6
    //  leave mask zero.
    //

    Done:

    if ( ip6 )
    {
        pIpAddress->SubnetLength = 0;
    }
    else
    {
        DnsAddr_BuildFromIp4( pIpAddress, ip, 0 );
        pIpAddress->SubnetLength = mask;
    }
    
    return TRUE;
}



//
//  RPC buffer writing utilities
//

PCHAR
FASTCALL
Name_PlaceNodeNameInBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    )
/*++

Routine Description:

    Write domain name to buffer.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pNodeStop - node to stop writing at;
        OPTIONAL, if not given or not ancestor of pNode then FQDN is
        written to buffer

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        DNS_DEBUG(ANY, ("Invalid buffer in Name_PlaceNodeNameInBuffer()\n"
                        "    pch = %p\n"
                        "    pchBufEnd = %p\n",
                        pch, pchBufEnd));

        ASSERT(FALSE);
        return NULL;
    }

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        //  break from loop if reach stop node
        //      - remove terminating dot since this is relative name
        //      - if writing stop node (zone root) itself, write '@'

        if ( pNode == pNodeStop )
        {
            if ( pch > pchBuf )
            {
                --pch;
                ASSERT( *pch == '.' );
                break;
            }
            else
            {
                ASSERT( pNodeStop );
                *pch++ = '@';
                break;
            }
        }

        //  check length rr
        //      - must handle length and a BYTE for "."

        labelLength = pNode->cchLabelLength;
        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        if ( pch + labelLength + 1 > pchBufEnd )
        {
            DNS_DEBUG(ANY, ("Node full name exceeds limit:\n"
                            "    pch = %p; labelLength = %d; pchBufEnd = %p\n"
                            "    pNode = %p; pNodeStop = %p\n",
                            pch, labelLength, pchBufEnd, pNode, pNodeStop));
            return NULL;
        }

        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            if ( pch == pchBuf )
            {
                *pch++ = '.';
            }
            break;
        }

        //  write the node label
        //  write separating dot

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;
        *pch++ = '.';

        //  move up to parent node
    }
    while ( pNode = pNode->pParent );

    //  root should break loop, not pNode = NULL

    ASSERT( pNode );

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote name %s (len=%d) into buffer at postion %p\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return pch;
}



PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain name to RPC buffer.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after RPC buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in buffer.
    NULL if out of buffer.  Sets last error to ERROR_MORE_DATA.

--*/
{
    PCHAR   pchstart;       // starting position
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pchstart = pch;
    pch++;

    //
    //  write full node name to buffer
    //

    pch = Name_PlaceNodeNameInBuffer(
                pch,
                pchStop,
                pNode,
                NULL );         //  FQDN
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return NULL;
    }
    ASSERT( pch <= pchStop );

    //
    //  write name length byte
    //      - do NOT count terminating NULL
    //

    ASSERT( *pch == 0 );
    ASSERT( (pch - pchstart - 1) <= MAXUCHAR );

    *pchstart = (CHAR)(UCHAR)(pch - pchstart - 1);

    return pch;
}



PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain node label to RPC buffer.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after RPC buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in buffer.
    NULL if out of buffer.  Sets last error to ERROR_MORE_DATA.

--*/
{
    PCHAR   pchstart;           // starting position
    INT     labelLength;     // bytes in current label


    DNS_DEBUG( RPC2, ( "Name_PlaceNodeLabelInBuffer\n" ));

    //
    //  first byte will contain name length, skip it
    //

    pchstart = pch;
    pch++;

    //
    //  writing node's label
    //

    labelLength = pNode->cchLabelLength;
    ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

    //
    //  check length
    //      - length byte, label length, terminating NULL
    //

    if ( pch + labelLength + 2 > pchStop )
    {
        SetLastError( ERROR_MORE_DATA );
        return NULL;
    }

    //
    //  write the name, NULL terminated
    //

    RtlCopyMemory(
        pch,
        pNode->szLabel,
        labelLength );

    pch += labelLength;
    *pch = 0;

    //
    //  write name length byte
    //  do NOT include terminating NULL
    //

    ASSERT( (pch - pchstart - 1) <= MAXUCHAR );
    *pchstart = (CHAR)(UCHAR)(pch - pchstart - 1);

    DNS_DEBUG( RPC2, (
        "Wrote name %s (len=%d) into buffer at postion %p\n",
        pchstart + 1,
        *pchstart,
        pchstart ));

    return pch;
}



//
//  File name\string read\write utilies.
//
//  These routines handle the name conversion issues relating to
//  writing names and strings in flat ANSI files
//      -- special file characters
//      -- quoted string
//      -- character quotes for special characters and unprintable chars
//
//  The character to char properties table allows simple mapping of
//  a character to its properties saving us a bunch of compare\branch
//  instructions in parsing file names\strings.
//
//  See nameutil.h for specific properties.
//

WORD    DnsFileCharPropertyTable[] =
{
    //  control chars 0-31 must be octal in all circumstances
    //  end-of-line and tab characters are special

    FC_NULL,                // zero special on read, some RPC strings NULL terminated

    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,

    FC_TAB,                 // tab
    FC_NEWLINE,             // line feed
    FC_OCTAL,
    FC_OCTAL,
    FC_RETURN,              // carriage return
    FC_OCTAL,
    FC_OCTAL,

    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,

    FC_BLANK,               // blank, special char but needs octal quote

    FC_NON_RFC,             // !
    FC_QUOTE,               // " always must be quoted
    FC_NON_RFC,             // #
    FC_NON_RFC,             // $
    FC_NON_RFC,             // %
    FC_NON_RFC,             // &
    FC_NON_RFC,             // '

    FC_SPECIAL,             // ( datafile line extension
    FC_SPECIAL,             // ) datafile line extension
    FC_NON_RFC,             // *
    FC_NON_RFC,             // +
    FC_NON_RFC,             // ,
    FC_RFC,                 // - RFC for hostname
    FC_DOT,                 // . must quote in names
    FC_NON_RFC,             // /

    // 0 - 9 RFC for hostname

    FC_NUMBER,  FC_NUMBER,  FC_NUMBER,  FC_NUMBER,
    FC_NUMBER,  FC_NUMBER,  FC_NUMBER,  FC_NUMBER,
    FC_NUMBER,  FC_NUMBER,

    FC_NON_RFC,             // :
    FC_SPECIAL,             // ;  datafile comment
    FC_NON_RFC,             // <
    FC_NON_RFC,             // =
    FC_NON_RFC,             // >
    FC_NON_RFC,             // ?
    FC_NON_RFC,             // @

    // A - Z RFC for hostname

    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,

    FC_NON_RFC,             // [
    FC_SLASH,               // \ always must be quoted
    FC_NON_RFC,             // ]
    FC_NON_RFC,             // ^
    FC_NON_RFC,             // _
    FC_NON_RFC,             // `

    // a - z RFC for hostname

    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,

    FC_NON_RFC,             // {
    FC_NON_RFC,             // |
    FC_NON_RFC,             // }
    FC_NON_RFC,             // ~
    FC_OCTAL,               // 0x7f DEL code

    // high chars
    //
    // DEVNOTE: could either be considered printable or octal

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH
};



VOID
Name_VerifyValidFileCharPropertyTable(
    VOID
    )
/*++

Routine Description:

    Verify haven't broken lookup table.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT( DnsFileCharPropertyTable[0]       == FC_NULL      );
    ASSERT( DnsFileCharPropertyTable['\t']    == FC_TAB       );
    ASSERT( DnsFileCharPropertyTable['\n']    == FC_NEWLINE   );
    ASSERT( DnsFileCharPropertyTable['\r']    == FC_RETURN    );
    ASSERT( DnsFileCharPropertyTable[' ']     == FC_BLANK     );
    ASSERT( DnsFileCharPropertyTable['"']     == FC_QUOTE     );
    ASSERT( DnsFileCharPropertyTable['(']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable[')']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable['-']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable['.']     == FC_DOT       );
    ASSERT( DnsFileCharPropertyTable['0']     == FC_NUMBER    );
    ASSERT( DnsFileCharPropertyTable['9']     == FC_NUMBER    );
    ASSERT( DnsFileCharPropertyTable[';']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable['A']     == FC_UPPER     );
    ASSERT( DnsFileCharPropertyTable['Z']     == FC_UPPER     );
    ASSERT( DnsFileCharPropertyTable['\\']    == FC_SLASH     );
    ASSERT( DnsFileCharPropertyTable['a']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable['z']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable[0x7f]    == FC_OCTAL     );
    ASSERT( DnsFileCharPropertyTable[0xff]    == FC_OCTAL     );
};



//
//  File writing utilities
//

PCHAR
FASTCALL
File_PlaceStringInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      DWORD           dwFlag,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Write string to file

Arguments:

    pchBuf      - location to write name

    pchBufStop  - buffers stop byte (byte after buffer)

    dwFlag      - flag for type of string write
        FILE_WRITE_NAME_LABEL
        FILE_WRITE_QUOTED_STRING
        FILE_WRITE_DOTTED_NAME
        FILE_WRITE_FILE_NAME

    pchString   - string to write

    dwStringLength - string length

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL on out of space error.

    For file names, force quote if name contains a space char.

--*/
{
    PCHAR   pch;
    UCHAR   ch;
    WORD    charType;
    WORD    octalMask;
    WORD    quoteMask;
    WORD    mask;
    BOOL    fForceQuote = FALSE;

    pch = pchBuf;

    //
    //  check buffer length
    //  to avoid a bunch of code, just verify we're ok even with
    //  maximum expansion of all characters ( 4 times, character to octal <\ddd> )
    //

    if ( pch + 4*dwStringLength + 1 >= pchBufEnd )
    {
        return NULL;
    }

    //
    //  name label
    //      - must quote special chars (ex ();)
    //

    if ( dwFlag == FILE_WRITE_NAME_LABEL )
    {
        octalMask = B_PRINT_TOKEN_OCTAL;
        quoteMask = B_PRINT_TOKEN_QUOTED;
    }

    //
    //  quoted string -- all printable characters (except quoting slash) write
    //

    else if ( dwFlag == FILE_WRITE_QUOTED_STRING )
    {
        octalMask = B_PRINT_STRING_OCTAL;
        quoteMask = B_PRINT_STRING_QUOTED;
        *pch++ = QUOTE_CHAR;
    }

    //
    //  zone and file names in boot file
    //      - unlike name, must print "." directly (not-quoted)
    //      - same octals as in string
    //      - but no quoting of printable characters
    //          this avoids problem of quoting "\" which is valid in file names
    //
    //  note:  obviously these are NOT completely identical to string
    //      in that other special chars (ex.();) are not appropriate
    //      however, this is ONLY for ASCII file write so other chars
    //      should not appear in zone or file names
    //

    else
    {
        ASSERT( dwFlag == FILE_WRITE_FILE_NAME || dwFlag == FILE_WRITE_DOTTED_NAME );

        //
        //  Force quote of file name if it contains a space char.
        //

        if ( dwFlag == FILE_WRITE_FILE_NAME &&
            memchr( pchString, ' ', dwStringLength ) )
        {
            fForceQuote = TRUE;
            *pch++ = QUOTE_CHAR;
        }

        octalMask = B_PRINT_STRING_OCTAL;
        quoteMask = 0;
    }

    mask = octalMask | quoteMask;

    //
    //  check each character, expand where special handling required
    //

    while ( dwStringLength-- )
    {
        ch = (UCHAR) *pchString++;

        charType = DnsFileCharPropertyTable[ ch ];

        //  handle the 99% case first
        //  hopefully minimizing instructions

        if ( ! (charType & mask ) )
        {
            *pch++ = ch;
            continue;
        }

        //  character needs quoting, but is printable

        else if ( charType & quoteMask )
        {
            *pch++ = SLASH_CHAR;
            *pch++ = ch;
            continue;
        }

        //  character not printable (at least in this context), needs octal quote

        else
        {
            ASSERT( charType & octalMask );
            pch += sprintf( pch, "\\%03o", ch );
            continue;
        }
    }

    //  terminate
    //      - quote if quoted string
    //      - NULL on final character for simplicity, string always ready to write

    if ( dwFlag == FILE_WRITE_QUOTED_STRING || fForceQuote )
    {
        *pch++ = QUOTE_CHAR;
    }

    ASSERT( pch < pchBufEnd );
    *pch = 0;

    return pch;
}



PCHAR
FASTCALL
File_PlaceNodeNameInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    )
/*++

Routine Description:

    Write domain name to buffer.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pNodeStop - node to stop writing at;
        OPTIONAL, if not given or not ancestor of pNode then FQDN is
        written to buffer

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        return NULL;
    }

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        //  break from loop if reach stop node
        //      - remove terminating dot since this is relative name
        //      - if writing stop node (zone root) itself, write '@'

        if ( pNode == pNodeStop )
        {
            if ( pch > pchBuf )
            {
                --pch;
                ASSERT( *pch == '.' );
                break;
            }
            else
            {
                ASSERT( pNodeStop );
                *pch++ = '@';
                break;
            }
        }

        //  check length rr
        //      - must handle length and a BYTE for "."

        labelLength = pNode->cchLabelLength;
        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        if ( pch + labelLength + 1 > pchBufEnd )
        {
            return NULL;
        }

        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            if ( pch == pchBuf )
            {
                *pch++ = '.';
            }
            break;
        }

        //  write the node label
        //  write separating dot

        pch = File_PlaceStringInFileBuffer(
                pch,
                pchBufEnd,
                FILE_WRITE_NAME_LABEL,
                pNode->szLabel,
                labelLength );
        if ( !pch )
        {
            return NULL;
        }
        *pch++ = '.';

        //  move up to parent node
    }
    while ( pNode = pNode->pParent );

    //  root should break loop, not pNode = NULL

    ASSERT( pNode );

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote file name %s (len=%d) into buffer at postion %p\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return pch;
}



PCHAR
File_WriteRawNameToFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write raw name to buffer in file format.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pZone - OPTIONAL, if given name writing stops at zone name

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        return NULL;
    }

    //
    //  traverse labels in name until
    //      - reach end (FQDN)
    //      - or reach zone root
    //

    while( 1 )
    {
        labelLength = *pName;

        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        //
        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            break;
        }

#if 0
        //
        //  DEVNOTE: for efficiency, check if at zone name and if so
        //              terminate
        //
        //  at zone name check?
        //      - can check count of labels
        //      - remaining length
        //      - or just check
        //

        if ( zoneLabelCount == labelLength )
        {
            Name_CompareRawNames(
                pName,
                pZone->pCountName.RawName );
        }
#endif

        //  write the node label
        //  write separating dot if already wrote previous label

        if ( pch > pchBuf )
        {
            *pch++ = '.';
        }

        pch = File_PlaceStringInFileBuffer(
                pch,
                pchBufEnd,
                FILE_WRITE_NAME_LABEL,
                ++pName,
                labelLength );
        if ( !pch )
        {
            return NULL;
        }

        pName += labelLength;
    }

    //  write a terminating NULL

    *pch++ = '.';
    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote file name %s (len=%d) into buffer at postion %p\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return pch;
}



//
//  File reading utilites
//

PCHAR
extractQuotedChar(
    OUT     PCHAR           pchResult,
    IN      PCHAR           pchIn,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Writes value of quoted char to buffer.

Arguments:

    pchResult   - result buffer

    pchIn       - text to copy

    pchEnd      - end of test

Return Value:

    Ptr to next position in incoming buffer.

--*/
{
    CHAR        ch;
    UCHAR       octalNumber = 0;
    DWORD       countOctal = 0;

    //
    //  protect against writing past end of buffer
    //
    //  two cases:
    //      \<char>             -- value is char
    //      \<octal number>     -- octal value
    //      octal number up to three digits long
    //

    while ( pchIn <= pchEnd )
    {
        ch = *pchIn++;
        if ( ch < '0' || ch > '7' )
        {
            if ( countOctal == 0 )
            {
                goto Done;
            }
            pchIn--;
            break;
        }
        octalNumber <<= 3;
        octalNumber += (ch - '0');
        DNS_DEBUG( LOOKUP2, (
            "Ch = %c;  Octal = %d\n",
            ch, octalNumber ));
        if ( ++countOctal == 3 )
        {
            break;
        }
    }

    ch = (CHAR)octalNumber;

Done:
    *pchResult++ = ch;

    //  return ptr to next input character

    DNS_DEBUG( LOOKUP2, (
        "Quote result %c (%d)\n",
        ch, ch ));

    return pchIn;
}



PCHAR
File_CopyFileTextData(
    OUT     PCHAR           pchBuffer,
    IN      DWORD           cchBufferLength,
    IN      PCHAR           pchText,
    IN      DWORD           cchLength,          OPTIONAL
    IN      BOOL            fWriteLengthChar
    )
/*++

Routine Description:

    Copies text data into TXT record data form, converting quoted characters.
    
    Jan 2001: This routine has been generalized to decode any string that
    might contain octal escaped characters. At some point in the future this
    function should be renamed for clarity.

Arguments:

    pchResult - result buffer

    cchBufferLength - total usable length of result buffer

    pchText - text to copy

    cchLength - number of chars in text; if zero then pchText is assumed
        to be NULL terminated

    fWriteLengthChar - if TRUE, output buffer will start with single byte
        length character, if FALSE output buffer will be NULL-terminated
        string

Return Value:

    Ptr to next position in result buffer.
    NULL on error.

--*/
{
    PCHAR       pch;
    CHAR        ch;
    PCHAR       pchend;         //  ptr to end of name
    PCHAR       pchoutEnd;      //  ptr to end out output buffer
    PCHAR       presult;
    UCHAR       octalNumber;
    DWORD       countOctal;
    DNS_STATUS  status;

    ASSERT( pchBuffer && cchBufferLength );

    DNS_DEBUG( LOOKUP2, (
        "Building Text data element for \"%.*s\"\n",
        cchLength,
        pchText ));

    //
    //  setup start and end ptrs and verify length
    //

    pch = pchText;
    if ( !cchLength )
    {
        cchLength = strlen( pch );
    }
    ASSERT( cchBufferLength >= cchLength );
    pchend = pch + cchLength;
    pchoutEnd = pchBuffer + cchBufferLength;
    if ( !fWriteLengthChar )
    {
        --pchoutEnd;        //  Save room for terminating NULL.
    }

    //
    //  result buffer, leave space for count character
    //

    presult = pchBuffer;
    if ( fWriteLengthChar )
    {
        presult++;
    }

    //
    //  Loop until end of name
    //

    while ( pch < pchend )
    {
        if ( presult >= pchoutEnd )
        {
            return NULL;
        }
        ch = *pch++;

        //  not quoted, party on

        if ( ch != SLASH_CHAR )
        {
            *presult++ = ch;
            continue;
        }

        //
        //  quoted character
        //      - single quote just get next char
        //      - octal quote read up to three octal characters
        //

        else if ( ch == SLASH_CHAR )
        {
            pch = extractQuotedChar(
                    presult++,
                    pch,
                    pchend );
        }
    }

    //  set count char count

    if ( fWriteLengthChar )
    {
        ASSERT( (presult - pchBuffer - 1) <= MAXUCHAR );
        *(PUCHAR)pchBuffer = (UCHAR)(presult - pchBuffer - 1);
    }
    else
    {
        *presult = '\0';    //  NULL terminate
    }

    return presult;
}



DNS_STATUS
Name_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    )
/*++

Routine Description:

    Converts file name to counted name format.

    Note, this is currently the general dotted-to-dbase name
    translation routine.  It should be noted that quoted characters
    will be translated to filename specifications.

Arguments:

    pCountName  - count name buffer

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    DNS_STATUS_FQDN             -- if name is FQDN
    DNS_STATUS_DOTTED_NAME      -- for non-FQDN
    DNS_ERROR_INVALID_NAME      -- if name invalid

--*/
{
    PCHAR       pch;
    UCHAR       ch;
    PCHAR       pchstartLabel;           // ptr to start of label
    PCHAR       pchend;             // ptr to end of name
    PCHAR       presult;
    PCHAR       presultLabel;
    PCHAR       presultMax;
    WORD        charType = 0;
    WORD        maskNoCopy;
    WORD        maskDowncase;
    DNS_STATUS  status;
    INT         labelLength;        // length of current label
    UCHAR       labelCount = 0;

    DNS_DEBUG( LOOKUP, (
        "Building count name for \"%.*s\"\n",
        cchNameLength ? cchNameLength : DNS_MAX_NAME_LENGTH,
        pchName ));

    //
    //  NULL name
    //

    if ( !pchName )
    {
        ASSERT( cchNameLength == 0 );
        pCountName->Length = 0;
        pCountName->LabelCount = 0;
        pCountName->RawName[0] = 0;
        return ERROR_SUCCESS;
    }

    //
    //  result buffer, leave space for label
    //

    presultLabel = presult = pCountName->RawName;
    presultMax = presult + DNS_MAX_NAME_LENGTH;
    presult++;

    //
    //  Character selection mask
    //      '\' slash quote
    //      '.' dot label separator are special chars
    //      upper case must be downcased
    //      everything else is copied dumb copy
    //

    maskNoCopy = B_PARSE_NAME_MASK | B_UPPER;
    maskDowncase = B_UPPER;

    //
    //  setup start and end ptrs and verify length
    //

    pchstartLabel = pch = pchName;
    if ( !cchNameLength )
    {
        cchNameLength = strlen( pch );
    }
    pchend = pch + cchNameLength;

    //
    //  Loop until end of name
    //
    //
    //  DEVNOTE:  standard form of DNS names (UTF8 case considerations)
    //      should convert to standard form handling all casing
    //      right here
    //

    while ( 1 )
    {
        //  check for input termination
        //      - setup as dummy label terminator, but ch==0, signals no terminating dot
        //
        //  otherwise get next character

        if ( pch >= pchend )
        {
            ch = 0;
            charType = FC_NULL;
        }
        else
        {
            ch = (UCHAR) *pch++;
            charType = DnsFileCharPropertyTable[ ch ];
        }

        DNS_DEBUG( PARSE2, (
            "Converting ch=%d <%c>\n"
            "    charType = %d\n",
            ch, ch,
            charType ));

        //
        //  DEVNOTE:  detect UTF8 extension chars, and downcase at end
        //
        //      probably best approach is handle regular case, and just
        //      detect high octal, then do full down-casing of utf8
        //      alternatively could catch here, and do char processing
        //      in loop (build UTF8 char -- convert when done, write downcased
        //      UTF8
        //

        //  handle RFC printable characters (the 99% case) first

        if ( ! (charType & maskNoCopy) )
        {
            //  if name exceeds DNS name max => invalid

            if ( presult >= presultMax )
            {
                goto InvalidName;
            }
            *presult++ = ch;
            continue;
        }

        //  downcase upper case
        //      do this here so RR data fields can be compared by simple
        //      memcmp, rather than requiring type specific comparison routines

        if ( charType & maskDowncase )
        {
            //  if name exceeds DNS name max => invalid

            if ( presult >= presultMax )
            {
                goto InvalidName;
            }
            *presult++ = DOWNCASE_ASCII(ch);
            continue;
        }

        //
        //  label terminator
        //      - set length of previous label
        //      - save ptr to this next label
        //      - check for name termination
        //

        if ( charType & B_DOT )
        {
            //  verify label length

            labelLength = (int)(presult - presultLabel - 1);

            if ( labelLength > DNS_MAX_LABEL_LENGTH )
            {
                DNS_DEBUG( LOOKUP, (
                    "Label exceeds 63 byte limit:  %.*s\n",
                    pchend - pchName,
                    pchstartLabel ));
                goto InvalidName;
            }

            //  set label count in result name

            *presultLabel = (CHAR)labelLength;
            presultLabel = presult++;

            //
            //  termination
            //      ex: "microsoft.com."
            //      ex: "microsoft.com"
            //      ex: "."
            //
            //  if no explicit dot termination, then just wrote previous label
            //      => write 0 label
            //  otherwise already wrote 0 label
            //      => done
            //
            //  ch value preserves final character to make relative \ FQDN distinction
            //
            //  note: RPC does send NULL terminated strings with length that includes
            //      the NULL;  however, they will still terminate here as
            //

            if ( pch >= pchend )
            {
                if ( labelLength != 0 )
                {
                    labelCount++;
                    *presultLabel = 0;
                    break;
                }

                //
                //  root (".") name
                //  dec presult, so correct length (1) is written for name
                //      we already wrote zero length label above
                //
                //  note:  RPC can also generate this situation when it includes
                //      NULL termination in length of name
                //      ex.  <8>jamesg.<0>
                //  in this case also, we won't terminate until processing the <0>,
                //  and when we do we'll have already written the zero label above
                //

                presult--;
                ASSERT( (presult == pCountName->RawName + 1)  ||  ch == 0 );
                break;
            }

            //  set up for next label

            if ( labelLength != 0 )
            {
                labelCount++;
                continue;
            }

            //
            //  catch bogus entries
            //      ex:  ".blah"
            //      ex:  "foo..bar"
            //      ex:  "more.."
            //      ex:  ".."
            //
            //  only root domain name, should have label that started
            //      with DOT, and it must immediately terminate
            //

            ASSERT( ch == DOT_CHAR  &&  pch <= pchend );

            DNS_DEBUG( LOOKUP, ( "Bogus double--dot label\n" ));
            goto InvalidName;
        }

        //  quoted character
        //      - single quote just get next char
        //      - octal quote read up to three octal characters

        else if ( ch == SLASH_CHAR )
        {
            pch = extractQuotedChar(
                    presult++,
                    pch,
                    pchend );
        }

        ELSE_ASSERT_FALSE;
    }

    //
    //  termination
    //  separate status for two cases:
    //      - no trailing dot case (ex: "microsoft.com")
    //      - FQDN
    //

    if ( ch == 0 )
    {
        status = DNS_STATUS_DOTTED_NAME;
    }
    else
    {
        status = DNS_STATUS_FQDN;
    }

    //
    //  DEVNOTE:  standard form of DNS names (UTF8 case considerations)
    //
    //      should convert to standard form handling all casing
    //      right here
    //


    //
    //  set counted name length
    //

    ASSERT( presult > pCountName->RawName );
    ASSERT( *(presult-1) == 0 );

    pCountName->Length = (UCHAR)(presult - pCountName->RawName);
    pCountName->LabelCount = labelCount;

    IF_DEBUG( LOOKUP )
    {
        DnsDbg_Lock();
        Dbg_CountName(
            "Counted name for file name ",
            pCountName,
            NULL );
        DnsPrintf(
            "    for file name %.*s"
            "    Name is %s name\n",
            cchNameLength,
            pchName,
            (status == DNS_STATUS_DOTTED_NAME) ? "relative" : "FQDN" );
        DnsDbg_Unlock();
    }
    return status;


InvalidName:

    DNS_DEBUG( LOOKUP, (
        "Failed to create lookup name for %.*s\n",
        cchNameLength,
        pchName ));

    return DNS_ERROR_INVALID_NAME;
}



//
//  Wire name
//

PCHAR
Wire_SkipPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Skips over transport name.

Arguments:

    pchPacketName - ptr to start of name to skip

Return Value:

    Ptr to next
    NULL if no more names

--*/
{
    pchPacketName = Dns_SkipPacketName(
                        pchPacketName,
                        DNSMSG_END( pMsg ) );
    if ( !pchPacketName )
    {
        DNS_LOG_EVENT_BAD_PACKET(
            DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
            pMsg );
    }
    return pchPacketName;
}

//
//  End nameutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\name.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    name.c

Abstract:

    Domain Name System (DNS) Server

    Count\dbase name functions.

Author:

    Jim Gilroy (jamesg)     April 1998

Revision History:

--*/


#include "dnssrv.h"



//
//  Basic count name functions
//

DWORD
Name_SizeofCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Get sizeof of count name -- full buffer length.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    return( pName->Length + SIZEOF_COUNT_NAME_FIXED );
}



VOID
Name_ClearCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Clear count name.

    This is equivalent to setting name to root.

Arguments:

    pName - count name

Return Value:

    None.

--*/
{
    pName->Length = 1;
    pName->LabelCount = 0;
    pName->RawName[0] = 0;
}



PDB_NAME
Name_SkipCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Skip to end of count name.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    return( (PDB_NAME) (pName->RawName + pName->Length) );
}



BOOL
Name_IsEqualCountNames(
    IN      PCOUNT_NAME     pName1,
    IN      PCOUNT_NAME     pName2
    )
/*++

Routine Description:

    Get sizeof of count name -- full buffer length.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    if ( pName1->Length != pName2->Length )
    {
        return FALSE;
    }

    return RtlEqualMemory(
                pName1->RawName,
                pName2->RawName,
                pName1->Length );
}



BOOL
Name_ValidateCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Validate Dbase name.

Arguments:

    pName - count name to validate

Return Value:

    TRUE if valid count name.
    FALSE on error.

--*/
{
    PCHAR   pch;
    PCHAR   pchstop;
    DWORD   labelCount = 0;
    DWORD   labelLength;


    pch = pName->RawName;
    pchstop = pch + pName->Length;

    //
    //  write each label to buffer
    //

    while ( pch < pchstop )
    {
        labelLength = *pch++;

        if ( labelLength == 0 )
        {
            break;
        }
        pch += labelLength;
        labelCount++;
    }

    if ( pch != pchstop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Invalid name length in validation!!!\n"
            "    name start = %p\n",
            pName->RawName ));
        ASSERT( FALSE );
        return FALSE;
    }

    //
    //  DEVNOTE: label count not being set correctly?
    //

    if ( labelCount != pName->LabelCount )
    {
        pName->LabelCount = (UCHAR)labelCount;
        // return FALSE;
    }

    return TRUE;
}



DNS_STATUS
Name_CopyCountName(
    OUT     PCOUNT_NAME     pOutName,
    IN      PCOUNT_NAME     pCopyName
    )
/*++

Routine Description:

    Copy counted name.

Arguments:

    pOutName  - count name buffer

    pCopyName   - count name to copy

Return Value:

    ERROR_SUCCESS

--*/
{
    //
    //  copy name
    //      - note no validity check
    //

    RtlCopyMemory(
        pOutName,
        pCopyName,
        pCopyName->Length + SIZEOF_COUNT_NAME_FIXED );

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Count name after copy:  ",
            pOutName,
            "\n"
            );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Name_AppendCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCOUNT_NAME     pAppendName
    )
/*++

Routine Description:

    Append one counted name to another.

Arguments:

    pCountName  - counted name buffer

    pAppendName - counted name to append

Return Value:

    ERROR_SUCCESS           -- if successful
    DNS_ERROR_INVALID_NAME  -- if name invalid

--*/
{
    DWORD   length;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Appending counted name:  ",
            pAppendName,
            "\n" );
        Dbg_CountName(
            "    to counted name:  ",
            pCountName,
            "\n" );
    }

    //
    //  verify valid length
    //

    length = pCountName->Length + pAppendName->Length - 1;
    if ( length > DNS_MAX_NAME_LENGTH )
    {
        return DNS_ERROR_INVALID_NAME;
    }

    //
    //  add label counts
    //

    pCountName->LabelCount += pAppendName->LabelCount;

    //
    //  copy append name
    //      - note no validity check
    //      - note write over first names terminating NULL
    //

    RtlCopyMemory(
        pCountName->RawName + pCountName->Length - 1,
        pAppendName->RawName,
        pAppendName->Length );

    pCountName->Length = (UCHAR) length;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Count name post-append:  ",
            pCountName,
            "\n" );
    }
    return ERROR_SUCCESS;
}



//
//  From dotted name
//

PCOUNT_NAME
Name_CreateCountNameFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    )
/*++

Routine Description:

    Create counted name.

    Note the created name is READ_ONLY it contains ONLY space
    necessary for name.

Arguments:

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    Ptr to counted name.
    NULL on invalid name or alloc error.

--*/
{
    PCOUNT_NAME     pcountName;
    DNS_STATUS      status;

    //
    //  allocate space
    //      - one extra character required for leading label
    //      - one extra character may be required terminating NULL if not
    //          FQDN form
    //

    if ( !cchNameLength )
    {
        if ( pchName )
        {
            cchNameLength = strlen( pchName );
        }
    }
    pcountName = ALLOC_TAGHEAP( (SIZEOF_COUNT_NAME_FIXED + cchNameLength + 2), MEMTAG_NAME );
    IF_NOMEM( !pcountName )
    {
        return NULL;
    }

    //
    //  DEVNOTE: Using file name routine for dotted name. Need to decide
    //  name validity and format for name input to Zone_Create()
    //      -> UTF8?  file format?
    //

    status = Name_ConvertFileNameToCountName(
                pcountName,
                pchName,
                cchNameLength );

    if ( status != ERROR_INVALID_NAME )
    {
        IF_DEBUG( LOOKUP2 )
        {
            Dbg_CountName(
                "Count converted from file name:  ",
                pcountName,
                "\n"
                );
        }
        return( pcountName );
    }

    FREE_HEAP( pcountName );
    return NULL;
}



DNS_STATUS
Name_AppendDottedNameToCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    )
/*++

Routine Description:

    Append dotted name to count name.

Arguments:

    pCountName  - existing count name to append to

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    Ptr to counted name.
    NULL on invalid name or alloc error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      nameAppend;

    //
    //  no-op when no name given
    //

    if ( !pchName )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  build count name for dotted name
    //

    status = Name_ConvertFileNameToCountName(
                & nameAppend,
                pchName,
                cchNameLength );

    if ( status == ERROR_INVALID_NAME )
    {
        DNS_DEBUG( ANY, (
            "Invalid name %.*s not converted to count name!\n",
            cchNameLength,
            pchName ));
        return( status );
    }

    ASSERT( status == DNS_STATUS_FQDN || status == DNS_STATUS_DOTTED_NAME );

    //
    //  append name to existing count name
    //

    return Name_AppendCountName(
                pCountName,
                & nameAppend );
}



//
//  From dbase node
//

VOID
Name_NodeToCountName(
    OUT     PCOUNT_NAME     pName,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain name to packet.

    This writes FULL domain name -- no compression.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    UCHAR   labelLength;
    UCHAR   labelCount = 0;
    PCHAR   pch;

    ASSERT( pNode != NULL );
    ASSERT( pName != NULL );

    //
    //  traverse back up database, writing complete domain name
    //

    pch = pName->RawName;

    while( 1 )
    {
        ASSERT( pNode->cchLabelLength <= 63 );

        labelLength = pNode->cchLabelLength;
        *pch++ = labelLength;

        if ( labelLength == 0 )
        {
            ASSERT( pNode->pParent == NULL );
            break;
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;
        labelCount++;
        pNode = pNode->pParent;
    }

    //  determine full name length

    pName->Length = (UCHAR)(pch - pName->RawName);

    pName->LabelCount = labelCount;

    IF_DEBUG( READ )
    {
        DNS_PRINT((
            "Node %s at %p written to count name\n",
            pNode->szLabel,
            pNode ));
        Dbg_CountName(
            "New count name for node:",
            pName,
            NULL );
    }
}



//
//  Packet read\write
//

PCHAR
Name_PacketNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Converts packet name to counted name format.

Arguments:

    pCountName  - counted name buffer

    pMsg        - message buffer containing name

    pchPacketName - ptr to name in packet

    pchEnd      - limit on extent of name;
                    - may be message buffer end
                    - message end
                    - packet RR data end

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    PUCHAR  pch;
    PUCHAR  pchnext = NULL;
    UCHAR   ch;
    UCHAR   cch;
    UCHAR   cflag;
    PUCHAR  presult;
    PUCHAR  presultStop;
    UCHAR   labelCount = 0;

    //
    //  set result stop
    //      - if reach stop byte, then invalid name
    //

    presult = pCountName->RawName;
    presultStop = presult + DNS_MAX_NAME_LENGTH;

    pch = pchPacketName;

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            *presult++ = cch;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;
        if ( cflag == 0 )
        {
            labelCount++;
            *presult++ = cch;
            if ( presult + cch >= presultStop )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_MessageNameEx(
                        "Packet name exceeding name length:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }

                DNS_LOG_EVENT_BAD_PACKET(
                    DNS_EVENT_PACKET_NAME_TOO_LONG,
                    pMsg );

                goto InvalidName;
            }

            if ( pch + cch >= pchEnd )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Packet name at %p in message %p\n"
                        "    extends to %p beyond end of packet buffer %p\n",
                        pchPacketName,
                        pMsg,
                        pch,
                        pchEnd ));
                    Dbg_MessageNameEx(
                        "Packet name with invalid name:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }
                goto InvalidName;
            }

            //
            //  copy downcasing ASCII upper chars
            //  UTF8 MUST be properly downcased on wire
            //

            while ( cch-- )
            {
                ch = *pch++;
                if ( !IS_ASCII_UPPER(ch) )
                {
                    *presult++ = ch;
                    continue;
                }
                *presult++ = DOWNCASE_ASCII(ch);
                continue;
            }

            ASSERT( presult < presultStop );
            continue;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;
            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch >= pchPacketName || pch >= pchoffset )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Bogus name offset %d, encountered at %p\n"
                        "    to location %p beyond offset\n",
                        offset,
                        pchoffset,
                        pch ));

                    Dbg_MessageNameEx(
                        "Packet name with bad offset:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }

                DNS_LOG_EVENT_BAD_PACKET(
                    DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                    pMsg );

                goto InvalidName;
            }

            //  on first offset, save ptr to byte following name
            //  parsing continues at this point

            if ( !pchnext )
            {
                pchnext = pchoffset + sizeof(WORD);
            }
            continue;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchPacketName,
                    pMsg,
                    pchEnd,
                    NULL );
            }

            DNS_LOG_EVENT_BAD_PACKET(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                pMsg );

            goto InvalidName;
        }
    }

    //  set counted name length

    pCountName->Length = (UCHAR)(presult - pCountName->RawName);
    pCountName->LabelCount = labelCount;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_RawName(
            "Packet Name",
            pCountName->RawName,
            "\n" );
    }

    //  return ptr to byte following name
    //      - if offset in name, this was found above
    //      - otherwise it's byte after terminator

    if ( pchnext )
    {
        return pchnext;
    }
    return pch;


InvalidName:

    //
    //  Note we used to log DNS_EVENT_INVALID_PACKET_DOMAIN_NAME here.
    //

    return NULL;
}



DWORD
Name_SizeofCountNameForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR *         ppchPacketName,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Determine of database name for a packet name.

Arguments:

    pMsg - ptr to message

    pchPacketName - addr of ptr to name in packet;  on return set to
        point at byte after name

    pchEnd - furthest possible end of name in message
                - end of record data for name in record
                - end of message for name in message

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PUCHAR  pch;
    PCHAR   pchafterName = 0;
    PCHAR   pchstart;
    PCHAR   pchoffset;
    DWORD   length;
    WORD    offset;
    UCHAR   ch;
    UCHAR   cch;
    UCHAR   cflag;


    pch = *ppchPacketName;
    pchstart = pch;
    length = 1;             // for NULL termination

    //
    //  Set packet end if not explicitly given
    //
    //  DEVNOTE:  should be message end, not buffer end
    //

    if ( !pchEnd )
    {
        pchEnd = pMsg->pBufferEnd;
    }

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            pchafterName = pch;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;
        if ( cflag == 0 )
        {
            length += cch + 1;
            pch += cch;

            if ( pch < pchEnd )
            {
                continue;
            }

            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p in message %p\n"
                    "    extends to %p beyond end of data %p\n",
                    pchstart,
                    pMsg,
                    pch,
                    pchEnd ));
                Dbg_MessageNameEx(
                    "Packet name with invalid name:\n",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }
            goto InvalidName;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            if ( pch >= pchEnd )
            {
                goto InvalidName;
            }

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;

            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch < pchstart && pch < pchoffset )
            {
                if ( pchafterName == 0 )
                {
                    ASSERT( pchoffset >= pchstart );
                    pchafterName = pchoffset + sizeof(WORD);
                }
                continue;
            }

            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "ERROR:  Bogus name offset %d, encountered at %p\n"
                    "    to location %p beyond offset\n",
                    offset,
                    pchoffset,
                    pch ));
                Dbg_MessageNameEx(
                    "Packet name with bad offset:\n",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }

            DNS_LOG_EVENT_BAD_PACKET(
                DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                pMsg );

            goto InvalidName;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }

            DNS_LOG_EVENT_BAD_PACKET(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                pMsg );

            goto InvalidName;
        }
    }

    //  total length check

    if ( length > DNS_MAX_NAME_LENGTH )
    {
        goto InvalidName;
    }

    //  return length of entire name including header

    DNS_DEBUG( LOOKUP2, (
        "Raw name length %d for packet name at %p\n",
        length,
        pchstart ));

    ASSERT( pchafterName );
    *ppchPacketName = pchafterName;

    return length + SIZEOF_COUNT_NAME_FIXED;

InvalidName:

    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
        pMsg );

    *ppchPacketName = pchstart;
    return 0;
}



PCOUNT_NAME
Name_CreateCountNameFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Converts packet name to counted name format.

Arguments:

    pchPacketName - ptr to name in packet

    pdnsMsg     - ptr to DNS message header

    pCountName  - counted name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    COUNT_NAME      tempCountName;
    PCOUNT_NAME     pcountName;
    DWORD           length;

    //
    //  DEVNOTE: later for speed, just do counting on first pass,
    //      then second pass is copy into correct sized buffer
    //

    //
    //  convert from packet to count name
    //

    if ( ! Name_PacketNameToCountName(
                & tempCountName,
                pMsg,
                pchPacketName,
                DNSMSG_END( pMsg )
                ) )
    {
        return NULL;
    }

    //
    //  create count name with standard alloc functions
    //  most names will be short blobs that fit comfortably in standard RRs
    //

    length = tempCountName.Length + SIZEOF_COUNT_NAME_FIXED;

    pcountName = (PCOUNT_NAME) ALLOC_TAGHEAP( length, MEMTAG_NAME );
    IF_NOMEM( !pcountName )
    {
        return NULL;
    }

    //
    //  copy count name
    //

    RtlCopyMemory(
        pcountName,
        & tempCountName,
        length );

    return (PDB_NAME) pcountName;
}



//
//  RPC buffer (as dotted)
//

PCHAR
Name_WriteCountNameToBufferAsDottedName(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

    fPreserveEmbeddedDots - labels may contain embedded
        dots, if this flag is set these dots will be
        escaped with a backslash in the output buffer.

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    PCHAR   pread;
    DWORD   labelLength;
    INT     embeddedDots = 0;

    DNS_DEBUG( WRITE, (
        "Name_WriteDbaseNameToBufferAsDottedName()\n" ));

    pch = pchBuf;

    //  ensure adequate length

    if ( pch + pName->Length >= pchBufEnd )
    {
        return NULL;
    }

    //
    //  write each label to buffer
    //

    pread = pName->RawName;

    while ( labelLength = *pread++ )
    {
        ASSERT( pch + labelLength < pchBufEnd );

        //
        //  The label may contain embedded dots. Optionally replace
        //  "." with "\." so that embedded dot does not look like
        //  a regular label separator.
        //

        if ( fPreserveEmbeddedDots && memchr( pread, '.', labelLength ) )
        {
            PCHAR   pchscan;
            PCHAR   pchscanEnd = pread + labelLength;

            for ( pchscan = pread; pchscan < pchscanEnd; ++pchscan )
            {
                //
                //  The extra backslash char makes the initial buffer length
                //  check unreliable do manual check to make sure there's room
                //  for this char plus backslash.
                //

                if ( pch >= pchBufEnd - 2 )
                {
                    return NULL;
                }

                //
                //  Copy character, escaping with backslash if necessary.
                //

                if ( *pchscan == '.' )
                {
                    *pch++ = '\\';
                    ++embeddedDots;
                }
                *pch++ = *pchscan;
            }
        }
        else
        {
            RtlCopyMemory(
                pch,
                pread,
                labelLength );
            pch += labelLength;
        }

        *pch++ = '.';

        pread += labelLength;
    }

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( RPC, (
        "Wrote name %s (len=%d) into buffer at postion %p\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    ASSERT( pch - pchBuf == pName->Length + embeddedDots - 1 );

    return( pch );
}


PCHAR
Name_WriteDbaseNameToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL if unable to write name to buffer.  SetLastError to ERROR_MORE_DATA

--*/
{
    PCHAR   pch;
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pch = pchBuf;
    pch++;

    //
    //  write dbase name to buffer
    //

    pch = Name_WriteCountNameToBufferAsDottedName(
            pch,
            pchBufEnd,
            pName,
            fPreserveEmbeddedDots );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return NULL;
    }
    ASSERT( pch <= pchBufEnd );

    //
    //  write name length byte
    //      - do NOT count terminating NULL
    //

    ASSERT( *pch == 0 );

    ASSERT( (pch - pchBuf - 1) <= MAXUCHAR );

    *pchBuf = (CHAR)(UCHAR)(pch - pchBuf - 1);

    return( pch );
}


PCHAR
Name_WriteDbaseNameToRpcBufferNt4(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL if unable to write name to buffer.  SetLastError to ERROR_MORE_DATA

--*/
{
    PCHAR   pch;
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pch = pchBuf;
    pch++;

    //
    //  write dbase name to buffer
    //

    pch = Name_WriteCountNameToBufferAsDottedName(
            pch,
            pchBufEnd,
            pName,
            FALSE );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return NULL;
    }
    ASSERT( pch <= pchBufEnd );

    //
    //  write name length byte
    //      - include terminating NULL
    //
    //  note, we're not interested in string length here, just how
    //  much space name took up in buffer
    //

    pch++;

    ASSERT( (pch - pchBuf - 1) <= MAXUCHAR );

    *pchBuf = (CHAR)(UCHAR)(pch - pchBuf - 1);
    return( pch );
}



DWORD
Name_ConvertRpcNameToCountName(
    IN      PCOUNT_NAME     pName,
    IN OUT  PDNS_RPC_NAME   pRpcName
    )
/*++

Routine Description:

    Converts dotted counted name to COUNT_NAME format.
    For read from RPC buffer.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Length of converted name, if successful.
    0 on error.

--*/
{
    DNS_STATUS  status;

    ASSERT( pName );
    ASSERT( pRpcName );

    //
    //  If the length of the RPC name is zero but the first
    //  name character is not zero, an old DNSMGR is trying
    //  to give us a mal-formed empty string.
    //

    if ( pRpcName->cchNameLength == 0 && pRpcName->achName[ 0 ] )
    {
        return 0;
    }

    //
    //  Convert the name.
    //

    status = Name_ConvertFileNameToCountName(
                pName,
                pRpcName->achName,
                pRpcName->cchNameLength
                );
    if ( status == ERROR_INVALID_NAME )
    {
        return 0;
    }
    return( pName->Length + SIZEOF_COUNT_NAME_FIXED );
}




//
//  Lookup name
//
//  Lookup names are form of name used directly in looking up name in database.
//
//  Lookup names are stored as
//      - count of labels
//      - total name length
//      - list of ptrs to labels
//      - list of label lengths
//
//  Lookup names are assumed to be FQDNs.
//
//  Because of this we make the following implementation simplifications:
//
//      - only store non-zero labels, empty root label is not stored
//          and label ptr and label length list MAY NOT be assumed to
//          be zero terminated
//
//      - total name length is kept as PACKET LENGTH of name;  hence
//          it is sum of individuals labels lengths plus label count
//          (one count byte for each label) PLUS ONE for null terminator;
//          this makes checks of valid name length straightforward
//

#define DOT ('.')


BOOL
Name_ConvertPacketNameToLookupName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts packet name to lookup name format.

Arguments:

    pchPacketName - ptr to name in packet

    pdnsMsg - ptr to DNS message header

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    register PUCHAR pch;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR *         pointers;
    UCHAR *         lengths;
    USHORT          labelCount = 0;
    WORD            totalLength = 0;

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;


    //
    //  Loop until end of name
    //

    pch = pchPacketName;

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            //  not using explicit termination anymore
            //  if turned back on must change labelCount check below
            //    *lengths = 0;
            //    *pointers = NULL;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;

        if ( cflag == 0 )
        {
            //  kick out if pass maximum label count

            if ( labelCount >= DNS_MAX_NAME_LABELS )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_MessageNameEx(
                        "Packet name exceeds max label count:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       //  end at message end
                        NULL );
                }

                DNS_LOG_EVENT_BAD_PACKET(
                    DNS_EVENT_PACKET_NAME_TOO_MANY_LABELS,
                    pMsg );

                goto InvalidName;
            }

            //  kick out if label is too long

            if ( cch > DNS_MAX_LABEL_LENGTH )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_MessageNameEx(
                        "Label in packet name exceeds max label length:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       //  end at message end
                        NULL );
                }

                DNS_LOG_EVENT_BAD_PACKET(
                    DNS_EVENT_PACKET_NAME_LABEL_TOO_LONG,
                    pMsg );

                goto InvalidName;
            }

            *lengths++  = cch;
            *pointers++ = pch;
            
            labelCount++;
            totalLength += cch + 1;
            pch += cch;

            //
            //  DEVNOTE: this should be message end, not buffer end
            //      problem is do we use this routine to look up WRITTEN lookup name?
            //      if so then message length not updated yet
            //
            //  if ( pch >= DNSMSG_END(pMsg) )
            //

            if ( pch >= pMsg->pBufferEnd )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Packet name at %p in message %p\n"
                        "    extends to %p beyond end of packet buffer %p\n",
                        pchPacketName,
                        pMsg,
                        pch,
                        pMsg->pBufferEnd ));
                    Dbg_MessageNameEx(
                        "Packet name with invalid name:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       // end at message end
                        NULL );
                }
                goto InvalidName;
            }
            continue;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;
            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch >= pchPacketName || pch >= pchoffset )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Bogus name offset %d, encountered at %p\n"
                        "    to location %p beyond offset\n",
                        offset,
                        pchoffset,
                        pch ));
                    Dbg_MessageNameEx(
                        "Packet name with bad offset:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       // end at message end
                        NULL );
                }

                DNS_LOG_EVENT_BAD_PACKET(
                    DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                    pMsg );

                goto InvalidName;
            }
            continue;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchPacketName,
                    pMsg,
                    NULL,       // end at message end
                    NULL );
            }

            DNS_LOG_EVENT_BAD_PACKET(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                pMsg );

            goto InvalidName;
        }
    }

    //
    //  set count in lookup name
    //

    if ( totalLength >= DNS_MAX_NAME_LENGTH )
    {
        IF_DEBUG( LOOKUP )
        {
            Dbg_MessageNameEx(
                "Packet name exceeding name length:\n",
                pchPacketName,
                pMsg,
                NULL,       // end at message end
                NULL );
        }

        DNS_LOG_EVENT_BAD_PACKET(
            DNS_EVENT_PACKET_NAME_TOO_LONG,
            pMsg );

        goto InvalidName;
    }

    pLookupName->cLabelCount    = labelCount;
    pLookupName->cchNameLength  = totalLength + 1;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Packet Name",
            pLookupName
            );
    }

    return TRUE;

InvalidName:

    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
        pMsg );

    return FALSE;
}



BOOL
Name_ConvertRawNameToLookupName(
    IN      PCHAR           pchRawName,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts packet name to lookup name format.

Arguments:

    pchRawName - ptr to name in packet

    pdnsMsg - ptr to DNS message header

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    register PUCHAR pch;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR *         pointers;
    UCHAR *         lengths;
    USHORT          labelCount = 0;         // count of labels
    WORD            totalLength = 0;

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;

    //
    //  Loop until end of name
    //

    pch = pchRawName;

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            *lengths = 0;
            *pointers = NULL;
            break;
        }

        //
        //  label, store ptr and length
        //

        if ( labelCount >= DNS_MAX_NAME_LABELS )
        {
            DNS_DEBUG( ANY, (
                "Raw name exceeds label count!\n",
                pchRawName ));
            goto InvalidName;
        }
        *lengths++  = cch;
        *pointers++ = pch;
        labelCount++;
        totalLength = cch + 1;
        pch += cch;
        continue;
    }

    //
    //  set count in lookup name
    //

    if ( totalLength >= DNS_MAX_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "Raw name too long!\n" ));
        goto InvalidName;
    }

    pLookupName->cLabelCount    = labelCount;
    pLookupName->cchNameLength  = totalLength + 1;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Packet Name",
            pLookupName );
    }
    return TRUE;


InvalidName:

    IF_DEBUG( ANY )
    {
        Dbg_RawName(
            "Invalid Raw Name",
            pchRawName,
            "\n" );
    }
    return FALSE;
}




BOOL
Name_CompareLookupNames(
    IN      PLOOKUP_NAME    pName1,
    IN      PLOOKUP_NAME    pName2
    )
/*++

Routine Description:

    Compare two lookup names for equality.

Arguments:

    Lookup names to compare.

Return Value:

    TRUE if equal, else FALSE.

--*/
{
    INT     i;

    ASSERT( pName1 && pName2 );

    if ( pName1->cLabelCount != pName2->cLabelCount ||
         pName1->cchNameLength != pName2->cchNameLength )
    {
        return FALSE;
    }

    for ( i = 0; i < pName1->cLabelCount; ++i )
    {
        UCHAR   len1 = pName1->cchLabelArray[ i ];

        if ( len1 != pName2->cchLabelArray[ i ] ||
             !RtlEqualMemory(
                    pName1->pchLabelArray[ i ], 
                    pName2->pchLabelArray[ i ],
                    len1 ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}   //  Name_CompareLookupNames



BOOL
Name_ConvertDottedNameToLookupName(
    IN      PCHAR           pchDottedName,
    IN      DWORD           cchDottedNameLength,    OPTIONAL
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts dotted name to lookup name format.

Arguments:

    pchDottedName - name to convert, given in human readable (dotted) form.

    cchDottedNameLength - number of chars in dotted name, if zero then
            pchDottedName is assumed to be NULL terminated

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch;
    CHAR    ch;
    PCHAR   pchstart;           // ptr to start of label
    PCHAR   pchend;             // ptr to end of name
    PCHAR * pointers;           // ptr into lookup name pointer array
    UCHAR * lengths;            // ptr into lookup name length array
    DWORD   labelCount = 0;     // count of labels
    INT     label_length;       // length of current label
    INT     cchtotal = 0;       // total length of name


    IF_DEBUG( LOOKUP2 )
    {
        if ( cchDottedNameLength )
        {
            DNS_PRINT((
                "Creating lookup name for \"%.*s\"\n",
                cchDottedNameLength,
                pchDottedName ));
        }
        else
        {
            DNS_PRINT((
                "Creating lookup name for \"%s\"\n",
                pchDottedName ));
        }
    }

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;


    //
    //  Setup start and end ptrs and verify length
    //

    pch = pchDottedName;
    pchstart = pch;
    if ( !cchDottedNameLength )
    {
        cchDottedNameLength = strlen( pch );
    }
    if ( cchDottedNameLength >= DNS_MAX_NAME_LENGTH )
    {
        //  note length can be valid at max length if dot terminated

        if ( cchDottedNameLength > DNS_MAX_NAME_LENGTH
                ||
            pch[cchDottedNameLength-1] != '.' )
        {
            goto InvalidName;
        }
    }
    pchend = pch + cchDottedNameLength;

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        if ( pch >= pchend )
        {
            ch = 0;
        }
        else
        {
            ch = *pch;
        }

        //
        //  find end of label
        //      - save ptr to start
        //      - save label length
        //

        if ( ch == DOT || ch == 0 )
        {
            //
            //  verify label length
            //

            label_length = (INT)(pch - pchstart);

            if ( label_length > DNS_MAX_LABEL_LENGTH )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "Label exceeds 63 byte limit:  %.*s\n",
                        pchend - pchstart,
                        pchstart ));
                }
                goto InvalidName;
            }

            //
            //  test for termination, trailing dot case
            //      ex: "microsoft.com."
            //      ex: "."
            //
            //  zero label length will catch both
            //      - label starting at terminating NULL,
            //      - standalone "." for root domain
            //

            if ( label_length == 0 )
            {
                //
                //  catch bogus entries
                //      ex:  ".blah"
                //      ex:  "blah.."
                //      ex:  "foo..bar"
                //      ex:  ".."
                //
                //  only root domain name, should have label that started
                //      with DOT, and it must immediately terminate
                //

                if ( ch == DOT
                        &&
                     ( labelCount != 0  ||  ++pch < pchend ) )
                {
                    IF_DEBUG( LOOKUP )
                    {
                        DNS_PRINT((
                            "Bogus label:  %.*s\n",
                            pchend - pchstart,
                            pchstart ));
                    }
                    goto InvalidName;
                }
                break;
            }

            if ( ++labelCount > DNS_MAX_NAME_LABELS )
            {
                DNS_PRINT((
                    "Name_ConvertDottedNameToLookupName: "
                    "name has too many labels\n\t%s\n",
                    pchDottedName ));
                goto InvalidName;
            }
            *pointers++ = pchstart;
            *lengths++ = (UCHAR) label_length;

            cchtotal += label_length;
            cchtotal++;

            //
            //  termination, no trailing dot case
            //      ex: "microsoft.com"
            //

            if ( ch == 0 )
            {
                break;
            }

            //
            //  skip dot
            //  save pointer to start of next label
            //

            pchstart = ++pch;      // save ptr to start of next label
            continue;
        }

        pch++;
    }

    //
    //  set counts in lookup name
    //      - total length is one more than sum of label counts and
    //          lengths to allow for 0 termination
    //

    pLookupName->cLabelCount = (USHORT) labelCount;
    pLookupName->cchNameLength = cchtotal + 1;

    ASSERT( pLookupName->cchNameLength <= DNS_MAX_NAME_LENGTH );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Lookup name for %.*s",
            cchDottedNameLength,
            pchDottedName
            ));
        Dbg_LookupName(
            "",
            pLookupName
            );
    }
    return ( TRUE );


InvalidName:

    IF_DEBUG( LOOKUP )
    {
        DNS_PRINT((
            "Failed to create lookup name for %.*s ",
            cchDottedNameLength,
            pchDottedName ));
    }
    {
        //
        //  copy name to NULL terminate for logging
        //

        CHAR    szName[ DNS_MAX_NAME_LENGTH+1 ];
        PCHAR   pszName = szName;

        if ( cchDottedNameLength > DNS_MAX_NAME_LENGTH )
        {
            cchDottedNameLength = DNS_MAX_NAME_LENGTH;
        }
        RtlCopyMemory(
            szName,
            pchDottedName,
            cchDottedNameLength
            );
        szName[ cchDottedNameLength ] = 0;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_DOTTED_DOMAIN_NAME,
            1,
            &pszName,
            EVENTARG_ALL_UTF8,
            0 );
    }
    return FALSE;
}



BOOL
Name_AppendLookupName(
    IN OUT  PLOOKUP_NAME    pLookupName,
    IN      PLOOKUP_NAME    pAppendName
    )
/*++

Routine Description:

    Appends domain name at end of another lookup name.

Arguments:

    pLookupName - lookup name buffer

    pAppendName - name to append

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    INT i;
    USHORT countLabels;

    ASSERT( pLookupName && pAppendName );

    //
    //  check total length
    //

    pLookupName->cchNameLength += pAppendName->cchNameLength - 1;

    if ( pLookupName->cchNameLength > DNS_MAX_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Appended lookup name too long\n"
            "    append name length   = %d\n"
            "    total appended length = %d\n",
            pAppendName->cchNameLength,
            pLookupName->cchNameLength  ));

        pLookupName->cchNameLength -= pAppendName->cchNameLength - 1;
        goto NameError;
    }

    //
    //  check total label count
    //

    countLabels = pLookupName->cLabelCount;

    if ( countLabels + pAppendName->cLabelCount > DNS_MAX_NAME_LABELS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Appended lookup name too many labels\n" ));
        goto NameError;
    }

    //
    //  loop until end of appended name
    //

    for ( i = 0;
            i < pAppendName->cLabelCount;
                i++ )
    {
        pLookupName->pchLabelArray[countLabels] = pAppendName->pchLabelArray[i];
        pLookupName->cchLabelArray[countLabels] = pAppendName->cchLabelArray[i];

        //  increment lookup name label count

        countLabels++;
    }

    //  reset lookup name label count

    pLookupName->cLabelCount = countLabels;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Appended lookup name",
            pLookupName
            );
    }
    return TRUE;

NameError:

    return FALSE;
}



DWORD
Name_ConvertLookupNameToDottedName(
    OUT     PCHAR           pchDottedName,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts lookup name to dotted string name.

Arguments:

    pchDottedName - buffer for name MUST be DNS_MAX_NAME_LENGTH long

    pLookupName - lookup name

Return Value:

    Count of characters converted, if successful.
    Zero on error.

--*/
{
    PCHAR   pch = pchDottedName;
    INT     i;
    INT     cchlabel;

    ASSERT( pLookupName && pchDottedName );

    //
    //  check total length
    //

    if ( pLookupName->cchNameLength > DNS_MAX_NAME_LENGTH )
    {
        *pch = '\0';
        goto NameError;
    }

    //
    //  handle special case of root
    //

    *pch = DOT;

    //
    //  loop until end of appended name
    //

    for ( i = 0;
            i < pLookupName->cLabelCount;
                i++ )
    {
        cchlabel = pLookupName->cchLabelArray[i];

        if ( cchlabel > DNS_MAX_LABEL_LENGTH )
        {
            goto NameError;
        }
        RtlCopyMemory(
            pch,
            pLookupName->pchLabelArray[i],
            cchlabel
            );
        pch += cchlabel;
        *pch++ = DOT;
    }

    //  NULL terminate

    *pch = 0;
    return( (DWORD)(pch - pchDottedName) );

NameError:

    DNS_DEBUG( ANY, (
        "ERROR:  Converting lookupname with invalid name or label count\n" ));
    ASSERT( FALSE );
    return 0;
}



VOID
Name_WriteLookupNameForNode(
    IN      PDB_NODE        pNode,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Writes lookup name for domain node.

Arguments:

    pNode - node to get name for

    pLookupName - lookup name buffer

Return Value:

    None

--*/
{
    register USHORT i = 0;
    register UCHAR  cchlabelLength = 0;
    INT             cchNameLength = 0;

    ASSERT( pNode != NULL );
    ASSERT( pLookupName != NULL );

    //
    //  traverse back up database, writing complete domain name
    //
    //  note:  not including root node, for current lookup name
    //      implementation, all lookup names are fully qualified;
    //      hence we stop when find zero label length
    //

    cchNameLength = 0;

    while( cchlabelLength = pNode->cchLabelLength )
    {
        ASSERT( cchlabelLength <= 63 );

        pLookupName->pchLabelArray[ i ] = pNode->szLabel;
        pLookupName->cchLabelArray[ i ] = cchlabelLength;

        cchNameLength += cchlabelLength;
        cchNameLength ++;
        i++;

        //
        //  get node's parent
        //

        pNode = pNode->pParent;

        ASSERT( pNode != NULL );
    }

    //
    //  set counts in lookup name
    //

    pLookupName->cLabelCount = i;
    pLookupName->cchNameLength = cchNameLength + 1;
}



//
//  IP to reverse lookup node names.
//

BOOL
Name_LookupNameToIpAddress(
    IN      PLOOKUP_NAME    pLookupName,
    OUT     PDNS_ADDR       pDnsAddr
    )
/*++

Routine Description:

    Convert lookup name (for in-addr.arpa domain) to corresponding
    IP address (in net byte order).
    
    DEVNOTE IPv6: I am converting the prototype but the guts of the 
    function will remain IPv4 only as this is used by NBTSTAT only.

Arguments:

    pLookupName - lookup name buffer

    pDnsAddr - addr to write IP address

Return Value:

    TRUE if lookup name is valid IP
    FALSE otherwise

--*/
{
    DWORD           dwByte;
    INT             i;
    UCHAR           cchlabel;
    PUCHAR          pchLabel;
    IP4_ADDRESS     ipAddress = 0;

    ASSERT( pDnsAddr );
    ASSERT( pLookupName );

    //
    //  verify six labels (4 address bytes, and "in-addr.arpa")
    //

    if ( pLookupName->cLabelCount != 6 )
    {
        IF_DEBUG( NBSTAT )
        {
            Dbg_LookupName(
                "Attempt to convert bogus reverse lookup name to IP address.",
                pLookupName );
        }
        return FALSE;
    }

    //
    //  write each address byte in turn
    //

    for ( i=0; i<4; i++ )
    {
        cchlabel = pLookupName->cchLabelArray[ i ];
        pchLabel = pLookupName->pchLabelArray[ i ];

        ASSERT( pchLabel );
        ASSERT( cchlabel );

        if ( cchlabel > 3 )
        {
            TEST_ASSERT( FALSE );
            return FALSE;
        }

        //  create UCHAR for address byte
        //  add in one decimal digit at a time

        dwByte = 0;
        while ( cchlabel-- )
        {
            dwByte *= 10;
            TEST_ASSERT( *pchLabel >= '0');
            TEST_ASSERT( *pchLabel <= '9');
            dwByte += (*pchLabel++) - '0';
        }
        if ( dwByte > 255 )
        {
            TEST_ASSERT( FALSE );
            return FALSE;
        }

        //  put address byte in IP address
        //      - network byte order

        ((PUCHAR)&ipAddress)[3-i] = (UCHAR) dwByte;
    }

    //
    //  verify in-addr.arpa. domain
    //

    ASSERT( pLookupName->cchLabelArray[ i ] == 7 );
    ASSERT( ! _strnicmp(
                pLookupName->pchLabelArray[ i ],
                "in-addr",
                7 ) );

    DnsAddr_BuildFromIp4( pDnsAddr, ipAddress, 0 );
    
    return TRUE;
}



BOOL
Name_WriteLookupNameForIpAddress(
    IN      LPSTR           pszIpAddress,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Write lookup name for IP address.

Arguments:

    pszIpAddress -- IP address of reverse lookup node desired

    pLookupName -- lookup name to create

Return Value:

    TRUE if successfull.
    FALSE otherwise.

--*/
{
    LOOKUP_NAME looknameArpa;

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Getting lookup name for IP addres = %s\n",
            pszIpAddress ));
    }

    if ( ! Name_ConvertDottedNameToLookupName(
                "in-addr.arpa",
                0,
                & looknameArpa ) )
    {
        ASSERT( FALSE );
        return FALSE;
    }
    if ( ! Name_ConvertDottedNameToLookupName(
                pszIpAddress,
                0,
                pLookupName ) )
    {
        ASSERT( FALSE );
        return FALSE;
    }
    if ( ! Name_AppendLookupName(
                pLookupName,
                & looknameArpa ) )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    return TRUE;
}


//
//  End of name.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\packetq.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    packetq.h

Abstract:

    Domain Name System (DNS) Server

    Packet queue definitions.

    Packet queue is used for queuing queries to WINS and other
    name servers.

Author:

    Jim Gilroy (jamesg)     August 21, 1995

Revision History:

--*/


#ifndef _DNS_PACKETQ_INCLUDED_
#define _DNS_PACKETQ_INCLUDED_


//
//  Packet queue structure
//

typedef struct _packet_queue
{
    LIST_ENTRY          listHead;       //  list of messages
    CRITICAL_SECTION    csQueue;        //  protecting CS
    LPSTR               pszName;        //  queue name
    HANDLE              hEvent;         //  event for queue

    //  flags

    BOOL        fQueryTimeOrder;
    BOOL        fDiscardExpiredOnQueuing;
    BOOL        fDiscardDuplicatesOnQueuing;
    DWORD       dwMaximumElements;

    //
    //  counters
    //

    DWORD       cLength;
    DWORD       cQueued;
    DWORD       cDequeued;
    DWORD       cTimedOut;

    //
    //  time out
    //

    DWORD       dwDefaultTimeout;       //  def timeout, if dwExpireTime not set
    DWORD       dwMinimumTimeout;       //  minimum timeout packet will have

    WORD        wXid;                   //  XID for referrals
}
PACKET_QUEUE, *PPACKET_QUEUE;


//
//  Queue behavior flags
//

#define QUEUE_SET_EVENT             (0x00000001)
#define QUEUE_DISCARD_EXPIRED       (0x00000002)
#define QUEUE_DISCARD_DUPLICATES    (0x00000004)
#define QUEUE_QUERY_TIME_ORDER      (0x00000008)

#define QUEUE_DEFAULT_MAX_ELEMENTS  5000


//
//  Message queued check
//

#define IS_MSG_QUEUED(pMsg)     ( (pMsg)->dwQueuingTime != 0 )


//
//  Queue validation
//

BOOL
PQ_ValidatePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    );

#define VALIDATE_PACKET_QUEUE(pQueue)   PQ_ValidatePacketQueue(pQueue)


//
//  Queue locking
//

#if DBG
#define LOCK_QUEUE(pQueue)                          \
    {                                               \
        EnterCriticalSection( &pQueue->csQueue );   \
        VALIDATE_PACKET_QUEUE(pQueue);              \
    }

#define UNLOCK_QUEUE(pQueue)                        \
    {                                               \
        VALIDATE_PACKET_QUEUE(pQueue);              \
        LeaveCriticalSection( &pQueue->csQueue );   \
    }

#else
#define LOCK_QUEUE(pQueue)      EnterCriticalSection( &pQueue->csQueue )
#define UNLOCK_QUEUE(pQueue)    LeaveCriticalSection( &pQueue->csQueue )
#endif


PPACKET_QUEUE
PQ_CreatePacketQueue(
    IN      LPSTR           pszQueueName,
    IN      DWORD           dwFlags,
    IN      DWORD           dwDefaultTimeout,
    IN      DWORD           dwMaximumElements
    );

VOID
PQ_CleanupPacketQueueHandles(
    IN OUT  PPACKET_QUEUE   pQueue
    );

VOID
PQ_DeletePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    );

BOOL
PQ_QueuePacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
PQ_QueuePacketSetEvent(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
PQ_QueuePacketEx(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    );

PDNS_MSGINFO
PQ_DequeueNextPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    );

VOID
PQ_YankQueuedPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
PQ_DequeueTimedOutPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    OUT     PDWORD          pdwTimeout
    );

//  Queue cleanup

VOID
PQ_DiscardDuplicatesOfNewPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsgNew,
    IN      BOOL            fAlreadyLocked
    );

VOID
PQ_DiscardExpiredQueuedPackets(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    );

//  XID queuing

WORD
PQ_QueuePacketWithXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
PQ_QueuePacketWithXidAndSend(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
PQ_DequeuePacketWithMatchingXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      WORD            wMatchXid
    );

BOOL
PQ_IsQuestionAlreadyQueued(
    IN      PPACKET_QUEUE   pQueue,
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    );


//  UPDATE queuing

PDNS_MSGINFO
PQ_DequeueNextPacketOfUnlockedZone(
    IN OUT  PPACKET_QUEUE   pQueue
    );

PDNS_MSGINFO
PQ_DequeueNextFreshPacketMatchingZone(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      PZONE_INFO      pZone
    );


VOID
PQ_WalkPacketQueueWithFunction(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      VOID            (*pFunction)( PDNS_MSGINFO  )
    );

#endif  //  _DNS_PACKETQ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\nameutil.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nameutil.h

Abstract:

    Domain Name System (DNS) Server

    Name utility definitions.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/

#ifndef _NAMEUTIL_INCLUDED_
#define _NAMEUTIL_INCLUDED_


//
//  Simple downcase for ASCII
//

#define DOWNCASE_ASCII(ch)      ((ch)+ 0x20)

//  no side effects allowed

#define IS_ASCII_UPPER(ch)      (ch <= 'Z' && ch >= 'A')



//
//  Reading and writing names\strings to file
//

//
//  Character attributes bitfields
//
//  Read
//      - can be read ok (directly)
//      - terminates token
//      - terminates quoted string
//
//  Print
//      - print quoted in token (unquoted string)
//      - print octal in token
//      - print quoted in quoted string
//      - print octal in quoted string
//

#define B_CHAR_NON_RFC          0x0001
#define B_NUMBER                0x0002
#define B_UPPER                 0x0004
#define B_SLASH                 0x0008
#define B_DOT                   0x0010

#define B_READ_TOKEN_STOP       0x0100
#define B_READ_STRING_STOP      0x0200
#define B_READ_WHITESPACE       0x0400

#define B_PRINT_TOKEN_QUOTED    0x1000
#define B_PRINT_TOKEN_OCTAL     0x2000
#define B_PRINT_STRING_QUOTED   0x4000
#define B_PRINT_STRING_OCTAL    0x8000

//
//  Handy combinations
//

//  combined mask to mark characters that stop read for token or string

#define B_READ_STOP             (B_READ_TOKEN_STOP | B_READ_STRING_STOP)

//  mask for chars that need special processing
//  if character doesn't hit mask, then can be skipped without checking
//  for further processing

#define B_READ_MASK             (B_READ_STOP | B_READ_WHITESPACE | B_SLASH)


//  parsing name special chars are slash and dot

#define B_PARSE_NAME_MASK       (B_DOT | B_SLASH)


#define B_PRINT_QUOTED          (B_PRINT_TOKEN_QUOTED | B_PRINT_STRING_QUOTED)
#define B_PRINT_OCTAL           (B_PRINT_TOKEN_OCTAL | B_PRINT_STRING_OCTAL)

#define B_PRINT_TOKEN_MASK      (B_PRINT_TOKEN_QUOTED | B_PRINT_TOKEN_OCTAL)
#define B_PRINT_STRING_MASK     (B_PRINT_STRING_QUOTED | B_PRINT_STRING_OCTAL)

#define B_PRINT_MASK            (B_PRINT_TOKEN_MASK | B_PRINT_STRING_MASK)

//
//  printable characters with no special meaning
//

#define FC_RFC          (0)
#define FC_LOWER        (0)
#define FC_UPPER        (B_UPPER)
#define FC_NUMBER       (0)
#define FC_NON_RFC      (B_CHAR_NON_RFC)

//
//  special chars -- ; ( )
//      - terminates token
//      - does NOT terminate quoted string
//      - print quoted in token
//      - print directly in quoted string
//

#define FC_SPECIAL      (B_READ_TOKEN_STOP | B_PRINT_TOKEN_QUOTED)

//
//  dot
//      - no special read token action
//      - but special meaning in names (label separator)
//      - print quoted in name labels (hence all unquote strings) to avoid being
//          taken as label separator
//      - print directly in quoted string
//

#define FC_DOT          (B_DOT | B_PRINT_TOKEN_QUOTED)

//
//  quote
//      - no read effect in token
//      - terminates quoted string
//      - print quoted always (to avoid being taken as string start\stop)
//

#define FC_QUOTE        (B_READ_STRING_STOP | B_PRINT_QUOTED)

//
//  slash
//      - on read, turns on quote, or turns off if on, no termination effect
//      - print quoted always
//

#define FC_SLASH        (B_SLASH | B_PRINT_QUOTED)

//
//  blank
//      - is whitespace
//      - terminates token
//      - no terminate quoted string
//      - print octal in token
//      - print directly in quoted string
//

#define FC_BLANK        (B_READ_WHITESPACE | B_READ_TOKEN_STOP | B_PRINT_TOKEN_OCTAL)

//
//  tab
//      - is whitespace
//      - terminates token
//      - no terminate quoted string
//      - print octal always
//

#define FC_TAB          (B_READ_WHITESPACE | B_READ_TOKEN_STOP | B_PRINT_OCTAL)

//
//  return
//      - is whitespace
//      - terminates token or string
//      - print octal always
//

#define FC_RETURN       (B_READ_WHITESPACE | B_READ_STOP | B_PRINT_OCTAL)

//
//  newline
//      - unlike return, not whitespace, we use as official EOL token
//      - terminates token or string
//      - print octal always
//

#define FC_NEWLINE      (B_READ_STOP | B_PRINT_OCTAL)

//
//  control chars and other unprintables
//      - no read affect
//      - print octal always
//

#define FC_OCTAL        (B_CHAR_NON_RFC | B_PRINT_OCTAL)

//
//  zero
//      - treat as dot on read (some RPC strings may have NULL terminator)
//      - print octal always
//

#define FC_NULL         (B_DOT | B_CHAR_NON_RFC | B_PRINT_OCTAL)


//
//  treat HIGH (>127) characters as unprintable and
//      print octal equivalents
//

#define FC_HIGH         (FC_OCTAL)





//
//  Character to character type mapping table
//

extern  WORD    DnsFileCharPropertyTable[];


//
//  File name\string read routines
//

VOID
Name_VerifyValidFileCharPropertyTable(
    VOID
    );

//
//  Write name or string to file utils
//
//  Flag indicates slightly differing semantics for special characters
//  for different types of writes.
//
//

#define  FILE_WRITE_NAME_LABEL      (0)
#define  FILE_WRITE_QUOTED_STRING   (1)
#define  FILE_WRITE_DOTTED_NAME     (2)
#define  FILE_WRITE_FILE_NAME       (3)

PCHAR
FASTCALL
File_PlaceStringInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      DWORD           dwFlag,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
FASTCALL
File_PlaceNodeNameInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

PCHAR
File_WriteRawNameToFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    );

#define File_WriteDbaseNameToFileBuffer(a,b,c,d) \
        File_WriteRawNameToFileBuffer(a,b,(c)->RawName,d)

//
//  File read name
//

DNS_STATUS
Name_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    );

#define Name_ConvertFileNameToDbaseName(a,b,c) \
        Name_ConvertFileNameToCountName((a),(b),(c))

#define Name_ConvertDottedNameToDbaseName(a,b,c) \
        Name_ConvertFileNameToDbaseName((a),(b),(c))


//
//  Name utilites
//

PCHAR
Wire_SkipPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );


//
//  Lookup name utilites (lookname.c)
//

BOOL
Name_ConvertDottedNameToLookupName(
    IN      PCHAR           pchDottedName,
    IN      DWORD           cchDottedNameLength,    OPTIONAL
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_AppendLookupName(
    IN OUT  PLOOKUP_NAME    pLookupName,
    IN      PLOOKUP_NAME    pAppendName
    );

DWORD
Name_ConvertLookupNameToDottedName(
    OUT     PCHAR           pchDottedName,
    IN      PLOOKUP_NAME    pLookupName
    );

VOID
Name_WriteLookupNameForNode(
    IN      PDB_NODE        pNode,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_LookupNameToIpAddress(
    IN      PLOOKUP_NAME    pLookupName,
    OUT     PDNS_ADDR       pIpAddress
    );

BOOL
Name_WriteLookupNameForIpAddress(
    IN      LPSTR           pszIpAddress,
    IN      PLOOKUP_NAME    pLookupName
    );

BOOL
Name_ConvertRawNameToLookupName(
    IN      PCHAR           pchRawName,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_ConvertPacketNameToLookupName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_CompareLookupNames(
    IN      PLOOKUP_NAME    pName1,
    IN      PLOOKUP_NAME    pName2
    );


//
//  Name and node signatures (nameutil.c)
//

DWORD
FASTCALL
Name_MakeNodeNameSignature(
    IN OUT  PDB_NODE        pNode
    );

DWORD
FASTCALL
Name_MakeNameSignature(
    IN      PDB_NAME        pName
    );

DWORD
FASTCALL
Name_MakeRawNameSignature(
    IN      PCHAR           pchRawName
    );


//
//  Node to packet writing (nameutil.c)
//

BOOL
FASTCALL
Name_IsNodePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NODE        pNode
    );

BOOL
FASTCALL
Name_IsRawNamePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchRawName
    );


PCHAR
FASTCALL
Name_PlaceFullNodeNameInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInPacketWithCompressedZone(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode,
    IN      WORD            wZoneOffset,
    IN      PDB_NODE        pnodeZoneRoot
    );

PCHAR
FASTCALL
Name_PlaceNodeLabelInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode,
    IN      WORD            wCompressedDomain
    );

PCHAR
FASTCALL
Name_PlaceLookupNameInPacket(
    IN OUT  PCHAR           pchPacket,
    IN      PCHAR           pchStop,
    IN      PLOOKUP_NAME    pLookupName,
    IN      BOOL            fSkipFirstLabel
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR           pch,
    IN      PDB_NODE        pNode,
    IN      BOOL            fUseCompression
    );

#define Name_PlaceNodeNameInPacket(pMsg, pch, pNode) \
        Name_PlaceNodeNameInPacketEx( (pMsg), (pch), (pNode), TRUE )

//
//  Compression read\write (nameutil.c)
//

VOID
FASTCALL
Name_SaveCompressionForLookupName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PLOOKUP_NAME    pLookname,
    IN      PDB_NODE        pNode
    );

VOID
FASTCALL
Name_SaveCompressionWithNode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PDB_NODE        pNode
    );

PDB_NODE
FASTCALL
Name_CheckCompressionForPacketName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );


//
//  Reverse lookup name utils (nameutil.c)
//

BOOL
Name_GetIpAddressForReverseNode(
    IN      PDB_NODE        pNodeReverse,
    OUT     PDNS_ADDR       pIpAddress
    );


//
//  General write node to buffer routine
//

PCHAR
FASTCALL
Name_PlaceNodeNameInBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

#define Name_PlaceFullNodeNameInBuffer(a,b,c) \
        Name_PlaceNodeNameInBuffer(a,b,c,NULL )



//
//  RPC buffer routines
//

PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

//
//  NT4 RPC buffer routines
//

PCHAR
FASTCALL
Name_PlaceReverseNodeNameAsIpAddressInBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnodeToWrite
    );

PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    );

PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );




//
//  Count name \ Dbase name (name.c)
//

DWORD
Name_SizeofCountName(
    IN      PCOUNT_NAME     pName
    );

#define Name_SizeofDbaseNameFromCountName(pname) \
        Name_SizeofCountName(pname)


VOID
Name_ClearCountName(
    IN      PCOUNT_NAME     pName
    );

PDB_NAME
Name_SkipCountName(
    IN      PCOUNT_NAME     pName
    );

BOOL
Name_IsEqualCountNames(
    IN      PCOUNT_NAME     pName1,
    IN      PCOUNT_NAME     pName2
    );

BOOL
Name_ValidateCountName(
    IN      PCOUNT_NAME     pName
    );

DNS_STATUS
Name_AppendCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCOUNT_NAME     pAppendName
    );

DNS_STATUS
Name_CopyCountName(
    OUT     PCOUNT_NAME     pOutName,
    IN      PCOUNT_NAME     pCopyName
    );

//  macro to dbase name routines

#define Name_SizeofDbaseName(a)             Name_SizeofCountName(a)
#define Name_ClearDbaseName(a)              Name_ClearCountName(a)
#define Name_SkipDbaseName(a)               Name_SkipCountName(a)
#define Name_IsEqualDbaseNames(a,b)         Name_IsEqualCountNames(a,b)
#define Name_ValidateDbaseName(a)           Name_ValidateCountName(a)
#define Name_AppendDbaseName(a,b)           Name_AppendCountName(a,b)
#define Name_CopyDbaseName(a,b)             Name_CopyCountName(a,b)

#define Name_CopyCountNameToDbaseName(a,b)  Name_CopyCountName((a),(b))

#define Name_LengthDbaseNameFromCountName(a) \
        Name_SizeofCountName(a)


//
//  From Dotted name
//

PCOUNT_NAME
Name_CreateCountNameFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    );

DNS_STATUS
Name_AppendDottedNameToCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    );

#define Name_AppendDottedNameToDbaseName(a,b,c) \
        Name_AppendDottedNameToCountName(a,b,c)


//
//  Node to counted name
//

VOID
Name_NodeToCountName(
    OUT     PCOUNT_NAME         pName,
    IN      PDB_NODE            pNode
    );

#define Name_NodeToDbaseName(a,b)   Name_NodeToCountName(a,b)


//
//  Packet name reading utils
//

PCHAR
Name_PacketNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchEnd
    );

#define Name_PacketNameToDbaseName( pResult, pMsg, pName, pchEnd ) \
        Name_PacketNameToCountName( pResult, pMsg, pName, pchEnd )

DWORD
Name_SizeofCountNameForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR *         ppchPacketName,
    IN      PCHAR           pchEnd
    );

#define Name_LengthDbaseNameForPacketName(a,b,c) \
        Name_SizeofCountNameForPacketName(a,b,c)

PCOUNT_NAME
Name_CreateCountNameFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );

#define Name_CreateDbaseNameFromPacketName(a,b) \
        Name_CreateCountNameFromPacketName(a,b)


//
//  Dbase to packet
//

PCHAR
Name_WriteCountNameToPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchCurrent,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fCompression
    );

#define Name_WriteDbaseNameToPacketEx(m,p,n,f) \
        Name_WriteCountNameToPacketEx(m,p,n,f)

//  version without compression flag

#define Name_WriteDbaseNameToPacket(m,p,n)    \
        Name_WriteCountNameToPacketEx(m,p,n,TRUE)

//
//  Dbase to RPC buffer
//

PCHAR
Name_WriteCountNameToBufferAsDottedName(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    );

PCHAR
Name_WriteDbaseNameToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    );

PCHAR
Name_WriteDbaseNameToRpcBufferNt4(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName
    );

DWORD
Name_ConvertRpcNameToCountName(
    IN      PCOUNT_NAME     pName,
    IN OUT  PDNS_RPC_NAME   pRpcName
    );


#endif  // _NAMEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\nbstat.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nbstat.c

Abstract:

    Domain Name System (DNS) Server

    Reverse lookups using netBIOS node status.

Author:

    Jim Gilroy (jamesg)         October, 1995

    Borrowed NBT lookup code from David Treadwell's NT winsock.

Revision History:

--*/


#include "dnssrv.h"

#include <nbtioctl.h>
#include <nb30.h>
#include <nspapi.h>
#include <svcguid.h>


//
//  NBT IOCTL reponse structures
//

typedef struct _DNS_NBT_INFO
{
    IO_STATUS_BLOCK     IoStatus;
    tIPANDNAMEINFO      IpAndNameInfo;
    CHAR                Buffer[2048];
}
DNS_NBT_INFO, *PDNS_NBT_INFO;

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
}
tADAPTERSTATUS;

//
//  NBT handles
//
//  On multihomed may have multiple NBT interfaces.  Need handle
//  to each one.
//

DWORD   cNbtInterfaceCount;
PHANDLE pahNbtHandles;

DWORD   dwInterfaceBitmask;

DWORD   dwNbtBufferLength;

//
//  Nbstat thread wait parameters
//
//  Have separate pointer to NBT events in wait array (not separate array)
//  for coding simplicity.
//

DWORD   cEventArrayCount;
PHANDLE phWaitEventArray;
PHANDLE phNbstatEventArray;

//
//  Status code for uncompleted Nbstat queries
//

#define DNS_NBT_NO_STATUS   (0xdddddddd)

//
//  Nbstat global flag
//

BOOL    g_bNbstatInitialized;

//
//  Nbstat queues
//      - public for recv() threads to queue queries to nbstat
//      - private for holding queries during lookup
//

PPACKET_QUEUE   pNbstatQueue;
PPACKET_QUEUE   pNbstatPrivateQueue;


//
//  Nbstat timeout
//

#define NBSTAT_QUERY_HARD_TIMEOUT     (15)          // fifteen seconds
#define NBSTAT_TIMEOUT_ALL_EVENTS (0xffffffff)


//
//  Private protos
//

VOID
FASTCALL
makeNbstatRequestThroughNbt(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
buildNbstatWaitEventArray(
    VOID
    );

VOID
processNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    );

VOID
sendNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      LPSTR           pszResultName
    );

VOID
cleanupNbstatQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    );

VOID
cancelOutstandingNbstatRequests(
    VOID
    );

BOOL
openNbt(
    VOID
    );

VOID
closeNbt(
    VOID
    );

PDNS_NBT_INFO
allocateNbstatBuffer(
    VOID
    );

VOID
freeNbstatBuffer(
    IN      PDNS_NBT_INFO   pBuf
    );



BOOL
FASTCALL
Nbstat_MakeRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Make NetBIOS reverse node status request.

    Called by recv() thread when NBSTAT lookup indicated for query.

Arguments:

    pQuery -- request to use nbstat lookup for

Return Value:

    TRUE -- if successfully made nbstat request
    FALSE -- if failed

--*/
{
    INT             err;
    DNS_ADDR        ip;
    PDB_RECORD      pnbstatRR;
    NTSTATUS        status;

    //
    //  If WinsR functionality is diabled, do nothing and return FALSE
    //  to force the caller to continue processing the packet.
    //
    
    if ( !SrvCfg_dwEnableWinsR )
    {
        return FALSE;
    }
    
    ASSERT( pQuery );
    ASSERT( g_bNbstatInitialized );

    IF_DEBUG( NBSTAT )
    {
        Dbg_MessageNameEx(
            "No answer for ",
            pQuery->MessageBody,
            pQuery,
            NULL,       // default end to end of message
            " in database, doing NBSTAT lookup\n" );
    }

    //
    //  get NBSTAT info for this zone
    //      - Nbstat queries ALWAYS for the zone the question name
    //      - possible NBSTAT turned off for this zone
    //

    pQuery->pzoneCurrent = pZone;
    pnbstatRR = pZone->pWinsRR;

    if ( !pnbstatRR )
    {
        DNS_PRINT(( "ERROR:  NBSTAT lookup for zone without NBSTAT RR\n" ));
        TEST_ASSERT( pZone->pWinsRR );
        return FALSE;
    }
    ASSERT( pnbstatRR->wType == DNS_TYPE_WINSR );
    ASSERT( pnbstatRR->Data.WINSR.dwCacheTimeout );
    ASSERT( pnbstatRR->Data.WINSR.dwLookupTimeout );
    pQuery->U.Nbstat.pRR = pnbstatRR;

    //
    //  Only handle direct lookup (questions)
    //
    //  DCR:  nbstat following CNAME, but only if customer requires
    //      note, fix would require
    //          - IP write to use last name
    //          - node to be for last name
    //          - finish either to skip Send_NameError() or fix it
    //              to handle AnswerCount != 0

    if ( pQuery->Head.AnswerCount != 0 )
    {
        DNS_DEBUG( NBSTAT, (
            "NBSTAT lookup for non-question rejected\n"
            "    packet = %p\n",
            pQuery ));
        return FALSE;
    }

    //
    //  For reverse lookup we send to address indicated by the DNS question
    //  name.
    //
    //  The first 4 labels of the question, are the address bytes in
    //  reverse order.
    //
    //  Example:
    //      question: (2)22(2)80(2)55(3)157(7)in-addr(4)arpa(0)
    //      then send to 157.55.80.22
    //
    //  Reject:
    //      - reverse lookups with less than four octets
    //      - queries for zero or broadcast address
    //
    //  Note:
    //  The rest of the sockaddr (family + port) so we can just
    //  copy the template and change the address.
    //
    //  Also, the netBIOS question name, is the same for all these
    //  reverse queries -- set to specify request for all names.
    //

    if ( !Name_LookupNameToIpAddress(
                pQuery->pLooknameQuestion,
                &ip ) )
    {
        return FALSE;
    }
    DNS_DEBUG( NBSTAT, (
        "Nbstat lookup for address %s\n",
        DNSADDR_STRING( &ip ) ));

    //
    //  Reject broadcast and zero address queries
    //
    //  Note:  automated broadcast and zero zones should screen these out.
    //

    if ( DnsAddr_IsClear( &ip ) )
    {
        DNS_PRINT(( "ERROR:  Attempted invalid address reverse lookup\n" ));
        return FALSE;
    }

    //
    //  Queue request to NBSTAT thread
    //

    DnsAddr_Copy( &pQuery->U.Nbstat.ipNbstat, &ip );

    PQ_QueuePacketEx(
        pNbstatQueue,
        pQuery,
        FALSE );

    DNS_DEBUG( NBSTAT, (
        "Queued query at %p to NBSTAT thread using event %p\n",
        pQuery,
        pNbstatQueue->hEvent ));

    STAT_INC( WinsStats.WinsReverseLookups );
    PERF_INC( pcWinsReverseLookupReceived );     // PerfMon hook

    return TRUE;
}



VOID
FASTCALL
makeNbstatRequestThroughNbt(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Make NetBIOS reverse node status request through NBT.

Arguments:

    pQuery -- request to use nbstat lookup for

Return Value:

    TRUE -- if successfully made nbstat request
    FALSE -- if failed

--*/
{
    INT             err;
    NTSTATUS        status;
    UINT            j;
    ULONG           SizeInput;
    PDNS_NBT_INFO   pnbtInfo;

    ASSERT( pQuery );
    ASSERT( pQuery->pzoneCurrent );
    ASSERT( pQuery->U.Nbstat.pRR );
    ASSERT( g_bNbstatInitialized );
    ASSERT( pQuery->Head.AnswerCount == 0 );


    IF_DEBUG( NBSTAT )
    {
        DNS_PRINT((
            "Making nbstat query through NBT for query at %p\n",
            pQuery ));
    }

    //
    //  Allocate space for nbstat info
    //      - NBStat events
    //      - NBT IOCTL recieve buffer
    //

    pQuery->U.Nbstat.pNbstat = pnbtInfo = allocateNbstatBuffer();
    if ( !pnbtInfo )
    {
        DNS_PRINT(( "ERROR:  Allocating nbstat block failed\n" ));
        goto ServerFailure;
    }
    IF_DEBUG( NBSTAT )
    {
        DNS_PRINT((
            "Setup to call nbstat for query %p.  Buffer at %p\n",
            pQuery,
            pnbtInfo ));
    }

    //
    //  Initialize flags
    //

    pQuery->fDelete = FALSE;
    pQuery->U.Nbstat.fNbstatResponded = FALSE;
    pQuery->U.Nbstat.dwNbtInterfaceMask = 0;

    //
    //  Make the adapter status request on each NBT interface
    //

    for ( j=0; j < cNbtInterfaceCount; j++ )
    {
        tIPANDNAMEINFO * pipnameInfo = &pnbtInfo->IpAndNameInfo;
        ASSERT( pipnameInfo );

        IF_DEBUG( NBSTAT )
        {
            DNS_PRINT((
                "Making nbstat call for query %p, buffer at %p\n",
                pQuery,
                pnbtInfo ));
        }

        //  init the address info block

        RtlZeroMemory(
            pipnameInfo,
            sizeof(tIPANDNAMEINFO) );

        //  FIXIP6: make sure I have correct byte ordering
        //  pipnameInfo->IpAddress = ntohl( pQuery->U.Nbstat.ipNbstat );

        pipnameInfo->IpAddress = ntohl( DnsAddr_GetIp4( &pQuery->U.Nbstat.ipNbstat ) );

        pipnameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
        pipnameInfo->NetbiosAddress.TAAddressCount = 1;
        pipnameInfo->NetbiosAddress.Address[0].AddressLength
                                        = sizeof(TDI_ADDRESS_NETBIOS);
        pipnameInfo->NetbiosAddress.Address[0].AddressType
                                        = TDI_ADDRESS_TYPE_NETBIOS;
        pipnameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
                                        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
        SizeInput = sizeof(tIPANDNAMEINFO);

        //
        //  init the status
        //  status code is initialize to a non-returnable value
        //  a change in this status is how we know NBT IOCTL has
        //  completed for this adapter
        //

        pnbtInfo->IoStatus.Status = DNS_NBT_NO_STATUS;

        //
        //  drop adapter status IOCTL
        //

        status = NtDeviceIoControlFile(
                     pahNbtHandles[j],
                     phNbstatEventArray[j],
                     NULL,
                     NULL,
                     & pnbtInfo->IoStatus,
                     IOCTL_NETBT_ADAPTER_STATUS,
                     pipnameInfo,
                     sizeof(tIPANDNAMEINFO),
                     pnbtInfo->Buffer,
                     sizeof(pnbtInfo->Buffer) );
        if ( status != STATUS_PENDING )
        {
            pnbtInfo->IoStatus.Status = status;

            DNS_PRINT((
                "WARNING:  Nbstat NtDeviceIoControlFile status %p,\n"
                "    not STATUS_PENDING\n",
                status ));

            //  set bit to indicate this NBT interface responded
            //  if all fail, return FALSE to do SERVER_FAILURE return

            pQuery->U.Nbstat.dwNbtInterfaceMask |= (1 << j);

            if ( pQuery->U.Nbstat.dwNbtInterfaceMask == dwInterfaceBitmask )
            {
                goto ServerFailure;
            }
        }

        //  get block for next adapter

        pnbtInfo++;
    }

    DNS_DEBUG( NBSTAT, (
        "Launched NBSTAT for address %s for query at %p\n",
        IP_STRING( pQuery->U.Nbstat.ipNbstat ),
        pQuery ));

    //
    //  put query on private nbstat queue during NBT lookup
    //  set expiration timeout based on WINS-R record for zone
    //

    pQuery->dwExpireTime = ((PDB_RECORD)pQuery->U.Nbstat.pRR)
                                    ->Data.WINSR.dwLookupTimeout;
    PQ_QueuePacketWithXid(
        pNbstatPrivateQueue,
        pQuery );
    return;

ServerFailure:

    DNS_DEBUG( ANY, (
        "ERROR:  Failed nbstat lookup for query at %p\n",
        pQuery ));

    if ( pQuery->U.Nbstat.pNbstat )
    {
        freeNbstatBuffer( pQuery->U.Nbstat.pNbstat );
        pQuery->U.Nbstat.pNbstat = NULL;
    }
    pQuery->fDelete = TRUE;
    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



VOID
processNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    )
/*++

Routine Description:

    Use NBT to do node status query, to resolve host name for IP address.

    This code is lifted directly from winsock project SockNbtResolveAddr(),
    with minor modifications to also extract netBIOS scope.

Arguments:

    pQuery -- query for which nbstat done

    iEvent -- event index which succeeded

Return Value:

    None.

--*/
{
    DWORD       i;          //  name counter
    NTSTATUS    status;
    BOOL        success = FALSE;

    PDNS_NBT_INFO   pnbtInfo;

    tADAPTERSTATUS * pAdapterStatus;
    LONG            cNameCount;             //  count of names in response
    PNAME_BUFFER    pNames;
    PNAME_BUFFER    pNameBest = NULL;       //  best name found so far
    UCHAR           ucNameType;             //  name type <00>, <20>, etc
    BOOLEAN         fFoundServer = FALSE;   //  found server byte

    CHAR            achResultName[ DNS_MAX_NAME_LENGTH ];
    DWORD           dwResultNameLength = DNS_MAX_NAME_LENGTH;


    DNS_DEBUG( NBSTAT, (
        "Nbstat response for query at %p on adapter %d\n"
        "    Queried address %s\n",
        pQuery,
        iEvent,
        IP_STRING(pQuery->U.Nbstat.ipNbstat) ));

    //
    //  Set bit to indicate this NBT interface responded
    //

    i = 1;
    i <<= iEvent;
    pQuery->U.Nbstat.dwNbtInterfaceMask |= i;

    //
    //  If already sent response -- no further action needed
    //

    if ( pQuery->U.Nbstat.fNbstatResponded )
    {
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    //
    //  check response from this NBT adapter
    //

    pnbtInfo = &((PDNS_NBT_INFO)pQuery->U.Nbstat.pNbstat)[iEvent];

    pAdapterStatus = (tADAPTERSTATUS *)pnbtInfo->Buffer;

    if ( !NT_SUCCESS(pnbtInfo->IoStatus.Status)
            ||
        pAdapterStatus->AdapterInfo.name_count == 0 )
    {
        DNS_DEBUG( NBSTAT, (
            "Nbstat response empty or error for query at %p\n"
            "    iEvent = %d\n"
            "    status = %p\n"
            "    name count = %d\n",
            pQuery,
            iEvent,
            pnbtInfo->IoStatus.Status,
            pAdapterStatus->AdapterInfo.name_count ));

        //  if WAIT_TIMEOUT     in main loop, caused us to cancel
        //  then send back SERVER_FAILED when NBT completes the IRP

        if ( pnbtInfo->IoStatus.Status == STATUS_CANCELLED )
        {
            pQuery->U.Nbstat.fNbstatResponded = TRUE;
            Reject_Request( pQuery, DNS_RCODE_SERVER_FAILURE, 0 );
        }
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    pNames = pAdapterStatus->Names;
    cNameCount = pAdapterStatus->AdapterInfo.name_count;

    //
    //  find best name in NBT packet -- write to DNS packet
    //
    //  name priority:
    //      - workstation -- name<00>
    //      - server -- name<20>
    //      - any unique name
    //
    //  toss if no unique names
    //
    //  note:  names are given in ASCII, with blank (0x20) padding on
    //      right
    //

    while( cNameCount-- )
    {
        //  skip group names

        if ( pNames->name_flags & GROUP_NAME )
        {
            pNames++;
            continue;
        }

        //  always take WORKSTATION name
        //  SERVER name better than arbitrary unique name
        //  take any unique name if none found yet

        ucNameType = pNames->name[NCBNAMSZ-1];

        DNS_DEBUG( NBSTAT, (
            "Checking unique nbstat name %.*s<%02x>\n.",
            NCBNAMSZ-1,
            pNames->name,
            ucNameType ));

        if ( ucNameType == NETBIOS_WORKSTATION_BYTE )
        {
            pNameBest = pNames;
            break;
        }
        else if ( ucNameType == NETBIOS_SERVER_BYTE
                &&
                ! fFoundServer )
        {
            fFoundServer = TRUE;
            pNameBest = pNames;
        }
        else if ( !pNameBest )
        {
            pNameBest = pNames;
        }

        //  get next NAME_BUFFER structure

        pNames++;
    }

    //
    //  response but no unique name
    //

    if ( !pNameBest )
    {
        DNS_DEBUG( NBSTAT, ( "Nbstat response empty or error\n" ));
        pQuery->U.Nbstat.fNbstatResponded = TRUE;
        Send_NameError( pQuery );
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    //
    //  found a unique name -- use it to respond
    //  copy name until first space or end of name
    //

    for ( i = 0; i < NCBNAMSZ-1 && pNameBest->name[i] != ' '; i++ )
    {
        achResultName[i] = pNameBest->name[i];
    }

    dwResultNameLength = i;
    achResultName[i] = '\0';

    DNS_DEBUG( NBSTAT, (
        "Valid Nbstat name %s <%2x> in adpater status name list,\n"
        "    querying for IP address %s, from query at %p\n",
        achResultName,
        ucNameType,
        IP_STRING(pQuery->U.Nbstat.ipNbstat),
        pQuery ));

    ASSERT( ! pQuery->fDelete );

    pQuery->U.Nbstat.fNbstatResponded = TRUE;
    sendNbstatResponse(
        pQuery,
        achResultName );

    cleanupNbstatQuery( pQuery, iEvent );
}



VOID
sendNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      LPSTR           pszResultName
    )
/*++

Routine Description:

    Process NBT node status response.

Arguments:

    pQuery -- query matched to WINS response

    pszResultName -- name returned by NBT

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pnbstatRR;
    PDB_NODE    pnode;
    PDB_NODE    pnodeResult;
    DNS_STATUS  status;
    DWORD       lengthResult;
    WCHAR       unicodeBuffer[ MAX_WINS_NAME_LENGTH+1 ];
    CHAR        utf8Buffer[ DNS_MAX_LABEL_LENGTH ];

    ASSERT( pQuery );
    ASSERT( pQuery->pzoneCurrent );
    ASSERT( pQuery->dwQueryTime );


    STAT_INC( WinsStats.WinsReverseResponses );
    PERF_INC( pcWinsReverseResponseSent );       // PerfMon hook

    //
    //  get zone nbstat
    //      - if now off, send name error
    //

    pnbstatRR = pQuery->pzoneCurrent->pWinsRR;
    if ( !pnbstatRR )
    {
        DNS_DEBUG( ANY, (
            "WARNING:  WINSR lookup on zone %s, was discontinued\n"
            "    after nbstat lookup for query %p was launched\n",
            pQuery->pzoneCurrent->pszZoneName,
            pQuery ));
        Send_NameError( pQuery );
        return;
    }

    if ( pnbstatRR != pQuery->U.Nbstat.pRR )
    {
        PDB_RECORD  ptemprr = pQuery->U.Nbstat.pRR;

        DNS_DEBUG( ANY, (
            "WARNING:  WINSR lookup on zone %s was changed\n"
            "    after nbstat lookup for query %p was launched\n"
            "    new WINSR = %p\n"
            "    old WINSR = %p\n",
            pQuery->pzoneCurrent->pszZoneName,
            pQuery,
            pnbstatRR,
            ptemprr ));

        ASSERT( ptemprr->wType == DNS_TYPE_WINSR );
        //  shouldn't be on free list, should be on timeout free
        //ASSERT( IS_ON_FREE_LIST(prr) );
    }

    //
    //  validate zone WINSR record
    //      - legitimate to be on SLOW_FREE list, if just returned
    //      from context switch to thread that did WINSR update,
    //      but then MUST not be equal to existing zone WINS RR
    //      - not WINSR or in FREE list are code bugs
    //

    while ( pnbstatRR->wType != DNS_TYPE_WINSR ||
                IS_ON_FREE_LIST(pnbstatRR) ||
                IS_SLOW_FREE_RR(pnbstatRR) )
    {
        Dbg_DbaseRecord(
            "BOGUS NBSTAT RR!!!\n",
            pnbstatRR );

        ASSERT( pnbstatRR->wType == DNS_TYPE_WINSR );
        ASSERT( !IS_ON_FREE_LIST(pnbstatRR) );
        ASSERT( !IS_SLOW_FREE_RR(pnbstatRR) || pnbstatRR != pQuery->pzoneCurrent->pWinsRR );

        if ( pnbstatRR != pQuery->pzoneCurrent->pWinsRR )
        {
            pnbstatRR = pQuery->pzoneCurrent->pWinsRR;
            if ( !pnbstatRR )
            {
                Send_NameError( pQuery );
                return;
            }
            DNS_DEBUG( ANY, (
                "WARNING:  WINSR lookup on zone %s was changed during nbstat completion!\n"
                "    continuing with new WINSR = %p\n",
                pQuery->pzoneCurrent->pszZoneName,
                pnbstatRR ));
            continue;
        }
        goto ServerFailure;
    }


    //
    //  create owner node, if doesn't exist
    //

    pnode = pQuery->pnodeCurrent;
    if ( !pnode )
    {
        pnode = Lookup_ZoneNode(
                    pQuery->pzoneCurrent,
                    (PCHAR) pQuery->MessageBody,
                    pQuery,
                    NULL,               //  no lookup name
                    LOOKUP_NAME_FQDN,
                    NULL,               //  create
                    NULL );             //  following node ptr
        if ( !pnode )
        {
            ASSERT( FALSE );
            goto ServerFailure;
        }
    }
    IF_DEBUG( NBSTAT )
    {
        Dbg_NodeName(
            "NBSTAT adding PTR record to node ",
            pnode,
            "\n" );
    }

    //
    //  convert result name from OEM to UTF8
    //      - no-op if ASCII name
    //      - otherwise go to unicode and come back
    //

    lengthResult = strlen( pszResultName );

    if ( !Dns_IsStringAsciiEx( pszResultName, lengthResult ) )
    {
        DWORD   unicodeLength;
        DWORD   utf8Length;
        DWORD   i;

        status = RtlOemToUnicodeN(
                    unicodeBuffer,
                    (MAX_WINS_NAME_LENGTH * 2),
                    & unicodeLength,
                    pszResultName,
                    lengthResult );

        if ( status != ERROR_SUCCESS )
        {
            goto ServerFailure;
        }
        unicodeLength = unicodeLength / 2;

        DNS_DEBUG( NBSTAT, (
            "Nbstat response name %s converted to unicode %.*S (count=%d)\n",
            pszResultName,
            unicodeLength,
            unicodeBuffer,
            unicodeLength ));

        //  downcase in unicode to so don't mess it up

        i = CharLowerBuffW( unicodeBuffer, unicodeLength );
        if ( i != unicodeLength )
        {
            ASSERT( FALSE );
            goto ServerFailure;
        }

        utf8Length = DnsUnicodeToUtf8(
                        unicodeBuffer,
                        unicodeLength,
                        utf8Buffer,
                        DNS_MAX_LABEL_LENGTH );
        if ( utf8Length == 0 )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Converting NBTSTAT name to UTF8\n" ));
            ASSERT( FALSE );
            goto ServerFailure;
        }

        lengthResult = utf8Length;
        pszResultName = utf8Buffer;

        DNS_DEBUG( NBSTAT, (
            "Nbstat UTF8 result name %.*s (count = %d)\n",
            lengthResult,
            pszResultName,
            lengthResult ));
    }

    //
    //  cache RR in database
    //      - allocate the RR
    //      - fill in PTR record and cache timeout
    //      - rank is authoritative answer
    //

    prr = RR_AllocateEx(
                (WORD)(lengthResult + 1 +
                    Name_SizeofDbaseName( &pnbstatRR->Data.WINSR.nameResultDomain )),
                MEMTAG_RECORD_WINSPTR );

    IF_NOMEM( !prr )
    {
        goto ServerFailure;
    }
    prr->wType = DNS_TYPE_PTR;
    prr->dwTtlSeconds = pnbstatRR->Data.WINSR.dwCacheTimeout + pQuery->dwQueryTime;

    SET_RR_RANK( prr, RANK_CACHE_A_ANSWER );

    //
    //  build resulting PTR name from host name + result domain
    //

    status = Name_ConvertFileNameToCountName(
                & prr->Data.PTR.nameTarget,
                pszResultName,
                lengthResult );
    if ( status == ERROR_INVALID_NAME )
    {
        DNS_PRINT(( "ERROR:  Failed NBSTAT dbase name create!\n" ));
        ASSERT( FALSE );
    }
    status = Name_AppendCountName(
                & prr->Data.PTR.nameTarget,
                & pnbstatRR->Data.WINSR.nameResultDomain );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Failed NBSTAT dbase name append!\n" ));
        ASSERT( FALSE );
    }

    RR_CacheSetAtNode(
        pnode,
        prr,                //  first record
        prr,                //  last record
        pnbstatRR->Data.WINS.dwCacheTimeout,
        DNS_TIME() );       //  cache from current time

    //
    //  write RR to packet
    //
    //  always use compressed name pointing to original question name
    //      (right after header)
    //

    ASSERT( pQuery->wOffsetCurrent == sizeof(DNS_HEADER) );

    if ( !Wire_AddResourceRecordToMessage(
                pQuery,
                NULL,
                sizeof(DNS_HEADER),     // offset to question name in packet
                prr,
                0 ) )                   // flags
    {
        ASSERT( FALSE );        // should never be out of space in packet
        goto ServerFailure;
    }

    //  set answer count -- should be only answer

    ASSERT( pQuery->Head.AnswerCount == 0 );
    pQuery->Head.AnswerCount++;

    Send_Response( pQuery, 0 );
    return;

ServerFailure:

    //
    //  DEVNOTE:  redo NBSTAT query if failure?
    //
    //  but, if couldn't write RR, then this is truly a server failure
    //

    DNS_DEBUG( ANY, (
        "ERROR:  Nbstat response parsing error "
        "    sending server failure for query at %p\n",
        pQuery ));

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



//
//  Nbstat utilities
//

VOID
cleanupNbstatQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    )
/*++

Routine Description:

    Cleanup after NBStat query.

    Close events, free memory.

Arguments:

    pQuery -- query to cleanup

    iEvent -- event for which NBT IOCTL completed

Return Value:

    None.

--*/
{
    PDNS_NBT_INFO   pnbtInfo = pQuery->U.Nbstat.pNbstat;
    UINT            i;

    ASSERT( !pQuery->fDelete );

    //
    //  reset the status on this adapter, if all NBT IOCTLs not complete
    //

    if ( pQuery->U.Nbstat.dwNbtInterfaceMask != dwInterfaceBitmask )
    {
        ASSERT( pQuery->U.Nbstat.dwNbtInterfaceMask < dwInterfaceBitmask );

        //  status code is reset to a non-returnable value
        //  this keeps us from checking this query again when
        //  event for this adapter is signalled again

        pnbtInfo[iEvent].IoStatus.Status = DNS_NBT_NO_STATUS;
        return;
    }

    //
    //  all interfaces have responded -- dequeue
    //

    PQ_YankQueuedPacket(
        pNbstatPrivateQueue,
        pQuery );

    //
    //  query pronounced dead -- if no response to client yet, respond
    //

    if ( !pQuery->U.Nbstat.fNbstatResponded )
    {
        ASSERT( !pQuery->fDelete );
        pQuery->U.Nbstat.fNbstatResponded = TRUE;
        Send_NameError( pQuery );
    }

    //
    //  cleanup nbstat query
    //      - free nbstat buffer
    //      - free query
    //

    DNS_DEBUG( NBSTAT, (
        "Clearing nbstat query at %p\n",
        pQuery ));

    freeNbstatBuffer( pnbtInfo );
    pQuery->U.Nbstat.pNbstat = NULL;
    Packet_Free( pQuery );
}



VOID
cancelOutstandingNbstatRequests(
    VOID
    )
/*++

Routine Description:

    Cancell outstand NBT requests.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UINT            i;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    //  cancell outstanding I/O requests on each NBT interface
    //

    DNS_DEBUG( NBSTAT, ( "Cancelling outstaning nbstat requests I/O requests\n" ));

    for ( i = 0; i < cNbtInterfaceCount; i++ )
    {
        NtCancelIoFile(
            pahNbtHandles[i],
            &ioStatusBlock );
    }

    DNS_DEBUG( NBSTAT, ( "NBSTAT:  I/O requests cancelled\n" ));
}



//
//  NBStat Thread
//

DWORD
NbstatThread(
    IN      LPVOID  Dummy
    )
/*++

Routine Description:

    Nbstat thread.
        - send nbstat queries
        - processes response from NBT
        - timeout queries
        - sends DNS responses

Arguments:

    Dummy

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pquery;
    PDNS_NBT_INFO   pnbtInfo;
    DWORD           waitResult;
    DWORD           waitTimeout;
    INT             ievent;

    //
    //  Wait for the worker thread event to be signalled indicating
    //  that there is work to do, or for the termination event
    //  to be signalled indicating that we should exit.
    //

    while ( TRUE )
    {
        //
        //  wait
        //
        //  - wait event array includes:
        //      - shutdown event
        //      - nbstat queuing event (for new queries)
        //      - nbstat IOCTL response events (for nbstat responses)
        //
        //  - timeout
        //      - INFINITE if no outstanding queries
        //      - otherwise 2 seconds, to catch even shortest timeouts
        //          in reasonable time
        //

        waitTimeout = 2000;

        if ( !pNbstatPrivateQueue->cLength )
        {
            waitTimeout = INFINITE;
        }

        waitResult = WaitForMultipleObjects(
                            cEventArrayCount,
                            phWaitEventArray,
                            FALSE,              // any event stops wait
                            waitTimeout );

        DNS_DEBUG( NBSTAT, (
            "Nbstat wait completed\n"
            "    waitTimeout = %d\n"
            "    waitResult = %d\n"
            "    event index  = %d\n",
            waitTimeout,
            waitResult,
            waitResult - WAIT_OBJECT_0 ));

        //
        //  Check and possibly wait on service status
        //

        if ( fDnsThreadAlert )
        {
            if ( !Thread_ServiceCheck() )
            {
                IF_DEBUG( SHUTDOWN )
                {
                    DNS_PRINT(( "Terminating Worker thread\n" ));
                }
                return( 1 );
            }
        }

        //
        //  determine event or timeout
        //

        switch ( waitResult )
        {
        case WAIT_OBJECT_0:

            //
            //  first event is new query on nbstat queue
            //
            //  - send NBSTAT request for new queries
            //  - place on private nbstat queue
            //

            DNS_DEBUG( NBSTAT, (
                "Hit nbstat queuing event\n"
                "    Nbstat public queue length = %d\n",
                pNbstatQueue->cLength ));

            while ( pquery = PQ_DequeueNextPacket( pNbstatQueue, FALSE ) )
            {
                makeNbstatRequestThroughNbt( pquery );
            }
            break;

        case WAIT_TIMEOUT:
        {
            DWORD   currentTime = GetCurrentTimeInSeconds();
            BOOL    foutstandingQueries = FALSE;

            //
            //  send NAME_ERROR for any timed out queries
            //
            //  also track existence of unresponded, non-timed-out
            //  queries;  if none exist then can cancel NBT i/o to
            //  speed cleanup

            pquery = (PDNS_MSGINFO) pNbstatPrivateQueue->listHead.Flink;

            while ( (PLIST_ENTRY)pquery != &pNbstatPrivateQueue->listHead )
            {
                if ( !pquery->U.Nbstat.fNbstatResponded )
                {
                    if ( pquery->dwExpireTime < currentTime )
                    {
                        pquery->U.Nbstat.fNbstatResponded = TRUE;
                        Send_NameError( pquery );
                    }
                    else
                    {
                        foutstandingQueries = TRUE;
                    }
                }
                //  next query
                pquery = (PDNS_MSGINFO) ((PLIST_ENTRY)pquery)->Flink;
            }

            //
            //  if no outstanding nbstat requests -- cancel to speed cleanup
            //

            if ( !foutstandingQueries )
            {
                DNS_DEBUG( NBSTAT, (
                    "Cancelling NBT requests.  All queries responded to\n"
                    "    queue length = %d\n",
                    pNbstatPrivateQueue->cLength ));
                cancelOutstandingNbstatRequests();
            }
            break;
        }

        case WAIT_FAILED:

            ASSERT( FALSE );
            break;

#if DBG
        case WAIT_OBJECT_0 + 1:

            //  this is DNS shutdown event, if fired, should have
            //      exited above

            ASSERT( FALSE );
#endif

        default:

            //
            //  NBStat response
            //
            //  event signalled corresponds to an NBT response on a
            //  specific adapter
            //
            //  first reset event so that we are SURE that any completions
            //  after we check a query will be indicated
            //

            ievent = waitResult - WAIT_OBJECT_0 - 2;

            ASSERT( ievent < (INT)cNbtInterfaceCount );
            ResetEvent( phNbstatEventArray[ievent] );

            //
            //  check each outstanding Nbtstat query in the queue for
            //  status of NBT request on adapter corresponding to
            //  the signalled event
            //
            //  if status is NOT equal to status code set before query
            //  then NBT has responded to this query -- process it
            //
            //  note save next query before processing as on response
            //  query may be removed from the queue
            //

            pquery = (PDNS_MSGINFO) pNbstatPrivateQueue->listHead.Flink;

            while ( (PLIST_ENTRY)pquery != &pNbstatPrivateQueue->listHead )
            {
                PDNS_MSGINFO    pthisQuery = pquery;
                pquery = (PDNS_MSGINFO) ((PLIST_ENTRY)pquery)->Flink;

                ASSERT( pthisQuery->U.Nbstat.pNbstat );
                pnbtInfo = &((PDNS_NBT_INFO)pthisQuery->U.Nbstat.pNbstat)[ievent];

                if ( pnbtInfo->IoStatus.Status == DNS_NBT_NO_STATUS )
                {
                    //
                    //  DEVNOTE: if timed out, then we're hosed
                    //

                    continue;
                }
                
                processNbstatResponse( pthisQuery, ievent );
            }
            break;
        }

        //  loop until service shutdown
    }
}



//
//  Open and close NBT for lookup
//

BOOL
openNbt(
    VOID
    )
/*++

Routine Description:

    Opens NBT handles to use NBT to do reverse lookups.

    This routine is a clone of Dave Treadwell's SockOpenNbt() for winsock.

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    DNS_STATUS          status = STATUS_UNSUCCESSFUL;
    HKEY                nbtKey = NULL;
    PWSTR               deviceName = NULL;
    ULONG               deviceNameLength;
    ULONG               type;
    DWORD               interfaceCount;
    PWSTR               pwide;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      deviceString;
    OBJECT_ATTRIBUTES   objectAttributes;

    //
    //  First determine whether we actually need to open NBT.
    //

    if ( cNbtInterfaceCount > 0 )
    {
        return TRUE;
    }

    //
    //  First read the registry to obtain the device name of one of
    //  NBT's device exports.
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Linkage",
                0,
                KEY_READ,
                &nbtKey );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Determine the size of the device name.  We need this so that we
    //  can allocate enough memory to hold it.
    //

    deviceNameLength = 0;

    status = RegQueryValueExW(
                nbtKey,
                L"Export",
                NULL,
                &type,
                NULL,
                &deviceNameLength );
    if ( status != ERROR_MORE_DATA && status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Allocate enough memory to hold the mapping.
    //

    deviceName = ALLOC_TAGHEAP( deviceNameLength, MEMTAG_NBSTAT );
    IF_NOMEM( !deviceName )
    {
        goto Exit;
    }

    //
    //  Get the actual device names from the registry.
    //

    status = RegQueryValueExW(
                nbtKey,
                L"Export",
                NULL,
                &type,
                (PVOID)deviceName,
                &deviceNameLength );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Count the number of names exported by NetBT.
    //      - need at least one to operate
    //

    interfaceCount = 0;

    for ( pwide = deviceName; *pwide != L'\0'; pwide += wcslen(pwide) + 1 )
    {
        interfaceCount++;
    }
    if ( interfaceCount == 0 )
    {
        DNS_DEBUG( NBSTAT, ( "ERROR:  cNbtInterfaceCount = 0\n" ));
        goto Exit;
    }
    DNS_DEBUG( NBSTAT, (
        "Nbstat init:  cNbtInterfaceCount = %d\n",
        interfaceCount ));

    //
    //  Allocate NBT control handle for each interface.
    //

    pahNbtHandles = ALLOC_TAGHEAP_ZERO( (interfaceCount+1)*sizeof(HANDLE), MEMTAG_NBSTAT );
    IF_NOMEM( !pahNbtHandles )
    {
        goto Exit;
    }

    //
    //  Open NBT control channel for each interface
    //      - keep count only of those actually opened
    //      - log failures
    //      - need at least one to do nbstat lookups
    //

    for ( pwide = deviceName;  *pwide != L'\0';  pwide += wcslen(pwide) + 1 )
    {
        DNS_DEBUG( NBSTAT, (
            "Opening interface %S for NBSTAT\n",
            pwide ));

        RtlInitUnicodeString( &deviceString, pwide );

        InitializeObjectAttributes(
            &objectAttributes,
            &deviceString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL );

        status = NtCreateFile(
                     &pahNbtHandles[ cNbtInterfaceCount ],
                     GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                     // AllocationSize
                     0L,                                       // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE,       // ShareAccess
                     FILE_OPEN_IF,                             // CreateDisposition
                     0,                                        // CreateOptions
                     NULL,
                     0 );
        if ( NT_SUCCESS(status) )
        {
            cNbtInterfaceCount++;
            continue;
        }

        //
        //  NDIS WAN "adapters" will routinely fail;  rather than log spurious
        //  failure events, we'll just stop all adapter failure event logging
        //
        //  DEVNOTE:  nbstat failure logging, ignore NDIS WAN links
        //

        else
        {
#if 0
            PCHAR   parg = (PCHAR)pwide;

            DNS_LOG_EVENT_EX(
                DNS_EVENT_NBSTAT_ADAPTER_FAILED,
                1,
                & parg,
                NULL,
                status );
#endif
            DNS_DEBUG( ANY, (
                "ERROR:  Opening NBT for adapter %S failed\n",
                pwide ));
            continue;
        }
    }

Exit:

    DNS_DEBUG( NBSTAT, (
        "Opened %d adpaters for NBSTAT lookup\n",
        cNbtInterfaceCount ));

    //  cleanup

    if ( nbtKey )
    {
        RegCloseKey( nbtKey );
    }
    if ( deviceName )
    {
        FREE_HEAP( deviceName );
    }

    //
    //  if any adapters opened -- success
    //
    //  if unsuccessful, close NBT
    //      - note, since we only do this if unable to open any
    //      adapter, closeNbt just becomes memory free
    //

    if ( cNbtInterfaceCount == 0 )
    {
        DNS_PRINT(( "ERROR:  Unable to open NBT.\n\n" ));
        closeNbt();
    }

    return cNbtInterfaceCount > 0;
}



VOID
closeNbt(
    VOID
    )
/*++

Routine Description:

    Read, store names of and count of NBT devices.

    This info is stored, so that we can reopen NBT handles, whenever
    we are forced to cancel

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    None.

--*/
{
    INT i;

    //
    //  close NBT handles
    //

    if ( pahNbtHandles != NULL )
    {
        for ( i=0; pahNbtHandles[i] != NULL; i++ )
        {
            NtClose( pahNbtHandles[i] );
        }
        FREE_HEAP( pahNbtHandles );
    }

    pahNbtHandles = 0;
    cNbtInterfaceCount = 0;
}



//
//  Global Nbstat init and cleanup
//

VOID
Nbstat_StartupInitialize(
    VOID
    )
/*++

Routine Description:

    Startup init of NBSTAT globals -- whether using NBSTAT or not

Arguments:

    None

Globals:

    All NBSTAT globals that can be referenced whether NBSTAT used or
    not, are initialized.

Return Value:

    None.

--*/
{
    g_bNbstatInitialized = FALSE;

    cNbtInterfaceCount = 0;
    dwInterfaceBitmask = 0;
    dwNbtBufferLength = 0;

    pNbstatQueue = NULL;
    pNbstatPrivateQueue = NULL;
}



BOOL
Nbstat_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize for NBSTAT lookup.

Arguments:

    None

Globals:

    pNbstatQueue -- public nbstat queue for queuing queries for
        nbstat lookup

    pNbstatPrivateQueue -- private queue to hold queries during nbstat
        lookup

    cNbtInterfaceCount -- set to number of nbt handles

    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    DWORD  i;

    if ( g_bNbstatInitialized )
    {
        IF_DEBUG( INIT )
        {
            DNS_PRINT(( "Nbstat already initialized\n" ));
        }
        return TRUE;
    }

    //
    //  Init globals
    //

    cNbtInterfaceCount = 0;
    dwInterfaceBitmask = 0;
    dwNbtBufferLength = 0;

    //
    //  Open NBT interfaces
    //

    if ( !openNbt() )
    {
        goto Failed;
    }

    //
    //  create bitmask for all interfaces
    //

    dwInterfaceBitmask = 0;
    for (i=0; i<cNbtInterfaceCount; i++ )
    {
        dwInterfaceBitmask <<= 1;
        dwInterfaceBitmask++;
    }

    //
    //  set nbstat buffer allocation size
    //

    dwNbtBufferLength = cNbtInterfaceCount * sizeof(DNS_NBT_INFO);

    //
    //  Create public and private nbstat queues
    //
    //  recv threads queue packet to nbstat thread via public queue
    //      - set event when queue
    //      - expire packets to prevent queue backup
    //

    pNbstatQueue = PQ_CreatePacketQueue(
                        "Nbstat",
                        QUEUE_SET_EVENT |QUEUE_DISCARD_EXPIRED,
                        0,                          //  default timeout
                        0 );                        //  maximum elements
    if ( !pNbstatQueue )
    {
        goto Failed;
    }

    pNbstatPrivateQueue = PQ_CreatePacketQueue(
                            "NbstatPrivate",
                            0,                      //  flags
                            0,                      //  default timeout
                            0 );                    //  maximum elements
    if ( !pNbstatPrivateQueue )
    {
        goto Failed;
    }

    //
    //  create nbstat event array
    //      - includes shutdown and queuing events
    //      along with event for each NBT interface
    //

    cEventArrayCount = cNbtInterfaceCount + 2;

    phWaitEventArray = ALLOC_TAGHEAP( (sizeof(HANDLE) * cEventArrayCount), MEMTAG_NBSTAT );
    IF_NOMEM( !phWaitEventArray )
    {
        DNS_PRINT(( "ERROR:  Failure allocating nbstat event array\n" ));
        goto Failed;
    }

    phWaitEventArray[0] = pNbstatQueue->hEvent;
    phWaitEventArray[1] = hDnsShutdownEvent;

    //
    //  keep separate ptr to start of Nbstat events for simplicity
    //

    phNbstatEventArray = &phWaitEventArray[2];

    for (i=0; i<cNbtInterfaceCount; i++ )
    {
        HANDLE event = CreateEvent( NULL, TRUE, TRUE, NULL );
        if ( !event )
        {
            DNS_PRINT(( "ERROR:  unable to create NBSTAT events\n" ));
            goto Failed;
        }
        phNbstatEventArray[i] = event;
    }

    //
    //  Create nbstat thread
    //

    if ( !Thread_Create(
                "Nbstat Thread",
                NbstatThread,
                NULL,
                0 ) )
    {
        goto Failed;
    }

    g_bNbstatInitialized = TRUE;
    return TRUE;

Failed:

    DNS_PRINT(( "Nbstat initialization failed\n" ));

    DNS_LOG_EVENT(
        DNS_EVENT_NBSTAT_INIT_FAILED,
        0,
        NULL,
        NULL,
        0 );
    closeNbt();
    return FALSE;
}



VOID
Nbstat_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutsdown Nbstat and cleans up.

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    if ( !g_bNbstatInitialized )
    {
        return;
    }

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Shutting down Nbstat lookup\n" ));
    }
    g_bNbstatInitialized = FALSE;

    //
    //  cleanup NBSTAT queues
    //

    PQ_CleanupPacketQueueHandles( pNbstatQueue );
    PQ_CleanupPacketQueueHandles( pNbstatPrivateQueue );

#if 0
    //
    //  now as process memory cleanup unnecesary
    //
    //  cancel outstanding events, cleanup nbstat memory
    //

    PQ_WalkPacketQueueWithFunction(
        pNbstatPrivateQueue,
        cleanupNbstatQuery );

    //
    //  cleanup packet queues
    //

    PQ_DeletePacketQueue( pNbstatQueue );
    PQ_DeletePacketQueue( pNbstatPrivateQueue );
#endif

    //
    //  close NBT
    //

    closeNbt();
}



//
//  Nbstat buffer allocation / free list
//
//  Maintain a free list of packets to avoid reallocation to service
//  every query.
//
//  Implement as stack using single linked list.
//  List head points at first nbstat buffer.  First field in each nbstat buffer
//  serves as next ptr.  Last points at NULL.
//

PDNS_NBT_INFO   pNbstatFreeListHead = NULL;

INT cNbstatFreeListCount = 0;

#define NBSTAT_FREE_LIST_LIMIT (30)

#define NBSTAT_ALLOC_LOCK()      // currently only used by nbstat thread
#define NBSTAT_ALLOC_UNLOCK()    // currently only used by nbstat thread



PDNS_NBT_INFO
allocateNbstatBuffer(
    VOID
    )
/*++

Routine Description:

    Allocate an Nbstat buffer.

    Use free list if buffer available, otherwise heap.

Arguments:

    None.

Return Value:

    Ptr to new nbstat buffer info block, if successful.
    NULL otherwise.

--*/
{
    PDNS_NBT_INFO   pbuf;

    NBSTAT_ALLOC_LOCK();

    //
    //  Nbstat nbstat buffer buffer available on free list?
    //

    if ( pNbstatFreeListHead )
    {
        ASSERT( cNbstatFreeListCount != 0 );
        ASSERT( IS_DNS_HEAP_DWORD(pNbstatFreeListHead) );

        pbuf = pNbstatFreeListHead;
        pNbstatFreeListHead = *(PDNS_NBT_INFO *) pbuf;

        cNbstatFreeListCount--;
        NbstatStats.NbstatUsed++;
    }

    //
    //  no packets on free list -- create new
    //      - create nbstat events for buffer
    //

    else
    {
        ASSERT( cNbstatFreeListCount == 0 );

        pbuf = (PDNS_NBT_INFO) ALLOC_TAGHEAP( dwNbtBufferLength, MEMTAG_NBSTAT );
        IF_NOMEM( !pbuf )
        {
            NBSTAT_ALLOC_UNLOCK();
            return NULL;
        }
        NbstatStats.NbstatAlloc++;
        NbstatStats.NbstatUsed++;
    }

    ASSERT( !cNbstatFreeListCount || pNbstatFreeListHead );
    ASSERT( cNbstatFreeListCount > 0 || ! pNbstatFreeListHead );

    NBSTAT_ALLOC_UNLOCK();

    IF_DEBUG( HEAP )
    {
        DNS_PRINT((
            "Allocating/reusing nbstat buffer at %p\n"
            "    Free list count = %d\n",
            pbuf,
            cNbstatFreeListCount ));
    }

    return pbuf;
}



VOID
freeNbstatBuffer(
    IN      PDNS_NBT_INFO   pBuf
    )
/*++

Routine Description:

    Free an nbstat buffer.

    Kept on free list up to max number of buffers.

Arguments:

    pBuf -- RR to free.

Return Value:

    None.

--*/
{
    ASSERT( Mem_HeapMemoryValidate(pBuf) );

    NBSTAT_ALLOC_LOCK();

    ASSERT( !cNbstatFreeListCount || pNbstatFreeListHead );
    ASSERT( cNbstatFreeListCount > 0 || ! pNbstatFreeListHead );

    NbstatStats.NbstatReturn++;

    //
    //  free list at limit -- free packet
    //  space on free list -- stick nbstat buffer on front of free list
    //

    if ( cNbstatFreeListCount >= NBSTAT_FREE_LIST_LIMIT )
    {
        FREE_HEAP( pBuf );
        NbstatStats.NbstatFree++;
    }
    else
    {
        * (PDNS_NBT_INFO *) pBuf = pNbstatFreeListHead;
        pNbstatFreeListHead = pBuf;
        cNbstatFreeListCount++;
    }

    NBSTAT_ALLOC_UNLOCK();

    IF_DEBUG( HEAP )
    {
        DNS_PRINT((
            "Returned nbstat buffer at %p\n"
            "    Free list count = %d\n",
            pBuf,
            cNbstatFreeListCount ));
    }
}



VOID
Nbstat_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic Nbstat buffer counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  outstanding memory
    //

    NbstatStats.NbstatNetAllocs = NbstatStats.NbstatAlloc - NbstatStats.NbstatFree;
    NbstatStats.NbstatMemory = NbstatStats.NbstatNetAllocs * dwNbtBufferLength;
    PERF_SET( pcNbstatMemory , NbstatStats.NbstatMemory );   // PerfMon hook

    //
    //  outstanding nbstat buffers
    //      - free list
    //      - in processing
    //

    NbstatStats.NbstatInFreeList = cNbstatFreeListCount;
    NbstatStats.NbstatInUse = NbstatStats.NbstatUsed - NbstatStats.NbstatReturn;
}

//
//  End of nbstat.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\packetq.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    packetq.c

Abstract:

    Domain Name System (DNS) Server

    Packet queue routines.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#include "dnssrv.h"

//
//  Queuing flag -- for debug
//
//  use queuing time as flag, for ON or OFF the queue
//  only use QUEUED macro where not otherwise setting flag
//

#if DBG
#define SET_MSG_DEQUEUED(pMsg)  ( (pMsg)->dwQueuingTime = 0 )
#define SET_MSG_QUEUED(pMsg)    ( (pMsg)->dwQueuingTime = 1 )

#else   // retail

#define SET_MSG_DEQUEUED(pMsg)
#define SET_MSG_QUEUED(pMsg)
#endif


//
//  Private queues -- extern here for debug purposes
//

extern  PPACKET_QUEUE   g_pWinsQueue;
extern  PPACKET_QUEUE   g_UpdateForwardingQueue;
extern  PPACKET_QUEUE   pNbstatPrivateQueue;


//
//  Implementation note:
//
//  Packets are enqueued at tail.
//
//  For straight in order queuing, this means we dequeue from the front.
//
//  For XID and time stamped packets, this means oldest packets are
//  at front, and XID and times grow toward back of list.  This also means
//  that the timed out packets accumulate at the front of the queue, and
//  searching for new matching responses is best done from the rear
//  of the queue.
//



VOID
PQ_DiscardDuplicatesOfNewPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsgNew,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Discard duplicate packets on queuing.

    Kills off any duplicate packets in the queue.
    Packets that are dequeued are discarded.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsgNew -- message being queued

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;

    //  quick escape if queue empty, before locking

    if ( pQueue->cLength == 0 )
    {
        return;
    }

    //
    //  loop through queue and delete any duplicates of packet being queued
    //
    //  note:  if we find one, we're done as any previous queuing should have
    //      squashed any previous duplicate message;
    //      this does allow the queue to have dups, if we requeue a message
    //      without doing this check
    //
    //  DEVNOTE: it would be cool to leave messages ON the queue while
    //      being processed, so that we could do this check and kill all
    //      dups -- especially for update, but also for recursion
    //
    //      however, then we'd need to have an in-use flag, and have
    //      some sort of dequeue on send flag
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        if ( DnsAddr_IsEqual(
                &pmsg->RemoteAddr,
                &pMsgNew->RemoteAddr,
                DNSADDR_MATCH_SOCKADDR ) &&
             RtlEqualMemory(
                &pmsg->Head,
                &pMsgNew->Head,
                pmsg->MessageLength ) )
        {
            pQueue->cDequeued++;
            pQueue->cLength--;

            DNS_DEBUG( UPDATE, (
                "Discarding duplicate of new packet in queue %s\n"
                "    remote IP    = %s:%d\n"
                "    XID          = %d\n",
                pQueue->pszName,
                DNSADDR_STRING( &pmsg->RemoteAddr ),
                pmsg->RemoteAddr.SockaddrIn6.sin6_port,
                pmsg->Head.Xid ));

            RemoveEntryList( (PLIST_ENTRY)pmsg );
            SET_MSG_DEQUEUED( pmsg );
            Packet_Free( pmsg );
            break;
        }
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
        continue;
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }
}



VOID
PQ_DiscardExpiredQueuedPackets(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Discard stale packets.

    This utility is designed to be used in both queuing\dequeuing
    operations to suppress growth of a queue (ex. update queue)
    that collects packets for a potentially long interval.
    Assumes we hold lock on given queue.

    Packets that are dequeued are discarded.

Arguments:

    pQueue -- packet queue to stick packet on

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pmsgNext;
    DWORD           expireTime;

    //  quick escape if queue empty, before locking

    if ( pQueue->cLength == 0 )
    {
        return;
    }

    //  calculate last valid packet time

    expireTime = DNS_TIME() - pQueue->dwDefaultTimeout;

    //
    //  loop through queue and delete all packets which we're queued
    //      before a given time
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    DNS_DEBUG( UPDATE, (
        "Queue %s discard packet check\n"
        "    queue length         = %d\n"
        "    expire time          = %d\n"
        "    first msg query time = %d\n",
        pQueue->pszName,
        pQueue->cLength,
        expireTime,
        ( PLIST_ENTRY )pmsg != &pQueue->listHead
            ? pmsg->dwQueryTime : 0 ));

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //  dump stale packets

        if ( pmsg->dwQueryTime < expireTime )
        {
            pQueue->cDequeued++;
            pQueue->cTimedOut++;
            pQueue->cLength--;

            pmsgNext = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
            RemoveEntryList( (PLIST_ENTRY)pmsg );
            SET_MSG_DEQUEUED( pmsg );
            Packet_Free( pmsg );
            pmsg = pmsgNext;
            continue;
        }

        //  packets are queued in order, when reach non-timed-out
        //  packet, we are done

        break;
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }
}



BOOL
addPacketToQueue(
    IN OUT  PPACKET_QUEUE       pQueue,
    IN OUT  PDNS_MSGINFO        pMsg
    )
/*++

Routine Description:

    Enqueue packet. The caller must have the queue locked.

Arguments:

    pQueue -- packet queue

    pMsg -- packet to enqueue

Return Value:

    TRUE if queued, FALSE on error.

--*/
{
    if ( !pQueue || !pMsg )
    {
        ASSERT( pQueue );
        ASSERT( pMsg );
        return FALSE;
    }
    
    ASSERT( !pQueue->dwMaximumElements ||
            pQueue->cLength < pQueue->dwMaximumElements );

    if ( pQueue->dwMaximumElements &&
         pQueue->cLength >= pQueue->dwMaximumElements )
    {
        return FALSE;
    }
    
    InsertTailList( &pQueue->listHead, ( PLIST_ENTRY ) pMsg );

    pQueue->cQueued++;
    pQueue->cLength++;
    
    return TRUE;
}



BOOL
PQ_QueuePacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

Return Value:

    TRUE if packet successfully queued.

--*/
{
    BOOL        bqueued;
    
    LOCK_QUEUE( pQueue );

    bqueued = addPacketToQueue( pQueue, pMsg );

    if ( bqueued )
    {
        MSG_ASSERT( pMsg, !IS_MSG_QUEUED( pMsg ) );
        SET_MSG_QUEUED( pMsg );
    }

    UNLOCK_QUEUE( pQueue );
    
    return bqueued;
}



BOOL
PQ_QueuePacketSetEvent(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet and set event.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

Return Value:

    TRUE if packet successfully queued.

--*/
{
    BOOL        bqueued;

    LOCK_QUEUE( pQueue );

    bqueued = addPacketToQueue( pQueue, pMsg );

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED( pMsg ) );
    SET_MSG_QUEUED( pMsg );

    UNLOCK_QUEUE( pQueue );

    //
    //  set event indicating packet on queue
    //  do this after leaving CS;  this does occasionally
    //  cause unnecessary thread wakeup when queue has just been
    //  emptied, but I think this is less costly then setting
    //  event inside CS, which will often result in having threads
    //  wake, then immediately block on CS
    //

    if ( bqueued && pQueue->hEvent )
    {
        SetEvent( pQueue->hEvent );
    }
    
    return bqueued;
}



BOOL
PQ_QueuePacketEx(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Enqueue packet and set event.
    Packet queue kept sorted by query time.

    This is necessary for update to insure in-order execution of
    updates, even if packets must be requeued.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    fAlreadyLocked -- TRUE if queue already locked by caller

Return Value:

    TRUE if packet successfully queued.

--*/
{
    BOOL    bqueued = FALSE;
    
    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    //
    //  scrub queue -- eliminate expired and duplicate packets from queue?
    //      - update queue has these flags set
    //

    if ( pQueue->fDiscardExpiredOnQueuing )
    {
        PQ_DiscardExpiredQueuedPackets(
            pQueue,
            TRUE );         //  queue already locked
    }
    if ( pQueue->fDiscardDuplicatesOnQueuing )
    {
        PQ_DiscardDuplicatesOfNewPacket(
            pQueue,
            pMsg,
            TRUE );         //  queue already locked
    }

    DNS_DEBUG( UPDATE, (
        "PQ_QueuePacketEx in queue %s\n"
        "    pMsg         = %p\n"
        "    query time   = %d\n"
        "    current time = %d\n",
        pQueue->pszName,
        pMsg,
        pMsg->dwQueryTime,
        DNS_TIME() ));

    //
    //  queuing in query time order?
    //  this option is necessary for update to insure in-order execution
    //      of updates
    //

    ASSERT( !pQueue->dwMaximumElements ||
            pQueue->cLength < pQueue->dwMaximumElements );

    if ( !pQueue->dwMaximumElements ||
         pQueue->cLength < pQueue->dwMaximumElements )
    {
        if ( pQueue->fQueryTimeOrder )
        {
            PDNS_MSGINFO    pmsgQueued;
            DWORD           queryTime = pMsg->dwQueryTime;

            pmsgQueued = (PDNS_MSGINFO) pQueue->listHead.Blink;

            while ( (PLIST_ENTRY)pmsgQueued != &pQueue->listHead )
            {
                //  if packet is older than ours, stop
                //      correct positions is immediately behind this packet

                if ( pmsgQueued->dwQueryTime <= queryTime )
                {
                    break;
                }
                pmsgQueued = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsgQueued)->Blink;
            }

            InsertHeadList( ( PLIST_ENTRY ) pmsgQueued, ( PLIST_ENTRY ) pMsg );
        }

        //  otherwise simple queuing at back

        else
        {
            InsertTailList( &pQueue->listHead, (PLIST_ENTRY)pMsg );
        }

        pQueue->cQueued++;
        pQueue->cLength++;
        bqueued = TRUE;

        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        SET_MSG_QUEUED(pMsg);
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    //
    //  set event indicating packet on queue
    //  do this after leaving CS;  this does occasionally
    //  cause unnecessary thread wakeup when queue has just been
    //  emptied, but I think this is less costly then setting
    //  event inside CS, which will often result in having threads
    //  wake, then immediately block on CS
    //

    if ( bqueued && pQueue->hEvent )
    {
        SetEvent( pQueue->hEvent );
    }
    
    return bqueued;
}



PDNS_MSGINFO
PQ_DequeueNextPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Dequeue next packet from queue.

Arguments:

    pQueue -- packet queue to stick packet on

    fAlreadyLocked -- TRUE if queue already locked by caller

Return Value:

    Ptr to message at head of list.

--*/
{
    PDNS_MSGINFO     pmsg;

    //
    //  grab head packet on queue -- if any
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    if ( (PLIST_ENTRY)pmsg == &pQueue->listHead )
    {
        pmsg = NULL;
    }
    else
    {
        pQueue->cDequeued++;
        pQueue->cLength--;

        RemoveEntryList( (PLIST_ENTRY)pmsg );
        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        SET_MSG_DEQUEUED(pmsg);
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    return pmsg;
}



VOID
PQ_YankQueuedPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Yank packet from queue.

    By yank, we mean that packet is pulled from queue without any check as
    to whether it is on queue.  Caller must "know" that packet was put on queue
    and has not been dequeued.

Arguments:

    pQueue -- packet queue to remove packet from

    pMsg -- packet to yank from queue

Return Value:

    None.

--*/
{
    LOCK_QUEUE( pQueue );

    RemoveEntryList( &pMsg->ListEntry );

    //  treat as if packet never on queue

    pQueue->cLength--;
    pQueue->cQueued--;

    MSG_ASSERT( pMsg, IS_MSG_QUEUED( pMsg ) );
    SET_MSG_DEQUEUED( pMsg );

    UNLOCK_QUEUE( pQueue );
}



//
//  Special XID queuing routines
//

WORD
PQ_QueuePacketWithXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    Note:  may set dwExpireTime, to a timeout interval for this packet
    different from default.  If so this timeout will be used.

Return Value:

    XID for packet on the queue or zero if packet could not be queued.

--*/
{
    DWORD   currentTime;
    WORD    xid;
    BOOL    bqueued;

    //
    //  Place the request on the queue.
    //
    //  MUST do this before send, so packet is guaranteed to be in
    //  queue when get response.
    //
    //  Optionally get XID -- also protected by CS.
    //

    //
    //  set current time \ expire time in packet
    //      - save if FIRST query time for packet
    //

    currentTime = DNS_TIME();

    //  use queuing time as flag for ON or OFF queue
    ASSERT( pMsg->dwQueuingTime == 0 );

    pMsg->dwQueuingTime = currentTime;

    if ( !pMsg->dwQueryTime )
    {
        pMsg->dwQueryTime = currentTime;
    }

    //
    //  if dwExpireTime given, treat it as an override of the default
    //      timeout
    //

    if ( pMsg->dwExpireTime )
    {
        //  track minimum possible timeout in queue, to speed up
        //  finding timed out packets in queue

        if ( pMsg->dwExpireTime < pQueue->dwMinimumTimeout )
        {
            pQueue->dwMinimumTimeout = pMsg->dwExpireTime;
        }
        pMsg->dwExpireTime += currentTime;
    }
    else
    {
        pMsg->dwExpireTime = currentTime + pQueue->dwDefaultTimeout;    //  entry timeout length
    }

    //  Sanity check: expire time less than 5 minutes!
    ASSERT( pMsg->dwExpireTime - currentTime < 300 );

    DNS_DEBUG( MSGTIMEOUT, (
        "queuing msg %p in queue %s(%p) expire %d curr %d (%d)\n",
        pMsg,
        pQueue->pszName,
        pQueue,
        pMsg->dwExpireTime,
        currentTime,
        pMsg->dwExpireTime - currentTime ));

    //
    //  Lock the queue. Do XID generation inside lock because we use the queue's
    //  wXid member as part of the random portion for the new XID.
    //

    LOCK_QUEUE( pQueue );

    //
    //  set XID, if none specified
    //
    //  caller can use this in any fashion, just so consistent between
    //  between sending and what receiver sends to packet matching routine
    //
    //  setting this completely here, so avoid touching query after
    //  queuing, which is invalid if queries are outstanding with
    //  might dequeue the packet
    //

    xid = pMsg->wQueuingXid;

    if ( !xid )
    {
        //  for recursion, generate "apparently random" XID
        //      - random portion from hashing up ptr and time
        //      - sequential portion to insure that XID even under "bizzarro" conditions
        //      does not wrap in reasonable time interval
        //
        //  for WINS, use serial XID
        //
        //  WINS server does a poor job of throwing out old entries, but it does
        //  throw out matching XID from the same IP, so XIDs MUST stay unique for a
        //  relatively long period (up to minutes) of time;  since WINS is more of
        //  an intranet issue, less exposed to security attacks, we can go with
        //  serial XID

        xid = pQueue->wXid++;

        if ( pQueue == g_pRecursionQueue )
        {
            DWORD   randomPart = 
                        ( xid *
                        ( currentTime +
                        ( ( DWORD ) ( ULONG_PTR ) pMsg >> ( xid & 0x7 ) ) ) );

#if 1
            DNS_DEBUG( RECURSE, (
                "RECURSION XID: base=0x%04X now=0x%04X msg=0x%08X tmp=0x%04X\n"
                "RECURSION XID: seq=0x%04X rnd=0x%04X seq+rnd=0x%04X final=0x%04X\n",
                xid,
                currentTime,
                ( DWORD ) ( ULONG_PTR ) pMsg,
                randomPart,
                XID_SEQUENTIAL_MAKE( xid ),
                XID_RANDOM_MAKE( ( WORD ) randomPart ),
                XID_SEQUENTIAL_MAKE( xid ) | XID_RANDOM_MAKE( ( WORD ) randomPart ),
                MAKE_RECURSION_XID( XID_SEQUENTIAL_MAKE( xid ) |
                    XID_RANDOM_MAKE( ( WORD ) randomPart ) ) ));
#endif

            xid = XID_SEQUENTIAL_MAKE( xid ) | XID_RANDOM_MAKE( ( WORD ) randomPart );
            xid = MAKE_RECURSION_XID( xid );
        }
        else if ( pQueue == g_pWinsQueue )
        {
            xid = MAKE_WINS_XID( xid );
        }

#if DBG
        //  other queues which use this function do NOT munge XID

        else if ( pQueue == g_UpdateForwardingQueue )
        {
            MSG_ASSERT( pMsg, pMsg->Head.Opcode == DNS_OPCODE_UPDATE );
        }
        else if ( pQueue == pNbstatPrivateQueue )
        {
            MSG_ASSERT( pMsg, pMsg->U.Nbstat.pNbstat );
        }
        else
        {
            MSG_ASSERT( pMsg, FALSE );
        }
#endif
        pMsg->wQueuingXid = xid;
    }

    #if 0   //  #if DBG
    {
        //
        //  Search the queue for an XID the same as the one we're queuing.
        //  This is expensive so we probably shouldn't do it in retail,
        //  but I'm interested to see if stress will trigger this.
        //
    
        PDNS_MSGINFO    pRover = (PDNS_MSGINFO) pQueue->listHead.Blink;

        while ( ( PLIST_ENTRY ) pRover != &pQueue->listHead )
        {
            ASSERT( pRover->wQueuingXid != pMsg->wQueuingXid );
            pRover = ( PDNS_MSGINFO ) ( ( PLIST_ENTRY ) pRover )->Blink;
        }
    }
    #endif

    //
    //  Insert packet at tail of queue. Dequeue function checks backwards 
    //  from tail so it will checking most recent packets first.
    //

    bqueued = addPacketToQueue( pQueue, pMsg );

    UNLOCK_QUEUE( pQueue );

    return bqueued ? xid : 0;
}   //  PQ_QueuePacketWithXid



DNS_STATUS
PQ_QueuePacketWithXidAndSend(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet and send.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    Note:  may set dwExpireTime, to a timeout interval for this packet
    different from default.  If so this timeout will be used.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode from Send_Message() if error.

--*/
{
    DNS_STATUS  status;

    //
    //  Must hold CS around both queuing and send
    //
    //  Packet must be on queue before send, so that quick response is
    //  properly handled.  And must send before releasing CS, so that
    //  packet can NOT be dequeued and deleted (by roque response processing)
    //  before send complete.
    //

    EnterCriticalSection( & pQueue->csQueue );

    //
    //  scrub queue -- eliminate expired and duplicate packets from queue?
    //      - update forwarding queue has these flags set
    //

    if ( pQueue->fDiscardExpiredOnQueuing )
    {
        PQ_DiscardExpiredQueuedPackets(
            pQueue,
            TRUE );         //  queue already locked
    }
    if ( pQueue->fDiscardDuplicatesOnQueuing )
    {
        PQ_DiscardDuplicatesOfNewPacket(
            pQueue,
            pMsg,
            TRUE );         //  queue already locked
    }

    pMsg->Head.Xid = PQ_QueuePacketWithXid(
                         pQueue,
                         pMsg );
    DNS_DEBUG( UPDATE, (
        "Queuing message %p and sending\n"
        "    queuing XID = %hx\n"
        "    queuing time=%d, expire=%d\n"
        "    Sending msg to NS at %s\n",
        pMsg,
        pMsg->Head.Xid,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        DNSADDR_STRING( &pMsg->RemoteAddr ) ));

    pMsg->fDelete = FALSE;

    status = Send_Msg( pMsg, 0 );

    //  DEVNOTE:  new new time field?
    //  must reset query time as send resets it with ms time
    //  as part of recursion response time tracking

    pMsg->dwQueryTime = DNS_TIME();

    LeaveCriticalSection( & pQueue->csQueue );

    return status;
}



PDNS_MSGINFO
PQ_DequeuePacketWithMatchingXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      WORD            wMatchXid
    )
/*++

Routine Description:

    Dequeue packet matching given XID.

Arguments:

    pQueue -- packet queue to remove packet from

    wMatchXid -- XID to match

Return Value:

    Matching packet, if found.
    Otherwise NULL.

--*/
{
    PDNS_MSGINFO    pmsg;

    //
    //  walk backwards through queue looking for packet
    //
    //  we start at back, to check most recent packets first
    //  and avoid build up of timed out packets
    //

    LOCK_QUEUE( pQueue );

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Blink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //
        //  matching XID ?
        //

        if ( pmsg->wQueuingXid == wMatchXid )
        {
            pQueue->cDequeued++;
            pQueue->cLength--;

            RemoveEntryList( (PLIST_ENTRY)pmsg );
            UNLOCK_QUEUE( pQueue );

            MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
            SET_MSG_DEQUEUED(pmsg);
            return pmsg;
        }

        //  get next packet

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Blink;
    }

    UNLOCK_QUEUE( pQueue );
    return NULL;
}



BOOL
PQ_IsQuestionAlreadyQueued(
    IN      PPACKET_QUEUE   pQueue,
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Checks if the queue already contains a matching question.

    For a query to match all these fields much match:
        XID
        client IP
        client port
        question type
        question name

Arguments:

    pQueue -- packet queue to check

    pMsg -- message to try and match in pQueue

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    TRUE - a duplicate query to pMsg is in the queue
    FALSE - no duplicate query to pMsg is in the queue

--*/
{
    BOOL            isQueued = FALSE;
    PDNS_MSGINFO    pmsg;

    //  Quick escape.

    if ( !pMsg || !pQueue || pQueue->cLength == 0 )
    {
        goto Done;
    }

    //
    //  Loop through queue and search for match.
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    for ( pmsg = ( PDNS_MSGINFO ) pQueue->listHead.Flink;
          ( PLIST_ENTRY ) pmsg != &pQueue->listHead;
          pmsg = ( PDNS_MSGINFO ) ( ( PLIST_ENTRY ) pmsg )->Flink )
    {
        if ( pmsg->Head.Xid == pMsg->Head.Xid &&
             DnsAddr_IsEqual(
                &pmsg->RemoteAddr,
                &pMsg->RemoteAddr,
                DNSADDR_MATCH_SOCKADDR ) &&
            pmsg->wQuestionType == pMsg->wQuestionType &&
            Name_CompareLookupNames(
                pmsg->pLooknameQuestion,
                pMsg->pLooknameQuestion ) )
        {
            DNS_DEBUG( RECURSE, (
                "Matched query in %s queue\n"
                "    remote IP    = %s:%d\n"
                "    XID          = %X\n",
                pQueue->pszName,
                DNSADDR_STRING( &pmsg->RemoteAddr ),
                pmsg->RemoteAddr.SockaddrIn6.sin6_port,
                pmsg->Head.Xid ));
            isQueued = TRUE;
            break;
        }
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    Done:

    return isQueued;
}   //  PQ_IsQuestionAlreadyQueued



PDNS_MSGINFO
PQ_DequeueTimedOutPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    OUT     PDWORD          pdwTimeout
    )
/*++

Routine Description:

    Dequeue next timed out packet on packet queue.

    This function handles the case of a queue, where there are
    multiple possible timeout lengths, and hence may have first
    timed out packet deep in the queue.

Arguments:

    pQueue -- packet queue to remove packet from

    pdwTimeout -- smallest

Return Value:

    Ptr to oldest timed out packet, if any.
    NULL if no timed out packets on queue.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           dwTime;
    DWORD           dwStopTime;
    DWORD           dwTimeout;
    DWORD           dwSmallestTimeout;

    DNS_DEBUG( MSGTIMEOUT, (
        "Find next timeout in packet queue %s (length = %d)\n",
        pQueue->pszName,
        pQueue->cLength ));

    //
    //  next possible timeout -- if packet not found -- is queue
    //      minimum + 1;  this is what timeout would be if packet
    //      was immediately queued with minimum timeout
    //

    dwSmallestTimeout = pQueue->dwMinimumTimeout + 1;

    //
    //  optimize, for nothing in queue
    //

    if ( pQueue->cLength == 0 )
    {
        *pdwTimeout = dwSmallestTimeout;
        return NULL;
    }

    //
    //  dequeue next timed out entry
    //  check until
    //      - end of queue
    //      - find timed out packet
    //      - determine no more timed out packets can exist
    //
    //  dwStopTime is last possible packet queuing time, for which
    //  minimum timeout could still produce a timeout
    //

    dwTime = GetCurrentTimeInSeconds();
    dwStopTime = dwTime - pQueue->dwMinimumTimeout;

    LOCK_QUEUE( pQueue );

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( 1 )
    {
        if ( (PLIST_ENTRY)pmsg == &pQueue->listHead )
        {
            //  hit end of queue

            pmsg = NULL;
            break;
        }

        //  Sanity check: expire time less than 5 minutes!
        ASSERT( dwTime > pmsg->dwExpireTime ||
            pmsg->dwExpireTime - dwTime < 300 );

        //
        //  Fix bug 23177: The test is now "< dwTime", used to be "<=".
        //  With "<=" we could end up waiting for only a small fraction  
        //  of a second. By using "<" we will wait possibly a 
        //  fraction of a second too long, but this is preferable to 
        //  waiting for too short, especially in the case where the timeout 
        //  is one second.
        //

        if ( pmsg->dwExpireTime < dwTime )
        {
            //  timed out packet, cut from list
            //  return 0 timeout

            pQueue->cDequeued++;
            pQueue->cTimedOut++;
            pQueue->cLength--;
            RemoveEntryList( (PLIST_ENTRY)pmsg );
            dwSmallestTimeout = 0;

            MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
            SET_MSG_DEQUEUED(pmsg);
            break;
        }

        if ( pmsg->dwQueuingTime > dwStopTime )
        {
            //  packets queued after this one, can NOT possibly be timed out

            pmsg = NULL;
            break;
        }

        //
        //  save smallest message timeout encountered
        //

        dwTimeout = pmsg->dwExpireTime - dwTime;
        if ( dwTimeout < dwSmallestTimeout )
        {
            dwSmallestTimeout = dwTimeout;
        }

        //  next packet

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }

    UNLOCK_QUEUE( pQueue );

    *pdwTimeout = dwSmallestTimeout;
    return pmsg;
}



//
//  Special UPDATE queuing routines
//

PDNS_MSGINFO
PQ_DequeueNextPacketOfUnlockedZone(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Dequeue next packet from queue that is for an unlocked zone.

Arguments:

    pQueue -- packet queue to dequeue from

Return Value:

    Ptr to next message dequeued.
    NULL if none in list.

--*/
{
    PDNS_MSGINFO     pmsg;

    //  optimize for nothing queued

    if ( pQueue->cLength == 0 )
    {
        return NULL;
    }

    //
    //  break datatype slightly to delete old packets;  this has two
    //  benefits
    //      1) slight performance gain staying in queue until find good
    //          packet
    //      2) more important, making sure queue is kept clean even if
    //          zone deleted or removed from updates, other updates
    //          will clean up
    //

    LOCK_QUEUE( pQueue );

    PQ_DiscardExpiredQueuedPackets(
        pQueue,
        TRUE );         //  queue already locked

    //
    //  loop through queue until find next packet queued for zone
    //

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //  ignore packets for locked zones

        ASSERT( pmsg->pzoneCurrent );

        if ( pmsg->pzoneCurrent->fLocked )
        {
            pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
            continue;
        }

        //  unlocked zone, dequeue message

        pQueue->cDequeued++;
        pQueue->cLength--;

        RemoveEntryList( (PLIST_ENTRY)pmsg );
        UNLOCK_QUEUE( pQueue );

        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        SET_MSG_DEQUEUED(pmsg);
        return pmsg;
    }

    UNLOCK_QUEUE( pQueue );
    return NULL;
}



//
//  Create and delete packet queues
//

PPACKET_QUEUE
PQ_CreatePacketQueue(
    IN      LPSTR           pszQueueName,
    IN      DWORD           dwFlags,
    IN      DWORD           dwDefaultTimeout,
    IN      DWORD           dwMaximumElements
    )
/*++

Routine Description:

    Creates a packet queue.

Arguments:

    pszQueueName -- name for queue

    dwFlags -- queue behavior flags
        currently supported:
            QUEUE_SET_EVENT
            QUEUE_DISCARD_EXPIRED
            QUEUE_DISCARD_DUPLICATES
            QUEUE_QUERY_TIME_ORDER

    dwDefaultTimeout -- default timeout on queue

Return Value:

    Ptr to packet queue structure if successful.
    NULL if error.

--*/
{
    PPACKET_QUEUE   pqueue;

    DNS_DEBUG( INIT2, ( "Creating %s packet queue\n", pszQueueName ));

    //
    //  allocate packet queue structure
    //

    pqueue = ALLOC_TAGHEAP_ZERO( sizeof( PACKET_QUEUE ), MEMTAG_SAFE );
    IF_NOMEM( ! pqueue )
    {
        DNS_PRINT((
            "ERROR:  could not allocate memory for packet queue %s\n",
            pszQueueName ));
        return NULL;
    }

    //
    //  initialize the list
    //

    if ( DnsInitializeCriticalSection( &pqueue->csQueue ) != ERROR_SUCCESS )
    {
        return NULL;
    }
    InitializeListHead( &pqueue->listHead );

    //
    //  queuing sets event?
    //

    if ( dwFlags & QUEUE_SET_EVENT )
    {
        pqueue->hEvent = CreateEvent(
                            NULL,       //  no security attributes
                            FALSE,      //  auto-reset
                            FALSE,      //  start non-signalled
                            NULL );     //  no name
        if ( !pqueue->hEvent )
        {
            FREE_HEAP( pqueue );
            return NULL;
        }
    }

    //
    //  bool queuing behavior flags
    //

    if ( dwFlags & QUEUE_DISCARD_EXPIRED )
    {
        pqueue->fDiscardExpiredOnQueuing = TRUE;
    }
    if ( dwFlags & QUEUE_DISCARD_DUPLICATES )
    {
        pqueue->fDiscardDuplicatesOnQueuing = TRUE;
    }
    if ( dwFlags & QUEUE_QUERY_TIME_ORDER )
    {
        pqueue->fQueryTimeOrder = TRUE;
    }

    //
    //  fill in callers info
    //

    pqueue->pszName = pszQueueName;

    //
    //  timeout constraint
    //
    //  default timeout MUST exist to protect against spinning in
    //  timeout check threads -- which would always find zero time
    //  to next timeout
    //

    if ( dwDefaultTimeout < 1 )
    {
        dwDefaultTimeout = 1;
    }
    pqueue->dwDefaultTimeout = dwDefaultTimeout;

    //  initialize minimum timeout interval at default

    pqueue->dwMinimumTimeout = dwDefaultTimeout;

    //  starting XID

    pqueue->wXid = 1;
    
    pqueue->dwMaximumElements =
        dwMaximumElements ?
            dwMaximumElements : QUEUE_DEFAULT_MAX_ELEMENTS;

    return pqueue;
}



VOID
PQ_WalkPacketQueueWithFunction(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      VOID            (*pFunction)( PDNS_MSGINFO )
    )
/*++

Routine Description:

    Walk through packet queue with function.

Arguments:

    pQueue -- packet queue to delete

    pFunction -- function to call on each messag in queue

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pcheckMsg;

    ASSERT( pQueue );

    //
    //  walk queue
    //

    LOCK_QUEUE( pQueue );

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        pFunction( pmsg );

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }
    UNLOCK_QUEUE( pQueue );
}



VOID
PQ_CleanupPacketQueueHandles(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Cleanup handles associated with a packet queue.

    Since server memory can be deleted as a whole, separate
    this function from actually freeing packet queue memory.

Arguments:

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    if ( !pQueue )
    {
        DNS_PRINT((
            "CleanupPacketQueueHandles called for non-existant packet queue\n" ));
        return;
    }

    //
    //  close queuing event
    //

    if ( pQueue->hEvent )
    {
        CloseHandle( pQueue->hEvent );
    }

    //
    //  delete CS
    //

    DeleteCriticalSection( &pQueue->csQueue );

    DNS_DEBUG( SHUTDOWN, (
        "Deleted handles for %s queue\n",
        pQueue->pszName ));
}



//
//  As own process, no need to free virtual memory on shutdown
//

VOID
PQ_DeletePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Delete the packet queue.

    Call this for packet queues on service shutdown.

    Note that function does not receive actual queue ptr variable.
    If queue ptr is used as flag, caller must NULL flag to indicate
    queue shutdown prior to call or must otherwise insure that no
    other threads will attempt to use queue.

Arguments:

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pcheckMsg;

    if ( !pQueue )
    {
        DNS_PRINT((
            "DeletePacketQueue called for non-existant packet queue\n" ));
        return;
    }
    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT((
            "Deleting %s queue\n",
            pQueue->pszName ));
    }

    //
    //  walk queue, delete every packet
    //      - no need to do list entry stuff, cause stay in list until done
    //

    LOCK_QUEUE( pQueue );

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        pcheckMsg = pmsg;
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
        pQueue->cTimedOut++;
        pQueue->cLength--;
        Packet_Free( pcheckMsg );
    }
    UNLOCK_QUEUE( pQueue );

    ASSERT( pQueue->cLength == 0 );
    ASSERT( pQueue->cQueued == pQueue->cDequeued + pQueue->cTimedOut );

    //
    //  delete queue structure itself
    //

    FREE_HEAP( pQueue );
}



BOOL
PQ_ValidatePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Validate packet queue.

Arguments:

    pQueue -- packet queue to stick packet on

Return Value:

    TRUE if queue valid.
    FALSE otherwise.

--*/
{
    register PDNS_MSGINFO   pmsg;
    PDNS_MSGINFO    pmsgBlink;
    DWORD           currentTime;
    DWORD           count = 0;

    //
    //  currently no special ordering, XID, or time checks
    //

    //
    //  walk queue, validate
    //      - packet queued
    //      - queue links valid
    //      - XID for queues with XID range
    //

    EnterCriticalSection( &pQueue->csQueue );

    currentTime = DNS_TIME();
    currentTime++;

    pmsgBlink = (PDNS_MSGINFO) &pQueue->listHead;

    while ( 1 )
    {
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsgBlink)->Flink;

        if ( pmsg == (PDNS_MSGINFO)&pQueue->listHead )
        {
            break;
        }

        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        MSG_ASSERT( pmsg, pmsg->dwQueuingTime <= currentTime );
        MSG_ASSERT( pmsg, (PDNS_MSGINFO)pmsg->ListEntry.Blink == pmsgBlink );

        //  make link check explicit for retail

        HARD_ASSERT( (PDNS_MSGINFO)pmsg->ListEntry.Blink == pmsgBlink );

        pmsgBlink = pmsg;
        count++;

        ASSERT( count <= pQueue->cQueued );

        //
        //  queue specific:  XID requirement?
        //

        if ( pQueue == g_pWinsQueue )
        {
            MSG_ASSERT( pmsg, IS_WINS_XID(pmsg->wQueuingXid) );
        }
        if ( pQueue == g_pRecursionQueue )
        {
            MSG_ASSERT( pmsg, IS_RECURSION_XID(pmsg->wQueuingXid) );
        }
    }

    LeaveCriticalSection( &pQueue->csQueue );

    return TRUE;
}



#if DBG

VOID
Dbg_PacketQueue(
    IN      LPSTR           pszHeader,
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Print all queries in packet queue.

Arguments:

    pszHeader -- header to print

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           count = 0;

    //
    //  note:  can NOT take debug lock OUTSIDE queue lock, as we'd then
    //      be in possible deadlock, as there are places in the recursion
    //      code (sending packet) where printing done holding queuing
    //      lock (so that packet is known to be valid, not dequeued
    //      and thrown away)
    //  instead take queuing lock on the outside
    //

    LOCK_QUEUE( pQueue );
    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "Dumping Packet queue %s, count = %d:\n",
        pszHeader ? pszHeader : "",
        pQueue->pszName,
        pQueue->cLength );

    //
    //  walk queue
    //

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        DNS_PRINT((
            "%s Queue Packet[%d] queuing XID = %x\n",
            pQueue->pszName,
            count,
            pmsg->wQueuingXid
            ));
        Dbg_DnsMessage(
            NULL,
            pmsg );

        count++;
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }

    ASSERT( count == pQueue->cLength );

    DnsDebugUnlock();
    UNLOCK_QUEUE( pQueue );
}

#endif  // DBG


//
//  End of packetq.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\packet.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    packet.c

Abstract:

    Packet management.

Author:

    Jim Gilroy,  November 1996

Revision History:

--*/

#include "dnssrv.h"


//
//  Packet allocation / free list
//
//  Maintain a free list of packets to avoid reallocation to service
//  every query.
//
//  Implement as stack using single linked list.
//  List head points at first message.  First field in each message
//  serves as next ptr.  Last points at NULL.
//

PDNS_MSGINFO        g_pPacketFreeListHead;

INT                 g_PacketFreeListCount;

CRITICAL_SECTION    g_PacketListCs;

#define LOCK_PACKET_LIST()      EnterCriticalSection( &g_PacketListCs );
#define UNLOCK_PACKET_LIST()    LeaveCriticalSection( &g_PacketListCs );

#define PACKET_FREE_LIST_LIMIT  (100)


//  Free message indicator

#ifdef _WIN64
#define FREE_MSG_BLINK          ((PLIST_ENTRY) 0xfeebfeebfeebfeeb)
#else
#define FREE_MSG_BLINK          ((PLIST_ENTRY) 0xfeebfeeb)
#endif

#define SET_FREE_MSG(pmsg)      ((pmsg)->ListEntry.Blink = FREE_MSG_BLINK )
#define IS_FREE_MSG(pmsg)       ((pmsg)->ListEntry.Blink == FREE_MSG_BLINK )



BOOL
Packet_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize packet list processing.

Arguments:

    None.

Return Value:

    TRUE/FALSE for success/failure.

--*/
{
    //  packet free list

    g_pPacketFreeListHead = NULL;
    g_PacketFreeListCount = 0;

    //  packet list lock

    if ( DnsInitializeCriticalSection( &g_PacketListCs ) == ERROR_SUCCESS )
    {
        return TRUE;
    }

    return FALSE;
}



VOID
Packet_ListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup packet list for restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &g_PacketListCs );
}



BOOL
Packet_ValidateFreeMessageList(
    VOID
    )
/*++

Routine Description:

    Validate free message list.

    Makes sure NO packet in list is active.

Arguments:

    pList -- start ptr of message list

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    register PDNS_MSGINFO    pMsg;
    INT                      count = 0;

    //
    //  DEVNOTE: should just use packet queuing routines
    //

    LOCK_PACKET_LIST();

    ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
    ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

    pMsg = g_pPacketFreeListHead;

    //
    //  check all packets in free list, make sure none queued
    //
    //      - also count to avoid spin on cyclic list
    //

    while ( pMsg )
    {
        MSG_ASSERT( pMsg, IS_FREE_MSG(pMsg) );
        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, pMsg->pRecurseMsg == NULL );
        MSG_ASSERT( pMsg, pMsg->pConnection == NULL );
        MSG_ASSERT( pMsg, (PDNS_MSGINFO)pMsg->ListEntry.Flink != pMsg );
        MSG_ASSERT( pMsg, IS_PACKET_FREE_LIST((PDNS_MSGINFO)pMsg) );

        count++;
        ASSERT ( count <= g_PacketFreeListCount );

        pMsg = (PDNS_MSGINFO) pMsg->ListEntry.Flink;
    }

    UNLOCK_PACKET_LIST();

    return TRUE;
}



//
//  UDP Messages
//

PDNS_MSGINFO
Packet_AllocateUdpMessage(
    VOID
    )
/*++

Routine Description:

    Allocate a UDP packet.

    Use free list if packet available, otherwise heap.

Arguments:

    None.

Return Value:

    Ptr to new message info block, if successful.
    NULL otherwise.

--*/
{
    PDNS_MSGINFO    pMsg;

    LOCK_PACKET_LIST();

    ASSERT( Packet_ValidateFreeMessageList() );

    //
    //  UDP message buffer available on free list?
    //

    if ( g_pPacketFreeListHead )
    {
        ASSERT( g_PacketFreeListCount != 0 );
        ASSERT( IS_DNS_HEAP_DWORD(g_pPacketFreeListHead) );

        pMsg = g_pPacketFreeListHead;
        g_pPacketFreeListHead = *(PDNS_MSGINFO *) pMsg;

        ASSERT( g_pPacketFreeListHead != pMsg );

        g_PacketFreeListCount--;
        STAT_INC( PacketStats.UdpUsed );

        //
        //  if taking off the list, then MUST not be
        //      - in queue
        //      - attached to another query
        //
        //  note:  queuing time serves as flag for ON or OFF queue
        //  no packet should be freed while on queue
        //

        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, pMsg->pRecurseMsg == NULL );
        MSG_ASSERT( pMsg, IS_PACKET_FREE_LIST((PDNS_MSGINFO)pMsg) );

        ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
        ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

        UNLOCK_PACKET_LIST();
    }

    //
    //  no packets on free list -- create new
    //      - clear lock before ALLOC, to avoid unnecessary contention
    //      - keep stats in lock, alloc failure is death condition

    else
    {
        ASSERT( g_PacketFreeListCount == 0 );

        STAT_INC( PacketStats.UdpAlloc );
        STAT_INC( PacketStats.UdpUsed );
        UNLOCK_PACKET_LIST();

        pMsg = ALLOC_TAGHEAP(
            DNS_MSG_INFO_HEADER_LENGTH +
                SrvCfg_dwMaxUdpPacketSize +
                50,
            MEMTAG_PACKET_UDP );
        IF_NOMEM( !pMsg )
        {
            return NULL;
        }

        //  on first allocation clear full info blob, to clear baadfood

        RtlZeroMemory(
            (PCHAR) pMsg,
            sizeof( DNS_MSGINFO ) );
    }

    //
    //  init message
    //      - clear header fields
    //      - set defaults
    //      - for UDP packets we allow the entire packet to be usable
    //

    Packet_Initialize( pMsg,
        DNSSRV_UDP_PACKET_BUFFER_LENGTH,
        SrvCfg_dwMaxUdpPacketSize );
    pMsg->BufferLength = pMsg->MaxBufferLength;
    pMsg->pBufferEnd = ( PCHAR ) DNS_HEADER_PTR( pMsg ) + pMsg->BufferLength;

    ASSERT( !pMsg->fTcp && pMsg->fDelete );

    SET_PACKET_ACTIVE_UDP( pMsg );

    //  packet tracking
    //  no leaks, don't worry about this

    //Packet_AllocPacketTrack( pMsg );

    DNS_DEBUG( HEAP, (
        "Returning new UDP message at %p.\n"
        "\tFree list count = %d.\n",
        pMsg,
        g_PacketFreeListCount ));

    return pMsg;
}



VOID
Packet_FreeUdpMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free a standard sized RR.

Arguments:

    pMsg -- RR to free.

Return Value:

    None.

--*/
{
    if ( !pMsg )
    {
        return;
    }
    
    ASSERT( Mem_HeapMemoryValidate( pMsg ) );

    //
    //  skip over message validation for NS list buffers
    //

    if ( !pMsg->fNsList )
    {
        //  This assert is no longer valid since EDNS allows larger packets.
        //  Perhaps we should replace this with a UDP/TCP flag check instead?
        //  ASSERT( pMsg->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH );

        //
        //  if freeing, then MUST not be
        //      - in queue
        //      - attached to another query
        //
        //  note:  queuing time serves as flag for ON or OFF queue
        //  no packet should be freed while on queue
        //
        //  DEVNOTE: possible problem with message free on PnP
        //
        //  seen problems with dual message free on PnP;
        //  attempt to minimize likelyhood, by testing if message alread on free
        //  list;  do before and after lock, so we're likely to catch it
        //  if already enlisted BEFORE it goes out and if just being enlisted we
        //  still catch it
        //

        DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

        MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
        MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
        if ( IS_FREE_MSG(pMsg) )
        {
            DNS_PRINT(( "ERROR:  freeing FREE message %p!!!\n", pMsg ));
            ASSERT( FALSE );
            return;
        }

        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, !pMsg->pRecurseMsg );
        MSG_ASSERT( pMsg, !pMsg->pConnection );
    }

    LOCK_PACKET_LIST();

    //  test already-freed condition inside lock, so we don't miss
    //  case where another thread just freed

    MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
    MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
    MSG_ASSERT( pMsg, IS_PACKET_ACTIVE_UDP(pMsg) );

    if ( IS_FREE_MSG(pMsg) )
    {
        DNS_PRINT(( "ERROR:  freeing FREE message %p!!!\n", pMsg ));
        UNLOCK_PACKET_LIST();
        return;
    }

    ASSERT( Packet_ValidateFreeMessageList() );

    //  packet tracking
    //  no leaks -- currently disabled
    //Packet_FreePacketTrack( pMsg );

    //
    //  stats
    //

    STAT_INC( PacketStats.UdpReturn );

    if ( pMsg->fRecursePacket )
    {
        STAT_INC( PacketStats.RecursePacketReturn );
    }
    if ( pMsg->Head.IsResponse )
    {
        STAT_INC( PacketStats.UdpResponseReturn );
    }
    else if ( !pMsg->fNsList )
    {
        STAT_INC( PacketStats.UdpQueryReturn );
    }

    //
    //  free list at limit -- free packet
    //      - clear lock before FREE_HEAP to limit contention
    //

    if ( g_PacketFreeListCount >= PACKET_FREE_LIST_LIMIT )
    {
        STAT_INC( PacketStats.UdpFree );
        UNLOCK_PACKET_LIST();

        DNS_DEBUG( HEAP, (
            "UDP message at %p dumped back to heap.\n"
            "\tFree list count = %d.\n",
            pMsg,
            g_PacketFreeListCount ));

        SET_PACKET_FREE_HEAP( pMsg );
        FREE_HEAP( pMsg );
    }

    //
    //  space on free list -- stick message on front of free list
    //      - makes gives us immediate reuse, limiting paging
    //

    else
    {
        SET_FREE_MSG(pMsg);
        SET_PACKET_FREE_LIST( pMsg );

        * (PDNS_MSGINFO *) pMsg = g_pPacketFreeListHead;
        g_pPacketFreeListHead = pMsg;
        g_PacketFreeListCount++;

        ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
        ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

        UNLOCK_PACKET_LIST();

        DNS_DEBUG( HEAP, (
            "Stuck UDP message at %p on free list.\n"
            "\tFree list count = %d.\n",
            pMsg,
            g_PacketFreeListCount ));
    }
}



VOID
Packet_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic UDP message counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  outstanding memory
    //

    PacketStats.UdpNetAllocs = PacketStats.UdpAlloc - PacketStats.UdpFree;

    PacketStats.UdpMemory = PacketStats.UdpNetAllocs * DNS_UDP_ALLOC_LENGTH;
    PERF_SET( pcUdpMessageMemory , PacketStats.UdpMemory );      // PerfMon hook

    //
    //  outstanding packets
    //

    PacketStats.UdpInFreeList = g_PacketFreeListCount;

    PacketStats.UdpInUse = PacketStats.UdpUsed - PacketStats.UdpReturn;

    PacketStats.PacketsForNsListInUse =
            PacketStats.PacketsForNsListUsed -
            PacketStats.PacketsForNsListReturned;
}   //  Packet_WriteDerivedStats



//
//  TCP message allocation
//

PDNS_MSGINFO
Packet_AllocateTcpMessage(
    IN      DWORD   dwMinBufferLength
    )
/*++

Routine Description:

    Allocate TCP message.

    Set up for default TCP message.

Arguments:

    dwMinBufferLength - minimum buffer length to allocate

Return Value:

    Ptr to message info.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           allocLength;

    DNS_DEBUG( TCP, (
        "Tcp_AllocateMessage(), requesting %d bytes\n",
        dwMinBufferLength ));

    //
    //  If allocation length is not specified, use default.
    //

    if ( !dwMinBufferLength )
    {
        dwMinBufferLength = SrvCfg_dwTcpRecvPacketSize;
    }

    allocLength = DNS_MSG_INFO_HEADER_LENGTH + dwMinBufferLength;

    pmsg = ALLOC_TAGHEAP( allocLength, MEMTAG_PACKET_TCP );
    IF_NOMEM( ! pmsg )
    {
        DNS_PRINT((
            "ERROR:  failure to alloc %d byte TCP buffer.\n",
            dwMinBufferLength ));
        return NULL;
    }

    //
    //  init message
    //      - clear header fields
    //      - set defaults
    //      - set for TCP
    //

    Packet_Initialize( pmsg, dwMinBufferLength, dwMinBufferLength );

    pmsg->fTcp = TRUE;
    SET_PACKET_ACTIVE_TCP( pmsg );

    ASSERT( (PCHAR)pmsg + allocLength > pmsg->pBufferEnd );

    //  packet tracking
    //  no leak so not active
    //Packet_AllocPacketTrack( pmsg );

    //  record stats

    STAT_INC( PacketStats.TcpAlloc );
    STAT_INC( PacketStats.TcpNetAllocs );
    STAT_ADD( PacketStats.TcpMemory, allocLength );
    PERF_ADD( pcTcpMessageMemory, allocLength );

    return pmsg;
}


#if 0

PDNS_MSGINFO
Packet_ReallocateTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwMinBufferLength
    )
/*++

Routine Description:

    Reallocate TCP message.

Arguments:

    pMsg - message info buffer to receive packet

    dwMinBufferLength - minimum buffer length to allocate

Return Value:

    New message buffer.

--*/
{
    PDNS_MSGINFO    pmsgOld = pMsg;
    DWORD           bufferLength;

    ASSERT( pMsg );
    ASSERT( pMsg->fTcp );
    ASSERT( dwMinBufferLength > pMsg->BufferLength );

    //
    //  Determine allocation size,
    //

    bufferLength = DNS_TCP_DEFAULT_ALLOC_LENGTH;

    if ( dwMinBufferLength > DNS_TCP_DEFAULT_PACKET_LENGTH )
    {
        bufferLength = DNS_TCP_REALLOC_LENGTH;
    }

    DNS_DEBUG( TCP, (
        "Tcp_ReallocateMessage(), pMsg at %p\n"
        "\texisting length  = %d.\n"
        "\trequesting       = %d.\n"
        "\tallocating       = %d.\n",
        pMsg,
        pMsg->BufferLength,
        dwMinBufferLength,
        bufferLength ));


    pMsg = REALLOCATE_HEAP(
                pMsg,
                (INT) bufferLength );
    IF_NOMEM( pMsg == NULL )
    {
        DNS_PRINT((
            "ERROR:  failure to realloc %d byte buffer for\n"
            "\texisting message at %p.\n",
            bufferLength,
            pMsg ));

        //  failed reallocing to answer query
        //  if have received message, respond with SERVER_FAILURE
        //  normal timeout cleanup on socket and connection

        if ( ! pmsgOld->pchRecv )
        {
            ASSERT( ! pmsgOld->pConnection );
            ASSERT( pmsgOld->fMessageComplete );
            Reject_Request(
                pmsgOld,
                DNS_RCODE_SERVER_FAILURE,
                0 );
        }

        //  failed getting another message on existing connection
        //      - need to disassociate message and connection
        //      - call deletes everything -- connection, socket, buffer

        else if ( pmsgOld->pConnection )
        {
            ASSERT( ((PDNS_SOCKET)pmsgOld->pConnection)->pMsg
                            == pmsgOld );
            Tcp_ConnectionDeleteForSocket( pmsgOld->Socket, NULL );
        }

        //  failed getting message buffer on first query
        //  so connection does not yet exist
        //  closing socket, dump buffer

        else
        {
            Sock_CloseSocket( pmsgOld->Socket );
            FREE_HEAP( pmsgOld );
        }
        return( NULL );
    }

    //  record stats

    STAT_INC( PacketStats.TcpRealloc );
    STAT_ADD( PacketStats.TcpMemory, (bufferLength - pMsg->BufferLength) );
    PERF_ADD( pcTcpMessageMemory ,
            (bufferLength - pMsg->BufferLength) );      //PerfMon hook

    //  set new buffer (packet) length

    pMsg->BufferLength = bufferLength - DNS_MSG_INFO_HEADER_LENGTH;
    pMsg->pBufferEnd = (PCHAR)DNS_HEADER_PTR(pMsg) + pMsg->BufferLength;
    ASSERT( IS_DWORD_ALIGNED(pMsg->pBufferEnd) );

    //
    //  if new buffer
    //      - reset self-referential pointers
    //      - reset connection info to point at new message buffer
    //

    if ( pMsg != pmsgOld )
    {
        INT_PTR delta = (PCHAR)pMsg - (PCHAR)pmsgOld;

        SET_MESSAGE_FIELDS_AFTER_RECV( pMsg );
        pMsg->pQuestion = (PDNS_QUESTION) ((PCHAR)pMsg->pQuestion + delta);
        pMsg->pCurrent += delta;

        if ( pMsg->pchRecv )
        {
            pMsg->pchRecv += delta;
        }
        if ( pMsg->pConnection )
        {
            Tcp_ConnectionUpdateForPartialMessage( pMsg );
            ASSERT( ((PDNS_SOCKET)pMsg->pConnection)->pMsg == pMsg );
        }
    }

    IF_DEBUG( TCP )
    {
        DNS_PRINT((
            "Reallocated TCP message at %p:\n"
            "\tnew=%p, new length\n"
            "\texisting message at %p.\n",
            pmsgOld,
            pMsg,
            bufferLength ));

        //  existing query reallocated print it out

        if ( ! pMsg->pchRecv )
        {
            Dbg_DnsMessage(
                "New Reallocated query response",
                pMsg );
        }
    }
    return pMsg;
}
#endif



VOID
Packet_FreeTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free a standard sized RR.

Arguments:

    pMsg -- RR to free.

Return Value:

    None.

--*/
{
    if ( !pMsg )
    {
        return;
    }

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    //
    //  Never allocate TCP message of standard size.
    //  UDP messages switched to TCP (TCP cursive queries)
    //      are always flipped back to UDP for free
    //
    //  note, this is NOT necessary, as packets are atomic heap allocations
    //      but it is more efficient
    //

    //
    //  note, there is oddball case where switch message to TCP for recursion
    //      to remote DNS was NOT completed, before original query timed out
    //      of the recursion queue;  packet then freed as TCP
    //

    //ASSERT( pMsg->BufferLength != DNSSRV_UDP_PACKET_BUFFER_LENGTH );

    ASSERT( IS_PACKET_ACTIVE_TCP(pMsg) ||
            IS_PACKET_ACTIVE_UDP(pMsg) );

    if ( pMsg->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH &&
         IS_PACKET_ACTIVE_UDP(pMsg) )
    {
        DNS_DEBUG( ANY, (
            "UDP Packet %p came down TCP free pipe -- freeing via UDP routine.\n",
            pMsg ));
        Packet_FreeUdpMessage( pMsg );
        return;
    }

    //  verify recursion message cleaned up

    ASSERT( pMsg->pRecurseMsg == NULL );

    //  Queuing time serves as flag for ON or OFF queue
    //  no packet should be freed while on queue

    ASSERT( pMsg->dwQueuingTime == 0 );

    //  record stats

    STAT_INC( PacketStats.TcpFree );
    STAT_DEC( PacketStats.TcpNetAllocs );
    STAT_SUB( PacketStats.TcpMemory, (pMsg->BufferLength + DNS_MSG_INFO_HEADER_LENGTH) );
    PERF_SUB( pcTcpMessageMemory ,
                (pMsg->BufferLength + DNS_MSG_INFO_HEADER_LENGTH) );

    //  packet tracking
    //  no leak -- currently disabled
    //Packet_FreePacketTrack( pMsg );

    SET_PACKET_FREE_HEAP( pMsg );
    FREE_HEAP( pMsg );
}



//
//  Global packet routines -- not UDP or TCP specific.
//
//  This routine is used throughout the rest of the code for freeing
//  packets.  The specific TCP and UDP routines should NEVER be used
//  and hence are not made public.
//

VOID
FASTCALL
Packet_Initialize(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwUsableBufferLength,
    IN      DWORD           dwMaxBufferLength
    )
/*++

Routine Description:

    Standard initialization on a packet.

    Clear all flag fields, set buffer pointers.

Arguments:

    pMsg -- message to init

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;

    //
    //  clear header fields
    //      - clear from start all the way to additional blob
    //      - don't clear additional and compression for perf
    //      (a few cleared fields inits them below)
    //

    RtlZeroMemory(
        ( PCHAR ) pMsg,
        ( ( PCHAR )&pMsg->Additional - ( PCHAR )pMsg ) );

    //
    //  set basic packet info
    //

    pMsg->MaxBufferLength   = dwMaxBufferLength;
    pMsg->BufferLength      = dwUsableBufferLength;
    pMsg->pBufferEnd        = ( PCHAR ) DNS_HEADER_PTR( pMsg ) +
                              pMsg->BufferLength;

    //  end of buffer marker then lookup name will follow packet

    DNS_MSG_SET_BUFFER_MARKER( pMsg );
    
    pMsg->pLooknameQuestion = ( PLOOKUP_NAME )
        ( ( DNS_END_OF_BUFFER_MARKER_PTYPE )
          ( ( PCHAR ) DNS_HEADER_PTR( pMsg ) +
                      pMsg->MaxBufferLength ) + 1 );

    #ifdef _WIN64
    ASSERT( IS_QWORD_ALIGNED( pMsg->pBufferEnd ) );
    #else
    ASSERT( IS_DWORD_ALIGNED( pMsg->pBufferEnd ) );
    #endif

    //  handy markers for debugging

    pMsg->FlagMarker    = PACKET_FLAG_MARKER;
    pMsg->UnionMarker   = PACKET_UNION_MARKER;

    //  init additional info and compression

    INITIALIZE_ADDITIONAL( pMsg );
    INITIALIZE_COMPRESSION( pMsg );

    //  default to delete on send

    pMsg->fDelete = TRUE;

    //  address length
    //  need to set for both TCP and UDP as TCP response can be flipped
    //      or to UDP to forward to client

    DnsAddr_SetSockaddrRecvLength( &pMsg->RemoteAddr );

    //  packet tracking
    //  no current leaks, so this is off
    //Packet_AllocPacketTrack( pMsg );

    DNS_DEBUG( HEAP, (
        "Initialized new message buffer at %p (usable len=%d, max len=%d).\n",
        pMsg,
        pMsg->BufferLength,
        pMsg->MaxBufferLength ));

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );
}



VOID
Packet_Free(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free message info structure.

    Includes free of allocated sub-structures.

    This is the global "free a message" routine -- specific TCP \ UDP
    routines should NOT be used.

Arguments:

    pMsg -- message to free

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    precurse;

    if ( !pMsg )
    {
        return;
    }

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    //  catch free of queued or freed messages

    MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
    MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  free recursion message?
    //
    //  verify we're freeing original query, not freeing recursive
    //  query, as message it points back to may still be in use
    //
    //  note:  recursion message should always be UDP sized, even if
    //      recursed using TCP connection
    //

    MSG_ASSERT( pMsg, !pMsg->fRecursePacket );

    precurse = pMsg->pRecurseMsg;
    if ( precurse )
    {
        MSG_ASSERT( precurse, precurse != pMsg );
        MSG_ASSERT( precurse, precurse->pRecurseMsg == pMsg );
        MSG_ASSERT( precurse, precurse->fRecursePacket );
        MSG_ASSERT( precurse, ! precurse->pConnection );
#if DBG
        //  break cross-link to allow check if direct use of underlying routines

        pMsg->pRecurseMsg = NULL;
        precurse->pRecurseMsg = NULL;
        precurse->fTcp = FALSE;
        //  EDNS: buffer length is no longer always equal to UDP size!
        //  ASSERT( precurse->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH );
#endif
        Packet_FreeUdpMessage( precurse );
    }

    //
    //  remote NS list
    //

    if ( pMsg->pNsList )
    {
        Remote_NsListCleanup( pMsg );
        pMsg->pNsList = NULL;
    }

    //
    //  free message itself
    //

    if ( pMsg->fTcp )
    {
        Packet_FreeTcpMessage( pMsg );
    }
    else
    {
        Packet_FreeUdpMessage( pMsg );
    }
}




//
//  Debug packet tracking
//

#if DBG
LIST_ENTRY  PacketTrackListHead;

//  max time processing should take -- 10 minutes

#define MAX_PACKET_PROCESSING_TIME  (600)


DWORD   PacketTrackViolations;
DWORD   PacketTrackListLength;

PDNS_MSGINFO    pLastViolator;



VOID
Packet_InitPacketTrack(
    VOID
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- new message

Return Value:

    None.

--*/
{
    InitializeListHead( &PacketTrackListHead );

    PacketTrackViolations = 0;
    PacketTrackListLength = 0;
    pLastViolator = NULL;
}



VOID
Packet_AllocPacketTrack(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- new message

Return Value:

    None.

--*/
{
    //  use UDP message alloc lock

    LOCK_PACKET_LIST();

    //
    //  check list entry
    //

    if ( !IsListEmpty(&PacketTrackListHead) )
    {
        PDNS_MSGINFO    pfront;

        pfront = (PDNS_MSGINFO)
                    ( (PCHAR)pMsg - (PCHAR)&pMsg->DbgListEntry +
                    (PCHAR) PacketTrackListHead.Flink );

        if ( pfront != pLastViolator &&
            pfront->dwQueryTime + MAX_PACKET_PROCESSING_TIME < DNS_TIME() )
        {
            //  DEVNOTE: there's a problem here in that this packet may be 
            //      operational on another thread this could cause 
            //      changes in packet even as print takes place

            IF_DEBUG( OFF )
            {
                Dbg_DnsMessage(
                    "Message exceeded max processing time:",
                    pfront );
                //ASSERT( FALSE );
            }
            IF_DEBUG( ANY )
            {
                DNS_PRINT((
                    "WARNING:  Packet tracking violation %ds on packet %p\n"
                    "\ttotal violations     = %d\n"
                    "\tcurrent list length  = %d\n",
                    MAX_PACKET_PROCESSING_TIME,
                    pfront,
                    PacketTrackViolations,
                    PacketTrackListLength ));
            }
            PacketTrackViolations++;
            pLastViolator = pfront;
        }
    }

    //
    //  queue up new message
    //

    pMsg->dwQueryTime = DNS_TIME();

    RtlZeroMemory(
        & pMsg->Head,
        sizeof( DNS_HEADER ) );

    InsertTailList( &PacketTrackListHead, &pMsg->DbgListEntry );

    PacketTrackListLength++;
    UNLOCK_PACKET_LIST();
}



VOID
Packet_FreePacketTrack(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- freed message

Return Value:

    None.

--*/
{
    if ( !pMsg )
    {
        return;
    }

    LOCK_PACKET_LIST();
    RemoveEntryList( &pMsg->DbgListEntry );
    PacketTrackListLength--;
    UNLOCK_PACKET_LIST();
}
#endif


//
//  End packet.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\plugin.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    plugin.h

Abstract:

    Domain Name System (DNS) Server

    DNS plugins

    NOTE: AT THIS TIME THIS CODE IS NOT PART OF THE WINDOWS DNS
    SERVER AND IS NOT OFFICIALLY SUPPORTED.

Author:

    Jeff Westhead, November 2001

Revision History:

--*/


#ifndef _PLUGIN_H_INCLUDED
#define _PLUGIN_H_INCLUDED


#define DNS_SERVER      1

#include "DnsPluginInterface.h"


//
//  Globals
//

extern HMODULE                      g_hServerLevelPluginModule;

extern PLUGIN_INIT_FUNCTION         g_pfnPluginInit;
extern PLUGIN_CLEANUP_FUNCTION      g_pfnPluginCleanup;
extern PLUGIN_DNSQUERY_FUNCTION     g_pfnPluginDnsQuery;


//
//  Functions
//

DNS_STATUS
Plugin_Initialize(
    VOID
    );

DNS_STATUS
Plugin_Cleanup(
    VOID
    );

DNS_STATUS
Plugin_DnsQuery( 
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchQueryName
    );


#endif  //  _PLUGIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\plugin.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    plugin.c

Abstract:

    Domain Name System (DNS) Server

    Plugin module - allows third parties to provide DLLs
    that supply DNS records directly into the DNS server
    
    NOTE: AT THIS TIME THIS CODE IS NOT PART OF THE WINDOWS DNS
    SERVER AND IS NOT OFFICIALLY SUPPORTED.

Author:

    Jeff Westhead (jwesth)  November, 2001

Revision History:

    jwesth      11/2001     initial implementation

--*/


/****************************************************************************


****************************************************************************/


//
//  Includes
//


#include "dnssrv.h"

#include "plugin.h"


//
//  Constants
//


#define     DNS_PLUGIN_DEFAULT_NAME_ERROR_TTL       60


//
//  Globals
//


HMODULE                     g_hServerLevelPluginModule = NULL;

PLUGIN_INIT_FUNCTION        g_pfnPluginInit = NULL;
PLUGIN_CLEANUP_FUNCTION     g_pfnPluginCleanup = NULL;
PLUGIN_DNSQUERY_FUNCTION    g_pfnPluginDnsQuery = NULL;


//
//  Local functions
//



PVOID
__stdcall
pluginAllocator(
    size_t          dnsRecordDataLength
    )
/*++

Routine Description:

    Function that will be called by address from plugin DLLs to
    allocate resource record memory. Use this function only to
    allocate DNS resource records.

Arguments:

    dnsRecordDataLength -- size of DNS record data, for example
        you would pass 4 for an A record

Return Value:

    Pointer to memory block or NULL on allocation failure.

--*/
{
    DBG_FN( "pluginAllocator" )
    
    PDB_RECORD      pnewRecord;
    
    pnewRecord = RR_AllocateEx(
                    ( WORD ) dnsRecordDataLength,
                    MEMTAG_RECORD_CACHE );
    pnewRecord->dwTtlSeconds = 60 * 10;         //  10 minute default cache
    return pnewRecord;
}   //  pluginAllocator



VOID
__stdcall
pluginFree(
    PVOID           pFree
    )
/*++

Routine Description:

    Function that will be called by address from plugin DLLs to
    free resource record memory. Use this function only to
    free DNS resource records. 

Arguments:

    pFree -- pointer to DNS resource record to free

Return Value:

    None.

--*/
{
    DBG_FN( "pluginFree" )
    
    RR_Free( ( PDB_RECORD ) pFree );
}   //  pluginFree


//
//  External functions
//



DNS_STATUS
Plugin_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize plugins.

Arguments:

Return Value:

    Error code.

--*/
{
    DBG_FN( "Plugin_Initialize" )

    DNS_STATUS          status = ERROR_SUCCESS;

    if ( !SrvCfg_pwszServerLevelPluginDll )
    {
        goto Done;
    }
    
    //
    //  Free any resources in already in use.
    //
    
    Plugin_Cleanup();
    
    //
    //  Load the plugin DLL and entry points.
    //
    
    g_hServerLevelPluginModule = LoadLibraryW( SrvCfg_pwszServerLevelPluginDll );
    if ( !g_hServerLevelPluginModule )
    {
        status = GetLastError();
        DNSLOG( PLUGIN, (
            "Error %d loading plugin DLL %S\n",
            status,
            SrvCfg_pwszServerLevelPluginDll ));
        goto Done;
    }

    g_pfnPluginInit = ( PLUGIN_INIT_FUNCTION )
        GetProcAddress(
            g_hServerLevelPluginModule,
            PLUGIN_FNAME_INIT );
    if ( !g_pfnPluginInit )
    {
        status = GetLastError();
        DNSLOG( PLUGIN, (
            "Error %d loading " PLUGIN_FNAME_INIT " from DLL %S\n",
            status,
            SrvCfg_pwszServerLevelPluginDll ));
        goto Done;
    }
    
    g_pfnPluginCleanup = ( PLUGIN_CLEANUP_FUNCTION )
        GetProcAddress(
            g_hServerLevelPluginModule,
            PLUGIN_FNAME_CLEANUP );
    if ( !g_pfnPluginCleanup )
    {
        status = GetLastError();
        DNSLOG( PLUGIN, (
            "Error %d loading " PLUGIN_FNAME_CLEANUP " from DLL %S\n",
            status,
            SrvCfg_pwszServerLevelPluginDll ));
        goto Done;
    }
    
    g_pfnPluginDnsQuery = ( PLUGIN_DNSQUERY_FUNCTION )
        GetProcAddress(
            g_hServerLevelPluginModule,
            PLUGIN_FNAME_DNSQUERY );
    if ( !g_pfnPluginDnsQuery )
    {
        status = GetLastError();
        DNSLOG( PLUGIN, (
            "Error %d loading " PLUGIN_FNAME_DNSQUERY " from DLL %S\n",
            status,
            SrvCfg_pwszServerLevelPluginDll ));
        goto Done;
    }
    
    Done:
    
    //
    //  Call initialize function.
    //
    
    if ( status == ERROR_SUCCESS && g_pfnPluginInit )
    {
        status = g_pfnPluginInit( pluginAllocator, pluginFree );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: plugin init returned %d for DLL %S\n", fn,
                status,
                SrvCfg_pwszServerLevelPluginDll ));
            Plugin_Cleanup();
        }
    }
    
    if ( SrvCfg_pwszServerLevelPluginDll )
    {
        DNS_DEBUG( INIT, (
            "%s: returning %d for DLL %S\n", fn,
            status,
            SrvCfg_pwszServerLevelPluginDll ));
    }

    return status;
}   //  Plugin_Initialize



DNS_STATUS
Plugin_Cleanup(
    VOID
    )
/*++

Routine Description:

    Free resources for plugins.

Arguments:

Return Value:

    Error code.

--*/
{
    DBG_FN( "Plugin_Cleanup" )

    DNS_STATUS          status = ERROR_SUCCESS;

    if ( g_hServerLevelPluginModule )
    {
        //
        //  Call cleanup function if we have one.
        //
        
        if ( g_pfnPluginCleanup )
        {
            g_pfnPluginCleanup();
        }

        FreeLibrary( g_hServerLevelPluginModule );
        g_hServerLevelPluginModule = NULL;
        g_pfnPluginInit = NULL;
        g_pfnPluginCleanup = NULL;
        g_pfnPluginDnsQuery = NULL;
    }

    DNS_DEBUG( INIT, ( "%s: returning %s\n", status ));

    return status;
}   //  Plugin_Cleanup



DNS_STATUS
Plugin_DnsQuery( 
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchQueryName
    )
/*++

Routine Description:

    Call plugin and insert result RRs into cache.

Arguments:

    pMsg -- DNS message
    
    pchQueryName -- pointer to query name in message

Return Value:

    Error code.

--*/
{
    DBG_FN( "Plugin_DnsQuery" )

    DNS_STATUS          status = ERROR_SUCCESS;
    CHAR                szname[ 2 * DNS_MAX_NAME_LENGTH + 2 ];
    CHAR                szownerName[ 2 * DNS_MAX_NAME_LENGTH + 2 ];
    PDB_RECORD          prrlistHead = NULL;
    PDB_RECORD          prrlistTail;
    PDB_RECORD          prr;
    PDB_NODE            pnode;
    LOOKUP_NAME         lookupName;

    #if DBG
    DWORD               timer;
    #endif

    if ( g_pfnPluginDnsQuery == NULL )
    {
        goto Done;
    }

    //
    //  Create or find a cache node for this question.
    //
    
    pnode = Lookup_NodeForPacket(
                pMsg,
                pchQueryName,
                LOOKUP_CACHE_CREATE );
    if ( !pnode )
    {
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Done;
    }

    //
    //  Convert the question name to a dotted name.
    //
    
    if ( Name_ConvertPacketNameToLookupName(
                pMsg,
                pchQueryName,
                &lookupName ) == 0 )
    {
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Done;
    }

    if ( Name_ConvertLookupNameToDottedName( 
                szname,
                &lookupName ) == 0 )
    {
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Done;
    }

    //
    //  Query the plugin for a record list at for this name and type.
    //

    #if DBG
    timer = GetTickCount();
    #endif
    
    *szownerName = '\0';

    status = g_pfnPluginDnsQuery(
                    szname,
                    pMsg->wTypeCurrent,
                    szownerName,
                    &prrlistHead );

    #if DBG
    timer = GetTickCount() - timer;
    ASSERT( timer < 1000 && GetTickCount() > 1000000 )
    DNSLOG( PLUGIN, (
        "plugin returned %d in %d msecs\n"
        "    type %d at name %s\n"
        "    plugin returned owner name %s\n", fn,
        status,
        timer,
        pMsg->wQuestionType,
        szname,
        szownerName ));
    #endif

    //
    //  Cache name error, auth empty response, etc. depending on
    //  plugin return code.
    //
    
    if ( status == DNS_PLUGIN_NO_RECORDS || status == DNS_PLUGIN_NAME_ERROR )
    {
        PDB_NODE            pzoneRootNode = NULL;

        //
        //  If the plugin has provided an SOA record, find or create a
        //  cache node for it. The plugin must return only a single record
        //  in this case and the record must be of type SOA.
        //
        
        ASSERT( !prrlistHead ||
                prrlistHead &&
                    prrlistHead->wType == DNS_TYPE_SOA &&
                    !prrlistHead->pRRNext );

        if ( prrlistHead && prrlistHead->wType == DNS_TYPE_SOA && *szownerName )
        {
            pzoneRootNode = Lookup_ZoneNodeFromDotted(
                                NULL,           //  zone pointer
                                szownerName,
                                strlen( szownerName ),
                                LOOKUP_CACHE_CREATE,
                                NULL,           //  closest node pointer
                                NULL );         //  status pointer
        }
        
        //
        //  Cache the name error or empty auth response.
        //
        
        ( status == DNS_PLUGIN_NO_RECORDS
            ? RR_CacheEmptyAuth
            : RR_CacheNameError )
                    ( pnode,
                      pMsg->wQuestionType,
                      pMsg->dwQueryTime,
                      TRUE,                     //  authoritative
                      pzoneRootNode,            //  SOA zone root
                      prrlistHead
                            ? prrlistHead->Data.SOA.dwMinimumTtl
                            : DNS_PLUGIN_DEFAULT_NAME_ERROR_TTL );

        //
        //  Drop through and cache the SOA record at the SOA node.
        //
        
        pnode = pzoneRootNode;
    }
    else if ( status != DNS_PLUGIN_SUCCESS )
    {
        goto Done;
    }
    
    //
    //  Cache the record set returned at this node.
    //
    
    if ( prrlistHead )
    {
        BOOL            cachedOkay;

        //
        //  Traverse list, fixup values, find tail.
        //
        
        for ( prr = prrlistHead; prr; prr = prr->pRRNext )
        {
            if ( prr->wType == DNS_TYPE_A )
            {
                RR_RANK( prr ) = RANK_CACHE_A_ANSWER;
            }
            else
            {
                RR_RANK( prr ) = RANK_CACHE_NA_ANSWER;
            }

            if ( prr->dwTtlSeconds == 0 )
            {
                prr->dwTtlSeconds = 3600;   //  default TTL is one hour
            }
            else if ( prr->dwTtlSeconds < 10 )
            {
                prr->dwTtlSeconds = 10;     //  minimum TTL is 10 seconds
            }

            if ( !prr->pRRNext )
            {
                prrlistTail = prr;
            }
        }
        
        //
        //  Cache the record set.
        //

        if ( pnode )
        {
            cachedOkay = RR_CacheSetAtNode(
                            pnode,
                            prrlistHead,
                            prrlistTail,
                            prrlistHead->dwTtlSeconds,
                            DNS_TIME() );
            if ( cachedOkay )
            {
                prrlistHead = NULL;
            }
            else
            {
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
            }
        }
    }

    Done:
    
    //
    //  If the plugin allocated a record list but it was not consumed
    //  for some reason, free it.
    //
    
    if ( prrlistHead )
    {
        PDB_RECORD      prrnext;
        
        for ( prr = prrlistHead; prr; prr = prrnext )
        {
            prrnext = prr->pRRNext;
            RR_Free( prr );
        }
    }

    //
    //  If the plugin returned NO_RECORDS or NAME_ERROR, then we have cached
    //  that information appropriately, and we should return SUCCESS to the
    //  caller to signify that the plugin has given us valid data and that
    //  data has been inserted into the DNS server cache.
    //
        
    if ( status == DNS_PLUGIN_NO_RECORDS || status == DNS_PLUGIN_NAME_ERROR )
    {
        status = ERROR_SUCCESS;
    }

    DNS_DEBUG( INIT, ( "%s: returning %d\n", fn, status ));
    
    return status;
}   //  Plugin_DnsQuery


//
//  End plugin.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\record.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    record.h

Abstract:

    Domain Name System(DNS) Server

    Resource record database definitions.

Author:

    Jim Gilroy (jamesg)     June 27, 1995

Revision History:

    jamesg  Mar 1995    --  writing RR from message to database
    jamesg  May 1995    --  HINFO, TXT, WKS, MINFO definitions
                        --  parsing RR types
                        --  support variable sized RR
    jamesg  Jun 1995    --  RR delete
                        --  CAIRO RR
                        --  RR cleanup
                        --  created this file
    jamesg  Dec 1996    --  type indexed dispatch tables

--*/


#ifndef _RECORD_INCLUDED_
#define _RECORD_INCLUDED_



//
//  RR data rank
//
//  Cache data always has low bit set to allow single bit
//  test for all cache data types.
//

#define RANK_ZONE                   (0xf0)
#define RANK_CACHE_A_ANSWER         (0xc1)
#define RANK_NS_GLUE                (0x82)
#define RANK_GLUE                   (0x80)
#define RANK_CACHE_A_AUTHORITY      (0x71)
#define RANK_CACHE_NA_ANSWER        (0x61)
#define RANK_CACHE_A_ADDITIONAL     (0x51)
#define RANK_CACHE_NA_AUTHORITY     (0x41)
#define RANK_CACHE_NA_ADDITIONAL    (0x31)
#define RANK_OUTSIDE_GLUE           (0x20)
#define RANK_ROOT_HINT              (0x08)

#define RANK_CACHE_BIT              (0x01)
#define IS_CACHE_RANK(rank)         ( (rank) & RANK_CACHE_BIT )
#define IS_CACHE_RR(pRR)            ( IS_CACHE_RANK( (pRR)->RecordRank ))


//
//  Hack for debugging slow-free \ double frees
//
#define RANK_SLOWFREE_BIT           (0x04)
#define SET_SLOWFREE_RANK(pRR)      ( (pRR)->RecordRank |= RANK_SLOWFREE_BIT )
#define IS_SLOWFREE_RANK(pRR)       ( (pRR)->RecordRank & RANK_SLOWFREE_BIT )

//
//  Query/Set Rank
//

#define IS_ZONE_RR(pRR)             ( (pRR)->RecordRank == RANK_ZONE )
#define IS_ROOT_HINT_RR(pRR)        ( (pRR)->RecordRank == RANK_ROOT_HINT )
#define IS_CACHE_HINT_RR(pRR)       ( IS_ROOT_HINT_RR(pRR) )
#define IS_GLUE_RR(pRR)             ( (pRR)->RecordRank == RANK_GLUE )
#define IS_OUTSIDE_GLUE_RR(pRR)     ( (pRR)->RecordRank == RANK_OUTSIDE_GLUE )
#define IS_NS_GLUE_RR(pRR)          ( (pRR)->RecordRank == RANK_NS_GLUE )

#define SET_RANK_ZONE(pRR)          ( (pRR)->RecordRank = RANK_ZONE )
#define SET_RANK_NS_GLUE(pRR)       ( (pRR)->RecordRank = RANK_NS_GLUE )
#define SET_RANK_GLUE(pRR)          ( (pRR)->RecordRank = RANK_GLUE )
#define SET_RANK_OUTSIDE_GLUE(pRR)  ( (pRR)->RecordRank = RANK_OUTSIDE_GLUE )
#define SET_RANK_ROOT_HINT(pRR)     ( (pRR)->RecordRank = RANK_ROOT_HINT )

#define RR_RANK(pRR)                ( (pRR)->RecordRank )
#define CLEAR_RR_RANK(pRR)          ( (pRR)->RecordRank = 0 )
#define SET_RR_RANK(pRR, rank)      ( (pRR)->RecordRank = (rank) )

//
//  RR flag properties
//

#define RR_ZERO_TTL         0x0010
#define RR_FIXED_TTL        0x0020
#define RR_ZONE_TTL         0x0040
#define RR_EMPTY_AUTH       0x0080      //  cached empty auth for RR type
#define RR_REFERENCE        0x0100      //  references a node
#define RR_SLOW_FREE        0x0200      //  free with timeout

#define RR_DO_NOT_AGE       0x0400      //  ignore when force aging records

#define RR_VALID            0x1000      //  valid in-use
#define RR_LISTED           0x4000      //  in RR list
#define RR_MATCH            0x8000      //  matched in comparison operation

//
//  Query/Set RR properties
//

#define IS_ZERO_TTL_RR(pRR)         ( (pRR)->wRRFlags & RR_ZERO_TTL )
#define IS_FIXED_TTL_RR(pRR)        ( (pRR)->wRRFlags & RR_FIXED_TTL )
#define IS_ZONE_TTL_RR(pRR)         ( (pRR)->wRRFlags & RR_ZONE_TTL )
#define IS_REFERENCE_RR(pRR)        ( (pRR)->wRRFlags & RR_REFERENCE )
#define IS_SLOW_FREE_RR(pRR)        ( (pRR)->wRRFlags & RR_SLOW_FREE )
#define IS_MATCH_RR(pRR)            ( (pRR)->wRRFlags & RR_MATCH )
#define IS_EMPTY_AUTH_RR(pRR)       ( (pRR)->wRRFlags & RR_EMPTY_AUTH )
#define IS_DO_NOT_AGE_RR(pRR)       ( (pRR)->wRRFlags & RR_DO_NOT_AGE )

#if DBG
#define IS_LISTED_RR(pRR)           ( (pRR)->wRRFlags & RR_LISTED )
#else   // retail:  need some expression when used in ASSERTs even when macroed away
#define IS_LISTED_RR(pRR)           ( TRUE )
#endif

#define SET_FIXED_TTL_RR(pRR)       ( (pRR)->wRRFlags |= RR_FIXED_TTL )
#define SET_ZERO_TTL_RR(pRR)        ( (pRR)->wRRFlags |= RR_ZERO_TTL )
#define SET_ZONE_TTL_RR(pRR)        ( (pRR)->wRRFlags |= RR_ZONE_TTL )
#define SET_REFERENCE_RR(pRR)       ( (pRR)->wRRFlags |= RR_REFERENCE )
#define SET_SLOW_FREE_RR(pRR)       ( (pRR)->wRRFlags |= RR_SLOW_FREE )
#define SET_MATCH_RR(pRR)           ( (pRR)->wRRFlags |= RR_MATCH )
#define SET_LISTED_RR(pRR)          ( (pRR)->wRRFlags |= RR_LISTED )
#define SET_EMPTY_AUTH_RR(pRR)      ( (pRR)->wRRFlags |= RR_EMPTY_AUTH )
#define SET_DO_NOT_AGE_RR(pRR)      ( (pRR)->wRRFlags |= RR_DO_NOT_AGE )

#define CLEAR_FIXED_TTL_RR(pRR)     ( (pRR)->wRRFlags &= ~RR_FIXED_TTL )
#define CLEAR_ZERO_TTL_RR(pRR)      ( (pRR)->wRRFlags &= ~RR_ZERO_TTL )
#define CLEAR_ZONE_TTL_RR(pRR)      ( (pRR)->wRRFlags &= ~RR_ZONE_TTL )
#define CLEAR_REFERENCE_RR(pRR)     ( (pRR)->wRRFlags &= ~RR_REFERENCE )
#define CLEAR_MATCH_RR(pRR)         ( (pRR)->wRRFlags &= ~RR_MATCH )
#define CLEAR_LISTED_RR(pRR)        ( (pRR)->wRRFlags &= ~RR_LISTED )
#define CLEAR_EMPTY_AUTH_RR(pRR)    ( (pRR)->wRRFlags &= ~RR_EMPTY_AUTH )
#define CLEAR_DO_NOT_AGE_RR(pRR)    ( (pRR)->wRRFlags &= ~RR_DO_NOT_AGE )

//
//  Reserved flag properties
//

typedef struct _ReservedRecordFlags
{
    BYTE    Source          : 4;
    BYTE    Reserved        : 3;
    BYTE    StandardAlloc   : 1;
}
RECRESVFLAG, *PRECRESVFLAG;

#if 0
#define RR_FILE             (1)     //  source
#define RR_DS               (2)
#define RR_ADMIN            (3)
#define RR_DYNUP            (4)
#define RR_AXFR             (5)
#define RR_IXFR             (6)
#define RR_COPY             (7)
#define RR_CACHE            (8)
#define RR_NO_EXIST         (9)
#define RR_AUTO             (10)
#define RR_SOURCE_MAX       (RR_AUTO)

#define SET_FILE_RR(pRR)        ( (pRR)->Reserved.Source = RR_FILE )
#define SET_DS_RR(pRR)          ( (pRR)->Reserved.Source = RR_DS )
#define SET_ADMIN_RR(pRR)       ( (pRR)->Reserved.Source = RR_ADMIN )
#define SET_DYNUP_RR(pRR)       ( (pRR)->Reserved.Source = RR_DYNUP )
#define SET_AXFR_RR(pRR)        ( (pRR)->Reserved.Source = RR_AXFR )
#define SET_IXFR_RR(pRR)        ( (pRR)->Reserved.Source = RR_IXFR )
#define SET_COPY_RR(pRR)        ( (pRR)->Reserved.Source = RR_COPY )
#define SET_CACHE_RR(pRR)       ( (pRR)->Reserved.Source = RR_CACHE )
#define SET_AUTO_RR(pRR)        ( (pRR)->Reserved.Source = RR_AUTO )
#endif

//
//  Type bitmask
//
//  For some tracking purposes it is nice to know list of types
//  as bitmask (ULONGLONG).
//

#define A_BITMASK_BIT           ((ULONGLONG) 0x0000000000000002)
#define NS_BITMASK_BIT          ((ULONGLONG) 0x0000000000000004)
#define CNAME_BITMASK_BIT       ((ULONGLONG) 0x0000000000000020)
#define SOA_BITMASK_BIT         ((ULONGLONG) 0x0000000000000040)
#define PTR_BITMASK_BIT         ((ULONGLONG) 0x0000000000001000)
#define MX_BITMASK_BIT          ((ULONGLONG) 0x0000000000008000)
#define SRV_BITMASK_BIT         ((ULONGLONG) 0x0000000200000000)
#define OTHERTYPE_BITMASK_BIT   ((ULONGLONG) 0x8000000000000000)

#if 0
#define A_BITMASK_BIT           ((ULONGLONG) 0x00000001)
#define NS_BITMASK_BIT          ((ULONGLONG) 0x00000002)
#define CNAME_BITMASK_BIT       ((ULONGLONG) 0x00000010)
#define SOA_BITMASK_BIT         ((ULONGLONG) 0x00000020)
#define PTR_BITMASK_BIT         ((ULONGLONG) 0x00000800)
#define MX_BITMASK_BIT          ((ULONGLONG) 0x00004000)
#define SRV_BITMASK_BIT         ((ULONGLONG) 0x80000000)
#define OTHERTYPE_BITMASK_BIT   ((ULONGLONG) 0x00000004)    // using MF space
#endif


//
//  Get node referenced by record data
//

#define REF_RAW_NAME( pnode )   ( (PCHAR)&(pnode))

//
//  Resource record list manipulation.
//

#define EMPTY_RR_LIST( pNode )  ( ! pNode->pRRList )

#define FIRST_RR( pNode )       ((PDB_RECORD)pNode->pRRList)

#define NEXT_RR( pRR )          ( (pRR)->pRRNext )

//
//  simple RR list traversal
//
//  use this to get addr of node's RR list ptr, which is then
//  treated as list ptr
//
//  simple detail free traverse then looks like
//
//      pRR = START_RR_TRAVERSE( pNode );
//
//      WHILE_MORE_RR( pRR )
//      {
//          // do stuff
//      }
//

#define START_RR_TRAVERSE(pNode)    ((PDB_RECORD)&pNode->pRRList)

#define WHILE_MORE_RR( pRR )     while( pRR = pRR->pRRNext )


//
//  Resource record database structure
//

//
//  Size of type independent fields -- always present
//
//  WARNING:  MUST! keep this current with changes in header
//

#define SIZEOF_DBASE_RR_FIXED_PART ( \
                sizeof(PVOID) + \
                sizeof(DWORD) + \
                sizeof(WORD)  + \
                sizeof(WORD)  + \
                sizeof(DWORD) + \
                sizeof(DWORD) )

#define SIZEOF_DBASE_A_RECORD   (SIZEOF_DBASE_RR_FIXED_PART \
                                    + sizeof(IP_ADDRESS))

//
//  Minimum record type specific database sizes.
//
//  Fixed field definitions are in dnslib record.h
//

#define MIN_PTR_SIZE        (SIZEOF_DBASE_NAME_FIXED)
#define MIN_MX_SIZE         (sizeof(WORD) + SIZEOF_DBASE_NAME_FIXED)
#define MIN_SOA_SIZE        (SIZEOF_SOA_FIXED_DATA + 2*SIZEOF_DBASE_NAME_FIXED)
#define MIN_MINFO_SIZE      (2 * SIZEOF_DBASE_NAME_FIXED)
#define MIN_SRV_SIZE        (SIZEOF_SRV_FIXED_DATA + SIZEOF_DBASE_NAME_FIXED)

#define MIN_WINS_SIZE       (SIZEOF_WINS_FIXED_DATA + sizeof(DWORD))
#define MIN_NBSTAT_SIZE     (SIZEOF_WINS_FIXED_DATA + SIZEOF_DBASE_NAME_FIXED)


//
//  RR structure
//
//  NOTE:  For efficiency, all these fields should be aligned.
//
//  Class is a property of entire tree (database), so not stored
//  in records.  (Only supportting IN       class currently.)
//
//  Note to speed response all data -- that is not pointer to another
//  DNS node -- is kept in network byte order.
//  In addition, TTL (for non-cached data) is in network byte order.
//

#define DNS_MAX_TYPE_BITMAP_LENGTH      (16)

typedef struct _Dbase_Record
{
    //
    //  Next pointer MUST be at front of structure to allow us
    //  to treat the RR list ptr in the domain NODE, identical
    //  as a regular RR ptr, for purposes of accessing its "next"
    //  ptr.  This allows us to simplify or avoid all the front of
    //  list special cases.
    //

    struct _Dbase_Record *    pRRNext;

    //
    //  Flags -- caching, rank, etc.
    //

    UCHAR           RecordRank;
    RECRESVFLAG     Reserved;
    WORD            wRRFlags;

    WORD            wType;              // in host order
    WORD            wDataLength;

    DWORD           dwTtlSeconds;       // in network order for regular fixed TTL
                                        // in host order, if cached timeout
    DWORD           dwTimeStamp;        // create time stamp (hours)

    //
    //  Data for specific types
    //

    union
    {
        struct
        {
            IP_ADDRESS      ipAddress;
        }
        A;

        struct
        {
            //  Note: this is a QWORD-aligned structure. On ia64 the stuff
            //  before union is currently a pointer and 4 DWORDs, so the
            //  alignment is good. But if we ever change the stuff before
            //  the union the compiler may insert badding to QWORD-align
            //  the union. This will mess with our fixed-constant allocation
            //  stuff, so be careful.
            IP6_ADDRESS     Ip6Addr;
        }
        AAAA;

        struct
        {
            DWORD           dwSerialNo;
            DWORD           dwRefresh;
            DWORD           dwRetry;
            DWORD           dwExpire;
            DWORD           dwMinimumTtl;
            DB_NAME         namePrimaryServer;

            //  ZoneAdmin name immediately follows
            //  DB_NAME         nameZoneAdmin;
        }
        SOA;

        struct
        {
            DB_NAME         nameTarget;
        }
        PTR,
        NS,
        CNAME,
        MB,
        MD,
        MF,
        MG,
        MR;

        struct
        {
            DB_NAME         nameMailbox;

            //  ErrorsMailbox immediately follows
            // DB_NAME         nameErrorsMailbox;
        }
        MINFO,
        RP;

        struct
        {
            WORD            wPreference;
            DB_NAME         nameExchange;
        }
        MX,
        AFSDB,
        RT;

        struct
        {
            BYTE            chData[1];
        }
        HINFO,
        ISDN,
        TXT,
        X25,
        Null;

        struct
        {
            IP_ADDRESS      ipAddress;
            UCHAR           chProtocol;
            BYTE            bBitMask[1];
        }
        WKS;

        struct
        {
            WORD            wTypeCovered;
            BYTE            chAlgorithm;
            BYTE            chLabelCount;
            DWORD           dwOriginalTtl;
            DWORD           dwSigExpiration;
            DWORD           dwSigInception;
            WORD            wKeyTag;
            DB_NAME         nameSigner;
            //  signature data follows signer's name
        }
        SIG;

        struct
        {
            WORD            wFlags;
            BYTE            chProtocol;
            BYTE            chAlgorithm;
            BYTE            Key[1];
        }
        KEY;

        struct
        {
            WORD            wVersion;
            WORD            wSize;
            WORD            wHorPrec;
            WORD            wVerPrec;
            DWORD           dwLatitude;
            DWORD           dwLongitude;
            DWORD           dwAltitude;
        }
        LOC;

        struct
        {
            BYTE            bTypeBitMap[ DNS_MAX_TYPE_BITMAP_LENGTH ];
            DB_NAME         nameNext;
        }
        NXT;

        struct
        {
            WORD            wPriority;
            WORD            wWeight;
            WORD            wPort;
            DB_NAME         nameTarget;
        }
        SRV;

        struct
        {
            UCHAR           chFormat;
            BYTE            bAddress[1];
        }
        ATMA;

        struct
        {
            DWORD           dwTimeSigned;
            DWORD           dwTimeExpire;
            WORD            wSigLength;
            BYTE            bSignature;
            DB_NAME         nameAlgorithm;

            //  Maybe followed in packet by other data
            //  If need to process then move fixed fields ahead of
            //      bSignature

            //  WORD    wError;
            //  WORD    wOtherLen;
            //  BYTE    bOtherData;
        }
        TSIG;

        struct
        {
            WORD            wKeyLength;
            BYTE            bKey[1];
        }
        TKEY;

        //
        //  MS types
        //

        struct
        {
            DWORD           dwMappingFlag;
            DWORD           dwLookupTimeout;
            DWORD           dwCacheTimeout;
            DWORD           cWinsServerCount;
            IP_ADDRESS      aipWinsServers[1];
        }
        WINS;

        struct
        {
            DWORD           dwMappingFlag;
            DWORD           dwLookupTimeout;
            DWORD           dwCacheTimeout;
            DB_NAME         nameResultDomain;
        }
        WINSR;

        //
        //  NoExist is special in that always refers to name above it in tree.
        //      so can still use reference.
        //
        //  DEVNOTE: could switch to just tracking labels above it in tree (safer)
        //

        struct
        {
            PDB_NODE        pnodeZoneRoot;
        }
        NOEXIST;

        //
        //  Empty auth functions much like NOEXIST
        //

        struct
        {
            PDB_NODE        psoaNode;
        }
        EMPTYAUTH;

        struct
        {
            UCHAR           chPrefixBits;
            // AddressSuffix should be SIZEOF_A6_ADDRESS_SUFFIX_LENGTH
            // bytes but that constant is not available in dnsexts
            BYTE            AddressSuffix[ 16 ];
            DB_NAME         namePrefix;
        }
        A6;

        struct
        {
            WORD            wUdpPayloadSize;
            DWORD           dwExtendedFlags;
            // Add array for <attribute,value pairs> here for EDNS1+
        }
        OPT;

    } Data;
}
DB_RECORD, *PDB_RECORD;

typedef const DB_RECORD *PCDB_RECORD;


//
//  Record parsing structure.
//

typedef struct _ParseRecord
{
    //
    //  Next pointer MUST be at front of structure.
    //  Allows list add macros to handle these cleanly and node ptr
    //  to list to be treated as RR.
    //

    struct _ParseRecord *  pNext;

    PCHAR   pchWireRR;
    PCHAR   pchData;

    DWORD   dwTtl;

    WORD    wClass;
    WORD    wType;
    WORD    wDataLength;

    UCHAR   Section;
    UCHAR   SourceTag;
}
PARSE_RECORD, *PPARSE_RECORD;


//
//  DS Record
//

typedef struct _DsRecordFlags
{
    DWORD   Reserved    :   16;
    DWORD   Version     :   8;
    DWORD   Rank        :   8;
}
DS_RECORD_FLAGS, *PDS_RECORD_FLAGS;

#define DS_RECORD_VERSION_RELEASE   (5)

typedef struct _DsRecord
{
    WORD                wDataLength;
    WORD                wType;

    //DWORD               dwFlags;
    BYTE                Version;
    BYTE                Rank;
    WORD                wFlags;

    DWORD               dwSerial;
    DWORD               dwTtlSeconds;
    DWORD               dwReserved;
    DWORD               dwTimeStamp;

    union               _DataUnion
    {
        struct
        {
            LONGLONG        EntombedTime;
        }
        Tombstone;
    }
    Data;
}
DS_RECORD, *PDS_RECORD;

#define SIZEOF_DS_RECORD_HEADER         (6*sizeof(DWORD))



//
//  Resource record type operations (rrecord.c)
//

WORD
FASTCALL
QueryIndexForType(
    IN      WORD            wType
    );

WORD
FASTCALL
RR_IndexForType(
    IN      WORD            wType
    );

BOOL
RR_AllocationInit(
    VOID
    );

PDB_RECORD
RR_CreateFromWire(
    IN      WORD            wType,
    IN      WORD            wDataLength
    );

PDB_RECORD
RR_CreateFixedLength(
    IN      WORD            wType
    );

PDB_RECORD
RR_Copy(
    IN      PDB_RECORD      pSoaRR,
    IN      DWORD           Flag
    );

PDB_RECORD
RR_AllocateEx(
    IN      WORD            wDataLength,
    IN      DWORD           SourceTag
    );

//  backward compatibility

#define RR_Allocate(len)    RR_AllocateEx( len, 0 )

PDB_NODE
RR_DataReference(
    IN OUT  PDB_NODE        pNode
    );

DNS_STATUS
RR_DerefAndFree(
    IN OUT  PDB_RECORD      pRR
    );

VOID
RR_Free(
    IN OUT  PDB_RECORD      pRR
    );

BOOL
RR_Validate(
    IN      PDB_RECORD      pRR,
    IN      BOOL            fActive,
    IN      WORD            wType,
    IN      DWORD           dwSource
    );

#define IS_VALID_RECORD(pRR)    (RR_Validate(pRR,TRUE,0,0))


VOID
RR_WriteDerivedStats(
    VOID
    );

ULONGLONG
RR_SetTypeInBitmask(
    IN OUT  ULONGLONG       TypeBitmask,
    IN      WORD            wType
    );

//
//  Standard type creation (rrecord.c)
//

PDB_RECORD
RR_CreateARecord(
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwTtl,
    IN      DWORD           SourceTag
    );

PDB_RECORD
RR_CreatePtr(
    IN      PDB_NAME        pNameTarget,
    IN      LPSTR           pszTarget,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      DWORD           SourceTag
    );

PDB_RECORD
RR_CreateSoa(
    IN      PDB_RECORD      pExistingSoa,
    IN      PDB_NAME        pnameAdmin,
    IN      LPSTR           pszAdmin
    );

//
//  Type specific functions
//  From rrflat.c
//

PCHAR
WksFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    );

//
//  Name error caching -- Currently using RR of zero type.
//

#define DNS_TYPE_NOEXIST    DNS_TYPE_ZERO


//
//  Resource record dispatch tables
//

typedef DNS_STATUS (* RR_FILE_READ_FUNCTION)();

extern  RR_FILE_READ_FUNCTION   RRFileReadTable[];

typedef PCHAR (* RR_FILE_WRITE_FUNCTION)();

extern  RR_FILE_WRITE_FUNCTION  RRFileWriteTable[];


typedef PDB_RECORD (* RR_WIRE_READ_FUNCTION)();

extern  RR_WIRE_READ_FUNCTION   RRWireReadTable[];

typedef PCHAR (* RR_WIRE_WRITE_FUNCTION)();

extern  RR_WIRE_WRITE_FUNCTION  RRWireWriteTable[];


typedef DNS_STATUS (* RR_FLAT_READ_FUNCTION)();

extern  RR_FLAT_READ_FUNCTION   RRFlatReadTable[];

typedef PCHAR (* RR_FLAT_WRITE_FUNCTION)();

extern  RR_FLAT_WRITE_FUNCTION  RRFlatWriteTable[];


typedef DNS_STATUS (* RR_VALIDATE_FUNCTION)();

extern  RR_VALIDATE_FUNCTION    RecordValidateTable[];


//
//  Generic template for dispatch function lookup
//

typedef VOID (* RR_GENERIC_DISPATCH_FUNCTION)();

typedef RR_GENERIC_DISPATCH_FUNCTION    RR_GENERIC_DISPATCH_TABLE[];

RR_GENERIC_DISPATCH_FUNCTION
RR_DispatchFunctionForType(
    IN      RR_GENERIC_DISPATCH_TABLE   pTable,
    IN      WORD                        wType
    );

//
//  Indexing into dispatch tables or property tables
//
//  Check type against max self indexed type.
//  Offsets to other types:
//      - WINS\WINSR packed in after last self-indexed
//      - then compound query types
//

#define DNSSRV_MAX_SELF_INDEXED_TYPE    (48)

#define DNSSRV_OFFSET_TO_WINS_TYPE_INDEX    \
        (DNS_TYPE_WINS - DNSSRV_MAX_SELF_INDEXED_TYPE - 1)

#define DNSSRV_OFFSET_TO_COMPOUND_TYPE_INDEX    \
        (DNS_TYPE_TKEY - DNSSRV_MAX_SELF_INDEXED_TYPE - 3)

#ifdef  INDEX_FOR_TYPE
#undef  INDEX_FOR_TYPE
#endif

#define INDEX_FOR_TYPE(type)    \
        ( (type <= DNSSRV_MAX_SELF_INDEXED_TYPE)   \
            ? type                          \
            : RR_IndexForType(type) )

#define INDEX_FOR_QUERY_TYPE(type)    \
        ( (type <= DNSSRV_MAX_SELF_INDEXED_TYPE)   \
            ? type                          \
            : QueryIndexForType(type) )



//
//  Type property table property indexes
//

extern  UCHAR  RecordTypePropertyTable[][5];

#define RECORD_PROP_CNAME_QUERY     (0)
#define RECORD_PROP_WITH_CNAME      (1)
#define RECORD_PROP_WILDCARD        (2)
#define RECORD_PROP_UPDATE          (3)
#define RECORD_PROP_ROUND_ROBIN     (4)

#define RECORD_PROP_TERMINATOR      (0xff)


//
//  Updateable type
//
//  DEVNOTE: not using update table
//

#define IS_DYNAMIC_UPDATE_TYPE(wType)   ((wType) < DNS_TYPE_TSIG)

#define IS_SPECIAL_UPDATE_TYPE(wType)   \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_CNAME   ||  \
            (wType) == DNS_TYPE_SOA     )

//
//  Check if type Wildcard applicable
//      - since we MUST always check before sending NAME_ERROR
//      there's no point in not checking all types even those
//      unwildcardable

#define IS_WILDCARD_TYPE(wType)     (TRUE)


//
//  Check if CNAME able type.
//
//  Optimize the property lookups for type A.
//

#define IS_ALLOWED_WITH_CNAME_TYPE(wType) \
            RecordTypePropertyTable       \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_WITH_CNAME ]

//  anything allowed to be at CNAME node -- same as above + CNAME type

#define IS_ALLOWED_AT_CNAME_NODE_TYPE(wType)    \
            ( (wType) == DNS_TYPE_CNAME   ||    \
            RecordTypePropertyTable             \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_WITH_CNAME ] )

//  Follow CNAME on query (optimize for type A)

#define IS_CNAME_REPLACEABLE_TYPE(wType) \
            ( (wType) == DNS_TYPE_A     ||      \
            RecordTypePropertyTable             \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_CNAME_QUERY ] )

//
//  Round-robin types.
//

#define IS_ROUND_ROBIN_TYPE( wType )            \
            ( RecordTypePropertyTable           \
                [ INDEX_FOR_QUERY_TYPE( wType ) ][ RECORD_PROP_ROUND_ROBIN ] )


//
//  Glue types
//

#define IS_GLUE_TYPE(wType)  \
        (   (wType) == DNS_TYPE_A   ||  \
            (wType) == DNS_TYPE_NS  ||  \
            (wType) == DNS_TYPE_AAAA    )

#define IS_ROOT_HINT_TYPE(type)     IS_GLUE_TYPE(type)

#define IS_GLUE_ADDRESS_TYPE(wType)  \
        (   (wType) == DNS_TYPE_A   ||  \
            (wType) == DNS_TYPE_AAAA  )

//
//  Generating additional query types
//

#define IS_NON_ADDITIONAL_GENERATING_TYPE(wType) \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_PTR     ||  \
            (wType) == DNS_TYPE_AAAA    )


//
//  Valid authority section types
//

#define IS_AUTHORITY_SECTION_TYPE(wType)    \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_SOA     ||  \
            (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_NXT )

//
//  Valid additional section types
//

#define IS_ADDITIONAL_SECTION_TYPE(wType)   \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_OPT )

//
//  Subzone valid types
//      - for load or update
//

#define IS_SUBZONE_TYPE(wType) \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     )

#define IS_UPDATE_IN_SUBZONE_TYPE(wType) \
        IS_SUBZONE_TYPE(wType)

#define IS_SUBZONE_OR_DELEGATION_TYPE(wType) \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     )

#define IS_UPDATE_AT_DELEGATION_TYPE(wType) \
        IS_SUBZONE_OR_DELEGATION_TYPE(wType)

//
//  DNSSEC type
//

#define IS_DNSSEC_TYPE(wType)               \
        (   (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_NXT     )

//
//  Non-scavenging types
//

#define IS_NON_SCAVENGE_TYPE(wType) \
        (   (wType) != DNS_TYPE_A       &&  \
          ( (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_SOA     ||  \
            IS_WINS_TYPE(wType) ) )


//
//  Check for compound types
//
//  Note when RRs exist with the high byte set, these must be looked
//  at carefully to insure validity.
//

#define IS_COMPOUND_TYPE(wType) \
        ( (wType) >= DNS_TYPE_TKEY && (wType) <= DNS_TYPE_ALL )

#define IS_COMPOUND_TYPE_EXCEPT_ANY(wType) \
        ( (wType) >= DNS_TYPE_TKEY && (wType) <= DNS_TYPE_MAILA )


//
//  WINS record tests
//

#define IS_WINS_RR(pRR)             IS_WINS_TYPE( (pRR)->wType )

#define IS_WINS_RR_LOCAL(pRR)       (!!((pRR)->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL))

#define IS_WINS_RR_AND_LOCAL(pRR)   (IS_WINS_RR(pRR) && IS_WINS_RR_LOCAL(pRR))


//
//  Record enumeration flags on RPC calls
//
//  Note, this is not record selection flags, those
//  are in dnsrpc.h.
//

#define ENUM_DOMAIN_ROOT    (0x80000000)
#define ENUM_NAME_FULL      (0x40000000)
#define ENUM_GLUE           (0x20000000)
#define ENUM_FOR_NT4        (0x10000000)


//
//  Limit lookup\caching of CNAME chains
//

#define CNAME_CHAIN_LIMIT (8)

//
//  Quick reverse record property lookup
//

extern DWORD  RecordTypeCombinedPropertyTable[];
#define REVERSE_TABLE   (RecordTypeCombinedPropertyTable)

extern DWORD  RecordTypeReverseCombinedPropertyTable[];
#define REVERSE_COMBINED_DATA   (RecordTypeReverseCombinedPropertyTable)


//
//  Resource record macro
//

#define SIZEOF_COMPRESSED_NAME_AND_DB_RECORD        \
            (sizeof(WORD) + sizeof(DNS_WIRE_RECORD)


//
//  Address record with compressed name
//  An extremely useful special case.
//

#include <packon.h>
typedef struct _DNS_COMPRESSED_A_RECORD
{
    WORD                wCompressedName;
    WORD                wType;
    WORD                wClass;
    DWORD               dwTtl;
    WORD                wDataLength;
    IP_ADDRESS          ipAddress;
}
DNS_COMPRESSED_A_RECORD, *PDNS_COMPRESSED_A_RECORD;
#include <packoff.h>


#define SIZEOF_COMPRESSED_A_RECORD  (sizof(DNS_COMPRESSED_A_RECORD))

#define NET_BYTE_ORDER_A_RECORD_DATA_LENGTH (0x0400)


//
//  Default SOA values
//

#define DEFAULT_SOA_SERIAL_NO       1
#define DEFAULT_SOA_REFRESH         900     // 15 minutes
#define DEFAULT_SOA_RETRY           600     // ten minutes
#define DEFAULT_SOA_EXPIRE          86400   // one day
#define DEFAULT_SOA_MIN_TTL         3600    // one hour

//
//  SOA version retrieval from wire record.
//  Another useful special case.
//

#define SOA_VERSION_OF_PREVIOUS_RECORD( pch ) \
            FlipUnalignedDword((pch) - SIZEOF_SOA_FIXED_DATA)


#endif // _RRECORD_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\record.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    record.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle resource records (RR).

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Default SOA values
//

#define DEFAULT_SOA_SERIAL_NO       1
#define DEFAULT_SOA_REFRESH         900     // 15 minutes
#define DEFAULT_SOA_RETRY           600     // ten minutes
#define DEFAULT_SOA_EXPIRE          86400   // one day
#define DEFAULT_SOA_MIN_TTL         3600    // one hour

#define DNS_DEFAULT_SOA_ADMIN_NAME  "hostmaster"


//
//  Record type properties table
//
//  Properties outer subscript:
//      0 - cnameable query type
//      1 - allowed with cname type
//      2 - wildcardable type
//      3 - slow free
//
//
//  CNAME query rule:
//      Everything but ALL, XFR or CNAME queries and any of
//      of the record types that we allow to live at nodes with CNAME
//      ... NS, SOA, SIG, KEY, WINS, WINSR
//
//  Allowed with CNAME rule:
//      Only security types on all records (SIG, KEY) and
//      zone root types (NS, SOA, WINS, WINSR)
//
//  Wildcard rule:
//      Don't wildcard
//          - specific address (A, AAAA, etc.?)
//          - zone root (SOA, NS, WINS, WINSR)
//          - node security records
//      everything else ok.
//      (some mail programs use ALL to query so strangely allow wildcarding ALL)
//
//  Update rule:
//      0 -- query type, no updates
//      1 -- type updateable
//      2 -- type updateable, but requires special handling (NS, SOA, CNAME need flag reset)
//
//  Round robin rule:
//      Jiggle nodes in list after each query to cycle results. By default
//      all types are round-robined, but registry settings can turn off
//      individual types.
//

UCHAR  RecordTypePropertyTable[][5] =
{
//  CNAMEable   at CNAME    wildcard    update      robin
//  ---------   --------    --------    ------      -----
    1,          0,          0,          0,          0,      //  ZERO
    1,          0,          0,          1,          1,      //  A
    1,          1,          0,          2,          1,      //  NS
    1,          0,          1,          1,          1,      //  MD
    1,          0,          1,          1,          1,      //  MF
    0,          0,          0,          2,          1,      //  CNAME
    1,          1,          0,          2,          1,      //  SOA
    1,          0,          1,          1,          1,      //  MB
    1,          0,          1,          1,          1,      //  MG
    1,          0,          1,          1,          1,      //  MR
    1,          0,          1,          1,          1,      //  NULL
    1,          0,          1,          1,          1,      //  WKS
    1,          0,          1,          1,          1,      //  PTR
    1,          0,          1,          1,          1,      //  HINFO
    1,          0,          1,          1,          1,      //  MINFO
    1,          0,          1,          1,          1,      //  MX
    1,          0,          1,          1,          1,      //  TEXT
    1,          0,          1,          1,          1,      //  RP
    1,          0,          1,          1,          1,      //  AFSDB
    1,          0,          1,          1,          1,      //  X25
    1,          0,          1,          1,          1,      //  ISDN
    1,          0,          1,          1,          1,      //  RT
    1,          0,          1,          1,          1,      //  NSAP
    1,          0,          1,          1,          1,      //  NSAPPTR
    0,          1,          0,          0,          1,      //  SIG
    0,          1,          0,          1,          1,      //  KEY
    1,          0,          1,          1,          1,      //  PX
    1,          0,          1,          1,          1,      //  GPOS
    1,          0,          0,          1,          1,      //  AAAA
    1,          0,          1,          1,          1,      //  LOC
    0,          1,          0,          1,          1,      //  NXT
    1,          0,          1,          1,          1,      //  31
    1,          0,          1,          1,          1,      //  32
    1,          0,          1,          1,          1,      //  SRV
    1,          0,          1,          1,          1,      //  ATMA
    1,          0,          1,          1,          1,      //  35
    1,          0,          1,          1,          1,      //  36
    1,          0,          1,          1,          1,      //  37
    1,          0,          1,          1,          1,      //  A6
    1,          0,          1,          1,          1,      //  DNAME
    1,          0,          1,          1,          1,      //  40
    1,          0,          1,          1,          0,      //  OPT
    1,          0,          1,          1,          1,      //  42
    1,          0,          1,          1,          1,      //  43
    1,          0,          1,          1,          1,      //  44
    1,          0,          1,          1,          1,      //  45
    1,          0,          1,          1,          1,      //  46
    1,          0,          1,          1,          1,      //  47
    1,          0,          1,          1,          1,      //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as DNSSRV_MAX_SELF_INDEXED_TYPE defined in record.h
    //         (see note above in record info table)

    //  WINS types

    0,          1,          0,          0,          0,      //  WINS
    0,          1,          0,          0,          0,      //  WINSR

    //  compound query types
    //      - don't follow CNAMEs
    //      - can't exist as records period
    //      - mail box and ALL do follow wildcard
    //      - no updates allowed

    0,          0,          0,          0,          0,      //  DNS_TYPE_TKEY   (249)
    0,          0,          0,          0,          0,      //  DNS_TYPE_TSIG
    0,          0,          0,          0,          0,      //  DNS_TYPE_IXFR
    0,          0,          0,          0,          0,      //  DNS_TYPE_AXFR
    0,          0,          1,          0,          0,      //  DNS_TYPE_MAILB
    0,          0,          1,          0,          0,      //  DNS_TYPE_MAILA
    0,          0,          1,          0,          0,      //  DNS_TYPE_ALL    (255)

    //  terminator element for iteration

    0xff,       0xff,       0xff,       0xff,       0xff
};


//
//  Slow free for NS and SOA
//      - NS just added protection on recurse, delegation walking
//      - SOA as PTR is outstanding
//
//  Note:  if change this to allow substantial SLOW frees, them MUST
//          change timeout thread to run cleanup more frequently
//
//  DEVNOTE:  alternative to RR lock or slow everything on fast thread, IS
//      to actually determine safe frees (XFR tree, COPY_RR, etc.), but
//      ultimately if A records not safe, then must have some faster
//      SLOW_FREE turnaround
//

#define DO_SLOW_FREE_ON_RR(pRR)     ((pRR)->wType == DNS_TYPE_NS || \
                                     (pRR)->wType == DNS_TYPE_SOA)




WORD
FASTCALL
QueryIndexForType(
    IN      WORD    wType
    )
/*++

Routine Description:

    Return index for non-self indexed types.
    Includes both WINS and compound (query only) types.

Arguments:

    wType -- type to index

Return Value:

    Index of type.
    0 for unknown type.

--*/
{
    //  if not self-indexed
    //      - compound (type ALL) next most likely
    //      - then WINS
    //      - unknown gets type zero

    if ( wType > DNSSRV_MAX_SELF_INDEXED_TYPE )
    {
        if ( wType <= DNS_TYPE_ALL )
        {
            if ( wType >= DNS_TYPE_TKEY )
            {
                wType -= DNSSRV_OFFSET_TO_COMPOUND_TYPE_INDEX;
            }
            else    //  unknown type < 255
            {
                wType = 0;
            }
        }
        else if ( wType == DNS_TYPE_WINS || wType == DNS_TYPE_WINSR )
        {
            wType -= DNSSRV_OFFSET_TO_WINS_TYPE_INDEX;
        }
        else    // unknown type > 255
        {
            wType = 0;
        }
    }
    return( wType );
}



WORD
FASTCALL
RR_IndexForType(
    IN      WORD    wType
    )
/*++

Routine Description:

    Return index for non-self indexed RECORD types.
    Same as above except without the query only types.

Arguments:

    wType -- type to index

Return Value:

    Index of type.
    0 for unknown type.

--*/
{
    //  if not self-indexed
    //      - check WINS
    //      - unknown gets type zero

    if ( wType > DNSSRV_MAX_SELF_INDEXED_TYPE )
    {
        if ( wType == DNS_TYPE_WINS || wType == DNS_TYPE_WINSR )
        {
            wType -= DNSSRV_OFFSET_TO_WINS_TYPE_INDEX;
        }
        else    // unknown type
        {
            wType = 0;
        }
    }
    return( wType );
}



PDB_RECORD
RR_Copy(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Create copy of record.

    Note:  the copy is NOT a valid copy with valid references to data nodes
            it should NOT be enlisted and data references may expire one
            timeout interval past creation, so should be used only during
            single packet manipulation

    Note:  if we want more permanent record, then simply bump reference
            count of nodes referenced, and allow normal cleanup

Arguments:

    pRR - ptr to resource record

    Flag - currently unused;  later may be used to indicate record
        should properly reference desired nodes

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;

    prr = RR_AllocateEx( pRR->wDataLength, MEMTAG_RECORD_COPY );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    RtlCopyMemory(
        prr,
        pRR,
        (INT)pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART );

    //  reset source tag in record

    prr->pRRNext = NULL;

    return prr;
}


//
//  Record allocation will use standard alloc lock.
//  This allows us to avoid taking lock twice.
//

#define RR_ALLOC_LOCK()     STANDARD_ALLOC_LOCK()
#define RR_ALLOC_UNLOCK()   STANDARD_ALLOC_UNLOCK()



PDB_RECORD
RR_AllocateEx(
    IN      WORD            wDataLength,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Allocate a resource record.

    This keeps us from needing to hit heap, for common RR operations,
    AND saves overhead of heap fields on each RR.

Arguments:

    None.

Return Value:

    Ptr to new RR, if successful.
    NULL otherwise.

--*/
{
    PDB_RECORD  pRR;
    PDB_RECORD  pRRNext;
    DWORD       dwAllocSize;
    INT         i;
    DWORD       length;

    //  some allocs will come down with tag undetermined

    if ( MemTag == 0 )
    {
        MemTag = MEMTAG_RECORD_UNKNOWN;
    }

    //
    //  detemine actual allocation length
    //

    length = wDataLength + SIZEOF_DBASE_RR_FIXED_PART;

    pRR = ALLOC_TAGHEAP( length, MemTag );
    IF_NOMEM( !pRR )
    {
        return NULL;
    }

    STAT_INC( RecordStats.Used );
    STAT_INC( RecordStats.InUse );
    STAT_ADD( RecordStats.Memory, length );

    //
    //  set basic fields
    //      - clear RR header
    //      - set datalength
    //      - set source tag
    //

    RtlZeroMemory(
        pRR,
        SIZEOF_DBASE_RR_FIXED_PART );

    pRR->wDataLength = wDataLength;

    //  DEVNOTE: track difference between standard and heap allocs

    pRR->Reserved.StandardAlloc = (BYTE) Mem_IsStandardBlockLength(length);

    return pRR;
}



VOID
RR_Free(
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Free a record.
    Standard sized RRs are returned to a free list for reuse.
    Non-standard sized RRs are returned to the heap.

Arguments:

    pRR -- RR to free.

Return Value:

    None.

--*/
{
    DWORD   length;

    if ( !pRR )
    {
        return;
    }

    ASSERT( Mem_HeapMemoryValidate( pRR ) );

    DNS_DEBUG( UPDATE, (
        "Free RR at %p, memtag = %d\n",
        pRR,
        Mem_GetTag(pRR) ));

    //  special hack to catch bogus record free's
    //  this fires when record that's been queued for slow free, is freed
    //  by someone other than slow free execution routine

    IF_DEBUG( ANY )
    {
        if ( IS_SLOW_FREE_RR(pRR) && !IS_SLOWFREE_RANK(pRR) )
        {
            Dbg_DbaseRecord(
                "Bad invalid free of slow-free record!",
                pRR );
            ASSERT( FALSE );
        }
    }
    //ASSERT( !IS_SLOW_FREE_RR(pRR) || IS_SLOWFREE_RANK(pRR) );

    //
    //  nail down WINS free issues
    //

    IF_DEBUG( WINS )
    {
        if ( IS_WINS_RR(pRR) )
        {
            Dbg_DbaseRecord(
                "WINS record in RR_Free()",
                pRR );
            DNS_PRINT((
                "RR_Free on WINS record at %p\n",
                pRR ));
        }
    }

    //  verify NOT previously freed record
    //  don't want anything in free list twice

    if ( IS_ON_FREE_LIST(pRR) )
    {
        ASSERT( FALSE );
        Dbg_DbaseRecord(
            "ERROR:  RR is previously freed block !!!",
            pRR );
        ASSERT( FALSE );
        return;
    }

    if ( DO_SLOW_FREE_ON_RR(pRR)  &&  !IS_SLOW_FREE_RR(pRR) )
    {
        SET_SLOW_FREE_RR(pRR);
        Timeout_FreeWithFunction( pRR, RR_Free );
        STAT_INC( RecordStats.SlowFreeQueued );
        return;
    }

    //  track RRs returned

    if ( IS_CACHE_RR(pRR) )
    {
        STAT_DEC( RecordStats.CacheCurrent );
        STAT_INC( RecordStats.CacheTimeouts );
    }

    if ( IS_SLOW_FREE_RR(pRR) )
    {
        STAT_INC( RecordStats.SlowFreeFinished );
    }

    //  free
    //
    //  DEVNOTE: could have a check that blob is some type of record
    //

    length = pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART;

    HARD_ASSERT( Mem_IsStandardBlockLength(length) == pRR->Reserved.StandardAlloc );

    //FREE_TAGHEAP( pRR, length, MEMTAG_RECORD+pRR->Reserved.Source );
    FREE_TAGHEAP( pRR, length, 0 );

    STAT_INC( RecordStats.Return );
    STAT_DEC( RecordStats.InUse );
    STAT_SUB( RecordStats.Memory, length );
}



BOOL
RR_Validate(
    IN      PDB_RECORD      pRR,
    IN      BOOL            fActive,
    IN      WORD            wType,
    IN      DWORD           dwSource
    )
/*++

Routine Description:

    Validate a record.

Arguments:

    pRR     -- RR to validate

    fActive -- not in free list

    wType   -- of a particular type

    dwSource -- expected source

Return Value:

    TRUE if valid record.
    FALSE on error.

--*/
{
    if ( !pRR )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    //  Note: Record type validation not actually done,
    //      as this is sometimes called in update code on pAddRR which is
    //      actual enlisted ptr
    //

    //
    //  verify pRR memory
    //      - valid heap
    //      - RECORD tag
    //      - adequate length
    //      - not on free list
    //

    if ( ! Mem_VerifyHeapBlock(
                pRR,
                0,
                //MEMTAG_RECORD + pRR->Reserved.Source,
                pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART ) )
    {
        DNS_PRINT((
            "\nERROR:  Record at %p, failed mem check!!!\n",
            pRR ));
        ASSERT( FALSE );
        return FALSE;
    }

    //
    //  if active, then not on slow free list
    //

    if ( fActive )
    {
        if ( IS_SLOW_FREE_RR(pRR) )
        {
            Dbg_DbaseRecord(
                "Bad invalid free of slow-free record!",
                pRR );
            ASSERT( FALSE );
            return FALSE;
        }
    }

    //  verify NOT previously freed record
    //  don't want anything in free list twice

    if ( IS_ON_FREE_LIST(pRR) )
    {
        Dbg_DbaseRecord(
            "ERROR:  RR is previously freed block !!!",
            pRR );
        ASSERT( FALSE );
        return FALSE;
    }

#if 0
    //
    //  source tracking
    //

    if ( dwSource && (dwSource != pRR->Reserved.Source) )
    {
        DNS_PRINT((
            "\nERROR:  Record at %p, failed source (%d) check!!!\n",
            pRR,
            dwSource ));
        ASSERT( FALSE );
        return FALSE;
    }
#endif

    return TRUE;
}



VOID
RR_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic record counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



ULONGLONG
RR_SetTypeInBitmask(
    IN      ULONGLONG       TypeBitmask,
    IN      WORD            wType
    )
/*++

Routine Description:

    Set bit in bitmask corresponding to type.

Arguments:

    TypeBitmask -- type bitmask

    wType - type

Return Value:

    None

--*/
{
    if ( wType < 63 )
    {
        return TypeBitmask | ( ( ULONGLONG )1 << wType );
    }

    return TypeBitmask | OTHERTYPE_BITMASK_BIT;
}



RR_GENERIC_DISPATCH_FUNCTION
RR_DispatchFunctionForType(
    IN      RR_GENERIC_DISPATCH_TABLE   pTable,
    IN      WORD                        wType
    )
/*++

Routine Description:

    Generic RR dispatch function finder.

Arguments:

Return Value:

    Ptr to dispatch function.
    NULL when not found and default not available.

--*/
{
    RR_GENERIC_DISPATCH_FUNCTION    pfn;
    WORD                            index;

    //
    //  dispatch RR functions
    //      - find in table
    //      - if NO table entry OR index outside table => use default in index 0
    //

    index = INDEX_FOR_TYPE( wType );
    ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( index )
    {
        pfn = pTable[ index ];
    }
    else
    {
        DNS_DEBUG( READ, (
            "WARNING:  Dispatch of unknown record type %d.\n",
            wType ));
        pfn = NULL;
    }

    if ( !pfn )
    {
        pfn = pTable[0];
    }

    return pfn;
}



//
//  Create common types
//

PDB_RECORD
RR_CreateARecord(
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwTtl,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create A record.

Arguments:

    ipAddress -- IP address for record

    dwTtl -- TTL to set

Return Value:

    Ptr to new A record -- if successful
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate A record
    //

    prr = RR_AllocateEx( ( WORD ) SIZEOF_IP_ADDRESS, MemTag );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    prr->wType = DNS_TYPE_A;
    prr->dwTtlSeconds = dwTtl;
    prr->dwTimeStamp = 0;
    prr->Data.A.ipAddress = ipAddress;

    return prr;
}



PDB_RECORD
RR_CreatePtr(
    IN      PDB_NAME        pNameTarget,
    IN      LPSTR           pszTarget,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create new PTR-compatible record.
    Includes PTR, NS, CNAME or other single indirection types.

    For use in default zone create.

Arguments:

    pszTarget -- target name for record

    wType -- type to create

    dwTtl -- TTL

Return Value:

    Ptr to new SOA record.
    NULL on failure.

--*/
{
    PDB_RECORD      prr;
    DNS_STATUS      status;
    COUNT_NAME      nameTarget;

    DNS_DEBUG( INIT, (
        "RR_CreatePtr()\n"
        "\tpszTarget = %s\n"
        "\twType     = %d\n",
        pszTarget,
        wType ));

    //
    //  create dbase name for host name
    //

    if ( !pNameTarget )
    {
        status = Name_ConvertFileNameToCountName(
                    & nameTarget,
                    pszTarget,
                    0 );
        if ( status == ERROR_INVALID_NAME )
        {
            ASSERT( FALSE );
            return NULL;
        }
        pNameTarget = &nameTarget;
    }

    //
    //  allocate record
    //

    prr = RR_AllocateEx(
                (WORD) Name_LengthDbaseNameFromCountName(pNameTarget),
                MemTag );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //  set header fields
    //      - zone TTL for all auto-create NS, PTR records

    prr->wType = wType;
    prr->dwTtlSeconds = dwTtl;
    prr->dwTimeStamp = 0;

    SET_ZONE_TTL_RR( prr );

    //  copy in target name

    Name_CopyCountNameToDbaseName(
        & prr->Data.PTR.nameTarget,
        pNameTarget );

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Self-created PTR compatible record:",
            prr );
    }
    return prr;
}



PDB_RECORD
RR_CreateSoa(
    IN      PDB_RECORD      pExistingSoa,   OPTIONAL
    IN      PDB_NAME        pNameAdmin,
    IN      LPSTR           pszAdmin
    )
/*++

Routine Description:

    Create new SOA.

    For use in default create
        - default zone create of primary by admin
        - default reverse lookup zones
        - default when missing SOA
    And for use overwriting SOA on DS primary.

Arguments:

    pExistingSoa -- existing SOA to use of numeric values, otherwise, using defaults

    pNameAdmin  -- admin name in database format

    pszAdmin    -- admin name in string format

Return Value:

    Ptr to new SOA record.
    NULL on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NAME        pname;
    DB_NAME         namePrimary;
    DB_NAME         nameAdmin;
    DB_NAME         nameDomain;

    PCHAR           pszserverName;
    INT             serverNameLen;
    INT             adminNameLen;
    PCHAR           pszdomainName;
    INT             domainNameLen;
    PBYTE           precordEnd;
    PDB_RECORD      prr;


    DNS_DEBUG( INIT, (
        "RR_CreateSoa()\n"
        "\tpExistingSoa = %p\n"
        "\tpszAdmin     = %s\n",
        pExistingSoa,
        pszAdmin ));

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Existing SOA:",
            pExistingSoa );
    }

    //
    //  admin name
    //      - if given as dbase name, use it
    //      - if given existing SOA, use it
    //      - finally build own
    //          - use <AdminEmailName>.<ServerDomainName>
    //          - default admin name if not given
    //

    if ( pNameAdmin )
    {
        // no-op
    }
    else if ( pExistingSoa )
    {
        pNameAdmin = & pExistingSoa->Data.SOA.namePrimaryServer;
        pNameAdmin = Name_SkipDbaseName( pNameAdmin );
    }
    else
    {
        if ( !pszAdmin )
        {
            pszAdmin = DNS_DEFAULT_SOA_ADMIN_NAME;
        }
        Name_ClearDbaseName( &nameAdmin );

        status = Name_AppendDottedNameToDbaseName(
                    & nameAdmin,
                    pszAdmin,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return NULL;
        }

        //  append dbase name

        status = Name_AppendDottedNameToDbaseName(
                    & nameAdmin,
                    Dns_GetDomainName( SrvCfg_pszServerName ),
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return NULL;
        }

        pNameAdmin = &nameAdmin;
    }

    //
    //  allocate record
    //      - always AUTO-created
    //

    prr = RR_AllocateEx(
                (WORD) ( SIZEOF_SOA_FIXED_DATA +
                        Name_LengthDbaseNameFromCountName(&g_ServerDbaseName) +
                        Name_LengthDbaseNameFromCountName(pNameAdmin) ),
                MEMTAG_RECORD_AUTO );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  fixed fields
    //      - copy if previous SOA
    //      - otherwise default
    //

    if ( pExistingSoa )
    {
        prr->Data.SOA.dwSerialNo    = pExistingSoa->Data.SOA.dwSerialNo;
        prr->Data.SOA.dwRefresh     = pExistingSoa->Data.SOA.dwRefresh;
        prr->Data.SOA.dwRetry       = pExistingSoa->Data.SOA.dwRetry;
        prr->Data.SOA.dwExpire      = pExistingSoa->Data.SOA.dwExpire;
        prr->Data.SOA.dwMinimumTtl  = pExistingSoa->Data.SOA.dwMinimumTtl;
    }
    else
    {
        prr->Data.SOA.dwSerialNo    = htonl( DEFAULT_SOA_SERIAL_NO );
        prr->Data.SOA.dwRefresh     = htonl( DEFAULT_SOA_REFRESH );
        prr->Data.SOA.dwRetry       = htonl( DEFAULT_SOA_RETRY );
        prr->Data.SOA.dwExpire      = htonl( DEFAULT_SOA_EXPIRE );
        prr->Data.SOA.dwMinimumTtl  = htonl( DEFAULT_SOA_MIN_TTL );
    }

    //  fill in header
    //      - zone TTL for all auto-created SOAs

    prr->wType = DNS_TYPE_SOA;
    RR_RANK( prr ) = RANK_ZONE;
    prr->dwTtlSeconds = prr->Data.SOA.dwMinimumTtl;
    prr->dwTimeStamp = 0;

    SET_ZONE_TTL_RR( prr );

    //
    //  write names to new record
    //      - primary server name
    //      - zone admin name
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        &g_ServerDbaseName );

    pname = Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        pNameAdmin );

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Self-created SOA:",
            prr );
    }
    return prr;
}

//
//  End record.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\registry.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Domain Name System (DNS) Server

    DNS Registry definitions.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/

#ifndef _DNS_REGISTRY_INCLUDED_
#define _DNS_REGISTRY_INCLUDED_


//
//  Registry types
//
//  There are a few types of objects DNS reads\writes from registry:
//      DWORDS
//      IP arrays (stored as strings)
//      file (or directory) names
//      DNS names (meaning UTF8 string)
//
//  The registry API insist on distorting UTF8 data if written\read through
//  ANSI API.  Essentially they try for "best ANSI" match, rather than just
//  returning the binary data.  This requires that anything that can contain
//  extended characters MUST be written\read in unicode.
//
//  However, DNS property types are in ANSI.  And IP strings reads are easiest
//  to handle if kept in ANSI for simply processing to\from IP array.
//
//  Furthermore, we need a way to specify final type (UTF8 or unicode) of
//  string data.  General paradigm is to keep file name data in unicode for
//  use by system, but DNS name data converted to UTF8 for use by database.
//

#define DNS_REG_SZ_ANSI         (REG_SZ)
#define DNS_REG_EXPAND_WSZ      (0xf0000000 | REG_EXPAND_SZ)
#define DNS_REG_WSZ             (0xf0000000 | REG_SZ)
#define DNS_REG_UTF8            (0xff000000 | REG_SZ)

#define DNS_REG_TYPE_UNICODE( type )        ( (type) & 0xf0000000 )

#define REG_TYPE_FROM_DNS_REGTYPE( type )   ( (type) & 0x0000ffff )


//
//  Unicode versions of regkeys that require unicode read\write
//

#define DNS_REGKEY_ZONE_FILE_PRIVATE            ((LPSTR)TEXT(DNS_REGKEY_ZONE_FILE))
#define DNS_REGKEY_DATABASE_DIRECTORY_PRIVATE   ((LPSTR)TEXT(DNS_REGKEY_DATABASE_DIRECTORY))
#define DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE      ((LPSTR)TEXT(DNS_REGKEY_ROOT_HINTS_FILE))
#define DNS_REGKEY_LOG_FILE_PATH_PRIVATE        ((LPSTR)TEXT(DNS_REGKEY_LOG_FILE_PATH))
#define DNS_REGKEY_SERVER_PLUGIN_PRIVATE        ((LPSTR)TEXT(DNS_REGKEY_SERVER_PLUGIN))
#define DNS_REGKEY_BOOT_FILENAME_PRIVATE        ((LPSTR)TEXT(DNS_REGKEY_BOOT_FILENAME))
#define DNS_REGKEY_NO_ROUND_ROBIN_PRIVATE       ((LPSTR)TEXT(DNS_REGKEY_NO_ROUND_ROBIN))
#define DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE_PRIVATE    ((LPSTR)TEXT(DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE))
//
//  DNS Registry global
//
//  Indicates when writing parameters back to registry.  This should
//  be TRUE in all cases, except when booting from registry itself.
//

extern BOOL g_bRegistryWriteBack;


//
//  DNS registry key names
//
//  Note, exposed server\zone property names are given in DNS RPC header
//  (dnsrpc.h).  These property names are the registry key names.
//

//  Name for cache file zone

#define DNS_REGKEY_CACHE_ZONE               "CacheFile"

//
//  Private zone regkeys
//

//  DC Promo transitional zones

#define DNS_REGKEY_ZONE_DCPROMO_CONVERT     "DcPromoConvert"

//  Retired zone key for delete only

#define DNS_REGKEY_ZONE_USE_DBASE           "UseDatabase"

//  For versioning DS integrated zones

#define DNS_REGKEY_ZONE_VERSION             "SoaVersion"


//
//  Basic DNS registry operations (registry.c)
//

#define DNS_REGSOURCE_CCS       0       //  CurrentControlSet
#define DNS_REGSOURCE_SW        1       //  Software

//
//  Registry operation flags
//

#define DNS_REG_IMPERSONATING   ZONE_CREATE_IMPERSONATING   //  thread is impersonating RPC client

VOID
Reg_Init(
    VOID
    );

DWORD
Reg_GetZonesSource(
    VOID                        // returns one of DNS_REGSOURCE_XXX
    );

DWORD
Reg_SetZonesSource(
    DWORD       newSource       // one of DNS_REGSOURCE_XXX
    );

VOID
Reg_WriteZonesMovedMarker(
    VOID
    );

HKEY
Reg_OpenRoot(
    VOID
    );

HKEY
Reg_OpenParameters(
    VOID
    );

HKEY
Reg_OpenZones(
    VOID
    );

DNS_STATUS
Reg_EnumZones(
    IN OUT  PHKEY           phkeyZones,
    IN      DWORD           dwZoneIndex,
    OUT     PHKEY           phkeyZone,
    OUT     PWCHAR          pwchZoneNameBuf
    );

HKEY
Reg_OpenZone(
    IN      PWSTR           pwszZoneName,
    IN      HKEY            hZonesKey       OPTIONAL
    );

VOID
Reg_DeleteZone(
    IN      DWORD           dwFlags,
    IN      PWSTR           pwszZoneName
    );

DWORD
Reg_DeleteAllZones(
    VOID
    );

//
//  Registry write calls
//

DNS_STATUS
Reg_SetValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwType,
    IN      PVOID           pData,
    IN      DWORD           cbData
    );

DNS_STATUS
Reg_SetDwordValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwValue
    );

DNS_STATUS
Reg_SetAddrArray(
    IN      DWORD               dwFlags,        OPTIONAL
    IN      HKEY                hKey,           OPTIONAL
    IN      PZONE_INFO          pZone,          OPTIONAL
    IN      LPSTR               pszValueName,
    IN      PDNS_ADDR_ARRAY     pDnsAddrArray
    );

DNS_STATUS
Reg_DeleteValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    );

DNS_STATUS
Reg_DeleteKeySubtree(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,
    IN      PWSTR           pwsKeyName      OPTIONAL
    );

//
//  Registry read calls
//

DNS_STATUS
Reg_GetValue(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PVOID           pData,
    IN      PDWORD          pcbData
    );

PBYTE
Reg_GetValueAllocate(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PDWORD          pdwLength       OPTIONAL
    );

PDNS_ADDR_ARRAY
Reg_GetAddrArray(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    );

DNS_STATUS
Reg_ReadDwordValue(
    IN      HKEY            hKey,
    IN      PWSTR           pwsZoneName,    OPTIONAL
    IN      LPSTR           pszValueName,
    IN      BOOL            bByteResult,
    OUT     PVOID           pResult
    );

DNS_STATUS
Reg_AddPrincipalSecurity(
    IN      HKEY            hkey,
    IN      LPTSTR          pwsUser,
    IN      DWORD           dwAccessFlags   OPTIONAL
    );

LPSTR
Reg_AllocateExpandedString_A(
    IN      LPSTR           pszString
    );

PWSTR
Reg_AllocateExpandedString_W(
    IN      PWSTR           pwsString
    );

DNS_STATUS
Reg_ExtendRootAccess(
    VOID
    );

DNS_STATUS
Reg_ExtendZonesAccess(
    VOID
    );

#endif //   _DNS_REGISTRY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\registry.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Domain Name System (DNS) Server

    DNS registry operations.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include "dnssrv.h"
#include "sdutl.h"


#define MAX_MIGRATION_ZONE_COUNT    200


//
//  DNS registry handles
//

HKEY    hkeyDns;
HKEY    hkeyParameters;
HKEY    hKeyZones;
HKEY    hKeyCache;


//
//  DNS registry class
//

#define DNS_REGISTRY_CLASS          TEXT("DnsRegistryClass")
#define DNS_REGISTRY_CLASS_SIZE     sizeof(DNS_REGISTRY_CLASS)

#define DNS_REGISTRY_CLASS_WIDE         NULL
#define DNS_REGISTRY_CLASS_SIZE_WIDE    NULL


//
//  DNS registry constants
//

#define DNS_BASE_CCS    TEXT( "SYSTEM\\CurrentControlSet\\Services\\DNS" )
#define DNS_BASE_SW     TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\DNS Server" )

#define DNS_REGKEY_ROOT         ( DNS_BASE_CCS )
#define DNS_REGKEY_PARAMETERS   ( DNS_BASE_CCS  TEXT( "\\Parameters" ) )
#define DNS_REGKEY_ZONES_CCS    ( DNS_BASE_CCS  TEXT( "\\Zones" ) )
#define DNS_REGKEY_ZONES_SW     ( DNS_BASE_SW   TEXT( "\\Zones" ) )

#define DNS_REGKEY_ZONES() \
    ( g_ZonesRegistrySource == DNS_REGSOURCE_SW ? \
        DNS_REGKEY_ZONES_SW : DNS_REGKEY_ZONES_CCS )

#define DBG_REG_SOURCE_STRING( x ) \
    ( ( x ) == DNS_REGSOURCE_SW ? "Software" : "CurrentControlSet" )

#define DNS_ZONES_KEY_MOVED_MSG     ( TEXT( "moved to HKLM\\" ) DNS_BASE_SW )


//
//  DNS Registry global
//
//  Indicates when writing parameters back to registry.  This should
//  be TRUE in all cases, except when booting from registry itself.
//

BOOL    g_bRegistryWriteBack = TRUE;
DWORD   g_ZonesRegistrySource = 0;      // DNS_REGSOURCE_XXX constant



//
//  Registry utils
//

DWORD
Reg_LengthOfMultiSzW(
    IN      PWSTR           pwMultiSz
    )
/*++

Routine Description:

    Determine length (in bytes) of REG_MULTI_SZ string.

Arguments:

    pwMultiSz -- MULTI_SZ string to get length of

Return Value:

    Length in bytes of MULTI_SZ string.
    Length includes terminating 00 and is suitable for use with registry call.

--*/
{
    PWCHAR  pwch = pwMultiSz;
    WCHAR   wch;
    WCHAR   wchPrev = 1;

    //
    //  loop until 00 termination
    //

    while ( 1 )
    {
        wch = *pwch++;
        if ( wch != 0 )
        {
            wchPrev = wch;
            continue;
        }

        //  zero character
        //  if previous char zero, then terminate

        if ( wchPrev != 0 )
        {
            wchPrev = wch;
            continue;
        }
        break;
    }

    return (DWORD)(pwch - pwMultiSz) * 2;
}



BOOLEAN
Reg_KeyHasSubKeys(
    WCHAR *     pwsKeyName )
/*++

Routine Description:

    Returns TRUE if the specified key has children keys.

Arguments:

    pwsKeyName: name of key to check for subkeys

Return Value:

    TRUE if the key has subkeys exists.

--*/
{
    BOOLEAN     fHasKids = FALSE;
    HKEY        hKey = NULL;
    TCHAR       szKeyName[ 512 ];
    DWORD       dwKeyNameLen = sizeof( szKeyName ) / sizeof( TCHAR );

    ASSERT( pwsKeyName );

    RegOpenKeyW( HKEY_LOCAL_MACHINE, pwsKeyName, &hKey );
    if ( !hKey )
    {
        goto Done;
    }
    fHasKids = RegEnumKeyEx(
                    hKey,
                    0,
                    szKeyName,
                    &dwKeyNameLen,
                    0,
                    NULL,
                    0,
                    NULL ) == ERROR_SUCCESS;

    Done:
    if ( hKey )
    {
        RegCloseKey( hKey );
    }
    return fHasKids;
} // Reg_KeyHasSubKeys



//
//  DNS server specific registry functions
//

VOID
Reg_Init(
    VOID
    )
/*++

Routine Description:

    Call this function during initialization before any other registry
    calls are made.

    This function determines where the zones currently live in the
    registry (under CCS or under Software) and sets a global flag.

    In Whistler, if the zones are in CCS (because the system was upgraded
    to Whistler from W2K) we will force a zone migration to SW the first time
    a new zone is created. See zonelist.c, Zone_ListMigrateZones().

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Reg_Init" )

    HKEY        hKey = NULL;
    DNS_STATUS  status;
    BOOLEAN     fZonesInCCS, fZonesInSW;

    DNS_DEBUG( REGISTRY, (
        "%s: start\n", fn ));

    //
    //  Search the registry to determine where the zones live.
    //

    fZonesInCCS = Reg_KeyHasSubKeys( DNS_REGKEY_ZONES_CCS );
    fZonesInSW = Reg_KeyHasSubKeys( DNS_REGKEY_ZONES_SW );

    //
    //  If there are no zones assume this is a fresh install. Write the 
    //  "zones moved" marker to CCS so that admins will be able to find
    //  their zones in the new registry location under the Software key.
    //

    if ( !fZonesInCCS && !fZonesInSW )
    {
        Reg_WriteZonesMovedMarker();
        DNS_DEBUG( REGISTRY, (
            "%s: no zones found - writing \"zones moved\" marker\n", fn ));
    }

    //
    //  Handle error case where zones appear to exist in both places.
    //

    if ( fZonesInCCS && fZonesInSW )
    {
        //  ASSERT( !( fZonesInCCS && fZonesInSW ) );
        DNS_DEBUG( ANY, (
            "%s: zones found in both CurrentControlSet and Software!\n", fn ));
        g_ZonesRegistrySource = DNS_REGSOURCE_SW;
    }
    else
    {
        g_ZonesRegistrySource =
            fZonesInCCS ? DNS_REGSOURCE_CCS : DNS_REGSOURCE_SW;
    }

    //
    //  Done - the zones reg source global now contains the correct reg source
    //  to use when loading the zones from the registry.
    //

    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    DNS_DEBUG( REGISTRY, (
        "%s: finished - zones are in %s\n", fn,
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));
}   //  Reg_Init



DWORD
Reg_GetZonesSource(
    VOID
    )
/*++

Routine Description:

    Retrieves the current registry source for zones.

Arguments:

    None.

Return Value:

    DNS_REGSOURCE_XXX constant.

--*/
{
    DNS_DEBUG( REGISTRY, (
        "Reg_GetZonesSource: current source is %s\n",
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

    return g_ZonesRegistrySource;
}   //  Reg_GetZonesSource



DWORD
Reg_SetZonesSource(
    DWORD       newSource       // one of DNS_REGSOURCE_XXX
    )
/*++

Routine Description:

    Sets the registry source for zones.

Arguments:

    The new registry source for zones (DNS_REGSOURCE_XXX constant).

Return Value:

    The old registry source for zones (DNS_REGSOURCE_XXX constant).

--*/
{
    DWORD   oldSource = g_ZonesRegistrySource;

    ASSERT( oldSource == DNS_REGSOURCE_CCS || oldSource == DNS_REGSOURCE_SW );
    ASSERT( newSource == DNS_REGSOURCE_CCS || newSource == DNS_REGSOURCE_SW );

    g_ZonesRegistrySource = newSource;

    DNS_DEBUG( REGISTRY, (
        "Reg_SetZonesSource: switching from %s to %s\n",
        DBG_REG_SOURCE_STRING( oldSource ),
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

    return oldSource;
}   //  Reg_SetZonesSource



VOID
Reg_WriteZonesMovedMarker(
    VOID
    )
/*++

Routine Description:

    After successful zone migration from CurrentControlSet to Software,
    call this function to write a note for the administrator in CCS\Zones
    to redirect him to the new zones key.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   oldSource = Reg_SetZonesSource( DNS_REGSOURCE_CCS );

    HKEY    hZonesKey = Reg_OpenZones();

    if ( hZonesKey )
    {
        Reg_SetValue(
            0,                  //  flags
            hZonesKey,
            NULL,
            NULL,               //  default value for key
            DNS_REG_WSZ,        //  write this as a unicode string
            DNS_ZONES_KEY_MOVED_MSG,
            0 );
        RegCloseKey( hZonesKey );
    }
    else
    {
        DNS_DEBUG( REGISTRY, (
            "Reg_WriteZonesMovedMarker: failed to open CCS zones key\n" ));
    }

    Reg_SetZonesSource( oldSource );
}   //  Reg_WriteZonesMovedMarker



HKEY
Reg_OpenRoot(
   VOID
    )
/*++

Routine Description:

    Open or create DNS root key.

Arguments:

    None.

Return Value:

    DNS parameters registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyParam;
    DWORD       disposition;

    //
    //  open DNS parameters key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_ROOT,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyParam,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyExW() failed for opening DNS root key\n"
            "    status = %d\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        SetLastError( status );
        return NULL;
    }
    return hkeyParam;
}


HKEY
Reg_OpenParameters(
    VOID
    )
/*++

Routine Description:

    Open or create DNS parameters key.

Arguments:

    None.

Return Value:

    DNS parameters registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyParam;
    DWORD       disposition;

    //
    //  open DNS parameters key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_PARAMETERS,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyParam,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyExW() failed for opening parameters key\n"
            "    status = %d\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        return NULL;
    }
    return hkeyParam;
}



HKEY
Reg_OpenZones(
    VOID
    )
/*++

Routine Description:

    Open or create DNS "Zones" key.

Arguments:

    None.

Return Value:

    DNS zones registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyZones;
    DWORD       disposition;

    //
    //  open DNS zones key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_ZONES(),
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyZones,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyEx() failed for opening zones key\n"
            "    status = %d (under %s)\n",
            status,
            DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        return NULL;
    }
    return hkeyZones;
}



DNS_STATUS
Reg_EnumZones(
    IN OUT  PHKEY           phZonesKey,
    IN      DWORD           dwZoneIndex,
    OUT     PHKEY           phkeyThisZone,
    OUT     PWCHAR          pwZoneNameBuf
    )
/*++

Routine Description:

    Enumerate next zone.

Arguments:

    phZonesKey -- addr of Zones HKEY;  if hKey is zero, function opens
        Zones hKey and returns it in this value;  caller has responsibility
        to close Zones hKey after

    dwZoneIndex -- index of zone to enumerate;  zero on first call,
        increment for each subsequent call

    phkeyThisZone -- addr to set to zone HKEY

    pwZoneNameBuf -- buffer to receive zone name;  MUST be at least
        size of DNS_MAX_NAME_LENGTH

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    HKEY        hkeyZones;
    HKEY        hkeyThisZone;
    DNS_STATUS  status;
    DWORD       bufLength = DNS_MAX_NAME_LENGTH;

    ASSERT( phZonesKey != NULL );
    ASSERT( pwZoneNameBuf != NULL );
    ASSERT( phkeyThisZone != NULL );

    DNS_DEBUG( REGISTRY, (
        "Reg_EnumZones() with index = %d\n"
        "    ZonesKey = %p\n",
        dwZoneIndex,
        *phZonesKey ));

    //
    //  get zones key
    //

    hkeyZones = *phZonesKey;

    if ( !hkeyZones )
    {
        hkeyZones = Reg_OpenZones();
        if ( !hkeyZones )
        {
            return ERROR_OPEN_FAILED;
        }
        *phZonesKey = hkeyZones;
    }

    //
    //  enum indexed zone
    //

    status = RegEnumKeyEx(
                hkeyZones,
                dwZoneIndex,
                pwZoneNameBuf,
                & bufLength,
                NULL,
                NULL,
                NULL,
                NULL );

    DNS_DEBUG( REGISTRY, (
        "RegEnumKeyEx %d returned %d\n", dwZoneIndex, status ));

    if ( status != ERROR_SUCCESS )
    {
        IF_DEBUG( ANY )
        {
            if ( status != ERROR_NO_MORE_ITEMS )
            {
                DNS_PRINT((
                    "ERROR:  RegEnumKeyEx failed for opening zone[%d] key\n"
                    "    status = %d\n",
                    dwZoneIndex,
                    status ));
            }
        }
        return status;
    }
    DNS_DEBUG( REGISTRY, (
        "Reg_EnumZones() enumerated zone %S\n",
        pwZoneNameBuf ));

    //
    //  open zone key, if desired
    //

    if ( phkeyThisZone )
    {
        *phkeyThisZone = Reg_OpenZone( pwZoneNameBuf, hkeyZones );
        if ( !*phkeyThisZone )
        {
            return ERROR_OPEN_FAILED;
        }
    }

    return ERROR_SUCCESS;
}



HKEY
Reg_OpenZone(
    IN      PWSTR           pwsZoneName,
    IN      HKEY            hZonesKey       OPTIONAL
    )
/*++

Routine Description:

    Open or create a DNS zone key.

Arguments:

    pwsZoneName -- name of zone

    hZonesKey -- Zones key if already opened

Return Value:

    Zone's registry key, if successful.
    NULL otherwise.

--*/
{
    HKEY        hkeyThisZone = NULL;
    BOOL        fopenedZonesKey = FALSE;
    DNS_STATUS  status;
    DWORD       disposition;

    //
    //  error if called with zone with no name (i.e. cache)
    //

    if ( !pwsZoneName )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Reg_OpenZone() called with NULL name!\n" ));
        ASSERT( FALSE );
        return NULL;
    }

    //
    //  open DNS zone key
    //

    if ( !hZonesKey )
    {
        hZonesKey = Reg_OpenZones();
        if ( !hZonesKey )
        {
            return NULL;
        }
        fopenedZonesKey = TRUE;
    }

    //
    //  open/create zone key
    //

    status = RegCreateKeyEx(
                hZonesKey,
                pwsZoneName,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyThisZone,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyEx failed for opening zone %S\n"
            "    status = %d\n",
            pwsZoneName,
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
    }

    //  if had to open Zones key, close it

    if ( fopenedZonesKey )
    {
        RegCloseKey( hZonesKey );
    }

    return( hkeyThisZone );
}



VOID
Reg_DeleteZone(
    IN      DWORD           dwFlags,
    IN      PWSTR           pwsZoneName
    )
/*++

Routine Description:

    Delete a DNS zone key.

Arguments:

    dwFlags --  flags that modify how operation is performed

    pwsZoneName -- zone name

Return Value:

    None

--*/
{
    HKEY        hkeyZones = NULL;
    DNS_STATUS  status;

    //
    //  Registry operations must be done in the server context.
    //
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
    }

    //  open DNS Zones key

    hkeyZones = Reg_OpenZones();
    if ( !hkeyZones )
    {
        goto Done;
    }

    //  delete desired zone

    RegDeleteKey(
       hkeyZones,
       pwsZoneName );

    //  close Zones key

    Done:

    if ( hkeyZones )
    {
        RegCloseKey( hkeyZones );
    }
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    return;
}



DWORD
Reg_DeleteAllZones(
    VOID
    )
/*++

Routine Description:

    Delete the DNS zones key.

    When booting from boot file, this allows us to start with
    fresh zone set which will contain ONLY what is CURRENTLY in
    boot file.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_STATUS  status =
        Reg_DeleteKeySubtree( 0, HKEY_LOCAL_MACHINE, DNS_REGKEY_ZONES() );

    DNS_DEBUG( REGISTRY, (
        "Reg_DeleteAllZones: Reg_DeleteKeySubtree() status = %d\n",
        status ));
    return status;
}



//
//  General DNS registry value manipulation routines
//

DNS_STATUS
Reg_SetValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwType,
    IN      PVOID           pData,
    IN      DWORD           cbData
    )
/*++

Routine Description:

    Write a value to DNS registry.

Arguments:

    dwFlags         --  flags that modify how operation is performed
    
    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name (null for default value of key)

    dwType          --  registry data type

    pData           --  data to write

    cbData          --  count of data bytes

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_OPEN_FAILED, if could not open key
    Error code on failure

--*/
{
    BOOL        fneedClose = FALSE;
    DNS_STATUS  status;
    PWSTR       punicodeValue = NULL;
    DWORD       registryType;

    //
    //  Registry operations must be done in the server context.
    //
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }
    
    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            status = ERROR_OPEN_FAILED;
            goto Done;
        }
        fneedClose = TRUE;
    }

    //
    //  determine if need unicode read
    //
    //  general paradigm
    //      - keep in ANSI where possible, simply to avoid having to keep
    //          UNICODE property (reg value) names
    //      - IP strings work better with ANSI read anyway
    //      - file name strings must be handled in unicode as if write as
    //          UTF8, they'll be messed up
    //
    //  DEVNOTE: unicode registry info
    //      table in unicodeRegValue() is kinda lame
    //      alternatives:
    //          1) all unicode, keep unicode value names, convert IP back
    //          2) dwType expanded to carry (need to lookup unicode) info
    //              - with table OR
    //              - with direct conversion OR
    //              - requiring use of unicode valuename
    //          also allows us to have type that means (convert result back
    //          to UTF8)
    //

    if ( DNS_REG_TYPE_UNICODE(dwType) )
    {
        DWORD   regtype = REG_TYPE_FROM_DNS_REGTYPE( dwType );

        DNS_DEBUG( REGISTRY, (
            "Writing unicode regkey %S  regtype = %p\n",
            pszValueName,
            dwType ));

        //
        //  convert UTF8 string to unicode?
        //

        if ( DNS_REG_UTF8 == dwType )
        {
            pData = Dns_StringCopyAllocate(
                        pData,
                        0,
                        DnsCharSetUtf8,
                        DnsCharSetUnicode );
            if ( !pData )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }
            cbData = 0;
        }

        //  if string type with no length -- get it

        if ( cbData == 0 &&
             (  regtype == REG_SZ || regtype == REG_EXPAND_SZ ) )
        {
            cbData = (wcslen(pData) + 1) * 2;
        }

        status = RegSetValueExW(
                    hKey,
                    (PWSTR) pszValueName,   //  unicode reg value name
                    0,                      //  reserved
                    regtype,                //  real registry type
                    (PBYTE) pData,          //  data
                    cbData );               //  data length

        //  free allocated memory

        if ( DNS_REG_UTF8 == dwType )
        {
            FREE_HEAP(pData);
        }
    }
    else
    {
        if ( cbData == 0 && dwType == REG_SZ )
        {
            cbData = strlen( pData );
        }
        status = RegSetValueExA(
                    hKey,
                    pszValueName,
                    0,              //  reserved
                    dwType,         //  registry type
                    (PBYTE) pData,  //  data
                    cbData );       //  data length
    }

Done:

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }

    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_WRITE_FAILED,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegSetValueEx failed for value %s\n",
            pszValueName ));
    }
    else
    {
        DNS_DEBUG( REGISTRY, (
            "Wrote registry value %s, type = %d, length = %d\n",
            pszValueName,
            dwType,
            cbData ));
    }

    return status;
}


DNS_STATUS
Reg_SetDwordValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Write a DWORD value to DNS registry.

    Only purpose is to elminate some arguments to Reg_SetValue() along
    with the need to pass ptr to DWORD value rather than value itself.
    Saves little pieces of code sprinkled around for a very small perf
    penalty.

Arguments:

    dwFlags         --  flags that modify how operation is performed
    
    hKey            --  open handle to regkey

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

    dwValue         --  DWORD value to write

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_OPEN_FAILED, if could not open key
    Error code on failure

--*/
{
    DWORD   tempDword = dwValue;

    return  Reg_SetValue(
                dwFlags,
                hKey,
                pZone,
                pszValueName,
                REG_DWORD,
                &tempDword,
                sizeof( DWORD ) );
}



DNS_STATUS
Reg_SetAddrArray(
    IN      DWORD               dwFlags,        OPTIONAL
    IN      HKEY                hKey,           OPTIONAL
    IN      PZONE_INFO          pZone,          OPTIONAL
    IN      LPSTR               pszValueName,
    IN      PDNS_ADDR_ARRAY     pDnsAddrArray
    )
/*++

Routine Description:

    Writes an IP array to the registry.

    Caller responsible for freeing allocated memory.

Arguments:

    dwFlags         --  flags that modify how operation is performed

    hKey            --  open handle to regkey to write

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    pDnsAddrArray   --  IP array to write to registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       dataLength;
    PIP_ARRAY   pip4array = NULL;
    LPSTR       pszstringArray = NULL;
    DNS_STATUS  status;

    //
    //  if NO IP array, delete registry value
    //

    if ( !pDnsAddrArray )
    {
        status = Reg_DeleteValue(
                    dwFlags,
                    hKey,
                    pZone,
                    pszValueName );
        goto Done;
    }

    //
    //  FIXIPV6: convert to IP4 array.
    //

    pip4array = DnsAddrArray_CreateIp4Array( pDnsAddrArray );
    ASSERT( pip4array );
    if ( !pip4array )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    
    //
    //  convert IP array to string (space separated)
    //

    pszstringArray = Dns_CreateMultiIpStringFromIpArray(
                        pip4array,
                        0 );
    if ( !pszstringArray )
    {
        DNS_PRINT((
            "ERROR:  failed conversion to string of IP array at %p\n",
            pip4array ));
        ASSERT( pszstringArray );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  write back multi-IP string to registry
    //

    DNS_DEBUG( REGISTRY, (
        "Writing back string IP array for registry value %s\n"
        "    string IP array = %s\n",
        pszValueName,
        pszstringArray ));

    status = Reg_SetValue(
                dwFlags,
                hKey,
                pZone,
                pszValueName,
                REG_SZ,
                pszstringArray,
                strlen( pszstringArray ) + 1 );

    Done:
    
    FREE_TAGHEAP( pszstringArray, 0, MEMTAG_DNSLIB );
    FREE_HEAP( pip4array );

    return status;
}



DNS_STATUS
Reg_DeleteValue(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    )
/*++

Routine Description:

    Write a value to DNS registry.

Arguments:

    dwFlags         --  flags that modify how operation is performed

    hKey            --  open handle to regkey to delete

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

Return Value:

    ERROR_SUCCESS, if successful,
    status code on failure

--*/
{
    BOOL            fneedClose = FALSE;
    DNS_STATUS      status;

    //
    //  Registry operations must be done in the server context.
    //
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            status = ERROR_OPEN_FAILED;
            goto Done;
        }
        fneedClose = TRUE;
    }

    //
    //  delete desired key or value
    //

    status = RegDeleteValueA(
                hKey,
                pszValueName );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "WARNING:  RegDeleteValue failed for value %s\n",
            pszValueName ));

        if ( status == ERROR_FILE_NOT_FOUND )
        {
            status = ERROR_SUCCESS;
        }
    }

    //
    //  if opened key, close it
    //
    
    Done:

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }

    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    return status;
}



DNS_STATUS
Reg_GetValue(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PVOID           pData,
    IN      PDWORD          pcbData
    )
/*++

Routine Description:

    Read a DNS registry value.

Arguments:

    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    dwExpectedType  --  registry data type;  if given it is checked against
                        type found

    pData       --  ptr to buffer for data

    pcbData     --  buffer for count of data bytes;  on return contains the
                    length of the data item;
                    may be NULL ONLY if dwExpectedType is REG_DWORD

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_MORE_DATA, if buffer to small
    ERROR_INVALID_DATATYPE, if value datatype does not match expected type
    ERROR_OPEN_FAILED, if could not open key
    status code on failure

--*/
{
    BOOL        fneedClose = FALSE;
    DWORD       regtype;
    DNS_STATUS  status;
    DWORD       dataLength;

    DNS_DEBUG( REGISTRY, (
        "Reg_GetValue( z=%S value=%s, pdata=%p )\n",
        pZone ? pZone->pwsZoneName : NULL,
        pszValueName,
        pData ));

    //
    //  handle datalength field for DWORD queries
    //

    if ( !pcbData )
    {
        if ( dwExpectedType == REG_DWORD )
        {
            dataLength = sizeof(DWORD);
            pcbData = &dataLength;
        }
        else
        {
            ASSERT( FALSE );
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            return ERROR_OPEN_FAILED;
        }
        fneedClose = TRUE;
    }

    //
    //  determine if need unicode read
    //
    //  general paradigm
    //      - keep in ANSI where possible, simply to avoid having to keep
    //          UNICODE property (reg value) names
    //      - IP strings work better with ANSI read anyway
    //      - file name strings must be handled in unicode as if write as
    //          UTF8, they'll be messed up
    //

    if ( DNS_REG_TYPE_UNICODE(dwExpectedType) )
    {
        DNS_DEBUG( REGISTRY, (
            "Reading unicode regkey %S  exptype = %p\n",
            pszValueName,
            dwExpectedType ));

        dwExpectedType = REG_TYPE_FROM_DNS_REGTYPE( dwExpectedType );

        status = RegQueryValueExW(
                    hKey,
                    (PWSTR) pszValueName,
                    0,              //  reserved
                    & regtype,
                    (PBYTE) pData,  //  data
                    pcbData );      //  data length
    }
    else
    {
        status = RegQueryValueExA(
                    hKey,
                    pszValueName,
                    0,              //  reserved
                    & regtype,
                    (PBYTE) pData,  //  data
                    pcbData );      //  data length
    }

    if ( status != ERROR_SUCCESS )
    {
        IF_DEBUG( REGISTRY )
        {
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                if ( DNS_REG_TYPE_UNICODE( dwExpectedType ) )
                {
                    DNS_PRINT((
                        "Reg value %S does not exist\n",
                        pszValueName ));
                }
                else
                {
                    DNS_PRINT((
                        "Reg value %s does not exist\n",
                        pszValueName ));
                }
            }
            else
            {
                DNS_PRINT((
                    "RegQueryValueEx() failed for value %s\n"
                    "    status   = %p\n"
                    "    key      = %p\n"
                    "    zone     = %S\n"
                    "    type exp = %d\n"
                    "    pData    = %p\n"
                    "    datalen  = %d\n",
                    pszValueName,
                    status,
                    hKey,
                    pZone ? pZone->pwsZoneName : NULL,
                    dwExpectedType,
                    pData,
                    *pcbData ));
            }
        }
        goto ReadFailed;
    }

    //
    //  verify proper type, if given
    //      - make allowance for EXPAND_SZ requested, but REG_SZ in registry
    //

    else if ( dwExpectedType )
    {
        if ( dwExpectedType != regtype &&
            !(dwExpectedType == REG_EXPAND_SZ && regtype == REG_SZ ) )
        {
            status = ERROR_INVALID_DATATYPE;
            DNS_PRINT((
                "ERROR:  RegQueryValueEx for value %s returned unexpected type %d\n"
                "    expecting %d\n",
                pszValueName,
                regtype,
                dwExpectedType ));
            goto ReadFailed;
        }
    }


ReadFailed:

    //
    //  if opened key, close it
    //

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }

    //
    //  DEVNOTE-LOG: log read failures only when MUST exist
    //
#if 0

    if ( status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_READ_FAILED,
            0,
            NULL,
            NULL,
            status );
    }
#endif

    return status;
}



PBYTE
Reg_GetValueAllocate(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PDWORD          pdwLength       OPTIONAL
    )
/*++

Routine Description:

    Read a DNS registry value.

    Caller responsible for freeing allocated memory.

Arguments:

    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    dwExpectedType  --  registry data type;  if given it is checked against
                        type found

    pdwLength       -- address to receive allocation length

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    PBYTE       pdata;
    DWORD       dataLength = 0;
    DNS_STATUS  status;
    PBYTE       putf8;

    //
    //  call to get data length
    //

    status = Reg_GetValue(
                hKey,
                pZone,
                pszValueName,
                dwExpectedType,
                NULL,
                & dataLength );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "Failed to get datalength for value %s\n",
            pszValueName ));
        return NULL;
    }
    DNS_DEBUG( REGISTRY, (
        "Fetching %d byte item at registry value %s\n",
        dataLength,
        pszValueName ));

    //
    //  allocate desired buffer length
    //

    pdata = (PBYTE) ALLOC_TAGHEAP( dataLength, MEMTAG_REGISTRY );
    IF_NOMEM( !pdata )
    {
        return NULL;
    }

    //
    //  get actual registry data
    //

    status = Reg_GetValue(
                hKey,
                pZone,
                pszValueName,
                dwExpectedType,
                pdata,
                & dataLength );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  Failure to get data for value %s\n",
            pszValueName ));

        FREE_HEAP( pdata );
        return NULL;
    }

    //
    //  convert unicode string to UTF8?
    //

    if ( DNS_REG_UTF8 == dwExpectedType )
    {
        DNS_DEBUG( REGISTRY, (
            "Registry unicode string %S, to convert back to UTF8\n",
            pdata ));

        putf8 = Dns_StringCopyAllocate(
                    pdata,
                    0,
                    DnsCharSetUnicode,
                    DnsCharSetUtf8 );

        //  dump unicode string and use UTF8

        FREE_HEAP( pdata );
        pdata = putf8;

        if ( !pdata )
        {
            return NULL;
        }
        if ( pdwLength )
        {
            dataLength = strlen( pdata ) + 1;
        }
    }

    if ( pdwLength )
    {
        *pdwLength = dataLength;
    }

    HARD_ASSERT( Mem_VerifyHeapBlock( pdata, 0, 0 ) );

    return( pdata );
}



PDNS_ADDR_ARRAY
Reg_GetAddrArray(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    )
/*++

Routine Description:

    Read an IP array from the registry.

    Caller responsible for freeing allocated memory.

Arguments:

    hKey            --  open handle to regkey to read

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

Return Value:

    Ptr to address allocated, if successful or NULL on error.

--*/
{
    DWORD               dataLength;
    PDNS_ADDR_ARRAY     piparray = NULL;
    PIP4_ARRAY          pip4array = NULL;
    LPSTR               pszstringArray;
    DNS_STATUS          status;

    //
    //  retrieve IP array as string
    //

    pszstringArray = Reg_GetValueAllocate(
                        hKey,
                        pZone,
                        pszValueName,
                        REG_SZ,
                        &dataLength );
    if ( pszstringArray )
    {
        DNS_DEBUG( REGISTRY, (
            "Found string IP array for registry value %s\n"
            "    string = %s\n",
            pszValueName,
            pszstringArray ));

        status = Dns_CreateIpArrayFromMultiIpString(
                    pszstringArray,
                    &pip4array );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( REGISTRY, (
                "ERROR: string IP array %s is INVALID!\n",
                pszstringArray ));
            goto Invalid;
        }

        //
        //  Convert to DNSADDR.
        //

        piparray = DnsAddrArray_CreateFromIp4Array( pip4array );
        if ( !piparray )
        {
            goto Return;
        }
    }

    //
    //  For upgrades from NT4, attempt to load the registry value as
    //  a REG_BINARY.
    //
    
    if ( !piparray )
    {
        pip4array = ( PIP4_ARRAY ) Reg_GetValueAllocate(
                                        hKey,
                                        pZone,
                                        pszValueName,
                                        REG_BINARY,
                                        &dataLength );
        //
        //  Sanity check the IP4 array.
        //  

        if ( !pip4array )
        {
            goto Return;
        }
        
        if ( dataLength % sizeof( DWORD ) != 0 ||
             dataLength != Dns_SizeofIpArray( pip4array ) )
        {
            goto Invalid;
        }
        
        //
        //  Convert to DNSADDR.
        //

        piparray = DnsAddrArray_CreateFromIp4Array( pip4array );
        if ( !piparray )
        {
            goto Return;
        }
    }

    HARD_ASSERT( Mem_VerifyHeapBlock( piparray, 0, 0 ) );
    
    goto Return;

    Invalid:

    {
        PVOID   argArray[ 2 ];
        BYTE    argTypeArray[ 2 ];

        DNS_PRINT((
            "ERROR:  invalid IP_ARRAY read from registry\n"
            "    key=%p, zone=%S, value=%s\n",
            hKey,
            pZone ? pZone->pwsZoneName : NULL,
            pszValueName ));

        if ( pZone )
        {
            argTypeArray[ 0 ] = EVENTARG_UNICODE;
            argTypeArray[ 1 ] = EVENTARG_UTF8;

            argArray[ 0 ] = pZone->pwsZoneName;
            argArray[ 1 ] = pszValueName;

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_REGISTRY_ZONE_DATA,
                2,
                argArray,
                argTypeArray,
                0 );
        }
        else
        {
            argArray[ 0 ] = pszValueName;

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_REGISTRY_PARAM,
                1,
                argArray,
                EVENTARG_ALL_UTF8,
                0 );
        }
    }

    Return:
    
    FREE_HEAP( pszstringArray );
    FREE_HEAP( pip4array );
    
    //
    //  Make certain IP array ports are set.
    //
    
    if ( piparray )
    {
        DnsAddrArray_SetPort( piparray, DNS_PORT_NET_ORDER );
    }

    return piparray;
}



DNS_STATUS
Reg_ReadDwordValue(
    IN      HKEY            hKey,
    IN      PWSTR           pwsZoneName,    OPTIONAL
    IN      LPSTR           pszValueName,
    IN      BOOL            bByteResult,
    OUT     PVOID           pResult
    )
/*++

Routine Description:

    Read standard DWORD value from registry into memory location.

    This is just a wrapped to eliminate duplicate registry setup
    and debug info, for call that is used repeatedly in code.

Arguments:

    hKey            --  open handle to regkey to read

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

    bByteResult     --  treat result as BYTE sized

    pResult         --  ptr to result memory location

Return Value:

    ERROR_SUCCESS on successful read.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       regValue;
    DWORD       regSize = sizeof(DWORD);

    //
    //  make DWORD get call
    //

    status = Reg_GetValue(
                hKey,
                NULL,
                pszValueName,
                REG_DWORD,
                & regValue,
                & regSize );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Read zone %S %s value = %d\n",
            pwsZoneName ? pwsZoneName : NULL,
            pszValueName,
            regValue ));

        ASSERT( regSize == sizeof(DWORD) );

        if ( bByteResult )
        {
            * ( PBYTE ) pResult = ( UCHAR ) regValue;
        }
        else
        {
            * ( PDWORD ) pResult = regValue;
        }
    }
    return status;
}



//
//  Basic DNS independent registry operations
//

LPSTR
Reg_AllocateExpandedString_A(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Create expanded REG_EXPAND_SZ type string.

    Caller responsible for freeing allocated memory.

Arguments:

    pszString --    string to expand

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    LPSTR   pszexpanded;
    DWORD   dataLength = 0;

    //
    //  if NULL, return NULL
    //

    if ( !pszString )
    {
        return NULL;
    }

    //
    //  determine expanded length and allocate, then do actual expansion
    //

    dataLength = ExpandEnvironmentStringsA(
                        pszString,
                        NULL,
                        0 );
    if ( dataLength == 0 )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  ExpandEnvironmentStrings() failed getting length of %s\n",
            pszString ));
        return NULL;
    }

    pszexpanded = (PBYTE) ALLOC_TAGHEAP( dataLength, MEMTAG_REGISTRY );
    IF_NOMEM( !pszexpanded )
    {
        return NULL;
    }

    if ( !ExpandEnvironmentStringsA(
                        pszString,
                        pszexpanded,
                        dataLength ) )
    {
        return NULL;
    }
    return pszexpanded;
}



PWSTR
Reg_AllocateExpandedString_W(
    IN      PWSTR           pwsString
    )
/*++

Routine Description:

    Create expanded REG_EXPAND_SZ type string.

    Caller responsible for freeing allocated memory.

Arguments:

    pwsString --    string to expand

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    PWSTR   pexpanded;
    DWORD   dataLength = 0;

    //
    //  if NULL, return NULL
    //

    if ( !pwsString )
    {
        return NULL;
    }

    //
    //  determine expanded length and allocate, then do actual expansion
    //

    dataLength = ExpandEnvironmentStringsW(
                        pwsString,
                        NULL,
                        0 );
    if ( dataLength == 0 )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  ExpandEnvironmentStrings() failed getting length of %S\n",
            pwsString ));
        return NULL;
    }

    pexpanded = ( PWSTR ) ALLOC_TAGHEAP(
                    dataLength * sizeof( WCHAR ),
                    MEMTAG_REGISTRY );
    IF_NOMEM( !pexpanded )
    {
        return NULL;
    }

    if ( !ExpandEnvironmentStringsW(
                        pwsString,
                        pexpanded,
                        dataLength ) )
    {
        return NULL;
    }
    return pexpanded;
}



DNS_STATUS
Reg_DeleteKeySubtree(
    IN      DWORD           dwFlags,        OPTIONAL
    IN      HKEY            hKey,
    IN      PWSTR           pwsKeyName      OPTIONAL
    )
/*++

Routine Description:

    Delete key, including subtree.

    RegDeleteKey is broken in NT and does NOT have a mode for
    deleting entire subtree.  This handles that.

Arguments:

    dwFlags --  flags that modify how operation is performed

    hKey -- desired key, or higher level key

    pwsKeyName -- key name, relative to hKey given;  NULL if hKey is
        desired delete key

Return Value:

    ERROR_SUCCESS if successful
    Error status code on failure

--*/
{
    HKEY        hkeyOpened = NULL;
    DNS_STATUS  status;
    DWORD       index = 0;
    DWORD       bufLength;
    WCHAR       subkeyNameBuffer[ MAX_PATH + 1 ];

    DNS_DEBUG( REGISTRY, (
        "Reg_DeleteKeySubtree %S\n",
        pwsKeyName ));

    //
    //  Registry operations must be done in the server context.
    //
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  delete the key
    //      - if works, we're done
    //

    status = RegDeleteKeyW(
                hKey,
                pwsKeyName );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "Successfully deleted key %S from parent key %p\n",
            pwsKeyName,
            hKey ));
        goto Done;
    }

    //
    //  need to open and delete subkeys
    //      - if don't have handle to delete key, open it
    //

    if ( pwsKeyName )
    {
        status = RegOpenKeyW(
                    hKey,
                    pwsKeyName,
                    & hkeyOpened );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( REGISTRY, (
                "ERROR:  unable to open key %S from parent key %p\n"
                "    status = %d\n",
                pwsKeyName,
                hKey,
                status ));
            goto Done;
        }
        hKey = hkeyOpened;
    }

    //
    //  enum and delete subkeys
    //      - index is always zero if delete successful
    //

    index = 0;

    while ( 1 )
    {
        bufLength = sizeof( subkeyNameBuffer ) / sizeof( WCHAR );

        status = RegEnumKeyEx(
                    hKey,
                    index,
                    subkeyNameBuffer,
                    & bufLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL );

        //  recurse to delete enumerated key

        if ( status == ERROR_SUCCESS )
        {
            status = Reg_DeleteKeySubtree(
                        dwFlags,
                        hKey,
                        subkeyNameBuffer );
            if ( status == ERROR_SUCCESS )
            {
                continue;
            }
            break;
        }

        //  finished enumeration

        else if ( status == ERROR_NO_MORE_ITEMS )
        {
            status = ERROR_SUCCESS;
            break;
        }

        //  enumeration error

        DNS_PRINT((
            "ERROR:  RegEnumKeyEx failed for opening [%d] key\n"
            "    status = %d\n",
            index,
            status ));
        break;
    }

    //  if opened key at this level, close it

    if ( hkeyOpened )
    {
        RegCloseKey( hkeyOpened );
    }

    //
    //  retry delete of top level key
    //

    status = RegDeleteKeyW( hKey, pwsKeyName );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  Unable to delete key %S even after deleting subtree\n",
            pwsKeyName ));
    }

    Done:
    
    if ( dwFlags & DNS_REG_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    return status;
}


DNS_STATUS
Reg_AddPrincipalSecurity(
    IN      HKEY    hkey,
    IN      LPTSTR  pwsUser,
    IN      DWORD   dwAccessFlags       OPTIONAL
    )
/*++

Routine Description:

    Extend DNs registry service point access to contain given hkey SD + pwsUser
    security principal RW access.

Arguments:

    hKey            --  open handle to registry key

    pwsUser         --  user to add access to key

    dwAccessFlags   --  additional acccess flags such as:
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    DNS_STATUS  status = ERROR_SUCCESS;
    BOOL        bstatus = FALSE;
    BOOL        bDefaulted = FALSE;
    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;
    DWORD cbSd = 0;
    PSID pUser = NULL, pGroup = NULL;

    DNS_DEBUG( REGISTRY, (
        "Call Reg_AddPrincipalSecurity(%p, %S)\n",
        hkey, pwsUser));

    //
    //  parameter sanity.
    //

    if ( !hkey || !pwsUser )
    {
        DNS_DEBUG( REGISTRY, (
            "Error: Invalid key specified to Reg_SetSecurity\n"));
        ASSERT (hkey);
        ASSERT (pwsUser);
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  Get SD length to allocate
    //

    status = RegGetKeySecurity( hkey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                NULL,
                                &cbSd );
    if ( ERROR_INSUFFICIENT_BUFFER != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get key security\n",
            status ));
        ASSERT (FALSE);
        return status;
    }

    ASSERT ( cbSd > 0 );

    //
    //  Get current security descriptor
    //

    pOldSd = ALLOCATE_HEAP( cbSd );
    if ( !pOldSd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    status = RegGetKeySecurity( hkey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pOldSd,
                                &cbSd );

    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get key security (2)\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    //
    //  Extract SD user/group SIDS.
    //

    bstatus = GetSecurityDescriptorOwner( pOldSd,
                                          &pUser,
                                          &bDefaulted );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get SD user\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    ASSERT (pUser);

    bstatus = GetSecurityDescriptorGroup( pOldSd,
                                          &pGroup,
                                          &bDefaulted );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get SD group\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    ASSERT (pGroup);

    //
    //  Create new SD
    //

    status = SD_AddPrincipalToSD(
                    NULL,           //  SID
                    pwsUser,
                    pOldSd,
                    &pNewSd,
                    GENERIC_ALL |
                    STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                    dwAccessFlags,
                    pUser,
                    pGroup,
                    FALSE,
                    TRUE );

    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to add principal to SD\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    status = RegSetKeySecurity( hkey,
                                DACL_SECURITY_INFORMATION,
                                pNewSd );


    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to write new SD to registry\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Cleanup and return
    //

    Cleanup:

    FREE_HEAP( pOldSd );
    FREE_HEAP( pNewSd );

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_AddPrincipalSecurity\n",
        status ));
    return status;
}


DNS_STATUS
Reg_ExtendRootAccess(
    VOID
    )
/*++

Routine Description:

    Modifies DNS root regkey to contain DnsAdmins & whoever we like
    (nobody else at the moment)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    HKEY hkey;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( REGISTRY, (
        "Call  Reg_ExtendRootAccess\n" ));
    DNS_DEBUG( REGISTRY, (
        "Modifying DNS root key security\n" ));

    hkey = Reg_OpenRoot();
    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrincipalSecurity(
                    hkey,
                    SZ_DNS_ADMIN_GROUP_W,
                    0 );        //  can't use CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey( hkey );
    hkey = NULL;

    //
    //  DEVNOTE: Is this necessary at all? I use inheritance, but it seems
    //      that the registry doesn't modify existing keys but only apply
    //      to new ones. Seems to be necessary now.
    //
    DNS_DEBUG( REGISTRY, (
        "Modifying DNS Parameters key security\n" ));

    hkey = Reg_OpenParameters();
    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrincipalSecurity(
                    hkey,
                    SZ_DNS_ADMIN_GROUP_W,
                    0);
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey( hkey );

    //
    // set zones security w/ inheritance for sub containers.
    //

    status = Reg_ExtendZonesAccess();
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: cannot extend zones security\n",
            status ));
        ASSERT ( FALSE );
        goto Cleanup;
    }

Cleanup:

    if ( hkey )
    {
        RegCloseKey(hkey);
    }

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_ExtendRootAccess\n",
        status ));

    return status;
}


DNS_STATUS
Reg_ExtendZonesAccess(
    VOID
    )
/*++

Routine Description:

    Modifies DNS root regkey to contain DnsAdmins & whoever we like
    (nobody else at the moment)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    HKEY hkey;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( REGISTRY, (
        "Call  Reg_ExtendZonesAccess\n" ));
    DNS_DEBUG( REGISTRY, (
        "Modifying DNS Zones key security\n" ));

    hkey = Reg_OpenZones();
    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrincipalSecurity(
                    hkey,
                    SZ_DNS_ADMIN_GROUP_W,
                    CONTAINER_INHERIT_ACE |
                    OBJECT_INHERIT_ACE );
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed\n",
            status ));
        goto Cleanup;
    }

    //
    //  DEVNOTE-WORKAROUND: For some reason, if zone was just created, admin has
    //  only RO access but requires full access. So we add it here manually.
    //

    status = Reg_AddPrincipalSecurity(
                    hkey,
                    L"Administrators",
                    CONTAINER_INHERIT_ACE |
                    OBJECT_INHERIT_ACE );
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed for administrators\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey(hkey);
    hkey = NULL;

Cleanup:

    if ( hkey )
    {
        RegCloseKey(hkey);
    }

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_ExtendZonesAccess\n",
        status ));

    return status;
}


//
//  End of registry.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\recurse.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    recurse.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle recursive queries.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

    jamesg  Dec 1995    -   Recursion timeout, retry

--*/


#include "dnssrv.h"

#include <limits.h>     // for ULONG_MAX


BOOL    g_fUsingInternetRootServers = FALSE;


//
//  Recursion queue info
//

PPACKET_QUEUE   g_pRecursionQueue;

#define RECURSION_QUEUE_MAX_LENGTH  ( 25000 )

#define DEFAULT_RECURSION_RETRY     ( 2 )       //  2s before retry query
#define DEFAULT_RECURSION_TIMEOUT   ( 5 )       //  5s before final fail of query


//
//  Root server query
//      - track last time sent and don't try full resend if within 10 minutes
//

DWORD   g_NextRootNsQueryTime = 0;

#define ROOT_NS_QUERY_RETRY_TIME    ( 600 )     //  10 minutes


//
//  Private protos
//

BOOL
initializeQueryForRecursion(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
initializeQueryToRecurseNewQuestion(
    IN OUT  PDNS_MSGINFO    pQuery
    );

DNS_STATUS
sendRecursiveQuery(
    IN OUT          PDNS_MSGINFO    pQuery,
    IN OPTIONAL     PDNS_ADDR       paddrNameServer,
    IN              DWORD           timeout
    );

VOID
recursionServerFailure(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           status
    );

BOOL
startTcpRecursion(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
stopTcpRecursion(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
processRootNsQueryResponse(
    IN      PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
processCacheUpdateQueryResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
recurseConnectCallback(
    IN OUT  PDNS_MSGINFO    pRecurseMsg,
    IN      BOOL            fConnected
    );



VOID
FASTCALL
Recurse_WriteReferral(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Find and write referral to packet.

Arguments:

    pNode - ptr to node to start looking for referral;  generally
        this would be question node, or closest ancestor of it in database

    pQuery - query we are writing

Return Value:

    None

--*/
{
    register PDB_NODE   pnode;
    PDB_RECORD          prrNs;

    ASSERT( pQuery );

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_WriteReferral for query at %p\n",
            pQuery ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        DnsDbg_Unlock();
    }

    STAT_INC( RecurseStats.ReferralPasses );
    ASSERT( IS_SET_TO_WRITE_ANSWER_RECORDS(pQuery) ||
            IS_SET_TO_WRITE_AUTHORITY_RECORDS(pQuery) );

    SET_TO_WRITE_AUTHORITY_RECORDS(pQuery);

    //
    //  find closest zone root with NS
    //
    //  start at incoming node, and walk back up through database until
    //      find a name server, with an address record
    //

    Dbase_LockDatabase();
    SET_NODE_ACCESSED(pNode);
    pnode = pNode;

    while ( pnode != NULL )
    {
        DNS_DEBUG( RECURSE, (
            "Recursion at node label %.*s\n",
            pnode->cchLabelLength,
            pnode->szLabel ));

        //
        //  find "covering" zone root node
        //  switching to delegation if available
        //

        pnode = Recurse_CheckForDelegation(
                    pQuery,
                    pnode );
        if ( !pnode )
        {
            ASSERT( FALSE );
            break;
        }

        //  find name servers for this domain
        //      - if none, break out for next level in tree
        //
        //  protect against no-root server or unable to contact root
        //  if first NS record is ROOT_HINT, then we don't have any valid
        //  delegation information to send on and we're toast, move to parent
        //  which if we're at root, we'll kick out and SERVER_FAIL

        prrNs = RR_FindNextRecord(
                    pnode,
                    DNS_TYPE_NS,
                    NULL,
                    0 );
        if ( !prrNs  ||  IS_ROOT_HINT_RR(prrNs) )
        {
            pnode = pnode->pParent;

            //  if failed to find delegation NS -- bail
            //
            //  note, this can happen when:
            //      1) unable to contact root hints
            //      2) forwarding and have no root hints at all
            //

            if ( !pnode )
            {
                DNS_DEBUG( RECURSE, (
                    "ERROR:  Failed referral for query %p\n"
                    "    searched to root node\n",
                    pQuery ));
                break;
            }
            if ( IS_AUTH_NODE(pnode) )
            {
                DNS_DEBUG( RECURSE, (
                    "ERROR:  Failed referral for query %p\n"
                    "    delegation below %s in zone %s starting at node %s (%p)\n"
                    "    has no NS records;  this may be possible as transient\n",
                    pQuery,
                    pnode,
                    ((PZONE_INFO)pnode->pZone)->pszZoneName,
                    pNode->szLabel,
                    pNode ));
                ASSERT( FALSE );
                break;
            }
            continue;
        }

        Dbase_UnlockDatabase();

        //  have NS records,
        //  write NS and associated A records to the packet
        //
        //  DEVNOTE: zone holding delegation on referral?
        //      do we need to mark referral here and provide zone
        //      holding delegation -- if any?

        Answer_QuestionFromDatabase(
            pQuery,
            pnode,
            0,
            DNS_TYPE_NS );
        return;
    }

    //
    //  No referral name server's found!
    //      - should NEVER happen, as should always have root server
    //
    //  Since we don't track down rootNS records, we won't be
    //      able to refer either;  should launch rootNS query
    //      ??? should have mode where DON'T query root -- sort of no referral mode
    //      in other words server only useful for direct lookup?
    //

    Dbase_UnlockDatabase();

    DNS_DEBUG( ANY, ( "ERROR:  Unable to provide name server for referal\n" ));

    if ( pQuery->Head.AnswerCount == 0 )
    {
        Reject_Request(
            pQuery,
            DNS_RCODE_SERVER_FAILURE,
            0 );
    }
    else
    {
        Send_QueryResponse( pQuery );
    }
}



BOOL
initializeQueryForRecursion(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Initialize for query recursion.

        - allocating and initializing recursion block
        - allocate additional records block, if necessary

Arguments:

    pQuery -- query to recurse

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_MSGINFO    pmsgRecurse;

    //
    //  allocate recursion message
    //

    ASSERT( pQuery->pRecurseMsg == NULL );

    pmsgRecurse = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsgRecurse )
    {
        return FALSE;
    }

    STAT_INC( RecurseStats.QueriesRecursed );
    PERF_INC( pcRecursiveQueries );          // PerfMon hook
    STAT_INC( PacketStats.RecursePacketUsed );

    ASSERT( pmsgRecurse->fDelete == FALSE );
    ASSERT( pmsgRecurse->fTcp == FALSE );

    //
    //  link recursion message to query and vice versa
    //

    pQuery->pRecurseMsg = pmsgRecurse;
    pmsgRecurse->pRecurseMsg = pQuery;
    pmsgRecurse->fRecursePacket = TRUE;

    //
    //  NS IP visit list setup
    //

    Remote_NsListCreate( pQuery );
    
    IF_NOMEM( !pQuery->pNsList )
    {
        return FALSE;
    }

    //
    //  clear recursion flags
    //

    pQuery->fQuestionRecursed = FALSE;
    pQuery->fRecurseTimeoutWait = FALSE;
    return TRUE;
}



BOOL
initializeQueryToRecurseNewQuestion(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Initialize query to recurse new question.

Arguments:

    pQuery -- query to recurse

Return Value:

    TRUE if successfully wrote recursive message.
    FALSE if failure.

--*/
{
    PDNS_MSGINFO    pmsg;

    DNS_DEBUG( RECURSE, (
        "Init query at %p for recursion of new question, type %d\n"
        "    answer count %d\n"
        "    recurse message at %p\n",
        pQuery,
        pQuery->wTypeCurrent,
        pQuery->Head.AnswerCount,
        pQuery->pRecurseMsg ));

    //
    //  set for new question being recursed
    //      - start at beginning of forwarders list
    //      - set for new query XID, queuing routine does assignment
    //      - reset visited list
    //

    pQuery->fQuestionCompleted = FALSE;
    pQuery->fRecurseQuestionSent = FALSE;
    pQuery->nForwarder = 0;
    pQuery->wQueuingXid = 0;

    Remote_InitNsList( ( PNS_VISIT_LIST ) pQuery->pNsList );

    //  catch failure to set on any recursive query

    pQuery->pnodeRecurseRetry = NULL;

    //
    //  build actual recursion message
    //      - note message is initialized on initial init for recursion
    //      - always start query with UDP
    //

    pmsg = pQuery->pRecurseMsg;
    ASSERT( pmsg );
    ASSERT( pmsg->fDelete == FALSE );
    ASSERT( pmsg->fTcp == FALSE );
    ASSERT( pmsg->pRecurseMsg == pQuery );
    ASSERT( pmsg->fRecursePacket );

    //
    //  recursing original question
    //      - optimize by just copying original packet
    //      - clear flags we set for response
    //          - response flag
    //          - recursion available
    //      - set pCurrent to get correct message length on send
    //      - need to also copy OPT information
    //

    pmsg->Opt.fInsertOptInOutgoingMsg = pQuery->Opt.fInsertOptInOutgoingMsg;

    if ( RECURSING_ORIGINAL_QUESTION(pQuery) )
    {
        //
        //  Make sure the recurse msg is large enough to hold the query.
        //  This can fail when processing a TCP query that is larger than
        //  the UDP packet size. Could be a malicious attack, or a badly
        //  formatted packet, or some future large query.
        //

        if ( pQuery->MessageLength > pmsg->MaxBufferLength )
        {
            DNS_DEBUG( RECURSE, (
                "attempt to recurse %d byte question with %d byte packet!\n",
                pQuery->MessageLength,
                pmsg->MaxBufferLength ));
            ASSERT( pQuery->MessageLength <= pmsg->MaxBufferLength );
            return FALSE;
        }

        STAT_INC( RecurseStats.OriginalQuestionRecursed );

        RtlCopyMemory(
            (PBYTE) DNS_HEADER_PTR(pmsg),
            (PBYTE) DNS_HEADER_PTR(pQuery),
            pQuery->MessageLength );

        pmsg->MessageLength = pQuery->MessageLength;
        pmsg->pCurrent = DNSMSG_END( pmsg );
        pmsg->Head.RecursionAvailable = 0;
        pmsg->Head.IsResponse = 0;
    }

    //  if recursing, for CNAME or additional info,
    //  then write question from node and type

    else
    {
        ASSERT( pQuery->Head.AnswerCount != 0 || pQuery->Head.NameServerCount != 0 );

        if ( !Msg_WriteQuestion(
                    pmsg,
                    pQuery->pnodeCurrent,
                    pQuery->wTypeCurrent ))
        {
            ASSERT( FALSE );
            return FALSE;
        }

        //
        //  By rewriting the question we have removed the OPT, so zero the offset
        //  to the old OPT so we don't try to use it later in Send_Msg().
        //

        if ( pmsg->Opt.wOptOffset )
        {
            pmsg->Opt.wOptOffset = 0;
            ASSERT( pmsg->Head.AdditionalCount > 0 );
            --pmsg->Head.AdditionalCount;
        }

        IF_DEBUG( RECURSE2 )
        {
            DnsDebugLock();
            //  DEVNOTE: don't message with this in debug code,
            //  DEVNOTE: have Dbg_DnsMessage figure out larger or MessageLength
            //              or pCurrent and go out that far

            pQuery->MessageLength = (WORD)DNSMSG_OFFSET( pQuery, pQuery->pCurrent );
            Dbg_DnsMessage(
                "Recursing message for CNAME or additional data",
                pQuery );
            Dbg_NodeName(
                "Recursing for name ",
                pQuery->pnodeCurrent,
                "\n" );
            Dbg_DnsMessage(
                "Recursive query to send",
                pmsg );
            DnsDebugUnlock();
        }
        STAT_INC( RecurseStats.AdditionalRecursed );
    }

    pQuery->fQuestionRecursed = TRUE;
    STAT_INC( RecurseStats.TotalQuestionsRecursed );

    return TRUE;
}



BOOLEAN
recurseToForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDNS_ADDR_ARRAY aipForwarders,
    IN      BOOL            fSlave,
    IN      DWORD           timeout
    )
/*++

Routine Description:

    Handle all recursion to forwarding servers.

Arguments:

    pQuery -- query needing recursion

    aipForwarders -- array of servers to forward query to

    fSlave -- recursion after forward failure is not allowed

    timeout -- timeout to wait for response

Return Value:

    TRUE, if successful
    FALSE on error or done with forwarders

--*/
{
    DNS_ADDR    ipforwarder;

    //
    //  verify using forwarders
    //

    if ( !aipForwarders )
    {
        //  admin may have turned off forwarders, just now,
        //  do regular recursion

        TEST_ASSERT( aipForwarders );
        return FALSE;
    }

    //
    //  out of forwarding addresses ?
    //      - if slave DONE -- fail -- set fRecurseTimeoutWait flag so we don't
    //          queue up the query for another try
    //      - else try standard recursion
    //

    if ( ( DWORD ) pQuery->nForwarder >= aipForwarders->AddrCount )
    {
        if ( fSlave )
        {
            DNS_DEBUG( RECURSE, ( "Slave timeout of packet %p\n", pQuery ));
            pQuery->fRecurseTimeoutWait = TRUE;
            recursionServerFailure( pQuery, 0 );
            return TRUE;
        }
        else
        {
            DNS_DEBUG( RECURSE, ( "End of forwarders on packet %p\n", pQuery ));
            SET_DONE_FORWARDERS( pQuery );
            return FALSE;
        }
    }

    //
    //  send packet to next forwarder in list
    //      - inc forwarder index
    //

    DnsAddr_Copy( &ipforwarder, &aipForwarders->AddrArray[ pQuery->nForwarder ] );
    pQuery->nForwarder++;

    //
    //  set explicit expiration timeout
    //
    //  forwarders timeout (a local LAN timeout) is likely less than
    //  default timeout for recursion queue (a reasonable Internet timeout)
    //

    DNS_DEBUG( RECURSE, (
        "Recursing query at %p to forwarders name server at %s\n",
        pQuery,
        DNSADDR_STRING( &ipforwarder ) ));

    STAT_INC( RecurseStats.Forwards );

    sendRecursiveQuery(
        pQuery,
        &ipforwarder,
        timeout );

    return TRUE;
}   //  recurseToForwarder



DNS_STATUS
/*++

Routine Description:

    This function performs the actual queuing and sending of a query.
    This is the guts of sendRecursiveQuery and can be used by functions
    needing to resend queries without any query processing.

Arguments:

    pQuery - ptr to query

    ipArray - array of IPs (NULL if RemoteAddress already set)

Return Value:

    ERROR_SUCCESS if successfully sent and queued

--*/
queueAndSendRecursiveQuery( 
    IN OUT          PDNS_MSGINFO    pQuery,
    IN OPTIONAL     PDNS_ADDR_ARRAY ipArray )
{
    PDNS_MSGINFO    psendMsg;

    ASSERT( pQuery );
    psendMsg = pQuery->pRecurseMsg;
    ASSERT( psendMsg );
    ASSERT( psendMsg->pRecurseMsg == pQuery );  // check cross link

    //
    //  Enqueue original query in recursion queue
    //
    //  Note:
    //  Enqueue BEFORE send, so query on queue if another thread gets
    //  response.
    //  After queuing MUST NOT TOUCH pQuery as may be removed from
    //  queue and processed by another thread processing response.
    //

    EnterCriticalSection( & g_pRecursionQueue->csQueue );

    psendMsg->Head.Xid = PQ_QueuePacketWithXid(
                                g_pRecursionQueue,
                                pQuery );
    DNS_DEBUG( RECURSE, (
        "Recursing for queued query at %p\n"
        "    queuing XID = %hx\n"
        "    queuing time=%d, expire=%d\n"
        "    Sending msg at %p to NS at %s\n",
        pQuery,
        psendMsg->Head.Xid,
        pQuery->dwQueuingTime,
        pQuery->dwExpireTime,
        psendMsg,
        DNSADDR_STRING( &psendMsg->RemoteAddr ) ));

    MSG_ASSERT( psendMsg, psendMsg->Head.Xid == pQuery->wQueuingXid );
    MSG_ASSERT( psendMsg, psendMsg->fDelete == FALSE );
    MSG_ASSERT( psendMsg, psendMsg->Head.IsResponse == FALSE );
    MSG_ASSERT( psendMsg, psendMsg->Head.RecursionAvailable == FALSE );

    //
    //  If no array, then the send msg must already contain the
    //  destination remote IP address.
    //

    if ( ipArray )
    {
        ASSERT( ipArray->AddrCount > 0 );

        Send_Multiple(
            psendMsg,
            ipArray,
            &RecurseStats.Sends );
    }
    else
    {
        Send_Msg( psendMsg, 0 );
    }

    IF_DEBUG( RECURSE2 )
    {
        Dbg_PacketQueue(
            "Recursion packet queue after recursive send",
            g_pRecursionQueue );
    }
    MSG_ASSERT( psendMsg, psendMsg->fDelete == FALSE );

    LeaveCriticalSection( & g_pRecursionQueue->csQueue );

    return( ERROR_SUCCESS );
} // queueAndSendRecursiveQuery




DNS_STATUS
sendRecursiveQuery(
    IN OUT          PDNS_MSGINFO    pQuery,
    IN OPTIONAL     PDNS_ADDR       paddrNameServer,
    IN              DWORD           timeout
    )
/*++

Routine Description:

    Send recursive query.

Arguments:

    pQuery - ptr to response info

    paddrNameServer - IP address of name server to recurse to

    timeout - time to wait for response for, in seconds

Return Value:

    ERROR_SUCCESS if successfully send to remote machine, or
        query is otherwise eaten up and no longer in "control"
        of this thread (ex. missing glue query)
    DNSSRV_ERROR_OUT_OF_IP if no more NS IPs to send to hence
        caller can continue up the tree

--*/
{
    PDNS_MSGINFO        psendMsg;
    SOCKADDR_IN         saNameServer;
    DWORD               dwCurrentTime;
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_ADDR_ARRAY     pDnsAddrArray = NULL;

    DNS_DEBUG( RECURSE, (
        "sendRecursiveQuery at %p, to NS at %s (OPT=%s)\n",
        pQuery,
        paddrNameServer ? DNSADDR_STRING( paddrNameServer ) : "NULL",
        pQuery->Opt.fInsertOptInOutgoingMsg ? "TRUE" : "FALSE" ));

    //  should never send without having saved node to restart NS hunt
    //  unless this is a forwarder zone

    ASSERT( pQuery->pnodeRecurseRetry ||
            ( pQuery->pzoneCurrent &&
            IS_ZONE_FORWARDER( pQuery->pzoneCurrent ) ) );

    //
    //  get message for recursion
    //

    ASSERT( pQuery->pRecurseMsg );
    psendMsg = pQuery->pRecurseMsg;
    ASSERT( psendMsg->pRecurseMsg == pQuery );  // check cross link

    //
    //  set destination
    //      - set to send to NS IP address
    //      - inc queuing count
    //

    if ( paddrNameServer )
    {
        DnsAddr_Copy( &psendMsg->RemoteAddr, paddrNameServer );
    }
    else
    {
        DnsAddr_Reset( &psendMsg->RemoteAddr );
    }

    //
    //  repeating previously sent query?
    //

    if ( pQuery->fRecurseQuestionSent )
    {
        STAT_INC( RecurseStats.Retries );
    }
    pQuery->fRecurseQuestionSent = TRUE;

    //
    //  forwarding
    //      - single send to given forwarder
    //      - make a recursive query
    //      - set queuing expiration to forwarders timeout
    //

    if ( IS_FORWARDING( pQuery ) )
    {
        STAT_INC( RecurseStats.Sends );

        psendMsg->Head.RecursionDesired = 1;
        pQuery->dwExpireTime = timeout;

        queueAndSendRecursiveQuery( pQuery, NULL );
    }

    //
    //  not forwarding -- iterative query
    //      - iterative query
    //      - let recursion queue set expiration time
    //      (don't default these, as need to reset when reach end of
    //      forwarders list and switch to regular recursion)
    //
    //      - select "best" remote NS from list
    //      two failure states
    //          ERROR_MISSING_GLUE -- don't send but don't touch query
    //          ERROR_OUT_OF_IP -- don't send, but caller can continue
    //              up tree looking
    //

    else
    {
        if ( !paddrNameServer )
        {
            pDnsAddrArray =
                DnsAddrArray_Create( RECURSE_PASS_MAX_SEND_COUNT );
            
            status = Remote_ChooseSendIp(
                        pQuery,
                        pDnsAddrArray );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNSSRV_ERROR_MISSING_GLUE )
                {
                    status = ERROR_SUCCESS;
                }
                ELSE_ASSERT( status == DNSSRV_ERROR_OUT_OF_IP );

                goto Done;
            }
        }

        psendMsg->Head.RecursionDesired = 0;
        pQuery->dwExpireTime = 0;

        queueAndSendRecursiveQuery( pQuery, pDnsAddrArray );
    }

    Done:

    DnsAddrArray_Free( pDnsAddrArray );

    return status;
}



VOID
recursionServerFailure(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           status
    )
/*++

Routine Description:

    Recursion server failure.

    Send SERVER_FAILURE on recursion failure, but ONLY if question has
    NOT been answered.  If question answered send back.

Arguments:

    pQuery -- query to reply to
    
    status -- error that triggered the call to this function

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    STAT_INC( RecurseStats.RecursionFailure );

#if DBG
    if( pQuery->Head.QuestionCount != 1 )
    {
        Dbg_DnsMessage(
            "Recursion server failure on message:",
            pQuery );
        ASSERT( pQuery->Head.QuestionCount == 1 );
    }
#endif

    //
    //  if self-generated cache update query
    //

    if ( IS_CACHE_UPDATE_QUERY(pQuery) )
    {
        DNS_DEBUG( RECURSE, (
            "ERROR:  Recursion failure, on cache update query at %p\n"
            "    No valid response from any root servers\n",
            pQuery ));

        STAT_INC( RecurseStats.CacheUpdateFailure );

        //
        //  If status is DNSSRV_ERROR_OUT_OF_IP then we have reached a
        //  dead end of unreachable glue.
        //
    
        if ( status != DNSSRV_ERROR_OUT_OF_IP && SUSPENDED_QUERY( pQuery ) )
        {
            Recurse_ResumeSuspendedQuery( pQuery );
        }
        else
        {
            //
            //  Free all suspended packets - note in W2K3 we allow multiple
            //  levels of missing glue so we must travel up the suspended
            //  query chain and free all suspended packets.
            //
            
            PDNS_MSGINFO    psuspendedQuery = SUSPENDED_QUERY( pQuery );
            PDNS_MSGINFO    ppreviousSuspendedQuery;
            
            while ( psuspendedQuery )
            {
                ppreviousSuspendedQuery = SUSPENDED_QUERY( psuspendedQuery );
                SUSPENDED_QUERY( psuspendedQuery ) = NULL;
                Packet_Free( psuspendedQuery );
                psuspendedQuery = ppreviousSuspendedQuery;
            }
            
            //
            //  Free this message.
            //
            
            STAT_INC( RecurseStats.CacheUpdateFree );
            Packet_Free( pQuery );
        }
        return;
    }

    //
    //  already answered question
    //  recursion failure looking up additional records?
    //

    if ( pQuery->Head.AnswerCount > 0 )
    {
        DNS_DEBUG( RECURSE, (
            "Recursion failure, on answered query at %p\n"
            "    Sending response\n",
            pQuery ));
        ASSERT( pQuery->fDelete );
        STAT_INC( RecurseStats.PartialFailure );
        SET_OPT_BASED_ON_ORIGINAL_QUERY( pQuery );
        Send_Msg( pQuery, 0 );
        return;
    }

    //
    //  recursion/referral failure, on original question
    //
    //  if
    //      - have recursed question (have outstanding query)
    //      - NOT already gone through final wait
    //      - NOT past hard timeout
    //
    //  then requeue until final timeout, giving remote DNS a chance
    //  to respond
    //      - set expire time to end of final wait
    //      - set flag to indicate expiration is final expiration
    //

    if ( pQuery->fRecurseTimeoutWait )
    {
        STAT_INC( RecurseStats.FinalTimeoutExpired );
    }

    else if ( pQuery->fRecurseQuestionSent )
    {
        DWORD   deltaTime = DNS_TIME() - pQuery->dwQueryTime;

        if ( deltaTime < SrvCfg_dwRecursionTimeout )
        {
            pQuery->dwExpireTime = SrvCfg_dwRecursionTimeout - deltaTime;
            pQuery->fRecurseTimeoutWait = TRUE;

            PQ_QueuePacketWithXid(
                g_pRecursionQueue,
                pQuery );
            STAT_INC( RecurseStats.FinalTimeoutQueued );
            return;
        }
    }

    //
    //  otherwise failed
    //      - memory allocation failure
    //      - failure to get response to question within final timeout
    //

    DNS_DEBUG( RECURSE, (
        "Recursion failure on query at %p\n"
        "    Sending SERVER_FAILURE response\n",
        pQuery ));
    ASSERT( pQuery->fDelete );

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    STAT_INC( RecurseStats.ServerFailure );
}



//
//  Routines to process recursive response
//

VOID
Recurse_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Process response from another DNS server.

    Note:  Caller frees pResponse message.

Arguments:

    pResponse - ptr to response info

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    PDNS_MSGINFO    pquery;
    PDNS_MSGINFO    precurseMsg;
    DNS_STATUS      status;

    ASSERT( pResponse != NULL );
    ASSERT( pResponse->Head.IsResponse );

    DNS_DEBUG( RECURSE, (
        "Recurse_ProcessResponse() for packet at %p\n",
        pResponse ));

    STAT_INC( RecurseStats.Responses );

    //
    //  Locate matching query in recursion queue by XID.
    //

    pquery = PQ_DequeuePacketWithMatchingXid(
                g_pRecursionQueue,
                pResponse->Head.Xid );

    //
    //  no matching query?
    //
    //  this can happen if reponse comes back after timeout, or if when we
    //      send on multiple sockets
    //

    if ( !pquery )
    {
        IF_DEBUG( RECURSE )
        {
            EnterCriticalSection( & g_pRecursionQueue->csQueue );
            DNS_PRINT((
                "No matching recursive query for response at %p -- discarding\n"
                "    Response XID = 0x%04x\n",
                pResponse,
                pResponse->Head.Xid ));
            Dbg_PacketQueue(
                "Recursion packet queue -- no matching response",
                g_pRecursionQueue );
            LeaveCriticalSection( & g_pRecursionQueue->csQueue );
        }
        STAT_INC( RecurseStats.ResponseUnmatched );
        return;
    }

    DNS_DEBUG( RECURSE, (
        "Matched response at %p, to original query at %p\n",
        pResponse,
        pquery ));

    precurseMsg = pquery->pRecurseMsg;
    if ( !precurseMsg )
    {
        DnsDbg_Lock();
        Dbg_DnsMessage(
            "ERROR:  Queued recursive query without, message info\n",
            pquery );
        Dbg_DnsMessage(
            "Response packet matched to query\n",
            pResponse );
        DnsDbg_Unlock();
        ASSERT( FALSE );
        return;
    }

    MSG_ASSERT( pquery, precurseMsg->pRecurseMsg == pquery );
    MSG_ASSERT( pquery, precurseMsg->Head.Xid == pResponse->Head.Xid );

    //
    //  cleanup TCP recursion
    //      - close connection
    //      - reset for UDP is further queries
    //
    //  should NEVER have TCP response when recursion set for UDP;
    //  when reset to UDP, socket is closed and should be impossible
    //  to receive TCP response;  only possiblity is TCP response received
    //  then context switch to recursion timeout thread which shuts down
    //  TCP on recurse message
    //

    if ( precurseMsg->fTcp )
    {
        IF_DEBUG( RECURSE2 )
        if ( pResponse->fTcp )
        {
            STAT_INC( RecurseStats.TcpResponse );
            
            //            
            //  This is a valid assert BUT there are cases where TCP
            //  retries can cause us to match a response with an
            //  earlier send's XID. This is a good match but the
            //  sockets won't match so this assert must be disabled.
            //
            //  ASSERT( pResponse->Socket == precurseMsg->Socket );
            //
        }
        else
        {
            DnsDbg_Lock();
            DNS_DEBUG( ANY, (
                "WARNING:  UDP response, on query %p doing TCP recursion!\n"
                "    query recursive msg = %p\n",
                pquery,
                precurseMsg ));
            Dbg_DnsMessage(
                "Recurse message set for TCP on UDP response",
                precurseMsg );
            Dbg_DnsMessage(
                "Response message",
                pResponse );
            DnsDbg_Unlock();
        }
        stopTcpRecursion( precurseMsg );
    }

    else if ( pResponse->fTcp )
    {
        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "WARNING:  TCP response, on query %p doing UDP recursion!\n"
            "    query recursive msg = %p\n"
            "    This is possible if gave up on TCP connection and continued\n"
            "    recursion with UDP\n",
            pquery,
            precurseMsg ));
        Dbg_DnsMessage(
            "Response message:",
            pResponse );
        Dbg_DnsMessage(
            "Recurse message:",
            precurseMsg );
        DnsDbg_Unlock();
    }

    //
    // If we added an OPT RR to the original query that appears to have
    // caused the target server to return failure, we must retry the
    // query without the OPT RR.
    //

    if ( ( pResponse->Head.ResponseCode == DNS_RCODE_FORMERR ||
           pResponse->Head.ResponseCode == DNS_RCODE_NOTIMPL ) &&
         precurseMsg->Opt.wOptOffset )
    {
        DNS_DEBUG( EDNS, (
            "remote server returned error so resend without OPT RR:\n"
            "    original_query=%p recurse_msg=%p remote_rcode=%d remote_ip=%s\n",
            pquery,
            precurseMsg,
            pResponse->Head.ResponseCode,
            DNSADDR_STRING( &pResponse->RemoteAddr ) ));

        ASSERT( precurseMsg->Head.AdditionalCount );

        precurseMsg->pCurrent = DNSMSG_OPT_PTR( precurseMsg );
        precurseMsg->MessageLength =
            ( WORD ) DNSMSG_OFFSET( precurseMsg, precurseMsg->pCurrent );
        --precurseMsg->Head.AdditionalCount;
        precurseMsg->Opt.wOptOffset = 0;
        CLEAR_SEND_OPT( precurseMsg );
        precurseMsg->fDelete = FALSE;
        precurseMsg->Head.IsResponse = 0;

        //
        //  Reset query expire time. It will be set to the proper value
        //  when it is queued.
        // 

        pquery->dwExpireTime = 0;

        //
        //  In case the original query was sent via Send_Multiple,
        //  recopy the response source address to the outbound message.
        //

        DnsAddr_Copy( &precurseMsg->RemoteAddr, &pResponse->RemoteAddr );

        queueAndSendRecursiveQuery( pquery, NULL );

        //
        //  Remember that this server does not support EDNS so we can 
        //  avoid unnecessary retries in the future.
        //

        Remote_SetSupportedEDnsVersion(
            &pResponse->RemoteAddr,
            NO_EDNS_SUPPORT );
        return;
    } 

    //
    //  Validate the response.
    //

    if ( !Msg_NewValidateResponse( pResponse, precurseMsg, 0, 0 ) )
    {
        STAT_INC( RecurseStats.ResponseMismatched );

        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "WARNING: dequeued query is not valid for response\n"
            "    dequeued query recurse msg %p   response %p\n",
            precurseMsg,
            pResponse ));
        Dbg_DnsMessage(
            "Response received (not valid for query with same XID)",
            pResponse );
        Dbg_DnsMessage(
            "Query recurse msg with XID matching received response",
            precurseMsg );
        DnsDbg_Unlock();
        //  MSG_ASSERT( pquery, FALSE );
        Packet_Free( pquery );
        return;
    }

    //
    //  if self-generated cache update query
    //
    //      - write response into cache
    //      - return when found valid info, or search all NS
    //

    if ( IS_CACHE_UPDATE_QUERY(pquery) )
    {
        ASSERT( pquery->Head.Xid == DNS_CACHE_UPDATE_QUERY_XID );

        if ( SUSPENDED_QUERY(pquery) )
        {
            processCacheUpdateQueryResponse(
                pResponse,
                pquery );
        }
        else
        {
            processRootNsQueryResponse(
                pResponse,
                pquery );
        }
        return;
    }

    //
    //  truncated response
    //
    //  take simple approach here and NEVER cache a truncated response,
    //  go immediately and establish TCP connection
    //
    //  if TCP response has Truncation bit set, then it's a bad packet,
    //  ignore it and restart the recursion on the original query
    //
    //  DEVNOTE: need to be more intelligent on using TCP recursion
    //      if UDP query, should be able to use UDP response --
    //      even if we can't cache it all
    //      cache first -- obeying truncation rules -- then use response
    //      if possible
    //

    if ( pResponse->Head.Truncation )
    {
        //  if UDP response, attempt TCP recursion
        //
        //  note, connection failures are handled through callback
        //  before function return, all we need to do is fail back up
        //  call stack

        if ( !pResponse->fTcp )
        {
            startTcpRecursion(
                pquery,
                pResponse );
            return;
        }

        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "ERROR:  TCP response with truncation bit set!!!!\n"
            "    BAD DNS server -- possibly configured with too much DNS data at this node\n",
            pResponse ));
        Dbg_DnsMessage(
            "Response message:",
            pResponse );
        Dbg_DnsMessage(
            "Recurse message:",
            precurseMsg );
        DnsDbg_Unlock();

        ASSERT( !pResponse->fTcp );

        Recurse_Question(
            pquery,
            NULL );
        return;
    }

    //  any response cancels final wait state as may lead to new DNS
    //  servers to recurse to

    pquery->fRecurseTimeoutWait = FALSE;

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pquery, NULL );

    //
    //  If we found an OPT in the response, save the remote server's
    //  supported EDNS version.
    //  Note: we could probably accept other RCODEs besides NOERROR.
    //

    if ( pResponse->Opt.fFoundOptInIncomingMsg &&
         pResponse->Head.ResponseCode == DNS_RCODE_NOERROR )
    {
        Remote_SetSupportedEDnsVersion(
            &pResponse->RemoteAddr,
            pResponse->Opt.cVersion );
    } 

    //
    //  Make sure OPT flag is turned on for next search iteration.
    // 

    SET_SEND_OPT( pquery );
    SET_SEND_OPT( precurseMsg );

    switch ( status )
    {
    case ERROR_SUCCESS:

        //
        //  recursing original question
        //
        //  respond with response packet?
        //      - if no need to follow CNAME (other return code below)
        //      - if response is answer (not delegation)
        //      - if has required additional data
        //          - forwarding so full recursive response
        //          OR
        //          - query for type A (or other type that doesn't generate
        //          additional records) so no additional records can be
        //          OR
        //          - additional count > authority count; so presumably
        //          already have additional data for at least one answer
        //
        //  otherwise (delegation or potentially incomplete answer)
        //      => continue
        //
        //  Note, the problem to be eliminated by the additional data check:
        //      Across zone MX record
        //          foo.bar MX  10  mail.utexas.edu
        //      Iterative query of zone bar, brings response BUT does NOT include
        //          A record for host.
        //
        //  Now obviously we could try and recontruct packet, and "see" if any
        //  additional data needs to be queried for, but this is extraordinarily
        //  difficult.  Better is to just rebuild packet if we can't establish
        //  existence of data ourselves.  Making all the checks is important because
        //  forwarding packet gives MUCH more reliable response to client and is faster.
        //
        //  DEVNOTE: forward all successful forwarders responses for orig question?
        //      every valid forwarding response for original question should
        //      be forwarderable;  if it's not forwarder failed
        //

        if ( RECURSING_ORIGINAL_QUESTION( pquery ) )
        {
            if ( pResponse->Head.AnswerCount
                    &&
                ( IS_FORWARDING( pquery ) ||
                  IS_NON_ADDITIONAL_GENERATING_TYPE( pquery->wTypeCurrent ) ||
                  pResponse->Head.AdditionalCount > pResponse->Head.NameServerCount )
                    &&
                Send_RecursiveResponseToClient( pquery, pResponse ) )
            {
                break;
            }

            //  response was delegation or could not do direct send of
            //      response (eg. big TCP response to UDP client),
            //      then continue this query

            Answer_ContinueCurrentLookupForQuery( pquery );
            break;
        }

        //
        //  chasing CNAME or Additional data
        //      - on answer or delegation, continue we'll write records to
        //      response or recurse again with info from delegation
        //      - on authoritative empty response, just we write no records
        //      so move on to next query (avoiding possible spin)
        //

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_INFO_NO_RECORDS:

        //  This is an empty auth response. Send response to client if we 
        //  are working on the original query.

        if ( RECURSING_ORIGINAL_QUESTION( pquery ) &&
            Send_RecursiveResponseToClient( pquery, pResponse ) )
        {
            break;
        }
        STAT_INC( RecurseStats.ContinueNextLookup );
        Answer_ContinueNextLookupForQuery( pquery );
        break;

    case DNS_ERROR_NODE_IS_CNAME:

        //  if answer contains "unchased" cname, must build or own response
        //  and follow CNAME

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_ERROR_NAME_NOT_IN_ZONE:
    case DNS_ERROR_UNSECURE_PACKET:

        //  if unable to cache a record outside of zone of responding NS
        //  hence MUST continue query, may not send direct response

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_ERROR_RCODE_NAME_ERROR:
    case DNS_ERROR_RCODE_NXRRSET:

        //  name error or no RR set
        //      - if for original query, send on response
        //      - if chasing CNAME or Additional, then move on to
        //      next query as we can write no records for this query

        if ( RECURSING_ORIGINAL_QUESTION(pquery) &&
            Send_RecursiveResponseToClient( pquery, pResponse ) )
        {
            break;
        }
        else
        {
            STAT_INC( RecurseStats.ContinueNextLookup );
            Answer_ContinueNextLookupForQuery( pquery );
            break;
        }

    case DNS_ERROR_RCODE:
    case DNS_ERROR_BAD_PACKET:
    case DNS_ERROR_INVALID_NAME:
    case DNS_ERROR_CNAME_LOOP:

        //
        //  bad response
        //      - problem with remote server
        //      - busted name, or RR data format error detected
        //      - CNAME given generates loop
        //
        //  continue trying current lookup with other servers
        //

        //
        //  DEVNOTE: message errors could indicate corrupted packet
        //              and be worth redoing query to this NS?  problem
        //              would be termination to avoid loop
        //
        //  DEVNOTE: removing CNAME loop?  if new info is good?
        //
        //      would want to delete entire loop in cache and allow rebuild
        //

        pquery->fQuestionCompleted = FALSE;
        STAT_INC( RecurseStats.ContinueCurrentRecursion );

        Recurse_Question(
            pquery,
            NULL );
        break;

    case DNS_ERROR_RCODE_SERVER_FAILURE:

        //
        //  local server failure to process packet
        //      -- some problem creating nodes or records, (out of memory?)
        //
        //  send server failure message
        //      this frees pquery

        ASSERT( pquery->fDelete );

        Reject_Request(
            pquery,
            DNS_RCODE_SERVER_FAILURE,
            0 );
        break;

    default:

        // must have added new error code to function

        DNS_PRINT((
            "ERROR:  unknown status %p (%d) from CacheMessageResourceRecords()\n",
            status, status ));
        MSG_ASSERT( pquery, FALSE );
        Packet_Free( pquery );
        return;
    }
}



//
//  Initialization and cleanup
//

BOOL
Recurse_InitializeRecursion(
    VOID
    )
/*++

Routine Description:

    Initializes recursion to other DNS servers.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    //
    //  create recursion queue
    //      - set non-zero timeout\retry
    //      - set timeout to recursion retry timeout
    //      - no event on queuing
    //      - no queuing flags
    //
    //  JENHANCE:  what recursion really needs is XID hash
    //

    if ( SrvCfg_dwRecursionRetry == 0 )
    {
        SrvCfg_dwRecursionRetry = DEFAULT_RECURSION_RETRY;
    }

    ASSERT( SrvCfg_dwRecursionTimeout != 0 );
    if ( SrvCfg_dwRecursionTimeout == 0 )
    {
        SrvCfg_dwRecursionTimeout = DEFAULT_RECURSION_TIMEOUT;
    }

    ASSERT( SrvCfg_dwAdditionalRecursionTimeout != 0 );
    if ( SrvCfg_dwAdditionalRecursionTimeout == 0 )
    {
        SrvCfg_dwAdditionalRecursionTimeout = DEFAULT_RECURSION_TIMEOUT;
    }

    g_pRecursionQueue = PQ_CreatePacketQueue(
                            "Recursion",
                            0,                              //  flags
                            SrvCfg_dwRecursionRetry,        //  timeout
                            RECURSION_QUEUE_MAX_LENGTH );
    if ( !g_pRecursionQueue )
    {
        goto RecursionInitFailure;
    }

    //  init root NS query

    g_NextRootNsQueryTime = 0;

    //
    //  init remote list
    //

    if ( !Remote_ListInitialize() )
    {
        goto RecursionInitFailure;
    }

    //
    //  create recusion timeout thread
    //

    if ( !Thread_Create(
                "Recursion Timeout",
                Recurse_RecursionTimeoutThread,
                NULL,
                0 ) )
    {
        goto RecursionInitFailure;
    }

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    DNS_DEBUG( INIT, ( "Recursion queue at %p\n", g_pRecursionQueue ));
    return TRUE;

RecursionInitFailure:

    DNS_LOG_EVENT(
        DNS_EVENT_RECURSION_INIT_FAILED,
        0,
        NULL,
        NULL,
        GetLastError() );
    return FALSE;
}   //  Recurse_InitializeRecursion



VOID
Recurse_CleanupRecursion(
    VOID
    )
/*++

Routine Description:

    Cleanup recursion for restart.

Arguments:

    None

Return Value:

    None

--*/
{
    //  cleanup recursion queue

    PQ_CleanupPacketQueueHandles( g_pRecursionQueue );

    //  cleanup remote list

    Remote_ListCleanup();
}



//
//  TCP Recursion
//

VOID
recurseConnectCallback(
    IN OUT  PDNS_MSGINFO    pRecurseMsg,
    IN      BOOL            fConnected
    )
/*++

Routine Description:

    Callback when TCP forwarding routines complete connect.

    If connected -- send recursive query
    If not -- continue lookup on query

Arguments:

    pRecurseMsg -- recursive message

    fConnected -- connect to remote DNS completed

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pquery;

    ASSERT( pRecurseMsg );
    ASSERT( !pRecurseMsg->pConnection );

    DNS_DEBUG( RECURSE, (
        "recurseConnectCallback( %p )\n"
        "    remote DNS = %s\n"
        "    connect successful = %d\n",
        pRecurseMsg,
        DNSADDR_STRING( &pRecurseMsg->RemoteAddr ),
        fConnected ));

    pquery = pRecurseMsg->pRecurseMsg;

    ASSERT( pquery );
    ASSERT( pquery->fQuestionRecursed == TRUE );

    //
    //  send recursive query
    //
    //  note:  nothing special to setup query, same query as UDP request
    //  to the server -- uses same logic as recursion to a new server
    //
    //  clear pConnection ptr, simply as indication that connection no longer
    //  "owns" this message -- i.e. there's no ptr to message in connection
    //  object AND hence message will no longer be cleaned up by timeouts
    //  from the connection list;  (not sure this is best approach, but it
    //  squares with typical TCP recv -- pConnection set NULL when message
    //  dispatched to normal server processing)
    //

    if ( fConnected )
    {
        ASSERT( pRecurseMsg->fTcp );

        STAT_INC( RecurseStats.TcpQuery );

        sendRecursiveQuery(
            pquery,
            &pRecurseMsg->RemoteAddr,
            SrvCfg_dwForwardTimeout );
    }

    //
    //  connection failed
    //      continue with this query
    //

    else
    {
        IF_DEBUG( RECURSE )
        {
            Dbg_DnsMessage(
                "Failed TCP connect recursive query",
                pRecurseMsg );
            DNS_PRINT((
                "Rerecursing query %p after failed recursive TCP connect\n",
                pquery ));
        }
        ASSERT( !pRecurseMsg->fTcp );

        Recurse_Question(
            pquery,
            NULL );
    }
}



BOOL
startTcpRecursion(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Do TCP recursion for query.

    Send TCP recursive query, for desired query.
    Note:

Arguments:

    pQuery -- query to recurse;  note this routine takes control of pQuery,
        requeuing or ultimately freeing;  caller MUST NOT free

    pResponse -- truncated response from remote DNS, that causes TCP recursion

Return Value:

    TRUE if successfully launch TCP connection.
    FALSE on allocation failure.

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_ADDR       pdnsaddr = &pResponse->RemoteAddr;

    IF_DEBUG( RECURSE )
    {
        DNS_PRINT((
            "Encountered truncated recursive response %p,\n"
            "    for query %p\n"
            "    TCP recursion to server %s\n",
            pResponse,
            pQuery,
            DNSADDR_STRING( pdnsaddr ) ));
        Dbg_DnsMessage(
            "Truncated recursive response:",
            pResponse );
    }

    TEST_ASSERT( pResponse->fTcp == FALSE );

    STAT_INC( RecurseStats.TcpTry );

    //
    //  make connection attempt
    //
    //  on failure, the recurseConnectCallback() callback
    //  was called (with fConnected=FALSE);
    //  it will continue Recurse_Question() on query
    //  so we must not touch query -- it may well be long gone
    //  by now;  instead return up call stack to UDP receiver
    //

    return  Tcp_ConnectForForwarding(
                pQuery->pRecurseMsg,
                pdnsaddr,
                recurseConnectCallback );
}



VOID
stopTcpRecursion(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Stop TCP recursion for query.
        - close TCP connection
        - reset recursion info for further queries as UDP

    Note caller does any query continuation logic, which may be
    requerying (from timeout thread) or processing TCP response
    (from worker thread).

Arguments:

    pMsg -- recurse message using TCP

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    DNS_DEBUG( RECURSE, (
        "stopTcpRecursion() for recurse message at %p\n",
        pMsg ));

    //
    //  delete connection to server
    //
    //  note:  we don't cleanup connection;
    //  TCP thread cleans up connection when connection times out;
    //  if we cleanup, would free message that TCP thread could be
    //  processing right now;
    //
    //  DEVNOTE: TCP connection removal
    //  only interesting thing to do here would be to move up timeout
    //  to now;  however, unless you're going to wake TCP thread, that's
    //  probably useless as next select() wakeup is almost certainly for
    //  this timeout (unless lots of outbound TCP connections)
    //
    //  once completion port, can try closing handle, (but who cleans up
    //  message is still problematic -- another thread could have just
    //  recv'd and be processing message);  key element would be making
    //  sure message complete\non-complete before redropping i/o
    //

    // Tcp_ConnectionDeleteForSocket( pMsg->Socket, NULL );

    ASSERT( pMsg->pRecurseMsg );
    ASSERT( pMsg->fTcp );

    STAT_INC( PrivateStats.TcpDisconnect );

    //
    //  reset for UDP query
    //

    pMsg->pConnection = NULL;
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;
}



//
//  Cache update routines
//

BOOL
Recurse_SendCacheUpdateQuery(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeDelegation,
    IN      WORD            wType,
    IN      PDNS_MSGINFO    pQuerySuspended
    )
/*++

Routine Description:

    Send query for desired node and type to update info in cache.

    This is used for for root NS and for finding NS-host glue A records.

Arguments:

    pNode -- node to query at

    wType -- type of query

    pQuerySuspended -- query being suspended while making this query;  NULL if
        no query being suspended

Return Value:

    TRUE -- making query, if pQuerySuspended given it should be suspended
    FALSE -- unable to make query

--*/
{
    PDNS_MSGINFO    pquery;

    DNS_DEBUG( RECURSE, (
        "sendServerCacheUpdateQuery() for node label %s, type %d\n",
        pNode->szLabel,
        wType ));

    //
    //  Make sure we are not trying to trying to send a cache update query
    //  for the same query node we have already suspended a query for.
    //
    
    if ( pQuerySuspended && pQuerySuspended->pnodeCurrent == pNode )
    {
        DNS_DEBUG( RECURSE, (
            "ERROR: recursing for name already suspended\n" ));
        pQuerySuspended->fRecurseTimeoutWait = TRUE;
        return FALSE;
    }
    
    //
    //  if in authoritative zone, query pointless
    //

    if ( IS_AUTH_NODE( pNode ) )
    {
        DNS_DEBUG( RECURSE, (
            "ERROR: recursing for root-NS or glue in authoritative zone\n" ));
        return FALSE;
    }

    //
    //  create/clear message info structure
    //

    pquery = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pquery )
    {
        return FALSE;
    }

    //  cache update query

    if ( !Msg_WriteQuestion(
                pquery,
                pNode,
                wType ) )
    {
        DNS_PRINT(( "ERROR:  Unable to write cache update query\n" ));
    }

    STAT_INC( RecurseStats.CacheUpdateAlloc );

    //
    //  suspended query?
    //      - limit total attempts for any given query
    //      both of these are supposed to have been done when verifying whether
    //          node has "chaseable glue"
    //   save off node we are querying so don't query it again for glue
    //

    if ( pQuerySuspended )
    {
        //  jwesth Nov 2001: 2 levels of missing glue is now allowed
        //  ASSERT( !IS_CACHE_UPDATE_QUERY(pQuerySuspended) );
        STAT_INC( RecurseStats.SuspendedQuery );
    }

    //
    //  only other currently supported type is root-NS query
    //      (see call below)

    ELSE_ASSERT( pNode == DATABASE_CACHE_TREE && wType == DNS_TYPE_NS );


    //
    //  tag query to easily id when response comes back
    //  save info
    //      - need current node to relaunch query if bad response or timeout
    //      - need current type for checking response
    //      - other pquery parameters are NOT needed as we'll never go write
    //          answers for this query
    //

    ASSERT( !pquery->pRecurseMsg );

    pquery->Socket = DNS_CACHE_UPDATE_QUERY_SOCKET;
    DnsAddr_Reset( &pquery->RemoteAddr );
    pquery->Head.Xid = DNS_CACHE_UPDATE_QUERY_XID;

    SUSPENDED_QUERY( pquery ) = pQuerySuspended;

    pquery->dwQueryTime = DNS_TIME();

    SET_TO_WRITE_ANSWER_RECORDS( pquery );
    pquery->fRecurseIfNecessary = TRUE;
    pquery->wTypeCurrent        = wType;
    pquery->pnodeCurrent        = pNode;
    pquery->pnodeRecurseRetry   = pNode;
    pquery->pnodeDelegation     = pNodeDelegation;

    ASSERT( !pquery->pnodeClosest       &&
            !pquery->pzoneCurrent       &&
            !pquery->pnodeGlue          &&
            !pquery->pnodeCache         &&
            !pquery->pnodeCacheClosest );

    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Server generated query being sent via recursion:",
            pquery );
    }

    Recurse_Question(
        pquery,
        pNode );
    return TRUE;

}   //  Recurse_SendCacheUpdateQuery



VOID
Recurse_ResumeSuspendedQuery(
    IN OUT  PDNS_MSGINFO    pUpdateQuery
    )
/*++

Routine Description:

    Resume query suspended for cache update query.

Arguments:

    pUpdateQuery -- cache update query

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    psuspendedQuery = SUSPENDED_QUERY( pUpdateQuery );
    
    DNS_DEBUG( RECURSE, (
        "Recurse_ResumeSuspendedQuery( %p )\n"
        "    suspended query %p\n",
        pUpdateQuery,
        psuspendedQuery ));

    if ( psuspendedQuery )
    {
        STAT_INC( RecurseStats.ResumeSuspendedQuery );

        Recurse_Question(
            psuspendedQuery,
            NULL );             //  resume hunt for NS at same node in tree
    }

    //  only other query type is root NS query

    ELSE_ASSERT( pUpdateQuery->wTypeCurrent == DNS_TYPE_NS &&
                 pUpdateQuery->pnodeCurrent == DATABASE_CACHE_TREE );


    STAT_INC( RecurseStats.CacheUpdateFree );
    Packet_Free( pUpdateQuery );
}



VOID
processCacheUpdateQueryResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Process response to query made to update cache file entry.

Arguments:

    pResponse - ptr to response info;  caller must free

    pQuery - ptr to cache update query;  query is freed or requeued

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS      status;
    PDNS_MSGINFO    pquerySuspended;
    BOOL            fcnameAnswer = FALSE;

    ASSERT( pResponse != NULL );
    ASSERT( pQuery != NULL );

    DNS_DEBUG( RECURSE, ( "processCacheUpdateQueryResponse()\n" ));
    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Cache update query response:",
            pResponse );
    }
    STAT_INC( RecurseStats.CacheUpdateResponse );

    //
    //  Recover suspended query (if any). Note that the suspended query
    //  can be a suspended query. There can be a chain of suspended queries
    //  leading back to the original query.
    //

    pquerySuspended = SUSPENDED_QUERY( pQuery );
    if ( !pquerySuspended )
    {
        ASSERT( FALSE );
        STAT_INC( RecurseStats.CacheUpdateFree );
        Packet_Free( pQuery );
        return;
    }

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pQuery, &fcnameAnswer );

    #if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RECURSE, (
            "processCacheUpdateQueryResponse: cache records returned %d\n",
            status ));
    }
    #endif

    switch ( status )
    {
    case ERROR_SUCCESS:

        //
        //  two possibilities
        //      - wrote NS A record => resume suspended query
        //      - wrote delegation => continue looking up NS info
        //

        if ( pResponse->Head.AnswerCount )
        {
            //
            //  If we got a CNAME answer but the server configuration does
            //  not allow CNAMEs at delegations, resume query without
            //  rebuilding the NS list. Rebuilding the NS list is
            //  pointless since we have no new information. It is also
            //  dangerous since it will cause the server to go into a tight
            //  loop and resend the cache update query because rebuilding
            //  the NS list causes the server to forget that this NS has
            //  already been tried.
            //

            if ( !fcnameAnswer || SrvCfg_dwAllowCNAMEAtNS )
            {
                //  New information: rebuild NS list before resume.
                Remote_ForceNsListRebuild( pquerySuspended );
            }

            Recurse_ResumeSuspendedQuery( pQuery );
        }
        else
        {
            DNS_DEBUG( RECURSE, (
                "Cache update response at %p provides delegation\n"
                "    Continuing recursion of cache update query at %p\n",
                pResponse,
                pQuery ));

            STAT_INC( RecurseStats.CacheUpdateRetry );
            pQuery->fQuestionCompleted = FALSE;
            Recurse_Question(
                pQuery,
                pQuery->pnodeCurrent );
        }
        break;

    case DNS_INFO_NO_RECORDS:

        //  Empty authoritative response => resume suspended query

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p was empty auth response\n"
            "    Resuming suspended query at %p\n",
            pResponse,
            pquerySuspended ));
        Remote_ForceNsListRebuild( pquerySuspended );
        Recurse_ResumeSuspendedQuery( pQuery );
        break;

    case DNS_ERROR_RCODE_NAME_ERROR:
    case DNS_ERROR_CNAME_LOOP:

        //  failed to get useful response
        //  continue suspended query hopefully, there's another NS that
        //  we can track down

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p useless, no further attempt will\n"
            "    be made to update info for this name server\n"
            "    Resuming suspended query at %p\n",
            pResponse,
            pquerySuspended ));

        Recurse_ResumeSuspendedQuery( pQuery );
        break;

    case DNS_ERROR_RCODE:
    case DNS_ERROR_BAD_PACKET:
    case DNS_ERROR_INVALID_NAME:

        //  bad response
        //      - problem with remote server
        //      - busted name, or RR data format error detected
        //  continue attempt to update cache with other servers

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p bad or invalid\n"
            "    Continuing recursion of cache update query at %p\n",
            "    Resuming suspended query at %p\n",
            pResponse,
            pQuery ));

        STAT_INC( RecurseStats.CacheUpdateRetry );
        Recurse_Question(
            pQuery,
            NULL );
        break;

    case DNS_ERROR_NAME_NOT_IN_ZONE:

        //
        //  The response contains at least one RR that is outside zone.
        //  Hopefully the response contained something useful as well.
        //  Invalidate the NS list if the response contains an answer
        //  RR and resume the suspended query.
        //
        
        DNS_DEBUG( RECURSE, (
            "Cache update response %p contains data that is outside zone\n"
            "    Resuming suspended query at %p\n",
            pResponse,
            pQuery ));

        if ( pResponse->Head.AnswerCount )
        {
            Remote_ForceNsListRebuild( pquerySuspended );
        }
        Recurse_ResumeSuspendedQuery( pQuery );
        break;
        
    case DNS_ERROR_RCODE_SERVER_FAILURE:
    default:

        //  local server failure to process packet
        //      -- some problem creating nodes or records, (out of memory?)
        //
        //  send server failure message
        //      this frees suspended query

        DNS_DEBUG( RECURSE, (
            "Server failure on cache update response at %p\n", pQuery ));

        Recurse_ResumeSuspendedQuery( pQuery );
        break;
    }
}



//
//  Cache update -- root-NS query
//

VOID
sendRootNsQuery(
    VOID
    )
/*++

Routine Description:

    Send query for root NS.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  if recently queried, don't requery
    //

    if ( g_NextRootNsQueryTime >= DNS_TIME() )
    {
        DNS_DEBUG( RECURSE, (
            "sendRootNsQuery() -- skipping\n"
            "    g_NextRootNsQueryTime = %d\n"
            "    DNS_TIME = %d\n",
            g_NextRootNsQueryTime,
            DNS_TIME() ));
        return;
    }

    DNS_DEBUG( RECURSE, ( "sendRootNsQuery()\n" ));

    g_NextRootNsQueryTime = DNS_TIME() + ROOT_NS_QUERY_RETRY_TIME;
    STAT_INC( RecurseStats.RootNsQuery );

    //
    //  call cache update query
    //      - query database root
    //      - for NS
    //

    Recurse_SendCacheUpdateQuery(
        DATABASE_CACHE_TREE,
        NULL,                   //  no delegation
        DNS_TYPE_NS,
        NULL );                 //  no suspended query
}



VOID
processRootNsQueryResponse(
    PDNS_MSGINFO    pResponse,
    PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Process response to query made to update cache file entry.

Arguments:

    pResponse - ptr to response info;  caller must free

    pQuery - ptr to cache update query;  query is freed or requeued

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS  status;

    ASSERT( pResponse != NULL );
    ASSERT( pQuery != NULL );

    DNS_DEBUG( RECURSE, ( "processRootNsQueryResponse()\n" ));
    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Root NS query response:",
            pResponse );
    }

    STAT_INC( RecurseStats.RootNsResponse );

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pQuery, NULL );

    //
    //  if successfully read records, and server if authoritative,
    //      then we are done
    //
    //  DEVNOTE: write back cache file or at least mark dirty
    //

    if ( status == ERROR_SUCCESS
            &&
        ( pResponse->Head.Authoritative
            ||
          IS_FORWARDING(pQuery) ) )
    {
        DNS_DEBUG( RECURSE, (
            "Successfully wrote root NS query response at %p\n",
            pResponse ));
        IF_DEBUG( RECURSE2 )
        {
            Dbg_DnsMessage(
                "Root NS query now being freed:",
                pQuery );
        }

        STAT_INC( RecurseStats.CacheUpdateFree );
        Packet_Free( pQuery );
        return;
    }

    //
    //  any failure processing packet, or non-authoritative response
    //      keep trying servers, possibly using any information cached
    //      from this packet
    //
    //  note query freed on successful termination (above block) or
    //      out of NS, recursionServerFailure()
    //

    else
    {
        DNS_DEBUG( RECURSE, (
            "Root NS query caching failure %p or non-authoritative response at %p\n",
            status,
            pResponse ));
        STAT_INC( RecurseStats.CacheUpdateRetry );
        Recurse_Question(
            pQuery,
            NULL );
        return;
    }
}



//
//  Recursion timeout thread
//

DWORD
Recurse_RecursionTimeoutThread(
    IN      LPVOID      Dummy
    )
/*++

Routine Description:

    Thread to retry timed out requests on the recursion queue.

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pquery;                     // timed out query
    DWORD           err;
    DWORD           timeout;                    // next timeout
    DWORD           timeoutWins = ULONG_MAX;    // next WINS timeout

    //
    //  this thread keeps current time which allows all other
    //  threads to skip the system call
    //

    UPDATE_DNS_TIME();

    DNS_DEBUG( RECURSE, (
        "Starting recursion timeout thread at %d\n",
        DNS_TIME() ));

    //
    //  loop until service exit
    //
    //  execute this loop whenever a packet on the queue times out
    //      or
    //  once every timeout interval to check on the arrival of new
    //      packets in the queue
    //

    while ( TRUE )
    {
        //  Check and possibly wait on service status
        //  doing this at top of loop, so we hold off any processing
        //  until zones are loaded

        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread\n" ));
            return 1;
        }

        UPDATE_DNS_TIME();

        //
        //  Verify \ fix UDP receive
        //

        UDP_RECEIVE_CHECK();

        //
        //  Timed out recursion queries?
        //      - find original query and retry with next server
        //        OR
        //      - get interval to next possible timeout
        //

        while ( pquery = PQ_DequeueTimedOutPacket(
                            g_pRecursionQueue,
                            & timeout ) )
        {
            DNS_DEBUG( RECURSE, (
                "Recursion timeout of query at %p (total time %d)\n",
                pquery,
                TIME_SINCE_QUERY_RECEIVED( pquery ) ));

            MSG_ASSERT( pquery, pquery->pRecurseMsg );
            MSG_ASSERT( pquery, pquery->fQuestionRecursed );
            MSG_ASSERT( pquery, pquery->fRecurseQuestionSent );

            STAT_INC( RecurseStats.PacketTimeout );
            PERF_INC( pcRecursiveTimeOut );          // PerfMon hook

            ++pquery->nTimeoutCount;

            #if 1
            {
                //
                //  We must record that the remote server timed out!
                //  JJW: can't do it this way - we have no way to know who the
                //  frig timed out? what if we did a multiple send - we don't
                //  know which server to kill... but it's okay - it's enough
                //  that we don't ever improve a timed out server's priority - 
                //  that will keep it from being used often
                //

                PNS_VISIT_LIST  pvisitList = ( PNS_VISIT_LIST )( pquery->pNsList );
                PNS_VISIT       pvisitLast;

                //  ASSERT( pvisitList->VisitCount > 0 );

                if ( pvisitList && pvisitList->VisitCount > 0 )
                {
                    pvisitLast =
                        &pvisitList->NsList[ pvisitList->VisitCount - 1 ];
                    Remote_UpdateResponseTime(
                        &pvisitLast->IpAddress,
                        0,                          //  response time in usecs
                        TIME_SINCE_QUERY_RECEIVED( pquery ) );  //  timeout
                }
            }
            #endif

            //
            //  timeout of FINAL recursion wait => send SERVER_FAILURE
            //

            if ( pquery->fRecurseTimeoutWait )
            {
                recursionServerFailure( pquery, 0 );
                continue;
            }

            //
            //  cleanup TCP recursion
            //      - close connection
            //      - reset for UDP is further queries
            //

            if ( pquery->pRecurseMsg->fTcp )
            {
                stopTcpRecursion( pquery->pRecurseMsg );
            }

            //
            //  If are recursing for additional RRs and this query has
            //  been in progress for a significant amount of time, return
            //  what we've got to the client now.
            //

            if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS( pquery ) &&
                TIME_SINCE_QUERY_RECEIVED( pquery ) >
                    SrvCfg_dwAdditionalRecursionTimeout )
            {
                DNS_DEBUG( RECURSE, (
                    "Query %p was received %d seconds ago and is still "
                    "chasing additional data\n"
                    "    sending current result to client now (max is %d seconds)\n",
                    pquery,
                    TIME_SINCE_QUERY_RECEIVED( pquery ),
                    SrvCfg_dwAdditionalRecursionTimeout ));

                pquery->MessageLength = DNSMSG_CURRENT_OFFSET( pquery );

                //
                //  We may be unable to send the response to the client if
                //  there is an issue with EDNS packet sizes. If the client's
                //  advertised packet size is smaller than the size of answer 
                //  we've accumulated, we need to regenerate the answer so that 
                //  it can be sent to the client.
                //

                if ( !Send_RecursiveResponseToClient( pquery, pquery ) )
                {
                    Answer_ContinueCurrentLookupForQuery( pquery );
                }
                continue;
            }

            //
            //  resend to next NS or forwarder
            //

            Recurse_Question(
                pquery,
                NULL );
        }

        //  Recursion timeout may have taken up some cycles,
        //  so reset timer

        UPDATE_DNS_TIME();

        DNS_DEBUG( OFF, (
            "RTT after r-queue before WINS at %d\n",
            DNS_TIME() ));


        //
        //  Timed out WINS packet?
        //      - dequeue timed out packets
        //      - continue WINS lookup if more WINS servers
        //      - otherwise continue lookup on query
        //          - NAME_ERROR if lookup for original question
        //      OR
        //      - get interval to next possible timeout
        //

        if ( SrvCfg_fWinsInitialized )
        {
            while ( pquery = PQ_DequeueTimedOutPacket(
                                g_pWinsQueue,
                                & timeoutWins ) )
            {
                DNS_DEBUG( WINS, (
                    "WINS queue timeout of query at %p\n",
                    pquery ));
                ASSERT( pquery->fWins );
                ASSERT( pquery->fQuestionRecursed );

                if ( !Wins_MakeWinsRequest(
                            pquery,
                            NULL,
                            0,
                            NULL ) )
                {
                    Answer_ContinueNextLookupForQuery( pquery );
                }
            }
        }

        //
        //  Verify \ fix UDP receive
        //

        UDP_RECEIVE_CHECK();

        //
        //  If no more timed out queries -- WAIT
        //
        //  Always wait for 1 second.  This is a typical retry time
        //  for the recursion and WINS queues.
        //
        //  This is simpler than using time to next packet timeout.
        //  And if, traffic is so slow, that we are waking up
        //  unnecessarily, then the wasted cycles aren't an issue anyway.
        //

        err = WaitForSingleObject(
                    hDnsShutdownEvent,  // service shutdown
                    1000 );             // 1 second
    }
}



VOID
FASTCALL
Recurse_Question(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Do recursive lookup on query.

    This is main (re)entry point into recusive lookup.

Arguments:

    pQuery  - query to recurse

    pNode   - node to start recursive search at
        should be closest node in tree to name of query;
        if not given defaults to pQuery->pnodeRecurseRetry which is last zone root
        at which previous recursion is done;
        note that this generally SHOULD be given;  it is only appropriate to restart
        at previous recusion when timed out or otherwise received useless response
        from previous recursive query;  if receive data, even if delegation, then
        need to restart at node closest to question

Return Value:

    None

--*/
{
    PDB_NODE        pnodePrevious = NULL;
    IP_ADDRESS      ipNs;
    DNS_STATUS      status = 0;
    PDB_NODE        pnodeMissingGlue = NULL;
    PDB_NODE        pnewNode;
    BOOL            movedNodeToNotAuthZoneRoot = FALSE;

    ASSERT( pQuery );
    
    IF_DNSLOG( RECURSE )
    {    
        PCHAR       psznode = NULL;

        DNSLOG( RECURSE, (
            "Recursing question from node %s (query %p)\n",
            psznode = Log_FormatNodeName( pNode ),
            pQuery ));
        FREE_HEAP( psznode );
    }

    //
    //  if passed final message timeout -- kill message
    //
    //  need this to slam the door on situation where message is
    //  repeatedly kept alive by responses, but never successfully
    //  completed;  with TCP recursion, it's become even more likely
    //  to run past final timeout and risk referencing nodes that
    //  have been cleaned up by XFR recv
    //

    if ( pQuery->dwQueryTime + SrvCfg_dwRecursionTimeout < DNS_TIME() )
    {
        DNSLOG( RECURSE, (
            "Immediate final timeout of query %p\n",
            pQuery ));
        goto Failed;
    }

    //
    //  find node to start or resume looking for name servers at
    //

    if ( !pNode )
    {
        pNode = pQuery->pnodeRecurseRetry;
        if ( !pNode )
        {
            ASSERT( FALSE );
            goto Failed;
        }
    }

#if 0
    //
    //  in local. domain
    //      - if so, ignore and continue if getting additional data
    //      - no-response (cleanup) if original question
    //
    //  .local check only interesting if cache NODE and NO DELEGATION available
    //

    if ( !pQuery->pnodeDelegation &&
         IS_CACHE_TREE_NODE(pNode) &&
         Dbase_IsNodeInSubtree( pNode, g_pCacheLocalNode ) )
    {
        if ( RECURSING_ORIGINAL_QUESTION(pQuery) )
        {
            DNS_DEBUG( RECURSE, (
                "WARNING:  Query %p for local. domain deleted without answer!\n",
                pQuery ));
            goto Failed;
        }
        else
        {
            DNS_DEBUG( RECURSE, (
                "Skipping local. domain recursion for query %p\n"
                "    Recursion not for question, moving to next lookup\n",
                pQuery ));
            Answer_ContinueNextLookupForQuery( pQuery );
            return;
        }
    }
#endif

    //
    //  Write a referral? Special case for stub zone: always write referral
    //  for iterative queries.
    //

    if ( !pQuery->fRecurseIfNecessary )
    {
        Recurse_WriteReferral( pQuery, pNode );
        return;
    }

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_Question() for query at %p\n",
            pQuery ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        DnsDbg_Unlock();
    }

    STAT_INC( RecurseStats.LookupPasses );

    //
    //  set up for recursion
    //
    //  single label recursion check?
    //      - not doing single label recursion AND
    //      - original question AND
    //      - single label
    //      => quit SERVER_FAILURE
    //      note RecursionSent flag must be FALSE to otherwise will
    //      wait before sending SERVER_FAILURE
    //

    if ( !pQuery->pRecurseMsg )
    {
        if ( !SrvCfg_fRecurseSingleLabel &&
             pQuery->pLooknameQuestion->cLabelCount <= 1 &&
             ! IS_CACHE_UPDATE_QUERY(pQuery) &&
             RECURSING_ORIGINAL_QUESTION(pQuery) &&
             ( pQuery->wQuestionType != DNS_TYPE_NS &&
               pQuery->wQuestionType != DNS_TYPE_SOA ) )
        {
            DNSLOG( RECURSE, (
                "Query fails single label check (%p)\n",
                pQuery ));
            pQuery->fRecurseQuestionSent = FALSE;
            goto Failed;
        }

        if ( !initializeQueryForRecursion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  first time through for current question ?
    //  i.e. NOT repeating previous recursion to new NS
    //      - reset flags
    //      - write new question to recurse message
    //

    if ( !pQuery->fQuestionRecursed )
    {
        if ( !initializeQueryToRecurseNewQuestion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  Activate EDNS since we're recursing the query to another server.
    //

    pQuery->Opt.fInsertOptInOutgoingMsg = ( BOOLEAN ) SrvCfg_dwEnableEDnsProbes;
    if ( pQuery->pRecurseMsg )
    {
        pQuery->pRecurseMsg->Opt.fInsertOptInOutgoingMsg =
            ( BOOLEAN ) SrvCfg_dwEnableEDnsProbes;
    }

    //
    //  Is this a forward zone? If so, forward to next forwarder.
    //  When forwarders have been exhausted, set the retry node to one of:
    //  a) a delegation for the name, if one exists, or
    //  b) the cache root to force recursion to the root servers.
    //

    if ( pQuery->pnodeRecurseRetry
        && pQuery->pnodeRecurseRetry->pZone )
    {
        PZONE_INFO  pZone =
            ( PZONE_INFO ) pQuery->pnodeRecurseRetry->pZone;

        if ( IS_ZONE_FORWARDER( pZone ) &&
            !IS_DONE_FORWARDING( pQuery ) )
        {
            if ( recurseToForwarder(
                    pQuery,
                    pZone->aipMasters,
                    pZone->fForwarderSlave,
                    pZone->dwForwarderTimeout ) )
            {
                return;
            }

            //
            //  The forwarder failed. Search for a non-forwarder node in
            //  the database (probably a delegation). If no node is found
            //  recurse to the root servers.
            //

            pNode = Lookup_NodeForPacket(
                            pQuery,
                            pQuery->MessageBody,
                            LOOKUP_IGNORE_FORWARDER );
            if ( !pNode )
            {
                pNode = pQuery->pnodeDelegation ?
                    pQuery->pnodeDelegation :
                    DATABASE_CACHE_TREE;
            }
            pQuery->pnodeRecurseRetry = pNode;
        }
    }

    //
    //  using server level FORWARDERS ?
    //      - first save node to retry at if exhaust forwarders
    //      - get next forwarders address
    //      - set forwarders timeout
    //      - make recursive query
    //
    //  if we've hit a stub zone, do not recurse to server level forwarders
    //
    //  if query in delegated subzone, only use forwarders if explicitly
    //      set to forward delegations, otherwise directly recurse
    //
    //  if out of forwarders, continue with normal recursion
    //      or if slave, stop
    //

    if ( !( pQuery->pzoneCurrent && IS_ZONE_NOTAUTH( pQuery->pzoneCurrent ) ) &&
         SrvCfg_aipForwarders &&
         ! IS_DONE_FORWARDING( pQuery ) &&
         ( !pQuery->pnodeDelegation || SrvCfg_fForwardDelegations ) )
    {
        pQuery->pnodeRecurseRetry = pNode;
        if ( recurseToForwarder(
                pQuery,
                SrvCfg_aipForwarders,
                SrvCfg_fSlave,
                SrvCfg_dwForwardTimeout ) )
        {
            return;
        }
    }

    //  MUST leave with pRecurseMsg and pVisitedNs set

    ASSERT( pQuery->pNsList && pQuery->pRecurseMsg );

    //
    //  find name server to answer query
    //
    //  start at incoming node, and walk back up through database until
    //      find a zone root with uncontacted servers
    //
    //  DEVNOTE:  incoming node MUST have been accessed in last time interval,
    //      so -- since travelling UP the tree -- no need to explicitly lock?
    //
    //  DEVNOTE: when do NODE locking, then should lock for EACH node in
    //      each time through in loop (or at least where takes out pNsList
    //      then uses it (as this is kept at node)
    //

    //Dbase_LockDatabase();

    ASSERT( IS_NODE_RECENTLY_ACCESSED( pNode ) ||
            pNode == DATABASE_ROOT_NODE ||
            pNode == DATABASE_CACHE_TREE );
    SET_NODE_ACCESSED( pNode );

    while ( 1 )
    {
        //
        //  bail if
        //      - recurse fails at root
        //      - recurse fails at delegation

        if ( pnodePrevious )
        {
            pNode = pnodePrevious->pParent;
            if ( !pNode )
            {
                DNS_DEBUG( RECURSE, (
                    "Stopping recursion for query %p, searched up to root domain\n",
                    pQuery ));
                break;
            }
            if ( IS_AUTH_NODE(pNode) )
            {
                DNS_DEBUG( RECURSE, (
                    "Stopping recursion for query %p\n"
                    "    Failed recurse at delegation %p (l=%s)\n"
                    "    backed into zone %s\n",
                    pQuery,
                    pnodePrevious,
                    pnodePrevious->szLabel,
                    ((PZONE_INFO)pNode->pZone)->pszZoneName ));

                ASSERT( pQuery->pRecurseMsg );
                STAT_INC( RecurseStats.FailureReachAuthority );
                break;
            }
        }

        DNS_DEBUG( RECURSE2, (
            "Recursion at node label %.*s\n",
            pNode->cchLabelLength,
            pNode->szLabel ));

        //
        //  find "covering" zone root node
        //  switching to delegation if available
        //

        pNode = Recurse_CheckForDelegation(
                    pQuery,
                    pNode );
        if ( !pNode )
        {
            ASSERT( FALSE );
            break;
        }

        //
        //  Not-auth zone. If we've ended up at a cache node with fewer labels
        //  than the root of the not-auth zone or if the current node is already
        //  the not-auth zone root, perform special handling as required.
        //
        //  Take a local copy of the zone root in case the zone expires and the
        //  tree node is swapped out. We can still use the tree for this query
        //  but we don't want to pick up the swapped-in NULL tree.
        //
        //  This can only be done once per Recurse_Question call.
        //

        if ( !movedNodeToNotAuthZoneRoot &&
             pQuery->pzoneCurrent &&
             IS_ZONE_NOTAUTH( pQuery->pzoneCurrent ) &&
             ( pNode->pZone == pQuery->pzoneCurrent ||
                IS_CACHE_TREE_NODE( pNode ) ) &&
             pNode->cLabelCount <= pQuery->pzoneCurrent->cZoneNameLabelCount &&
             ( pnewNode = pQuery->pzoneCurrent->pZoneRoot ) != NULL )
        {
            DNS_DEBUG( RECURSE, (
                "not-auth zone: moving current node from cache tree to zone root \"%.*s\"\n",
                pnewNode->cchLabelLength,
                pnewNode->szLabel ));

            pNode = pnewNode;
            movedNodeToNotAuthZoneRoot = TRUE;

            //
            //  Special handling for forward zones: no need to build visit 
            //  list, just send to forwarders. For stub zones we continue 
            //  on to build visit list and recurse to stub masters.
            //

            if ( IS_ZONE_FORWARDER( pQuery->pzoneCurrent ) )
            {
                DNS_DEBUG( LOOKUP, (
                    "Hit forwarding zone %s\n",
                    pQuery->pzoneCurrent->pszZoneName ));

                Recurse_SendToDomainForwarder( pQuery, pNode );
                return;
            }
        }

        pnodePrevious = pNode;

        ASSERT(
            !IS_CACHE_TREE_NODE( pNode ) ||
            pNode->pChildren ||
            IS_NODE_RECENTLY_ACCESSED( pNode ) );
        SET_NODE_ACCESSED(pNode);

        //
        //  Find name servers for this domain.
        //      - get domain resource records
        //      - find NS records
        //      - find corresponding A (address) records
        //
        //  If recursion is not desired, build response of NS and corresponding
        //  address records.
        //
        //  If recursion, launch query to these name server(s), making
        //  original query.
        //

        DNS_DEBUG( RECURSE2, (
            "Recursion up to zone root with label <%.*s>\n",
            pNode->cchLabelLength,
            pNode->szLabel ));

        #if 0
        //
        //  If we are about recurse to Internet root servers, screen 
        //  question name against a list of names we know the Internet root 
        //  servers can't answer.
        //

        if ( !pNode->pParent &&
            IS_CACHE_TREE_NODE( pNode ) &&
            g_fUsingInternetRootServers &&
            SrvCfg_dwRecurseToInetRootMask != 0 )
        {
        }
        #endif

        //
        //  find name servers IPs for this domain
        //      - if none, break out for next level in tree
        //

        status = Remote_BuildVisitListForNewZone(
                    pNode,
                    pQuery );

        switch ( status )
        {
            case ERROR_SUCCESS:

                break;      //  drop down to send recursive query

            case ERROR_NO_DATA:

                DNS_DEBUG( RECURSE, (
                    "No NS-IP data at zone root %p (l=%s) for query %p\n"
                    "    continuing up tree\n",
                    pNode,
                    pNode->szLabel,
                    pQuery ));
                continue;

            case DNSSRV_ERROR_ONLY_ROOT_HINTS:

                DNS_DEBUG( RECURSE, (
                    "Reached root-hint NS recursing query %p, without response\n"
                    "    sending root NS query\n",
                    pQuery ));

                sendRootNsQuery();
                break;      //  drop down to send recursive query

            case DNSSRV_ERROR_ZONE_ALREADY_RESPONDED:

                IF_DNSLOG( RECURSE )
                {
                    PCHAR       psznode = NULL;
                    
                    DNSLOG( RECURSE, (
                        "Query recursed back to domain %s from which an NS has already responded\n",
                        psznode = Log_FormatNodeName( pNode ) ));
                    FREE_HEAP( psznode );
                }

                STAT_INC( RecurseStats.FailureReachPreviousResponse );
                goto Failed;

            default:

                HARD_ASSERT( FALSE );
                goto Failed;
        }

        pQuery->pnodeRecurseRetry = pNode;


        //
        //  if successful building NS list, then send
        //      ERROR_SUCCESS indicates pQuery no longer owned by this
        //          thread (sent, missing glue query, etc.)
        //      ERROR_OUT_OF_IP indicates no more unsent IP
        //          try moving up the tree
        //

        status = sendRecursiveQuery(
                    pQuery,
                    0,              // no specified IP, send from remote list
                    SrvCfg_dwForwardTimeout );
        if ( status == ERROR_SUCCESS )
        {
            return;
        }

        ASSERT( status == DNSSRV_ERROR_OUT_OF_IP );

        //
        //  Continue and move up the tree but ONLY if we have not continued
        //  up the tree for a period of time. We do not want to hammer the
        //  parent domain's NS servers in the case of a lame delegation.
        //
        
        if ( pQuery->dwQueryTime > pNode->dwContinueToParentTtl )
        {
            pNode->dwContinueToParentTtl =
                pQuery->dwQueryTime + SrvCfg_dwLameDelegationTtl;

            DNS_DEBUG( RECURSE, (
                "No unvisited IP addresses at node %s - continuing up tree\n",
                pNode->szLabel ));

            IF_DNSLOG( RECURSE )
            {
                PCHAR       psznode = NULL;
                
                DNSLOG( RECURSE, (
                    "Query recursed to node %s but found no IP addresses so the server\n"
                    LOG_INDENT "will continue up the DNS tree\n",
                    psznode = Log_FormatNodeName( pNode ) ));
                FREE_HEAP( psznode );
            }
            continue;
        }

        DNS_DEBUG( RECURSE, (
            "No unvisited IP addresses at node %s - stopping recursion\n",
            pNode->szLabel ));
            
        IF_DNSLOG( RECURSE )
        {
            PCHAR       psznode = NULL;
            
            DNSLOG( RECURSE, (
                "Query recursed to node %s where a cached lame delegation was detected\n",
                psznode = Log_FormatNodeName( pNode ) ));
            FREE_HEAP( psznode );
        }

        pQuery->fRecurseQuestionSent = FALSE;   //  Force immediate failure.

        break;        
    }

Failed:

    //Dbase_UnlockDatabase();
    STAT_INC( RecurseStats.RecursePassFailure );
    PERF_INC( pcRecursiveQueryFailure );

    recursionServerFailure( pQuery, status );
}



VOID
FASTCALL
Recurse_SendToDomainForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    This function sends a query to a domain forwarding server, and
    sets up the query so additional forwarding servers can be used
    if the first server times out.

Arguments:

    pQuery - query to foward

    pZone - the forwarding zone

Return Value:

    None

--*/
{
    PZONE_INFO      pZone;

    ASSERT( pQuery );
    ASSERT( pZoneRoot );
    ASSERT( pZoneRoot->pZone );

    DNS_DEBUG( RECURSE, (
        "Recurse_SendToDomainForwarder() query=%p\n  pZoneRoot=%p pZone=%p\n",
        pQuery,
        pZoneRoot,
        pZoneRoot ? pZoneRoot->pZone : NULL ));

    if ( !pZoneRoot || !pZoneRoot->pZone )
    {
        goto Failed;
    }

    pZone = ( PZONE_INFO ) pZoneRoot->pZone;

    //
    //  if passed final message timeout -- kill message
    //

    if ( pQuery->dwQueryTime + pZone->dwForwarderTimeout < DNS_TIME() )
    {
        DNS_DEBUG( RECURSE, (
            "Recurse_SendToDomainForwarder() immediate final timeout of query=%p\n",
            pQuery ));
        goto Failed;
    }

    // JJW: Inc stats? (see Recurse_Question)

    if ( !pQuery->pRecurseMsg )
    {
        if ( !initializeQueryForRecursion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  first time through for current question ?
    //  i.e. NOT repeating previous recursion to new NS
    //      - reset flags
    //      - write new question to recurse message
    //

    if ( !pQuery->fQuestionRecursed )
    {
        if ( !initializeQueryToRecurseNewQuestion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  Set the recurse node so if a forwarder times out we can get
    //  back to the current zone to try the next configured forwarder.
    //

    // JJW: which to set?
    pQuery->pnodeRecurseRetry =
        pQuery->pRecurseMsg->pnodeRecurseRetry =
        pZoneRoot;
    
    //
    //  Turn on EDNS in the query
    //

    SET_SEND_OPT( pQuery->pRecurseMsg );

    //
    //  Send to the forwarders for this zone.
    //

    if ( pZone->aipMasters &&
        !IS_DONE_FORWARDING( pQuery ) )
    {
        if ( recurseToForwarder(
                pQuery,
                pZone->aipMasters,
                pZone->fForwarderSlave,
                pZone->dwForwarderTimeout ) )
        {
            return;
        }
    }

Failed:

    // JJW: inc stats? (see Recurse_Question)

    recursionServerFailure( pQuery, 0 );
}



PDB_NODE
Recurse_CheckForDelegation(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Find node for recursion\referral.

    Finds closest of cache ZONE_ROOT node and delegation (if any).
    If cache ZONE_ROOT and delegation at same name, then uses delegation.

Arguments:

    pMsg - query we are writing

    pNode - ptr to node to start looking for referral;  generally
        this would be question node, or closest ancestor of it in database

Return Value:

    Ptr to closest\best zone root node, to use for referral.
    NULL if no data whatsoever -- even for zone root.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pnodeDelegation;

    ASSERT( pMsg );

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_CheckForDelegation() query at %p\n",
            pMsg ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        IF_DEBUG( RECURSE2 )
        {
            Dbg_DbaseNode(
                "Node to start iteration from is ",
                pNode );
        }
        DnsDbg_Unlock();
    }

    //
    //  find closest zone root to node
    //      - if cache node, may zip up to cache root node
    //

    pnode = pNode;
    while ( !IS_ZONE_ROOT(pnode) )
    {
        if ( !pnode->pParent )
        {
            //  see note in rrlist.c RR_ListResetNodeFlags()
            //ASSERT( FALSE );
            SET_ZONE_ROOT( pnode );
            break;
        }
        pnode = pnode->pParent;
    }

    //
    //  if no delegation -- just use cache node
    //

    pnodeDelegation = pMsg->pnodeDelegation;
    if ( !pnodeDelegation )
    {
        DNS_DEBUG( RECURSE, (
            "No delegation recurse\\refer to node %p\n",
            pnode ));
        return pnode;
    }

    //
    //  if node is delegation, use it
    //

    ASSERT( IS_NODE_RECENTLY_ACCESSED( pnodeDelegation ) );

    if ( pNode == pnodeDelegation ||
        pnode == pnodeDelegation ||
        pNode == pMsg->pnodeGlue )
    {
        DNS_DEBUG( RECURSE, (
            "Node %p is delegation, use it\n",
            pnode ));
        return pnode;
    }

    //
    //  find actual delegation
    //      - note:  could fail in transient, when absorb delegation
    //

    ASSERT( IS_SUBZONE_NODE( pnodeDelegation ) );

    while ( IS_GLUE_NODE( pnodeDelegation ) )
    {
        pnodeDelegation = pnodeDelegation->pParent;
    }
    ASSERT( IS_DELEGATION_NODE( pnodeDelegation ) );

    //
    //  if delegation at label count greater (deeper) than cache node -- use it
    //  otherwise use cache node
    //

    if ( pnodeDelegation->cLabelCount >= pnode->cLabelCount )
    {
        DNS_DEBUG( RECURSE, (
            "Delegation node %p (lc=%d) is as deep at cache node %p (lc=%d)\n"
            "    switching to delegation node\n",
            pnodeDelegation, pnodeDelegation->cLabelCount,
            pnode, pnode->cLabelCount ));
        pnode = pnodeDelegation;
    }

    return pnode;
}

//
//  End of recurse.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rescodes.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    rescodes.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for resources from dnssrv.rc

Author:



Revision History:

--*/


#ifndef _RESCODES_INCLUDED
#define _RESCODES_INCLUDED


//
// String Resources defined in dnssrv.rc
//

#define ID_ADMIN_GROUP_DESCRIPTION      0x0000C002
#define ID_PROXY_GROUP_DESCRIPTION      0x0000C004


#endif

//
// end of rescodes.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\recurse.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    recurse.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for recursive query processing.

Author:

    Jim Gilroy (jamesg)     August 1995

Revision History:

--*/


#ifndef _DNS_RECURSE_INCLUDED_
#define _DNS_RECURSE_INCLUDED_


//
//  Visited NS list structure
//
//  Info for tracking "visits" (sends to and responses from) remote
//  NS for recursion.
//

//  Size of list in overlay pointed to by packet ptr.

#define MAX_NS_RECURSION_ATTEMPTS       ( 200 )
#define MAX_PACKET_NS_LIST_COUNT        ( MAX_NS_RECURSION_ATTEMPTS )

//  Actual structure size -- large enough to read all the best stuff in
//      any reasonable configuration.  Can be large as will be temp
//      stack memory used just to build list and prioritize.

#define MAX_NS_LIST_COUNT               ( 200 )


//
//  Remote NS IP visit struct
//
//  The Data union replaces overloaded use of Priority for the
//  missing glue node ptr - this caused problem for Win64.
//

typedef struct _DnsVisitIp
{
    PDB_NODE        pNsNode;
    union
    {
        struct
        {
            DWORD           Priority;
            DWORD           SendTime;
        };
        PDB_NODE        pnodeMissingGlueDelegation;
    } Data;
    DNS_ADDR        IpAddress;
    UCHAR           SendCount;
    UCHAR           Response;
    UCHAR           Reserved2;
    UCHAR           Reserved3;
}
NS_VISIT, *PNS_VISIT;


typedef struct _DnsVisitedNsList
{
    DWORD           Count;
    DWORD           VisitCount;
    DWORD           MaxCount;
    DWORD           ZoneIndex;
    PDB_NODE        pZoneRootCurrent;
    PDB_NODE        pZoneRootResponded;
    PDB_NODE        pNodeMissingGlue;

#if 0
    DWORD           cMissingGlueQueries;
    PDB_NODE        MissingGlueNodes[ MAX_GLUE_CHASING_ATTEMPTS ];
#endif

    NS_VISIT        NsList[ MAX_NS_LIST_COUNT ];
}
NS_VISIT_LIST, *PNS_VISIT_LIST;


//  Overload missing glue delegation on priority field
//  Note:  for Win64 this will also take SendTime field
/*
#define MISSING_GLUE_DELEGATION(pvisit) \
        ( *(PDB_NODE *)(&(pvisit)->Priority) )
*/


//
//  Verify that overlay will work
//
//  NS list currently kept in standard a TCP packet which is assumed to
//  always be at least DNS_TCP_DEFAULT_ALLOC_LENGTH bytes.
//

#if DBG
UCHAR   nslistcheckArray[
            DNS_TCP_DEFAULT_ALLOC_LENGTH
            + sizeof(NS_VISIT) * (MAX_NS_LIST_COUNT - MAX_NS_RECURSION_ATTEMPTS)
            - sizeof(NS_VISIT_LIST) ];
#endif

//
//  Old overlay in additional section no longer in use.
//

//  DEVNOTE:  more space for overlay in recursion packet after
//      max DNS name + question -- the rest of standard message
//      is unused
//
//  DEVNOTE:  at minimum should add compression count space
//      and make sure NoCompressionWrite on when writing question
//
//  Note, that size of NS_VISIT_LIST in packet is NOT the C-defined
//  structure size, as it contains fewer NS entries.
//  The default size is larger in order to accomodate ALL the available
//  NS.  However if there are many only a reasonable number selected
//  on the basis of priority, will actually be contacted.
//

#if 0
#if DBG
UCHAR   nslistcheckArray[
            sizeof(ADDITIONAL_INFO)
            + sizeof(NS_VISIT) * (MAX_NS_LIST_COUNT - MAX_NS_RECURSION_ATTEMPTS)
            - sizeof(NS_VISIT_LIST) ];
#endif
#endif


//
//  Max sends on single recurse pass
//

#define RECURSE_PASS_MAX_SEND_COUNT     (3)



//
//  Recursion query\response timeouts (kept in ms)
//

//  server responds but after query timed out and retried

#define MAX_RESPONDING_PRIORITY     (DEFAULT_RECURSION_RETRY * 1000)

#define MAX_RECURSE_TIME_MS         (MAX_RECURSION_TIMEOUT * 1000)


//
//  Forwarders state tests
//

#define SET_DONE_FORWARDERS( pQuery )   ((pQuery)->nForwarder = (-1))

#define IS_FORWARDING( pQuery )         ((pQuery)->nForwarder > 0)

#define IS_DONE_FORWARDING( pQuery )    ((pQuery)->nForwarder < 0)


//
//  Macroize some useful tests
//

#define RECURSING_ORIGINAL_QUESTION(pQuery)     \
        ( (pQuery)->Head.AnswerCount == 0 && IS_SET_TO_WRITE_ANSWER_RECORDS(pQuery) )


//
//  Values to identify cache update queries
//      - root NS queries
//      - queries for missing glue
//

#define DNS_CACHE_UPDATE_QUERY_SOCKET   (0xfccccccf)
#define DNS_CACHE_UPDATE_QUERY_IP       (0xff000001)
#define DNS_CACHE_UPDATE_QUERY_XID      (1)

#define IS_CACHE_UPDATE_QUERY( pQuery ) \
                    ( (pQuery)->Socket == DNS_CACHE_UPDATE_QUERY_SOCKET )

#define DNS_INFO_VISIT_SERVER (0x4f000001)

#define SUSPENDED_QUERY( pMsg )     ( (PDNS_MSGINFO)(pMsg)->pchRecv )


//
//  Recursion functions (recurse.c)
//

VOID
FASTCALL
Recurse_Question(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNodeClosest
    );

PDB_NODE
Recurse_CheckForDelegation(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode
    );

VOID
FASTCALL
Recurse_WriteReferral(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    );

VOID
Recurse_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

DNS_STATUS
Recurse_MarkNodeNsListDirty(
    IN      PDB_NODE        pNode
    );

DNS_STATUS
Recurse_DeleteNodeNsList(
    IN OUT  PDB_NODE        pNode
    );

BOOL
Recurse_SendCacheUpdateQuery(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeDelegation,
    IN      WORD            wType,
    IN      PDNS_MSGINFO    pQuerySuspended
    );

VOID
Recurse_ResumeSuspendedQuery(
    IN OUT  PDNS_MSGINFO    pUpdateQuery
    );

VOID
Recurse_SendToDomainForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    );


//
//  Global recursion startup and shutdown
//

BOOL
Recurse_InitializeRecursion(
    VOID
    );

VOID
Recurse_CleanupRecursion(
    VOID
    );

//
//  Recursion timeout thread
//

DWORD
Recurse_RecursionTimeoutThread(
    IN      LPVOID Dummy
    );

//
//  Remote DNS server routines (remote.c)
//

BOOL
Remote_ListInitialize(
    VOID
    );

VOID
Remote_ListCleanup(
    VOID
    );

VOID
Remote_NsListCreate(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Remote_NsListCleanup(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Remote_InitNsList(
    IN OUT  PNS_VISIT_LIST  pNsList
    );

DNS_STATUS
Remote_BuildVisitListForNewZone(
    IN      PDB_NODE        pZoneRoot,
    IN OUT  PDNS_MSGINFO    pQuery
    );

DNS_STATUS
Remote_ChooseSendIp(
    IN OUT  PDNS_MSGINFO        pQuery,
    OUT     PDNS_ADDR_ARRAY     IpArray
    );

VOID
Remote_ForceNsListRebuild(
    IN OUT  PDNS_MSGINFO    pQuery
    );

PDB_NODE
Remote_FindZoneRootOfRespondingNs(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDNS_MSGINFO    pResponse
    );

VOID
Remote_SetValidResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    );

VOID
Remote_UpdateResponseTime(
    IN      PDNS_ADDR       pDnsAddr,
    IN      DWORD           ResponseTime,
    IN      DWORD           Timeout
    );

// Constants used by Remote_QuerySupportedEDnsVersion
// and Remote_SetSupportedEDnsVersion:
#define NO_EDNS_SUPPORT                 ((UCHAR)0xff)
#define UNKNOWN_EDNS_VERSION            ((UCHAR)0xfe)
#define IS_VALID_EDNS_VERSION(_ver)     ( _ver >= 0 && _ver < 6 )

UCHAR 
Remote_QuerySupportedEDnsVersion(
    IN      PDNS_ADDR       pDnsAddr
    );

VOID
Remote_SetSupportedEDnsVersion(
    IN      PDNS_ADDR       pDnsAddr,
    IN      UCHAR           EDnsVersion
    );



#endif // _DNS_RECURSE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Domain Name System (DNS) Server

    RPC intialization, shutdown and utility routines.

    Actual RPC callable routines are in the modules for their functional
    area.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include <rpc.h>
#include "dnssrv.h"
#include "rpcdce.h"
#include "secobj.h"
#include "sdutl.h"

#undef UNICODE


//
//  RPC globals
//

BOOL    g_bRpcInitialized = FALSE;

PSECURITY_DESCRIPTOR g_pRpcSecurityDescriptor;



#define AUTO_BIND



DNS_STATUS
Rpc_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server side RPC.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    RPC_STATUS  status;
    BOOL        buseTcpip = FALSE;
    DWORD       len;

    DNS_DEBUG( RPC, (
        "Rpc_Initialize( %p )\n",
        SrvCfg_dwRpcProtocol ));

    //
    //  RPC disabled?
    //

    if ( !SrvCfg_dwRpcProtocol )
    {
        DNS_PRINT(( "RPC disabled -- running without RPC\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  Create security for RPC API
    //

    status = NetpCreateWellKnownSids( NULL );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating well known SIDs\n" ));
        return status;
    }

    status = RpcUtil_CreateSecurityObjects();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating DNS security object\n" ));
        #if !DBG
        return status;   //  DBG - allow to continue
        #endif
    }

    //
    //  build security descriptor
    //
    //  security is
    //      - owner LocalSystem
    //      - read access for Everyone
    //

    g_pRpcSecurityDescriptor = NULL;

    //
    //  RCP over TCP/IP
    //

    if ( SrvCfg_dwRpcProtocol & DNS_RPC_USE_TCPIP )
    {
#ifdef AUTO_BIND

        RPC_BINDING_VECTOR * bindingVector;

        status = RpcServerUseProtseqA(
                        "ncacn_ip_tcp",                     //  protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,     //  max concurrent calls
                        g_pRpcSecurityDescriptor );
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseq() for TCP/IP failed\n"
                "    status = %d 0x%08lx\n",
                status, status ));
            return status;
        }

        status = RpcServerInqBindings( &bindingVector );

        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerInqBindings failed\n"
                "    status = %d 0x%08lx\n",
                status, status ));
            return status;
        }

        //
        //  register interface(s)
        //  since only one DNS server on a host can use
        //      RpcEpRegister() rather than RpcEpRegisterNoReplace()
        //

        status = RpcEpRegisterA(
                    DnsServer_ServerIfHandle,
                    bindingVector,
                    NULL,
                    "" );
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcEpRegisterNoReplace() failed\n"
                "    status = %d %p\n",
                status, status ));
            return status;
        }

        //
        //  free binding vector
        //

        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
        status = RPC_S_OK;

#else  // not AUTO_BIND

        status = RpcServerUseProtseqEpA(
                        "ncacn_ip_tcp",                 //  protocol string
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, //  maximum concurrent calls
                        DNS_RPC_SERVER_PORT_A,          //  endpoint
                        g_pRpcSecurityDescriptor );     //  security
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for TCP/IP failed\n"
                "    status = %d 0x%08lx\n",
                status, status ));
            return status;
        }

#endif // AUTO_BIND

        buseTcpip = TRUE;
    }

    //
    //  RPC over named pipes
    //

    if ( SrvCfg_dwRpcProtocol & DNS_RPC_USE_NAMED_PIPE )
    {
        status = RpcServerUseProtseqEpA(
                        "ncacn_np",                     //  protocol string
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, //  maximum concurrent calls
                        DNS_RPC_NAMED_PIPE_A,           //  endpoint
                        g_pRpcSecurityDescriptor );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for named pipe failed\n"
                "    status = %d 0x%08lx\n",
                status,
                status ));
            return status;
        }
    }

    //
    //  RPC over LPC
    //
    //  Need LPC
    //
    //  1. performance.
    //  2. due to a bug in the security checking when rpc is made from
    //      one local system process to another local system process using
    //      other protocols.
    //

    if ( SrvCfg_dwRpcProtocol & DNS_RPC_USE_LPC )
    {
        status = RpcServerUseProtseqEpA(
                        "ncalrpc",                      //  protocol string
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, //  maximum concurrent calls
                        DNS_RPC_LPC_EP_A,               //  endpoint
                        g_pRpcSecurityDescriptor );     //  security

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for LPC failed\n"
                "    status = %d 0x%08lx\n",
                status, status ));
            return status;
        }
    }

    //
    //  register DNS RPC interface(s)
    //

    status = RpcServerRegisterIf(
                    DnsServer_ServerIfHandle,
                    0,
                    0 );
    if ( status != RPC_S_OK )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  RpcServerRegisterIf() failed\n"
            "    status = %d 0x%08lx\n",
            status, status ));
        return status;
    }

    //
    //  for TCP/IP setup authentication
    //

    if ( buseTcpip )
    {
        PWSTR   pwszprincipleName = NULL;

        status = RpcServerInqDefaultPrincNameW(
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        &pwszprincipleName );
        if ( status == ERROR_SUCCESS )
        {
            status = RpcServerRegisterAuthInfoW(
                        pwszprincipleName,
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        NULL );
        }
        RpcStringFreeW( &pwszprincipleName );
        pwszprincipleName = NULL;

        status = RpcServerInqDefaultPrincNameW(
                        RPC_C_AUTHN_GSS_KERBEROS,
                        &pwszprincipleName );
        if ( status == ERROR_SUCCESS )
        {
            status = RpcServerRegisterAuthInfoW(
                        pwszprincipleName,
                        RPC_C_AUTHN_GSS_KERBEROS,
                        NULL,
                        NULL );
        }
        RpcStringFreeW( &pwszprincipleName );
        pwszprincipleName = NULL;

        status = RpcServerInqDefaultPrincNameW(
                        RPC_C_AUTHN_WINNT,
                        &pwszprincipleName );
        if ( status == ERROR_SUCCESS )
        {
            status = RpcServerRegisterAuthInfoW(
                        pwszprincipleName,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        NULL );
        }
        RpcStringFreeW( &pwszprincipleName );

        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerRegisterAuthInfo() failed\n"
                "    status = %d 0x%08lx\n",
                status, status ));
            return status;
        }
    }

    //
    //  Listen on RPC
    //

    status = RpcServerListen(
                1,                                  //  min threads
                RPC_C_LISTEN_MAX_CALLS_DEFAULT,     //  max concurrent calls
                TRUE );                             //  return on completion

    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcServerListen() failed\n"
            "    status = %d 0x%p\n",
            status, status ));
        return status;
    }

    g_bRpcInitialized = TRUE;
    return status;
}   //  Rpc_Initialize



VOID
Rpc_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown RPC on the server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   status;
    RPC_BINDING_VECTOR * bindingVector = NULL;

    DNS_DEBUG( RPC, ( "Rpc_Shutdown()\n" ));

    if( ! g_bRpcInitialized )
    {
        DNS_DEBUG( RPC, (
            "RPC not active, no shutdown necessary\n" ));
        return;
    }

    //
    //  stop server listen
    //  then wait for all RPC threads to go away
    //

    status = RpcMgmtStopServerListening( NULL );
    if ( status == RPC_S_OK )
    {
        status = RpcMgmtWaitServerListen();
    }

    //
    //  unbind / unregister endpoints
    //

    status = RpcServerInqBindings( &bindingVector );
    ASSERT( status == RPC_S_OK );

    if ( status == RPC_S_OK )
    {
        status = RpcEpUnregister(
                    DnsServer_ServerIfHandle,
                    bindingVector,
                    NULL );               // Uuid vector.
#if DBG
        if ( status != RPC_S_OK )
        {
            DNS_PRINT((
                "ERROR:  RpcEpUnregister, status = %d\n", status ));
        }
#endif
    }

    //
    //  free binding vector
    //

    if ( bindingVector )
    {
        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
    }

    //
    //  wait for all calls to complete
    //

    status = RpcServerUnregisterIf(
                DnsServer_ServerIfHandle,
                0,
                TRUE );
    ASSERT( status == ERROR_SUCCESS );

    g_bRpcInitialized = FALSE;

    DNS_DEBUG( RPC, (
        "RPC shutdown completed\n" ));
}



//
//  RPC allocate and free routines
//

PVOID
MIDL_user_allocate(
    IN      size_t          cBytes
    )
/*++

Routine Description:

    Allocate memory for use in RPC
        - used by server RPC stubs to unpack arguments
        - used by DNS RPC functions to allocate memory to send to client

Arguments:

    cBytes -- count of bytes to allocate

Return Value:

    Ptr to allocated memory, if successful.
    NULL on allocation failure.

--*/
{
    PVOID   pMem;

    pMem = ALLOC_TAGHEAP( cBytes, MEMTAG_RPC );

    DNS_DEBUG( RPC, (
        "RPC allocation of %d bytes at %p\n",
        cBytes,
        pMem ));

    return pMem;
}



PVOID
MIDL_user_allocate_zero(
    IN      size_t          cBytes
    )
/*++

Routine Description:

    Allocate zeroed memory for use in RPC
        - used by DNS RPC functions to allocate memory to send to client

Arguments:

    cBytes -- count of bytes to allocate

Return Value:

    Ptr to allocated memory, if successful.
    NULL on allocation failure.

--*/
{
    PVOID   pMem;

    pMem = MIDL_user_allocate( cBytes );
    if ( !pMem )
    {
        return pMem;
    }

    RtlZeroMemory( pMem, cBytes );

    return pMem;
}



VOID
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Free memory used in RPC
        - used by server RPC stubs to free memory sent back to client
        - used by DNS RPC functions when freeing sub-structures in RPC buffers

Arguments:

    pMem -- memory to free

Return Value:

    None

--*/
{
    DNS_DEBUG( RPC, (
        "Free RPC allocation at %p\n",
        pMem ));

    //  allocation passed to RPC might have had another source

    FREE_TAGHEAP( pMem, 0, 0 );
}



//
//  RPC buffer writing utilities
//
//  These are used to write allocated substructures -- IP arrays and
//  strings -- to RPC buffer.
//


BOOL
RpcUtil_CopyIpArrayToRpcBuffer(
    IN OUT  PIP_ARRAY *         paipRpcIpArray,
    IN      PDNS_ADDR_ARRAY     aipLocalIpArray
    )
/*++

Routine Description:

    Copy local IP Array to RPC buffer.
    
    FIXIPV6: currently this function takes a DNS_ADDR_ARRAY and copies
    it into an IP4-only RPC array.

Arguments:

    paipRpcIpArray -- address in RPC buffer to place IP array;  may or may
        not have existing IP array

    aipLocalIpArray -- local IP array

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *paipRpcIpArray )
    {
        MIDL_user_free( *paipRpcIpArray );
        *paipRpcIpArray = NULL;
    }
    if ( aipLocalIpArray )
    {
        *paipRpcIpArray = DnsAddrArray_CreateIp4Array( aipLocalIpArray );
        if ( !*paipRpcIpArray )
        {
            return FALSE;
        }
    }
    return TRUE;
}



BOOL
RpcUtil_CopyStringToRpcBuffer(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString
    )
/*++

Routine Description:

    Copy local string to RPC buffer. If the output pointer is not NULL
    on entry to this function it is assumed to be an RPC string and is freed.

Arguments:

    ppszRpcString -- pointer to receive address of new RPC string

    pszLocalString -- local string

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *ppszRpcString )
    {
        MIDL_user_free( *ppszRpcString );
        *ppszRpcString = NULL;
    }
    if ( pszLocalString )
    {
        *ppszRpcString = Dns_CreateStringCopy( pszLocalString, 0 );
        if ( ! *ppszRpcString )
        {
            return FALSE;
        }
    }
    return TRUE;
}



BOOL
RpcUtil_CopyStringToRpcBufferEx(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString,
    IN      BOOL            fUnicodeIn,
    IN      BOOL            fUnicodeOut
    )
/*++

Routine Description:

    Copy local string to RPC buffer.

Arguments:

    ppszRpcString -- address in RPC buffer to place string;  may or may
        not have existing string

    pszLocalString -- local string

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *ppszRpcString )
    {
        MIDL_user_free( *ppszRpcString );
        *ppszRpcString = NULL;
    }
    if ( pszLocalString )
    {
        *ppszRpcString = Dns_StringCopyAllocate(
                            pszLocalString,
                            0,
                            fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                            fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8 );
        if ( ! *ppszRpcString )
        {
            return FALSE;
        }
    }
    return TRUE;
}



//
//  Access control for RPC API
//

//
//  Access control globals
//

PSECURITY_DESCRIPTOR    g_GlobalSecurityDescriptor;

GENERIC_MAPPING g_GlobalSecurityInfoMapping =
{
    STANDARD_RIGHTS_READ,       //  generic read access
    STANDARD_RIGHTS_WRITE,      //  generic write
    STANDARD_RIGHTS_EXECUTE,    //  generic execute
    DNS_ALL_ACCESS              //  generic all
};

#define DNS_SERVICE_OBJECT_NAME     TEXT( "DnsServer" )


DNS_STATUS
RpcUtil_CreateSecurityObjects(
    VOID
    )
/*++

Routine Description:

    Add security ACEs to DNS security descriptor.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    NTSTATUS status;

    //
    //  Create ACE data for the DACL.
    //
    //  Note, ordering matters!   When access is checked it is checked
    //  by moving down the list until access is granted or denied.
    //
    //  Admin -- all access
    //  SysOps -- DNS admin access
    //

    ACE_DATA AceData[] =
    {
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid },
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, DNS_ALL_ACCESS, &AliasSystemOpsSid },
    };

    //
    //  Create the security descriptor
    //

    status = NetpCreateSecurityObject(
               AceData,
               sizeof( AceData ) / sizeof( AceData [ 0 ] ),
               LocalSystemSid,
               LocalSystemSid,
               &g_GlobalSecurityInfoMapping,
               &g_GlobalSecurityDescriptor );

    return RtlNtStatusToDosError( status );
}



DNS_STATUS
RpcUtil_ApiAccessCheck(
    IN      ACCESS_MASK     DesiredAccess
    )
/*++

Routine Description:

    Check caller for desired access needed for the calling API.
    NOTE: Skipping test if we're ds integrated. Will use
    Granular access check.

Arguments:

    DesiredAccess - required access to call the API.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if access not allowed.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( RPC, ( "Call: RpcUtil_ApiAccessCheck\n" ));

    status = NetpAccessCheckAndAudit(
                DNS_SERVICE_NAME,                   //  Subsystem name
                DNS_SERVICE_OBJECT_NAME,            //  Object typedef name
                g_GlobalSecurityDescriptor,         //  Security descriptor
                DesiredAccess,                      //  Desired access
                &g_GlobalSecurityInfoMapping );     //  Generic mapping
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "ACCESS DENIED (%lu): RpcUtil_ApiAccessCheck\n",
             status ));
        status = ERROR_ACCESS_DENIED;
    }

#if DBG
    //
    //  DBG: if not running as a service the access check will always fail,
    //  so fake success if the registry key is set.
    //

    if ( status == ERROR_ACCESS_DENIED &&
         !g_RunAsService &&
         !SrvCfg_dwIgnoreRpcAccessFailures )
    {
        DNS_DEBUG( RPC, (
            "RpcUtil_ApiAccessCheck: granting access even though check failed\n",
             status ));
        status = ERROR_SUCCESS;
    }
#endif

    DNS_DEBUG( RPC, (
        "Exit (%lu): RpcUtil_ApiAccessCheck\n",
         status ));

    return status;
}



DNS_STATUS
RpcUtil_CheckAdminPrivilege(
    IN      PZONE_INFO      pZone,
    IN      PDNS_DP_INFO    pDpInfo,
    IN      DWORD           dwPrivilege
    )
/*++

Routine Description:

    Check for that caller has desired privilege.
    Precondition: Post RpcImpersonation!! Getting thread token.

Arguments:

    pZone -- Zone if specific zone action, NULL for server actions

    pszDpFqdn -- FQDN of the directory partition where the action will
        take place (this argument is only used if pZone is NULL)

    dwPrivilege -- desired action (PRIVILEGE_XXX constant from dnsprocs.h)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if access not allowed.
    other NTSTATUS error code if API call failure

--*/
{
    HANDLE                  htoken = NULL;
    BOOL                    bstatus;
    DWORD                   status = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    psecurityDescriptor = NULL;
    // AccessCheck Parameter
    DWORD                   desiredAccess;
    GENERIC_MAPPING         genericMapping;
    PRIVILEGE_SET           privilegeSet;
    DWORD                   privilegeSetLength;
    DWORD                   grantedAccess = 0;

    //
    //  Select a SD to use:
    //      - if zone specified and has SD, use zone SD
    //      - if DP specified and has SD, use DP SD
    //      - else use server SD
    //

    if ( pZone )
    {
        psecurityDescriptor = pZone->pSD;
    }

    if ( !psecurityDescriptor && pDpInfo )
    {
        psecurityDescriptor = pDpInfo->pMsDnsSd;
    }

    if ( !psecurityDescriptor )
    {
        //
        //  Force refresh of MicrosoftDNS ACL from DS.
        //
        
        Ds_ReadServerObjectSD( pServerLdap, &g_pServerObjectSD );
        
        psecurityDescriptor = g_pServerObjectSD;
    }

    DNS_DEBUG( RPC, (
        "CheckAdminPrivilege( zone=%s, priv=%p ) against SD %p\n",
        pZone ? pZone->pszZoneName : "NONE",
        dwPrivilege,
        psecurityDescriptor ));

    #if 0
    Dbg_DumpSD( "CheckAdminPrivilege", psecurityDescriptor );
    #endif

    //
    //  if no SD from DS -- then signal for old security check
    //
    //  DEVNOTE-DCR: 455822 - old/new access?
    //

    if ( !psecurityDescriptor )
    {
        DNS_DEBUG( RPC, (
            "No DS security check -- fail over to old RPC security\n" ));
        return DNSSRV_STATUS_DS_UNAVAILABLE;
    }

    //
    // Second level access check. See if client in DnsAdmins group
    // 1. get thread token (must be an impersonating thread).
    // 2. See if user has RW privilage in the zone or on the server SD
    //

    bstatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_READ,
                    TRUE,
                    &htoken );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "ERROR <%lu>: failed to open thread token!\n",
             status ));
        ASSERT( bstatus );
        goto Failed;
    }

    #if DBG
    {
        PSID        pSid = NULL;

        if ( Dbg_GetUserSidForToken( htoken, &pSid ) )
        {
            DNS_DEBUG( RPC, (
                "CheckAdminPrivilege: impersonating: %S\n",
                Dbg_DumpSid( pSid ) ));
            Dbg_FreeUserSid( &pSid );
        }
        else
        {
            DNS_DEBUG( RPC, (
                "CheckAdminPrivilege: GetUserSidForToken failed\n" ));
        }
    }
    #endif

    //  validate SD

    if ( !IsValidSecurityDescriptor( psecurityDescriptor ) )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "Error <%lu>: Invalid security descriptor\n",
            status));
        ASSERT( !"invalid SD" );
        goto Failed;
    }

    //
    //  access check against SD
    //
    //      - generic mapping that corresponds to DS objects
    //      - support READ or WRITE access levels
    //

    //  generic mapping for DS objects

    genericMapping.GenericRead      = DNS_DS_GENERIC_READ;
    genericMapping.GenericWrite     = DNS_DS_GENERIC_WRITE;
    genericMapping.GenericExecute   = DNS_DS_GENERIC_EXECUTE;
    genericMapping.GenericAll       = DNS_DS_GENERIC_ALL;

    if ( dwPrivilege == PRIVILEGE_READ )
    {
        desiredAccess = GENERIC_READ;
    }
    else
    {
        desiredAccess = GENERIC_READ | GENERIC_WRITE;
    }

    DNS_DEBUG( RPC, (
        "desiredAccess before MapGenericMask() =        0x%08X\n",
        desiredAccess ));

    MapGenericMask( &desiredAccess, &genericMapping );

    DNS_DEBUG( RPC, (
        "desiredAccess after MapGenericMask() =         0x%08X\n",
        desiredAccess ));

    //
    //  do access check
    //

    privilegeSetLength = sizeof( privilegeSet );
    bstatus = AccessCheck(
                    psecurityDescriptor,
                    htoken,
                    desiredAccess,
                    &genericMapping,
                    &privilegeSet,
                    &privilegeSetLength,
                    &grantedAccess,
                    &status );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "Error <%lu>: AccessCheck Failed\n",
            status));
        ASSERT( bstatus );
        goto Failed;
    }

    if ( !status )
    {
        DNS_DEBUG( RPC, (
            "Warning:  Client DENIED by AccessCheck\n"
            "    requested access = %p\n",
            desiredAccess ));
        status = ERROR_ACCESS_DENIED;
        goto Failed;
    }

    DNS_DEBUG( RPC, (
        "RPC Client GRANTED access by AccessCheck\n" ));

    CloseHandle( htoken );

    return ERROR_SUCCESS;

Failed:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_ACCESS_DENIED;
    }
    if ( htoken )
    {
        CloseHandle( htoken );
    }
    return status;
}



DNS_STATUS
RpcUtil_FindZone(
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppZone
    )
/*++

Routine Description:

    Find the zone specified by RPC client.

Arguments:

    pszZoneName -- zone name for zone actions, NULL for server actions.

    dwFlag -- flag for action to control special zones

    ppZone -- resulting zone


Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    PZONE_INFO  pzone = NULL;
    DNS_STATUS  status = DNS_ERROR_ZONE_DOES_NOT_EXIST;

    if ( pszZoneName )
    {
        pzone = Zone_FindZoneByName( ( LPSTR ) pszZoneName );

        if ( pzone )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            if ( _stricmp( pszZoneName, DNS_ZONE_ROOT_HINTS_A ) == 0 )
            {
                if ( dwFlag & RPC_INIT_FIND_ALL_ZONES )
                {
                    pzone = g_pRootHintsZone;
                }
                status = ERROR_SUCCESS;
            }
            else if ( _stricmp( pszZoneName, DNS_ZONE_CACHE_A ) == 0 ||
                      _stricmp( pszZoneName, "." ) == 0 )
            {
                if ( dwFlag & RPC_INIT_FIND_ALL_ZONES )
                {
                    pzone = g_pCacheZone;
                }
                status = ERROR_SUCCESS;
            }
            else if ( Zone_GetFilterForMultiZoneName( ( LPSTR ) pszZoneName ) )
            {
                //
                //  Return NULL zone pointer with ERROR_SUCCESS.
                //
                
                status = ERROR_SUCCESS;
            }
            else
            {
                DNS_DEBUG( RPC, (
                    "ERROR:  zone name %s does not match real or pseudo zones!\n",
                    pszZoneName ));
            }
        }
    }
    else
    {
        //  If no zone name specified, return success and NULL.
        
        status = ERROR_SUCCESS;
    }

    if ( ppZone )
    {
        *ppZone = pzone;
    }

    DNS_DEBUG( RPC, (
        "RpcUtil_FindZone( %s ) returning %d with pZone = %p\n",
        pszZoneName,
        status,
        pzone ));
        
    return status;
}



DNS_STATUS
RpcUtil_SessionSecurityInit(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwPrivilege,
    IN      DWORD           dwFlag,
    OUT     PBOOL           pfImpersonating
    )
/*++

Routine Description:

    RPC security init and check for session.

    Impersonate client and check for that caller has desired privilege.

Arguments:

    pDpInfo -- pointer to directory partition for DP actions or NULL

    pZone -- zone name for zone actions, NULL for server actions

    dwPrivilege -- desired action

    dwFlag -- flag for action to control special zones

    pfImpersonating -- ptr to receive impersonating flag

Return Value:

    ERROR_SUCCESS or error code

--*/
{
    DNS_STATUS  status;
    BOOL        bimpersonating = FALSE;

    DNS_DEBUG( RPC, (
        "RpcUtil_SessionSecurityInit()\n"
        "    zone = %p = %s\n"
        "    privilege = %p\n",
        pZone,
        pZone ? pZone->pszZoneName : NULL,
        dwPrivilege ));

    //
    //  PRIVILEGE_WRITE_IF_FILE_READ_IF_DS means that if this operation 
    //  appears to involve the DS, then we want to access check for READ 
    //  permission only and allow the "real" access checking to be done by 
    //  Active Directory. If this operation does not appear to involve the 
    //  DS then we want to perform access check for WRITE permission.
    //

    if ( dwPrivilege == PRIVILEGE_WRITE_IF_FILE_READ_IF_DS )
    {
        if ( pDpInfo )
        {
            dwPrivilege = PRIVILEGE_READ;
        }
        else if ( pZone )
        {
            dwPrivilege = IS_ZONE_DSINTEGRATED( pZone )
                                ? PRIVILEGE_READ
                                : PRIVILEGE_WRITE;
        }
        else
        {
            dwPrivilege = PRIVILEGE_WRITE;
        }
    }

    //
    //  impersonate -- currently do for all calls
    //
    //  not strictly necessary for calls which don't write to DS and
    //  which use Net API authentication, but better to just always do
    //  this
    //
    //  DEVNOTE: if always impersonate can eliminate bImpersonate flag
    //      and always revert on cleanup
    //

    status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }
    bimpersonating = TRUE;

    //
    //  check with new granular access
    //  if check fails -- still try NT4 administrator-has-access
    //
    //  some issue about whether Admin should OVERRIDE or whether
    //  granular access ought to be able to defeat admin;  i think
    //  the former is fine, we just need to get the story out
    //

    if ( g_pDefaultServerSD )
    {
        //
        //  First check if user has READ permission on the server's
        //  MicrosoftDNS object. Then check more granular ACL.
        //
        
        status = RpcUtil_CheckAdminPrivilege( NULL, NULL, PRIVILEGE_READ );
        if ( status == ERROR_SUCCESS )
        {
            status = RpcUtil_CheckAdminPrivilege(
                        pZone,
                        pDpInfo,
                        dwPrivilege );
        }
        else
        {
            DNS_DEBUG( RPC, (
                "User does not have read permission on this server (error=%lu)\n",
                status ));
        }
    }
    else
    {
        status = RpcUtil_ApiAccessCheck( DNS_ADMIN_ACCESS );
    }


Cleanup:

    //  revert to self on failure

    if ( status != ERROR_SUCCESS && bimpersonating )
    {
        DNS_STATUS  st;
        
        st = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( st == ERROR_SUCCESS )
        {
            bimpersonating = FALSE;
        }
    }

    if ( pfImpersonating )
    {
        *pfImpersonating = bimpersonating;
    }

    DNS_DEBUG( RPC, (
        "RpcUtil_SessionSecurityInit returning %lu\n",
        status ));

    return status;
}



DNS_STATUS
RpcUtil_SessionComplete(
    VOID
    )
/*++

Routine Description:

    Cleanup for ending RPC call.
    Do revert to self, if impersonating.

Arguments:

    None

Return Value:

    None

--*/
{
    return RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
}


DNS_STATUS
RpcUtil_SwitchSecurityContext(
    IN  BOOL    bSwitchToClientContext
    )
/*++

Routine Description:

    Shells on RPC impersonation api's.
    Provides single entry point access to changing rpc impersonation state.

Arguments:

   bSwitchToClientContext -- request to switch to client or server context?

Return Value:

    ERROR_SUCCESS if context switch was successful
    Error code if context switch failed.

--*/
{
    DWORD   status;

    if ( bSwitchToClientContext )
    {
        //
        //  We're currently in server context and would like to impersonate
        //  the RPC client.
        //

        status = RpcImpersonateClient( 0 );
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( RPC, (
                "Error <%lu>: RpcImpersonateClient failed\n", status ));
            ASSERT( status == RPC_S_OK );
        }
        else
        {
            DNS_DEBUG( RPC, (
                "RPC thread now in client context\n", status ));
        }
    }
    else
    {
        //
        //  We're currently impersonating the RPC client and want to
        //  revert to self.
        //

        status = RpcRevertToSelf();
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( ANY, (
                "Error <%lu>: RpcRevertToSelf failed\n", status ));
            ASSERT( status == RPC_S_OK );
        }
        else
        {
            DNS_DEBUG( RPC, (
                "RPC thread now in server context\n", status ));
        }
    }

    return status;
}


//
//  End rpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\remote.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    remote.c

Abstract:

    Domain Name System (DNS) Server

    Remote server tracking.

Author:

    Jim Gilroy (jamesg)     November 29, 1998

Revision History:

--*/


#include "dnssrv.h"

#include <stddef.h>


//
//  Visit NS list
//
//  Zone root node info is overloaded into NS-IP entries of
//  visit list.
//

#define NS_LIST_ZONE_ROOT_PRIORITY          (0)
#define NS_LIST_ZONE_ROOT_SEND_COUNT        (0)

//
//  Special visit list priorities
//
//  New priority set so we try unknown server if lowest is larger than this value.
//  This ensures that we will try local lan servers, and not get pulled into using
//  available but remote server.  Yet it keeps us preferentially going to quickly
//  responding DNS server connected to local LAN.
//

#define NEW_IP_PRIORITY             (50)
#define MAX_FAST_SERVER_PRIORITY    (100)

#define NO_RESPONSE_PRIORITY        (0x7ffffff7)
#define MISSING_GLUE_PRIORITY       (0xffff8888)


//
//  Special visit list "IP" for denoting special entries
//

//  empty "missing-glue" IP

#define IP_MISSING_GLUE             (0xffffffff)

#define DnsAddr_SetMissingGlue( pDnsAddr )                                  \
    DnsAddr_BuildFromIp4( pDnsAddr, IP_MISSING_GLUE, 0 )

#define DnsAddr_IsMissingGlue( pDnsAddr )                                   \
    DnsAddr_MatchesIp4( pDnsAddr, IP_MISSING_GLUE )


//  zone root node entry in list

#define IP_ZONE_ROOT_NODE           (0x7fffffff)

#define DnsAddr_SetZoneRootNode( pDnsAddr )                                 \
    DnsAddr_BuildFromIp4( pDnsAddr, IP_ZONE_ROOT_NODE, 0 )

#define DnsAddr_IsZoneRootNode( pDnsAddr )                                  \
    DnsAddr_MatchesIp4( pDnsAddr, IP_ZONE_ROOT_NODE )


//
//  Max sends to any IP
//

#define RECURSE_IP_SEND_MAX         (2)

//
//  Count of visit IPs for zone
//

#define ZONE_VISIT_NS_COUNT(pvisit) ((UCHAR)(pvisit)->Priority)

//
//  Random seed - no protection necessary
//

ULONG       g_RandomSeed = 0;



//
//  Remote server status tracking.
//
//  Purpose of this module is to allow DNS server to track
//  the status of remote servers in order to choose the best
//  one for recursing a query.
//
//  The definition of "best" basically boils down to responds fastest.
//
//  To some extent the defintion of "best" may be dependent on what
//  data -- what zone -- is being queried for.  But since we deal here
//  with iterative queries to other servers, there should be no delay
//  even when response is not authoritative.
//
//  Specific data sets may be stored at nodes -- example, all the NS\IP
//  available at delegation point -- this module deals only with the
//  global tracking of remote server response.
//
//
//  Implementation:
//
//  1) Independent memory blob for each remote server's data
//  2) Access through hash table with buckets.
//
//
//  EDNS tracking:
//  This module now also tracks the EDNS versions supported by remote
//  servers. This allows us to not continually retry EDNS communication
//  with remotes. However, once per day (by default) we will purge our
//  knowledge of the remote's EDNS support in case it has changed. We
//  do this by keeping track of the last time we set the EDNS version of
//  the server and dumping this knowledge if the time period has elapsed.
// 


//
//  Remote server data
//

typedef struct _RemoteServer
{
    struct _RemoteServer *  pNext;
    DNS_ADDR                DnsAddr;
    DWORD                   LastAccess;
    DWORD                   AverageResponse;
    DWORD                   BestResponse;
    UCHAR                   ResponseCount;
    UCHAR                   TimeoutCount;
    UCHAR                   EDnsVersion;
    DWORD                   LastTimeEDnsVersionSet;
}
REMOTE_SRV, *PREMOTE_SRV;


//
//  Hash table
//

#define REMOTE_ARRAY_SIZE   (256)

PREMOTE_SRV         RemoteHash[ REMOTE_ARRAY_SIZE ];

CRITICAL_SECTION    csRemoteLock;

#define LOCK_REMOTE()      EnterCriticalSection( &csRemoteLock );
#define UNLOCK_REMOTE()    LeaveCriticalSection( &csRemoteLock );



//
//  Private remote functions
//

PREMOTE_SRV
Remote_FindOrCreate(
    IN      PDNS_ADDR       pDnsAddr,
    IN      BOOL            fCreate,
    IN      BOOL            fLocked
    )
/*++

Routine Description:

    Find or create remote blob.

Arguments:

    pDnsAddr -- IP to find

    fCreate   -- TRUE to create if not found

    fLocked   -- TRUE if remote list already locked

Return Value:

    Ptr to remote struct.

--*/
{
    PREMOTE_SRV premote;
    PREMOTE_SRV pback;

    DNS_DEBUG( REMOTE, (
        "Remote_FindOrCreate( %s )\n",
        DNSADDR_STRING( pDnsAddr ) ));

    ASSERT( pDnsAddr );
    
    if ( !fLocked )
    {
        LOCK_REMOTE();
    }

    //
    //  hash on last IP octect (most random)
    //      - note IP in net byte order so low octect is in high memory
    //  FIXIPV6: is this hash moderately balanced?
    //

    pback = ( PREMOTE_SRV ) &RemoteHash[ pDnsAddr->SockaddrIn6.sin6_addr.s6_bytes[ 15 ] ];

    while( premote = pback->pNext )
    {
        int     icompare = memcmp(
                                &premote->DnsAddr.SockaddrIn6,
                                &pDnsAddr->SockaddrIn6,
                                sizeof( pDnsAddr->SockaddrIn6 ) );
        
        if ( icompare < 0 )
        {
            pback = premote;
            continue;
        }
        else if ( icompare == 0 )
        {
            goto Done;
        }

        if ( fCreate )
        {
            break;
        }
        else
        {
            premote = NULL;
            goto Done;
        }
    }

    //
    //  not in list -- allocate and enlist
    //

    premote = ALLOC_TAGHEAP_ZERO( sizeof( REMOTE_SRV ), MEMTAG_REMOTE );
    IF_NOMEM( !premote )
    {
        goto Done;
    }
    DnsAddr_Copy( &premote->DnsAddr, pDnsAddr );

    premote->pNext = pback->pNext;
    pback->pNext = premote;


Done:

    if ( !fLocked )
    {
        UNLOCK_REMOTE();
    }
    return premote;
}



VOID
Remote_UpdateResponseTime(
    IN      PDNS_ADDR       pDnsAddr,
    IN      DWORD           ResponseTime,
    IN      DWORD           Timeout
    )
/*++

Routine Description:

    Update timeoutFind or create remote blob.

    DEVNOTE-DCR: 455666 - use sliding average?

Arguments:

    pDnsAddr -- IP to find

    ResponseTime -- response time (ms)

    Timeout -- if no response, timeout in seconds

Return Value:

    None

--*/
{
    PREMOTE_SRV premote;
    PREMOTE_SRV pback;

    DNS_DEBUG( REMOTE, (
        "Remote_UpdateResponseTime( %s )\n"
        "    resp time = %d\n"
        "    timeout   = %d\n",
        DNSADDR_STRING( pDnsAddr ),
        ResponseTime,
        Timeout ));

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
                    pDnsAddr,
                    TRUE,       //  create
         